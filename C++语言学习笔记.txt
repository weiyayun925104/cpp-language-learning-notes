Jumping into C++
C++程序设计现代方法
第2章 C++基础
2.1 C++简介
如果你按照前面一章的描述搭建好了开发环境，应该已经成功运行了自己的第一个程序。恭喜！这是个良好的开端。
本章，我们来学习C++的基础，让你能够独立编写简单的程序。 下面我将介绍几个你会反复遇到的概念：
程序结构、main函数、标准函数、程序注释，以及如何像程序员一样思考。
2.1.1 最简单的C++程序
让我们从最简单的程序（不实现任何功能）入手，循序渐进地学习。
int main ()  { }
示例代码2：empty.cpp
看，多么简单！
第一行代码：
int main ()
告诉编译器有一个叫main的函数，这个函数返回一个整数（注意：在 C++中，整数简写为int）。
函数是人们编写的一段代码，代码里通常调用其他函数或语言的基础函数。
此例中，函数内部没有任何操作， 不过我们很快就会编写包含某些操作的函数。
main函数比较特殊，它是C++程序中唯一的必须包含的函数。main函数指向程序运行的起始点。
使用时我们需要在main之前指明它的返回值，如int。当一个函数有返回值时，调用该函数的代码能够获取到函数的返回值。
在main函数的例子中，返回值传递给操作系统。
通常这里需要一个明确的返回值，但C++允许main函数省略返回声明，默认返回0（通知操作系统程序运行正常）。
花括号“{”和“}”分别是函数开始和结束的标志（很快我们会看到其他的代码块）。你可以认为它们代表开始和结尾。
此例中函数没做任何事情，因为两个花括号之间没有内容。
当运行这个简单的程序时，你看不到任何输出。因此，让我们往代码里面添加一点有趣的东西（只是一点点）。

#include <iostream>

using namespace std;

int main ()
{
    cout << "HEY, you, I'm alive! Oh, and Hello World!\n";
}
示例代码3：hello.cpp
首先，注意花括号之间有了内容――这意味程序会执行某些操作！让我们按部就班地分析这个程序。
第一行：
#include <iostream>
是一个include语句，它告诉编译器在生成可执行文件前把isotream头文件放到这段程序中。（iostream头文件由编译器提供，以提供输入输出功能。）
使用#include可以将头文件中所有的内容加入到程序中。通过引用头文件，你可以调用编译器提供的众多函数。
我们需要引用包含基础函数的头文件来调用基础函数。iostream头文件包含了需要使用的大部分基础函数，并且几乎所有的程序都以这个头文件开头。
此外，大部分程序都会包含一个或多个这样的引用声明。
紧跟着include语句的是这行：
using namespace std;
这是大部分C++程序都会包含的样板代码，初学时只要把它放在include语句之后、程序的开头即可。
这段代码能让你很方便地调用iostream头文件中例程的缩写。我们之后会详细讲述它的工作方 式，现在只需要记得包含它就可以了。
请注意行末的分号。分号是C++语法的一部分，它告诉编译器语句在这里结束，C++里大部分语句用分号终止。
很多新手会忘记使用分号，因此当程序无法正常编译时请确保没有遗漏分号。当我介绍一个新的概念时，会告诉你是否需要使用分号。
接下来便是main函数，程序从这里开始执行：
int main ()
程序的下一行有一个奇怪的符号<<：
cout << "HEY, you, I'm alive! Oh, and Hello World!\n";
C++使用cout对象（读音为“C out”）输出文本，iostream头文件中包含了cout函数，而这就是我们引用iostream头文件的原因。
<<符号称为“插入运算符”（insertion operator），程序用它来指明输出内容。简言之，cout<< 实现了将文本作为参数传递给函数的函数调用，
函数调用就是运行与函数相关的代码。调用函数时通常需要使用参数，此例中我们提供的字符串便是参数。此例中函数把参数输出到屏幕上。
引号的作用是让编译器输出特殊符号除外的字符串原文。\n符号是特殊符号的一种，它的功能是换行，效果与按下键盘上的回车键一样， 
即将光标移到下一行（稍后对此做详细介绍）。
有时候，你会遇到用特殊值endl作为换行的情况：
cout << "Hello" << endl 和cout << "Hello\n"本质上相同。1
单词"endl"代表"end line"，最后的字母是“L”，不是数字“1”。把 “L”当成“1”写成“end1”是一个常见的错误，要谨慎。――译者注
再次强调一下分号，调用函数时需要在末尾加上它。
最后用一个花括号结束函数，这个程序便可以编译和运行了。你可以直接打开随书附带的源文件进行编译和运行，或者自己敲一遍代码。
 当然，也可以直接复制粘贴，不过建议你自己敲一遍代码，代码并不多，还可以帮你熟悉编译器相关细节，如分号的使用。
当第一个程序跑起来后，为什么不尝试修改cout函数来练习C++编程呢？
试试输出不同的内容或输出多行文本――看看你能让计算机做些什么。
2.1.2 程序无法运行的原因 当你运行本书附带的程序时，可能看不到结果――程序一闪而过然后 关闭。
这种情况的发生取决于使用的操作系统和编译器，如果使用本书推荐的环境就不会遇到这个问题，如果是其他的环境就可能遇到。
你可以在程序结尾增加下述代码解决这个问题。
cin.get();
这行代码会让程序在结束前等待你按键输入一个值，所以可以在窗口关闭前看到程序运行的结果。
2.1.3 C++程序的基本结构
瞧，这么短的程序有这么多的知识点。让我们剥离所有细节，看看 C++程序的基本框架。
[include statements]
using namespace std;  
 
int main()
{
    [你的代码写在这里];
}
如果上面的某一段被删掉会出现什么情况？
如果删掉include语句或者using namespace std，程序将无法编译。
如果程序无法编译，说明其中有些地方编译器无法理解――可能是语法错误（比如少了一个分号）或者头文件丢失。
在刚开始编程时，追踪编译错误会比较困难，任何编译失败都会产生一个或多个编译错误， 这些编译错误会提示错误原因。
下面是一个常见的编译错误。
error: 'cout' was not declared in this scope
如果错误信息中出现以上内容，请确保代码包含了iostream头文件并声明了using namespace std;。
编译错误有时候难以理解。如果删除了分号，可能会得到各种各样的编译错误――通常错误会出现在丢失分号的那行代码的后面，
因此如果看到一大串莫名其妙的错误，请查看上一行是否有分号。随着时间的推移，你会越来越擅长分析编译错误，并且编译错误会越来越少。
因此在刚开始时，遇到一堆编译错误不要觉得很糟糕，这是学会解决错误的必经之路。
2.2 为程序添加注释 在学习编程的同时也应该学习如何为代码添加说明（如果没有其他人 阅读，就为你自己添加）。
这个过程就是给代码添加注释。在接下来 的学习中，我会非常频繁地使用注释帮助解释示例代码。
当你告诉编译器一段文本是注释时，编译器便会忽略这段文本，任何用来描述代码的文本都可以作为注释。
添加注释时可以使用 //，告诉编译器这行剩下的部分是注释，也可以使用/*和*/，它们中间所有被隔断的文本都是注释。
 //这是一行注释
此行代码不是注释 
 
/*这是一个多行注释
此行是注释的一部分
*/ 
某些编译环境会改变注释区域的颜色，表示这段文本不是可执行代码。这也是语法高亮的一个例子。
当学习编程时，通过注释掉（comment out）一部分不想进行编译的 代码来观察输出的改变，是一个非常有用的方法。
例如，如果想观察程序没有cout语句时的现象，就可以把cout语句注释掉。
#include <iostream>

using namespace std;

int main ()
{
    //     cout <<"HEY, you, I'm alive! Oh, and Hello World!\n";
}
示例代码4：hello_comment.cpp
要注意，不要意外注释掉其他有用代码。
如果有效代码被注释掉了，比如注释掉了头文件，程序便可能无法正常编译。
如果编译代码时出现很多错误，你可以尝试注释掉可能不正确的代码，如果注释之后程序能够编译，那么问题就出在这段被注释掉的代码中。

问答题
1 . 程序正确执行后，会返回给操作系统什么值？
A. -1
B. 1
C. 0
D. 程序不返回值

C

2 . 所有C++必须包含的函数是？
A. start()
B. system()
C. main()
D. program()

C

3 .什么符号用在代码段的开始和结尾?
A. { }
B. -> 和 <-
C. BEGIN 和 END
D. ( 和 )

A

4 . 大部分C++程序以什么符号结尾？
A. .
B. ;
C. :
D. '

B

5 . 下面哪个是正确的注释符号?
A. */ Comments */
B. ** Comment **
C. /* Comment */
D. { Comment }

C

6 . 使用cout需要包含哪个头文件?
A. stream
B. 不需要包含，它默认可用
C. iostream
D. using namespace std; 

C

实践题
1 . 编写一个能输出你名字的程序。
2 . 编写一个程序，在屏幕上显示多行文本，每一行显示一个你朋友的名字。
3 . 尝试注释掉我们所编程序中的每一行，观察程序能否编译。这些编译错误代表什么？你能找出程序改变后出现这些变化的原因吗？

#include <iostream>

using namespace std;

int main()
{
    cout << "Your name\n Charlotte\n Nicole\n Willy" << endl;
    cin.get();

    return 0;
}

显示结果如下
Your name
 Charlotte
 Nicole
 Willy

第 3 章 用户交互和变量
到目前为止，你已经学习了如何编写简单的程序来显示输入的信息， 学会了如何为程序添加注释。
这棒极了！但如果想和用户进行交互该怎么办呢？
与用户进行交互，你需要接受外部信息的输入。要做到这一点必须对输入进行存储。
在编程中，将输入的数据以及其他的数据存储在变量中。不同类型的信息（例如数字和字母）存储在不同的变量中；
当声明一个变量时，必须包括数据类型以及变量的名称。
最常见的基本数据类型有char、int和double。
一个char型的变量能存储一个字符，int型的变量能存储整数（不包含小数的数字），double变量可以存储包含小数的数字。
这些变量类型是声明变量时使用的关键词。
3.1 变量
3.1.1 C++中的变量声明
你只有先声明变量，才能使用变量（编译器对提前告之的事情很挑剔）。
使用语法“type <name>;”声明变量。（请再次注意分号！）
下面是声明变量的例子：
int whole_number;
char letter;
double number_with_decimals;
同种类型的变量可以在同一行声明，变量间用逗号隔开。
int a, b, c, d;
我推荐一行只声明一个变量，这样容易阅读。
3.1.2 使用变量
你已经知道了如何让编译器识别变量，那么如何来使用它们呢？
使用cin（读音“C in”）来接受输入，后面跟着反方向的插入操作 符“>>”，之后便是你想让用户输入的变量。
下面是一个演示如何使用变量的简单程序。
#include <iostream>

using namespace std;

int main ()
{
    int thisisanumber;
    cout << "Please enter a number: ";
    cin >> thisisanumber;
    cout << "You entered: " << thisisanumber << "\n";

    return 0;
}
示例代码5：readnum.cpp
让我们逐行分解并测试这个程序。第一部分你已经看过了，所以我们主要分析main函数。
int thisisanumber;
这行声明thisisanumber为整型。接下来一行是：
cin >> thisisanumber;
函数cin >> 把用户输入的值用thisisanumber存储起来。用户输入之后必须按确定键，程序才会读取数据。
3.1.3 程序闪退的处理方法
如果你之前使用cin.get()来阻止程序闪退，即使使用cin.get()上面的程序在运行时可能依然会闪退。你可以在cin.get();前增加cin.ignore();来解决这个问题。
cin.ignore()函数会读取并丢弃一个字符，此例中将读取并丢掉用户按下的回车键。
当用户向程序输入字符时，回车键也被接收，但我们并不需要，所以应当丢弃。只有当你使用cin.get()让程序等待用户输入时才会用到这个函数，
若没有这行，cin.get()会读取换行符，程序依然会闪退。
记住当变量被声明为整数时，若用户输入小数，小数部分将会被截断 （数字的小数部分将会被忽略，比如3.1415会变成3）。
运行示例程序时，请试着输入小数或字符串。不同的输入会有不同的反应，无论你输入什么它都能够正常响应。正常的程序需要进行错误处理，不过 目前我们不需要关心这些。
cout << "You entered: " << thisisanumber << "\n";
这行代码用于输出用户的输入。注意变量没有引号。如果用引号把thisisanumber引起来，程序将会输出“You Entered: thisisanumber”。
没有引号时编译器会把thisisanumber识别成变量， 程序会检查变量的值，将变量名替换成该变量的赋值然后将结果输出。
顺便提一句，不要被一行中有两个插入操作符弄晕了，一行中包含多 个插入操作符是完全可行的，并且所有的输出都会被输出在同一个地 方。
你必须用插入操作符（<<）将字符串常量和变量分开，用一个<< 同时输出字符串常量和变量会出错：
错误代码
cout << "You entered: " thisisanumber;
像调用其他函数一样，行末是一个分号。如果忘记分号，编译时会出现编译错误。
3.1.4 修改，使用和比较变量
读入和输出变量很快会让人觉得没意思。接下来让我们修改变量，让程序根据变量的不同赋值给予不同的回应。
很快，我们就可以以不同的方式回应用户的不同输入。
你可以使用赋值操作符=将值传递给变量。
int x;  
 
x = 5;
设置x等于5。你可能会认为等号会对左右两边的值进行比较，但这里等号不是比较。
在C++中，用来判断等式的是由两个等号组成的的操作符==。==经常用在if语句或循环语句中。
接下来的几章里，我们会学习如何根据用户的不同输入采取不同的计算，过程中会用到大量的比较操作。
a == 5 // 不是把5赋值给a，而是检查a是否等于5
你也可以对变量执行算术运算。
* 两个值相乘
- 两个值相减
+ 两个值相加
/ 一个值除以另一个值
下面是几个示例：
a = 4 * 6; // （注意分号和注释的使用）a等于24
a = a + 5; // a等于a的初始值加5
3.1.5 加减1的简写
变量加1在C++中非常常见：
int x = 0;
x = x + 1;
当我们处理像循环那样的操作时，会大量使用这种模式。它的使用非常普遍以至于有一个单独的++操作符，只对变量加1。
上面的代码可以写成：
int x = 0;
x++;
x的结果是1。++操作符通常称为递增操作符，变量加一通常称为变量递增。
操作符--的工作原理相同，不过它使变量减1。--操作符通常称为递减操作符，变量减1称为变量递减。
知道了这一点，你可以猜一下C++的名称是怎么来的？C++基于C语 言，字面意思是“C加1”。
C++不是一个全新的语言，而是经过补充后的C。我想如果C++的创造者们知道C++其实比C强大那么多，他们可能会把它命名为C平方。
变量赋值使用相似的快捷操作符:
x += 5; // x加5
同样适用减、乘和除运算：
x -= 5; // x减5
x *= 5; // x乘5  x /= 5; // x除以5
最后，++和--不但可以用在变量后，还可以用在变量前：
--x;
++y;
两者的区别是表达式返回的值不同。如果这么写：
int x = 0;
cout << x++;
输出是0。尽管x修改了，但是表达式x++返回的是x的初始值。因为++在变量的后面，你可以认为变量在被输出后才获取到新值。
如果你把操作符放到变量的前面，就能立即得到新值：
int x = 0;
cout << ++x;
表达式首先对x加1，接着获取x的值，这样便会输出1。借助这些操作，你可以用C++编写一个小型的计算器了。
#include <iostream>
using namespace std;
int main()
{
    int first_argument;
    int second_argument;
    cout << "Enter first argument: ";
    cin >> first_argument;
    cout << "Enter second argument: ";
    cin >> second_argument;
    cout << first_argument << " * " << second_argument << " = " << first_argument * second_argument << endl;
    cout << first_argument << " + " << second_argument << " = " << first_argument + second_argument << endl;
    cout << first_argument << " / " << second_argument << " = " << first_argument / second_argument << endl;
    cout << first_argument << " - " << second_argument << " = " << first_argument - second_argument << endl;
}
示例代码6：calculator.cpp
显示结果如下
Enter first argument: 66
Enter second argument: 33
66 * 33 = 2178
66 + 33 = 99
66 / 33 = 2
66 - 33 = 33

3.2 变量的使用和滥用
3.2.1 C++中声明变量的常见错误
声明变量后可以让程序执行很多操作，但一个错误的变量声明会导致一些初始化错误。
例如，如果你想使用一个没有声明的变量，编译会失败，出现变量未声明的编译错误。编译器通常会提示如下的错误：
error: 'x' was not declared in this scope
如果使用未声明的变量（例子中的x），报错信息取决于你正使用的编译器。示例中的错误信息由MinGW和Code::Blocks产生。
同一个类型可以声明多个变量，但多个变量不能为同一个名称。
例如，你不能同时用double和int声明my_val。声明两个不同的变量使用同一个名称则会出现类似以下的错误信息：
error: conflicting declaration 'double my_val'
error: 'my_val' has a previous declaration as'int my_val'
error: declaration of'double my_val'
error: conflicts with previous declaration 'int my_val'
第三个经常出错的地方是行末忘记加分号：
错误代码
int x
这种错误会导致编译器产生不同的错误信息，错误信息内容取决于变量声明后面的代码。一般来说，编译错误会从变量声明的下一行开始。
最后，还有些错误会发生在运行时，比如你在声明一个变量时变量未初始化。那么你必须在使用前进行初始化。
初始化变量就是在使用前对变量进行赋值。若没有初始化，程序运行结果便会不确定。下面是一个常见的问题程序：
int x;
int y;  
y = 5;
x = x + y;
y在使用前被赋值成5，但是x的初始值却是未知的。程序运行时会随机对x进行赋值，因此它可能是任何值！
不要想当然的认为变量会被初始化成0之类的。
有一个技巧可以避免上述问题，就是在声明变量时直接赋值。
int x = 0;
这个技巧可以确保变量在创建时便有明确的值。养成这个习惯会让你在以后的编程中减少一些纠结的bug和打字次数。
3.2.2 区分大小写
现在可以讨论另一个容易让你困惑的重要概念了――区分大小写。 
C++区分字符大小写，Cat和cat对编译器来说是两个不同的东西。在 C++中，所有的关键词、函数和变量都区分大小写。
变量在声明和使用时大小写不同（如声明时用X但是使用时用x）会导致出现变量未声明的错误，即使你认为已经声明过了。
3.2.3 变量命名
选择有意义、描述性的变量名是非常重要的。下面是一个反面案例：
val1 = val2 * val3;
这是什么意思？无人可解。等式中的名字几乎没有任何意义。
编程当天你会觉得自己写的代码含义很明显，第二天就会感觉完全不可理解了。
描述性命名会让你在下次阅读代码时不会糊涂。
例如：
area = width * height;
就比第一个等式清晰明了，而且结构等式不变，仅仅修改了第一个等式的变量名。
3.3 字符串存储
你可能已经注意到，目前所有的数据类型只允许处理简单的值，比如一个整数或字符。
事实上用这些基础数据就可以处理很多的事情，但C++还提供了其他的数据类型。
事实上C++还可以让你自定义数据类型，不过等我们讲结构的时候再讲这些。
一个最常用的数据类型是string。string可以存储多个字符。你已经见过将字符串输出到屏幕上了。
cout << "HEY, you, I'm alive! Oh, and Hello World!\n";
C++string类允许你对字符串进行保存，修改等操作。
声明字符串也非常容易：
#include <string>

using namespace std;

int main ()
{
    string my_string;
}
示例代码7：string.cpp
不像你使用其他内置类型，使用字符串时必须使用<string>头文件。 
因为编译器没有内置string类型，不像整型那样内置在编译器中。字符串类型由C++标准库（一个大型可复用的代码库）提供。
像C++提供的其他基本类型一样，你可以直接使用cin读入用户输入的字符串。
#include <iostream>
#include <string>

using namespace std;

int main ()
{
    string user_name;

    cout << "Please enter your name: ";
    cin >> user_name;
    cout << "Hi " << user_name << "\n";
}
示例代码8： string_name.cpp
显示结果如下
Please enter your name: Hello,world!
Hi Hello,world!

程序创建一个字符串变量，提示用户输入他或者她的名字，然后进行输出。
像其他的变量一样，字符串可以进行初始化。
string user_name = "<unknown>";
如果你想把两个字符串合并，可以用“+”把一个字符串追加到另一个字符串上。
#include <iostream>
#include <string>
using namespace std;
int main ()
{
    string user_first_name;
    string user_last_name;
    cout << "Please enter your first name: ";
    cin >> user_first_name;
    cout << "Please enter your last name: ";
    cin >> user_last_name;
    string user_full_name = user_first_name + " " + user_last_name;
    cout << "Your name is: " << user_full_name << "\n";
}
示例代码9：string_append.cpp
显示结果如下
Please enter your first name: Hello
Please enter your last name: World
Your name is: Hello World

这段程序把用户的姓、空格、用户的名这三个单独的字符串合并成一个字符串。
术语提示：有时候你会看到用单词concatenate 表示两个字符串连接到一起。
Concatenate来自拉丁语的“to chain together”，catena在拉丁语中表示链接。
如果你想一次读取一整行字符串，可以使用一个特殊的函数getline， 它被用来读取整行数据。
这个函数甚至可以帮你自动丢弃末尾的换行符。
使用getline，你需要传入输入源（本例中是cin）、读入字符串和终止字符三个参数。例如，下面代码可以读取用户的名：
getline(cin, user_first_name, '\n');
getline也可以用来读取某个字符之前的输入。比如逗号之前（尽管程序还是要用户按回车键之后才能接受数据）：
getline(cin, my_string, ',');
如果用户输入：
Hello, World
my_string会赋值为“Hello”，本例中剩下的文本“World”将会被驻留在输入缓存中，直到另一个输入声明读取它。
3.4 基本类型的存储解析
注意：这部分内容是高级知识，你目前还不需要使用。如果对这部分内容比较迷糊，请先跳过，回头再看。
此时，您可能想知道为什么我们会有如此多不同类型的基本变量。
让我们花点时间学习一下所有计算程序的两个基本构建块：位（bit） 和字节（byte）。
位是计算机存储的基本单元，一个位就是一个开 关，根据开关的设定，表示1或0。
1字节由8个位构成，相当于有8个位置，每个位置都可以代表两个值，那么一共就有256种0和1的组合 方式。
让我们分解一下。一个位可以存储0或1两个值，两个位能存储 一个位的两倍：00、01、10和11。
三个位是两个位的两倍，在两位的组合上又添加了一个0或1。所以每多一个位就能让代表的值数量翻倍。
换而言之，对于n个位，我们可以表示2的n次方个值。1字节是8个位，所以它有2的8次方=256种组合。
如果有2字节，那么就是16个位，可以代表 2的16次方（65536） 个值。
看不懂上面的内容不要紧，主要思想是字节越多，能存储的东西就越多。
例如，char是单字节，一个char只能存储256种不同的数据。而一个整型通常占用4字节，也就是说它能够表示大约40亿的数据。
有一个很好的例子，double和float的不同点仅仅在于double占用的空间是float的两倍。
float是存储小数的原始变量类型， float的命名事实上也是来源于小数点可以“浮”在数字的不同位置。
换言之，你可以有4个小数2个整数（12.2345），或者4个整数2个小数（3421.12）。 小数点前和小数点后的数字都没有限制。
如果你一下无法接受这些，不要紧，它们都是历史了。只要知道浮点数就代表着“带有小数点的数”。
float只有4字节，而double有8字节， 所以float比double存储的少。以前的电脑内存很少，4字节是一个很大的数，程序员会竭尽全力节省空间。
但现在，多使用double会更好一些。不过当程序可用内存较小时（如手机中的小内存），你仍然需要选择使用float。
char是最小的数据类型，它只有1字节。你可能会想，既然空间大小无所谓，为什么还需要char呢。
因为char有特殊的意义――输入输出都用字符而不是数字。用户可以向char变量输入字符，而且在输出字符时，
你会更希望直接显示存储在变量里的数字代表的字符，而不是显示这些数字。你可能会疑惑“这是什么意思？
为什么字符会是数字呢”，原因在于计算机用数字的形式存储我们看到的字符（如字母'a'）。
有一个数字和字符之间的映射表，称为ASCII表。ASCII表用来查找每个数字代表什么字符。
当程序要输出字符而不是数字时，程 序会先从ASCII表中查询该数字对应的字符3。
我不得不提示一下ASCII表非常的小，它只有256个值。也就是说它不适合像日语或汉语这种超过256个字符的语言。
处理这些语言采用Unicode编码。这超出了本书的范围。你可以在下面的网址了解相关信息：
（http://www.cprogramming.com/tutorial/unicode.html）。
1. 浮点数的缺陷
我想让你了解一些关于浮点数的东西。能使用float或double听起来是很不错，因为它们能表示的值范围很大。
浮点数用一种类似科学计算法的格式计算出一个范围，它只能表达范围内的数。
在科学计数法中，你用x * 10的y次方来表示数字。x通常存储数的前几位，而指数y，则用来提高数的数量级。
指数越大，电脑能存储的数也就越大。但是非指数部分没办法存储那么多个数字，它只能存储15个，所以只能使用15位精度的浮点数。
当处理比较小的数时，真实数值和电脑存储的数误差非常小。而当处理大数时，虽然相对误差小，但绝对误差会非常大。
大多数情况下，浮点数不精确不会影响你。但如果正在处理严谨的数值运算或科学计算，这便会关系重大。
2. 整数的缺陷
整数也有缺陷。事实上，整数和浮点数一点都不兼容。不像浮点数， 整数会准确存储你输入的值。
但它不会接受小数点。当两个整数进行除法运算时，结果会是整数。它会被截断，非小数部分保留，剩下的丢弃。
举个例子，如果你在数学考试中回答5/2 = 2 ，那肯定考试不及格。但计算机确是一直这么运算的！
你需要使用非整型的数据类型来获得带有小数点的答案。
程序默认输入的数字为整型，这也就是为什么5/2会被计算成2。不过，如果数字中包含小数点，比如5.0/2.0，编译器就会按照浮点数进行计算，
然后返回你期望的结果：2.5。 
问答题
１ . 什么类型可以存储数值3.1415?
A. int
B. char
C. double
D. string

C

2 . 下面哪个是比较两个变量的操作符?
A. :=
B. =
C. equal
D. ==

D

3 . 如何获取string数据类型?
A. 语言中包含，无需任何操作
B. 因为字符串用在输入输出上, 你需要引用iostream头文件
C. 引用string头文件
D. C++不支持

C

4 . 下面哪个变量类型不正确?
A. double
B. real
C. int
D. char

B

5 . 怎么读取用户的一整行输入?
A. 使用 cin >>
B.使用 readline
C. 使用 getline
D. 很困难

C

6 . C++中，cout << 1234/2000 会输出什么结果?
A. 0
B.0.617
C. 大约 .617, 不过结果不能精确的存储在浮点数中。
D. 要看等式两边的类型

A

7 . 为什么C++在有整数类型的情况下还需要char类型?
A. 因为字符和整数是两种完全不同的类型，一个是数字，一个是字母
B. 为了向下兼容C
C. 字符比数字更加容易读入和输出，尽管字符实际上存储为数字
D. 对国际支持，处理像汉语和日语这种包含很多字符的语言。

C

实践题
1 . 编写程序输出你的名字。
2 . 编写程序读取两个数字并相加。
3 . 编写程序，读取用户输入的两个数字进行相除，获取准确的结果。 确保整数和小数都能正确计算。

#include <iostream>
#include <string>

using namespace std;

int main()
{
	string name;
	cout << "Please enter your name: " << endl;
	getline(cin, name, '\n'); 
	cout << "Your name is: " << name << "\n";

	double number1 = 0;
	double number2 = 0;
	cout << "Please enter two numbers to add together. \nFirst Number : ";
	cin >> number1;
	cout << "Second Number : ";
	cin >> number2;

	double result = number1 + number2;
	cout << "The result is:\n" << number1 << " + " << number2 << " = " << result << "\n";

	cout << "Please enter two numbers to divide together. \nNumerator : ";
	cin >> number1;
	cout << "Denominator : ";
	cin >> number2;
	result = number1 / number2;
	cout << "The result is:\n" << number1 << " / " << number2 << " = " << result << endl;
}
显示结果如下
Please enter your name:
Hello World
Your name is: Hello World
Please enter two numbers to add together.
First Number : 6
Second Number : 5
The result is:
6 + 5 = 11
Please enter two numbers to divide together.
Numerator : 6
Denominator : 5
The result is:
6 / 5 = 1.2

第 4 章 if语句
目前你已经学会了编写按顺序执行的程序，程序还无法根据用户的不同输入采取不同的操作。
if语句可以控制程序根据给定条件的是 （true）或非（false），来判断是否执行某段代码。
换而言之，if语句允许程序根据用户的输入选择不同的操作。例如，程序可以通过if语句判断用户输入的密码是否正确，
从而决定用户能否访问程序。
4.1 if的基础语法
if语句的结构非常简单：
if ( <表达式的值为true> ) 
执行这个语句 
或：
if ( <表达式的值为true> ) 
 {
  执行花括号内的所有语句  
}
紧跟着if语句（将被选择性执行）的代码称为if语句的函数体（就 像main函数里的代码称为main函数的函数体）。
下面是if语法的一个简单示例：
if ( 5 < 10 )
    cout << "Five is now less than ten, that's a big surpise";
这里，我们需要判断语句“5小于10”是否正确。当然结果肯定是正确的。
你可以引用iostream头文件，编写一个完整的程序，把上面的代码放到main函数中运行一下，看看结果如何。
下面是一个用花括号包含多行语句的示例程序：
if ( 5 < 10 )
{
    cout << "Five is now less than ten, that's a big surprise\n";
    cout << "I hope this computer is working correctly.\n";
}
如果if语句后有多行代码，请用花括号将它们括起来，确保当且仅当if语句判断为真时，花括号里的所有代码都能执行。
我推荐你在编写if语句函数体时使用花括号。这么做可以确保所有应当执行的语句都被包含。
同时也会让if语句的函数体更清晰易读。在if函数体中不使用花括号包含第二个if语句是常见的错误，这会导致第二个if语句一直被执行。
if ( 5 < 10 )
    cout << "Five is now less than ten, that's a big surprise\n";
    cout << "I hope this computer is working correctly.\n";
代码缩进让人很难发现这类错误。相比之下，习惯把语句放在花括号内会安全很多。
目前为止，我描述的if语句语法比较枯燥，接下来让我们看看处理用户输入的实际的if语句。
#include <iostream>
using namespace std;
int main ()
{
    int x;
    cout << "Enter a number: ";
    cin >> x;
    if ( x < 10 )
    {
        cout << "You entered a value less than 10" << '\n';
    }
}
示例代码10：variable.cpp
显示结果如下
Enter a number: 9
You entered a value less than 10

Enter a number: 33

这个程序和之前的示例程序不同，它比较的值来自用户输入，而不是像之前的程序把值固定在程序里。这很令人兴奋！
程序第一次可以根据用户输入执行完全不同的操作。现在，让我们看看if语句的灵活性。 
4.2 表达式
if语句是一个简单的表达式。表达式是单个或多个相联的计算单个值的语句。
大部分能读取变量或常量（如数字）的语句都能读取表达式。事实上，变量和常量也是表达式――简单的表达式。
加法操作、 乘法操作是稍微复杂一点的表达式。当用在比较上时，表达式会返回true或者false。
4.2.1 truth
对编译器来说，表达式返回非零的数便是true，返回零就是false。比如语句：
if ( 1 )
能让if语句函数体里的所有代码都被执行。但是语句：
if ( 0 )
便会使函数体里的所有代码都不被执行。
C++有两个特殊的关键字――true和false，你可以将它们直接写在代码中。当按整型输出时true输出1，false输出0。
当你用关系操作符执行比较时，操作符也将返回true或false。
例如0 == 2的计算结果为false，2 == 2的计算结果是true。
（注意，判断相等时使用两个等号==，使用一个等号是对变量赋值。）
将关系操作符用在if语句中时，关系表达式的结果可以直接对应到true或者false无需再进行检查：
if ( x == 2 )
等同于：
if ( ( x == 2 ) == true )
第一种更易读。
编程时，我们时常需要比较两个变量值之间的大小关系。
下面这个表列出了用于两个值之间比较的关系操作符。
> 大于 5>4是true
< 小于 4<5是true
>= 大于等于 4>=4是true
<= 小于等于 3<=3是true
== 等于 5==5是true
!= 不等于 5!=4是true
4.2.2 布尔型
C++用一个特殊的类型bool存储比较的结果。bool类型和整型没有什么不同，但它非常的清晰明了，
因为它只有两种值――true 和false，这是它的优点。这些关键字和bool变量能让你的思路更清晰。
注意，所有比较操作的返回值都是布尔值。
２bool以George Boole命名。布尔逻辑是设计数字计算机的基础， 用true和false两种值表示的一种逻辑运算。
George Boole是设计布尔逻辑的数学家。
int x;
cin >> x;
bool is_x_two = x == 2; // 注意，双等号表示比较

if ( is_x_two )
{
    //如果x等于2，所以程序会执行到这里!
}
4.3 else语句
很多时候，你想让程序在执行操作前先进行一个简单的判断，如果判断为true（比如用户输入的密码是正确的），执行一种操作，
如果判断为false（比如用户输入的密码是错误的），执行另一种操作。
else语句允许你执行if-else比较。如果if语句里的条件为false，else之后代码便会执行（可能是一行，也可能是花括号内的多行）。
下面的示例程序将判断用户输入的数是负数还是正数。
#include <iostream>

using namespace std;

int main()
{
    int num;
    cout << "Enter a number: ";
    cin >> num;
    if ( num < 0 )
    {
        cout << "You entered a negative number\n";
    }
    else
    {
        cout << "You entered a non-negative number\n";
    }
}
示例代码11：non_negative.cpp
显示结果如下
Enter a number: 3
You entered a non-negative number

Enter a number: -3
You entered a negative number

4.4 else-if
else的另一类用法是当有多个条件语句同时为true时，你只想执行其中某一个条件语句。
例如，你可能想让上面的示例代码检测三种不同的情况：负数、零和正数。
你可以在if语句和它的函数体后使用else-if语句。在这种方式下，
如果第一个语句为true，后面的else-if将会被忽略，如果if语句为false，程序便会判断else-if语句的条件，
如果该条件为true，后面的else语句也不会执行。编程中可以使用一系列else-if语句确保只有一个代码块执行。
下面让我们修改上面的代码，使用一个else-if来判断零值：
#include <iostream>

using namespace std;

int main()
{
    int num;
    cout << "Enter a number: ";
    cin >> num;
    if ( num < 0 )
    {
        cout << "You entered a negative number\n";
    }
    else if ( num == 0 )
    {
        cout << "You entered zero\n";
    }
    else
    {
        cout << "You entered a positive number\n";
    }
}
示例代码12：else_if.cpp
显示结果如下
Enter a number: 3
You entered a positive number

Enter a number: 0
You entered zero

Enter a number: -3
You entered a negative number

4.5 字符串比较
C++中的string类允许你使用之前几章学习的所有用于比较的方法。 利用string类的比较，我们可以编写下面的代码检查程序。
#include <iostream>
#include <string>

using namespace std;

int main ()
{
    string password;
    cout << "Enter your password: " << "\n";
    getline( cin, password, '\n' );
    if ( password == "xyzzy" )
    {
        cout << "Access allowed" << "\n";
    }
    else
    {
        cout << "Bad password. Denied access!" << "\n";
        return 0;
    }
}
示例程序13：password.cpp
显示结果如下
Enter your password:
xyzzy
Access allowed

Enter your password:
Hello
Bad password. Denied access!

程序读取用户的输入，和密码xyzzy进行对比。如果输入的内容和密码不同，程序便会立即从main函数返回。
当然，真正的密码检查程序不会这么简单，首先，你不会把密码直接放进源代码里。
你也可以使用其他的比较操作，比如按照字母序比较两个字符串大小，或使用 != 判断两个字符串不相同。
4.6 逻辑运算符在条件语句上的有趣应用
目前，我们一次只能判断一个条件。如果想同时执行两次判断，比如判断用户名和密码都正确，你就不得不写很多if-else语句。
幸运的是，C++包含逻辑运算符，它提供了同时执行多个判断的功能（名字和之前的bool型有关，逻辑运算符作用于布尔值）。
你可以使用逻辑运算符编写更复杂的判断语句。例如，如果想判断一个名为age的变量值是否大于5且小于10，
你可以使用逻辑与 （Boolean AND）确保age>5和age<10都为true。
逻辑操作符和比较操作符一样，根据表达式的结果返回true或者false。
4.6.1 逻辑非
逻辑非（Boolean NOT）只有一个输入，如果输入为true，那么返回false，输入为false，则返回true。
例如，是（true）计算结果 为false，非（false）计算结果为true。零之外的任何数字的非值都为false。
C++中非的符号是!（没错，就是感叹号）。
例如：
if ( ! 0 )
{
    cout << "! 0 evaluates to true";
}
4.6.2 逻辑与
如果两个输入值都为true，那么逻辑与返回true（即“第一个值”与“第 二个值”都为true）。
true与false结果为false，因为其中一个输入值为false（两个值都是true结果才是true）。任意非零数字与false进行逻辑与返回值为false。
C++中与的操作符是&&，不要认为它用来判断两个数是否相等。它只用来判断两个参数是否都为true。
if ( 1 && 2 )
{
    cout << "Both 1 and 2 evaluate to true";
}
短路求值
如果第一个表达式是布尔型且返回false，那么第二个表达式将不会被计算。这就是短路求值。
短路运算很有用，你可以写出当且仅当第一个条件为true时才判断第二个条件的表达式。
例如下面的if语句中，使用短路预算可以在判断10除以x小于2时避免除以零。
if ( x != 0 && 10 / x < 2 )
{
    cout << "10 / x is less than 2";
}
当运行到if语句时，程序首先会判断x是不是0，如果是零，便直接跳过，不会判断第二个条件。
也就是说，你不需要担心除零引起程序崩溃。如果没有短路运算，不得不这样写：
if ( x != 0 )
{
    if ( 10 / x < 2 )
    {
        cout << "10 / x is less than 2";
    }
}
使用短路运算，你可以写出清晰明了的代码。
4.6.3 逻辑或
如果两个值都为true或其中一个为true，逻辑或（Boolean OR）返回true。例如，true或false返回true。false或false返回false。
 C++中逻辑或写成||，是管道符。在键盘上，它们被标记为中间有间隔的竖条，尽管大部分字体把它们显示成没有间隔的竖条。
大部分键盘上管道符和\符号在一个键上，需要按下Shift键才能输出。
和逻辑与一样，逻辑或也可以进行短路计算，如果第一个条件为true，便不会检查第二个。
4.6.4 综合表达式 
利用基本的逻辑运算符，你一次能判断两个条件。如果想判断更多呢？还记得表达式是由变量、操作符和常量构成的吗？
表达式同样 能由其他表达式构成。
例如，你可以用逻辑与和双等号比较操作符判断x等于2且y等于3。
x == 2 && y == 3
分析一段使用布尔值同时检查用户名和密码的示例程序：
#include <iostream>
#include <string>
using namespace std;
int main ()
{
    string username;
    string password;
    cout << "Enter your username: " << "\n";
    getline( cin, username, '\n' );
    cout << "Enter your password: " << "\n";
    getline( cin, password, '\n' );
    if ( username == "root" && password == "xyzzy" )
    {
        cout << "Access allowed" << "\n";
    }
    else
    {
        cout << "Bad username or password. Denied access!" << "\n";
        return 0;
    }
}
示例程序14：username_password.cpp
显示结果如下
Enter your username:
root
Enter your password:
xyzzy
Access allowed

Enter your username:
Hello
Enter your password:
xyzzy
Bad username or password. Denied access!

Enter your username:
root
Enter your password:
Hello
Bad username or password. Denied access!

程序运行时只允许输入正确密码的名为root的用户访问。你可以用else-if语句拓展程序，使其允许多个不同用户访问，
每个用户拥有自己的密码。
优先级
之前的例子中包含几个子表达式：
username == "root"
和：
password == "xyzzy"
C++中，操作符需要按照优先级进行计算。算术操作符的优先级 （+、-、/和*）和普通的数学运算一样；
乘法和除法的优先级大于加法和减法。
对于逻辑操作符，非操作优先，紧接着是比较操作，逻辑与比逻辑或优先。
C语言运算符
优先级                           名称                           符号                           结合性
1                              数组取下标                       []                             左结合性
1                              函数调用                          ()                             左结合性
1                         取结构和联合的成员               .   ->                        左结合性
1                              自增（后缀）                   ++                           左结合性
1                              自减（后缀）                    --                            左结合性
2                              自增（前缀）                   ++                           右结合性
2                              自减（前缀）                    --                            右结合性
2                              取地址                             &                             右结合性
2                              间接寻址                          *                              右结合性
2                              一元正号                         +                              右结合性
2                              一元负号                         -                               右结合性
2                              按位求反                         ~                              右结合性
2                              逻辑非                            !                               右结合性
2                             计算所需空间                  sizeof                         右结合性
3                             强制类型转换                   ()                               右结合性
4                             乘法类运算符                  *   /   %                      左结合性
5                             加法类运算符                  +   -                           左结合性
6                             移位                              <<   >>                      左结合性
7                             关系                              <   >   <=   >=            左结合性
8                             判等                              ==   !=                        左结合性
9                             按位与                            &                               左结合性
10                           按位异或                         ^                               左结合性
11                           按位或                             |                                左结合性
12                           逻辑与                           &&                             左结合性
13                           逻辑或                            ||                                左结合性
14                           条件                               ?:                                右结合性
15                           赋值                           = *= /= %=                    右结合性
                                                                += -= <<= >>=
                                                                &= ^= |=
16                           逗号                           ,                                     左结合性
下表中列出了逻辑操作符和比较操作符的优先级顺序
！
==, <, >, <=, =>, !=
&&
||
你可以用括号控制逻辑操作符和算数运算符的运算顺序。
例如，我们之前的例子：
x == 2 && y == 3
如果想实现“条件非true”，可以用括号：
! ( x == 2 && y == 3 )
4.6.5 逻辑表达式示例
让我们分析一些更复杂的逻辑表达式，看看你是否已经掌握了逻辑运算符。
下面表达式结果是什么呢？
! ( true && false )
结果是true。因为true && false结果为false，而!false结果为true。
下面还有一些题目，答案在脚注：
! ( true || false )
false。
! ( true || true && false )
false（非之前的结果是true）。
! ( ( true || false ) && false )
true。

问答题
1 下面哪个是true？
A. 1
B. 66
C. 0.1
D. -1
E. 以上全部

E

2 下面哪个是逻辑与的操作符？
A. &
B. &&
C. |
D. |&

B

3 表达式!( true && ! ( false || true ) )的结果是?
A. true
B. false

A

4 下面哪个是if语句的正确语法?
A. if expression
B. if { expression
C. if ( expression )
D. expression if

C

实践题 
1 . 编写程序，要求用户输入两个用户的年龄，并指出谁的年龄更大； 需要处理超过100的输入。

#include <iostream>
#include <string>

using namespace std;

int main()
{
    string username1;
    int username1Age;

    cout << "Please enter a username and age.\n";
    cout << "Username: ";
    cin >> username1;
    cout << "Age: ";
    cin >> username1Age;

    string username2;
    int username2Age;

    cout << "Please enter another username and age.\n";
    cout << "Username: ";
    cin >> username2;
    cout << "Age: ";
    cin >> username2Age;

    if ( (username1Age > 100) && (username2Age > 100) )
    {
        cout << "Wow! Both users are really old!" << "\n";
    }

    if (username1Age > username2Age)
    {
        cout << username1 << " is older than " << username2 << "\n";
    }
    else if (username1Age < username2Age)
    {
        cout << username2 << " is older than " << username1 << "\n";
    }
    else
    {
        cout << username1 << " is the same age as " << username2 << "\n";
    }
}
显示结果如下
Please enter a username and age.
Username: Hello
Age: 101
Please enter another username and age.
Username: World
Age: 102
Wow! Both users are really old!
World is older than Hello

2 . 编写一个简单的数字密码系统，两个数都有效时解密。要求只使用一个if语句进行判断。

#include <iostream>

using namespace std;

int main()
{
    int password1 = 12345;
    int password2 = 54321;
    int userPassword = 0;

    cout << "Please enter a number for your password:\n";
    cin >> userPassword;
    if ( (userPassword == password1) || (userPassword == password2) )
    {
        cout << "Yay! You guessed correctly" << "\n";
    }
    else
    {
        cout << "Error! Bad password! Intruder alert!" << "\n";
        return 0;
    }
}

显示结果如下
Please enter a number for your password:
12345
Yay! You guessed correctly

Please enter a number for your password:
54321
Yay! You guessed correctly

Please enter a number for your password:
123456
Error! Bad password! Intruder alert!

Please enter a number for your password:
123
Error! Bad password! Intruder alert!

Please enter a number for your password:
789
Error! Bad password! Intruder alert!

3 . 编写一个小型计算器，输入4个算术运算符中任一个和进行运算的两个参数，输出计算结果。

#include <iostream>
#include <string>

using namespace std;

int main()
{
    string operation;
    double number1 = 0;
    double number2 = 0;
    double result = 0;

    cout << "Please enter one of the four arithmetic operators: +, -, *, /" << "\n";
    cin >> operation;

    if ( ! ( (operation == "+") || (operation == "-") || (operation == "*") || (operation == "/") ) )
    {
        cout << "You entered an invalid operator! Program will exit." << "\n";
        return 0;
    }

    cout << "Please enter two numbers to use with the operator.\nNumber1: ";
    cin >> number1;
    cout << "Number2: ";
    cin >> number2;

    if (operation == "+")
    {
        result = number1 + number2;
    }
    else if (operation == "-")
    {
        result = number1 - number2;
    }
    else if (operation == "*")
    {
        result = number1 * number2;
    }
    else if (operation == "/")
    {
        if (number2 == 0)
        {
            cout << "Denominator is 0! Result is infinity.\n";
            return 0;
        }
        result = number1 / number2;
    }

    cout << "Operation is: \n" << number1 << " " << operation << " " << number2 << " = " << result << "\n";
}

显示结果如下
Please enter one of the four arithmetic operators: +, -, *, /
+
Please enter two numbers to use with the operator.
Number1: 3
Number2: 6
Operation is:
3 + 6 = 9

Please enter one of the four arithmetic operators: +, -, *, /
-
Please enter two numbers to use with the operator.
Number1: 6
Number2: 3
Operation is:
6 - 3 = 3

Please enter one of the four arithmetic operators: +, -, *, /
*
Please enter two numbers to use with the operator.
Number1: 3
Number2: 6
Operation is:
3 * 6 = 18

Please enter one of the four arithmetic operators: +, -, *, /
/
Please enter two numbers to use with the operator.
Number1: 6
Number2: 5
Operation is:
6 / 5 = 1.2

Please enter one of the four arithmetic operators: +, -, *, /
q
You entered an invalid operator! Program will exit.

Please enter one of the four arithmetic operators: +, -, *, /
/
Please enter two numbers to use with the operator.
Number1: 6
Number2: 0
Denominator is 0! Result is infinity.

4 . 拓展本章中的密码检验程序，使其可以处理多用户，每个用户有自己的密码，确保用户名和密码一一对应。
用户第一次登录失败时提示重新登录。思考处理多个用户和密码的方法难度。

#include <iostream>
#include <string>

using namespace std;

string promptUsername()
{
    string username;

    cout << "Enter your username: ";
    getline(cin, username, '\n');
    return username;
}

string promptPassword()
{
    string password;

    cout << "Enter your password: ";
    getline(cin, password, '\n');
    return password;
}

int main()
{
    string username = promptUsername();
    string password = promptPassword();

    string username1 = "root";
    string password1 = "guest";
    string username2 = "Mark";
    string password2 = "Thomas";
    if ( ( (username == username1) && (password == password1) ) ||
            ( (username == username2) && (password == password2) ) )
    {
        cout << "Access allowed" << "\n";
    }
    else
    {
        cout << "Bad username or password. Denied access! Try again..." << "\n";
        username = promptUsername();
        password = promptPassword();

        if ( ( (username == username1) && (password == password1) ) ||
                ( (username == username2) && (password == password2) ) )
        {
            cout << "Access allowed" << "\n";
        }
        else
        {
            cout << "Bad username or password. Denied access! You're outta here!" << "\n";
            return 0;
        }
    }
}

显示结果如下
Enter your username: root
Enter your password: guest
Access allowed

Enter your username: Mark
Enter your password: Thomas
Access allowed

Enter your username: Hello
Enter your password: World
Bad username or password. Denied access! Try again...
Enter your username: Mark
Enter your password: World
Bad username or password. Denied access! You're outta here!

第 5 章 循环
目前为止，你已经学会了如何让程序根据用户的输入执行不同的操作，但程序仍然只能运行一次。
你还无法编写程序反复提示用户重新输入。上一章后面有一道密码程序实践题，要求你在用户密码输入错误后提示重新输入，
对于这道题，不得不编写一连串if语句来重新核对密码。
这就是循序要解决的事情。循环可以重复执行某个代码块，功能极其强大，是大部分程序的核心。
大部分程序或网站产生的极其复杂的输出（如留言板）本质上是多次执行一个简单的任务。
现在，让我们想一下这意味着什么：循环可以让你编写的简单语句重复执行从而产生大量结果。
你可以按照用户意愿反复提示他重新输入密码，也可以在互联网论坛上显示上千份帖子。这非常的赞！
C++有三种循环：while、for和do-while。每种用法略有不同，我们一个一个地学习。
5.1 while循环
while循环是最简单的一种循环，基本结构是：
while ( <条件> ) 
{
 当条件为true时执行的代码 
}
事实上，除了会让自身重复执行外，while循环和if语句非常像，控制条件也是布尔表达式。
例如，下面是一个包含两个控制条件的while循 环：
while ( i == 2 || i == 3 )
下面是一个基本的while循环示例：
while ( true )
{
    cout << "I am looping\n";
}
警告：如果运行这个循环，它会永不停止！因为条件一直为true。
这称为无限循环，无限循环永不停止，只有杀掉程序才能终止运行
（可以通过按下Ctrl-C、Ctrl-Break或关掉控制台窗口杀死程序）。为了避免无限循环，你要确保循环条件不会一直为true。
常见错误
一个导致无限循环的常见错误是将循环控制条件中的双等号误写成单等号。
错误代码
int i = 1;
while ( i = 1 )
{
    cin >> i;
}
这个循环试图读取除1之外的用户输入，遗憾的是，循环条件是：
i = 1
而不是：
i == 1
表达式i = 1只会把i赋值为1。而赋值表达式只会返回分配给它的值， 此例中表达式返回1。
因为1不是零，表达式为true，所以这个循环将会无限执行下去。
让我们看看功能正常的循环！下面是一段完整的循环示例程序，程序 输出从0到9的数字：
#include <iostream>

using namespace std;

int main ()
{
    int i = 0;

    while ( i < 10 )
    {
        cout << i << '\n';
        i++;
    }
}
示例代码15：while.cpp
显示结果如下
0
1
2
3
4
5
6
7
8
9

如果你对循环依然困惑，可以试着这么想：当程序运行到循环体最后的括号时，会跳转到循环的开头，
重新判断条件，根据真假决定是再次重复，还是停止循环跳转到下一条语句。
5.2 for循环
for循环非常灵活方便，其语法是：
for ( 变量初始化；条件；变量更新 )
{    
 当条件为true时执行此处代码
}
循环内可以有很多内容，让我们分析一个短小的示例，分解循环中的每个元素。事实上，for循环和上面的while循环较为相似：
for ( int i = 0; i < 10; i++ )
{
    cout << i << '\n';
}
5.2.1 变量初始化
此例中，变量初始化是int i = 0，变量初始化允许编程人员声明一个变量并且赋值（或者对已经存在的变量进行赋值）。
这里，我们声明 了变量i。当某个变量的值在循环中被反复判断时，这个变量称为循环变量，此例中的i便是循环变量。
编程中经常使用字母i和j作为循环变量。每经过一次循环值增加1的变量称为循环计数器，变量从一个值计数到另一个值。
5.2.2 循环条件
当变量表达式为true时，循环条件控制程序重复自身（就像while循环 一样）。此例中，我们计算i是否小于10。
和while循环一样，程序在执行循环前会判断条件，每次循环结束也会重新判断，决定是否继续循环。
5.2.3 变量更新
在变量更新部分循环变量将被更新。用于变量更新的可能是表达式， 如i++，i=i+10，也可能是函数调用，
比如你可以调用一个不改变变量名但对代码有效的函数。
因为多数循环只有一个变量、一个条件和一个变量更新。for循环把所有和循环相关的逻辑写在一行中，这种方式非常紧凑。
注意这紧凑的一行使用分号分割各个部分；你不能忘掉分号。任何单个甚至所有部分都可以为空，但是分号必须存在。
如果条件为空，条件默认为true，程序将会一直循环，直到其他操作将其终止。这是另一种编写无限循环的方法。
想真正了解for循环的每个部分，我们可以和之前的while循环进行对比，让它们做相同的操作：
int i = 0; // 变量声明和初始化
while ( i < 10 ) // 条件
{
    cout << i << '\n';
    i++; // 变量更新
}
for循环更加紧凑。
让我们来看另一个for循环的示例，它能做一些比单纯输出数字更有趣的事情。
下面是完整的程序，将输出从0~9的平方数：
#include <iostream>

using namespace std;

int main ()
{
    for ( int i = 0; i < 10; i++ )
    {
        cout << i << " squared is " << i *i << endl;
    }
}
示例代码16：for.cpp
显示结果如下
0 squared is 0
1 squared is 1
2 squared is 4
3 squared is 9
4 squared is 16
5 squared is 25
6 squared is 36
7 squared is 49
8 squared is 64
9 squared is 81

这段程序是for循环的一个非常简单的示例。让我们分析示例，学 习for循环的每个部分是如何执行的。
1. 执行初始化步骤：i被设为0。
2. 判断控制条件：因为i小于10，执行循环体。
3. 变量更新：i加1。
4. 判断条件，若条件非true，循环结束。
5. 若条件为true，执行循环体，重复所有的内容。跳回第3步直到i不再小于10。
记住变量更新的步骤只发生在循环体运行之后，并不是第一时间就执行。
5.3 do-while循环
do-while循环比较具有目的性且很少使用。do-while循环的主要目的就是编写至少要执行一次的循环体。结构为：
do 
{     
//循环体... 
} while (条件);
循环条件在函数体的末尾而不是开头；因此，循环体至少要执行一 次，如果执行一次之后循环条件依旧为true，
程序将跳转到循环体的开头再次执行。do-while循环基本上算是颠倒的while循环。
while循环 是“当条件为true，执行循环体”，do-while循环是“执行循环体，如果条件为true跳转到开头重新执行”。
下面是一个简单的示例，让用户反 复输入密码直至密码正确。
#include <string>
#include <iostream>
using namespace std;
int main ()
{
    string password;
    do
    {
        cout << "Please enter your password: ";
        cin >> password;
    }
    while ( password != "foobar" );
    cout << "Welcome, you  got the password right\n";
}
示例代码17：dowhile.cpp
显示结果如下
Please enter your password: hello
Please enter your password: world
Please enter your password: foobar
Welcome, you  got the password right

这个循环将执行循环体至少一次，允许用户输入密码；如果密码不正确，循环将会继续，提示用户再次输入密码，直到用户输入正确的密码。
注意上面例子中while之后的分号！编程时很容易忘记分号，因为其他的循环不需要分号；事实上，其他的循环不能以分号结尾以免增添混乱。
5.4 控制循环
大多数情况通过判断循环条件退出循环，但有时候你也想早点跳出循 环。C++正好有一个关键字：break。
break语句可以立即终止循环， 无论循环执行到哪一步。
下面这段代码使用break语句重写密码示例程序，结束它的无限循环：
#include <string>
#include <iostream>

using namespace std;
int main ()
{
    string password;
    while ( 1 )
    {
        cout << "Please enter your password: ";
        cin >> password;
        if ( password == "foobar" )
        {
            break;
        }
    }
    cout << "Welcome, you got the password right";
}
示例代码18：break.cpp
显示结果如下
Please enter your password: Hello
Please enter your password: World
Please enter your password: foobar
Welcome, you got the password right

break语句会立刻结束循环，跳转到结束括号。此例中一旦输入正确密码循环便会终止。
因为break语句可以出现在循环的任何地方，包括最后，你可以像我这样编写无限循环代替do-while循环。
break语句和do-while循环末尾的条件判断语句功能非常相似。
当需要从庞大的循环体中跳出时，break语句非常实用。但是太多的break语句会让代码难以阅读。
第二种控制循环的方法是使用continue跳出单次循环。当运行到continue语句时，当前的单次循环提前结束，但循环并没有退出。 
例如，你可以借助continue语句编写一个不输出数字10的循环。
int i = 0;
while ( true )
{
    i++;
    if ( i == 10 )
    {
        continue;
    }
    cout << i << "\n";
}
上面的代码中，循环永不停止，但是当i增加到10时，continue语句会使程序跳过cout调用，跳回循环的开始行，重新判断循环条件。
在for循环中使用continue时，continue语句之后会立刻进行变量更新。
当你想跳过循环体中间的某些代码时，使用continue语句非常有用。 
例如，当判断用户输入时，如果用户输入了错误信息，可以使用下面的循环结构跳过输入处理：
while ( true )
{
    cin >> input;
    if ( ! isValid ( input ) )
    {
        continue;
    }
    //像平常一样处理输入
}
5.5 嵌套循环
在C++中，很多时候不止循环一个值，可能同时循环两个不同但相关的值。
例如，你可能想在一个循环中输出一串论坛的帖子，每个帖子都包含很多不同的值，如帖子的主题、作者和正文。
你可以用第二个循环输出这些信息，但是第二个循环需要嵌套到其他的循环中。这种循环就称为嵌套循环，表示一个循环嵌入在另一个里面。
让我们看一个不像论坛帖子那么复杂的简单例子，使用嵌套循环输出 一个乘法表：
#include <iostream>

using namespace std;

int main ()
{
    for ( int i = 0; i < 10; i++ )
    {
        cout << '\t' << i;
    }

    cout << '\n';

    for ( int i = 0; i < 10; ++i )
    {
        cout << i;
        for ( int j = 0; j < 10; ++j )
        {
            cout << '\t' << i *j;
        }
        cout << '\n';
    }
}
示例代码19：nested_loops.cpp
显示结果如下
        0       1       2       3       4       5       6       7       8       9
0       0       0       0       0       0       0       0       0       0       0
1       0       1       2       3       4       5       6       7       8       9
2       0       2       4       6       8       10      12      14      16      18
3       0       3       6       9       12      15      18      21      24      27
4       0       4       8       12      16      20      24      28      32      36
5       0       5       10      15      20      25      30      35      40      45
6       0       6       12      18      24      30      36      42      48      54
7       0       7       14      21      28      35      42      49      56      63
8       0       8       16      24      32      40      48      56      64      72
9       0       9       18      27      36      45      54      63      72      81

当你使用嵌套循环时，可以用外循环和内循环区分两个循环。此例中，包含变量j的是内循环，包含变量i的是外循环。
请注意内循环和外循环中不能使用相同的变量：
错误代码
for ( int i = 0; i < 10; i++ )
{
    //哎呀，i不小心重复定义了
    for ( int i = 0; i < 10; i++ )
    {
    }
}
你可以嵌套两个以上的循环，外循环嵌套内循环，内循环再嵌套一个循环，一层层下去，随便嵌套多少层。
5.6 选择合适的循环
目前你已经学了C++的三种不同的循环，但可能会奇怪：为什么需要三种循环呢？
事实上，你并不真的需要三种循环。像do-while循环大部分出现在课本上，在实际编程中for循环和while循环更为普遍。
下面的内容是关于选择合适循环类型的快速指南。
注意，它们只是一些经验总结，随着时间的推移，对依据代码选择合适类型的循环会有更深的了解，不要让这个指南成为你的金规玉律。
5.6.1 for循环 
当你知道循环的准确次数时可以使用for循环，例如从0计数到100， 用for循环计算乘法表也非常完美。
for循环更是遍历数组的标准方式 （关于数组，参见第10章）。相反，当变量的更新运算比较复杂时不建议使用for循环，
for循环适用于语句单一准确的情况，如果变量更新的步骤需要多行代码，使用for循环就会失去优势。
5.6.2 while循环
取长补短！如果循环条件比较复杂，或者在获取循环变量下一个值前需要做很多的数学运算，可以考虑while循环。
while循环可以清晰的看到循环什么时候结束，但是很难看出每次循环后哪里发生了变化。 
如果变化比较复杂，最好使用一个while循环，至少读者会知道这不是一个简单的更新。
例如，如果你有两个不同的循环变量：
int j = 5;
for ( int i = 0; i < 10 && j > 0; i++ )
{
    cout << i *j;
    j = i - j;
}
注意，不是所有影响循环的代码都会放在for循环的单行中，有一些会被放在循环体的末尾。
这可能会误导读者，因此最好选择while循环进行处理。
int i = 0;
int j = 5;

while ( i < 10 && j > 0 )
{
    cout << i *j;
    j = i - j;
    i++;
}
这依然不完美，但至少不会误导读者。
编写接近无限循环的程序时也适合使用while循环。例如，你有一个国际象棋程序，希望对战双方在游戏结束时都能成为赢家。
5.6.3 do-while循环
do-while是编程的黑天鹅――它们很长时间才出现一次。
使用do-while循环的唯一原因是你想执行至少一次操作。前面的提示用户输入密码的示例程序是一个很好的应用场景，
或者更普遍的，任何需要用户输入且重复提示直至用户输入正确密码的用户交互程序都适合使用do-while。
在某些情况中，如果想让循环体重复，但后面运行时需要和第一次运行不同，它也可能不是一个最好的选择，
例如在用户输入错误密码时你想提示不同的信息。
例如，下面的代码如何用do-while循环实现？
string password;
cout << "Enter your password: ";
cin >> password;
while ( password != "xyzzy" )
{
    cout << "Wrong password--try again: ";
    cin >> password;
}
string password;
do
{
    if ( password == "" )
    {
        cout << "Enter your password: ";
    }
    else
    {
        cout << "Wrong password--try again: ";
    }
    cin >> password;
}
while ( password != "xyzzy" );

想想do-while循环是如何使代码更复杂的？
关键点在于循环体不一样，尽管都在读取用户的输入，但我们想对用户显示不同的信息。
问答题 
1 . 代码int x; for(x=0; x<10; x++) {}中，x最终的值是？
A. 10
B. 9
C. 0
D. 1

A
2 . while(x<100)之后的代码何时会执行？
A. 当x小于100
B. 当x大于100
C. 当x等于100
D. 当它愿意的时候

A
3 . 哪个不是循环结构？
A. for
B. do-while
C. while
D. repeat until

D
4 . do-while能保证循环几次？
A. 0
B. 无限次
C. 1
D. 不定

C

实践题
1 . 编写程序输出完整的“99 Bottles of Beer”的歌词。

99 bottles of beer on the wall, 99 bottles of beer. Take one down, pass it around, 98 bottles of beer on the wall...
98 bottles of beer on the wall, 98 bottles of beer. Take one down, pass it around, 97 bottles of beer on the wall...
97 bottles of beer on the wall, 97 bottles of beer. Take one down, pass it around, 96 bottles of beer on the wall...
...
3 bottles of beer on the wall, 3 bottles of beer. Take one down, pass it around, 2 bottles of beer on the wall.
2 bottles of beer on the wall, 2 bottles of beer. Take one down, pass it around, 1 bottle of beer on the wall.
1 bottle of beer on the wall, 1 bottle of beer. Take one down, pass it around, 

#include <iostream>
#include <string>

using namespace std;

int main()
{
    for (int beer = 99; beer > 0; beer--)
    {
        if(beer != 99)
        {
            cout << beer << " bottles of beer on the wall.\n";
        }
        cout << beer << " bottles of beer on the wall, " << beer << " bottles of beer.\n" <<
             "Take one down, pass it around...\n";
    }
}

显示结果如下
99 bottles of beer on the wall, 99 bottles of beer.
Take one down, pass it around...
98 bottles of beer on the wall.
98 bottles of beer on the wall, 98 bottles of beer.
Take one down, pass it around...
97 bottles of beer on the wall.
97 bottles of beer on the wall, 97 bottles of beer.
Take one down, pass it around...
96 bottles of beer on the wall.
96 bottles of beer on the wall, 96 bottles of beer.
Take one down, pass it around...
95 bottles of beer on the wall.
95 bottles of beer on the wall, 95 bottles of beer.
Take one down, pass it around...
94 bottles of beer on the wall.
94 bottles of beer on the wall, 94 bottles of beer.
Take one down, pass it around...
93 bottles of beer on the wall.
93 bottles of beer on the wall, 93 bottles of beer.
Take one down, pass it around...
92 bottles of beer on the wall.
92 bottles of beer on the wall, 92 bottles of beer.
Take one down, pass it around...
91 bottles of beer on the wall.
91 bottles of beer on the wall, 91 bottles of beer.
Take one down, pass it around...
90 bottles of beer on the wall.
90 bottles of beer on the wall, 90 bottles of beer.
Take one down, pass it around...
89 bottles of beer on the wall.
89 bottles of beer on the wall, 89 bottles of beer.
Take one down, pass it around...
88 bottles of beer on the wall.
88 bottles of beer on the wall, 88 bottles of beer.
Take one down, pass it around...
87 bottles of beer on the wall.
87 bottles of beer on the wall, 87 bottles of beer.
Take one down, pass it around...
86 bottles of beer on the wall.
86 bottles of beer on the wall, 86 bottles of beer.
Take one down, pass it around...
85 bottles of beer on the wall.
85 bottles of beer on the wall, 85 bottles of beer.
Take one down, pass it around...
84 bottles of beer on the wall.
84 bottles of beer on the wall, 84 bottles of beer.
Take one down, pass it around...
83 bottles of beer on the wall.
83 bottles of beer on the wall, 83 bottles of beer.
Take one down, pass it around...
82 bottles of beer on the wall.
82 bottles of beer on the wall, 82 bottles of beer.
Take one down, pass it around...
81 bottles of beer on the wall.
81 bottles of beer on the wall, 81 bottles of beer.
Take one down, pass it around...
80 bottles of beer on the wall.
80 bottles of beer on the wall, 80 bottles of beer.
Take one down, pass it around...
79 bottles of beer on the wall.
79 bottles of beer on the wall, 79 bottles of beer.
Take one down, pass it around...
78 bottles of beer on the wall.
78 bottles of beer on the wall, 78 bottles of beer.
Take one down, pass it around...
77 bottles of beer on the wall.
77 bottles of beer on the wall, 77 bottles of beer.
Take one down, pass it around...
76 bottles of beer on the wall.
76 bottles of beer on the wall, 76 bottles of beer.
Take one down, pass it around...
75 bottles of beer on the wall.
75 bottles of beer on the wall, 75 bottles of beer.
Take one down, pass it around...
74 bottles of beer on the wall.
74 bottles of beer on the wall, 74 bottles of beer.
Take one down, pass it around...
73 bottles of beer on the wall.
73 bottles of beer on the wall, 73 bottles of beer.
Take one down, pass it around...
72 bottles of beer on the wall.
72 bottles of beer on the wall, 72 bottles of beer.
Take one down, pass it around...
71 bottles of beer on the wall.
71 bottles of beer on the wall, 71 bottles of beer.
Take one down, pass it around...
70 bottles of beer on the wall.
70 bottles of beer on the wall, 70 bottles of beer.
Take one down, pass it around...
69 bottles of beer on the wall.
69 bottles of beer on the wall, 69 bottles of beer.
Take one down, pass it around...
68 bottles of beer on the wall.
68 bottles of beer on the wall, 68 bottles of beer.
Take one down, pass it around...
67 bottles of beer on the wall.
67 bottles of beer on the wall, 67 bottles of beer.
Take one down, pass it around...
66 bottles of beer on the wall.
66 bottles of beer on the wall, 66 bottles of beer.
Take one down, pass it around...
65 bottles of beer on the wall.
65 bottles of beer on the wall, 65 bottles of beer.
Take one down, pass it around...
64 bottles of beer on the wall.
64 bottles of beer on the wall, 64 bottles of beer.
Take one down, pass it around...
63 bottles of beer on the wall.
63 bottles of beer on the wall, 63 bottles of beer.
Take one down, pass it around...
62 bottles of beer on the wall.
62 bottles of beer on the wall, 62 bottles of beer.
Take one down, pass it around...
61 bottles of beer on the wall.
61 bottles of beer on the wall, 61 bottles of beer.
Take one down, pass it around...
60 bottles of beer on the wall.
60 bottles of beer on the wall, 60 bottles of beer.
Take one down, pass it around...
59 bottles of beer on the wall.
59 bottles of beer on the wall, 59 bottles of beer.
Take one down, pass it around...
58 bottles of beer on the wall.
58 bottles of beer on the wall, 58 bottles of beer.
Take one down, pass it around...
57 bottles of beer on the wall.
57 bottles of beer on the wall, 57 bottles of beer.
Take one down, pass it around...
56 bottles of beer on the wall.
56 bottles of beer on the wall, 56 bottles of beer.
Take one down, pass it around...
55 bottles of beer on the wall.
55 bottles of beer on the wall, 55 bottles of beer.
Take one down, pass it around...
54 bottles of beer on the wall.
54 bottles of beer on the wall, 54 bottles of beer.
Take one down, pass it around...
53 bottles of beer on the wall.
53 bottles of beer on the wall, 53 bottles of beer.
Take one down, pass it around...
52 bottles of beer on the wall.
52 bottles of beer on the wall, 52 bottles of beer.
Take one down, pass it around...
51 bottles of beer on the wall.
51 bottles of beer on the wall, 51 bottles of beer.
Take one down, pass it around...
50 bottles of beer on the wall.
50 bottles of beer on the wall, 50 bottles of beer.
Take one down, pass it around...
49 bottles of beer on the wall.
49 bottles of beer on the wall, 49 bottles of beer.
Take one down, pass it around...
48 bottles of beer on the wall.
48 bottles of beer on the wall, 48 bottles of beer.
Take one down, pass it around...
47 bottles of beer on the wall.
47 bottles of beer on the wall, 47 bottles of beer.
Take one down, pass it around...
46 bottles of beer on the wall.
46 bottles of beer on the wall, 46 bottles of beer.
Take one down, pass it around...
45 bottles of beer on the wall.
45 bottles of beer on the wall, 45 bottles of beer.
Take one down, pass it around...
44 bottles of beer on the wall.
44 bottles of beer on the wall, 44 bottles of beer.
Take one down, pass it around...
43 bottles of beer on the wall.
43 bottles of beer on the wall, 43 bottles of beer.
Take one down, pass it around...
42 bottles of beer on the wall.
42 bottles of beer on the wall, 42 bottles of beer.
Take one down, pass it around...
41 bottles of beer on the wall.
41 bottles of beer on the wall, 41 bottles of beer.
Take one down, pass it around...
40 bottles of beer on the wall.
40 bottles of beer on the wall, 40 bottles of beer.
Take one down, pass it around...
39 bottles of beer on the wall.
39 bottles of beer on the wall, 39 bottles of beer.
Take one down, pass it around...
38 bottles of beer on the wall.
38 bottles of beer on the wall, 38 bottles of beer.
Take one down, pass it around...
37 bottles of beer on the wall.
37 bottles of beer on the wall, 37 bottles of beer.
Take one down, pass it around...
36 bottles of beer on the wall.
36 bottles of beer on the wall, 36 bottles of beer.
Take one down, pass it around...
35 bottles of beer on the wall.
35 bottles of beer on the wall, 35 bottles of beer.
Take one down, pass it around...
34 bottles of beer on the wall.
34 bottles of beer on the wall, 34 bottles of beer.
Take one down, pass it around...
33 bottles of beer on the wall.
33 bottles of beer on the wall, 33 bottles of beer.
Take one down, pass it around...
32 bottles of beer on the wall.
32 bottles of beer on the wall, 32 bottles of beer.
Take one down, pass it around...
31 bottles of beer on the wall.
31 bottles of beer on the wall, 31 bottles of beer.
Take one down, pass it around...
30 bottles of beer on the wall.
30 bottles of beer on the wall, 30 bottles of beer.
Take one down, pass it around...
29 bottles of beer on the wall.
29 bottles of beer on the wall, 29 bottles of beer.
Take one down, pass it around...
28 bottles of beer on the wall.
28 bottles of beer on the wall, 28 bottles of beer.
Take one down, pass it around...
27 bottles of beer on the wall.
27 bottles of beer on the wall, 27 bottles of beer.
Take one down, pass it around...
26 bottles of beer on the wall.
26 bottles of beer on the wall, 26 bottles of beer.
Take one down, pass it around...
25 bottles of beer on the wall.
25 bottles of beer on the wall, 25 bottles of beer.
Take one down, pass it around...
24 bottles of beer on the wall.
24 bottles of beer on the wall, 24 bottles of beer.
Take one down, pass it around...
23 bottles of beer on the wall.
23 bottles of beer on the wall, 23 bottles of beer.
Take one down, pass it around...
22 bottles of beer on the wall.
22 bottles of beer on the wall, 22 bottles of beer.
Take one down, pass it around...
21 bottles of beer on the wall.
21 bottles of beer on the wall, 21 bottles of beer.
Take one down, pass it around...
20 bottles of beer on the wall.
20 bottles of beer on the wall, 20 bottles of beer.
Take one down, pass it around...
19 bottles of beer on the wall.
19 bottles of beer on the wall, 19 bottles of beer.
Take one down, pass it around...
18 bottles of beer on the wall.
18 bottles of beer on the wall, 18 bottles of beer.
Take one down, pass it around...
17 bottles of beer on the wall.
17 bottles of beer on the wall, 17 bottles of beer.
Take one down, pass it around...
16 bottles of beer on the wall.
16 bottles of beer on the wall, 16 bottles of beer.
Take one down, pass it around...
15 bottles of beer on the wall.
15 bottles of beer on the wall, 15 bottles of beer.
Take one down, pass it around...
14 bottles of beer on the wall.
14 bottles of beer on the wall, 14 bottles of beer.
Take one down, pass it around...
13 bottles of beer on the wall.
13 bottles of beer on the wall, 13 bottles of beer.
Take one down, pass it around...
12 bottles of beer on the wall.
12 bottles of beer on the wall, 12 bottles of beer.
Take one down, pass it around...
11 bottles of beer on the wall.
11 bottles of beer on the wall, 11 bottles of beer.
Take one down, pass it around...
10 bottles of beer on the wall.
10 bottles of beer on the wall, 10 bottles of beer.
Take one down, pass it around...
9 bottles of beer on the wall.
9 bottles of beer on the wall, 9 bottles of beer.
Take one down, pass it around...
8 bottles of beer on the wall.
8 bottles of beer on the wall, 8 bottles of beer.
Take one down, pass it around...
7 bottles of beer on the wall.
7 bottles of beer on the wall, 7 bottles of beer.
Take one down, pass it around...
6 bottles of beer on the wall.
6 bottles of beer on the wall, 6 bottles of beer.
Take one down, pass it around...
5 bottles of beer on the wall.
5 bottles of beer on the wall, 5 bottles of beer.
Take one down, pass it around...
4 bottles of beer on the wall.
4 bottles of beer on the wall, 4 bottles of beer.
Take one down, pass it around...
3 bottles of beer on the wall.
3 bottles of beer on the wall, 3 bottles of beer.
Take one down, pass it around...
2 bottles of beer on the wall.
2 bottles of beer on the wall, 2 bottles of beer.
Take one down, pass it around...
1 bottles of beer on the wall.
1 bottles of beer on the wall, 1 bottles of beer.
Take one down, pass it around...

2 . 编写一个菜单程序，允许用户从列表中选择，如果输入不在列表选项内，重新输出列表。

#include <iostream>
#include <string>

using namespace std;

int main()
{
    string stout = "Stout";
    string IPA = "IPA";
    string wheatBeer = "Wheat Beer";
    string ale = "Ale";
    string beerChoice = "";

    do
    {
        cout << "Please specify which type of beer you would like:" << "\n" <<
             "\t" << stout << "\n"
             "\t" << IPA << "\n"
             "\t" << wheatBeer << "\n"
             "\t" << ale << "\n";

        getline(cin, beerChoice, '\n');
    }
    while ( (beerChoice != stout) &&
            (beerChoice != IPA) &&
            (beerChoice != wheatBeer) &&
            (beerChoice != ale) );

    cout << "Good choice!" << endl;
}

显示结果如下
Please specify which type of beer you would like:
        Stout
        IPA
        Wheat Beer
        Ale
Hello
Please specify which type of beer you would like:
        Stout
        IPA
        Wheat Beer
        Ale
World
Please specify which type of beer you would like:
        Stout
        IPA
        Wheat Beer
        Ale
Ale
Good choice!

3 . 编写程序计算用户输入的所有数的和，当用户输入0时结束程序。

#include <iostream>
#include <string>

using namespace std;

int main()
{
    double sum = 0.0;
    double inputValue = 0.0;

    do
    {
        cout << "Please provide a number to add to the sum of " << sum << "\n";
        cin >> inputValue;
        sum += inputValue;
    }
    while (inputValue != 0.0);
}

显示结果如下
Please provide a number to add to the sum of 0
9
Please provide a number to add to the sum of 9
8
Please provide a number to add to the sum of 17
6
Please provide a number to add to the sum of 23
5
Please provide a number to add to the sum of 28
9
Please provide a number to add to the sum of 37
6
Please provide a number to add to the sum of 43
9
Please provide a number to add to the sum of 52
0

4 . 编写密码提示，只允许用户尝试特定的次数――让用户无法轻易编写密码破解程序。

#include <iostream>
#include <string>

using namespace std;

int main()
{
    string password = "guest";
    string userInput = "";
    int attemptLimit = 5;

    for (size_t attempts = 0; attempts < attemptLimit; attempts++)
    {
        if (attempts > 0)
        {
            cout << "You entered an incorrect password! \n" <<
                 "Attempts remaining: " << attemptLimit - attempts << "\n";
        }
        cout << "Please enter your password: " << "\n";
        cin >> userInput;
        if (userInput == password)
        {
            cout << "Congratulations! You have been granted access..." << "\n";
            return 0;
        }
    }
    cout << "Sadly we can't let you in. Goodbye :-( " << "\n";
    return 1;
}

显示结果如下
Please enter your password:
Hello
You entered an incorrect password!
Attempts remaining: 4
Please enter your password:
World
You entered an incorrect password!
Attempts remaining: 3
Please enter your password:
Guest
You entered an incorrect password!
Attempts remaining: 2
Please enter your password:
guest
Congratulations! You have been granted access...

6 . 编写程序输出前20个数的平方数。

#include <iostream>

using namespace std;

int main()
{
    for (size_t i = 1; i < 21; i++)
    {
        cout << i *i << "\n";
    }
}

显示结果如下
1
4
9
16
25
36
49
64
81
100
121
144
169
196
225
256
289
324
361
400

7 . 编写一个调查程序，统计三种可能结果的出现次数。第一个输入是调查的问题；接下来的三个输入是可能的结果。
第一种结果用1表示，第二种用2，第三种用3。统计所有的结果直到输入0。当输入结束后程序会显示调查的结果。
请尝试用条形图输出结果，确保无论输入多少个结果，条形图都能适应屏幕输出。

#include <iostream>
#include <string>

using namespace std;

int main()
{
    string pollQuestion = "";
    cout << "Please enter a poll question that can be answered by: Agree, Disagree, Neither"  << "\n";
    getline(cin, pollQuestion, '\n');

    int agree = 0;
    int disagree = 0;
    int neither = 0;

    bool askingQuestions = true;
    int choice = 0;

    while(askingQuestions)
    {
        cout << pollQuestion << "\n" <<
             "Choices: " << "\n\t" <<
             "1 - Agree" << "\n\t" <<
             "2 - Disagree" << "\n\t" <<
             "3 - Neither" << "\n\t" <<
             "0 - No more questions, please!" << "\n";
        cin >> choice;

        if (choice == 1)
        {
            agree++;
        }
        else if (choice == 2)
        {
            disagree++;
        }
        else if (choice == 3)
        {
            neither++;
        }
        else if (choice == 0)
        {
            askingQuestions = false;
        }
        else
        {
            cout << "That is an invalid answer. Please try again." << "\n";
        }
    }

    string agreeBar = "";
    for (size_t i = 0; i < agree; i++)
    {
        agreeBar += "=";
    }

    string disagreeBar = "";
    for (size_t i = 0; i < disagree; i++)
    {
        disagreeBar += "=";
    }

    string neitherBar = "";
    for (size_t i = 0; i < neither; i++)
    {
        neitherBar += "=";
    }


    cout << "The following are the results of the following survey: " << "\n" <<
         pollQuestion << "\n" <<
         "Agree    (" << agree << "): " << agreeBar << "\n" <<
         "Disagree (" << disagree << "): " << disagreeBar << "\n" <<
         "Neither  (" << neither << "): " << neitherBar << "\n";
}

显示结果如下
Please enter a poll question that can be answered by: Agree, Disagree, Neither
tiger is bigger than cat?
tiger is bigger than cat?
Choices:
        1 - Agree
        2 - Disagree
        3 - Neither
        0 - No more questions, please!
1
tiger is bigger than cat?
Choices:
        1 - Agree
        2 - Disagree
        3 - Neither
        0 - No more questions, please!
1
tiger is bigger than cat?
Choices:
        1 - Agree
        2 - Disagree
        3 - Neither
        0 - No more questions, please!
2
tiger is bigger than cat?
Choices:
        1 - Agree
        2 - Disagree
        3 - Neither
        0 - No more questions, please!
3
tiger is bigger than cat?
Choices:
        1 - Agree
        2 - Disagree
        3 - Neither
        0 - No more questions, please!
3
tiger is bigger than cat?
Choices:
        1 - Agree
        2 - Disagree
        3 - Neither
        0 - No more questions, please!
2
tiger is bigger than cat?
Choices:
        1 - Agree
        2 - Disagree
        3 - Neither
        0 - No more questions, please!
1
tiger is bigger than cat?
Choices:
        1 - Agree
        2 - Disagree
        3 - Neither
        0 - No more questions, please!
0
The following are the results of the following survey:
tiger is bigger than cat?
Agree    (3): ===
Disagree (2): ==
Neither  (2): ==

第 6 章 函数
在上一章中我们学习了循环，现在已经可以编写一些有趣的程序。不过所有的代码都必须写在main函数里。
如果你想在main函数里编写复杂的程序，那么程序必将庞大且晦涩难懂。在完成前面几章的某些复杂练习题时，你应该已经注意到了这个问题。
再者，如果想在程序的不同位置做相同的事情，你就不得不一遍遍的复制粘贴这些代码。
函数此时要登场了――通过把程序分解成函数，你可以在很多地方不复制粘贴就能复用这些代码。
事实上，在前面的几章中你已经使用过几个标准函数，用它们处理输入和输出。
目前所学已经足够你编写一个新程序。函数的功能是组织代码，它能使代码方便复用且容易阅读。
6.1 函数语法
通过前面的学习，你已经知道如何创建一个函数；每个程序至少要有一个main函数！
接下来我们将学习另一类函数，详解这类函数中的每个部分。
int add (int x, int y)
{
    return x + y;
}
OK，开始！首先，请注意到上面的函数和我们熟悉（之前写过多次） 的main函数非常像。它们只有两点不同。
1. 上面的函数有两个参数：x和y。main函数没有任何参数。
2. 这个函数显式地返回一个值。（记住，main函数也有一个返回值， 但在程序中不需要使用return语句。）
代码行：
int add (int x, int y)
首先给出了返回值类型，然后给出了函数名，函数名后紧接着的是括号内的两个参数。
如果函数没有参数，你可以直接写一对空括号，如下：
int no_arg_function ()
如果函数没有返回值，那么返回值类型声明为void，如直接向屏幕输出信息的函数。
void可以防止你把函数用作表达式（表达式用在变量赋值或if语句判断条件中）。
返回值由return语句提供；这个函数中它只有一行：
return x + y;
但你可以像main函数一样编写多行，函数运行到return语句就会停止，把值返回给调用它的代码。
一旦声明了函数，就可以像下面这样调用它：
add( 1, 2 ); // 忽略返回值
你也可以把函数用作表达式，对变量赋值或者直接输出：
#include <iostream>

using namespace std;
int add (int x, int y)
{
    return x + y;
}
int main ()
{
    int result = add( 1, 2 );
    cout << "The result is: " << result << '\n';
    cout << "Adding 3 and 4 gives us: " << add( 3, 4 ) << endl;
}

示例代码20：add_function.cpp
显示结果如下
The result is: 3
Adding 3 and 4 gives us: 7

cout输出的是表达式的计算结果，而不是字符串add(3, 4)。
    cout << "Adding 3 and 4 gives us: " << add( 3, 4 ) << endl;
程序执行结果和下面这行代码一样。
cout << "Adding 3 and 4 gives us: " << 3 + 4 << endl;
在上面的示例程序中，程序中多次调用了add函数，但注意，我们并没有一遍遍地复制加法代码，
而是多次调用封装了加法功能的add函数。 如果函数比较短，调用函数没有多大帮助，
但如果我们把更多的代码添加到add函数中（比如某些输出参数和结果的调试语句），
调用函数将使得代码变动量很少――你仅仅需要修改函数，而不是修改所有重复的代码。
6.2 局部变量和全局变量
现在可以编写多个函数，每个函数可以有多个变量。接下来让我们花点时间讨论一下变量的名称。
当在函数里声明一个变量时，你会对它命名。那么在哪些地方我们可以通过变量名引用变量呢？ 
6.2.1 局部变量
分析一个简单的函数：
int addTen (int x)
{
    int result = x + 10;
    return result;
}
函数中有x和result两个变量。首先讨论result，result只在定义它的括号内有效，即只对add函数内部的两行代码有效。
换句话说，你可以在其他函数中使用result变量：
int getValueTen ()
{
    int result = 10;
    return result;
}
你甚至可以在addTen中调用getValueTen：
int addTen (int x)
{
    int result = x + getValueTen();
    return result;
}
上面有两个名为result的不同变量，一个属于addTen函数，另一个属 于getValueTen函数。
两个变量并不冲突，getValueTen执行时只会使用定义在它的括号内的result变量，addTen也是一样。
一个变量的有效范围称作它的作用域。变量的作用域指可以通过变量名称引用变量的区域。
在函数内部声明的变量只在该函数内部有效。 当主函数调用子函数时，主函数内声明的变量在子函数内无效，
子函数内声明的变量也只在该子函数内部有效。
函数的参数在函数内部声明。尽管参数的值由调用的函数进行赋值， 但这些参数对调用的函数无效。
比如addTen函数中的变量x，它是函数的参数，只能在定义它的addTen函数中使用。
此外，像其他在函数中声明的非参数类变量一样，参数变量x也不能被addTen函数的子函数使用。示例中，addTen的变量x对getValueTen函数无效。
函数参数就像传递给函数的变量的替身；改变函数参数对原始变量没有影响。当变量传递给函数时，变量的值被复制给函数参数。
#include <iostream>

using namespace std;
void changeArgument (int x)
{
    x = x + 5;
}

int main()
{
    int y = 4;
    changeArgument( y );
    cout << y << endl;
}
示例代码21：local_variable.cpp
显示结果如下
4

变量的作用域可以比函数代码区域小。C++用一组花括号定义小范围作用域。例如：
int divide (int numerator, int denominator)
{
    if ( denominator == 0 )
    {
        int result = 0;
        return result;
    }

    int result = numerator / denominator;
    return result;
}
第一个result的作用域只在if语句的花括号中，第二个result的作用域是从声明处到函数结尾。
一般来说，编译器不会阻止你创建两个同名变量。在示例函数divide函数中，
相似作用域下的多个同名变量会让看代码的人头疼不已。
在函数内部或代码块中声明的变量叫做局部变量。此外还有一种作用域更广的变量，叫做全局变量。
6.2.2 全局变量
有时，你可能想要某个变量对所有函数都有效。比如在棋盘游戏中， 可能想把“棋盘”存储为一个全局性的变量，
这样就可以让多个函数使用它而不需要次次都通过参数传值。
全局变量可以帮你实现这个功能。全局变量是一个声明在所有函数之外的变量，它在程序中声明代码后的任何地方都有效。
下面是一个如何声明和使用全局变量的基本示例。
#include <iostream>

using namespace std;

int doStuff ()
{
    return 2 + 3;
}

int count_of_function_calls = 0;
void fun ()
{
    count_of_function_calls++;
}
int main ()
{
    fun();
    fun();
    fun();
    cout << "Function fun was called " << count_of_function_calls << " times" << endl;
}
示例代码22：global_variable.cpp
显示结果如下
Function fun was called 3 times

变量count_of_function_calls的作用域从fun函数前开始。函数doStuff 在它之前声明，所以不能使用它。
fun和main在它之后声明，可以使用它。
6.2.3 有关全局变量的警告
全局变量似乎能让事情变得更容易，所有人都可以使用它。但是，使用全局变量会增加代码的阅读难度：想知道某个全局变量是否被使用过需阅读所有的代码！
正确的做法是少用全局变量。只有当你确定有些事情需要大范围有效时才使用全局变量。否则请最好采用将参数传递给函数的办法，别让它们访问全局变量。
即使你觉得某个特定的东西需要全局使用，但随后事实会证明没那么需要。
以前面的棋盘游戏为例，你可能计划写一个展示棋盘函数，通过访问全局变量实现。但如果你不想显示当前棋盘而想展示其他棋盘呢？
例如，展示采用其他步法之后的棋盘。你写的这个函数不能将棋盘作参数，访问全局变量它就只能展示全局棋盘。这就不是很方便了。
6.3 使函数可用
变量的作用域规则――只在声明后的区域有效，同样适用于函数（是不是很一致？）
例如，下面的程序不会成功编译：
错误代码
#include <iostream>

using namespace std;

int main ()
{
    int result = add( 1, 2 );
    cout << "The result is: " << result << '\n';
    cout << "Adding 3 and 4 gives us: " << add( 3, 4 ) << endl;
}
int add (int x, int y)
{
    return x + y;
}
示例代码23：badcode.cpp
如果试图编译这个程序，你会看到如下错误信息（或类似信息）：
badcode.cpp:7: error: 'add' was not declared in this scope  
问题出在调用add函数前它还没被声明，调用代码不在它的作用域中。
 调用一个未声明的函数会让编译器不解――它很无奈。
一种解决方案（我在示例中用过）是把整个函数放在调用它之前。另 一种是在定义函数之前先进行声明。
尽管声明函数和定义函数听起来非常相似，但它们有着本质的区别。 接下来详细解释这些术语。
6.3.1 函数定义和声明
定义一个函数意味着要给出完整的函数，包括函数体。
例如，我们编写的add函数便是函数定义，因为它包含了add的功能。
函数定义包含函数声明，因为函数定义需要用到所有函数声明提供的信息。
声明一个函数仅仅给出调用者需要的基本信息：名称、返回值类型和参数。
函数在被调用之前必须先声明，不管是用函数声明还是给出完整的函数定义。
声明一个函数需要编写函数原型。声明将告诉编译器函数会返回什 么，被谁调用以及它所传递的参数。
你可以认为函数原型是函数使用指导。
Return_type function_name (arg_type arg1, ..., arg_type argN);
arg_type只表示每个参数的类型，如int、double或者char。这和声明变量是一回事。
下面是一个函数原型：
int add (int x, int y);
原型表明add函数有两个整型参数，也会返回一个整型数。分号告诉编译器这只是一个函数原型而不是完整的函数定义；
不要忘记结尾的分号，免得编译出错。
6.3.2 函数原型的应用示例
下面是一个上面丢失函数原型代码的修正版本。
#include <iostream>

using namespace std;

int add (int x, int y);

int main ()
{
    int result = add( 1, 2 );
    cout << "The result is: " << result << '\n';
    cout << "Adding 3 and 4 gives us: " << add( 3, 4 ) << endl;
}

int add (int x, int y)
{
    return x + y;
}
示例代码24：function_prototype.cpp
显示结果如下
The result is: 3
Adding 3 and 4 gives us: 7

照常，程序由必须的头文件和using namespace std;开始。
接下来是以分号结尾的函数的声明。在这之后，包括main在内的所有代码都可以使用add函数，尽管add是在main之后定义。
因为在main之前声明了原型，编译器根据声明能解析出它的参数和返回值。
谨记尽管函数可以在定义之前被调用，但最终（编译前）程序中必须包含函数定义。
否则，链接步骤会失败；我们会在之后讲解编译和链接之间的差异。
6.4 把程序拆分成函数
现在已经知道如何编写函数，你还需要知道什么时候需要编写函数。
6.4.1 当需要重复代码时
使用函数的主要目的是复用代码。函数可以让程序的部分逻辑复用起来更容易，当你想使用这些逻辑时，只需要调用函数即可，无需复制粘贴代码。
复制粘贴尽管看起来也简单，但会导致代码重复很多次。 使用函数可以节省代码空间，使程序易读易改。
你会愿意在一个大型程序中修改40多次而不是只修改一个函数吗？反正我不会。
一个很好的经验是一旦你重复某些代码三次，就把这些代码封装成函数，方便以后重复使用。
6.4.2 使代码更加易读
即使无需复用代码，有一长段专业又复杂的代码也会让人很难理解你的代码。
这时你可以编写一个函数并标上“这是我想用的功能”，然后使用这个功能即可。
例如，如果你专门写一个函数处理“读取用户的输 入”，它的功能很容易理解。
否则要实现这个功能，你要编写代码处理索引按键，将按键转化为电信号，再对变量赋值，这很复杂！下面的写法会漂亮很多：
int x;
cin >> x;
阅读这个代码比阅读处理所有细节的代码好多了。当需要处理大量代码，你会发现很难抓住要点，此时需要编写一些函数来组织代码。
通过编写函数，你可以将注意力集中在函数的输入输出，而不是时时刻刻记住函数运行的细节。
的确，您有时会想知道所有细节，但是当您这样做时，就可以去看一下功能，因为您需要了解的所有功能都在一个地方。
如果您将所有细节与程序的较大结构混合在一起，则将很难阅读。
你可能会想“难道我不需要知道细节吗”，您有时会想知道所有细节，但是当您这样做时，只需要查看某个函数即可，
因为它所有的信息都在这里。当函数细节和程序结构混合在一起时，代码会很难阅读。
举一个菜单程序的例子，当用户选择一个菜单选项时，程序要运行复杂的代码。
此时每个菜单选项应该对应一个函数。每个菜单项都可以通过查看对应的函数进行理解，主输入代码的结构也会容易理解。
糟糕的代码通常只有基本的main函数，main函数里填充了大量乱七八糟 的代码。事实上，下一章你会看到这种程序的例子。
6.5 命名和重载函数
为代码的变量、函数等选一个好名字是一件非常重要的事情，名字有助于理解代码。函数调用不会展示函数实现的细节，
挑选一个能够描述函数重要特征的名字非常重要。名字如此重要以至于有时候你想用同一个名字代表多个东西，
例如通过三个坐标点计算三角形面积的函数：
int computeTriangleArea (int x1, int y1, int x2, int y2, int x3, int y3); 
但还有一个通过长和高计算三角形面积的函数。你可能想再次使用名称computeTriangleArea，
因为这个名字可以准确描述函数的作用。这 会不会和之前的computeTriangleArea冲突呢？
在C++中不会！C++允许函数重载；只要函数有不同的参数列表，多个函数可以共用一个名称。如下所示：
int computeTriangleArea (int x1, int y1, int x2, int y2, int x3, int y3); 
和：
int computeTriangleArea (int width, int height);
编译器可以根据调用地址不同区分这两个函数调用，因为两个函数的参数数量不同。（编译器也能处理相同数量不同类型的参数。）
所以像下面这两个函数：
computeTriangleArea( 1, 1, 1, 4, 1, 9 );
computeTriangleArea( 5, 10 );
编译器也能知道调用哪个函数。
重载函数不能滥用，两个有相同名字的函数并不意味着有一样的功能，但是如果两个函数参数不同但功能相同那么使用重载将比较有意义。
6.6 函数概述
和变量、循环、if语句一样，函数是C++程序员的基本工具。它可以在简单的接口下隐藏复杂的运算，处理重复的代码。
这让以后复用代码更为方便。
问答题 
1.哪个不是正确的原型？
A. int funct(char x, char y);
B. double funct(char x)
C. void funct();
D. char x();

B

2.函数原型int func(char x, double v, float t);的返回值类型是什 么？
A. char
B. int
C. float
D. double

B

3.下面哪个函数调用是有效的（假设函数存在）？
A. funct;
B. funct x, y;
C. funct();
D. int funct();

C

4.下面哪个是完整的函数？
A. int funct();
B. int funct(int x) {return x=x+1;}
C. void funct(int) {cout << "Hello"}
D. void funct(x) {cout << "Hello";} 

B

实践题 
1.将之前编写的“菜单程序”改写成一系列的函数调用。每个菜单选项对应一个函数。

#include <iostream>
#include <string>

using namespace std;

void SingNinetyNineBottlesSong()
{
    for (size_t beer = 99; beer > 0; beer--)
    {
        if (beer != 99)
        {
            cout << beer << " bottles of beer on the wall.\n";
        }
        cout << beer << " bottles of beer on the wall, " << beer << " bottles of beer.\n" <<
             "Take one down, pass it around...\n";
    }
}

int logIn()
{
    string password = "guest";
    string userInput = "";
    int attemptLimit = 5;

    for (size_t attempts = 0; attempts < attemptLimit; attempts++)
    {
        if (attempts > 0)
        {
            cout << "You entered an incorrect password! \n" <<
                 "Attempts remaining: " << attemptLimit - attempts << "\n";
        }
        cout << "Please enter your password" << "\n";
        cin >> userInput;
        if (userInput == password)
        {
            cout << "Congratulations! You have been granted access..." << "\n";
            return 0;
        }
    }
    cout << "Sadly we can't let you in. Goodbye :-( " << "\n";
    return 1;
}

string selectBeerChoice(string beerOptions[], size_t num)
{
    string beerChoice = "";
    string message = "";
    for (size_t i = 0; i < num; i++)
    {
        message += "\n\t" + beerOptions[i];
    }

    cout << "Please specify which type of beer you would like:" <<  message << "\n";

    getline(cin, beerChoice, '\n');
    return beerChoice;
}

bool validBeerChoice(string beerChoice, string beerOptions[], size_t num)
{
    bool isValid = false;
    for (size_t i = 0; i < num; i++)
    {
        if(beerChoice == beerOptions[i])
        {
            isValid = true;
            break;
        }
    }
    return isValid;
}

int main()
{
    if (logIn() == 1)
    {
        return 1;
    }

    cin.clear();
    cin.ignore(80, '\n'); 

    string beerOptions[4] = { "Stout", "IPA", "Wheat Beer", "Ale" };
    string beerChoice = "";

    do
    {
        beerChoice = selectBeerChoice(beerOptions, 4);
    }
    while (!validBeerChoice(beerChoice, beerOptions, 4));

    cout << "Good choice!" << endl;

    SingNinetyNineBottlesSong();
}

显示结果如下
Please enter your password
Hello
You entered an incorrect password!
Attempts remaining: 4
Please enter your password
World
You entered an incorrect password!
Attempts remaining: 3
Please enter your password
guest
Congratulations! You have been granted access...
Please specify which type of beer you would like:
        Stout
        IPA
        Wheat Beer
        Ale
Hello
Please specify which type of beer you would like:
        Stout
        IPA
        Wheat Beer
        Ale
World
Please specify which type of beer you would like:
        Stout
        IPA
        Wheat Beer
        Ale
IPA
Good choice!
99 bottles of beer on the wall, 99 bottles of beer.
Take one down, pass it around...
98 bottles of beer on the wall.
98 bottles of beer on the wall, 98 bottles of beer.
Take one down, pass it around...
97 bottles of beer on the wall.
97 bottles of beer on the wall, 97 bottles of beer.
Take one down, pass it around...
96 bottles of beer on the wall.
96 bottles of beer on the wall, 96 bottles of beer.
Take one down, pass it around...
95 bottles of beer on the wall.
95 bottles of beer on the wall, 95 bottles of beer.
Take one down, pass it around...
94 bottles of beer on the wall.
94 bottles of beer on the wall, 94 bottles of beer.
Take one down, pass it around...
93 bottles of beer on the wall.
93 bottles of beer on the wall, 93 bottles of beer.
Take one down, pass it around...
92 bottles of beer on the wall.
92 bottles of beer on the wall, 92 bottles of beer.
Take one down, pass it around...
91 bottles of beer on the wall.
91 bottles of beer on the wall, 91 bottles of beer.
Take one down, pass it around...
90 bottles of beer on the wall.
90 bottles of beer on the wall, 90 bottles of beer.
Take one down, pass it around...
89 bottles of beer on the wall.
89 bottles of beer on the wall, 89 bottles of beer.
Take one down, pass it around...
88 bottles of beer on the wall.
88 bottles of beer on the wall, 88 bottles of beer.
Take one down, pass it around...
87 bottles of beer on the wall.
87 bottles of beer on the wall, 87 bottles of beer.
Take one down, pass it around...
86 bottles of beer on the wall.
86 bottles of beer on the wall, 86 bottles of beer.
Take one down, pass it around...
85 bottles of beer on the wall.
85 bottles of beer on the wall, 85 bottles of beer.
Take one down, pass it around...
84 bottles of beer on the wall.
84 bottles of beer on the wall, 84 bottles of beer.
Take one down, pass it around...
83 bottles of beer on the wall.
83 bottles of beer on the wall, 83 bottles of beer.
Take one down, pass it around...
82 bottles of beer on the wall.
82 bottles of beer on the wall, 82 bottles of beer.
Take one down, pass it around...
81 bottles of beer on the wall.
81 bottles of beer on the wall, 81 bottles of beer.
Take one down, pass it around...
80 bottles of beer on the wall.
80 bottles of beer on the wall, 80 bottles of beer.
Take one down, pass it around...
79 bottles of beer on the wall.
79 bottles of beer on the wall, 79 bottles of beer.
Take one down, pass it around...
78 bottles of beer on the wall.
78 bottles of beer on the wall, 78 bottles of beer.
Take one down, pass it around...
77 bottles of beer on the wall.
77 bottles of beer on the wall, 77 bottles of beer.
Take one down, pass it around...
76 bottles of beer on the wall.
76 bottles of beer on the wall, 76 bottles of beer.
Take one down, pass it around...
75 bottles of beer on the wall.
75 bottles of beer on the wall, 75 bottles of beer.
Take one down, pass it around...
74 bottles of beer on the wall.
74 bottles of beer on the wall, 74 bottles of beer.
Take one down, pass it around...
73 bottles of beer on the wall.
73 bottles of beer on the wall, 73 bottles of beer.
Take one down, pass it around...
72 bottles of beer on the wall.
72 bottles of beer on the wall, 72 bottles of beer.
Take one down, pass it around...
71 bottles of beer on the wall.
71 bottles of beer on the wall, 71 bottles of beer.
Take one down, pass it around...
70 bottles of beer on the wall.
70 bottles of beer on the wall, 70 bottles of beer.
Take one down, pass it around...
69 bottles of beer on the wall.
69 bottles of beer on the wall, 69 bottles of beer.
Take one down, pass it around...
68 bottles of beer on the wall.
68 bottles of beer on the wall, 68 bottles of beer.
Take one down, pass it around...
67 bottles of beer on the wall.
67 bottles of beer on the wall, 67 bottles of beer.
Take one down, pass it around...
66 bottles of beer on the wall.
66 bottles of beer on the wall, 66 bottles of beer.
Take one down, pass it around...
65 bottles of beer on the wall.
65 bottles of beer on the wall, 65 bottles of beer.
Take one down, pass it around...
64 bottles of beer on the wall.
64 bottles of beer on the wall, 64 bottles of beer.
Take one down, pass it around...
63 bottles of beer on the wall.
63 bottles of beer on the wall, 63 bottles of beer.
Take one down, pass it around...
62 bottles of beer on the wall.
62 bottles of beer on the wall, 62 bottles of beer.
Take one down, pass it around...
61 bottles of beer on the wall.
61 bottles of beer on the wall, 61 bottles of beer.
Take one down, pass it around...
60 bottles of beer on the wall.
60 bottles of beer on the wall, 60 bottles of beer.
Take one down, pass it around...
59 bottles of beer on the wall.
59 bottles of beer on the wall, 59 bottles of beer.
Take one down, pass it around...
58 bottles of beer on the wall.
58 bottles of beer on the wall, 58 bottles of beer.
Take one down, pass it around...
57 bottles of beer on the wall.
57 bottles of beer on the wall, 57 bottles of beer.
Take one down, pass it around...
56 bottles of beer on the wall.
56 bottles of beer on the wall, 56 bottles of beer.
Take one down, pass it around...
55 bottles of beer on the wall.
55 bottles of beer on the wall, 55 bottles of beer.
Take one down, pass it around...
54 bottles of beer on the wall.
54 bottles of beer on the wall, 54 bottles of beer.
Take one down, pass it around...
53 bottles of beer on the wall.
53 bottles of beer on the wall, 53 bottles of beer.
Take one down, pass it around...
52 bottles of beer on the wall.
52 bottles of beer on the wall, 52 bottles of beer.
Take one down, pass it around...
51 bottles of beer on the wall.
51 bottles of beer on the wall, 51 bottles of beer.
Take one down, pass it around...
50 bottles of beer on the wall.
50 bottles of beer on the wall, 50 bottles of beer.
Take one down, pass it around...
49 bottles of beer on the wall.
49 bottles of beer on the wall, 49 bottles of beer.
Take one down, pass it around...
48 bottles of beer on the wall.
48 bottles of beer on the wall, 48 bottles of beer.
Take one down, pass it around...
47 bottles of beer on the wall.
47 bottles of beer on the wall, 47 bottles of beer.
Take one down, pass it around...
46 bottles of beer on the wall.
46 bottles of beer on the wall, 46 bottles of beer.
Take one down, pass it around...
45 bottles of beer on the wall.
45 bottles of beer on the wall, 45 bottles of beer.
Take one down, pass it around...
44 bottles of beer on the wall.
44 bottles of beer on the wall, 44 bottles of beer.
Take one down, pass it around...
43 bottles of beer on the wall.
43 bottles of beer on the wall, 43 bottles of beer.
Take one down, pass it around...
42 bottles of beer on the wall.
42 bottles of beer on the wall, 42 bottles of beer.
Take one down, pass it around...
41 bottles of beer on the wall.
41 bottles of beer on the wall, 41 bottles of beer.
Take one down, pass it around...
40 bottles of beer on the wall.
40 bottles of beer on the wall, 40 bottles of beer.
Take one down, pass it around...
39 bottles of beer on the wall.
39 bottles of beer on the wall, 39 bottles of beer.
Take one down, pass it around...
38 bottles of beer on the wall.
38 bottles of beer on the wall, 38 bottles of beer.
Take one down, pass it around...
37 bottles of beer on the wall.
37 bottles of beer on the wall, 37 bottles of beer.
Take one down, pass it around...
36 bottles of beer on the wall.
36 bottles of beer on the wall, 36 bottles of beer.
Take one down, pass it around...
35 bottles of beer on the wall.
35 bottles of beer on the wall, 35 bottles of beer.
Take one down, pass it around...
34 bottles of beer on the wall.
34 bottles of beer on the wall, 34 bottles of beer.
Take one down, pass it around...
33 bottles of beer on the wall.
33 bottles of beer on the wall, 33 bottles of beer.
Take one down, pass it around...
32 bottles of beer on the wall.
32 bottles of beer on the wall, 32 bottles of beer.
Take one down, pass it around...
31 bottles of beer on the wall.
31 bottles of beer on the wall, 31 bottles of beer.
Take one down, pass it around...
30 bottles of beer on the wall.
30 bottles of beer on the wall, 30 bottles of beer.
Take one down, pass it around...
29 bottles of beer on the wall.
29 bottles of beer on the wall, 29 bottles of beer.
Take one down, pass it around...
28 bottles of beer on the wall.
28 bottles of beer on the wall, 28 bottles of beer.
Take one down, pass it around...
27 bottles of beer on the wall.
27 bottles of beer on the wall, 27 bottles of beer.
Take one down, pass it around...
26 bottles of beer on the wall.
26 bottles of beer on the wall, 26 bottles of beer.
Take one down, pass it around...
25 bottles of beer on the wall.
25 bottles of beer on the wall, 25 bottles of beer.
Take one down, pass it around...
24 bottles of beer on the wall.
24 bottles of beer on the wall, 24 bottles of beer.
Take one down, pass it around...
23 bottles of beer on the wall.
23 bottles of beer on the wall, 23 bottles of beer.
Take one down, pass it around...
22 bottles of beer on the wall.
22 bottles of beer on the wall, 22 bottles of beer.
Take one down, pass it around...
21 bottles of beer on the wall.
21 bottles of beer on the wall, 21 bottles of beer.
Take one down, pass it around...
20 bottles of beer on the wall.
20 bottles of beer on the wall, 20 bottles of beer.
Take one down, pass it around...
19 bottles of beer on the wall.
19 bottles of beer on the wall, 19 bottles of beer.
Take one down, pass it around...
18 bottles of beer on the wall.
18 bottles of beer on the wall, 18 bottles of beer.
Take one down, pass it around...
17 bottles of beer on the wall.
17 bottles of beer on the wall, 17 bottles of beer.
Take one down, pass it around...
16 bottles of beer on the wall.
16 bottles of beer on the wall, 16 bottles of beer.
Take one down, pass it around...
15 bottles of beer on the wall.
15 bottles of beer on the wall, 15 bottles of beer.
Take one down, pass it around...
14 bottles of beer on the wall.
14 bottles of beer on the wall, 14 bottles of beer.
Take one down, pass it around...
13 bottles of beer on the wall.
13 bottles of beer on the wall, 13 bottles of beer.
Take one down, pass it around...
12 bottles of beer on the wall.
12 bottles of beer on the wall, 12 bottles of beer.
Take one down, pass it around...
11 bottles of beer on the wall.
11 bottles of beer on the wall, 11 bottles of beer.
Take one down, pass it around...
10 bottles of beer on the wall.
10 bottles of beer on the wall, 10 bottles of beer.
Take one down, pass it around...
9 bottles of beer on the wall.
9 bottles of beer on the wall, 9 bottles of beer.
Take one down, pass it around...
8 bottles of beer on the wall.
8 bottles of beer on the wall, 8 bottles of beer.
Take one down, pass it around...
7 bottles of beer on the wall.
7 bottles of beer on the wall, 7 bottles of beer.
Take one down, pass it around...
6 bottles of beer on the wall.
6 bottles of beer on the wall, 6 bottles of beer.
Take one down, pass it around...
5 bottles of beer on the wall.
5 bottles of beer on the wall, 5 bottles of beer.
Take one down, pass it around...
4 bottles of beer on the wall.
4 bottles of beer on the wall, 4 bottles of beer.
Take one down, pass it around...
3 bottles of beer on the wall.
3 bottles of beer on the wall, 3 bottles of beer.
Take one down, pass it around...
2 bottles of beer on the wall.
2 bottles of beer on the wall, 2 bottles of beer.
Take one down, pass it around...
1 bottles of beer on the wall.
1 bottles of beer on the wall, 1 bottles of beer.
Take one down, pass it around...


2.将计算器程序中的每个类型的计算分解成单独的函数。

#include <iostream>
#include <string>

using namespace std;

double Add(double number1, double number2);
double Subtract(double number1, double number2);
double Multiply(double number1, double number2);
double Divide(double number1, double number2);

int main()
{
    string operation;
    double number1 = 0;
    double number2 = 0;
    double result = 0;

    cout << "Please enter one of the four arithmetic operators: +, -, *, /" << "\n";
    cin >> operation;

    if ( !( (operation == "+") ||
             (operation == "-") ||
             (operation == "*") ||
             (operation == "/") ) )
    {
        cout << "You entered an invalid operator! Program will exit." << "\n";
        return 0;
    }

    cout << "Please enter two numbers to use with the operator.\nNumber1: ";
    cin >> number1;
    cout << "Number2: ";
    cin >> number2;

    if (operation == "+")
    {
        result = Add(number1, number2);
    }
    else if (operation == "-")
    {
        result = Subtract(number1, number2);
    }
    else if (operation == "*")
    {
        result = Multiply(number1, number2);
    }
    else if (operation == "/")
    {
        if (number2 == 0)
        {
            cout << "Denominator is 0! Result is infinity.";
            return 0;
        }
        result = Divide(number1, number2);
    }

    cout << "Operation is: \n" <<
         number1 << " " << operation << " " << number2 << " = " << result << "\n";
}

double Add(double number1, double number2)
{
    return number1 + number2;
}

double Subtract(double number1, double number2)
{
    return number1 - number2;
}

double Multiply(double number1, double number2)
{
    return number1 * number2;
}

double Divide(double number1, double number2)
{
    return number1 / number2;
}

显示结果如下
Please enter one of the four arithmetic operators: +, -, *, /
+
Please enter two numbers to use with the operator.
Number1: 6
Number2: 3
Operation is:
6 + 3 = 9

Please enter one of the four arithmetic operators: +, -, *, /
-
Please enter two numbers to use with the operator.
Number1: 6
Number2: 3
Operation is:
6 - 3 = 3

Please enter one of the four arithmetic operators: +, -, *, /
*
Please enter two numbers to use with the operator.
Number1: 6
Number2: 3
Operation is:
6 * 3 = 18

Please enter one of the four arithmetic operators: +, -, *, /
/
Please enter two numbers to use with the operator.
Number1: 6
Number2: 3
Operation is:
6 / 3 = 2

3.修改之前的密码程序，将密码检查逻辑从代码中分离，放入单独的函数中。

#include <iostream>
#include <string>

using namespace std;

string promptUsername();
string promptPassword();
bool isValidLogin(string userName, string password);

int main()
{
    string userName = "";
    string password = "";
    size_t maxAttempts = 5;
    bool loginSuccessful = false;

    for (size_t i = 0; i < maxAttempts; i++)
    {
        if (i > 0)
        {
            cout << "Bad username or password. Denied access! Try again... (" << i + 1 << " of " << maxAttempts << ")\n";
        }

        userName = promptUsername();
        password = promptPassword();
        if(isValidLogin(userName, password))
        {
            loginSuccessful = true;
            break;
        }
    }

    if (loginSuccessful)
    {
        cout << "Access allowed" << "\n";
    }
    else
    {
        cout << "Bad username or password. Denied access! You're outta here!" << "\n";
        return 0;
    }
}

string promptUsername()
{
    string username;

    cout << "Enter your username: " << "\n";
    getline(cin, username, '\n');
    return username;
}

string promptPassword()
{
    string password;

    cout << "Enter your password: " << "\n";
    getline(cin, password, '\n');
    return password;
}

bool isValidLogin(string userName, string password)
{
    string username1 = "root";
    string password1 = "guest";
    string username2 = "Mark";
    string password2 = "Thomas";

    return ( ( (userName == username1) && (password == password1) ) ||
             ( (userName == username2) && (password == password2) ) );
}

显示结果如下
Enter your username:
Hello
Enter your password:
World
Bad username or password. Denied access! Try again... (2 of 5)
Enter your username:
Mark
Enter your password:
Thomas
Access allowed

第 7 章 如何解决问题
现在已经学习了很多基础语言特性，估计你正在疯狂编写运行程序。 
但问题是，你怎么知道需要编写什么呢？即使了解当前问题，你依然会觉得自己像著名美国讽刺喜剧《南方公园》中“内裤精灵”：
第一步：收集内裤
第二步：？？
第三步：获利
你知道了结尾和开头，却不知道过程。
在阅读代码时这一步被略过了，但是当自己编写程序时，便会遇到这个问题。
OK，如果你对第二步比较迷糊，也没有什么关系。这部分非常有趣 。
当然我也承认这是编程中最具有挑战性的部分，其难度比语法大。但这也是最令人满意的一部分。
设计一个听起来很困难的东西，从草稿开始这是一件很神奇的事情；
没有什么东西能比得上赋予程序生命， 把困难的事情变得简单更棒的了。
练习的越多，经验越多，但是首先你需要了解应该练习什么。这便是这章中要讲的内容。
有个坏消息是 第二步很可能会变成22步，因为解决问题的关键是把大问题分解成很多小问题。
让我们拿出刀具、材料开始做开胃菜。首先要对如何解决问题有一个基本的了解。当有一个绝妙的想法但不确定如何将其转换为代码时，
你需要事先了解一些算法的基本概念。算法是解决问题的一系列步骤。即便你了解算法，依然不容易将逻辑转化为代码。
或许程序需要实现的内容非常的多。幸运的是，有一些工具可以解决这个问题。
还记得我之前所说的编程是把内容分解成电脑可以理解的碎片吗？函数的优点就是能构建计算机可以理解的代码块，而不用一直处理原始信息。
举个例子，如果想输出从1到100之间的素数，肯定要用到多个操作符，所以我们需要将其分解成电脑可以理解的步骤。
完成这个任务比较麻烦的地方在于需要做很多事情。在同一时间思考整个事情是相当艰巨的。
我们换一种思路：将其化整为零。每一步不需要单独的指令；只要尝试找到比目前方法更简单的方法即可。
合理的步骤如下：
1. 遍历从2到100的所有数字；
2. 检查每个数字是不是素数；
3. 如果是素数，输出。
OK，我们将其分解成一些不同的小问题，但是很明显无法将其转换成程序。还缺少什么呢？能否找到遍历1到100的数的方法？
这听起来非常像一个循环。事实上，几乎可以实现这段代码了：
for ( int i = 2; i < 100; i++ )
{
    // 判断i是不是素数？如果是，将其输出。
}
在代码中放置一个占位符函数――isPrime。如果函数接收的参数是素数则返回true，否则返回false。
接下来需要实现isPrime，假设函数存在，我们可以填写一部分代码。
大部分函数我们可以思考、编写，可以把问题分解，判断一个数字是否是素数的难度比判断100个要小， 所以思路非常正确。
for ( int i = 2; i < 100; i++ )
{
    if ( isPrime( i ) )
    {
        cout << i << endl;
    }
}
是不是很漂亮？我们已经有了一个基本的结构。现在唯一要做的是实现isPrime。
让我们思考如何判断一个数是不是素数。素数是指除了1和此整数自身外，不能被其他数整除的数。
这个定义给了我们足够的信息来把这个问题分解成更小的子问题。
想判断一个数是否有除数， 我们需要判断有没有数（除去1和自身）能将其整除。
因为通过很多不同的数判断除数，所以需要另外一个循环。以下是这部分算法的具体步骤。
1. 遍历从1到当前值。
2. 如果被检测值能够被变量a整除，返回false。
3. 如果不能被任何数整除，返回true。
来看看能否将以上内容转化为源代码。目前还不知道如何判断一个值能否被其他数整除，但是要坚定信念，
假设我们可以实现，所以用一 个isDivisible函数作为逻辑的占位符。
bool isPrime (int num)
{
    for ( int i = 2; i < num; i++)
    {
        if ( isDivisible( num, i ) )
        {
            return false;
        }
    }
    return true;
}
我们再一次把对一系列值的判断放到一个循环中。我们也把逻辑中的if语句翻译到代码中。
现在该如何实现isDivisible？一种方法是使用一个名为模运算符的特殊操作符，用符号%代替，返回整除的余数。
我提出这个新的操作符似乎有点不可思议，事实上有其他的方法判断一个数是不是有余数；我用模运算是因为这个最直接，
如果你想做 个练习，可以尝试找出同一个问题的不同解决方法。
10 % 2 == 0    // 10 / 2 = 5 没有余数
7.1 只需判断数被除时有无余数
bool isDivisible (int number, int divisor)
{
    return num % divisor == 0;
}
至此，我们已经把问题分解到电脑可以理解的地步。已经不需要编写任何其他函数了；
程序中所有的代码要么是已经定义的指令，要么是我们定义的函数。把所有的放到一起：
#include <iostream>

bool isDivisible (int number, int divisor);
bool isPrime (int number);

using namespace std;

int main ()
{
    for ( int i = 2; i < 100; i++ )
    {
        if ( isPrime( i ) )
        {
            cout << i << endl;
        }
    }
}
bool isPrime (int number)
{
    for ( int i = 2; (i * i) <= number; i++)
    {
        if ( isDivisible( number, i ) )
        {
            return false;
        }
    }
    return true;
}

bool isDivisible (int number, int divisor)
{
    return number % divisor == 0;
}
显示结果如下
2
3
5
7
11
13
17
19
23
29
31
37
41
43
47
53
59
61
67
71
73
79
83
89
97

通过使用函数原型，我们可以准确的执行一开始设想的代码。此外还可以像我们的设计一样从整体阅读代码，从辅助函数阅读函数内容。
7.2 效率和安全的简单说明
顺便聊几句，我们可以对代码进行改进使其更有效率，因为不需要在isPrime函数的循环中遍历2到number。
最容易想到的算法并不意味着是最优最有效率的算法。此例中，我们要计算从2到number的平方根。 
因为只计算了很小的一部分数字的素性，效率并不重要。
然而，通常用在银行或电子商务网站进行敏感数据保护的RSA算法，需要产生大素数来创建加密密钥。
产生大素数便需要检查数字是不是素数。如果想产生大量RSA加密密钥，你需要一个快速、效率的素数生成器。
当遇到看起来很大很难解决的问题时，分解成小问题会更加容易管理。你不需要立即知道如何解决这些小问题
（当然，这对如何解决并没有影响），只需要关心这些小问题的输入是什么，结果是什么。
如果你能编写程序解决这些问题，就可以接受下一个挑战：实现这些小问题。专注一段时间，便能编写出源代码。
设计程序并不总是简单（如果是的话，便会有很多无聊的软件工程师 了），有时候会因为一些原因无法解决子问题。
当问题难以分解时， 尝试后退一步，换一种可行的分解方案。
这种分解程序的方法叫做自顶向下设计，是一种强大的程序设计方法。
另一种方法是自底向上设计，强调首先解决辅助函数，然后使用辅助函数解决大问题。
自底而上设计可能会导致辅助函数完全用不到，但是从实现函数着手会有一个良好的开头。
对于初学者来说，使用自顶向下设计会优于自底向上设计，因为这会帮助你专注于解决问题，
尽可能准确找到所需要的辅助函数，而不是猜测哪些函数可能会用到。
请不要放弃尝试自底向上设计，它适合一些人，也可能适合你，如果无法理解自顶向下设计，在放弃之前反着想一下。
你无需用代码辅助设计。写在白纸或白板上可以让你观察前后是否合适，而无需关心C++语法和编译错误。
如果直接用代码进行设计，在 解决某些语法细节时可能会模糊大局。
所以不直接编写代码，而是编写每一步过程并且把每个过程分解成更小的部分是正确且自然的设计的方法。
不过要注意一点，设计程序并不容易；我所告知的会有效，但是这并不是“万金油”。
只有练习可以让你掌握，并且做得更好。可能会花费 一些时间，不要放弃。
7.3 不知道算法的情况下的解决方案
在找素数的例子中，因为素数的定义几乎就是判断素数的算法，所以任务非常简单。最后只是把算法翻译成代码的问题。
大多数情况下问题并不简单，你必须找到解决问题的算法。
例如，设想找出一种能将数字输出为英文名的算法（例如，输入1204，屏幕显示one thousand, two hundred four）。
在交流时，这种转变会非常自然，无需设想算法的结构；只需要说即可。（假设英语是母语，如果不是，在解决这个问时你会有优势！）
为了解决这类问题，你需要了解数据模型，才能想出算法。
编写几个示例并分析其相近或不同的地方直到找出模型是一个非常好的开始，如下所示：
因为原文中是对英语进行转换，所以以下对照表都为英文，具体数字对应可自行搜索。――译者注
1 one
10 ten
101 one hundred one
1 001 one thousand one
10 001 ten thousand one
100 001 one hundred thousand one
1 000 001 one million one
10 000 001 ten million one
100 000 001 one hundred million one
看到模型的规律了吗？
1 one
10 ten
101 one hundred one
1 001 one thousand one
10 001 ten thousand one
100 001 one hundred thousand one
1 000 001 one million one
10 000 001 ten million one
100 000 001 one hundred million one
每三个数字提升一层级，从无到thousand，到million。
此外，对每个三数字组有“one, ten, one hundred”模型。然后用“高层级”进行合并：
“one thousand”“ten thousand”和“one hundred thousand”。
这里的算法需要从把数字分解成三数字组开始，找到当前层级 （thousand、million、billion）的“量级”，
然后把当前层级翻译成文本并 与“量级”合并。每个三数字组都小于onethousand，所以需要解决更小的问题。继续观察更多的模型：
5 five
15 fifteen
25 twenty five
35 thirty five
45 forty five
105 one hundred five
115 one hundred fifteen
125 one hundred twenty five
135 one hundred thirty five
145 one hundred forty five
这里有一个相似的模式：如果有超过100的数字，文本便会是“X hundred”，接下来是两数字组的对应文本。
如果没有百位，便只有两数字组。
接下来需要决定如何处理两数字组。你观察到这里仍是一个模型了吗？
小于20的数，模式是各个数的对应，我们可以用一系列简单 的if-else语句搞定。
处理1~19时不得不对程序进行硬编码――这里没有算法可以解决。这不是什么时候都能遇到的。
所以我们的算法如下。
1. 分解数字到三数字组。
2. 对每个三数字组，运算文本；追加组的量级；将组合并。
3. 运算一个三数组的文本，计算百位的数字，把百位的数字转化成文本，添加hundreds，追加剩下两位的对应文本。
4. 计算两数字组的文本，如果小于20，直接查找替换；如果大于等于20，运算十位的数字，查找单词，追加最后一位的数字。
我们需要把算法转化成源代码，不是所有的细节都清晰明了，但是你有足够的大纲帮助使用自顶向下的设计方法实现算法。
你看到这个过程是怎样工作的了吗？通过比较不同的数字，我们可以发现数字构建的特定模型。
能够找到算法的种子，虽然不是所有的细节都清晰，但是没有关系；我们会细分问题，直到问题解决。
实践题
1.完成将从-999 999~999 999的数字转换成英文文本的源代码。

#include <iostream>
#include <string>

using namespace std;

string getOneDigitNumber(char number);
string getTeensNumber(char number);
string getTensNumber(char number);
string getTwoDigitNumber(char ten, char one);
string getThreeDigitNumber(char hundred, char ten, char one);
string getMagnitude(int divisionsOfThree);

int main()
{
    int i;

    cout << "Please enter an integer number: ";
    cin >> i;
    string numberAsString = to_string(i);

    string sign = "";
    bool isNegative = (numberAsString.at(0) == '-');
    if (isNegative)
    {
        sign = "Negative ";
    }

    int signOffset = 0;
    if (isNegative)
    {
        signOffset = 1;
    }

    int numberCount = numberAsString.length() - signOffset;

    string numberInEnglish = "";
    int tens = numberCount % 3;
    int divisionsOfThree = (numberCount - 1) / 3;

    if ( numberCount <= 3 )
    {
        switch (numberCount)
        {
        case 1:
            if ( numberAsString.at(signOffset) == '0' )
            {
                numberInEnglish = "zero";
            }
            else
            {
                numberInEnglish = getOneDigitNumber(numberAsString.at(signOffset));
            }
            break;
        case 2:
            numberInEnglish = getTwoDigitNumber(numberAsString.at(signOffset), numberAsString.at(signOffset + 1));
            break;
        case 3:
            numberInEnglish = getThreeDigitNumber(numberAsString.at(signOffset), numberAsString.at(signOffset + 1), numberAsString.at(signOffset + 2));
            break;
        default:
            break;
        }
        cout << numberAsString << ": " << sign << numberInEnglish << '\n';
        return 0;
    }

    if ( tens > 0 )
    {
        switch (tens)
        {
        case 1:
            numberInEnglish = getOneDigitNumber(numberAsString.at(signOffset));
            break;
        case 2:
            numberInEnglish = getTwoDigitNumber(numberAsString.at(signOffset), numberAsString.at(signOffset + 1));
            break;
        default:
            break;
        }
        numberInEnglish += " " + getMagnitude(divisionsOfThree);
        divisionsOfThree--;
    }

    for (size_t j = tens + signOffset; j < numberAsString.length(); j += 3)
    {
        string threeDigits = numberAsString.substr(j, 3);
        if (threeDigits != "000")
        {
            if(numberInEnglish.length() > 0)
            {
                numberInEnglish += ", ";
            }
            if (divisionsOfThree == 0)
            {
                numberInEnglish +=
                    getThreeDigitNumber(threeDigits.at(0), threeDigits.at(1), threeDigits.at(2));
            }
            else
            {
                numberInEnglish +=
                    getThreeDigitNumber(threeDigits.at(0), threeDigits.at(1), threeDigits.at(2)) + " " + getMagnitude(divisionsOfThree);
            }
        }

        divisionsOfThree--;
    }
    cout << numberAsString << ": " << sign << numberInEnglish << '\n';

}

string getOneDigitNumber(char number)
{
    switch(number)
    {
    case '1':
        return "one";
    case '2':
        return "two";
    case '3':
        return "three";
    case '4':
        return "four";
    case '5':
        return "five";
    case '6':
        return "six";
    case '7':
        return "seven";
    case '8':
        return "eight";
    case '9':
        return "nine";
    default:
        return "";
    }
}

string getTeensNumber(char number)
{
    switch (number)
    {
    case '0':
        return "ten";
    case '1':
        return "eleven";
    case '2':
        return "twelve";
    case '3':
        return "thirteen";
    case '4':
        return "fourteen";
    case '5':
        return "fifteen";
    case '6':
        return "sixteen";
    case '7':
        return "seventeen";
    case '8':
        return "eighteen";
    case '9':
        return "nineteen";
    default:
        return "";
    }
}

string getTensNumber(char number)
{
    switch (number)
    {
    case '2':
        return "twenty";
    case '3':
        return "thirty";
    case '4':
        return "fourty";
    case '5':
        return "fifty";
    case '6':
        return "sixty";
    case '7':
        return "seventy";
    case '8':
        return "eighty";
    case '9':
        return "ninety";
    default:
        return "";
    }
}

string getTwoDigitNumber(char ten, char one)
{
    if (ten == '0')
    {
        return  getOneDigitNumber(one);
    }
    else if (ten == '1')
    {
        return getTeensNumber(one);
    }
    else
    {
        if (one == '0')
        {
            return getTensNumber(ten);
        }
        else
        {
            return (getTensNumber(ten) + " " + getOneDigitNumber(one));
        }
    }
}

string getThreeDigitNumber(char hundred, char ten, char one)
{
    if (hundred == '0')
    {
        return  getTwoDigitNumber(ten, one);
    }
    else
    {
        if (ten == '0' && one == '0')
        {
            return (getOneDigitNumber(hundred) + " hundred");
        }
        else
        {
            return (getOneDigitNumber(hundred) + " hundred " + getTwoDigitNumber(ten, one));
        }
    }
}

string getMagnitude(int divisionsOfThree)
{
    switch (divisionsOfThree)
    {
    case 1:
        return "thousand";
    case 2:
        return "million";
    case 3:
        return "billion";
    case 4:
        return "trillion";
    default:
        return "";
    }
}

显示结果如下
Please enter an integer number: 0
0: zero

Please enter an integer number: 1
1: one

Please enter an integer number: 9
9: nine

Please enter an integer number: 10
10: ten

Please enter an integer number: 11
11: eleven

Please enter an integer number: 19
19: nineteen

Please enter an integer number: 20
20: twenty

Please enter an integer number: 21
21: twenty one

Please enter an integer number: 29
29: twenty nine

Please enter an integer number: 90
90: ninety

Please enter an integer number: 91
91: ninety one

Please enter an integer number: 99
99: ninety nine

Please enter an integer number: 100
100: one hundred

Please enter an integer number: 101
101: one hundred one

Please enter an integer number: 109
109: one hundred nine

Please enter an integer number: 190
190: one hundred ninety

Please enter an integer number: 191
191: one hundred ninety one

Please enter an integer number: 199
199: one hundred ninety nine

Please enter an integer number: 1000
1000: one thousand

Please enter an integer number: 1001
1001: one thousand, one

Please enter an integer number: 1001001
1001001: one million, one thousand, one


2.思考如何将英文文本转换成数字。这比之前的算法是难是易？如何处理错误输入？

#include <iostream>
#include <string>

using namespace std;

bool isNegative(string number);

string wordsToNumbers(string word);
bool isTens(string word);
string getTens(string numberAsWord);
bool isHundreds(string word);
string getHundreds(string numberAsWord);
int getMagnitudeBalance(string currentWord, string numberAsString);
string getPaddedForMagnitude(string numberAsString,	int magnitudeBalance);

bool isNumberDemarcator(char character);
bool isFirstLetter(string numberInEnglish,	int numberIndexFromEnd);
int wordsToMagnitude(string word);

string addZeroPadding(int numberOfZeroes);
string addCommasMagnitude(string numberAsWord);

char const space = ' ';
char const comma = ',';
char const hyphen = '-';

int main()
{
	string numberInEnglish = "";
	cout << "Please write in any number you wish to see written out in digits: " << '\n';
	getline(cin, numberInEnglish, '\n');

	string numberAsString = "";
	string currentWord = "";
	for (size_t i = 0; i < numberInEnglish.length(); i++)
	{
		char currentLetter = tolower(numberInEnglish[numberInEnglish.length() - 1 - i]);
		
		if (!isNumberDemarcator(currentLetter)) 
		{
			currentWord = currentLetter + currentWord;
		}
		
		if ( !(currentWord == "") && ( isNumberDemarcator(currentLetter) || isFirstLetter(numberInEnglish, i) ) )
		{
                                      int magnitudeBalance;

                                      if (isTens(currentWord))
			{
				numberAsString = getTens(numberAsString);
			}
                                      else if (isHundreds(currentWord))
			{
				numberAsString = getHundreds(numberAsString);
			}
                                      else if ( ( magnitudeBalance = getMagnitudeBalance(currentWord, numberAsString) ) > 0 )
			{
				numberAsString = getPaddedForMagnitude(numberAsString, magnitudeBalance);
			}
			string currentNumber = wordsToNumbers(currentWord);

			if (!(currentNumber == ""))
			{
				numberAsString = currentNumber + numberAsString;
			}
			
			currentWord = "";
		}
	}

	numberAsString = addCommasMagnitude(numberAsString);

	if (isNegative(numberInEnglish))
	{
		numberAsString = "-" + numberAsString;
	}
	cout << "The number you entered was " << numberAsString << '\n';
}

bool isNumberDemarcator(char character)
{
	return ( (character == hyphen) ||
		(character == comma) ||
		(character == space) );
}

bool isFirstLetter(string numberInEnglish, 
	int numberIndexFromEnd)
{
	return ( numberIndexFromEnd == numberInEnglish.length() - 1 );
}

bool isNegative(string number)
{
	string negative = "negative";
	if (number.length() > negative.length())
	{
		for (size_t i = 0; i < negative.length(); i++)
		{
			if (!(tolower(number[i]) == negative[i]))
			{
				return false;
			}
		}
		return true;
	}
	return false;
}

string wordsToNumbers(string word)
{
            if (word == "zero")
                         return "0";
	if (word == "one")
		return "1";
	if (word == "two")
		return "2";
	if (word == "three")
		return "3";
	if (word == "four")
		return "4";
	if (word == "five")
		return "5";
	if (word == "six")
		return "6";
	if (word == "seven")
		return "7";
	if (word == "eight")
		return "8";
	if (word == "nine")
		return "9";
	if (word == "ten")
		return "10";
	if (word == "eleven")
		return "11";
	if (word == "twelve")
		return "12";
	if (word == "thirteen")
		return "13";
	if (word == "fourteen")
		return "14";
	if (word == "fifteen")
		return "15";
	if (word == "sixteen")
		return "16";
	if (word == "seventeen")
		return "17";
	if (word == "eighteen")
		return "18";
	if (word == "nineteen")
		return "19";
	if (word == "twenty")
		return "2";
	if (word == "thirty")
		return "3";
	if (word == "forty")
		return "4";
	if (word == "fifty")
		return "5";
	if (word == "sixty")
		return "6";
	if (word == "seventy")
		return "7";
	if (word == "eighty")
		return "8";
	if (word == "ninety")
		return "9";
	return "";
}

bool isTens(string word)
{
	return ((word == "twenty") ||
		(word == "thirty") ||
		(word == "forty") ||
		(word == "fifty") ||
		(word == "sixty") ||
		(word == "seventy") ||
		(word == "eighty") ||
		(word == "ninety"));
}

string getTens(string numberAsWord)
{
	int numberLength = numberAsWord.length();
	if (numberLength < 2)
	{
		numberAsWord = addZeroPadding(1 - numberLength) + numberAsWord;
	}
	else
	{
		int offset = 1;
		while (offset - numberLength < 0)
		{
			offset += 3;
		}
		numberAsWord = addZeroPadding(offset - numberLength) + numberAsWord;
	}
	return numberAsWord;
}

bool isHundreds(string word)
{
	return (word == "hundred");
}

string getHundreds(string numberAsWord)
{
	int numberLength = numberAsWord.length();

	int offset = 2;
	while (offset - numberLength < 0)
	{
		offset += 3;
	}
	numberAsWord = addZeroPadding(offset - numberLength) + numberAsWord;

	return numberAsWord;
}

int getMagnitudeBalance(string currentWord,
	string numberAsString)
{
	int currentMagnitude = wordsToMagnitude(currentWord);
	int numberLength = numberAsString.length();
	return (currentMagnitude - numberLength);
}


string getPaddedForMagnitude(string numberAsString,
	int magnitudeBalance)
{
	return (addZeroPadding(magnitudeBalance) + numberAsString);
}


int wordsToMagnitude(string word)
{
	if (word == "thousand") { return 3; }
	if (word == "million") { return 6; }
	if (word == "billion") { return 9; }
	if (word == "trillion") { return 12; }
	return 0;
}

string addZeroPadding(int numberOfZeroes)
{
	string currentPadding = "";
	for (size_t j = 0; j < numberOfZeroes; j++)
	{
		currentPadding += "0";
	}
	return currentPadding;
}

string addCommasMagnitude(string numberAsWord)
{
	string numberAsWordWithCommas = "";
	int subcount = 0;
	int originalLength = numberAsWord.length();
	for (size_t i = 0; i < originalLength; i++)
	{
		numberAsWordWithCommas = numberAsWord[originalLength - 1 - i] + numberAsWordWithCommas;
		subcount++;
		if ((subcount == 3) && !(i == originalLength - 1))
		{
			subcount = 0;
			numberAsWordWithCommas = "," + numberAsWordWithCommas;
		}
	}
	return numberAsWordWithCommas;
}

显示结果如下
Please write in any number you wish to see written out in digits:
twenty
The number you entered was 20

Please write in any number you wish to see written out in digits:
twenty one
The number you entered was 21

Please write in any number you wish to see written out in digits:
zero
The number you entered was 0

Please write in any number you wish to see written out in digits:
twenty nine
The number you entered was 29

Please write in any number you wish to see written out in digits:
ninety
The number you entered was 90

Please write in any number you wish to see written out in digits:
ninety one
The number you entered was 91

Please write in any number you wish to see written out in digits:
ninety nine
The number you entered was 99

Please write in any number you wish to see written out in digits:
one hundred
The number you entered was 100

Please write in any number you wish to see written out in digits:
one hundred one
The number you entered was 101

Please write in any number you wish to see written out in digits:
one hundred twenty
The number you entered was 120

Please write in any number you wish to see written out in digits:
one hundred twenty one
The number you entered was 121

Please write in any number you wish to see written out in digits:
one million one thousand one hundred twenty one
The number you entered was 1,001,121

3.设计算法找出从1到1000中质因子相加是质数的数（例如，12有质因子2、2和3，相加得7，是质数）。完成代码。

#include <iostream>
#include <string>

using namespace std;

bool isDivisible(int number, int divisor);
bool isPrime(int number);
int getPrimeFactor(int number);
string numberHasPrimeFactorsWhichSumToPrime(int number);

int main()
{
    for (size_t i = 1; i <= 1000; i++)
    {
        string message = numberHasPrimeFactorsWhichSumToPrime(i);
        if (!(message == ""))
        {
            cout << message;
        }
    }
}

bool isPrime(int number)
{
    if (number <= 1)
    {
        return false;
    }

    int prime = 2;
    if (number == prime)
    {
        return true;
    }
    if (isDivisible(number, prime))
    {
        return false;
    }
    prime = 3;
    if (number == prime)
    {
        return true;
    }
    if (isDivisible(number, prime))
    {
        return false;
    }
    prime = 5;
    if (number == prime)
    {
        return true;
    }
    if (isDivisible(number, prime))
    {
        return false;
    }
    prime = 7;
    if (number == prime)
    {
        return true;
    }
    if (isDivisible(number, prime))
    {
        return false;
    }

    for (int i = 2; (i * i) <= number; i++)
    {
        if (isDivisible(number, i))
        {
            return false;
        }
    }
    return true;
}

bool isDivisible(int number, int divisor)
{
    return  number % divisor == 0;
}

int getPrimeFactor(int number)
{
    if (number <= 1)
    {
        return 0;
    }

    for (int i = 2; (i * i) <= number; i++)
    {
        if (isDivisible(number, i) && isPrime(i))
        {
            return i;
        }
    }
    return 0;
}

string numberHasPrimeFactorsWhichSumToPrime(int number)
{
    if (number <= 1)
    {
        return "";
    }
    if (isPrime(number))
    {
        return to_string(number) + " is prime number. \n";
    }

    int remainder = number;
    int currentSum = 0;
    string message = to_string(number) + " has prime factors: ";
    bool isFirstTerm = true;
    while (true)
    {
        int primeFactor = getPrimeFactor(remainder);
        if (primeFactor == 0)
        {
            return "An error has occurred with number " + to_string(number) + "\n";
        }
        if (!isFirstTerm)
        {
            message += ", ";
        }
        message += to_string(primeFactor);

        currentSum += primeFactor;
        remainder = (remainder / primeFactor);

        if (isPrime(remainder))
        {
            if (isPrime(remainder + currentSum))
            {
                message += ", " + to_string(remainder);
                message += " Which sum to: " + to_string(remainder + currentSum) + "\n";
                return message;
            }
            return "";
        }
        isFirstTerm = false;
    }
    return "";
}
显示结果如下
2 is prime number.
3 is prime number.
5 is prime number.
6 has prime factors: 2, 3 Which sum to: 5
7 is prime number.
10 has prime factors: 2, 5 Which sum to: 7
11 is prime number.
12 has prime factors: 2, 2, 3 Which sum to: 7
13 is prime number.
17 is prime number.
19 is prime number.
22 has prime factors: 2, 11 Which sum to: 13
23 is prime number.
28 has prime factors: 2, 2, 7 Which sum to: 11
29 is prime number.
31 is prime number.
34 has prime factors: 2, 17 Which sum to: 19
37 is prime number.
40 has prime factors: 2, 2, 2, 5 Which sum to: 11
41 is prime number.
43 is prime number.
45 has prime factors: 3, 3, 5 Which sum to: 11
47 is prime number.
48 has prime factors: 2, 2, 2, 2, 3 Which sum to: 11
52 has prime factors: 2, 2, 13 Which sum to: 17
53 is prime number.
54 has prime factors: 2, 3, 3, 3 Which sum to: 11
56 has prime factors: 2, 2, 2, 7 Which sum to: 13
58 has prime factors: 2, 29 Which sum to: 31
59 is prime number.
61 is prime number.
63 has prime factors: 3, 3, 7 Which sum to: 13
67 is prime number.
71 is prime number.
73 is prime number.
75 has prime factors: 3, 5, 5 Which sum to: 13
76 has prime factors: 2, 2, 19 Which sum to: 23
79 is prime number.
80 has prime factors: 2, 2, 2, 2, 5 Which sum to: 13
82 has prime factors: 2, 41 Which sum to: 43
83 is prime number.
88 has prime factors: 2, 2, 2, 11 Which sum to: 17
89 is prime number.
90 has prime factors: 2, 3, 3, 5 Which sum to: 13
96 has prime factors: 2, 2, 2, 2, 2, 3 Which sum to: 13
97 is prime number.
99 has prime factors: 3, 3, 11 Which sum to: 17
101 is prime number.
103 is prime number.
104 has prime factors: 2, 2, 2, 13 Which sum to: 19
107 is prime number.
108 has prime factors: 2, 2, 3, 3, 3 Which sum to: 13
109 is prime number.
113 is prime number.
117 has prime factors: 3, 3, 13 Which sum to: 19
118 has prime factors: 2, 59 Which sum to: 61
127 is prime number.
131 is prime number.
136 has prime factors: 2, 2, 2, 17 Which sum to: 23
137 is prime number.
139 is prime number.
142 has prime factors: 2, 71 Which sum to: 73
147 has prime factors: 3, 7, 7 Which sum to: 17
148 has prime factors: 2, 2, 37 Which sum to: 41
149 is prime number.
151 is prime number.
153 has prime factors: 3, 3, 17 Which sum to: 23
157 is prime number.
163 is prime number.
165 has prime factors: 3, 5, 11 Which sum to: 19
167 is prime number.
172 has prime factors: 2, 2, 43 Which sum to: 47
173 is prime number.
175 has prime factors: 5, 5, 7 Which sum to: 17
176 has prime factors: 2, 2, 2, 2, 11 Which sum to: 19
179 is prime number.
181 is prime number.
184 has prime factors: 2, 2, 2, 23 Which sum to: 29
191 is prime number.
193 is prime number.
197 is prime number.
198 has prime factors: 2, 3, 3, 11 Which sum to: 19
199 is prime number.
202 has prime factors: 2, 101 Which sum to: 103
207 has prime factors: 3, 3, 23 Which sum to: 29
210 has prime factors: 2, 3, 5, 7 Which sum to: 17
211 is prime number.
214 has prime factors: 2, 107 Which sum to: 109
223 is prime number.
224 has prime factors: 2, 2, 2, 2, 2, 7 Which sum to: 17
227 is prime number.
229 is prime number.
233 is prime number.
239 is prime number.
241 is prime number.
245 has prime factors: 5, 7, 7 Which sum to: 19
248 has prime factors: 2, 2, 2, 31 Which sum to: 37
250 has prime factors: 2, 5, 5, 5 Which sum to: 17
251 is prime number.
252 has prime factors: 2, 2, 3, 3, 7 Which sum to: 17
257 is prime number.
263 is prime number.
268 has prime factors: 2, 2, 67 Which sum to: 71
269 is prime number.
271 is prime number.
273 has prime factors: 3, 7, 13 Which sum to: 23
274 has prime factors: 2, 137 Which sum to: 139
277 is prime number.
279 has prime factors: 3, 3, 31 Which sum to: 37
281 is prime number.
283 is prime number.
293 is prime number.
294 has prime factors: 2, 3, 7, 7 Which sum to: 19
296 has prime factors: 2, 2, 2, 37 Which sum to: 43
298 has prime factors: 2, 149 Which sum to: 151
300 has prime factors: 2, 2, 3, 5, 5 Which sum to: 17
307 is prime number.
311 is prime number.
313 is prime number.
316 has prime factors: 2, 2, 79 Which sum to: 83
317 is prime number.
320 has prime factors: 2, 2, 2, 2, 2, 2, 5 Which sum to: 17
325 has prime factors: 5, 5, 13 Which sum to: 23
328 has prime factors: 2, 2, 2, 41 Which sum to: 47
331 is prime number.
333 has prime factors: 3, 3, 37 Which sum to: 43
337 is prime number.
345 has prime factors: 3, 5, 23 Which sum to: 31
347 is prime number.
349 is prime number.
350 has prime factors: 2, 5, 5, 7 Which sum to: 19
353 is prime number.
358 has prime factors: 2, 179 Which sum to: 181
359 is prime number.
360 has prime factors: 2, 2, 2, 3, 3, 5 Which sum to: 17
367 is prime number.
368 has prime factors: 2, 2, 2, 2, 23 Which sum to: 31
369 has prime factors: 3, 3, 41 Which sum to: 47
373 is prime number.
376 has prime factors: 2, 2, 2, 47 Which sum to: 53
379 is prime number.
382 has prime factors: 2, 191 Which sum to: 193
383 is prime number.
384 has prime factors: 2, 2, 2, 2, 2, 2, 2, 3 Which sum to: 17
385 has prime factors: 5, 7, 11 Which sum to: 23
388 has prime factors: 2, 2, 97 Which sum to: 101
389 is prime number.
390 has prime factors: 2, 3, 5, 13 Which sum to: 23
394 has prime factors: 2, 197 Which sum to: 199
397 is prime number.
399 has prime factors: 3, 7, 19 Which sum to: 29
401 is prime number.
405 has prime factors: 3, 3, 3, 3, 5 Which sum to: 17
409 is prime number.
412 has prime factors: 2, 2, 103 Which sum to: 107
414 has prime factors: 2, 3, 3, 23 Which sum to: 31
416 has prime factors: 2, 2, 2, 2, 2, 13 Which sum to: 23
419 is prime number.
420 has prime factors: 2, 2, 3, 5, 7 Which sum to: 19
421 is prime number.
423 has prime factors: 3, 3, 47 Which sum to: 53
424 has prime factors: 2, 2, 2, 53 Which sum to: 59
431 is prime number.
432 has prime factors: 2, 2, 2, 2, 3, 3, 3 Which sum to: 17
433 is prime number.
435 has prime factors: 3, 5, 29 Which sum to: 37
436 has prime factors: 2, 2, 109 Which sum to: 113
439 is prime number.
443 is prime number.
448 has prime factors: 2, 2, 2, 2, 2, 2, 7 Which sum to: 19
449 is prime number.
454 has prime factors: 2, 227 Which sum to: 229
457 is prime number.
461 is prime number.
462 has prime factors: 2, 3, 7, 11 Which sum to: 23
463 is prime number.
464 has prime factors: 2, 2, 2, 2, 29 Which sum to: 37
467 is prime number.
468 has prime factors: 2, 2, 3, 3, 13 Which sum to: 23
475 has prime factors: 5, 5, 19 Which sum to: 29
477 has prime factors: 3, 3, 53 Which sum to: 59
478 has prime factors: 2, 239 Which sum to: 241
479 is prime number.
486 has prime factors: 2, 3, 3, 3, 3, 3 Which sum to: 17
487 is prime number.
488 has prime factors: 2, 2, 2, 61 Which sum to: 67
491 is prime number.
499 is prime number.
500 has prime factors: 2, 2, 5, 5, 5 Which sum to: 19
503 is prime number.
504 has prime factors: 2, 2, 2, 3, 3, 7 Which sum to: 19
507 has prime factors: 3, 13, 13 Which sum to: 29
508 has prime factors: 2, 2, 127 Which sum to: 131
509 is prime number.
521 is prime number.
522 has prime factors: 2, 3, 3, 29 Which sum to: 37
523 is prime number.
536 has prime factors: 2, 2, 2, 67 Which sum to: 73
538 has prime factors: 2, 269 Which sum to: 271
541 is prime number.
547 is prime number.
549 has prime factors: 3, 3, 61 Which sum to: 67
550 has prime factors: 2, 5, 5, 11 Which sum to: 23
557 is prime number.
561 has prime factors: 3, 11, 17 Which sum to: 31
562 has prime factors: 2, 281 Which sum to: 283
563 is prime number.
567 has prime factors: 3, 3, 3, 3, 7 Which sum to: 19
569 is prime number.
570 has prime factors: 2, 3, 5, 19 Which sum to: 29
571 is prime number.
577 is prime number.
584 has prime factors: 2, 2, 2, 73 Which sum to: 79
587 is prime number.
593 is prime number.
595 has prime factors: 5, 7, 17 Which sum to: 29
599 is prime number.
600 has prime factors: 2, 2, 2, 3, 5, 5 Which sum to: 19
601 is prime number.
603 has prime factors: 3, 3, 67 Which sum to: 73
607 is prime number.
608 has prime factors: 2, 2, 2, 2, 2, 19 Which sum to: 29
613 is prime number.
617 is prime number.
619 is prime number.
622 has prime factors: 2, 311 Which sum to: 313
631 is prime number.
640 has prime factors: 2, 2, 2, 2, 2, 2, 2, 5 Which sum to: 19
641 is prime number.
643 is prime number.
647 is prime number.
651 has prime factors: 3, 7, 31 Which sum to: 41
652 has prime factors: 2, 2, 163 Which sum to: 167
653 is prime number.
657 has prime factors: 3, 3, 73 Which sum to: 79
659 is prime number.
660 has prime factors: 2, 2, 3, 5, 11 Which sum to: 23
661 is prime number.
664 has prime factors: 2, 2, 2, 83 Which sum to: 89
665 has prime factors: 5, 7, 19 Which sum to: 31
673 is prime number.
675 has prime factors: 3, 3, 3, 5, 5 Which sum to: 19
677 is prime number.
683 is prime number.
684 has prime factors: 2, 2, 3, 3, 19 Which sum to: 29
686 has prime factors: 2, 7, 7, 7 Which sum to: 23
691 is prime number.
694 has prime factors: 2, 347 Which sum to: 349
701 is prime number.
704 has prime factors: 2, 2, 2, 2, 2, 2, 11 Which sum to: 23
709 is prime number.
714 has prime factors: 2, 3, 7, 17 Which sum to: 29
715 has prime factors: 5, 11, 13 Which sum to: 29
719 is prime number.
720 has prime factors: 2, 2, 2, 2, 3, 3, 5 Which sum to: 19
727 is prime number.
733 is prime number.
739 is prime number.
743 is prime number.
747 has prime factors: 3, 3, 83 Which sum to: 89
751 is prime number.
757 is prime number.
759 has prime factors: 3, 11, 23 Which sum to: 37
761 is prime number.
768 has prime factors: 2, 2, 2, 2, 2, 2, 2, 2, 3 Which sum to: 19
769 is prime number.
772 has prime factors: 2, 2, 193 Which sum to: 197
773 is prime number.
775 has prime factors: 5, 5, 31 Which sum to: 41
776 has prime factors: 2, 2, 2, 97 Which sum to: 103
777 has prime factors: 3, 7, 37 Which sum to: 47
787 is prime number.
792 has prime factors: 2, 2, 2, 3, 3, 11 Which sum to: 23
795 has prime factors: 3, 5, 53 Which sum to: 61
797 is prime number.
798 has prime factors: 2, 3, 7, 19 Which sum to: 31
808 has prime factors: 2, 2, 2, 101 Which sum to: 107
809 is prime number.
810 has prime factors: 2, 3, 3, 3, 3, 5 Which sum to: 19
811 is prime number.
821 is prime number.
823 is prime number.
824 has prime factors: 2, 2, 2, 103 Which sum to: 109
827 is prime number.
829 is prime number.
833 has prime factors: 7, 7, 17 Which sum to: 31
838 has prime factors: 2, 419 Which sum to: 421
839 is prime number.
845 has prime factors: 5, 13, 13 Which sum to: 31
847 has prime factors: 7, 11, 11 Which sum to: 29
848 has prime factors: 2, 2, 2, 2, 53 Which sum to: 61
850 has prime factors: 2, 5, 5, 17 Which sum to: 29
853 is prime number.
856 has prime factors: 2, 2, 2, 107 Which sum to: 113
857 is prime number.
858 has prime factors: 2, 3, 11, 13 Which sum to: 29
859 is prime number.
862 has prime factors: 2, 431 Which sum to: 433
863 is prime number.
864 has prime factors: 2, 2, 2, 2, 2, 3, 3, 3 Which sum to: 19
867 has prime factors: 3, 17, 17 Which sum to: 37
873 has prime factors: 3, 3, 97 Which sum to: 103
877 is prime number.
881 is prime number.
883 is prime number.
885 has prime factors: 3, 5, 59 Which sum to: 67
887 is prime number.
891 has prime factors: 3, 3, 3, 3, 11 Which sum to: 23
892 has prime factors: 2, 2, 223 Which sum to: 227
903 has prime factors: 3, 7, 43 Which sum to: 53
907 is prime number.
909 has prime factors: 3, 3, 101 Which sum to: 107
911 is prime number.
916 has prime factors: 2, 2, 229 Which sum to: 233
919 is prime number.
922 has prime factors: 2, 461 Which sum to: 463
925 has prime factors: 5, 5, 37 Which sum to: 47
927 has prime factors: 3, 3, 103 Which sum to: 109
929 is prime number.
930 has prime factors: 2, 3, 5, 31 Which sum to: 41
937 is prime number.
941 is prime number.
944 has prime factors: 2, 2, 2, 2, 59 Which sum to: 67
947 is prime number.
950 has prime factors: 2, 5, 5, 19 Which sum to: 31
953 is prime number.
954 has prime factors: 2, 3, 3, 53 Which sum to: 61
957 has prime factors: 3, 11, 29 Which sum to: 43
963 has prime factors: 3, 3, 107 Which sum to: 113
967 is prime number.
971 is prime number.
972 has prime factors: 2, 2, 3, 3, 3, 3, 3 Which sum to: 19
977 is prime number.
980 has prime factors: 2, 2, 5, 7, 7 Which sum to: 23
983 is prime number.
991 is prime number.
992 has prime factors: 2, 2, 2, 2, 2, 31 Which sum to: 41
997 is prime number.


第 8 章 switch-case和枚举
到这里，我们先停止学习新的语言技巧，转而学习一点更基础的知识 ――选择性执行代码。
（不是所有的东西都像函数和程序设计一样令人兴奋！）你经常会写一长串if-else语句来判断不同的变量，例如： 
在读取用户输入值时，需要判断值是多少；编写游戏时，需要判断按 下的键是上键、下键、左键、右键还是空格键。
本章中，我们将学习如何使用switch-case语句更方便的编写多条件判断代码，也将学习如何创建配合switch-case语句使用的变量类型。
如果单个变量需要和多个整数值进行比较，相对于使用多重嵌套的if语 句，switch-case语句是一个非常好的替代品。
一个整数值可表示为整数类型，比如int型或char型。
下面介绍switch-case语句的基本语法。
switch后的变量在执行时将和每个case之后的值进行比较，当与其中的某个值匹配时，计算机将从匹配的case后的代码开始执行，
直至switch-case模块结束，或遇到break语句。
switch ( <variable> )
{
case this-value:
    // 如果<variable>==this-value执行此处代码
    break;
case that-value:
    // 如果<variable>==that-value执行此处代码
    break;
    // ...
default:
    // 如果<variable>不等于之后的任何case的值，执行此处代码
    break;
}
与给定变量值相等的首个case语句的冒号之后的代码将会执行。如果所有case语句中的值都不和给定变量值相等，
程序将执行default case。default是可选语句，但最好包含它以处理意外case。
请注意每组case代码之后break的使用。break阻止程序顺势而下执行后面的case语句。
不错，这个用法非常奇怪！但它的功能就在此，让程序有选择性地执行某个case代码。
每个case语句的变量必须是整型常量表达式，请注意下面这样是不合法的：
错误代码
int a = 10;
int b = 10;
switch ( a )
{
case b:
    // 代码
    break;
}
如果你尝试编译这段代码，将会看到如下的编译错误：
badcode.cpp:9: error: 'b' cannot appear in a constant-expression
下面是一个使用switch-case的示例程序：
#include <iostream>

using namespace std;

void playgame ()
{
    cout << "This is playgame.\n";
}
void loadgame ()
{
    cout << "This is loadgame.\n";
}
void playmultiplayer ()
{
    cout << "This is playmultiplayer.\n";
}

int main ()
{
    int input;
    cout << "1. Play game\n";
    cout << "2. Load game\n";
    cout << "3. Play multiplayer\n";
    cout << "4. Exit\n";
    cout << "Selection: ";
    cin >> input;
    switch ( input )
    {
    case 1:
        playgame();
        break;
    case 2:
        loadgame();
        break;
    case 3:
        playmultiplayer();
        break;
    case 4:
        cout << "Thank you for playing!\n";
        break;
    default:
        cout << "Error, bad input, quitting\n";
        break;
    }
}
显示结果如下
1. Play game
2. Load game
3. Play multiplayer
4. Exit
Selection: 1
This is playgame.

1. Play game
2. Load game
3. Play multiplayer
4. Exit
Selection: 2
This is loadgame.

1. Play game
2. Load game
3. Play multiplayer
4. Exit
Selection: 3
This is playmultiplayer.

1. Play game
2. Load game
3. Play multiplayer
4. Exit
Selection: 4
Thank you for playing!

1. Play game
2. Load game
3. Play multiplayer
4. Exit
Selection: 5
Error, bad input, quitting

示例代码25：switch.cpp
程序编译通过后将演示依据用户不同输入给出不同输出的简单模型， 这段程序实现的功能非常像游戏《等待戈多》（Waiting for Godot）。
你可能会注意到一个问题，用户在程序结束前只能进行一次选择，如果用户输错了值，就没有再选择的机会。
为了实现再选择，你可以把整个switch-case代码放入一个循环中，但那些break语句该怎么处理？ 它们会让循环退出吗？
当然不会，break语句只会让代码跳转到switch语句的最后。
8.1 比较switch-case和if-else
假设难以理解switch语句的逻辑，那么你可以尝试用if语句代替每个case语句，它们在本质上相同：
if ( 1 == input )
{
    playgame();
}
else if ( 2 == input )
{
    loadgame();
}
else if ( 3 == input )
{
    playmultiplayer();
}
else if ( 4 == input )
{
    cout << "Thank you for playing!\n";
}
else
{
    cout << "Error, bad input, quitting\n";
}
如果能用if-else做同样的事情，为什么还要用switch呢？switch的主要优点是它利用单个变量控制代码路径，可以清晰地显示程序工作流。
而大量使用if-else语句时，每个变量都需要仔细阅读。
8.2 使用枚举创建简单类型
在编程中，有时你想让变量只代表某几个指定的值，且这些值事先已经确定。
例如供用户选择的背景色是一组固定的值。如果能找到一种变量类型可以代表这一系列的常量将非常方便。
此外，这类变量会非常适用于switch-case，因为变量代表的每个值都是已知的。
接下来我们学习枚举变量：enum。enum是“enumerated type”的缩写， 是一系列固定值组合成的新的变量类型。
彩虹颜色就是一个很好的枚举类型：
enum RainbowColor {  RC_RED, RC_ORANGE, RC_YELLOW, RC_GREEN, RC_BLUE, RC_INDIGO, RC_VIOLET };
要点。
1. 关键字enum用来声明一个新的枚举；
2. 每个新的枚举类型有自己的名字；
3. 类型中所有可能的值都被列举出来（我使用前缀RC_以防别人因为某些原因在其他的enum中使用同样的颜色名）；
4. 最后，别忘了分号。
现在你可以像下面这样初始化枚举变量 ：
enum RainbowColor chosen_color = RC_RED;
接着，可以编写如下代码：
switch (chosen_color)
{
case RC_RED:
    /* 红色 */
    break;
case RC_ORANGE:
    /* 橙色 */
    break;
case RC_YELLOW:
    /* 黄色 */
    break;
case RC_GREEN:
    /* 绿色 */
    break;
case RC_BLUE:
    /* 蓝色 */
    break;
case RC_INDIGO:
    /* 靛蓝色 */
    break;
case RC_VIOLET:
    /* 紫色 */
    break;
default: /* 处理错误类型 */
    break;
}
使用枚举类型，我们可以确定覆盖了变量的所有可能值。虽然变量类型的本质是整型，也可以接收枚举之外的值，
但我不建议你用它表示其他的值，这会给程序维护人员带来麻烦。
你可能会奇怪：枚举到底是什么值？如果在声明枚举时没有提供特殊的值，那么值便是上一个枚举值加1，首个枚举的值是0。
此例中，RC_RED是0，RC_ORANGE是1。
你也可以对枚举值进行自定义；如果代码需要使用来自另一个系统的特定值，此时，自定义将会非常有用。
enum RainbowColor {RC_RED = 1, RC_ORANGE = 3, RC_YELLOW = 5, RC_GREEN = 7, RC_BLUE = 9, RC_INDIGO = 11, RC_VIOLET = 13};
枚举用处很大的一个主要原因是枚举允许对硬编码到程序中的值命名。
例如，如果想写一个井字棋游戏，你需要找到表示棋盘上X和O的方法。
你可能使用0代表空格，1代表O，2代表X。如果这么表示，你需要编写一些代码将棋盘上的每个空格与0、1和2比较。
if ( board_position == 1 )
{
    /* 如果是 O，在此处执行一些操作 */
}
这样的代码难以阅读，因为代码中的幻数有特殊含义，仅通过阅读代码很难理解这些数字意味着什么（除非代码中有注释），
而enum可以让你对这些值命名:
enum TicTacToeSquare { TTTS_BLANK, TTTS_O, TTTS_X }; 
 
if ( board_position == TTTS_O ) 
{
    /* 如果是 O，在此处执行一些操作 */
}
只有当未来某些可怜虫要修补bug时（这个可怜虫可能是你！），通读代码才能理解程序要做什么。
枚举比较适合处理固定类型的输入，switch-case比较适合处理用户输入，但这两种语句都不适合处理大量输入数据。
例如，你可能想读取一大堆棒球或足球的统计数据进行处理。这种情况下，你需要的不是switch-case，而是能存储并处理大量数据的方法。
这些是本书第二部分将要提及的。在此之前，我们会多了解一些方法，在不需要处理大量数据时编写程序做一些新鲜有趣的事情。
具体来讲，接下来我们将学习随机数的使用（做游戏时可能会用到）。
问答题
1.紧接着case语句的是什么？
A. :
B. ;
C. 
D. 新的一行代码

A
2.避免从一个case执行到另一个case需要什么？
A. end;
B. break;
C. Stop;
D. 分号

B
3.哪个关键字用来处理未知情况？
A. all
B. contingency
C. default
D. other

C
4.下面代码的运行结果是？
int x = 0;
switch( x )
{
case 1:
    cout << "One";
case 0:
    cout << "Zero";
case 2:
    cout << "Hello World";
}

A. One
B. Zero
C. Hello World
D. ZeroHello World

D
实践题
1.用switch-case重写第6章中的“菜单程序”。

#include <iostream>
#include <string>

using namespace std;

void SingNinetyNineBottlesSong()
{
    for (size_t beer = 99; beer > 0; beer--)
    {
        if (beer != 99)
        {
            cout << beer << " bottles of beer on the wall.\n";
        }
        cout << beer << " bottles of beer on the wall, " << beer << " bottles of beer.\n" <<
             "Take one down, pass it around...\n";
    }
}

int logIn()
{
    string password = "guest";
    string userInput = "";
    int attemptLimit = 5;

    for (size_t attempts = 0; attempts < attemptLimit; attempts++)
    {
        if (attempts > 0)
        {
            cout << "You entered an incorrect password! \n" <<
                 "Attempts remaining: " << attemptLimit - attempts << "\n";
        }
        cout << "Please enter your password" << "\n";
        cin >> userInput;
        if (userInput == password)
        {
            cout << "Congratulations! You have been granted access..." << "\n";
            return 0;
        }
    }
    cout << "Sadly we can't let you in. Goodbye :-( " << "\n";
    return 1;
}

int selectBeerChoice(string beerOptions[])
{
    int beerChoice = 0;

    cout << "Please specify which type of beer you would like:\n";
    cout << "\n\t " << "1 - " << beerOptions[0];
    cout << "\n\t " << "2 - " << beerOptions[1];
    cout << "\n\t " << "3 - " << beerOptions[2];
    cout << "\n\t " << "4 - " << beerOptions[3] << endl;

    cin >> beerChoice;
    return beerChoice;
}

bool validBeerChoice(int beerChoice)
{
    bool isValid = false;
    switch (beerChoice)
    {
    case 1:
        isValid = true;
        break;
    case 2:
        isValid = true;
        break;
    case 3:
        isValid = true;
        break;
    case 4:
        isValid = true;
        break;
    default:
        break;
    }
    return isValid;
}

int main()
{
    if (logIn() == 1)
    {
        return 1;
    }

    cin.clear();
    cin.ignore(80, '\n');

    string beerOptions[4] = { "Stout", "IPA", "Wheat Beer", "Ale" };
    int beerChoice = 0;

    do
    {
        beerChoice = selectBeerChoice(beerOptions);
    }
    while (!validBeerChoice(beerChoice));

    cout << "Good choice!" << endl;

    SingNinetyNineBottlesSong();
}

显示结果如下
Please enter your password
Hello
You entered an incorrect password!
Attempts remaining: 4
Please enter your password
World
You entered an incorrect password!
Attempts remaining: 3
Please enter your password
guest
Congratulations! You have been granted access...
Please specify which type of beer you would like:

         1 - Stout
         2 - IPA
         3 - Wheat Beer
         4 - Ale
3
Good choice!
99 bottles of beer on the wall, 99 bottles of beer.
Take one down, pass it around...
98 bottles of beer on the wall.
98 bottles of beer on the wall, 98 bottles of beer.
Take one down, pass it around...
97 bottles of beer on the wall.
97 bottles of beer on the wall, 97 bottles of beer.
Take one down, pass it around...
96 bottles of beer on the wall.
96 bottles of beer on the wall, 96 bottles of beer.
Take one down, pass it around...
95 bottles of beer on the wall.
95 bottles of beer on the wall, 95 bottles of beer.
Take one down, pass it around...
94 bottles of beer on the wall.
94 bottles of beer on the wall, 94 bottles of beer.
Take one down, pass it around...
93 bottles of beer on the wall.
93 bottles of beer on the wall, 93 bottles of beer.
Take one down, pass it around...
92 bottles of beer on the wall.
92 bottles of beer on the wall, 92 bottles of beer.
Take one down, pass it around...
91 bottles of beer on the wall.
91 bottles of beer on the wall, 91 bottles of beer.
Take one down, pass it around...
90 bottles of beer on the wall.
90 bottles of beer on the wall, 90 bottles of beer.
Take one down, pass it around...
89 bottles of beer on the wall.
89 bottles of beer on the wall, 89 bottles of beer.
Take one down, pass it around...
88 bottles of beer on the wall.
88 bottles of beer on the wall, 88 bottles of beer.
Take one down, pass it around...
87 bottles of beer on the wall.
87 bottles of beer on the wall, 87 bottles of beer.
Take one down, pass it around...
86 bottles of beer on the wall.
86 bottles of beer on the wall, 86 bottles of beer.
Take one down, pass it around...
85 bottles of beer on the wall.
85 bottles of beer on the wall, 85 bottles of beer.
Take one down, pass it around...
84 bottles of beer on the wall.
84 bottles of beer on the wall, 84 bottles of beer.
Take one down, pass it around...
83 bottles of beer on the wall.
83 bottles of beer on the wall, 83 bottles of beer.
Take one down, pass it around...
82 bottles of beer on the wall.
82 bottles of beer on the wall, 82 bottles of beer.
Take one down, pass it around...
81 bottles of beer on the wall.
81 bottles of beer on the wall, 81 bottles of beer.
Take one down, pass it around...
80 bottles of beer on the wall.
80 bottles of beer on the wall, 80 bottles of beer.
Take one down, pass it around...
79 bottles of beer on the wall.
79 bottles of beer on the wall, 79 bottles of beer.
Take one down, pass it around...
78 bottles of beer on the wall.
78 bottles of beer on the wall, 78 bottles of beer.
Take one down, pass it around...
77 bottles of beer on the wall.
77 bottles of beer on the wall, 77 bottles of beer.
Take one down, pass it around...
76 bottles of beer on the wall.
76 bottles of beer on the wall, 76 bottles of beer.
Take one down, pass it around...
75 bottles of beer on the wall.
75 bottles of beer on the wall, 75 bottles of beer.
Take one down, pass it around...
74 bottles of beer on the wall.
74 bottles of beer on the wall, 74 bottles of beer.
Take one down, pass it around...
73 bottles of beer on the wall.
73 bottles of beer on the wall, 73 bottles of beer.
Take one down, pass it around...
72 bottles of beer on the wall.
72 bottles of beer on the wall, 72 bottles of beer.
Take one down, pass it around...
71 bottles of beer on the wall.
71 bottles of beer on the wall, 71 bottles of beer.
Take one down, pass it around...
70 bottles of beer on the wall.
70 bottles of beer on the wall, 70 bottles of beer.
Take one down, pass it around...
69 bottles of beer on the wall.
69 bottles of beer on the wall, 69 bottles of beer.
Take one down, pass it around...
68 bottles of beer on the wall.
68 bottles of beer on the wall, 68 bottles of beer.
Take one down, pass it around...
67 bottles of beer on the wall.
67 bottles of beer on the wall, 67 bottles of beer.
Take one down, pass it around...
66 bottles of beer on the wall.
66 bottles of beer on the wall, 66 bottles of beer.
Take one down, pass it around...
65 bottles of beer on the wall.
65 bottles of beer on the wall, 65 bottles of beer.
Take one down, pass it around...
64 bottles of beer on the wall.
64 bottles of beer on the wall, 64 bottles of beer.
Take one down, pass it around...
63 bottles of beer on the wall.
63 bottles of beer on the wall, 63 bottles of beer.
Take one down, pass it around...
62 bottles of beer on the wall.
62 bottles of beer on the wall, 62 bottles of beer.
Take one down, pass it around...
61 bottles of beer on the wall.
61 bottles of beer on the wall, 61 bottles of beer.
Take one down, pass it around...
60 bottles of beer on the wall.
60 bottles of beer on the wall, 60 bottles of beer.
Take one down, pass it around...
59 bottles of beer on the wall.
59 bottles of beer on the wall, 59 bottles of beer.
Take one down, pass it around...
58 bottles of beer on the wall.
58 bottles of beer on the wall, 58 bottles of beer.
Take one down, pass it around...
57 bottles of beer on the wall.
57 bottles of beer on the wall, 57 bottles of beer.
Take one down, pass it around...
56 bottles of beer on the wall.
56 bottles of beer on the wall, 56 bottles of beer.
Take one down, pass it around...
55 bottles of beer on the wall.
55 bottles of beer on the wall, 55 bottles of beer.
Take one down, pass it around...
54 bottles of beer on the wall.
54 bottles of beer on the wall, 54 bottles of beer.
Take one down, pass it around...
53 bottles of beer on the wall.
53 bottles of beer on the wall, 53 bottles of beer.
Take one down, pass it around...
52 bottles of beer on the wall.
52 bottles of beer on the wall, 52 bottles of beer.
Take one down, pass it around...
51 bottles of beer on the wall.
51 bottles of beer on the wall, 51 bottles of beer.
Take one down, pass it around...
50 bottles of beer on the wall.
50 bottles of beer on the wall, 50 bottles of beer.
Take one down, pass it around...
49 bottles of beer on the wall.
49 bottles of beer on the wall, 49 bottles of beer.
Take one down, pass it around...
48 bottles of beer on the wall.
48 bottles of beer on the wall, 48 bottles of beer.
Take one down, pass it around...
47 bottles of beer on the wall.
47 bottles of beer on the wall, 47 bottles of beer.
Take one down, pass it around...
46 bottles of beer on the wall.
46 bottles of beer on the wall, 46 bottles of beer.
Take one down, pass it around...
45 bottles of beer on the wall.
45 bottles of beer on the wall, 45 bottles of beer.
Take one down, pass it around...
44 bottles of beer on the wall.
44 bottles of beer on the wall, 44 bottles of beer.
Take one down, pass it around...
43 bottles of beer on the wall.
43 bottles of beer on the wall, 43 bottles of beer.
Take one down, pass it around...
42 bottles of beer on the wall.
42 bottles of beer on the wall, 42 bottles of beer.
Take one down, pass it around...
41 bottles of beer on the wall.
41 bottles of beer on the wall, 41 bottles of beer.
Take one down, pass it around...
40 bottles of beer on the wall.
40 bottles of beer on the wall, 40 bottles of beer.
Take one down, pass it around...
39 bottles of beer on the wall.
39 bottles of beer on the wall, 39 bottles of beer.
Take one down, pass it around...
38 bottles of beer on the wall.
38 bottles of beer on the wall, 38 bottles of beer.
Take one down, pass it around...
37 bottles of beer on the wall.
37 bottles of beer on the wall, 37 bottles of beer.
Take one down, pass it around...
36 bottles of beer on the wall.
36 bottles of beer on the wall, 36 bottles of beer.
Take one down, pass it around...
35 bottles of beer on the wall.
35 bottles of beer on the wall, 35 bottles of beer.
Take one down, pass it around...
34 bottles of beer on the wall.
34 bottles of beer on the wall, 34 bottles of beer.
Take one down, pass it around...
33 bottles of beer on the wall.
33 bottles of beer on the wall, 33 bottles of beer.
Take one down, pass it around...
32 bottles of beer on the wall.
32 bottles of beer on the wall, 32 bottles of beer.
Take one down, pass it around...
31 bottles of beer on the wall.
31 bottles of beer on the wall, 31 bottles of beer.
Take one down, pass it around...
30 bottles of beer on the wall.
30 bottles of beer on the wall, 30 bottles of beer.
Take one down, pass it around...
29 bottles of beer on the wall.
29 bottles of beer on the wall, 29 bottles of beer.
Take one down, pass it around...
28 bottles of beer on the wall.
28 bottles of beer on the wall, 28 bottles of beer.
Take one down, pass it around...
27 bottles of beer on the wall.
27 bottles of beer on the wall, 27 bottles of beer.
Take one down, pass it around...
26 bottles of beer on the wall.
26 bottles of beer on the wall, 26 bottles of beer.
Take one down, pass it around...
25 bottles of beer on the wall.
25 bottles of beer on the wall, 25 bottles of beer.
Take one down, pass it around...
24 bottles of beer on the wall.
24 bottles of beer on the wall, 24 bottles of beer.
Take one down, pass it around...
23 bottles of beer on the wall.
23 bottles of beer on the wall, 23 bottles of beer.
Take one down, pass it around...
22 bottles of beer on the wall.
22 bottles of beer on the wall, 22 bottles of beer.
Take one down, pass it around...
21 bottles of beer on the wall.
21 bottles of beer on the wall, 21 bottles of beer.
Take one down, pass it around...
20 bottles of beer on the wall.
20 bottles of beer on the wall, 20 bottles of beer.
Take one down, pass it around...
19 bottles of beer on the wall.
19 bottles of beer on the wall, 19 bottles of beer.
Take one down, pass it around...
18 bottles of beer on the wall.
18 bottles of beer on the wall, 18 bottles of beer.
Take one down, pass it around...
17 bottles of beer on the wall.
17 bottles of beer on the wall, 17 bottles of beer.
Take one down, pass it around...
16 bottles of beer on the wall.
16 bottles of beer on the wall, 16 bottles of beer.
Take one down, pass it around...
15 bottles of beer on the wall.
15 bottles of beer on the wall, 15 bottles of beer.
Take one down, pass it around...
14 bottles of beer on the wall.
14 bottles of beer on the wall, 14 bottles of beer.
Take one down, pass it around...
13 bottles of beer on the wall.
13 bottles of beer on the wall, 13 bottles of beer.
Take one down, pass it around...
12 bottles of beer on the wall.
12 bottles of beer on the wall, 12 bottles of beer.
Take one down, pass it around...
11 bottles of beer on the wall.
11 bottles of beer on the wall, 11 bottles of beer.
Take one down, pass it around...
10 bottles of beer on the wall.
10 bottles of beer on the wall, 10 bottles of beer.
Take one down, pass it around...
9 bottles of beer on the wall.
9 bottles of beer on the wall, 9 bottles of beer.
Take one down, pass it around...
8 bottles of beer on the wall.
8 bottles of beer on the wall, 8 bottles of beer.
Take one down, pass it around...
7 bottles of beer on the wall.
7 bottles of beer on the wall, 7 bottles of beer.
Take one down, pass it around...
6 bottles of beer on the wall.
6 bottles of beer on the wall, 6 bottles of beer.
Take one down, pass it around...
5 bottles of beer on the wall.
5 bottles of beer on the wall, 5 bottles of beer.
Take one down, pass it around...
4 bottles of beer on the wall.
4 bottles of beer on the wall, 4 bottles of beer.
Take one down, pass it around...
3 bottles of beer on the wall.
3 bottles of beer on the wall, 3 bottles of beer.
Take one down, pass it around...
2 bottles of beer on the wall.
2 bottles of beer on the wall, 2 bottles of beer.
Take one down, pass it around...
1 bottles of beer on the wall.
1 bottles of beer on the wall, 1 bottles of beer.
Take one down, pass it around...

2.使用switch-case编写程序输出The Twelve Days of Christmas的所有歌词。

#include <iostream>
#include <string>

using namespace std;

string currentDay(int dayNumber);

int main()
{
	for (size_t i = 1; i <= 12; i++)
	{
		string day = currentDay(i);
		cout << "On the " << day << " day of Christmas, " <<
			"My true love sent to me\n";

		switch (i)
		{
			case 12:
				cout << "Twelve drummers drumming,\n";
			case 11:
				cout << "Eleven pipers piping,\n";
			case 10:
				cout << "Ten lords a-leaping,\n";
			case 9:
				cout << "Nine ladies dancing,\n";
			case 8:
				cout << "Eight maids a-milking,\n";
			case 7:
				cout << "Seven swans a-swimming,\n";
			case 6:
				cout << "Six geese a-laying,\n";
			case 5:
				cout << "Five golden rings,\n";
			case 4:
				cout << "Four calling birds,\n";
			case 3:
				cout << "Three French hens,\n";
			case 2:
				cout << "Two turtle doves,\n";
			default:
				break;
		}

		string ending = " partridge in a pear tree.\n\n";
		if (i == 1)
		{
			ending = "A" + ending;
		}
		else
		{
			ending = "And a" + ending;
		}
		cout << ending;
	}
}

string currentDay(int dayNumber)
{
	string day = "";
	switch (dayNumber)
	{
	case 1:
		day = "first";
		break;
	case 2:
		day = "second";
		break;
	case 3:
		day = "third";
		break;
	case 4:
		day = "fourth";
		break;
	case 5:
		day = "fifth";
		break;
	case 6:
		day = "sixth";
		break;
	case 7:
		day = "seventh";
		break;
	case 8:
		day = "eighth";
		break;
	case 9:
		day = "ninth";
		break;
	case 10:
		day = "tenth";
		break;
	case 11:
		day = "eleventh";
		break;
	case 12:
		day = "twelfth";
		break;
	}
	return day;
}

显示结果如下
On the first day of Christmas, My true love sent to me
A partridge in a pear tree.

On the second day of Christmas, My true love sent to me
Two turtle doves,
And a partridge in a pear tree.

On the third day of Christmas, My true love sent to me
Three French hens,
Two turtle doves,
And a partridge in a pear tree.

On the fourth day of Christmas, My true love sent to me
Four calling birds,
Three French hens,
Two turtle doves,
And a partridge in a pear tree.

On the fifth day of Christmas, My true love sent to me
Five golden rings,
Four calling birds,
Three French hens,
Two turtle doves,
And a partridge in a pear tree.

On the sixth day of Christmas, My true love sent to me
Six geese a-laying,
Five golden rings,
Four calling birds,
Three French hens,
Two turtle doves,
And a partridge in a pear tree.

On the seventh day of Christmas, My true love sent to me
Seven swans a-swimming,
Six geese a-laying,
Five golden rings,
Four calling birds,
Three French hens,
Two turtle doves,
And a partridge in a pear tree.

On the eighth day of Christmas, My true love sent to me
Eight maids a-milking,
Seven swans a-swimming,
Six geese a-laying,
Five golden rings,
Four calling birds,
Three French hens,
Two turtle doves,
And a partridge in a pear tree.

On the ninth day of Christmas, My true love sent to me
Nine ladies dancing,
Eight maids a-milking,
Seven swans a-swimming,
Six geese a-laying,
Five golden rings,
Four calling birds,
Three French hens,
Two turtle doves,
And a partridge in a pear tree.

On the tenth day of Christmas, My true love sent to me
Ten lords a-leaping,
Nine ladies dancing,
Eight maids a-milking,
Seven swans a-swimming,
Six geese a-laying,
Five golden rings,
Four calling birds,
Three French hens,
Two turtle doves,
And a partridge in a pear tree.

On the eleventh day of Christmas, My true love sent to me
Eleven pipers piping,
Ten lords a-leaping,
Nine ladies dancing,
Eight maids a-milking,
Seven swans a-swimming,
Six geese a-laying,
Five golden rings,
Four calling birds,
Three French hens,
Two turtle doves,
And a partridge in a pear tree.

On the twelfth day of Christmas, My true love sent to me
Twelve drummers drumming,
Eleven pipers piping,
Ten lords a-leaping,
Nine ladies dancing,
Eight maids a-milking,
Seven swans a-swimming,
Six geese a-laying,
Five golden rings,
Four calling birds,
Three French hens,
Two turtle doves,
And a partridge in a pear tree.

3.编写两个玩家的井字棋游戏，允许两人对抗；使用枚举代表棋盘的值。

#include <iostream>
#include <string>

using namespace std;

enum TicTacToeSquare
{
    TTTS_Blank,
    TTTS_O,
    TTTS_X
};

string setPlayer(bool playerXInSession);
bool validIndex(int boardPosition);
bool choiceTaken(int boardPosition);
void setChoice(int boardPosition, bool playerXInSession);
enum TicTacToeSquare choiceSquare(bool playerXInSession);
bool choiceWins(bool playerXInSession);

enum TicTacToeSquare square11 = TTTS_Blank;
enum TicTacToeSquare square12 = TTTS_Blank;
enum TicTacToeSquare square13 = TTTS_Blank;

enum TicTacToeSquare square21 = TTTS_Blank;
enum TicTacToeSquare square22 = TTTS_Blank;
enum TicTacToeSquare square23 = TTTS_Blank;

enum TicTacToeSquare square31 = TTTS_Blank;
enum TicTacToeSquare square32 = TTTS_Blank;
enum TicTacToeSquare square33 = TTTS_Blank;

int main()
{
    bool gameFinished = false;
    bool playerXInSession = true;
    string player = "";
    int boardPosition = 0;
    int choiceCount = 0;

    do
    {
        if (choiceCount == 9)
        {
            square11 = TTTS_Blank;
            square12 = TTTS_Blank;
            square13 = TTTS_Blank;

            square21 = TTTS_Blank;
            square22 = TTTS_Blank;
            square23 = TTTS_Blank;

            square31 = TTTS_Blank;
            square32 = TTTS_Blank;
            square33 = TTTS_Blank;

            choiceCount = 0;
        }
        boardPosition = 0;
        player = setPlayer(playerXInSession);

        cout << "Tic-Tac-Toe\n";
        cout << "_______\n";
        cout << "|" << square11 << "|" << square12 << "|" << square13 << "|\n";
        cout << "_______\n";
        cout << "|" << square21 << "|" << square22 << "|" << square23 << "|\n";
        cout << "_______\n";
        cout << "|" << square31 << "|" << square32 << "|" << square33 << "|\n";
        cout << "_______\n\n";

        cout << "Player " << player << ", choose your next move by entering the index of the board position to claim:\n";
        cout << "_______\n";
        cout << "|11|12|13|\n";
        cout << "_______\n";
        cout << "|21|22|23|\n";
        cout << "_______\n";
        cout << "|31|32|33|\n";
        cout << "_______\n\n";

        cin >> boardPosition;
        if (!validIndex(boardPosition))
        {
            cout << "That is an invalid choice. Please try again.\n";
            continue;
        }

        if (choiceTaken(boardPosition))
        {
            cout << "That square is already taken. Please try again.\n";
            continue;
        }

        setChoice(boardPosition, playerXInSession);
        choiceCount++;

        if (choiceWins(playerXInSession))
        {
            cout << "Player " << player << " wins!\n";
            gameFinished = true;
        }

        playerXInSession = !playerXInSession;
    }
    while (!gameFinished);
}

string setPlayer(bool playerXInSession)
{
    if (playerXInSession)
    {
        return "X";
    }
    return "O";
}

bool validIndex(int boardPosition)
{
    return ((boardPosition == 11) || (boardPosition == 12) || (boardPosition == 13) ||
            (boardPosition == 21) || (boardPosition == 22) || (boardPosition == 23) ||
            (boardPosition == 31) || (boardPosition == 32) || (boardPosition == 33));
}

bool choiceTaken(int boardPosition)
{
    switch(boardPosition)
    {
    case 11:
        return square11 != TTTS_Blank;
    case 12:
        return square12 != TTTS_Blank;
    case 13:
        return square13 != TTTS_Blank;
    case 21:
        return square21 != TTTS_Blank;
    case 22:
        return square22 != TTTS_Blank;
    case 23:
        return square23 != TTTS_Blank;
    case 31:
        return square31 != TTTS_Blank;
    case 32:
        return square32 != TTTS_Blank;
    case 33:
        return square33 != TTTS_Blank;
    default:
        return true;
    }
}

void setChoice(int boardPosition, bool playerXInSession)
{
    switch (boardPosition)
    {
    case 11:
        square11 = choiceSquare(playerXInSession);
        break;
    case 12:
        square12 = choiceSquare(playerXInSession);
        break;
    case 13:
        square13 = choiceSquare(playerXInSession);
        break;
    case 21:
        square21 = choiceSquare(playerXInSession);
        break;
    case 22:
        square22 = choiceSquare(playerXInSession);
        break;
    case 23:
        square23 = choiceSquare(playerXInSession);
        break;
    case 31:
        square31 = choiceSquare(playerXInSession);
        break;
    case 32:
        square32 = choiceSquare(playerXInSession);
        break;
    case 33:
        square33 = choiceSquare(playerXInSession);
        break;
    default:
        break;
    }
}

enum TicTacToeSquare choiceSquare(bool playerXInSession)
{
    if (playerXInSession)
    {
        return TTTS_X;
    }
    return TTTS_O;
}

bool choiceWins(bool playerXInSession)
{
    double result = 0;
    enum TicTacToeSquare choiceCheck = choiceSquare(playerXInSession);;

    // Check rows
    result = (square11 == choiceCheck) && (square12 == choiceCheck) && (square13 == choiceCheck);
    if (result == 1)
    {
        return true;
    }

    result = (square21 == choiceCheck) && (square22 == choiceCheck) && (square23 == choiceCheck);
    if (result == 1)
    {
        return true;
    }

    result = (square31 == choiceCheck) && (square32 == choiceCheck) && (square33 == choiceCheck);
    if (result == 1)
    {
        return true;
    }

    // Check columns
    result = (square11 == choiceCheck) && (square21 == choiceCheck) && (square31 == choiceCheck);
    if (result == 1)
    {
        return true;
    }

    result = (square12 == choiceCheck) && (square22 == choiceCheck) && (square32 == choiceCheck);
    if (result == 1)
    {
        return true;
    }

    result = (square13 == choiceCheck) && (square23 == choiceCheck) && (square33 == choiceCheck);
    if (result == 1)
    {
        return true;
    }

    // Check diagonals
    result = (square11 == choiceCheck) && (square22 == choiceCheck) && (square33 == choiceCheck);
    if (result == 1)
    {
        return true;
    }

    result = (square13 == choiceCheck) && (square22 == choiceCheck) && (square31 == choiceCheck);
    if (result == 1)
    {
        return true;
    }

    return false;
}

显示结果如下
Tic-Tac-Toe
_______
|0|0|0|
_______
|0|0|0|
_______
|0|0|0|
_______

Player X, choose your next move by entering the index of the board position to claim:
_______
|11|12|13|
_______
|21|22|23|
_______
|31|32|33|
_______

21
Tic-Tac-Toe
_______
|0|0|0|
_______
|2|0|0|
_______
|0|0|0|
_______

Player O, choose your next move by entering the index of the board position to claim:
_______
|11|12|13|
_______
|21|22|23|
_______
|31|32|33|
_______

13
Tic-Tac-Toe
_______
|0|0|1|
_______
|2|0|0|
_______
|0|0|0|
_______

Player X, choose your next move by entering the index of the board position to claim:
_______
|11|12|13|
_______
|21|22|23|
_______
|31|32|33|
_______

22
Tic-Tac-Toe
_______
|0|0|1|
_______
|2|2|0|
_______
|0|0|0|
_______

Player O, choose your next move by entering the index of the board position to claim:
_______
|11|12|13|
_______
|21|22|23|
_______
|31|32|33|
_______

23
Tic-Tac-Toe
_______
|0|0|1|
_______
|2|2|1|
_______
|0|0|0|
_______

Player X, choose your next move by entering the index of the board position to claim:
_______
|11|12|13|
_______
|21|22|23|
_______
|31|32|33|
_______

11
Tic-Tac-Toe
_______
|2|0|1|
_______
|2|2|1|
_______
|0|0|0|
_______

Player O, choose your next move by entering the index of the board position to claim:
_______
|11|12|13|
_______
|21|22|23|
_______
|31|32|33|
_______

33
Player O wins!


第 9 章 随机
有两种方法可以让你的程序每次运行结果不同：
1.让用户输入不同的数据（或者从文件中读取不同的数据）； 
2.对用户输入的相同数据采取不同的处理方式，使其运行结果不同。
大多数情况下，第一种方法是非常好的，用户总是希望他们程序的结果是可预测的。
比如当编写一个文本编辑器或者网页浏览器时，你会希望程序在用户每次输入一段文本或网址时执行同样的操作，
而不是由浏览器随机决定访问哪个页面。
但在某些情况，每次执行相同操作并不是一个好的处理方式。例如， 很多电脑游戏依赖随机，俄罗斯方块便是一个典型的例子，
如果每次游戏方块的下落顺序都相同，用户便会记住下落顺序，因为可以预测接下来会出现什么方块，所以得分会一次比一次高。
最后游戏和背诵圆周率的千位小数没啥不同。为了让俄罗斯方块游戏更有意思，程序需要随机选择下一次方块的形状和朝向。
为了实现这个功能，计算机需要生成随机数。因为计算机会准确执行命令，当我们执行相同的操作时计算机总会返回同样的结果。
这就很难生成真正的随机数。不过没有必要生成真的随机数。生成像随机数的数也能达到目的，这就是伪随机数。
要生成伪随机数，计算机需要一个种子，利用数学变换将种子转换成另一个值。
新值再成为下一个种子。如果程序每次采用不同的种子， 程序便永远不会生成相同的数据序列。
这里使用的数学转换需要特别挑选，要让所有数字的生成概率相等但又不会有明显的计算模型。 （例如，它不会只是每次对数字加1。）
C++提供了所有的功能。你无需关心数学转换，C++中有相关的函数实现。
所有你要做的只是提供随机种子，使用当前时间作种子即可。 让我们看一下细节：
9.1 获得随机数
C++有两个函数，一个是设置随机种子，另一个是用种子产生随机数：
void srand (int seed);
srand函数将某个数字设置为种子。在程序开头处需要调用一次srand。使用srand的典型方法是把time函数的结果作为参数，
time函数返回一个代表当前时间的数值：
time函数返回从1970年1月1日起到现在的秒数。这个规则源自于Unix操作系统，有时它称为Unix time。
大多数情况下，时间存储在32位有符号整型中。随着时间的增加，秒数会超过整型可表示的范围，最后将以负数结尾表示过去的时间。
超过整型数的现象将发生在2038年，它引起了对“2038年问题”（Year 2038 Problem）的讨论， 
使用Unix time的计算机程序将会把2038年当做1901年处理。详情请参考：http://en.wikipedia.org/wiki/Year_2038_problem。
srand ( time ( NULL ) );
目前你不用了解NULL参数，先就照着这么写；在后面关于指针的一章 中会介绍很多关于它的内容。
如果连续调用srand，程序会反复地更新随机数发生器种子，因为连续调用的时间序列非常相近，生成的随机数也会很相近。
（使用srand必须包含cstdlib头文件，使用time函数必须包含ctime头文件。）
#include <cstdlib>
#include <ctime>

int main ()
{
    //在最开始处调用一次
    srand( time( NULL ) );
}
示例代码26：srand.cpp
参照下面原型调用rand函数来获取随机数。
int rand ();
注意rand函数没有任何参数，仅有一个返回值。让我们将返回值输出出来。
#include <cstdlib>
#include <ctime>
#include <iostream>

using namespace std;

int main ()
{
    srand( time( NULL ) );
    cout << rand() << '\n';
}
示例代码27：rand.cpp
太好了！程序每次运行结果都不同，这意味着你可以玩上好几小时的猜数字游戏！
不过，这游戏可能也不那么令人兴奋，毕竟数字的范围太大了。如果数字能设定在某个范围内，你可以做更有趣的事情。
原本调用rand函 数会返回从0到常量RAND_MAX之间的某个值（RAND_MAX至少是32 767 ）。
这个范围很大，你可能只需要其中的一小部分，有个解决方案是循环调用rand函数，直到它返回规定范围内的值。
int randRange (int low, int high)
{
    while ( 1 )
    {
        int rand_result = rand();
        if ( rand_result >= low && rand_result <= high )
        {
            return rand_result;
        }
    }
}
但这个办法非常糟糕！首先是慢，如果想获取1到4之间的数字，程序要花费漫长的时间来获取这小范围内的数字，
因为rand返回值的范围实在太大。其次是无法保证程序会顺利结束，程序可能（尽管这不太可能）永远无法获取所需范围内的值。
这儿有一个更好的方法使你不必冒这个险。
C++有一个返回除法余数的操作符（如4/3商为1，余数为1）――模数运算符。
之前的几章中我们曾使用它判断质数。如果你没有注意到也不要紧，人们总是自动屏蔽数学函数。但模数非常有用。
因为被4整除的余数的范围是0~3。如果用rand函数返回的随机数除以所需数字的范围长度（即范围内数的数量），
便会获得0到最大范围之间的值 （不包含最大值）。
例如：
#include <ctime>
#include <cstdlib>
#include <iostream>

using namespace std;

int randRange (int low, int high)
{
    return rand() % ( high - low + 1 ) + low;
}

int main ()
{
    int i;
    srand( time( NULL ) );

    for ( i = 0; i < 1000; ++i )
    {
        cout.width (10);
        cout.flags(ios::right);
        cout << randRange( 4, 10 );
        if (i % 8 == 7)
        {
            cout << endl;
        }
    }
    if (i % 8 != 0)
    {
        cout << endl;
    }
}
示例代码28：modulus.cpp
显示结果如下
         5         8         7         9        10         8         9         7
        10         7         4         4         4         5         8         9
         5         8         9         6         4         5         8         5
         5        10         6         9         6         6         8         7
         8         9         6         6         4         9         7        10
         6         7         9         4         7         4        10         8
         9         8        10         7         8         5         8         9
        10         4         7         5         4         9         8         6
         5         8         8         5         7         9        10         7
         6         8         7         9         8         6         6         4
         9         4         7         4         5        10         7         4
         8        10        10         8         6         8         8         7
         5         4         8         6         9         7         9         4
         9         6         9         5         6        10         5         9
        10         7         9         9         6         5         8        10
         9         7         5         9         9         7         5         9
         7         8         4         6         9         8         4         8
         8         8         9        10         7         8         7         4
         4        10         7         4         5         9         8         8
         4         7         7         9         4         6         5         7
         8         4         7         7         8         6         4         5
        10         7         9         4         4         5         9        10
         5         5        10         4         9         6         6         9
         9         7         5         7         8         7         9         5
         5         5         8         9         7         6         8         4
         9         6         4        10         6         9         9         5
         9         6        10         7         8        10        10         5
         7         4         8         4         5         4        10         6
         4         8         9         7        10         6         6         9
         7         6         6         7        10         9         8         8
         4         5         9         7         4         8         6         5
         6         8        10         8         9        10        10         9
         5         7        10         4         9         5         7        10
         6         7         6         5         5         8         7         6
         7         5         7         6         7         9         7         9
         6         5         4         4         4         9         7         5
         5         7        10         8         8         5         8         8
         8         8         9        10         4         5        10         7
         4         4         9         5         9         6         4         9
         5         4         8         5         7         4         4         8
         7         8         6        10         9         8         7         7
         5         4         4         5        10        10         7         4
        10         5        10         6         5        10         4         6
         9         8         5         5         7         5         8         8
        10         8         7         8         5         9         9         4
         9         9         4         8         6         7         6        10
         8         6         5         8        10         4        10         6
         6        10         6         9         4        10         7         8
         7         8         4         6         6         9         6         9
         6         4         7         6         7         7         6        10
         7         5         7         7         5         4         9         6
        10         4         4         9         8         5         6         9
        10         4         4        10        10         5         9        10
         5        10         5         7         4         5         6         8
         7         9         4         8         7         7         8         7
         6         9        10        10         8         5         7         7
         6         5         5        10         6         8         7         6
         7         6         9         5         8         9         9         4
         7         9         6         8         4         4         9         6
         7         8        10         4        10         6         6        10
         8         7         7         8         4        10         8         5
         5         4         6         9         9         5         7        10
         8        10         8         6         8         6         8         4
         4         6         9         8         8         4         7        10
         7        10         6         5         7         8         4         8
         9         7         5         7         6         8         7        10
         5         4         6         9         4         8         7         4
        10         6         8         6         6         9        10         8
         6        10         7         9         8         8         7         6
         4         8         7         6        10         8        10         5
         6        10         8         7         6         5         5         5
         7         8         5         7         6         5         9         9
         9         6         7         6        10         8         6        10
        10         8        10         8         5         7         9         8
         5         4         9         7         5        10         8         6
         7         8         8        10         9         6         6         7
         8         7         8         7         5         8         4         9
         5         8         6         7         5         9         9         6
        10         7         9         9         6         4         5         8
         8         9         7         4         4         7         6         9
        10         8        10         9         5         4         8         7
         6         8        10         7         7         6         7         6
         9        10         4         9         9        10         6         4
         6         7        10         7        10         5        10         8
         9         9         6        10         7         8         6        10
         4        10         4         7        10         6         7         8
        10         5         7         8        10         7         7         5
         4         6         6        10         7         5         5        10
         9         6         7        10        10         8         7         8
         5         6         9         5         8         5         9         5
         5        10         8         4         7         4         5         5
         6         8         4         7         7         6         4         5
         8         7        10         5         4         6         8         6
         8         6         7        10         8        10         5         7
         8         7         7         9         7         6        10         7
         8         8         8        10         8         8         9        10
         9         8         5        10         4         7         5         6
         9         6         4         4         5        10         7         7
         6         8         5         7         9         4         8         6
         9         5         5         6         7         4         6         5
         6         5         9         4         8        10         5         4
         5         5         5         5         4         8         8         4
         4         8         5         9         6         9         9         4
         8         9         5         9         7         5        10         9
         4         9        10         6         6         4         6         6
        10         7         5        10        10         7         8        10
         4         9         6         7         7         4         5         9
         9         4         7         5         5         6         9        10
         9         6         5        10         6         6         5         5
         9         4         9         6         7         4        10         8
         9        10         9        10         4        10         8         7
         4         4         7        10         4         5        10        10
         7         9         7         7         4         6         6         8
         6         9         8         9         9         8         4         7
         7         7         6         5         5         8         7        10
         8        10         9         8         9         6         5        10
        10         8         4        10        10         6         5        10
         9        10         7         7         5         5         8         6
         9         8         8        10         5         9         9         7
         8         5         4         4         6         6        10         5
         8        10         9         6        10         4         5         6
        10         6         9         9         8         4         4         6
         6         6        10         5         4         6         8         6
         7         6         6         7         8         5         8         4
         9         5         6         6         5         5         8         9

这段程序有两点需要注意的地方。首先，我们必须对high-low加1，举例说明原因，设想目标范围是0到10，当中有11种可能出现的值。
减法获得的是两个值之间的差值，比范围内值的数量少1，因此必须加1。
其次，注意我们需要加上目标范围的最小值，设想如果想获取10到20之间的数，通过上面的方法只能获取0到10之间的随机数，再加10才能将范围设定到10到20之间。
掌握获取特定范围的随机数后，我们可以编写一些类似《猜数字》 （guessing games）或《模拟骰子》（simulate dice rolls）等有趣的程序。
9.2 bug和随机数
随机数在程序开发阶段会带来不方便。如果程序有bug，你会希望程序每次运行的结果都是固定的，
如果使用随机数，程序的bug可能不会每次都出现，这样就需要花很长时间测试运行程序并且要求得到的都是正确的结果，
即使这样还可能出现意料之外的bug。当测试或调试程序时，你可以注释掉srand调用。
因为当随机数发生器srand不更新种子时，rand函数在每次程序运行后会返回同样序列的值，如此一来程序每次执行的结果便会相同。
要是在调用srand后才出现bug该怎么办？一个技巧是记录程序每次运行的种子值：
int srand_seed = time( NULL );
cout << srand_seed << '\n';
srand( srand_seed );
当发现bug时，你可以修改程序，使用相同的随机种子可以最快找到 bug。例如，如果种子是35 434 333，可以修改程序为：
int srand_seed = 35434333;   // time( NULL );
cout << srand_seed << '\n';
srand( srand_seed );
这样程序每次运行都能得到可预期的值。
问答题
1.在rand之前不调用srand会发生什么？
A. rand失败
B. rand一直返回0
C. rand会在每次程序运行时返回同样的数列
D. 什么都不发生

C
2.为什么要用当前时间作为srand的种子？
A. 确保程序运行一致
B. 每次程序运行时产生新的随机值
C. 确保计算机产生真随机数
D. 这样做是为了方便你在对同一个操作需要多次设置种子时只调用一次srand即可完成

B
3.Rand返回值的范围？
A.想多少就多少
B. 0 到1000
C. 0 到RAND_MAX
D. 1 到RAND_MAX

C
4.表达式11 % 3的结果是？
A. 33
B. 3
C. 8
D. 2

D
5.什么时候应该使用srand？
A. 每次需要随机值时
B. 永远不需要，这只是Windows的一个封装
C. 一次，在程序的开头
D. 偶尔，在while循环内使用rand之后增加随机性

C
实践题
1.编写程序模拟抛硬币，运行多次查看结果是否随机。

#include <cstdlib>
#include <ctime>
#include <iostream>
#include <string>

using namespace std;

int randRange(int low, int high)
{
    return rand() % (high - low + 1) + low;
}

int main()
{
    int sRandSeed = time(nullptr);
    srand(sRandSeed);

    int keepFlippingCoins = 1;
    do
    {
        cout << "Enter the number of coin flips to do. Enter 0 to stop.\n";
        cin >> keepFlippingCoins;
        for (size_t i = 0; i < keepFlippingCoins; i++)
        {
            int coinNumber = randRange(1, 2);
            string face = "";
            if (coinNumber == 1)
            {
                face = "Heads\n";
            }
            else
            {
                face = "Tails\n";
            }
            cout << face;
        }
    }
    while (keepFlippingCoins != 0);
}

显示结果如下
Enter the number of coin flips to do. Enter 0 to stop.
6
Tails
Tails
Heads
Heads
Heads
Heads
Enter the number of coin flips to do. Enter 0 to stop.
8
Tails
Heads
Tails
Tails
Heads
Heads
Tails
Tails
Enter the number of coin flips to do. Enter 0 to stop.
12
Tails
Tails
Heads
Tails
Heads
Heads
Tails
Heads
Heads
Heads
Heads
Heads
Enter the number of coin flips to do. Enter 0 to stop.
0

2.编写程序选取1到100间的某个数字，让用户猜测。程序需要告诉用 户猜测的数与正确数相比是大、小还是刚好。

#include <cstdlib>
#include <ctime>
#include <iostream>

using namespace std;

int randRange(int low, int high)
{
    return rand() % (high - low + 1) + low;
}

int main()
{
    int sRandSeed = time(nullptr);
    srand(sRandSeed);

    int low = 1;
    int high = 100;
    int randomNumber = randRange(low, high);
    int guessedNumber = 0;
    bool stillGuessing = true;

    cout << "Guess what random number I have chosen between " << low << " and " << high << '\n';
    do
    {
        cin >> guessedNumber;
        if (guessedNumber > randomNumber)
        {
            cout << "Your guess is too high!\n";
        }
        else if (guessedNumber < randomNumber)
        {
            cout << "Your guess is too low!\n";
        }
        else
        {
            cout << "Correct!\n";
            stillGuessing = false;
        }
    }
    while (stillGuessing);
}

显示结果如下
Guess what random number I have chosen between 1 and 100
50
Your guess is too high!
39
Your guess is too high!
30
Your guess is too high!
20
Your guess is too high!
10
Your guess is too high!
9
Your guess is too high!
1
Your guess is too low!
6
Your guess is too high!
2
Correct!

3.编写程序升级问题2中的猜数游戏。程序需要多少次猜测？

#include <cstdlib>
#include <ctime>
#include <iostream>

using namespace std;

int randRange(int low, int high)
{
    return rand() % (high - low + 1) + low;
}

int main()
{
    int sRandSeed = time(nullptr);
    srand(sRandSeed);

    int low = 1;
    int high = 100;
    int randomNumber = randRange(low, high);
    bool stillGuessing = true;

    cout << "Guess what random number I have chosen between " << low << " and " << high << '\n';

    int numberOfGuesses = 0;
    int lastGuessHigh = high;
    int lastGuessLow = low;
    do
    {
        int guessedNumber = lastGuessLow + (lastGuessHigh - lastGuessLow) / 2;
        if (guessedNumber < lastGuessLow)
        {
            guessedNumber = lastGuessLow;
        }
        if (guessedNumber > lastGuessHigh)
        {
            guessedNumber = lastGuessHigh;
        }
        cout << "Program is guessing " << guessedNumber << '\n';

        if (guessedNumber > randomNumber)
        {
            cout << "Your guess is too high!\n";
            if (lastGuessHigh == guessedNumber)
            {
                lastGuessHigh--;
            }
            else
            {
                lastGuessHigh = guessedNumber;
            }
        }
        else if (guessedNumber < randomNumber)
        {
            cout << "Your guess is too low!\n";
            if (lastGuessLow == guessedNumber)
            {
                lastGuessLow++;
            }
            else
            {
                lastGuessLow = guessedNumber;
            }
        }
        else
        {
            cout << "Correct!\n";
            stillGuessing = false;
        }
        numberOfGuesses++;
    }
    while (stillGuessing);

    cout << "The random number was guessed by the program in " << numberOfGuesses << " tries." << endl;
}

显示结果如下
Guess what random number I have chosen between 1 and 100
Program is guessing 50
Your guess is too low!
Program is guessing 75
Your guess is too high!
Program is guessing 62
Your guess is too high!
Program is guessing 56
Your guess is too low!
Program is guessing 59
Correct!
The random number was guessed by the program in 5 tries.


4.编写《老虎机》（slot machine）游戏，对玩家随机展示老虎机的结果――每一轮有三种（或更多）值。

#include <cstdlib>
#include <ctime>
#include <iostream>

using namespace std;

int randRange(int low, int high)
{
    return rand() % (high - low + 1) + low;
}

int main()
{
    int sRandSeed = time(nullptr);
    srand(sRandSeed);

    cout << "Welcome to the slot machine game. \n";

    int minRange = 0;
    cout << "Please enter the minimum number to include: \n";
    cin >> minRange;

    int maxRange = 0;
    cout << "Please enter the maximum number to include: \n";
    cin >> maxRange;

    int randomNumber1 = randRange(minRange, maxRange);
    int randomNumber2 = randRange(minRange, maxRange);
    int randomNumber3 = randRange(minRange, maxRange);
    int guessedNumber1 = 0;
    int guessedNumber2 = 0;
    int guessedNumber3 = 0;
    bool stillGuessing = true;

    int option = 1;
    do
    {
        cout << "Enter any number to try again, or '0' to exit: " << '\n';
        cin >> option;
        if (option == 0)
        {
            cout << "You have chosen to forfeit your winnings!\n";
            return 1;
        }
        guessedNumber1 = randRange(minRange, maxRange);
        guessedNumber2 = randRange(minRange, maxRange);
        guessedNumber3 = randRange(minRange, maxRange);

        cout << "Results are: " << guessedNumber1 << " - " << guessedNumber2 << " - " << guessedNumber3 << '\n';

        if ((guessedNumber1 == randomNumber1) &&
                (guessedNumber2 == randomNumber2) &&
                (guessedNumber3 == randomNumber3))
        {
            stillGuessing = false;
        }
    }
    while (stillGuessing);

    cout << "Congratulations! You are a WINNER! \n";
}

显示结果如下
Welcome to the slot machine game.
Please enter the minimum number to include:
1
Please enter the maximum number to include:
999
Enter any number to try again, or '0' to exit:
1
Results are: 416 - 356 - 764
Enter any number to try again, or '0' to exit:
1
Results are: 678 - 374 - 651
Enter any number to try again, or '0' to exit:
1
Results are: 613 - 642 - 280
Enter any number to try again, or '0' to exit:
11
Results are: 666 - 266 - 583
Enter any number to try again, or '0' to exit:
1
Results are: 55 - 579 - 80
Enter any number to try again, or '0' to exit:
1
Results are: 213 - 400 - 396
Enter any number to try again, or '0' to exit:
1
Results are: 532 - 475 - 189
Enter any number to try again, or '0' to exit:
1
Results are: 977 - 322 - 495
Enter any number to try again, or '0' to exit:
1
Results are: 172 - 515 - 962
Enter any number to try again, or '0' to exit:
1
Results are: 225 - 279 - 256
Enter any number to try again, or '0' to exit:
1
Results are: 295 - 695 - 330
Enter any number to try again, or '0' to exit:
1
Results are: 777 - 92 - 703
Enter any number to try again, or '0' to exit:
1
Results are: 428 - 704 - 346
Enter any number to try again, or '0' to exit:
1
Results are: 426 - 89 - 330
Enter any number to try again, or '0' to exit:
1
Results are: 727 - 143 - 627
Enter any number to try again, or '0' to exit:
1
Results are: 806 - 74 - 27
Enter any number to try again, or '0' to exit:
10
Results are: 202 - 325 - 220
Enter any number to try again, or '0' to exit:
0
You have chosen to forfeit your winnings!

5.编写扑克牌（poker）游戏，首先对玩家提供5张牌，接着让用户选择新牌，然后判定手上的牌是不是好牌。
想想这个游戏是否容易实现。如果要记录已经出过的牌想想可能会遇到什么问题？与老虎机游戏相比这个游戏是简单还是困难？

#include <cstdlib>
#include <ctime>
#include <iostream>
#include <vector>


using namespace std;

enum suit_t {HEART, DIAMOND, SPADE, CLUB};

vector <int> dealhand();
vector <int> assign_value(vector <int>  & hand);
vector <int> assign_suit(vector <int>  & hand);
void analyze_hand (vector <int> & hand_value, vector <int> & hand_suit);
void print_result (void);

bool hand_straight, hand_royal_flush, hand_flush, hand_four, hand_three;
int hand_pairs;

int main()
{
    const char * rank_code[] = {"Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Jack", "Queen", "King", "Ace"};
    const char * suit_code[] = {"Hearts", "Diamonds", "Spades", "Clubs"};

    vector <int> hand_prelim;
    vector <int> hand_suit;
    vector <int> hand_value;

    hand_prelim = dealhand();
    hand_suit = assign_suit(hand_prelim);
    hand_value = assign_value(hand_prelim);


    int rank, suit;
    int size = hand_suit.size();
    for(int i = 0; i < size; i++)
    {
        suit = hand_suit.at(i);
        rank = hand_value.at(i);
        cout << rank_code[rank] << " of " << suit_code[suit] << "\n";
    }
    analyze_hand (hand_value, hand_suit);
    cout <<  "\n";
    print_result ();
}

#define NUM_RANKS 13
#define NUM_SUITS    4
#define NUM_CARDS 5

void analyze_hand (vector <int> & hand_value, vector <int> & hand_suit)
{
    int num_in_rank[NUM_RANKS] = {0};
    int num_in_suit[NUM_SUITS] = {0};

    int rank, suit;
    int size = hand_suit.size();
    for(int i = 0; i < size; i++)
    {
        suit = hand_suit.at(i);
        rank = hand_value.at(i);
        num_in_rank[rank]++;
        num_in_suit[suit]++;
    }

    hand_straight = false;
    hand_royal_flush = false;
    hand_flush = false;
    hand_four = false;
    hand_three = false;
    hand_pairs = 0;

    /* check for flush */
    for (suit = 0; suit < NUM_SUITS; suit++)
    {
        if (num_in_suit[suit] == NUM_CARDS)
        {
            hand_flush = true;
        }
    }

    int num_consec = 0;
    /* checks for royal flush */
    if (hand_flush)
    {
        for (rank = 8; rank < NUM_RANKS && num_in_rank[rank] > 0; rank++)
        {
            num_consec++;
        }
        if (num_consec == NUM_CARDS)
        {
            hand_royal_flush = true;
            return;
        }
    }

    num_consec = 0;
    /* check for straight */
    rank = 0;
    while (num_in_rank[rank] == 0)
    {
        rank++;
    }

    for (; rank < NUM_RANKS && num_in_rank[rank] > 0; rank++)
    {
        num_consec++;

        /* special case: low-straight */
        if (num_consec == 4 && rank == 3 && num_in_rank[12] > 0)
        {
            hand_straight = true;
            return;
        }
    }

    if (num_consec == NUM_CARDS)
    {
        hand_straight = true;
        return;
    }

    /* check for 4-of-a-kind, 3-of-a-kind, and pairs */
    for (rank = 0; rank < NUM_RANKS; rank++)
    {
        if (num_in_rank[rank] == 4)
        {
            hand_four = true;
        }
        if (num_in_rank[rank] == 3)
        {
            hand_three = true;
        }
        if (num_in_rank[rank] == 2)
        {
            hand_pairs++;
        }
    }
}
void print_result (void)
{
    if (hand_royal_flush)
    {
        cout << "Royal flush";
    }
    else if (hand_straight && hand_flush)
    {
        cout <<  "Straight flush";
    }
    else if (hand_four)
    {
        cout << "Four of a kind";
    }
    else if (hand_three && hand_pairs == 1)
    {
        cout << "Full house";
    }
    else if (hand_flush)
    {
        cout << "Flush";
    }
    else if (hand_straight)
    {
        cout << "Straight";
    }
    else if (hand_three)
    {
        cout << "Three of a kind";
    }
    else if (hand_pairs == 2)
    {
        cout << "Two pairs";
    }
    else if (hand_pairs == 1)
    {
        cout << "Pair";
    }
    else
    {
        cout << "High card";
    }

    cout <<  "\n";
}
vector <int> dealhand()
{
    int r;
    srand(time(NULL));
    vector <int> deck;
    vector <int> hand;

    for (int i = 0; i < 52; i++)
    {
        deck.push_back(i + 1);
    }

    for (int i = 0; i < NUM_CARDS; i++)
    {
        do
        {
            r = rand() % 52;
        }
        while (deck.at(r) == 0);
        deck.at(r) = 0;
        hand.push_back(r);
    }
    return hand;
}
vector <int> assign_suit(vector <int> & hand)
{
    vector <int> hand_suit;
    int size = hand.size();
    for(int i = 0; i < size; i++)
    {
        int r = hand.at(i);
        if (r < 13)
        {
            hand_suit.push_back(HEART);
        }
        else if (r < 26)
        {
            hand_suit.push_back(DIAMOND);
        }
        else if (r < 39)
        {
            hand_suit.push_back(SPADE);
        }
        else if (r < 52)
        {
            hand_suit.push_back(CLUB);
        }
        else
        {
            cout << "Error in assigning values in hand";
        }
    }
    return hand_suit;
}
vector <int> assign_value(vector <int> & hand)
{
    vector <int> hand_value;
    int size = hand.size();
    for(int i = 0; i < size; i++)
    {
        int r = hand.at(i);
        if (r < 13)
        {
            hand_value.push_back(r);
        }
        else if (r < 26)
        {
            hand_value.push_back(r - 13);
        }
        else if (r < 39)
        {
            hand_value.push_back(r - 26);
        }
        else if (r < 52)
        {
            hand_value.push_back(r - 39);
        }
        else
        {
            cout << "Error in assigning values in hand";
        }
    }
    return hand_value;
}
显示结果如下
King of Clubs
Ten of Hearts
Eight of Hearts
Ace of Clubs
King of Hearts

Pair

Eight of Diamonds
Nine of Spades
Five of Spades
Eight of Clubs
Five of Hearts

Two pairs

Nine of Hearts
Four of Diamonds
King of Clubs
Queen of Hearts
Six of Diamonds

High card

第二部分 数据处理
你已经学习了如何编写基础程序来实现一些有趣的东西，如显示输出 （比如你的名字）、和用户交互、
根据用户输入执行不同的操作、重复执行简单操作，甚至创建游戏。
这些都是好东西，但是一段时间之后，你可能会觉得这些程序很枯燥；只处理少量的数据没有什么乐趣。
但目前为止，你还未学习如何处理大量数据。回想前一章的扑克牌练习题，追踪被使用的牌是否很简单？将整副牌洗牌并展示又会有多困难？
[短暂地停顿一下]
很难。首先需要能存储52个不同值的方法，这需要52个不同的变量。 
每次对新牌赋值时，你都需要检查每个变量，看自己是否已经绘制它所代表的牌。
当处理第52张牌时，你会面对大量代码，没有心思编写更多的程序。
幸好程序员都很懒，他们不喜欢做那些并不是非做不可的事，于是他们想出了非常好的方法来解决这个问题。
此部分内容是关于如何解决这些问题的，让你知道如何处理大量数据：读取、存储和操作。
我们首先给出一个技巧，说明如何在不创建很多不同变量的情况下持有大量数据，这会帮助我们解决扑克牌问题。
第10章 数组
数组是“如何简单存储大量数据”的答案，本质上是一个通过单个名字存储多个数据的变量，但每个数据都有一个数字索引。
你可以认为数组是一个可以通过数字访问元素的编号列表。
数组很容易想象：
val0   val1   val2   val3   val4   val5
数组就像一串彼此相连的盒子；每个盒子是数组的一个元素。
获取数组的值就像通过数字寻找特定的盒子：“给我5号盒子”，这是很神奇的事情，
因为一个数组用一个名字存储所有的数据，很容易以编程的方式选择数组的元素。
如果想绘制5张扑克牌，可以在大小为5的数组中存储5张卡片。当选取新的卡片时只要通过索引修改数组即可，不用使用新的变量。
因此，在绘制每个独立的卡片时，使用变量存储索引可以让你使用同一段代码，而无需对每个变量编写不同的代码。不同之处如下：
Card1 = getRandomCard();
Card2 = getRandomCard();
Card3 = getRandomCard();
Card4 = getRandomCard();
Card5 = getRandomCard();
和：
for ( int i = 0; i < 5; i++ )
{
    card[ i ] = getRandomCard();
}
不妨设想一下如果有100种牌的情况！
10.1 数组的基础语法
声明数组需要指明两个内容（除了名字）：类型和大小。
int my_array[ 6 ];
这句代码声明了一个包含6个整型元素的数组。注意变量名之后的方括号，以及方括号内的数组大小。
访问数组里的元素需要使用方括号，不过这次方括号内的不是数组大 小，而是被访问元素的索引。
my_array[ 3 ];
我们可以这么想象一下：
my_array代表整个数组，但my_array[ 0 ]代表第一个元素，my_array[ 3 ]代表第四个。
如果对此比较疑惑，说明你注意力比较集中。这不是排版错误，数组的索引从0开始。
通过索引的意思是通过方括号内的数字获取数组中特定的值。你可能对此不习惯，除非父母（或教你识数的那个人）是程序员。
有一个简单的思考方法：索引是到达盒子前需要通过的队列的长度。 
你有可能在其他地方遇到过偏移量这个词。偏移量只是描述某些事情的独特方法，数组中的值相对于数组开始的偏移量是索引的大小。
因为数组的第一个元素在开头，所以偏移量和索引是0。
当选取了数组中特定值后，可以像其他变量一样使用。修改数组中的元素如下方代码：
int my_array[ 4 ]; //声明数组
my_array[ 2 ] = 2; // 设置数组中的第三个元素为2
10.2 数组使用示例
10.2.1 使用数组存储排序
回忆之前的问题：“如何对52张牌洗牌？”现在有了数组这个存储方法，可以解决存储52张牌的问题。
问题的另一部分是如何在面板上展示卡片的顺序。因为数组用数字做索引访问，所以你可以把面板上牌的顺序对应于数组中的元素顺序。
如果用52个不同的值随机对数组赋值，可以认为数组中的第一个元素（索引0）是面板的开头，最后一个元素（索引51）是底部。
数组的另一个常见用法是存储排好序的值。例如读取100个值并输出排好序的值。忽略排序相关的问题，表示值的顺序的方法是将值放入数组，
并利用数组的原始顺序。
10.2.2 用多维数组表示网格
数组也可以用来表示多维数据，如象棋棋盘，或者简单一点的东西，如井字棋棋盘（tic-tac-toe board），多维数据的索引不止一个。
声明二维数组需要提供每维的大小：
int tic_tac_toe_board[ 3 ][ 3 ];
下面是井字棋棋盘tic_tac_toe_board的简单可视化：
因为二维数组是方形，所以访问元素时需要两个索引，一个代表横向、一个代表纵向。
两个索引准确标记了表格中被访问元素的位置。 访问元素只需要两个值，一个在第一个方括号内，另一个在第二个方括号内。
你可以创建三维数组，尽管可能不需要。事实上，你可以创建四维、 五维或多维数组。这不好图示化，实践中也很少使用，所以我不进行演示。
一个网格型的数组可以让你更好地组织数据；对于井字棋棋盘，可以把数组中每个元素的值和棋盘位置对应。
你还可以使用数组表示 RPG（角色扮演游戏）游戏的迷宫或水平布局。
10.3 使用数组
10.3.1 数组和for循环
数组和for循环非常搭配；访问数组时可以使用将初始化为0的变量逐渐递增直到数组长度的模式。这种模式和for循环模型非常相符。
下面是一个演示使用for循环创建乘法表并用二维数组存储结果的小程序：
#include <iostream>

using namespace std;

int main ()
{
    int array[ 8 ][ 8 ];

    for ( int i = 0; i < 8; i++ )
    {
        for ( int j = 0; j < 8; j++ )
        {
            array[ i ][ j ] = i * j;
        }
    }
    cout << "Multiplication table:\n";
    for ( int i = 0; i < 8; i++ )
    {
        for ( int j = 0; j < 8; j++ )
        {
            cout << "[ " << i << " ][ " << j << " ] = ";
            cout << array[ i ][ j ] << " ";
            cout << "\n";
        }
    }
}
示例代码29：multidimensional_array.cpp
显示结果如下
Multiplication table:
[ 0 ][ 0 ] = 0
[ 0 ][ 1 ] = 0
[ 0 ][ 2 ] = 0
[ 0 ][ 3 ] = 0
[ 0 ][ 4 ] = 0
[ 0 ][ 5 ] = 0
[ 0 ][ 6 ] = 0
[ 0 ][ 7 ] = 0
[ 1 ][ 0 ] = 0
[ 1 ][ 1 ] = 1
[ 1 ][ 2 ] = 2
[ 1 ][ 3 ] = 3
[ 1 ][ 4 ] = 4
[ 1 ][ 5 ] = 5
[ 1 ][ 6 ] = 6
[ 1 ][ 7 ] = 7
[ 2 ][ 0 ] = 0
[ 2 ][ 1 ] = 2
[ 2 ][ 2 ] = 4
[ 2 ][ 3 ] = 6
[ 2 ][ 4 ] = 8
[ 2 ][ 5 ] = 10
[ 2 ][ 6 ] = 12
[ 2 ][ 7 ] = 14
[ 3 ][ 0 ] = 0
[ 3 ][ 1 ] = 3
[ 3 ][ 2 ] = 6
[ 3 ][ 3 ] = 9
[ 3 ][ 4 ] = 12
[ 3 ][ 5 ] = 15
[ 3 ][ 6 ] = 18
[ 3 ][ 7 ] = 21
[ 4 ][ 0 ] = 0
[ 4 ][ 1 ] = 4
[ 4 ][ 2 ] = 8
[ 4 ][ 3 ] = 12
[ 4 ][ 4 ] = 16
[ 4 ][ 5 ] = 20
[ 4 ][ 6 ] = 24
[ 4 ][ 7 ] = 28
[ 5 ][ 0 ] = 0
[ 5 ][ 1 ] = 5
[ 5 ][ 2 ] = 10
[ 5 ][ 3 ] = 15
[ 5 ][ 4 ] = 20
[ 5 ][ 5 ] = 25
[ 5 ][ 6 ] = 30
[ 5 ][ 7 ] = 35
[ 6 ][ 0 ] = 0
[ 6 ][ 1 ] = 6
[ 6 ][ 2 ] = 12
[ 6 ][ 3 ] = 18
[ 6 ][ 4 ] = 24
[ 6 ][ 5 ] = 30
[ 6 ][ 6 ] = 36
[ 6 ][ 7 ] = 42
[ 7 ][ 0 ] = 0
[ 7 ][ 1 ] = 7
[ 7 ][ 2 ] = 14
[ 7 ][ 3 ] = 21
[ 7 ][ 4 ] = 28
[ 7 ][ 5 ] = 35
[ 7 ][ 6 ] = 42
[ 7 ][ 7 ] = 49

10.3.2 将数组传递给函数
你会很快学到语言的交互特性。例如现在了解了数组，你会提问：“怎么把数组传递给函数？”幸运的是，这里没有太多语法。
当调用函数时，你只需要使用数组的名字：
int values[ 10 ];
sum_array( values );
声明函数时，如下所示输入数组名：  
int sum_array (int values[]);
“等下，”你可能会疑惑，“怎么回事？没有数组大小！”没错，对于一维数组，不需要指定大小。
定义数组时需要指定大小，因为编译器需要开辟空间；但传递数组给函数时，仅仅传递了原来的数组，因为没有创建新的数组，所以不需要指定大小。
事实上将原来的数组传递给函数意味着当你修改了函数内的数组时，发生的改变在函数结束后依然有效。
而我们之前看到的那些普通变量改变的是副本；当函数接收参数并修改变量时并不会影响原来的值。
当然，使用数组时，除非函数知道数组大小，否则函数需要将数组大小作为第二个参数：
int sumArray (int values[], int size)
{
    int sum = 0;
    for ( int i = 0; i < size; i++ )
    {
        sum += values[ i ];
    }
    return sum;
}
不过，传递多维数组时需要指定除首个之外的每个维度大小。
int check_tic_tac_toe (int board[][ 3 ]);
这非常奇怪！但目前你只需要记住无需包含首个大小（尽管可以填写，但是编译器会忽略）。
在介绍指针时我会详细介绍关于传递数组给函数的内容。那时我会解释发生在幕后的运算。现在只需要把它当成奇怪的语法即可。
让我们编写一个完整的程序演示sum_array函数：
#include <iostream>

using namespace std;

int sumArray (int values[], int size)
{
    int sum = 0;
    for ( int i = 0; i < size; i++ )
    {
        sum += values[ i ];
    }
    return sum;
}

int main ()
{
    int values[ 10 ];
    for ( int i = 0; i < 10; i++ )
    {
        cout << "Enter value " << i << ": ";
        cin >> values[ i ];
    }
    cout << sumArray( values, 10 ) << endl;
}
示例代码30：sum_array.cpp
显示结果如下
Enter value 0: 1
Enter value 1: 2
Enter value 2: 3
Enter value 3: 4
Enter value 4: 5
Enter value 5: 6
Enter value 6: 7
Enter value 7: 8
Enter value 8: 9
Enter value 9: 10
55

思考如何不使用数组编写这类程序。因为没有存储所有值的方法，你不得不保持连续相加――每当用户输入时，需要立即相加。
当你想在后面使用数字时，很难跟踪所有的数字（例如，显示被相加的数字）。
10.3.3 注销数组的末尾
如果数据超过数组的大小，请一定不要尝试把数据写在数组的最后一个元素之外，比如你有一个10个元素的数组，
然后尝试在偏移量10上写入数据。
错误代码
int my_array[ 10 ];
my_array[ 10 ] = 4; //尝试对第11个元素赋值
数组只有10个元素，所以最后一个有效的数组索引是9。使用索引10 是无效的，有可能会引起程序崩溃！（讨论内存时会解释崩溃原因。）
这种情况最可能的场景发生在编写循环遍历数组时：
错误代码
int vals[ 10 ];
for ( int i = 0; i <= 10; i++ )
{
    cin >> vals[ i ];
}
代码中数组有10个元素，但是循环条件会判断i小于等于10；也就是 说这将会写数据到vals[ 10 ]，这是不应该的。
而不幸的是，尽管编译器非常严格，但是却不会通知你这些bug。
你只会知道当程序崩溃或异常时程序会出现问题，因为改变的值被其他的代码所使用。
10.4 数组排序
让我们尝试回答之前的问题：“如何接收100个值并对其排序？”代码的基本框架现在应该相当清楚了，
首先你需要一个循环读取用户的100 个整型值：
#include <iostream>

using namespace std;

int main ()
{
    int values[ 100 ];
    for ( int i = 0; i < 100; i++ )
    {
        cout << "Enter value " << i << ": ";
        cin >> values[ i ];
    }
}
示例代码31: read_ints.cpp
这是很简单的部分，现在你已经获取到了数据，然后怎么进行排序呢？
大多数人首先想到的是找到列表中的最小值，移到最开始。然后查找列表中第二小的值，然后移动到第一个值的后面。
然后查找列表 中第三小的值，移动到第二个值后面。
如果以下对列表排序：
3，1，2 
首先需要将1移动到列表的开始：
1，3，2
然后把2移动到列表的第二个位置上：
1, 2, 3
这样看起来你是不是可以使用之前学过的C++特性来编写代码了？看起来很像循环。
遍历整个数组，从第一个元素开始，查找数组中剩下的元素中最小的值（数组中未排序的部分），判断是否可以放置在这里。
然后和当前索引的值进行交换（当前值必须移到其他地方）。采 用自顶向下的设计方法，开始编写一部分代码：
void sort (int array[])
{
    for ( int i = 0; i < 100; i++ )
    {
        int index = findSmallestRemainingElement( array, i );
        swap( array, i, index );
    }
}
现在我们可以考虑实现这两个辅助方 法：findSmallestRemainingElement和swap。
首先思考findSmallestRemainingElement；这个函数需要从索引i开始，遍历整个数组，找到数组中的最小的元素。
这个听起来像不像另外一个循环？我们查找数组的最小值，如果小于当前最小的元素，便设定这个元素的索引为当前最小元素的索引。
int findSmallestRemainingElement (int array[], int index)
{
    int index_of_smallest_value = index;
    for (int i = index + 1; i < ???; i++)
    {
        if ( array[ i ] < array[ index_of_smallest_value ] )
        {
            index_of_smallest_value = i;
        }
    }
    return index_of_smallest_value;
}
这看起来是不是很合理？但是有一个小问题，什么时候循环应该停止呢？函数参数中没有信息指明数组的大小！
我们需要添加上，调用函数findSmallestRemainingElement时同样需要大小。
注意，自顶向下设计需要返回到上层源代码并做一些修改――这是设计程序的正常部分，不用担心。
让我们做些修改使排序源代码无需把100硬编码进去。
int findSmallestRemainingElement (int array[], int size, int index)
{
    int index_of_smallest_value = index;
    for (int i = index + 1; i < size; i++)
    {
        if ( array[ i ] < array[ index_of_smallest_value ]  )
        {
            index_of_smallest_value = i;
        }
    }
    return index_of_smallest_value;
}
void sort (int array[], int size)
{
    for ( int i = 0; i < size; i++ )
    {
        int index = findSmallestRemainingElement( array, size, i );
        swap( array, i, index );
    }
}
最后需要实现swap函数。因为函数可以修改传递进去的原始数组，所以需要使用临时变量保存被重写的第一个值：
void swap (int array[], int first_index, int second_index)
{
    if (first_index == second_index)
    {
        return;
    }
    int temp = array[ first_index ];
    array[ first_index ] = array[ second_index ];
    array[ second_index ] = temp;
}
因为传入swap函数的原始数组可以直接修改，这么实现就可以了。
你可以用随机数对数组赋值并对数组排序，证明这个排序算法是否能正常工作。下面是完整程序：
#include <cstdlib>
#include <ctime>
#include <iostream> 
 
using namespace std; 
 
int findSmallestRemainingElement (int array[], int size, int index);
void swap (int array[], int first_index, int second_index);
void sort (int array[], int size);
void displayArray (int array[], int size);
 
int main ()
{
    int array[ 10 ];
    srand( time( NULL ) );
    for ( int i = 0; i < 10; i++ )
    {
        array[ i ] = rand() % 100;
    }
    cout << "Original array: ";
    displayArray( array, 10 );
    cout << '\n';

    sort( array, 10 );

    cout << "Sorted array: ";
    displayArray( array, 10 );
    cout << '\n';
}
int findSmallestRemainingElement (int array[], int size, int index)
{
    int index_of_smallest_value = index;
    for (int i = index + 1; i < size; i++)
    {
        if ( array[ i ] < array[ index_of_smallest_value ]  )
        {
            index_of_smallest_value = i;
        }
    }
    return index_of_smallest_value;
}
void swap (int array[], int first_index, int second_index)
{
    if (first_index == second_index)
    {
        return;
    }
    int temp = array[ first_index ];
    array[ first_index ] = array[ second_index ];
    array[ second_index ] = temp;
}
void sort (int array[], int size)
{
    for ( int i = 0; i < size; i++ )
    {
        int index = findSmallestRemainingElement( array, size, i );
        swap( array, i, index );
    }
}
void displayArray (int array[], int size)
{
    cout << "{";
    for ( int i = 0; i < size; i++ )
    {
        if ( i != 0 )
        {
            cout << ", ";
        }
        cout << array[ i ];
    }
    cout << "}";
}

示例代码32：insertion_sort.cpp
显示结果如下
Original array: {34, 22, 26, 12, 64, 7, 44, 31, 85, 39}
Sorted array: {7, 12, 22, 26, 31, 34, 39, 44, 64, 85}

上面的排序算法称为插入排序，虽然不是排序算法中最快的一个，但它容易理解并实现。
如果对于非常庞大的数据进行排序，需要选择更快但更难实现和理解的算法。作为程序员，你需要权衡这些。
大多数情况下，越容易实现的算法越好，但是如果每天需要处理网站上数百万的用户数据，最简单的算法通常难以胜任。
这需要你根据数据量和算法速度决定使用哪个算法。如果你是整晚跑一个批处理作业，慢一点没有问题，但是如果需要实时回复用户的搜索（如谷歌），这就不行了。
正如你所见，数组能让我们可以处理比以前多很多的数据。尽管仍有少量问题需要去解决。
如果想关联多个不同但相关的值，而不是存储单一的值，该怎么办？
数组可以帮助组织数据的不同部分，但是却不能组织不同数据类型的数据。在下面结构这一章中，我们会看到解决方法。
第二个问题是，数组提供的内存大小是固定的，在编写程序时已经固定。
如果想处理不限数量的数据，固定大小的数组将不能胜任。我们同样会在后面的几章中解决这个问题。
尽管有这些限制，数组依然非常重要。使用索引访问数据的思想会随时随地出现。
问答题
1.下面的声明数组中哪个正确的？
A. int anarray[ 10 ];
B. int anarray;
C. anarray{ 10 };
D. array anarray[ 10 ];

A
2.有29个元素的数组的最后一个元素的索引是什么？
A. 29
B. 28
C. 0
D. 程序定义的索引

B
3.下面哪个是多维数组？
A. array anarray[ 20 ][ 20 ];
B. int anarray[ 20 ][ 20 ];
C. int array[ 20, 20 ];
D. char array[ 20 ];

B
4.一个有100个元素的数组foo，下面哪个可以正确访问第7个元素？
A. foo[ 6 ];
B. foo[ 7 ];
C. foo( 7 );
D. foo;

A
5.下面哪个函数可以接收二维数组？
A. int func ( int x[][] );
B. int func ( int x[ 10 ][] );
C. int func ( int x[] );
D. int func ( int x[][ 10 ] );

D
实践题
1.编写代码实现插入排序的函数，可以处理任意大小的数组。

#include <cstdlib>
#include <ctime>
#include <iostream>

using namespace std;

int findSmallestRemainingElement(int array[], int size, int index);
void swap(int array[], int firstIndex, int secondIndex);
void sort(int array[], int size);
void displayArray(int array[], int size);

int main()
{
    int const size = 10;
    int array[size];
    srand(time(nullptr));
    for (size_t i = 0; i < size; i++)
    {
        array[i] = rand() % 100;
    }
    cout << "Original array: ";
    displayArray(array, size);
    cout << '\n';

    sort(array, size);

    cout << "Sorted array: ";
    displayArray(array, size);
    cout << '\n';
}
void sort(int array[], int size)
{
    for (int i = 0; i < size; i++)
    {
        int index = findSmallestRemainingElement(array, size, i);
        swap(array, i, index);
    }
}
int findSmallestRemainingElement(int array[], int size, int index)
{
    int indexOfSmallestValue = index;
    for (size_t i = index + 1; i < size; i++)
    {
        if (array[i] < array[indexOfSmallestValue])
        {
            indexOfSmallestValue = i;
        }
    }
    return indexOfSmallestValue;
}
void swap(int array[], int firstIndex, int secondIndex)
{
    if (firstIndex == secondIndex)
    {
        return;
    }
    int temp = array[firstIndex];
    array[firstIndex] = array[secondIndex];
    array[secondIndex] = temp;
}
void displayArray(int array[], int size)
{
    cout << "{";
    for (int i = 0; i < size; i++)
    {
        if (i != 0)
        {
            cout << ", ";
        }
        cout << array[i];
    }
    cout << "}";
}
显示结果如下
Original array: {13, 17, 66, 62, 95, 62, 53, 35, 37, 37}
Sorted array: {13, 17, 35, 37, 37, 53, 62, 62, 66, 95}

2.编写程序读取50个值，输出最大值、最小值、平均值以及50个输入值，每行输出一个。

#include <cstdlib>
#include <ctime>
#include <iostream>

using namespace std;

int max(int array[], int size);
int min(int array[], int size);
double average(int array[], int size);

int main()
{
    int const size = 50;
    int array[size];
    srand(time(nullptr));
    for (int i = 0; i < size; i++)
    {
        array[i] = rand() % 100000;
    }

    int maxValue = max(array, size);
    int minValue = min(array, size);
    double averageValue = average(array, size);

    cout << "Max: " << maxValue << '\n';
    cout << "Min: " << minValue << '\n';
    cout << "Average: " << averageValue << '\n';

    cout << '\n' << "From the following: \n";
    for (int i = 0; i < size; i++)
    {
        cout << array[i] << '\n';
    }
}

int max(int array[], int size)
{
    int maxValue = array[0];
    for (int i = 0; i < size; i++)
    {
        if (array[i] > maxValue)
        {
            maxValue = array[i];
        }
    }
    return maxValue;
}

int min(int array[], int size)
{
    int minValue = array[0];
    for (int i = 0; i < size; i++)
    {
        if (array[i] < minValue)
        {
            minValue = array[i];
        }
    }
    return minValue;
}


double average(int array[], int size)
{
    double sum = 0;
    for (int i = 0; i < size; i++)
    {
        sum += array[i];
    }
    return sum / size;
}
显示结果如下
Max: 97250
Min: 881
Average: 46614

From the following:
97250
11546
55792
27565
15321
38720
13089
881
24702
89455
72072
91903
41704
60492
14317
12507
51257
19234
84119
38557
13966
17426
44711
86661
2054
62570
92588
58541
20329
75767
6940
33931
87314
62732
61496
2635
1452
90937
19868
42506
80392
91941
34410
38448
68785
65079
50955
20043
84313
51427

3.编写程序检测数组是否已经排序，如果没有，进行排序。

#include <cstdlib>
#include <ctime>
#include <iostream>

using namespace std;

bool isSorted(int array[], int size);
bool isAscending(int array[], int size);
int findSmallestRemainingElement(int array[], int size, int index);
int findLargestRemainingElement(int array[], int size, int index);
void swap(int array[], int firstIndex, int secondIndex);
void sort(int array[], int size, bool ascending);
void displayArray(int array[], int size);


int main()
{
    int const size = 10;
    int array[size];
    srand(time(nullptr));
    for (int i = 0; i < size; i++)
    {
        array[i] = rand() % 100;
    }
    cout << "Original array: ";
    displayArray(array, size);
    cout << '\n';

    if (isSorted(array, size))
    {
        cout << "Array is sorted. No sorting action will be done." << '\n';
    }
    else
    {
        cout << "Array is not sorted. " << '\n';
        cout << "Array will be sorted based on the ordering of the first two elements." << '\n';
        bool isArrayAscending = isAscending(array, size);

        sort(array, size, isArrayAscending);

        cout << "Sorted array: ";
        displayArray(array, size);
        cout << '\n';

        if (isSorted(array, size))
        {
            cout << "Array has been correctly sorted." << '\n';
        }
    }
}

bool isAscending(int array[], int size)
{
    if (size >= 2)
    {
        return (array[1] >= array[0]);
    }
    return false;
}

bool isSorted(int array[], int size)
{
    bool isArrayAscending = isAscending(array, size);

    for (int i = 1; i < size; i++)
    {
        if ( isArrayAscending && (array[i] < array[i - 1]) )
        {
            return false;
        }

        if ( !isArrayAscending && (array[i] > array[i - 1]) )
        {
            return false;
        }
    }
    return true;
}

void sort(int array[], int size, bool ascending)
{
    for (int i = 0; i < size; i++)
    {
        int index;
        if (ascending)
        {
            index = findSmallestRemainingElement(array, size, i);
        }
        else
        {
            index = findLargestRemainingElement(array, size, i);
        }
        swap(array, i, index);
    }
}


int findSmallestRemainingElement(int array[], int size, int index)
{
    int indexOfSmallestValue = index;
    for (int i = index + 1; i < size; i++)
    {
        if (array[i] < array[indexOfSmallestValue])
        {
            indexOfSmallestValue = i;
        }
    }
    return indexOfSmallestValue;
}

int findLargestRemainingElement(int array[], int size, int index)
{
    int indexOfLargestValue = index;
    for (int i = index + 1; i < size; i++)
    {
        if (array[i] > array[indexOfLargestValue])
        {
            indexOfLargestValue = i;
        }
    }
    return indexOfLargestValue;
}


void swap(int array[], int firstIndex, int secondIndex)
{
    if (firstIndex == secondIndex)
    {
        return;
    }
    int temp = array[firstIndex];
    array[firstIndex] = array[secondIndex];
    array[secondIndex] = temp;
}

void displayArray(int array[], int size)
{
    cout << "{";
    for (size_t i = 0; i < size; i++)
    {
        if (i != 0)
        {
            cout << ", ";
        }
        cout << array[i];
    }
    cout << "}";
}
显示结果如下
Original array: {65, 77, 91, 31, 97, 15, 81, 76, 91, 85}
Array is not sorted.
Array will be sorted based on the ordering of the first two elements.
Sorted array: {15, 31, 65, 76, 77, 81, 85, 91, 91, 97}
Array has been correctly sorted.

Original array: {57, 66, 59, 34, 45, 45, 71, 84, 14, 39}
Array is not sorted.
Array will be sorted based on the ordering of the first two elements.
Sorted array: {14, 34, 39, 45, 45, 57, 59, 66, 71, 84}
Array has been correctly sorted.

Original array: {50, 52, 61, 46, 84, 18, 20, 74, 20, 90}
Array is not sorted.
Array will be sorted based on the ordering of the first two elements.
Sorted array: {18, 20, 20, 46, 50, 52, 61, 74, 84, 90}
Array has been correctly sorted.

4.编写两个玩家对战的井字棋游戏。程序可以判断玩家胜利或棋盘被填满（平局）。

#include <iostream>
#include <string>

using namespace std;

enum TicTacToeSquare
{
    TTTS_Blank,
    TTTS_O,
    TTTS_X
};

void populateGameBoard(enum TicTacToeSquare array[][3], int size);
string setPlayer(bool playerXInSession);
string translateEnumToString(enum TicTacToeSquare squareState);
bool validIndex(int boardPosition[], int boardSize);
bool choiceTaken(int boardPosition[], enum TicTacToeSquare gameBoard[][3]);
void setChoice(int boardPosition[], enum TicTacToeSquare gameBoard[][3], bool playerXInSession);
enum TicTacToeSquare choiceSquare(bool playerXInSession);
bool choiceWins(bool playerXInSession, enum TicTacToeSquare gameBoard[][3], int size);
bool boardIsFull(enum TicTacToeSquare gameBoard[][3], int size);

int main()
{
    bool gameFinished = false;
    bool playerXInSession = true;
    string player = "";
    int row = 0;
    int column = 0;

    int const size = 3;
    enum TicTacToeSquare gameBoard[size][size];
    populateGameBoard(gameBoard, size);

    do
    {
        row = 0;
        column = 0;
        player = setPlayer(playerXInSession);

        cout << "Tic-Tac-Toe\n";
        string horizontalBar = " _";
        for (int i = 0; i < size; i++)
        {
            horizontalBar += "__";
        }

        for (int i = 0; i <= size; i++)
        {
            if (i == 0)
            {
                for (int j = 0; j <= size; j++)
                {
                    if (j == 0)
                    {
                        cout << " ";
                    }
                    else
                    {
                        cout << " " << j;
                    }
                }
                cout << "\n";
            }
            else
            {
                cout << horizontalBar << "\n";
                for (int j = 0; j <= size; j++)
                {
                    if (j == 0)
                    {
                        cout << i;
                    }
                    else
                    {
                        cout << "|" << translateEnumToString(gameBoard[i - 1][j - 1]);
                    }
                }
                cout << "|\n";
            }
        }
        cout << horizontalBar << "\n\n";

        cout << "Player " << player << ", choose your next board position to claim:\n";

        cout << "Row: \n";
        cin >> row;
        row--;

        cout << "Column: \n";
        cin >> column;
        column--;

        int boardPosition[2] = {row, column};

        if (!validIndex(boardPosition, size))
        {
            cout << "That is an invalid choice. Please try again.\n";
            continue;
        }

        if (choiceTaken(boardPosition, gameBoard))
        {
            cout << "That square is already taken. Please try again.\n";
            continue;
        }

        setChoice(boardPosition, gameBoard, playerXInSession);

        if (choiceWins(playerXInSession, gameBoard, size))
        {
            cout << "Player " << player << " wins!\n";
            gameFinished = true;
        }

        if (boardIsFull(gameBoard, size))
        {
            cout << "Board is full. The game is a tie!\n";
            gameFinished = true;
        }

        playerXInSession = !playerXInSession;
    }
    while (!gameFinished);
}


void populateGameBoard(enum TicTacToeSquare array[][3], int size)
{
    for (size_t i = 0; i < size; i++)
    {
        for (size_t j = 0; j < size; j++)
        {
            array[i][j] = TTTS_Blank;
        }
    }
}

string setPlayer(bool playerXInSession)
{
    if (playerXInSession)
    {
        return "X";
    }
    return "O";
}

bool validIndex(int boardPosition[], int boardSize)
{
    return ( ( (boardPosition[0] >= 0) && (boardPosition[1] >= 0) ) &&
            ( (boardPosition[0] < boardSize) && (boardPosition[1] < boardSize) ) );
}

bool choiceTaken(int boardPosition[], enum TicTacToeSquare gameBoard[][3])
{
    return (gameBoard[ boardPosition[0] ][ boardPosition[1] ] != TTTS_Blank);
}

void setChoice(int boardPosition[], enum TicTacToeSquare gameBoard[][3], bool playerXInSession)
{
    gameBoard[ boardPosition[0] ][ boardPosition[1] ] = choiceSquare(playerXInSession);
}

enum TicTacToeSquare choiceSquare(bool playerXInSession)
{
    if (playerXInSession)
    {
        return TTTS_X;
    }
    return TTTS_O;
}

bool choiceWins(bool playerXInSession, enum TicTacToeSquare gameBoard[][3], int size)
{
    enum TicTacToeSquare choiceCheck = choiceSquare(playerXInSession);;
    double result;

    for (int i = 0; i < size; i++)
    {
        result = 1;
        for (int j = 0; j < size; j++)
        {
            result *= (gameBoard[i][j] == choiceCheck);
        }
        if (result == 1)
        {
            return true;
        }
    }

    for (int j = 0; j < size; j++)
    {
        result = 1;
        for (int i = 0; i < size; i++)
        {
            result *= (gameBoard[i][j] == choiceCheck);
        }
        if (result == 1)
        {
            return true;
        }
    }

    result = 1;
    for (int i = 0; i < size; i++)
    {
        result *= (gameBoard[i][i] == choiceCheck);
    }
    if (result == 1)
    {
        return true;
    }

    int maxIndex = size - 1;
    result = 1;
    for (int i = 0; i < size; i++)
    {
        result *= (gameBoard[i][maxIndex - i] == choiceCheck);
    }
    if (result == 1)
    {
        return true;
    }

    return false;
}

bool boardIsFull(enum TicTacToeSquare gameBoard[][3], int size)
{
    for (int i = 0; i < size; i++)
    {
        for (int j = 0; j < size; j++)
        {
            if (gameBoard[i][j] == TTTS_Blank)
            {
                return false;
            }
        }
    }
    return true;
}

string translateEnumToString(enum TicTacToeSquare squareState)
{
    switch (squareState)
    {
    case TTTS_Blank:
        return " ";
    case TTTS_O:
        return "O";
    case TTTS_X:
        return "X";
    default:
        return "~";
    }
}
显示结果如下
Tic-Tac-Toe
  1 2 3
 _______
1| | | |
 _______
2| | | |
 _______
3| | | |
 _______

Player X, choose your next board position to claim:
Row:
1
Column:
1
Tic-Tac-Toe
  1 2 3
 _______
1|X| | |
 _______
2| | | |
 _______
3| | | |
 _______

Player O, choose your next board position to claim:
Row:
2
Column:
2
Tic-Tac-Toe
  1 2 3
 _______
1|X| | |
 _______
2| |O| |
 _______
3| | | |
 _______

Player X, choose your next board position to claim:
Row:
1
Column:
3
Tic-Tac-Toe
  1 2 3
 _______
1|X| |X|
 _______
2| |O| |
 _______
3| | | |
 _______

Player O, choose your next board position to claim:
Row:
1
Column:
2
Tic-Tac-Toe
  1 2 3
 _______
1|X|O|X|
 _______
2| |O| |
 _______
3| | | |
 _______

Player X, choose your next board position to claim:
Row:
3
Column:
2
Tic-Tac-Toe
  1 2 3
 _______
1|X|O|X|
 _______
2| |O| |
 _______
3| |X| |
 _______

Player O, choose your next board position to claim:
Row:
2
Column:
1
Tic-Tac-Toe
  1 2 3
 _______
1|X|O|X|
 _______
2|O|O| |
 _______
3| |X| |
 _______

Player X, choose your next board position to claim:
Row:
3
Column:
3
Tic-Tac-Toe
  1 2 3
 _______
1|X|O|X|
 _______
2|O|O| |
 _______
3| |X|X|
 _______

Player O, choose your next board position to claim:
Row:
2
Column:
3
Player O wins!


5.编写井字棋游戏，棋盘大小超过3 * 3。四点一线即赢。在程序开始时允许玩家设置棋盘大小。

#include <iostream>
#include <string>

using namespace std;

enum TicTacToeSquare
{
    TTTS_Blank,
    TTTS_O,
    TTTS_X
};

#define MAXBOARDSIZE 8

void populateGameBoard(enum TicTacToeSquare array[][MAXBOARDSIZE], int size);
string setPlayer(bool playerXInSession);
string translateEnumToString(enum TicTacToeSquare squareState);
bool validIndex(int boardPosition[], int boardSize);
bool choiceTaken(int boardPosition[], enum TicTacToeSquare gameBoard[][MAXBOARDSIZE]);
void setChoice(int boardPosition[], enum TicTacToeSquare gameBoard[][MAXBOARDSIZE], bool playerXInSession);
enum TicTacToeSquare choiceSquare(bool playerXInSession);
bool choiceWins(bool playerXInSession, enum TicTacToeSquare gameBoard[][MAXBOARDSIZE], int size);
bool boardIsFull(enum TicTacToeSquare gameBoard[][MAXBOARDSIZE], int size);

int const minToWin = 4;

int main()
{
    bool gameFinished = false;
    bool playerXInSession = true;
    string player = "";
    int row = 0;
    int column = 0;

    int const size = MAXBOARDSIZE;
    int sizeUsed = 4;

    cout << "Please specify the number of spaces to be used for the rows/columns of the square board:\n";
    cout << "(Default is " << minToWin << ")\n";
    cin >> sizeUsed;
    if (sizeUsed < minToWin)
    {
        sizeUsed = minToWin;
    }
    if (sizeUsed > size)
    {
        sizeUsed = size;
    }

    enum TicTacToeSquare gameBoard[size][size];
    populateGameBoard(gameBoard, size);

    do
    {
        row = 0;
        column = 0;
        player = setPlayer(playerXInSession);

        cout << "Tic-Tac-Toe\n";
        cout << minToWin << "-in-a-row are needed to win!\n";
        string horizontalBar = " _";
        for (int i = 0; i < sizeUsed; i++)
        {
            horizontalBar += "__";
        }

        for (int i = 0; i <= sizeUsed; i++)
        {
            if (i == 0)
            {
                for (int j = 0; j <= sizeUsed; j++)
                {
                    if (j == 0)
                    {
                        cout << " ";
                    }
                    else
                    {
                        cout << " " << j;
                    }
                }
                cout << "\n";
            }
            else
            {
                cout << horizontalBar << "\n";
                for (int j = 0; j <= sizeUsed; j++)
                {
                    if (j == 0)
                    {
                        cout << i;
                    }
                    else
                    {
                        cout << "|" << translateEnumToString(gameBoard[i - 1][j - 1]);
                    }
                }
                cout << "|\n";
            }
        }
        cout << horizontalBar << "\n\n";

        cout << "Player " << player << ", choose your next board position to claim:\n";

        cout << "Row: \n";
        cin >> row;
        row--;

        cout << "Column: \n";
        cin >> column;
        column--;

        int boardPosition[2] = {row, column};

        if (!validIndex(boardPosition, sizeUsed))
        {
            cout << "That is an invalid choice. Please try again.\n";
            continue;
        }

        if (choiceTaken(boardPosition, gameBoard))
        {
            cout << "That square is already taken. Please try again.\n";
            continue;
        }

        setChoice(boardPosition, gameBoard, playerXInSession);

        if (choiceWins(playerXInSession, gameBoard, sizeUsed))
        {
            cout << "Player " << player << " wins!\n";
            gameFinished = true;
        }

        if (boardIsFull(gameBoard, sizeUsed))
        {
            cout << "Board is full. The game is a tie!\n";
            gameFinished = true;
        }

        playerXInSession = !playerXInSession;
    }
    while (!gameFinished);
}


void populateGameBoard(enum TicTacToeSquare array[][MAXBOARDSIZE], int size)
{
    for (size_t i = 0; i < size; i++)
    {
        for (size_t j = 0; j < size; j++)
        {
            array[i][j] = TTTS_Blank;
        }
    }
}

string setPlayer(bool playerXInSession)
{
    if (playerXInSession)
    {
        return "X";
    }
    return "O";
}

bool validIndex(int boardPosition[], int boardSize)
{
    return ( ( (boardPosition[0] >= 0) && (boardPosition[1] >= 0) ) &&
            ( (boardPosition[0] < boardSize) && (boardPosition[1] < boardSize) ) );
}

bool choiceTaken(int boardPosition[], enum TicTacToeSquare gameBoard[][MAXBOARDSIZE])
{
    return (gameBoard[ boardPosition[0] ][ boardPosition[1] ] != TTTS_Blank);
}

void setChoice(int boardPosition[], enum TicTacToeSquare gameBoard[][MAXBOARDSIZE], bool playerXInSession)
{
    gameBoard[ boardPosition[0] ][ boardPosition[1] ] = choiceSquare(playerXInSession);
}

enum TicTacToeSquare choiceSquare(bool playerXInSession)
{
    if (playerXInSession)
    {
        return TTTS_X;
    }
    return TTTS_O;
}

bool choiceWins(bool playerXInSession, enum TicTacToeSquare gameBoard[][MAXBOARDSIZE], int size)
{
    enum TicTacToeSquare choiceCheck = choiceSquare(playerXInSession);;
    double score;

    for (int i = 0; i < size; i++)
    {
        score = 0;
        for (int j = 0; j < size; j++)
        {

            if (gameBoard[i][j] == choiceCheck)
            {
                score++;
                if (score >= minToWin)
                {
                    return true;
                }
            }
            else
            {
                score = 0;
            }
        }
    }

    for (int j = 0; j < size; j++)
    {
        score = 0;
        for (int i = 0; i < size; i++)
        {
            if (gameBoard[i][j] == choiceCheck)
            {
                score++;
                if (score >= minToWin)
                {
                    return true;
                }
            }
            else
            {
                score = 0;
            }
        }
    }

    score = 0;
    for (int i = 0; i < size; i++)
    {
        if (gameBoard[i][i] == choiceCheck)
        {
            score++;
            if (score >= minToWin)
            {
                return true;
            }
        }
        else
        {
            score = 0;
        }
    }

    int maxIndex = size - 1;
    score = 0;
    for (int i = 0; i < size; i++)
    {
        if (gameBoard[i][maxIndex - i] == choiceCheck)
        {
            score++;
            if (score >= minToWin)
            {
                return true;
            }
        }
        else
        {
            score = 0;
        }
    }

    return false;
}

bool boardIsFull(enum TicTacToeSquare gameBoard[][MAXBOARDSIZE], int size)
{
    for (int i = 0; i < size; i++)
    {
        for (int j = 0; j < size; j++)
        {
            if (gameBoard[i][j] == TTTS_Blank)
            {
                return false;
            }
        }
    }
    return true;
}

string translateEnumToString(enum TicTacToeSquare squareState)
{
    switch (squareState)
    {
    case TTTS_Blank:
        return " ";
    case TTTS_O:
        return "O";
    case TTTS_X:
        return "X";
    default:
        return "~";
    }
}
显示结果如下
Please specify the number of spaces to be used for the rows/columns of the square board:
(Default is 4)
5
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5
 ___________
1| | | | | |
 ___________
2| | | | | |
 ___________
3| | | | | |
 ___________
4| | | | | |
 ___________
5| | | | | |
 ___________

Player X, choose your next board position to claim:
Row:
1
Column:
3
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5
 ___________
1| | |X| | |
 ___________
2| | | | | |
 ___________
3| | | | | |
 ___________
4| | | | | |
 ___________
5| | | | | |
 ___________

Player O, choose your next board position to claim:
Row:
3
Column:
2
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5
 ___________
1| | |X| | |
 ___________
2| | | | | |
 ___________
3| |O| | | |
 ___________
4| | | | | |
 ___________
5| | | | | |
 ___________

Player X, choose your next board position to claim:
Row:
1
Column:
5
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5
 ___________
1| | |X| |X|
 ___________
2| | | | | |
 ___________
3| |O| | | |
 ___________
4| | | | | |
 ___________
5| | | | | |
 ___________

Player O, choose your next board position to claim:
Row:
2
Column:
2
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5
 ___________
1| | |X| |X|
 ___________
2| |O| | | |
 ___________
3| |O| | | |
 ___________
4| | | | | |
 ___________
5| | | | | |
 ___________

Player X, choose your next board position to claim:
Row:
1
Column:
2
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5
 ___________
1| |X|X| |X|
 ___________
2| |O| | | |
 ___________
3| |O| | | |
 ___________
4| | | | | |
 ___________
5| | | | | |
 ___________

Player O, choose your next board position to claim:
Row:
1
Column:
4
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5
 ___________
1| |X|X|O|X|
 ___________
2| |O| | | |
 ___________
3| |O| | | |
 ___________
4| | | | | |
 ___________
5| | | | | |
 ___________

Player X, choose your next board position to claim:
Row:
2
Column:
4
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5
 ___________
1| |X|X|O|X|
 ___________
2| |O| |X| |
 ___________
3| |O| | | |
 ___________
4| | | | | |
 ___________
5| | | | | |
 ___________

Player O, choose your next board position to claim:
Row:
4
Column:
2
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5
 ___________
1| |X|X|O|X|
 ___________
2| |O| |X| |
 ___________
3| |O| | | |
 ___________
4| |O| | | |
 ___________
5| | | | | |
 ___________

Player X, choose your next board position to claim:
Row:
5
Column:
2
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5
 ___________
1| |X|X|O|X|
 ___________
2| |O| |X| |
 ___________
3| |O| | | |
 ___________
4| |O| | | |
 ___________
5| |X| | | |
 ___________

Player O, choose your next board position to claim:
Row:
3
Column:
4
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5
 ___________
1| |X|X|O|X|
 ___________
2| |O| |X| |
 ___________
3| |O| |O| |
 ___________
4| |O| | | |
 ___________
5| |X| | | |
 ___________

Player X, choose your next board position to claim:
Row:
4
Column:
5
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5
 ___________
1| |X|X|O|X|
 ___________
2| |O| |X| |
 ___________
3| |O| |O| |
 ___________
4| |O| | |X|
 ___________
5| |X| | | |
 ___________

Player O, choose your next board position to claim:
Row:
3
Column:
1
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5
 ___________
1| |X|X|O|X|
 ___________
2| |O| |X| |
 ___________
3|O|O| |O| |
 ___________
4| |O| | |X|
 ___________
5| |X| | | |
 ___________

Player X, choose your next board position to claim:
Row:
3
Column:
5
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5
 ___________
1| |X|X|O|X|
 ___________
2| |O| |X| |
 ___________
3|O|O| |O|X|
 ___________
4| |O| | |X|
 ___________
5| |X| | | |
 ___________

Player O, choose your next board position to claim:
Row:
3
Column:
3
Player O wins!

6.编写两人跳棋游戏（国际跳棋），允许玩家移动，判断移动是否合法和游戏是否结束。必须支持国王！

#include <iostream>
#include <string>

using namespace std;

enum CheckersSquare
{
	Checkers_Filled,
	Checkers_NotFilled,
	Checkers_SinglePiece_Black,
	Checkers_KingPiece_Black,
	Checkers_SinglePiece_Red,
	Checkers_KingPiece_Red
};

enum CheckersPlayers
{
	CheckersPlayers_Black,
	CheckersPlayers_Red
};

enum CheckersMoves
{
	CheckersMoves_ForwardLeft = 1,
	CheckersMoves_ForwardRight = 2,
	CheckersMoves_BackwardLeft = 3,
	CheckersMoves_BackwardRight = 4
};

int const maxBoardSize = 50;
int const minBoardSize = 10;

int const maxPieces = 500;
int const minPieces = 20;

void drawBoard(CheckersSquare gameBoard[][50], int boardSizeUsed, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50]);

void populateGameBoard(CheckersSquare array[][50], int size);
void populateBlackPieces(int boardSize, CheckersSquare playerPieces[][50], int numberOfPieces);
void populateRedPieces(int boardSize, CheckersSquare playerPieces[][50], int numberOfPieces);
bool isTurnWinning(int boardPosition[], int boardMove[], CheckersPlayers player, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50], CheckersSquare gameBoard[][50], int boardSizeUsed);
CheckersPlayers setPlayer(CheckersPlayers playerBlackInSession);

void getBoardPosition(int boardPosition[], int boardSizeUsed, CheckersPlayers player, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50]);
bool isValidPosition(int boardPosition[], CheckersPlayers player, CheckersSquare playerPieces[][50]);

void getMoveOffset(CheckersPlayers player, CheckersMoves move, int moveOffset[2]);
void chooseBoardMove(int boardPosition[], int boardMove[], int boardSizeUsed, CheckersSquare playerPiece, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50]);
bool moveIsValid(int boardPosition[], int offset[], int boardSizeUsed, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50]);
bool moveIsOntoOppositionPiece(int landingRow, int landingColumn, CheckersSquare oppositionPieces[][50]);
bool isInBounds(int row, int column, int boardSizeUse);
bool isOnBoardTopBottomEdge(int row, int boardSizeUsed);
bool makeBoardMove(int boardPosition[], int boardMove[], int boardSizeUsed, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50]);
void kingPiece(int row, int column, CheckersSquare playerPieces[][50]);

bool choiceWins(int boardSizeUsed, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50]);
bool areAllOppositionPiecesEliminated(int boardSizeUsed, CheckersSquare oppositionPieces[][50]);
bool areAllOppositionPiecesTrapped(int boardSizeUsed, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50]);
bool isPieceTrapped(int boardPosition[], CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50], int boardSizeUsed);
bool pieceCanJumpNeighboringPiece(int boardPosition[], CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50], int boardSizeUsed);

string translateEnumToString(CheckersSquare squareState);
string translateEnumToString(CheckersPlayers squareState);
bool isEven(int number);
bool isOdd(int number);
bool isValidSquare(int row, int column);
bool isPieceKing(CheckersSquare playerPiece);
CheckersPlayers getPlayer(CheckersSquare playerPiece);

int main()
{
	int boardSizeUsed = minBoardSize;
	int numberOfPiecesUsed = minPieces;

	CheckersSquare gameBoard[maxBoardSize][maxBoardSize];
	populateGameBoard(gameBoard, maxBoardSize);

	CheckersSquare BlackPieces[maxBoardSize][maxBoardSize];
	populateBlackPieces(boardSizeUsed, BlackPieces, numberOfPiecesUsed);

	CheckersSquare RedPieces[maxBoardSize][maxBoardSize];
	populateRedPieces(boardSizeUsed, RedPieces, numberOfPiecesUsed);

	CheckersPlayers player = CheckersPlayers_Black;

	bool gameFinished = false;
	int boardPosition[2];
	int boardMove[2];
	drawBoard(gameBoard, boardSizeUsed, BlackPieces, RedPieces);
	do
	{	
		if (player == CheckersPlayers_Black)
		{
			gameFinished = isTurnWinning(boardPosition, boardMove, player, BlackPieces, RedPieces, gameBoard, boardSizeUsed);
		}
		else
		{
			gameFinished = isTurnWinning(boardPosition, boardMove, player, RedPieces, BlackPieces, gameBoard, boardSizeUsed);
		}

		player = setPlayer(player);
	} while (!gameFinished);
}

bool isTurnWinning(int boardPosition[], int boardMove[], CheckersPlayers player, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50], CheckersSquare gameBoard[][50], int boardSizeUsed)
{
	getBoardPosition(boardPosition, boardSizeUsed, player, playerPieces, oppositionPieces);
	CheckersSquare playerPiece = playerPieces[ boardPosition[0] ][ boardPosition[1] ];

	bool nextPlayer;
	do
	{
		chooseBoardMove(boardPosition, boardMove, boardSizeUsed, playerPiece, playerPieces, oppositionPieces);
		nextPlayer = !makeBoardMove(boardPosition, boardMove, boardSizeUsed, playerPieces, oppositionPieces);
		drawBoard(gameBoard, boardSizeUsed, playerPieces, oppositionPieces);

		if (choiceWins(boardSizeUsed, playerPieces, oppositionPieces))
		{
			cout << "Player " << translateEnumToString(player) << " wins!\n";
			return true;
		}
	} while (!nextPlayer);
	return false;
}

void drawBoard(CheckersSquare gameBoard[][50], int boardSizeUsed, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50])
{
	cout << "Checkers\n";
	cout << "Black (O) Side\n";
	string horizontalBar = " _";
	for (int i = 0; i < boardSizeUsed; i++)
	{
		horizontalBar += "__";
	}

	for (int i = 0; i <= boardSizeUsed; i++)
	{
		if (i == 0)
		{
			for (int j = 0; j <= boardSizeUsed; j++)
			{
				if (j == 0)
				{
					cout << " ";
				}
				else
				{
					cout << " " << j;
				}
			}
			cout << "\n";
		}
		else
		{
			cout << horizontalBar << "\n";
			for (int j = 0; j <= boardSizeUsed; j++)
			{
				if (j == 0)
				{
					cout << i;
				}
				else
				{
					string squareCharacter;
					if (playerPieces[i - 1][j - 1] != Checkers_NotFilled)
					{
						squareCharacter = translateEnumToString(playerPieces[i - 1][j - 1]);
					}
					else if (oppositionPieces[i - 1][j - 1] != Checkers_NotFilled)
					{
						squareCharacter = translateEnumToString(oppositionPieces[i - 1][j - 1]);
					}
					else
					{
						squareCharacter = translateEnumToString(gameBoard[i - 1][j - 1]);
					}
					
					cout << "|" << squareCharacter;
				}
			}
			cout << "|\n";
		}
	}
	cout << "Red (X) Side\n";
	cout << horizontalBar << "\n\n";
}

void populateGameBoard(CheckersSquare array[][50], int size)
{
	for (int i = 0; i < size; i++)
	{
		for (int j = 0; j < size; j++)
		{
			if (isValidSquare(i, j))
			{
				array[i][j] = Checkers_Filled;
			}
			else
			{
				array[i][j] = Checkers_NotFilled;
			}
		}
	}
}

void populateBlackPieces(int boardSize, CheckersSquare playerPieces[][50], int numberOfPieces)
{
	int currentPlayerPiece = 1;

	for (int i = 0; i < boardSize; i++)
	{
		for (int j = 0; j < boardSize; j++)
		{
			if ( (currentPlayerPiece <= numberOfPieces) && 
				( isValidSquare(i, j) ) )
			{
				playerPieces[i][j] = Checkers_SinglePiece_Black;
				currentPlayerPiece++;
			}
			else
			{
				playerPieces[i][j] = Checkers_NotFilled;
			}
		}
	}
}

void populateRedPieces(int boardSize, CheckersSquare playerPieces[][50], int numberOfPieces)
{
	int currentPlayerPiece = 1;

	for (int i = boardSize - 1; i >= 0 ; i--)
	{
		for (int j = boardSize - 1; j >= 0; j--)
		{
			if ( (currentPlayerPiece <= numberOfPieces) &&
				( isValidSquare(i, j) ) )
			{
				playerPieces[i][j] = Checkers_SinglePiece_Red;
				currentPlayerPiece++;
			}
			else
			{
				playerPieces[i][j] = Checkers_NotFilled;
			}
		}
	}
}

CheckersPlayers setPlayer(CheckersPlayers playerBlackInSession)
{
	if (playerBlackInSession == CheckersPlayers_Red)
	{
		return CheckersPlayers_Black;
	}
	return CheckersPlayers_Red;
}



void getMoveOffset(CheckersPlayers player, CheckersMoves move, int moveOffset[2])
{
	switch (move)
	{
		case CheckersMoves_ForwardLeft:
			moveOffset[0] = 1;
			moveOffset[1] = 1;
			break;
		case CheckersMoves_ForwardRight:
			moveOffset[0] = 1;
			moveOffset[1] = -1;
			break;
		case CheckersMoves_BackwardLeft:
			moveOffset[0] = -1;
			moveOffset[1] = 1;
			break;
		case CheckersMoves_BackwardRight:
			moveOffset[0] = -1;
			moveOffset[1] = -1;
			break;
		default:
			moveOffset[0] = 0;
			moveOffset[1] = 0;
			break;
	}

	int direction = 1;
	if (player == CheckersPlayers_Red)
	{
		direction = -1;
	}

	moveOffset[0] = moveOffset[0] * direction;
	moveOffset[1] = moveOffset[1] * direction;
}

CheckersPlayers getPlayer(CheckersSquare playerPiece)
{
	if ((playerPiece == Checkers_SinglePiece_Black) || (playerPiece == Checkers_KingPiece_Black))
	{
		return CheckersPlayers_Black;
	}
	return CheckersPlayers_Red;
}

bool isPieceKing(CheckersSquare playerPiece)
{
	return ((playerPiece == Checkers_KingPiece_Black) || (playerPiece == Checkers_KingPiece_Red));
}



void getBoardPosition(int boardPosition[], int boardSizeUsed, CheckersPlayers player, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50])
{
	int startRow = 0;
	int startColumn = 0;
	bool isCurrentValidPosition;

	do
	{
		cout << "Player " << translateEnumToString(player) << ", choose the piece to move:\n";

		cout << "Row: \n";
		cin >> startRow;
		startRow--;
		boardPosition[0] = startRow;

		cout << "Column: \n";
		cin >> startColumn;
		startColumn--;
		boardPosition[1] = startColumn;
		
		cout << '\n';
		isCurrentValidPosition = isValidPosition(boardPosition, player, playerPieces);
		if (!isCurrentValidPosition)
		{
			cout << "Position chosen is invalid. \n";
			cout << "Please choose a row/column locating the piece to move.\n";
			continue;
		}

		isCurrentValidPosition = !isPieceTrapped(boardPosition, playerPieces, oppositionPieces, boardSizeUsed);
		if (!isCurrentValidPosition)
		{
			cout << "Piece chosen is trapped! \n";
			cout << "Please choose a different piece.\n";
			continue;
		}
	}
	while (!isCurrentValidPosition);
}

bool isValidPosition(int boardPosition[], CheckersPlayers player, CheckersSquare playerPieces[][50])
{
	if (player == CheckersPlayers_Black)
	{
		return ( (playerPieces[ boardPosition[0] ][ boardPosition[1] ] == Checkers_SinglePiece_Black) ||
			(playerPieces[ boardPosition[0] ][ boardPosition[1] ] == Checkers_KingPiece_Black) );
	}

	if (player == CheckersPlayers_Red)
	{
		return ( (playerPieces[ boardPosition[0] ][ boardPosition[1] ] == Checkers_SinglePiece_Red) ||
			(playerPieces[ boardPosition[0] ][ boardPosition[1] ] == Checkers_KingPiece_Red) );
	}

	return false;
}



void chooseBoardMove(int boardPosition[], int boardMove[], int boardSizeUsed, CheckersSquare playerPiece, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50])
{
	int moveChoice = 0;
	int tempMove[2];
	bool isCurrentValidMove = false;
	CheckersPlayers player = getPlayer(playerPiece);
	
	bool isCurrentPieceKing = isPieceKing(playerPiece);
	int maxEnum = 2;
	if (isCurrentPieceKing) { maxEnum = 4; }
	
	string pieceType = "regular";
	if (isCurrentPieceKing)
	{
		pieceType = "king";
	}

	do
	{
		cout << "Player " << translateEnumToString(player) << ", choose where to move the " << pieceType << " piece in reference to your starting side and direction:\n";
		cout << "1: Forward-Left\n";
		cout << "2: Forward-Right\n";
		if (isCurrentPieceKing)
		{
			cout << "3: Backward-Left\n";
			cout << "4: Backward-Right\n";
		}
		cin >> moveChoice;

		if (moveChoice < 1 || moveChoice > maxEnum)
		{
			cout << "Please enter a valid move number.\n";
			continue;
		}
		
		getMoveOffset(player, static_cast<CheckersMoves>(moveChoice), tempMove);

		isCurrentValidMove = moveIsValid(boardPosition, tempMove, boardSizeUsed, playerPieces, oppositionPieces);
		if (!isCurrentValidMove)
		{
			cout << "\n" << "Move will land piece out of bounds, or onto an occupied square." << "\n";
			cout << "Please choose another move." << "\n";
		}
	} while (!isCurrentValidMove);

	boardMove[0] = tempMove[0];
	boardMove[1] = tempMove[1];
}

bool moveIsValid(int boardPosition[], int offset[], int boardSizeUsed, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50])
{
	int landingRow = boardPosition[0] + offset[0];
	int landingColumn = boardPosition[1] + offset[1];

	if (!isInBounds(landingRow, landingColumn, boardSizeUsed)) { return false; }

	CheckersSquare neighboringPlayerPiece = playerPieces[landingRow][landingColumn];
	if (neighboringPlayerPiece != Checkers_NotFilled) { return false; }

	if (moveIsOntoOppositionPiece(landingRow, landingColumn, oppositionPieces))
	{
		landingRow += offset[0];
		landingColumn += offset[1];

		if (!isInBounds(landingRow, landingColumn, boardSizeUsed)) { return false; }

		CheckersSquare landingSquareOpposition = oppositionPieces[landingRow][landingColumn];
		CheckersSquare landingSquarePlayer = playerPieces[landingRow][landingColumn];
		if ( (landingSquareOpposition != Checkers_NotFilled) ||
			(landingSquarePlayer != Checkers_NotFilled) )
		{
			return false;
		}
	}
	return true;
}

bool moveIsOntoOppositionPiece(int landingRow, int landingColumn, CheckersSquare oppositionPieces[][50])
{
	CheckersSquare neighboringOpposingPiece = oppositionPieces[landingRow][landingColumn];
	return (neighboringOpposingPiece != Checkers_NotFilled);
}

bool isInBounds(int row, int column, int boardSizeUse)
{
	return ( (0 <= row) && (row < boardSizeUse) &&
			(0 <= column) && (column < boardSizeUse) );
}



bool makeBoardMove(int boardPosition[], int boardMove[], int boardSizeUsed, CheckersSquare playerPieces[][50],  CheckersSquare oppositionPieces[][50])
{
	int landingRow = boardPosition[0] + boardMove[0];
	int landingColumn = boardPosition[1] + boardMove[1];
	bool continueTurn = false;
	bool pieceWasJumped = false;

	if (moveIsOntoOppositionPiece(landingRow, landingColumn, oppositionPieces))
	{
		oppositionPieces[landingRow][landingColumn] = Checkers_NotFilled;
		pieceWasJumped = true;
		cout << "A piece was just jumped!\n";

		landingRow += boardMove[0];
		landingColumn += boardMove[1];

		continueTurn = true;
	}
	
	CheckersSquare currentPiece = playerPieces[ boardPosition[0] ][ boardPosition[1] ];
	playerPieces[ boardPosition[0] ][ boardPosition[1] ] = Checkers_NotFilled;
	playerPieces[landingRow][landingColumn] = currentPiece;
	boardPosition[0] = landingRow;
	boardPosition[1] = landingColumn;

	if (pieceWasJumped) { continueTurn = pieceCanJumpNeighboringPiece(boardPosition, playerPieces, oppositionPieces, boardSizeUsed); }

	if (isOnBoardTopBottomEdge(landingRow, boardSizeUsed))
	{
		if (!isPieceKing(currentPiece))
		{
			kingPiece(landingRow, landingColumn, playerPieces);
			cout << "Piece is upgraded to a king!\n";
		}
		continueTurn = false;
	}

	return continueTurn;
}

bool isOnBoardTopBottomEdge(int row, int boardSizeUsed)
{
	return ((row == 0) || (row == (boardSizeUsed - 1)));
}

void kingPiece(int row, int column, CheckersSquare playerPieces[][50])
{
	CheckersSquare currentPiece = playerPieces[row][column];
	if (currentPiece == Checkers_SinglePiece_Black)
	{
		playerPieces[row][column] = Checkers_KingPiece_Black;
	}
	if (currentPiece == Checkers_SinglePiece_Red)
	{
		playerPieces[row][column] = Checkers_KingPiece_Red;
	}
}



bool choiceWins(int boardSizeUsed, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50])
{
	return (areAllOppositionPiecesEliminated(boardSizeUsed, oppositionPieces) || areAllOppositionPiecesTrapped(boardSizeUsed, playerPieces, oppositionPieces));
}

bool areAllOppositionPiecesEliminated(int boardSizeUsed, CheckersSquare oppositionPieces[][50])
{
	for (int i = 0; i < boardSizeUsed; i++)
	{
		for (int j = 0; j < boardSizeUsed; j++)
		{
			if (oppositionPieces[i][j] != Checkers_NotFilled)
			{
				return false;
			}
		}
	}
	return true;
}

bool areAllOppositionPiecesTrapped(int boardSizeUsed, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50])
{
	for (int i = 0; i < boardSizeUsed; i++)
	{
		for (int j = 0; j < boardSizeUsed; j++)
		{
			if (oppositionPieces[i][j] != Checkers_NotFilled)
			{
				int boardPosition[2] = { i, j };
				if (!isPieceTrapped(boardPosition, oppositionPieces, playerPieces, boardSizeUsed))
				{
					return false;
				}
			}
		}
	}
	return true;
}

bool isPieceTrapped(int boardPosition[], CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50], int boardSizeUsed)
{
	CheckersSquare playerPiece = playerPieces[boardPosition[0]][boardPosition[1]];
	CheckersPlayers player = getPlayer(playerPiece);
	bool isCurrentPieceKing = isPieceKing(playerPiece);

	int maxEnum = 2;
	if (isCurrentPieceKing) { maxEnum = 4; }
	int tempMove[2];
	for (int i = 1; i <= maxEnum; i++)
	{
		getMoveOffset(player, static_cast<CheckersMoves>(i), tempMove);
		if (moveIsValid(boardPosition, tempMove, boardSizeUsed, playerPieces, oppositionPieces)) { return false; }
	}

	return true;
}

bool pieceCanJumpNeighboringPiece(int boardPosition[], CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50], int boardSizeUsed)
{
	CheckersSquare playerPiece = playerPieces[boardPosition[0]][boardPosition[1]];
	CheckersPlayers player = getPlayer(playerPiece);
	bool isCurrentPieceKing = isPieceKing(playerPiece);

	int maxEnum = 2;
	if (isCurrentPieceKing) { maxEnum = 4; }
	int tempMove[2];
	for (int i = 1; i <= maxEnum; i++)
	{
		getMoveOffset(player, static_cast<CheckersMoves>(i), tempMove);
		if (moveIsValid(boardPosition, tempMove, boardSizeUsed, playerPieces, oppositionPieces)) { return true; }
	}

	return false;
}



string translateEnumToString(CheckersSquare squareState)
{
	switch (squareState)
	{
	case Checkers_Filled:
		return "#";
	case Checkers_NotFilled:
		return " ";
	case Checkers_SinglePiece_Red:
		return "x";
	case Checkers_KingPiece_Red:
		return "X";
	case Checkers_SinglePiece_Black:
		return "o";
	case Checkers_KingPiece_Black:
		return "O";
	default:
		return "~";
	}
}

string translateEnumToString(CheckersPlayers squareState)
{
	switch (squareState)
	{
	case CheckersPlayers_Black:
		return "O";
	case CheckersPlayers_Red:
		return "X";
	default:
		return "~";
	}
}

bool isEven(int number)
{
	return (number % 2 == 0);
}

bool isOdd(int number)
{
	return !isEven(number);
}

bool isValidSquare(int row, int column)
{
	return ( ( isEven(row) && isOdd(column) ) ||
			( isOdd(row) && isEven(column) ) );
}
显示结果如下
Checkers
Black (O) Side
  1 2 3 4 5 6 7 8 9 10
 _____________________
1| |o| |o| |o| |o| |o|
 _____________________
2|o| |o| |o| |o| |o| |
 _____________________
3| |o| |o| |o| |o| |o|
 _____________________
4|o| |o| |o| |o| |o| |
 _____________________
5| |#| |#| |#| |#| |#|
 _____________________
6|#| |#| |#| |#| |#| |
 _____________________
7| |x| |x| |x| |x| |x|
 _____________________
8|x| |x| |x| |x| |x| |
 _____________________
9| |x| |x| |x| |x| |x|
 _____________________
10|x| |x| |x| |x| |x| |
Red (X) Side
 _____________________

Player O, choose the piece to move:
Row:
4
Column:
1

Player O, choose where to move the regular piece in reference to your starting side and direction:
1: Forward-Left
2: Forward-Right
1
Checkers
Black (O) Side
  1 2 3 4 5 6 7 8 9 10
 _____________________
1| |o| |o| |o| |o| |o|
 _____________________
2|o| |o| |o| |o| |o| |
 _____________________
3| |o| |o| |o| |o| |o|
 _____________________
4|#| |o| |o| |o| |o| |
 _____________________
5| |o| |#| |#| |#| |#|
 _____________________
6|#| |#| |#| |#| |#| |
 _____________________
7| |x| |x| |x| |x| |x|
 _____________________
8|x| |x| |x| |x| |x| |
 _____________________
9| |x| |x| |x| |x| |x|
 _____________________
10|x| |x| |x| |x| |x| |
Red (X) Side
 _____________________

Player X, choose the piece to move:
Row:
7
Column:
10

Player X, choose where to move the regular piece in reference to your starting side and direction:
1: Forward-Left
2: Forward-Right
1
Checkers
Black (O) Side
  1 2 3 4 5 6 7 8 9 10
 _____________________
1| |o| |o| |o| |o| |o|
 _____________________
2|o| |o| |o| |o| |o| |
 _____________________
3| |o| |o| |o| |o| |o|
 _____________________
4|#| |o| |o| |o| |o| |
 _____________________
5| |o| |#| |#| |#| |#|
 _____________________
6|#| |#| |#| |#| |x| |
 _____________________
7| |x| |x| |x| |x| |#|
 _____________________
8|x| |x| |x| |x| |x| |
 _____________________
9| |x| |x| |x| |x| |x|
 _____________________
10|x| |x| |x| |x| |x| |
Red (X) Side
 _____________________

Player O, choose the piece to move:
Row:
5
Column:
2

Player O, choose where to move the regular piece in reference to your starting side and direction:
1: Forward-Left
2: Forward-Right
1
Checkers
Black (O) Side
  1 2 3 4 5 6 7 8 9 10
 _____________________
1| |o| |o| |o| |o| |o|
 _____________________
2|o| |o| |o| |o| |o| |
 _____________________
3| |o| |o| |o| |o| |o|
 _____________________
4|#| |o| |o| |o| |o| |
 _____________________
5| |#| |#| |#| |#| |#|
 _____________________
6|#| |o| |#| |#| |x| |
 _____________________
7| |x| |x| |x| |x| |#|
 _____________________
8|x| |x| |x| |x| |x| |
 _____________________
9| |x| |x| |x| |x| |x|
 _____________________
10|x| |x| |x| |x| |x| |
Red (X) Side
 _____________________

Player X, choose the piece to move:
Row:
7
Column:
6

Player X, choose where to move the regular piece in reference to your starting side and direction:
1: Forward-Left
2: Forward-Right
1
Checkers
Black (O) Side
  1 2 3 4 5 6 7 8 9 10
 _____________________
1| |o| |o| |o| |o| |o|
 _____________________
2|o| |o| |o| |o| |o| |
 _____________________
3| |o| |o| |o| |o| |o|
 _____________________
4|#| |o| |o| |o| |o| |
 _____________________
5| |#| |#| |#| |#| |#|
 _____________________
6|#| |o| |x| |#| |x| |
 _____________________
7| |x| |x| |#| |x| |#|
 _____________________
8|x| |x| |x| |x| |x| |
 _____________________
9| |x| |x| |x| |x| |x|
 _____________________
10|x| |x| |x| |x| |x| |
Red (X) Side
 _____________________

Player O, choose the piece to move:
Row:
6
Column:
3

Piece chosen is trapped!
Please choose a different piece.
Player O, choose the piece to move:
Row:
4
Column:
3

Player O, choose where to move the regular piece in reference to your starting side and direction:
1: Forward-Left
2: Forward-Right
1
Checkers
Black (O) Side
  1 2 3 4 5 6 7 8 9 10
 _____________________
1| |o| |o| |o| |o| |o|
 _____________________
2|o| |o| |o| |o| |o| |
 _____________________
3| |o| |o| |o| |o| |o|
 _____________________
4|#| |#| |o| |o| |o| |
 _____________________
5| |#| |o| |#| |#| |#|
 _____________________
6|#| |o| |x| |#| |x| |
 _____________________
7| |x| |x| |#| |x| |#|
 _____________________
8|x| |x| |x| |x| |x| |
 _____________________
9| |x| |x| |x| |x| |x|
 _____________________
10|x| |x| |x| |x| |x| |
Red (X) Side
 _____________________

Player X, choose the piece to move:
Row:
7
Column:
4

Player X, choose where to move the regular piece in reference to your starting side and direction:
1: Forward-Left
2: Forward-Right
1
A piece was just jumped!
Checkers
Black (O) Side
  1 2 3 4 5 6 7 8 9 10
 _____________________
1| |o| |o| |o| |o| |o|
 _____________________
2|o| |o| |o| |o| |o| |
 _____________________
3| |o| |o| |o| |o| |o|
 _____________________
4|#| |#| |o| |o| |o| |
 _____________________
5| |x| |o| |#| |#| |#|
 _____________________
6|#| |#| |x| |#| |x| |
 _____________________
7| |x| |#| |#| |x| |#|
 _____________________
8|x| |x| |x| |x| |x| |
 _____________________
9| |x| |x| |x| |x| |x|
 _____________________
10|x| |x| |x| |x| |x| |
Red (X) Side
 _____________________

Player X, choose where to move the regular piece in reference to your starting side and direction:
1: Forward-Left
2: Forward-Right
5
Please enter a valid move number.
Player X, choose where to move the regular piece in reference to your starting side and direction:
1: Forward-Left
2: Forward-Right
2
Checkers
Black (O) Side
  1 2 3 4 5 6 7 8 9 10
 _____________________
1| |o| |o| |o| |o| |o|
 _____________________
2|o| |o| |o| |o| |o| |
 _____________________
3| |o| |o| |o| |o| |o|
 _____________________
4|#| |x| |o| |o| |o| |
 _____________________
5| |#| |o| |#| |#| |#|
 _____________________
6|#| |#| |x| |#| |x| |
 _____________________
7| |x| |#| |#| |x| |#|
 _____________________
8|x| |x| |x| |x| |x| |
 _____________________
9| |x| |x| |x| |x| |x|
 _____________________
10|x| |x| |x| |x| |x| |
Red (X) Side
 _____________________

Player O, choose the piece to move:
Row:
5
Column:
4

Player O, choose where to move the regular piece in reference to your starting side and direction:
1: Forward-Left
2: Forward-Right
1
A piece was just jumped!
Checkers
Black (O) Side
  1 2 3 4 5 6 7 8 9 10
 _____________________
1| |o| |o| |o| |o| |o|
 _____________________
2|o| |o| |o| |o| |o| |
 _____________________
3| |o| |o| |o| |o| |o|
 _____________________
4|#| |x| |o| |o| |o| |
 _____________________
5| |#| |#| |#| |#| |#|
 _____________________
6|#| |#| |#| |#| |x| |
 _____________________
7| |x| |#| |o| |x| |#|
 _____________________
8|x| |x| |x| |x| |x| |
 _____________________
9| |x| |x| |x| |x| |x|
 _____________________
10|x| |x| |x| |x| |x| |
Red (X) Side
 _____________________

Player X, choose the piece to move:
Row:

第 11 章 结构体
11.1 关联多个值
现在可以将单个值存储在一个数组中了，这使你有可能编写出可以处理大量数据的程序。
当你处理更多的数据时，可能会遇到不同数据块间有关联的情况。
比如，你想将电子游戏中多个玩家在屏幕上的坐标 （x和y值）与玩家的名字一起存储。现在可以用三个独立的数组来实现这个目的：
int x_coordinates[10];
int y_coordinates[10];
string names[10];
但要注意，每个数组都是跟其他数组相关联的。因此，如果你移动了某一个数组里某个元素的位置，
就必须移动另外两个与其相对应的数组元素的位置。又要跟踪第四个数组里的值时，这会变得非常烦琐。
你必须增加另一个数组，并使其与原来的三个数组保持同步。
幸好设计编程语言的人不是受虐狂，设计了一个更好的能够将相关联的值组合起来的方法 ――结构体。
结构体允许你将不同的值存储在同一个变量名下的不同变量中。当多块数据需要组合在一起时，结构体就能派上用场了。
11.1.1 语法
定义一个结构体的语法格式是：
struct SpaceShip
{
    int x_coordinate;
    int y_coordinate;
    string name;
};   // <- 注意分号，千万不能漏掉它
此处的SpaceShip是我们所定义的特定结构体类型的名称。
换句话说， 你创建了自己的类型。就像使用double或int一样，你可以使用这个结构体类型来声明一个变量：
SpaceShip my_ship;
变量名x_coordinate、y_coordinate和name都是新类型的域（field）。 等等，域，什么是域？
实际情况是这样的：刚刚我们创建了一个复合类型，它是一个存储了多个相互关联的值（比如屏幕的x和y坐标，或姓氏与名字）的变量。
通过把要访问的值命名为域这种方式，可以区别这个复合类型变量中的值。这就像是两个不同名的变量，
但不同的是，这两个变量被组合在了一起，并以一致的方式来命名。你可以把结构体想象成具有多个域的表单（想一想驾驶执照应用程序），
表单里存储了大量的数据， 表单的每个域就是一块特定的相关数据。
声明一个结构体等价于定义一个表单，声明一个该结构体类型的变量等价于创建一个该表单的副本，可以用来填写和存储一连串的数据。
要访问结构体的域，将“.”加在结构体变量名后。（注意，不是结构体类型名后，每个结构体变量都有自己独立的域和值。）
接着，写域的名字：
// 声明变量
SpaceShip my_ship 
 
// 使用该变量
my_ship.x_coordinate = 40;
my_ship.y_coordinate = 40;
my_ship.name = "USS Enterprise (NCC-1701-D)";
如你所见，一个结构体里可以有许多域，这些域没有数量限制，也不要求类型相同。
现在，我们来看一个示例程序，该程序将结合数组和结构体，演示一个游戏读取5位玩家名称的过程（不包括该游戏的主体程序）：
#include <iostream>

using namespace std;

struct PlayerInfo
{
    int skill_level;
    string name;
};

using namespace std;

int main ()
{
    PlayerInfo players[ 5 ];
    for ( int i = 0; i < 5; i++ )
    {
        cout << "Please enter the name for player" << i << " : \n";
        cin >> players[ i ].name;
        cout << "Please enter the skill level for " << players[ i ].name << " : \n";
        cin >> players[ i ].skill_level;
    }
    for ( int i = 0; i < 5; ++i )
    {
        cout << players[ i ].name << " is at skill level " << players[ i ].skill_level << "\n";
    }
}
显示结果如下
Please enter the name for player0 :
Hello
Please enter the skill level for Hello :
6
Please enter the name for player1 :
World
Please enter the skill level for World :
8
Please enter the name for player2 :
Mark
Please enter the skill level for Mark :
9
Please enter the name for player3 :
Thomas
Please enter the skill level for Thomas :
8
Please enter the name for player4 :
Peter
Please enter the skill level for Peter :
9
Hello is at skill level 6
World is at skill level 8
Mark is at skill level 9
Thomas is at skill level 8
Peter is at skill level 9

结构体PlayrInfo声明了两个域：玩家名称name和玩家技能等级skill_level。
由于可以像使用其他变量类型（比如int）一样使用PlayerInfo，故你可以创建一个PlayerInfo的数组。
创建了一个结构体数组后，你可以像访问简单类型数组中的元素那样，访问结构体数组中的每个元素；
要访问数组中第一个结构体的某个域，比如获取数组中第一个玩家的名字，使用players[0].name即可。
此程序将数组和结构体结合起来，在第一个for循环里，读取了包括两块不同数据在内的五个不同玩家的信息，
然后在第二个for循环中将这些信息显示出来。你不必再为每个玩家的数据都建立多个相关联的数组，
也就是不需要单独建立player_names和player_skill_level数组。
11.1.2 传递结构体变量
你可能经常会想到写一个函数，将结构作为函数的参数或返回值。
例如，如果你写了一个有移动飞船的小游戏，可能需要一个函数来初始化新出现的敌军的结构体：
struct EnemySpaceShip
{
    int x_coordinate;
    int y_coordinate;
    int weapon_power;
};

EnemySpaceShip getNewEnemy();
在此例中，调用getNewEnemy应该返回一个所有域都已初始化的结构体的值。你可以这样写：
EnemySpaceShip getNewEnemy()
{
    EnemySpaceShip ship;
    ship.x_coordinate = 0;
    ship.y_coordinate = 0;
    ship.weapon_power = 20;
    return Ship;
}
这个函数实际上是返回一个ship局部变量的副本。也就是说，它将会把该结构体的每个域都复制到新变量中。
虽然复制多个域的过程看似缓慢，但没关系，因为大多数情况下计算机的速度快到可忽略不计这一复制过程的开销。
然而，一旦你开始处理大量的结构体，问题便产生了！下一章我们将讨论如何使用指针来避免这些额外的复制操作。
为了获取返回的结构变量，可按如下方式书写代码：
EnemySpaceShip ship = getNewEnemy();
现在你能够像使用其他结构变量一样，轻松自如地使用ship变量了。
向函数传递一个结构体的代码应该像这样：
EnemySpaceShip upgradeWeapons (EnemySpaceShip ship)
{
    ship.weapon_power += 10;
    return ship;
}
将一个结构体传递到函数时，该结构体会被复制下来（就像刚才返回一个结构体那样）。
我们在该函数中对结构体作出的任何修改都会丢失。这也就是在这个函数中对结构体进行修改后，
将修改后的结构体作为函数的返回值返回的原因，因为原始的结构体要使用upgradeWeapons来修改EnemySpaceShip，我们必须这样写：
ship = upgradeWeapons( ship );
当upgradeWeapons函数被调用时，变量ship被复制到函数的参数里； 
当upgradeWeapons函数返回时，返回的EnemySpaceShip变量被复制回ship中，覆盖了原来的域。
这是一个简单的程序，演示了如何创建和升级单个敌军飞船：
struct EnemySpaceShip
{
    int x_coordinate;
    int y_coordinate;
    int weapon_power;
};

EnemySpaceShip getNewEnemy ()
{
    EnemySpaceShip ship;
    ship.x_coordinate = 0;
    ship.y_coordinate = 0;
    ship.weapon_power = 20;
    return ship;
}

EnemySpaceShip upgradeWeapons (EnemySpaceShip ship)
{
    ship.weapon_power += 10;
    return ship;
}

int main ()
{
    EnemySpaceShip enemy = getNewEnemy();
    enemy = upgradeWeapons( enemy );
}
示例代码33：upgrade.cpp
你也许想知道，如何创建无限数量的敌舰，并在游戏过程中保持对所有敌舰的跟踪。怎么创建敌舰？
你可以调用getNewEnemy函数。但怎么 追踪这些敌舰呢？你会将它们存储在什么地方呢？
目前，我们只能访问固定长度的数组。我们能创建一个EnemySpaceShip对象的数组：
EnemySpaceShip my_enemy_ships[ 10 ];
但这条语句一次最多给你10艘敌舰。这可能足够了，也可能不够。
我们将在接下来的几章里介绍解决这个问题的方法。下一章将从指针谈起。
问答题
1.下列哪个选项访问了结构体b里的域？
A. b->var;
B. b.var;
C. b-var;
D. b>var;

B
2.下列哪一项正确定义了一个结构体？
A. struct {int a;}
B. struct a_struct {int a};
C. struct a_struct int a;
D. struct a_struct {int a;};

D
3.下列的哪个选项正确地声明了类型名为foo，变量名为my_foo的结构体变量？
A. my_foo as struct foo;
B. foo my_foo;
C. my_foo;
D. int my_foo;

B
4.以下代码的最终输出结果是多少？
#include <iostream>

using namespace std;

struct MyStruct
{
    int x;
};

void updateStruct (MyStruct my_struct)
{
    my_struct.x = 10;
}

int main ()
{
    MyStruct my_struct;
    my_struct.x = 5;
    updateStruct( my_struct );
    cout << my_struct.x << '\n';
}

A. 5
B. 10
C. 此代码无法编译

A
实践题
1.编写一个程序，让用户可以在单个结构体中填入一个人的名字、地址，以及电话号码。

#include <iostream>
#include <string>

using namespace std;

struct Person
{
    string name;
    string address;
    string phoneNumber;
};

int main()
{
    Person person;

    cout << "Please enter your name:\n";
    getline(cin, person.name, '\n');

    cout << "Please enter your address:\n";
    getline(cin, person.address, '\n');

    cout << "Please enter your phone number:\n";
    getline(cin, person.phoneNumber, '\n');

    cout << "Your name is: " << person.name << '\n';
    cout << "Your address is: " << person.address << '\n';
    cout << "Your phone number is: " << person.phoneNumber << '\n';
}
显示结果如下
Please enter your name:
Mark Thomas
Please enter your address:
Hello World
Please enter your phone number:
123456789
Your name is: Mark Thomas
Your address is: Hello World
Your phone number is: 123456789

2.创建一个太空船对象的数组，并写一个程序，使太空船能够不断地更新位置，直到其在屏幕中无法显示为止。
假设屏幕的尺寸是1024像 素×768像素。

#include <cstdlib>
#include <ctime>
#include <iostream>

using namespace std;

struct EnemySpaceShip
{
    int xCoordinate;
    int yCoordinate;
    int weaponPower;
};

int const screenWidth = 1024;
int const screenHeight = 768;
int const maxNumberOfShips = 50;
int const moveScale = 10;

int randRange(int low, int high);
bool shipIsOnScreen(EnemySpaceShip ship);
bool shipsOnScreen(EnemySpaceShip ships[], int numberOfShips);
void printFleet(EnemySpaceShip fleet[], int numberOfShips);


int main()
{
    srand( time(nullptr) );

    cout << "Enter the number of 50 or fewer space ships that you want to fly around:\n";

    int numberOfShips;
    cin >> numberOfShips;
    if (numberOfShips > maxNumberOfShips)
    {
        numberOfShips = maxNumberOfShips;
    }

    int weaponHigh = 10;
    int weaponLow = 1;

    EnemySpaceShip fleet[maxNumberOfShips];
    for (int i = 0; i < numberOfShips; i++)
    {
        fleet[i].weaponPower = randRange(weaponLow, weaponHigh);
        fleet[i].xCoordinate = randRange(0, screenWidth);
        fleet[i].yCoordinate = randRange(0, screenHeight);
    }
    printFleet(fleet, numberOfShips);

    do
    {
        cout << "==================== Moving Ships that are Still On Screen ================================\n";
        for (int i = 0; i < numberOfShips; i++)
        {
            if ( shipIsOnScreen(fleet[i]) )
            {
                fleet[i].xCoordinate += randRange(-3 * moveScale, 3 * moveScale);
                fleet[i].yCoordinate += randRange(-3 * moveScale, 3 * moveScale);
            }
        }
        printFleet(fleet, numberOfShips);

    }
    while ( shipsOnScreen(fleet, numberOfShips) );

    cout << "All ships have left the " << screenWidth << "px X " << screenHeight << "px screen.";
}

void printFleet(EnemySpaceShip fleet[], int numberOfShips)
{
    for (int i = 0; i < numberOfShips; i++)
    {
        cout << "Ship # " << i + 1 << " (" << fleet[i].xCoordinate << ',' << fleet[i].yCoordinate << ')' << " Weapon power: " << fleet[i].weaponPower << '\n';
    }
}

int randRange(int low, int high)
{
    return rand() % (high - low + 1) + low;
}

bool shipsOnScreen(EnemySpaceShip ships[], int numberOfShips)
{
    for (int i = 0; i < numberOfShips; i++)
    {
        if (shipIsOnScreen(ships[i]))
        {
            return true;
        }
    }
    return false;
}

bool shipIsOnScreen(EnemySpaceShip ship)
{
    return ( (0 <= ship.xCoordinate && ship.xCoordinate <= screenWidth) &&
            (0 <= ship.yCoordinate && ship.yCoordinate <= screenHeight) );
}
显示结果如下
Enter the number of 50 or fewer space ships that you want to fly around:
8
Ship # 1 (113,248) Weapon power: 4
Ship # 2 (15,34) Weapon power: 5
Ship # 3 (414,409) Weapon power: 6
Ship # 4 (832,508) Weapon power: 1
Ship # 5 (761,456) Weapon power: 6
Ship # 6 (483,745) Weapon power: 8
Ship # 7 (234,404) Weapon power: 3
Ship # 8 (905,750) Weapon power: 10
==================== Moving Ships that are Still On Screen ================================
Ship # 1 (137,257) Weapon power: 4
Ship # 2 (41,36) Weapon power: 5
Ship # 3 (387,431) Weapon power: 6
Ship # 4 (837,508) Weapon power: 1
Ship # 5 (757,442) Weapon power: 6
Ship # 6 (456,753) Weapon power: 8
Ship # 7 (216,400) Weapon power: 3
Ship # 8 (914,723) Weapon power: 10

3.基于题1，创建一个地址簿程序。使用户不但能够填写单个结构体， 还能够添加新条目，每一个新条目都要有自己的名称和电话号码。
它允许用户添加任意多的条目；想一想，这做起来是否容易以及是否可行。该程序还应能够显示出全部或部分条目，使用户可以浏览条目列表。

#include <iostream>
#include <string>

using namespace std;

struct Person
{
    string name;
    string address;
    string phoneNumber;
};

int const maxNumberOfEntries = 50;

int main()
{
    int numberOfEntries;
    cout << "Please specify between 1 and " << maxNumberOfEntries << " the number of address book entries that you want to fill...\n";
    cin >> numberOfEntries;
    cin.clear();
    cin.ignore(80, '\n'); 

    if (numberOfEntries < 1)
    {
        numberOfEntries = 1;
    }

    Person people[maxNumberOfEntries];

    int actualNumberOfEntries = 0;
    for (int i = 0; i < maxNumberOfEntries; i++)
    {
        string temp;

        cout << "Please fill out # " << i + 1 << " of " << numberOfEntries << " entries.\n";
        cout << "Please enter your name:\n";
        getline(cin, people[i].name, '\n');

        cout << "Please enter your address:\n";
        getline(cin, people[i].address, '\n');

        cout << "Please enter your phone number:\n";
        getline(cin, people[i].phoneNumber, '\n');

        string addMore;
        cout << "Would you like to add another name? (Y/N)\n";
        cin >> addMore;
        cin.clear();
        cin.ignore(80, '\n'); 

        actualNumberOfEntries++;
        if (addMore == "N")
        {
            break;
        }
    }

    cout << "Writing out contents of address book:\n";
    cout << "=====================\n";
    for (int i = 0; i < actualNumberOfEntries; i++)
    {
        cout << "Entry # " << i + 1 << '\n';
        cout << "Your name is: " << people[i].name << '\n';
        cout << "Your address is: " << people[i].address << '\n';
        cout << "Your phone number is: " << people[i].phoneNumber << '\n';
        cout << "=====================\n";
    }
}
显示结果如下
Please specify between 1 and 50 the number of address book entries that you want to fill...
8
Please fill out # 1 of 8 entries.
Please enter your name:
Mark Thomas
Please enter your address:
Hello World
Please enter your phone number:
123456789
Would you like to add another name? (Y/N)
Y
Please fill out # 2 of 8 entries.
Please enter your name:
Peter
Please enter your address:
USA
Please enter your phone number:
123
Would you like to add another name? (Y/N)
Y
Please fill out # 3 of 8 entries.
Please enter your name:
Smith
Please enter your address:
UK
Please enter your phone number:
789
Would you like to add another name? (Y/N)
N
Writing out contents of address book:
=====================
Entry # 1
Your name is: Mark Thomas
Your address is: Hello World
Your phone number is: 123456789
=====================
Entry # 2
Your name is: Peter
Your address is: USA
Your phone number is: 123
=====================
Entry # 3
Your name is: Smith
Your address is: UK
Your phone number is: 789
=====================

4.编写一个程序，允许用户输入一个游戏的高分，并保持对用户名和分数的跟踪。
添加一个功能，使之可以显示每个用户的最高分、特定用户的所有分数、所有用户的所有分数，以及用户的列表。

#include <iostream>
#include <string>
#include <vector>

using namespace std;

struct User
{
    string name;
    vector <int> scores;

    int highScore()
    {
        int size = scores.size();
        int highScore = 0;
        for (int i = 0; i < size; i++)
        {
            if (scores.at(i) > highScore)
            {
                highScore = scores.at(i);
            }
        }
        return highScore;
    }
};

void listUsers(User users[], int numberOfUsers);
void allScores(User user);
void allScores(User users[], int numberOfUsers);
void allScoresFromSpecifiedUser(User users[], int numberOfUsers);
void highestScores(User users[], int numberOfUsers);

int main()
{
    User users[50];
    int usersAdded = 0;
    int scoreTemp;

    for (int i = 0; i < 50; i++)
    {
        string result;
        cout << "Please enter your name: \n";
        getline(cin, users[i].name, '\n');

        cout << "Enter scores (0 to stop) : \n";
        for (int j = 0; j < 50; j++)
        {
            cout << "Score: ";
            cin >> scoreTemp;
            if (scoreTemp <= 0)
            {
                break;
            }
            users[i].scores.push_back(scoreTemp);
        }

        usersAdded++;
        cout << "Would you like to enter scores for another user? (Y/N)\n";
        cin >> result;
        cin.clear();
        cin.ignore(80, '\n'); 

        if (result == "N")
        {
            break;
        }

        cout << '\n';
    }
    cout << '\n';
    cout << '\n';

    int option = 0;
    do
    {
        cout << "Please select from the following:\n";
        cout << "(1) Print names of all users\n";
        cout << "(2) Print the highest score from each user\n";
        cout << "(3) Print all scores from a specified user\n";
        cout << "(4) Print all scores from all users\n";
        cout << "(5) Exit\n";
        cout << "=========\n";
        cin >> option;
        cin.clear();
        cin.ignore(80, '\n'); 

        cout << "\n\n";
        switch (option)
        {
        case 1:
            listUsers(users, usersAdded);
            break;
        case 2:
            highestScores(users, usersAdded);
            break;
        case 3:
            allScoresFromSpecifiedUser(users, usersAdded);
            break;
        case 4:
            allScores(users, usersAdded);
            break;
        case 5:
            break;
        default:
            break;
        }
    }
    while (option != 5);
}

void allScoresFromSpecifiedUser(User users[], int numberOfUsers)
{
    cout << "Users:\n";
    int choice = -1;
    for (int i = 0; i < numberOfUsers; i++)
    {
        cout << '(' << i << ") " << users[i].name << '\n';
    }
    do
    {
        cout << "Please choose the user by number to print all scores for.\n";
        cin >> choice;
    }
    while (choice < 0 || numberOfUsers <= choice);

    cin.clear();
    cin.ignore(80, '\n'); 

    cout << "\n\n";
    allScores(users[choice]);
    cout << "\n\n";
}

void listUsers(User users[], int numberOfUsers)
{
    cout << "Users:\n";
    for (int i = 0; i < numberOfUsers; i++)
    {
        cout << users[i].name << '\n';
    }
    cout << "\n\n";
}

void highestScores(User users[], int numberOfUsers)
{
    cout << "Highest score for each user:\n";
    for (int i = 0; i < numberOfUsers; i++)
    {
        cout << users[i].name << ": " << users[i].highScore() << '\n';
    }
    cout << "\n\n";
}

void allScores(User users[], int numberOfUsers)
{
    cout << "All scores for all users:\n";
    for (int i = 0; i < numberOfUsers; i++)
    {
        allScores(users[i]);
    }
}

void allScores(User user)
{
    cout << "All scores for user " << user.name << ":\n";
    int size = user.scores.size();
    for (int scoreIndex = 0; scoreIndex < size; scoreIndex++)
    {
        cout << user.scores.at(scoreIndex) << '\n';
    }
    cout << "\n\n";
}
显示结果如下
Please enter your name:
Mark Thomas
Enter scores (0 to stop) :
Score: 88
Score: 77
Score: 66
Score: 99
Score: 0
Would you like to enter scores for another user? (Y/N)
Y

Please enter your name:
Peter
Enter scores (0 to stop) :
Score: 87
Score: 89
Score: 68
Score: 0
Would you like to enter scores for another user? (Y/N)
Y

Please enter your name:
Smith
Enter scores (0 to stop) :
Score: 98
Score: 97
Score: 91
Score: 0
Would you like to enter scores for another user? (Y/N)
N


Please select from the following:
(1) Print names of all users
(2) Print the highest score from each user
(3) Print all scores from a specified user
(4) Print all scores from all users
(5) Exit
=========
1


Users:
Mark Thomas
Peter
Smith


Please select from the following:
(1) Print names of all users
(2) Print the highest score from each user
(3) Print all scores from a specified user
(4) Print all scores from all users
(5) Exit
=========
2


Highest score for each user:
Mark Thomas: 99
Peter: 89
Smith: 98


Please select from the following:
(1) Print names of all users
(2) Print the highest score from each user
(3) Print all scores from a specified user
(4) Print all scores from all users
(5) Exit
=========
4


All scores for all users:
All scores for user Mark Thomas:
88
77
66
99


All scores for user Peter:
87
89
68


All scores for user Smith:
98
97
91


Please select from the following:
(1) Print names of all users
(2) Print the highest score from each user
(3) Print all scores from a specified user
(4) Print all scores from all users
(5) Exit
=========
3


Users:
(0) Mark Thomas
(1) Peter
(2) Smith
Please choose the user by number to print all scores for.
0


All scores for user Mark Thomas:
88
77
66
99




Please select from the following:
(1) Print names of all users
(2) Print the highest score from each user
(3) Print all scores from a specified user
(4) Print all scores from all users
(5) Exit
=========
5

第 12 章 指针简介
12.1 忘记之前对指针的认知
很遗憾，指针的概念被很多初学者（甚至专业程序员）认为是一个神秘的东西。
如果曾听说指针不易学习、让人困惑或是难以理解，请忘记和忽略一切关于这类“难”的说法。
事实上，在我以前教编程的时候，几乎每个学生都能很好地理解并掌握关于指针的知识。
读完我的书，我保证你也能够理解指针的工作原理、作用及使用方法。当然，前提是你要花时间认真学习。
理解指针可能会花几天时间消耗些脑细胞，不过，给大脑简单做个“健 身”运动也挺好的。
我保证，接下来几章会被分成若干小块来写，这样 你的大脑可以多多休息。在介绍语法细节前，我先解释指针的概念和作用。
12.2 指针的概念以及关注指针的原因
到目前为止，我们所能够使用的内存大小是固定的，这个大小在程序开始运行前就已经确定了。
当你声明一个变量时，底层会分配出一定大小的内存来存储变量的信息，而分配内存的多少，则是在编译时确定的，
在程序运行阶段，你不能改变分配的这块内存的大小。我们已经能够创建数据数组来使用大量的变量，其实质就是一大串内存。
但是，数组不能够存储超过写程序时就已指定好的元素数量。
在接下来的几章里，我们将学习如何访问比程序开始运行时所占用的更多的内存空间。
你将学习如何创建数量无限制的敌舰，它们可以同时在四周飞行（当然，要减掉飞走的数量）。
为了能够访问（几乎）无限量的内存，我们需要一种类型的变量，它能够直接引用存储着变量值的内存，这种变量就叫做指针。
顾名思义，指针就是“指向”内存空间的变量。指针与超链接非常类似。
一个网页存储于某个位置（即某个Web服务器）。你如果想将该网页的副本发送给某人，需要下载整个页面并通过电子邮件发送给他吗？
不，发送一个链接就好了。同样，一个指针允许你保存或发送一个到变量、数组或结构体的“链接”，而不是制作一份副本。
与超链接类似，指针存储着一些数据的位置，即地址。
因此，你可以使用指针来保存从操作系统那儿获得的地址。换言之，使用指针使程序能够请求更多的内存，并且能访问这些内存。
实际上，你早就见过指针的例子了；当将一个数组传递给函数时，数组没有被复制，而是直接传递给这个函数了。
这一过程就使用到了指针。看，指针没那么难理解！
但在更深入地讨论之前，让我们先来谈谈内存。
12.3 内存的概念
有一个将内存概念形象化的简单方法，就是把它想象成一个Excel电子表格。电子表格由许多的“单元格”组成，每个单元格可以存储一段数据。
计算机内存也类似：它由大量连续的数据段构成。而与Excel不同的是，内存里的每个“单元格”仅能存储一段非常小的数据――1字节，
而1字节本身只有256个可能的取值（0~255）。而且，内存是一种“线性”的组织结构，而Excel是一种网格结构。
事实上，你甚至可以将内存看做一个非常长的字符数组。
正如Excel里的每个单元格都可由行号和列号来定位一样，内存里的每个“单元格”也有一个地址。
当指针保存了某个“单元格”的内存地址时， 指针里存储的值即为该地址。
（在Excel中，指针就是一个保存了另一个单元格的名称的单元格――比如，单元格C1里的内容是字符串 A1。）
下面是一小块内存的示意图。它看起来很像一个数组，其实数组本身就是一串连续的内存。
此处的方框表示能够存储数据的内存空间，方框上方的数字是内存地址，每个数字都标识着一个内存位置。
这些数字之间的步长为4，因为在内存中多数变量都占用4字节。此图表示与6个不同的4字节变量相关联的内存模型。
（顺便说一句，你经常会看到以十六进制格式表示的内存地址。如果你第一次见到这样的数字，可能会将它看做“无意义的数据”。
不过，不用担心，我会使用一般的数字表示方式。）
其实，“一个变量在内存中占用4字节”这一说法，只有在32位机器上才成立（32位等于4字节）。
多数32位CPU的指令都是以4字节为大小来操作数据的。即便如此，这种说法也不全对，因为还存在一些变 量，
其大小是大于4字节的（比如double类型的变量）。为了简化问题，现在还不需考虑这些细节。
十六进制数以16为基底，通常以这样的格式来书写：0x10ab0200， 0x表示这是一个十六进制数，剩余的是数字，
其中A~F表示数值10~15。
地址4处的内存是一个指针变量，其存储的值可以是另一个变量的内存地址――16。
其他标记为 ?? 的值表明它们不具有任何特定的已知值；当然，任何时刻每个内存地址里都存储着某些值。
在该内存块被初始化之前，这个值是没有用的，可以是任何值。
12.3.1 变量与地址
你可能会很困惑，变量和地址究竟有什么区别？变量是值的表示形式，这个值实际上存储在一个特定的内存位置，即一个特定的内存地址。
换句话说，编译器使用内存地址来实现程序中的变量。指针是一种特殊类型的变量，可以存储一个变量的地址。
最酷的是，一旦你拥有了变量的地址，就可以从这个地址中取出存储在其中的数据。
如果你恰好要将一个巨大的数据块传递到一个函数中，在程序运行时刻将数据块的位置传递给函数，要比复制数据块的所有数据高效得多
（类似于刚才针对数组的操作）。这个方法同样可以用来避免传递结构体的副本到函数。
我们的思路是将该结构体中数据的内存地址传递给函数，而不是将该结构体的数据复制一份。
指针最重要的功能是让你在任何时候都可以从操作系统里获取更多的内存。
怎样从操作系统里获取内存呢？操作系统会告诉你该内存的地址，你需要用一个指针将其存储下来。
如果你之后又需要更多内存的话，可以向操作系统申请更多的内存，并更新指针的值。
因此，指针使我们可以使用超过固定大小的数据，在程序运行时动态选择需要的内存大小。
操作系统管理内存，这一说法并不全对。事实上，通常会有几个不同“层”的代码来处理内存分配。
操作系统是其中一层，但在操作系统上面还有其他层。为了避免混乱，我们先暂且忽略这些区别。
如果你不能完全理解，请不要担心。如果它很重要的话，我是不会做个注释就草草了事的。
现在姑且不必理会它，稍后它才会有意义。
相关术语的说明
指针可以指：
1. 内存地址本身； 
2. 存储内存地址的变量。
通常，两者之间的区别并不重要。因为如果你传递一个指针变量给函数，就是在传递该指针的值，也就是内存地址。
当我想讨论一个内存地址时，会称它为内存地址，或仅仅称为地址； 
当想讨论一个存储着内存地址的变量时，我才会称它为指针。
当一个变量存储了另一变量的地址，我会说，它指向了那个变量。
12.3.2 内存布局
内存究竟从何而来？为什么请求内存时无论如何都要通过操作系统呢？
Excel中有非常多的单元格供你使用。计算机中也有非常多的内存供你 访问。
但是，内存比Excel更结构化。你的程序可使用的内存中，有一些已经在使用。
当前正在执行的函数中声明的变量就正存储于内存中，这部分在使用的内存称为栈。
之所以称为栈，是因为如果你调用了若干个函数，那么系统会按照函数的调用顺序，
将每个函数的局部变量以“栈叠加”的方式放置于这段内存中。我们目前使用到的所有变量都存储在栈上。
内存的第二部分是未分配内存区域（free store），有时又称为堆。
这是一片尚未分配的内存区域，你可以以块为单位来请求它。这部分内存由操作系统进行管理，
一旦一块内存被分配出去，它便只能由分配了这块内存的原始代码使用，或是由内存分配器将这块内存的地址交付给代码来使用。
使用指针，我们便可以访问这块内存。
能够访问内存是很强大的。但能力越大，责任也越大。内存是稀缺资源，虽然不像在GB级的RAM成为标准之前那么稀缺，但它仍然是有限的。
每一块从未分配内存区域中分配出来的内存，当你的程序不再需要它时，都应释放回去。
负责释放特定内存块的代码称为该内存的所有者。当内存的所有者不再需要该内存时，例如在一个空间射击游戏中，
如果一艘船被摧毁，这艘船的内存的所有者就应该将该内存释放回未分配内存区域，以便这块内存可以重新分配给其他代码语句使用。
如果不这样做，程序将会耗光内存，导致运行速度下降甚至崩溃。
你或者你身边的人可能抱怨过火狐浏览器（Firefox）占用了太多的内存，导致浏览器越来越慢，像龟爬似的，
这就是因为某些开发者没有释放本应释放的内存，造成了所谓的内存泄漏。
我得为火狐辩解下。有些问题可能是由于写得很差的扩展（即用户写的附加组件）造成的，不能怪罪于火狐内核。
不过，最终的结果是一样的：运行时的内存不足给用户带来了严重的后果！
所有权这个概念是函数及其使用者之间接口的一部分，它在编程语言中没有显式出现。
当你写一个函数，它接受一个指针，你应该说明该函数是否占用了内存的所有权。
C++不会为你追踪内存的所有权。只要程序正在运行，C++就永远不会帮你释放已经显式分配了的内存， 除非你显式要求释放。
事实上，只有某些代码应使用某些内存，这就是为什么不能随便取一些内存地址来使用；
如果只是生成一个随机数，然后把它当做内存地址来用，后果会怎样呢？
技术上来讲可以这样做，但这是一个糟糕的想法。你不知道谁被分配了这块内存，甚至有可能是栈本身，
如果你修改了内存里存储的值，就会破坏正在使用中的数据！
为了帮助发现 这类问题，操作系统会将尚未分配给你使用的内存保护起来――该内存对你来说是非法的，
访问非法内存将导致程序崩溃，这样，你就能察觉到这类问题。
随机生成的内存地址还存在一个小问题，即内存地址一般需要对齐。要访问一个整型数，所使用到的内存地址必须是4的倍数。
如果你随机生成一个内存地址，必须正确对齐。不同的计算机体系结构对内存对齐有着不同的要求，
由于对性能的需求不同，这种现象普遍存在。
等一下，我说崩溃也是好事一桩吗？嗯，的确是！相比将错误数值写入合法内存中引起的错误，访问非法内存造成的崩溃更容易被发现。 
你通常会很快发现此类崩溃，因为问题立即就会发生。如果改变了本不属于你的内存，
这个错误会持续到拥有该内存的代码尝试去使用它时才会发生，而这可能距内存被修改已经很长时间了。
我的一个同事喜欢把它解释为："轮胎脱落时，车轮螺母一公里前就掉了。"
顺便说一句，有些人会告诉你，非法内存造成的崩溃很难诊断，这是因为那些人没读过这本书。
第20章将讨论如何调试由非法内存造成的崩溃。
1. 非法指针
一种可能不小心访问非法内存的情况是：使用了未初始化过的指针。 
声明一个指针时，指针中的数据是随机生成的，它指向一个可能合法，也可能非法的位置。
不过可以肯定的是，此时使用它相当危险， 这等同于使用了一个随机生成的地址！
使用此数值可能导致程序崩溃，或数据损坏。你必须在使用指针前初始化它！
2. 内存和数组
还记得我说过么？越过数组末端写数据会发生问题，对吧？
现在，我们知道了更多关于内存的知识，你可以理解为什么了吧。
数组具有一段与其关联的特定数量的内存，数量的多少由数组的大小决定。
如果你访问数组末端之后的元素，访问的就是与数组不相关的内存；没错，这块内存不在数组中。
而这块内存究竟是什么，这取决于实际的代码和编译器的实现方式。但它不会是数组的一部分，所以使用它肯定会产生问题。
12.4 指针的其他优点（和缺点）
现在，你已经了解了一些指针的细节。我们回想一下之前的比喻，再来权衡下一些使用指针的利弊。
超链接和指针有很多相同的优点和缺点。
1. 不必做复制；如果该网页又大又复杂，复制可能很难（比如将整个维基百科的一份副本发送给某人）。
同样地，内存中的数据可能相当复杂，它可能很难被正确地复制（后面将详细讨论），或者复制的速度太慢
（复制大量的内存可能会非常耗时）。
2. 不必担心获得的是否是网页的最新版本。如果作者更新了网页，只要重新访问该链接就能得到更改的内容。
如果你有一个指向内存的指针，就总是能够访问那个内存地址的最新值。
当然，发送链接而不是副本，也存在一些不足之处。
1. 页面可能被移动或删除。类似地，即使指针仍指向某块内存，该内存还是有可能已经被释放回了操作系统。
为了避免这类问题，拥有这块内存的代码必须跟踪并确定是否有其他人正在使用它。
2. 你必须在线才能访问页面。这是超链接的缺点，但通常不会影响指针。
将指针比喻为Web上的链接，可以帮助你理解为什么要使用指针，但也有些问题。
一是超链接和Web是不同的东西，而指针和变量则不是。这是什么意思呢？
指针只是另一种变量（但它有其特殊性质）， 而超链接不是网页。
但从另一方面来说，指针不同于普通类型的变量，就像是超链接不同于网页一样。
到目前为止，全清楚了吗？我答应过将指针的内容分成很多的短章， 以便你的大脑能休息一下。
所以，本章就先到此为止吧。
现在你已经掌握了一些所需的核心知识，下一章将讨论使用指针的具体细节。
问答题
1.以下哪项不是使用指针的好理由？
A.你想要允许函数修改传递给它的参数
B.你想要避免复制一个占用了很大内存的变量，以节省空间
C.你希望能够从操作系统获得更多的内存
D.你希望能够更快速地访问变量

D
2.指针中存储的是什么？
A.另一个变量的名称
B.一个整数值
C.另一个变量在内存中的地址
D.一个内存地址，但不一定是另一个变量

D
3.程序执行过程中，从哪里可以获取到更多的内存？
A.不能得到任何更多的内存
B.栈
C.未分配内存区域
D.通过声明另一个变量

C
4.使用指针时，可能会遇到什么错误？
A.访问了本不能用到的内存，导致崩溃
B.访问错误的内存地址，导致数据污染
C.忘了将内存释放回操作系统，导致程序耗光内存
D.以上皆可能

D
5.函数中声明的普通变量，其内存来自哪里？
A.未分配存储区域
B.栈
C.普通变量不使用内存
D.来自该程序的二进制文件本身

B
6.分配到内存后，需要做些什么？
A.什么都不用做，它永远是你的
B.使用完后要释放回操作系统
C.将所指向的值置为0
D.将值0存入指针中

B

第13章 使用指针
现在，我们已经了解了内存的概念，以及应如何理解内存。那么，如何编写使用内存的代码呢？
在本章中，你将学会使用指针的语法，通过大量图表和一些基本例子来学习真正的程序是如何使用指针的。
下一章才会介绍如何完全访问未分配内存区中的内存，而本章你只需掌握做到这一点的所有工具。
13.1 指针的语法
声明一个指针
C++有专门的语法来声明一个指针变量。该语法不仅仅指出一个变量为指针，同时表明指针所指向的内存的类型。
以下是声明一个指针变量的语法：
<type> * <ptr_name>;
例如，可以声明一个指针，用它存储一个整型数的地址：
int * p_points_to_integer;
注意，这里的*是关键所在，它紧挨着出现在变量名前时，表示声明该变量为指针。
我习惯在变量名前加个p_前缀，以便清楚地表明该变量是个指针，但这不是C++的语法所必需的。
有个小陷阱：要在一条声明语句中声明多个指针，就必须在每个变量名前都加上星号：
// p_pointer1是指针, nonpointer1是普通的int变量
int *p_pointer1, nonpointer1;
 
// p_pointer1和p_pointer2都是指针
int *p pointer1 *p pointer2;
你可能会奇怪：为什么没有一种更简单的方式来声明指针呢？
比如，用pointer p_pointer这样的语句。这是因为，要让编译器能够正确地解释和使用内存地址，
就需要让它知道地址中存储的是哪种类型的数据（比如，内存中相同的字节数对于double和int类型来说，意义不一样。）
与其为每种指针类型创建单独的名字（比如用int_ptr表示int类型的指针，char_ptr表示char类型的指针，等等），
还不如总是用*和类型名来声明指针。
13.2 指针的指向：变量的地址
指针既可以直接指向新分配的内存，也可以指向一个已经存在的变量。
来看看这要怎么做。为了获得变量地址（即变量在内存中的位置），要把符号&放在变量名前。
&称为取地址操作符，因为它能返回变量的内存地址：
int x;
int * p_x = & x; 
*p_x = 2;   // initialize x to 2
&的作用是得到变量的地址，使用&符号就像是通过网站的地址栏获得该网站的URL（统一资源定位符，即我们常说的网址），
否则， 我们只能光盯着网页的内容看了。
获取变量地址的意义通常是为了做些独特的事情――大多数时候，是想从变量中获得其实际的值。
指针的使用
使用指针同样也需要一些新的语法。指针的使用通常可以用来做下列两件事：
1.获得指针中存储的内存地址；
2.获得内存单元中存储的值。
要获得指针中存储的内存地址，直接使用指针即可，就像使用一个普通变量一样。
下面的程序片段输出指针p_pointer_to_integer指向（存储）的地址：
int x = 5;
int * p_pointer_to_integer = & x;
cout << p_pointer_to_integer;   // 输出x的地址，等价于cout << & x;
这个代码片段打印输出变量x的内存地址，而这个地址存储在p_pointer_to_integer中。
要访问内存单元中存储的值，你可以使用*操作符。下面就是一个小例子：
int x = 5;
int * p_pointer_to_integer = & x;
cout << *p_pointer_to_integer;   // 输出5，等价于cout << x;
代码*p_pointer_to_integer表示"到指针所指向的内存，去取出存储在里面的值"。
此例中，指针p_pointer_to_integer指向了变量x，而x的值是5，所以输出了数值5。
有个简单的方法，可以记住*用于获取指针变量所指向的变量值：指针变量跟普通变量没什么两样儿，
我们可以通过变量名来获得变量的值，而指针变量的值就是它存储的内存地址。
如果我们还想做一些更 复杂的事儿，比如获得内存地址中存储的值，就必须使用特殊的语法，即使用*号，*被看做特殊行为的标志。
使用*来获得指针变量指向的地址的值，这一过程称为间接引用指针。
这个名词的由来是为了获得地址中存储的值，我们是通过一个到该内存地址的引用，使用它，间接地达到目的地。
通过间接引用指针，还可以修改指针地址所指向的变量的值：
int x;
int *p_pointer_to_integer = & x;
*p_pointer_to_integer = 5;   // x现在为5
cout << x;
那么，什么时候应该在变量名前加上*号（或&号）呢？这个其实很容易出错。下表可供参考：
操作目的                           需要的操作符                           示例
声明指针                           *                                             int *p_x;
获得指针所指向的地址         不需要                                    cout << p_x;
调整指针所指向的地址         不需要                                    int *p_x; p_x = address;
获得指针所指向的地址中的值         *                                   cout << *p_x;
调整指针所指向的地址中的值         *                                   *p_x = 5;
声明变量                           不需要                                     int y;
获得变量的值                     不需要                                    int y; cout << y;
调整变量的值                     不需要                                    int y; y = 5;
获得变量的地址                  &                                           int y; int *p_x; p_x = & y;
调整变量的地址                  不可行                                    不可以。变量地址不能更改
记住这张表，只需要两个简单的规则：
指针存储的是地址。因此，直接使用“裸”指针得到的就是地址。要获得或调整存储在该地址中的值，必须添加额外的*。
变量存储的是数据值。因此，直接使用变量得到的就是数据值。而要获得变量的地址，就必须额外添加&。
现在，我们通过一个简单的程序，来演示这些功能，并学习一个很实用的分析内存变化情况的技巧。
#include <iostream>

using namespace std;

int main ()
{
    int x;
    int *p_int;

    p_int = & x;
    cout << "Please enter a number: ";
    cin >> x;
    cout << *p_int << '\n';
    *p_int = 10;
    cout << x;
}
示例代码34：pointer.cpp
显示结果如下
Please enter a number: 8
8
10
第一个cout输出变量x的值。这是怎么发生的呢？让我们逐步地执行程序，观察内存是怎样变化的。
我们用箭头来表示指针指向的位置，方框中的数字表示非指针变量在内存中的值。
刚开始，我们有一个整型变量x，以及一个指向整型的指针变量p_int。
直观上，可以认为现在有两个值未知的变量（它们可能彼此相邻）。
接着，代码通过使用取地址操作符（&）获得变量x的地址，并将该地址存储到指针p_int中。
p_int = & x;   // 将x的地址赋值给p_int
因此，我们可以画一条从变量p_int到变量x的箭头，表示指针p_int指向变量x。
然后用户输入一个数字，存储在变量x中，该存储位置也是p_int所指向的位置。
cin >> x;         // 读入一个值并赋值给变量x，这里的x也可以用*p_int来表示
简单起见，我们假设用户输入数字5。现在内存的情况变成了这样：
接着，下一行代码将*p_int传给cout，它会检查p_int中的地址，并且到该地址中取出其变量值，
你可以结合内存示意图中的箭头来想象这一过程。
cout << *p_int << '\n';   // 使用*来获得指针所指向的变量的值
最后的两行语句表明，通过指针可以修改变量原来的值。这个语句将值10存储到p_int所指向的内存中，也即是存储着变量x的值的内存。
*p_int = 10;
现在的内存状态是：
你看，通过示意图，我们可以很容易弄明白使用指针时内存的变化过 程。
当你搞不清楚时，绘制出内存的初始状态，配合箭头图逐步运行程序，内存的变化过程就一目了然了。
每当指针的指向改变时，便绘制新的箭头；每当变量的值发生变化时，更新它的值。
通过这些操作，即使再复杂的系统，你也能够理解。
13.3 未初始化指针与空指针
注意到上面的例子中，指针p_int在使用前先被初始化指向了一块特定的内存地址。
如果不这样做，指针可能会指向任何位置，从而导致令人不快的后果，比如覆盖了其他变量的值，或程序崩溃，等等。
为了 避免此类事故或其他不良后果，你应该养成在使用指针前先初始化的好习惯。
有时候，你需要明确知道："哟，这个指针一看就没有被初始化。"
因此，可以用nullptr来标记一个明确没有被初始化的指针。
如果一个指针为nullptr，即说明它未初始化。每新建一个指针，你应该首先将它的值设置为nullptr，
这样可以方便以后检查，看看它是否已经被设置成了指向可用的地址。
否则，就没有办法测试指针是否可用，这可能会导致系统崩溃。
int *p_int = nullptr;  
...
if ( p_int != nullptr )
{
    *p_int = 2;
}
13.4 指针和函数
指针允许你将局部变量的地址传给函数，然后在函数中修改局部变量。
下面两个函数是说明这一过程的经典例子。这两个函数都试图交换两个变量中存储的值：
#include <iostream>

using namespace std;

void swap1 (int left, int right)
{
    int temp = left;
    left = right;
    right = temp;
}

void swap2 (int *p_left, int *p_right)
{
    int temp = *p_left;
    *p_left = *p_right;
    *p_right = temp;
}

int main ()
{
    int x = 1, y = 2;
    swap1( x, y );
    cout << x << " " << y << '\n';
    swap2( & x, & y );
    cout << x << " " << y << '\n';
}
示例代码35：swap.cpp
显示结果如下
1 2
2 1

先思考下，你猜哪个函数能正确地交换了两个值呢？
没错，swap1只是交换了swap1函数中两个局部变量的值，而无法修改传递过来的原始值，
因为swap1只是存储了原始值的一个副本（原始值在变量x和y中）。
直观上看，swap1函数调用和复制了变量x和y的值，并传给变量left和right；
接着，left的值被放入temp，而left被赋给right的值；
最后，temp的值被放入right。即，交换了left和right的值，但x和y的值完全没变。
函数swap2就有意思多了，它接受局部变量x和y的地址，变量p_left 和p_right现在指向了x和y。
现在，swap2可以访问变量x和y的内存。所以，当swap2执行交换操作 时，写入的是这两个变量的内存。
首先，将p_left指向的值复制给变量temp，然后，又将p_right所指向的值复制给p_left；
请注意，此刻变量x在内存中的值已经被修改了。最后，temp中的值赋给p_right所指向的内存，完成了交换。
像这样去交换两个变量的值，并不是指针的主要价值。C++的另一种语言特性，可以很容易地写出这类交换函数，无需通过完整的指针。
这一语言特性即“引用”。
13.5 引用
有时，你想利用指针的一些特性（如避免大块数据的额外副本），但又不需要其全部功能。
这种情况，往往可以使用引用。引用是指一个变量引用了另外一个变量，它们背后共享着相同的内存。
引用变量的使用方法跟普通变量类似，你可以将它想象成一个简化版的指针，
我们不需要在使用引用的值或给引用赋值时，使用特殊的*和&语法。
与指针不同的是，引用必须始终指向有效内存。声明一个引用，需要使用&符号：
int &ref;
然而，这个声明是非法的，因为引用必须初始化（引用必须总指向有效的地址）。
int x = 5;
int &ref = x;   // 注意，不需要在x的前面加上*号
我们可以用跟可视化指针相同的方式来可视化引用。但是，使用引用时，得到的是引用的内存中的值，而不是内存地址。
int x = 5;
int &ref = x;
这里，变量ref的实际地址持有一个指向变量x的内存的指针。当你直接写ref（即不带任何诸如&或*符号）时，
编译器知道你想要指向的实际的值。从某种意义上说，引用是一种跟指针的“默认”行为相反的指针，
当你使用变量名时，结果刚好跟使用指针相反。
给函数传递结构体时可以使用引用，而无需传递整个结构体，也不用担心空指针问题。
struct myBigStruct
{
    int x[ 100 ];
};

void takeStruct (myBigStruct &my_struct)
{
    my_struct.x[ 0 ] = 100;
}
由于引用始终指向初始对象，所以你可以避免复制整个对象，并能够修改传递到函数的原始对象。
上面的例子演示了如何修改my_struct.x[0]，使得函数返回时，传递到函数中的原始结构体的.x[0]等于100。
我们刚才学习了使用指针来写一个交换函数的方法，使用引用来写会更简便。现在来看一看：
void swap (int &left, int &right)
{
    int temp = right;
    right = left;
    left = temp;
}
注意，这远比使用等效的指针更简单。事实上，我们可以把引用仅仅看做原始变量的一个别名。
当然，在编译器中引用的实现使用了指针来存储，只不过获取真正的数据和间接引用等工作编译器都帮你做了。
引用与指针的区别
当需要通过多个名称来使用同一个变量时，我们可以使用引用来替代指针。
比如，你想要将参数传递给一个函数而不用复制它们，又或者希望函数对参数的修改能够对调用者可见。
引用并不像指针那般灵活，因为引用必须总是有效的。
不存在空引用 （null reference）――我们不能在使用引用时说“嘿，我引用的东西无效”，因为这不是设计引用的目的。
由于引用不能指向NULL，所以不能用它来构建复杂的数据结构。
接下来的几章，我们会更多地讨论数据结构的构建。每次构建数据结构前，先问问自己，你是否可以用引用来达到同样的效果。
引用和指针还有一个区别：一旦一个引用被初始化，你便不能改变它指向的内存。
引用永远指向相同的变量，这也限制了它们构建复杂的数据结构的灵活性。
剩下的几章中，我会在适当时候使用引用。尤其是将一个结构体或者类（我们以后会讲到类）的实例作为参数传给函数时，总会使用引用。使用引用的模式通常会是这样：
void (myStructType & arg);
问答题
1.下面哪个选项正确地声明了指针？
A. int x;
B. int &x;
C. ptr x;
D. int *x;

D
2.下面哪一项给出了整数变量的内存地址？
A. *a;
B. a;
C. &a;
D. address( a );

C
3.下面哪一项给出了指针p_a所指向的变量的内存地址？
A. p_a;
B. *p_a;
C. &p_a;
D. address( p_a );

A
4.下面哪一项给出了指针p_a所指向的地址中存储的值？
A. p_a;
B. val( p_a );
C. *p_a;
D. &p_a;

C
5.下列哪一项正确声明了一个引用？
A. int *p_int;
B. int &my_ref;
C. int &my_ref = & my_orig_val;
D. int &my_ref = my_orig_val;

D
6.下列哪一项不适合使用引用？
A. 为了存储一个未分配存储区中动态分配出来的地址
B. 为了避免一个较大的值传递给函数时的复制操作
C. 为了强制函数的一个参数，其值永远不能为NULL
D. 为了让一个函数能够访问传递给它的原始变量，而无需使用指针

A
实践题
1.写一个函数，提示用户输入姓氏和名字，姓和名要作为两个单独的值。
这个函数通过传递到该函数的额外的指针（或引用）参数，返回两个值给调用方。
先试着用指针来做，然后尝试使用引用。（提示： 函数签名看起来类似于前面的交换函数！）

#include <iostream>
#include <string>

using namespace std;

void getNameByPointer(string *firstName, string *lastName)
{
    cout << "Please enter your first name: ";
    cin >> *firstName;

    cout << "Please enter your last name: ";
    cin >> *lastName;
}

void getNameByReference(string &firstName, string &lastName)
{
    cout << "Please enter your first name: ";
    cin >> firstName;

    cout << "Please enter your last name: ";
    cin >> lastName;
}

int main()
{
    string firstName;
    string lastName;

    getNameByPointer(&firstName, &lastName);
    cout << "Your name is " << firstName << " " << lastName << '\n';

    getNameByReference(firstName, lastName);
    cout << "Your name is " << firstName << " " << lastName << '\n';
}
显示结果如下
Please enter your first name: Mark
Please enter your last name: Thomas
Your name is Mark Thomas
Please enter your first name: Hello
Please enter your last name: World
Your name is Hello World

3.修改实践题1中所写的程序，使得它不必总是提示用户输入姓氏。只有调用方传递进来的姓氏为空时，才提示。

#include <iostream>
#include <string>

using namespace std;

void getNameByPointer(string *firstName, string *lastName)
{
    cout << "Please enter your first name: ";
    cin >> *firstName;

    if ( lastName->empty() )
    {
        cout << "Please enter your last name: ";
        cin >> *lastName;
    }
}

void getNameByReference(string &firstName, string &lastName)
{
    cout << "Please enter your first name: ";
    cin >> firstName;

    if (lastName.empty())
    {
        cout << "Please enter your last name: ";
        cin >> lastName;
    }
}

int main()
{
    string firstName;
    string lastName;

    getNameByPointer(&firstName, &lastName);
    cout << "Your name is " << firstName << " " << lastName << '\n';
    cout << '\n';

    getNameByPointer(&firstName, &lastName);
    cout << "Your name is " << firstName << " " << lastName << '\n';
    cout << '\n';

    string firstName3;
    string lastName3;

    getNameByReference(firstName3, lastName3);
    cout << "Your name is " << firstName3 << " " << lastName3 << '\n';
    cout << '\n';

    getNameByReference(firstName3, lastName3);
    cout << "Your name is " << firstName3 << " " << lastName3 << '\n';
    cout << '\n';
}
显示结果如下
Please enter your first name: Mark
Please enter your last name: Thomas
Your name is Mark Thomas

Please enter your first name: Peter
Your name is Peter Thomas

Please enter your first name: Hello
Please enter your last name: World
Your name is Hello World

Please enter your first name: Smith
Your name is Smith World

4.写一个函数，它接受两个输入参数，返回两个结果给调用方：一个 是两个参数相乘的结果，另一个是相加的结果。
由于函数只能直接返回一个值，你需要通过指针或引用参数来返回第二个值。

#include <iostream>

using namespace std;

void add_multipy(int x, int y, int &sum, int &product)
{
    sum = x + y;
    product = x * y;
}

int main()
{
    int x;
    int y;

    cout << "Enter two numbers to get the sum and product. \n";

    cout << "x: ";
    cin >> x;

    cout << "y: ";
    cin >> y;

    int sum = 0;
    int product = 0;
    add_multipy(x, y, sum, product);

    cout << "x + y = " << x << " + " << y << " = " << sum << '\n';
    cout << "x * y = " << x << " * " << y << " = " << product << '\n';
}
显示结果如下
Enter two numbers to get the sum and product.
x: 8
y: 9
x + y = 8 + 9 = 17
x * y = 8 * 9 = 72

5.写一个程序，比较两个不同的变量在栈中的内存地址，并根据地址的数值顺序依次输出变量。

#include <iostream>
#include <string>

using namespace std;

int main()
{
    int number = 50;
    int *numberAddress = &number;
    int numberValue = number;
    cout << "Number variable has the following\n";
    cout << "Address: " << numberAddress << " Value: " << numberValue << '\n';

    int number2 = 1;
    int *numberAddress2 = &number2;
    int numberValue2 = number2;
    cout << "Number variable has the following\n";
    cout << "Address: " << numberAddress2 << " Value: " << numberValue2 << '\n';

    cout << '\n';
    cout << "Variables will be written in order of their addresses: \n";
    if (numberAddress2 < numberAddress)
    {
        cout << "Address: " << numberAddress2 << " Value: " << numberValue2 << '\n';
        cout << "Address: " << numberAddress << " Value: " << numberValue << '\n';
    }
    else
    {
        cout << "Address: " << numberAddress << " Value: " << numberValue << '\n';
        cout << "Address: " << numberAddress2 << " Value: " << numberValue2 << '\n';
    }
    cout << "\n\n";

    string name = "Mark";
    string *nameAddress = &name;
    string nameValue = name;

    cout << "Name variable has the following\n";
    cout << "Address: " << nameAddress << " Value: " << nameValue << '\n';

    string name2 = "Rutherfurd";
    string *nameAddress2 = &name2;
    string nameValue2 = name2;

    cout << "Name variable has the following\n";
    cout << "Address: " << nameAddress2 << " Value: " << nameValue2 << '\n';

    cout << '\n';
    cout << "Variables will be written in order of their addresses: \n";
    if (nameAddress2 < nameAddress)
    {
        cout << "Address: " << nameAddress2 << " Value: " << nameValue2 << '\n';
        cout << "Address: " << nameAddress << " Value: " << nameValue << '\n';
    }
    else
    {
        cout << "Address: " << nameAddress << " Value: " << nameValue << '\n';
        cout << "Address: " << nameAddress2 << " Value: " << nameValue2 << '\n';
    }
}
显示结果如下
Number variable has the following
Address: 0x7fffefe75f50 Value: 50
Number variable has the following
Address: 0x7fffefe75f54 Value: 1

Variables will be written in order of their addresses:
Address: 0x7fffefe75f50 Value: 50
Address: 0x7fffefe75f54 Value: 1


Name variable has the following
Address: 0x7fffefe75f80 Value: Mark
Name variable has the following
Address: 0x7fffefe75fc0 Value: Rutherfurd

Variables will be written in order of their addresses:
Address: 0x7fffefe75f80 Value: Mark
Address: 0x7fffefe75fc0 Value: Rutherfurd

第 14 章 动态内存分配
恭喜你熬过了前面几章枯燥的内容，现在一起进入指针的有趣部分： 使用指针来解决实际问题。
没错！我们终于为学习如何在程序运行时获得尽可能多的内存做好了准备。
虽然不太应该，但我们已经有能力“垄断”内存市场了！
14.1 获得更多的新内存
动态分配是指，在程序运行时请求所需要的内存大小。你的程序将计算出它所需的内存数量，而不是只能处理一组特定大小的固定的变量。本节将讲述如何分配内存的基础知识，后续各节将介绍如何充分利用动态分配的优势。
首先让我们来看看如何获得更多的内存。关键字new用来将未分配内存区中的内存初始化分配给指针。
请记住，未分配内存区是一块未使用的内存，你的程序可以请求访问它。以下是基本的语法：
int * p_int = new int;
new运算符需要一个“示例”变量，以便计算出所请求的内存大小。
在这 个例子中，示例变量是一个整数类型（int）。因此，new运算符接受一个整数类型，并返回足够的内存来容纳整数值。
p_int设置为指向该内存，使得p_int和使用p_int的相关代码成为了该内存的所有者。
换句话说，使用p_int的代码必须在不再使用该内存时，进行一个称为释放内存的操作，显式地将这块内存归还给未分配内存区。
在p_int释放之前，它所指向的内容被标记成了“正使用”（inuse），不能再次分配。
如果你一直分配内存但又不释放它，内存将耗光。
要“释放内存”，可以使用delete关键字，它把通过new分配到的内存释放回未分配内存区。以下语句释放p_int指向的内存：
delete p_int;
释放指针指向的内存后，将指针重置为nullptr是个不错的选择：
delete p_int;
p_int = nullptr;
这不是必要的。不过，指针一旦被delete，你就不能读写它指向的内存了，
因为这块内存已经释放回未分配内存区（而且很可能又分配出去）。
将指针设置为nullptr后，如果代码尝试间接引用一个释放了的指针（即使是经验丰富的程序员也常常犯这种错误），
你立即就能发现，因为该程序会崩溃。这种情况比用户数据被破坏后才发现要好得多。
14.1.1 运行内存不足
内存不是无穷无尽的资源。我们的确可以任意挥霍内存，但如果真这么做了，将无法获得更多的内存。
在C++中，如果因为系统内存不足 而导致调用new失败，系统将“抛出一个异常”。
通常不用担心这些，现代操作系统中这种情况极其罕见，许多程序可以忽略掉这种可能性。
 （如果程序写得很好并正确释放内存，它就更不可能发生了。一个永远不释放内存的程序，才最有可能引起内存不足。）
异常是接近本书结尾才介绍的高级内容。通常最好的做法是：始终释放你分配到的内存，别担心new操作会失败。
14.1.2 引用和动态分配
一般来说，不宜将刚分配到的内存存储于引用中：
int &val = *(new int);
其原因是：引用不直接访问原始的内存地址。虽然可以通过&来访问到，但是引用一般用在为变量提供额外的名称，
而不是存储动态分配的内存。
14.2 指针和数组
你可能有疑问，现在已经可以用new来将指针初始化指向一块内存了， 那如果想实际获取更多内存应该怎么办呢？
答案是，指针也可以指向一组值的序列。换句话说，指针可以像数组那样使用――毕竟，数组就是顺序布局在内存中的一组值的序列。
由于一个指针存储一个内存地址，所以它能够存储数组的第一个元素的地址。
要访问数组的各个元素，你只需知道该元素与数组起始地址的距离，而这个距离是固定的。
这有什么用呢？实际上，我们可以从未分配内存区中动态地创建一个数组，在运行时确定需要的内存数量。
稍后我会展示一个这样的例子，现在先来了解一些基础知识。
可以像这样，将一个数组直接赋值给指针，无需用到取地址操作符：
int numbers[ 8 ];
int * p_numbers = numbers;
现在，可以像使用数组一样地使用指针：
for ( int i = 0; i < 8; ++i )
{
    p_numbers[ i ] = i;
}
数组numbers被赋给指针时，仿佛它本身就是一个指针一样。重要的是理解清楚，数组不是指针，但数组可以被赋值给指针。
C++编译器知道怎样将一个数组转换为一个指针，这个指针会指向数组的第一个元素。
（这种转换在C++中经常发生。例如，你可以将一个char类型的变量赋给一个int类型的变量。
char不是int，但编译器知道如何进行转换。）
可以使用new动态来分配一个数组的内存，并将该内存赋给指针：
int * p_numbers = new int [ 8 ];
这条语句使用了数组的语法来作为new的参数，以便告诉编译器需要分配多少内存：只要8个元素的整数数组就够了。
现在，你可以像使用数组一样地使用指针p_numbers。不过与数组不同的是：需要释放p_numbers指向的内存，
但你从来不需要释放一个指向静态声明的数组的指针。有一个delete运算符的特殊语法，可以释放动态分配的数组内存：
delete [] p_numbers;
方括号告诉编译器，指针指向了一个数组，而不是单个值。
现在，到了你一直在翘首企盼的例子了：动态地确定需要多少内存：
int count_of_numbers;
cin >> count_of_numbers;
int * p_numbers = new int [count_of_numbers];
这段代码会询问用户需要的内存数量，然后使用该变量来确定动态分配的数组的大小。
事实上，我们甚至不需要预先知道确切的数字，而是随着数量的增长重新分配内存。这意味着可能要做一些额外的复制操作。
接下来看一段演示这种方法的程序，该程序读入用户输入的数字。一旦数字的数量超过了数组所能容纳的大小，我们就会重新调整数组。
#include <iostream>

using namespace std;

int *growArray (int *p_values, int cur_size);

int main ()
{
    int next_element = 0;
    int size = 10;
    int *p_values = new int [ size ];
    int val = 0;
    cout << "Please enter a positive number (0 to exit): ";
    cin >> val;
    while ( val > 0 )
    {
        if ( size == next_element )
        {
            p_values = growArray( p_values, size );
        }
        p_values[ next_element ] = val;
        next_element++;
        val = 0;
        cout << "Please enter a positive number (0 to exit): ";
        cin >> val;
    }
    for (int i = 0; i < next_element; i++)
    {
        if (i != 0)
        {
            cout << ", ";
        }
        cout << p_values[ i ];
    }
    delete [] p_values;
}
int *growArray (int *p_values, int cur_size)
{
    int *p_new_values = new int[ cur_size * 2 ];
    for ( int i = 0; i < cur_size; ++i )
    {
        p_new_values[ i ] = p_values[ i ];
    }
    delete [] p_values;
    return p_new_values;
}
示例代码36：resize_array.cpp
显示结果如下
Please enter a positive number (0 to exit): 1
Please enter a positive number (0 to exit): 2
Please enter a positive number (0 to exit): 3
Please enter a positive number (0 to exit): 4
Please enter a positive number (0 to exit): 5
Please enter a positive number (0 to exit): 6
Please enter a positive number (0 to exit): 7
Please enter a positive number (0 to exit): 8
Please enter a positive number (0 to exit): 9
Please enter a positive number (0 to exit): 11
Please enter a positive number (0 to exit): 12
Please enter a positive number (0 to exit): 13
Please enter a positive number (0 to exit): 14
Please enter a positive number (0 to exit): 15
Please enter a positive number (0 to exit): 16
Please enter a positive number (0 to exit): 17
Please enter a positive number (0 to exit): 18
Please enter a positive number (0 to exit): 19
Please enter a positive number (0 to exit): 21
Please enter a positive number (0 to exit): 22
Please enter a positive number (0 to exit): 23
Please enter a positive number (0 to exit): 24
Please enter a positive number (0 to exit): 25
Please enter a positive number (0 to exit): 26
Please enter a positive number (0 to exit): 0
1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 22, 23, 24, 25, 26

来考虑一下如何增长数组。怎么做呢？我们不能只是仅仅请求扩展内存，我们必须在获得更多的内存后把原来的值复制过来。
另一个问题是应该请求多少内存。一次增长一个数组元素的空间实在有些低效。
尽管你不会耗尽内存，但这会导致许多次不必要的内存分配操作，使得速度太慢。
一个好的策略是把当前的数组大小加倍。这样一来，如果停止读入新值，这不会浪费太多空间，
总共占用的空间不会超过使用中的空间的两倍，同时又不必不停地重新分配内存。
显然，我们需要知道当前数组的大小以及原始数组的值，以便复制原始数组。
int *growArray (int *p_values, int cur_size)
{
    int *p_new_values = new int[ cur_size * 2 ];
    for ( int i = 0; i < cur_size; ++i )
    {
        p_new_values[ i ] = p_values[ i ];
    }
    delete [] p_values;
    return p_new_values;
}
示例代码37：resize_array.cpp（待续）
请注意这段代码是如何在数组数据复制完成后，小心翼翼地删除掉原来的p_values。
一不留神，就会发生内存泄漏，因为程序从growArray返回后我们覆盖了指向原数组的指针。
14.3 多维数组
调整一个大数组的大小是非常有用的技术，你一定要掌握。但是，有时你想要处理的不仅仅是一个大数组。
还记得当我们讨论多维数组时，心情何等激动吗？如果能够选择多维数组的大小，是不是很厉害呢？
我们完全可以做到这一点。这是一个很好的帮助你真正深入理解指针的练习，而且它本身也非常有用。
不过，做到这一点需要掌握一些其他的背景知识。本章接下来的几个部分将介绍这些内容，
最后再向你展示如何动态分配多维的数据结构。
14.4 指针运算
本节将深入探索指针，可能需要多花点工夫来学习。但这些极富挑战性的内容很有意义，
如果你一遍不能理解清楚，那最好再读一遍。如果能理解本节的所有内容，包括二维数组的分配，
那么有关指针的一切你几乎都能够不太费力地掌握了。
所以，本节有点艰难，而且不像某些章那样立竿见影；但是相信我，如果多花些时间来学习，阅读本书的其余部分时你便能够事半功倍。
我们先来谈谈内存地址，以及如何看待它们。指针代表内存地址，而内存地址归根结底只是个数字。
所以，就像使用数字一样，你可以对指针执行一些数学运算。
例如，指针与一个数相加，或两个指针相减。什么情况下你会这么做呢？
比如当你想写一块内存，并且知道所要放置值的地方的实际偏移量时，就可以这么干。
这一切听起来像天方夜谭吗？其实你已经多次这样用了，那就是――数组！
如下代码所示：
int x[ 10 ];
x[ 3 ] = 120;
你正在执行指针运算，将第3个内存槽位的值设置为120，方括号只是做指针运算的语法糖。
通过如下语句可以执行相同的操作：
* ( x + 3 ) = 120;
我们来分析一下。令人惊讶而又迷惑的是，这不是把x的值增加3，而是增加了3*sizeof(int)。
sizeof是一个特殊的关键字，指以字节为单位返回一个类型的变量的大小，处理内存时经常会用到。
指针运算总是加上内存“槽位”（slot），而不是直接加上数字（就像使用数组的方括号可以访问特定的数组槽位一样）。
以变量大小为单位增减，能够防止意外使用指针对两个值之间的数据（例如，一个槽位的最后2字节和另一个槽位的前2字节）进行读写。
顺便说下，也可以让两个指针相减，以计算其距离。再次提醒，这个距离是槽位的数量而不是字节数
（两个不同类型的指针不能相减， 因为它们可能有不同大小的槽位）。
我很少看到指针之间相减。永远不要把两个指针相加，因为你只可以将指针加上一个偏移量。
大多数情况下，你应该使用数组语法，而不是试图进行正确的指针运算。
做指针运算时，你很难一直清醒地知道正在进行的事情，很容易就忽略是在增加内存槽位而不是单字节。
然而，理解指针运算能使你更容易做一些复杂的事情，后续几章将使用到这些能力。指针运算还有助于了解如何动态地分配多维数组。
14.4.1 理解二维数组
在开始学习分配多维数组前，你需要知道多维数组的真正含义。
再次提醒，这是一个哪怕困难重重也应该迎难而上努力理解的部分，守得云开见月明！
让我们从一个令人好奇的古怪现象谈起：当声明一个接收二维数组为参数的函数时，并不需要总是提供数组两个部分的大小，
只要提供第二个部分的大小就行。
你可以两个大小都提供：
int sumTwoDArray( int array[ 4 ][ 4 ] );
或只提供第二个大小：
int sumTwoDArray( int array[][ 4 ] );
但你不能两个大小都省略：
int sumTwoDArray( int array[][] );
也不能只给出第一个大小：
int sumTwoDArray( int array[ 4 ][] );
这是为什么呢？因为只有某些大小已知，指针运算才能正确地进行。
二维数组实际上是按先后顺序依次以条状存储在内存中的，编译器允许程序员把它当成一个正方形的内存块，
但它其实只是地址的线性集合。编译器通过将数组访问（比如array[3][2]）转换成内存中的位置，来实现这一效果。
有一个理解它的简单方法。如果你想象中的一个4X4的数组是这样子的：
但实际上，该数组在内存中是这样分布的：
为了使用array[3][2]（位于最后一组），编译器需要向下访问内存的 三行（经过第一组、第二组和第三组这三行）和两列。
由于要经过三行，而每行的宽度是4个整数，因此我们得走4×3个整数槽位，再加上两个整数槽位（为了到达最后一行中的第三个元素）。
换句话说，array[3][2]转换成了以下的指针运算：
*(array + 3 * <width of array> + 2)
现在可以看到，我们需要数组的宽度，没有它就不能完成计算。二维数组的第二维就是其宽度。
数据放在内存中的物理方式，决定了仅有高度是不能计算出这个结果的
（如果数组以另外一个方向来存放，这时候需要的可能就是高度了）。
因此，当你把数组作为参数传递给函数时，数组的高度可有可无，但数组的第二维必须要明确指定。
事实上任何的多维数组，都必须指定除高度之外的所有维度的大小。
一维数组可以看做是数组的特例，即一个只有高度的数组。
问题又来了，由于声明二维数组需要宽度必须确定，动态分配一个具有任意宽度的二维数组就需要C++的一个特性――指向指针的指针。
14.4.2 指向指针的指针
除指向普通数据外，指针也可以指向其他指针。毕竟，指针就像其他任何变量一样，有一个可以访问的地址。
声明一个指向指针的指针，要这样写：
int **p_p_x;
p_p_x指向一个指针的内存地址，而这个指针又指向了一个整数。我使用前缀p_p标示指针本身指向另一个指针。
这意味着，你需要给它提供一个指针的内存地址。比如：
int *p_y;
int **p_p_x;
p_p_x = & p_y;
然后可以通过使用p_p_x将一个指针赋值给p_y：
*p_p_x = new int;
如同使用指针来创建一个任意大小的一维数组，我们可以以同样的方法，使用指向指针的指针来创建一个任意大小的二维数组。
可以这样思考，你有一个一维数组的指针，这些指针每一个都指向第二个一维数组。来看看示意图，
假设我们声明了一个指向指针的指针来存储一个井字棋棋盘：
第一个指针，指向指针的集合，其中每个指针指向井字板的一行。以下是分配出这种数据结构的代码：
int **p_p_tictactoe;   
// 注意，这里是int*, 因为我们要分配一个指针数组
p_p_tictactoe = new int * [ 3 ];  
 
// 现在，让每个指针都存储整数数组的地址
for ( int i = 0; i < 3; i++ )
{
    p_p_tictactoe[ i ] = new int[ 3 ];
}
这时可以像使用二维数组一样地使用分配的内存了。例如，我们可以用两个for循环来初始化整个井字板：
for ( int i = 0; i < 3; i++ )
{
    for ( int j = 0; j < 3; j++ )
    {
        p_p_tictactoe[ i ][ j ] = 0;
    }
}
要释放其内存，我们要按照同初始化完全相反的顺序来实行――首先释放每一行的指针，然后释放掉指向这些行的指针：
for ( int i = 0; i < 3; i++ )
{
    delete [] p_p_tictactoe[ i ];
}

delete [] p_p_tictactoe;
通常不会在已知内存大小时（比如创建井字板的情况）使用这种方法，下面这种写法要简单一些：
int tic_tac_toe_board[3][3];
但如果你想创建一个任意大的游戏板，应该用第一种写法。
14.4.3 指向指针的指针与二维数组
请注意，使用指向指针的指针来存放二维数组时，这种二维数据在内存中的存放方式与普通的二维数组并不相同。
一个标准的二维数组都是连续的内存，但基于指针的方法却不是。
示意图中显示每一行都是一个单独的数据块。事实上，每一行在内存中的存储位置，可能会彼此完全远离。
将数组作为参数传递给函数，有一些需要注意的地方。你已经知道可以将一个数组赋值给指针：
int x[ 8 ];
int *y = x;
但是，不能将一个二维数组赋值给指向指针的指针：
错误代码
int x[8][8];
int **y = x; // 无法编译!
在第一种情况中，数组可以看做一个指针，它指向一块包含了所有数据的内存块。
在第二种情况，数组仍然只是一个指向了一块内存块的指针。
这就是指向指针的指针与二维数组在内存中存放方式的不一样所导致的一个严重后果：
不能将指向指针的指针传递给函数中的多维数组 （尽管我们可以传递一个指针给函数中的一维数组）。
int sum_matrix (int values[][ 4 ], int num_rows)
{
    int running_total = 0;
    for ( int i = 0; i < num_rows; i++ )
    {
        for ( int j = 0; j < 4; j++ )
        {
            running_total += values[ i ][ j ];
        }
    }
    return running_total;
}
如下，将一个指向指针的指针传递给sum_matrix函数，编译器会报错：
错误代码
int **x;
// 分配一个指向指针的指针x, 10行
sum_matrix( x, 10 );   // 无法编译
一维情况下，程序只是到指针地址的一个特定的偏移位置来取值进行操作。
但在二维情况下，指向指针的指针这种方法需要用到两个指针引用：
一个指针找到正确的行，另一个指针取出行中正确的值。
而对 于二维数组，只是使用指针的偏移运算来获得正确的值；
由于一个指向指针的指针不能做这种运算，因此编译器不允许将指向指针的指针传递给二维数组，尽管你写的代码看起来是一样的！
14.5 盘点指针
学习指针一开始可能会让人觉得非常困惑，但你有能力理解它们。
如果你还没有吃透指针的一切内容，那就多做几次深呼吸，然后重读本章，做完所有的测验，并努力解决实践题。
不必做到完全掌握所有情况下如何使用指针的每一个细微差别，但你应该知道初始化和使用指针的语法，并懂得如何分配内存。
问答题
1.下列哪一项是C++中分配内存的正确关键字？
A. new
B. malloc
C. create
D. value

A
2.下列哪一项是C++中释放内存的正确关键字？
好吧，如果这两题你回答的是malloc和free，也算对，这两个是从C延续过来的函数――但你可能没有阅读本章！
A. free
B. delete
C. clear
D. remove

B
3.以下说法哪一项是正确的？
A. 数组与指针是一样的
B. 数组不能够被赋值给指针
C. 指针可以被当做数组，但两者是不一样的
D. 可以像数组一样地使用指针，但不能将数组分配给指针

C
4.下面的代码中，x、p_int和p_p_int最终的值是多少？
（注意，由于整数和指针是不同的类型，编译器不会直接接受此代码，
但此练习是有用的，通过纸上的代码同样有助于理解多维指针。）
int x = 0;
int *p_int = & x;
int **p_p_int = & p_int;
*p_int = 12;
**p_p_int = 25;
p_int = 12;
*p_p_int = 3;
p_p_int = 27;

A. x = 0, p_p_int = 27, p_int = 12
B. x = 25, p_p_int = 27, p_int = 12
C. x = 25, p_p_int = 27, p_int = 3
D. x = 3, p_p_int = 27, p_int = 12

C
5.你怎样能表明一个指针没有指向有效的值？
A. 将指针置为负数
B. 将指针置为nullptr
C. 释放与指针相关联的内存
D. 将指针置为false

B
实践题
1.写一个函数，创建一个二维乘法表，它的两个维度的大小不固定。

#include <iostream>
#include <string>

using namespace std;

void printBoard(int tableSize, int **table, int maxEntrySize);
string numberWithPadding(int number, int maxSize);
int numberOfPaddingItems(int number, int maxSize);

int main()
{
    int tableSize = 10;

    cout << "Please specify the size of the multiplication table (Default is 10x10): ";
    cin >> tableSize;

    int **p_p_table;
    p_p_table = new int * [tableSize];

    for (int i = 0; i < tableSize; i++)
    {
        p_p_table[i] = new int[tableSize];
    }

    for (int i = 0; i < tableSize; i++)
    {
        for (int j = 0; j < tableSize; j++)
        {
            p_p_table[i][j] = i * j;
        }
    }
    int maxEntrySize = (tableSize - 1) * (tableSize - 1);
    printBoard(tableSize, p_p_table, maxEntrySize);

    for (int i = 0; i < tableSize; i++)
    {
        delete [] p_p_table[i];
    }
    delete [] p_p_table;
}

string numberWithPadding(int number, int maxSize)
{
    string numberAsString = to_string(number);
    string zeros;
    int paddingCount = numberOfPaddingItems(number, maxSize);
    if (paddingCount > 0)
    {
        for (int i = 0; i < paddingCount; i++)
        {
            zeros += '0';
        }
        numberAsString = zeros + numberAsString;
    }
    return numberAsString;
}

int numberOfPaddingItems(int number, int maxSize)
{
    string numberAsString = to_string(number);
    string maxSizeAsString = to_string(maxSize);

    return (maxSizeAsString.length() - numberAsString.length());
}

void printBoard(int tableSize, int **p_p_table, int maxEntrySize)
{
    string horizontalBar = " _";
    for (int i = 0; i < tableSize; i++)
    {
        horizontalBar += "__";
        int paddingCount = numberOfPaddingItems(1, maxEntrySize);
        if (paddingCount > 0)
        {
            for (int j = 0; j < paddingCount; j++)
            {
                horizontalBar += "_";
            }
        }
    }

    for (int i = 0; i <= tableSize; i++)
    {
        if (i == 0)
        {
            for (int j = 0; j <= tableSize; j++)
            {
                if (j == 0)
                {
                    cout << " ";
                }
                else
                {
                    cout << " " << numberWithPadding(j - 1, maxEntrySize);
                }
            }
            cout << "\n";
        }
        else
        {
            cout << horizontalBar << "\n";
            for (int j = 0; j <= tableSize; j++)
            {
                if (j == 0)
                {
                    cout << i - 1;
                }
                else
                {
                    string value = numberWithPadding(p_p_table[i - 1][j - 1], maxEntrySize);
                    cout << "|" << value;
                }
            }
            cout << "|\n";
        }
    }
    cout << horizontalBar << "\n\n";
}
显示结果如下
Please specify the size of the multiplication table (Default is 10x10): 10
  00 01 02 03 04 05 06 07 08 09
 _______________________________
0|00|00|00|00|00|00|00|00|00|00|
 _______________________________
1|00|01|02|03|04|05|06|07|08|09|
 _______________________________
2|00|02|04|06|08|10|12|14|16|18|
 _______________________________
3|00|03|06|09|12|15|18|21|24|27|
 _______________________________
4|00|04|08|12|16|20|24|28|32|36|
 _______________________________
5|00|05|10|15|20|25|30|35|40|45|
 _______________________________
6|00|06|12|18|24|30|36|42|48|54|
 _______________________________
7|00|07|14|21|28|35|42|49|56|63|
 _______________________________
8|00|08|16|24|32|40|48|56|64|72|
 _______________________________
9|00|09|18|27|36|45|54|63|72|81|
 _______________________________

2.写一个函数，它接受三个参数，分别是length、width和height，
用这三个值动态地分配一个三维数组，并用乘法表填充此三维数组。确保必要时释放内存。

#include <iostream>
#include <string>

using namespace std;

void printTable(int tableWidth, int tableLength, int tableRow, int ***table, int maxEntrySize);
string numberWithPadding(int number, int maxSize);
int numberOfPaddingItems(int number, int maxSize);
int **initializeTable2D(int tableWidth, int tableLength);
void disposeTable2D(int **p_p_table2D, int tableWidth);

int main()
{
    int tableLength = 10;
    int tableWidth = 10;
    int tableHeight = 10;

    cout << "Please specify the size of the multiplication table (Default is 10x10x10): \n";
    cout << "Table length:";
    cin >> tableLength;

    cout << "Table width:";
    cin >> tableWidth;

    cout << "Table height:";
    cin >> tableHeight;


    int ***p_p_table3D;
    p_p_table3D = new int **[tableHeight];

    for (int i = 0; i < tableHeight; i++)
    {
        p_p_table3D[i] = initializeTable2D(tableWidth, tableLength);
    }


    for (int i = 0; i < tableHeight; i++)
    {
        for (int j = 0; j < tableWidth; j++)
        {
            for (int k = 0; k < tableLength; k++)
            {
                p_p_table3D[i][j][k] = i * j * k;
            }
        }
    }
    int maxEntrySize = (tableWidth - 1) * (tableLength - 1) * (tableHeight - 1);

    int displayPlane = 1;
    while (displayPlane != 0)
    {
        cout << "Please specify which 2D table plane to print from the 3D table of " << tableHeight << " layers (0 to quit): \n";
        cout << "Current layer is: " << displayPlane << '\n';
        cin >> displayPlane;
        if (displayPlane == 0)
        {
            continue;
        }
        if (displayPlane < 0 || tableHeight < displayPlane)
        {
            cout << "You have selected a plane index that is out of bounds. Please try again.\n";
            continue;
        }
        printTable(tableWidth, tableLength, displayPlane, p_p_table3D, maxEntrySize);
    }

    for (int i = 0; i < tableHeight; i++)
    {
        disposeTable2D(p_p_table3D[i], tableWidth);
    }
    delete[] p_p_table3D;
}

int **initializeTable2D(int tableWidth, int tableLength)
{
    int **p_p_table2D = new int *[tableWidth];
    for (int j = 0; j < tableWidth; j++)
    {
        p_p_table2D[j] = new int[tableLength];
    }
    return p_p_table2D;
}

void disposeTable2D(int **p_p_table2D, int tableWidth)
{
    for (int j = 0; j < tableWidth; j++)
    {
        delete[] p_p_table2D[j];
    }

    delete[] p_p_table2D;
}

string numberWithPadding(int number, int maxSize)
{
    string numberAsString = to_string(number);
    string zeros;
    int paddingCount = numberOfPaddingItems(number, maxSize);
    if (paddingCount > 0)
    {
        for (int i = 0; i < paddingCount; i++)
        {
            zeros += '0';
        }
        numberAsString = zeros + numberAsString;
    }
    return numberAsString;
}

int numberOfPaddingItems(int number, int maxSize)
{
    string numberAsString = to_string(number);
    string maxSizeAsString = to_string(maxSize);

    return (maxSizeAsString.length() - numberAsString.length());
}

void printTable(int tableWidth, int tableLength, int tableRow, int ***p_p_table, int maxEntrySize)
{
    string horizontalBar = " _";
    for (int i = 0; i < tableWidth; i++)
    {
        horizontalBar += "__";
        int paddingCount = numberOfPaddingItems(1, maxEntrySize);
        if (paddingCount > 0)
        {
            for (int j = 0; j < paddingCount; j++)
            {
                horizontalBar += "_";
            }
        }
    }

    for (int i = 0; i <= tableWidth; i++)
    {
        if (i == 0)
        {
            for (int j = 0; j <= tableLength; j++)
            {
                if (j == 0)
                {
                    cout << " ";
                }
                else
                {
                    cout << " " << numberWithPadding(j - 1, maxEntrySize);
                }
            }
            cout << "\n";
        }
        else
        {
            cout << horizontalBar << "\n";
            for (int j = 0; j <= tableLength; j++)
            {
                if (j == 0)
                {
                    cout << i - 1;
                }
                else
                {
                    string value = numberWithPadding(p_p_table[tableRow - 1][i - 1][j - 1], maxEntrySize);
                    cout << "|" << value;
                }
            }
            cout << "|\n";
        }
    }
    cout << horizontalBar << "\n\n";
}
显示结果如下
Please specify the size of the multiplication table (Default is 10x10x10):
Table length:10
Table width:10
Table height:10
Please specify which 2D table plane to print from the 3D table of 10 layers (0 to quit):
Current layer is: 1
2
  000 001 002 003 004 005 006 007 008 009
 _________________________________________
0|000|000|000|000|000|000|000|000|000|000|
 _________________________________________
1|000|001|002|003|004|005|006|007|008|009|
 _________________________________________
2|000|002|004|006|008|010|012|014|016|018|
 _________________________________________
3|000|003|006|009|012|015|018|021|024|027|
 _________________________________________
4|000|004|008|012|016|020|024|028|032|036|
 _________________________________________
5|000|005|010|015|020|025|030|035|040|045|
 _________________________________________
6|000|006|012|018|024|030|036|042|048|054|
 _________________________________________
7|000|007|014|021|028|035|042|049|056|063|
 _________________________________________
8|000|008|016|024|032|040|048|056|064|072|
 _________________________________________
9|000|009|018|027|036|045|054|063|072|081|
 _________________________________________

Please specify which 2D table plane to print from the 3D table of 10 layers (0 to quit):
Current layer is: 2
1
  000 001 002 003 004 005 006 007 008 009
 _________________________________________
0|000|000|000|000|000|000|000|000|000|000|
 _________________________________________
1|000|000|000|000|000|000|000|000|000|000|
 _________________________________________
2|000|000|000|000|000|000|000|000|000|000|
 _________________________________________
3|000|000|000|000|000|000|000|000|000|000|
 _________________________________________
4|000|000|000|000|000|000|000|000|000|000|
 _________________________________________
5|000|000|000|000|000|000|000|000|000|000|
 _________________________________________
6|000|000|000|000|000|000|000|000|000|000|
 _________________________________________
7|000|000|000|000|000|000|000|000|000|000|
 _________________________________________
8|000|000|000|000|000|000|000|000|000|000|
 _________________________________________
9|000|000|000|000|000|000|000|000|000|000|
 _________________________________________

Please specify which 2D table plane to print from the 3D table of 10 layers (0 to quit):
Current layer is: 1
3
  000 001 002 003 004 005 006 007 008 009
 _________________________________________
0|000|000|000|000|000|000|000|000|000|000|
 _________________________________________
1|000|002|004|006|008|010|012|014|016|018|
 _________________________________________
2|000|004|008|012|016|020|024|028|032|036|
 _________________________________________
3|000|006|012|018|024|030|036|042|048|054|
 _________________________________________
4|000|008|016|024|032|040|048|056|064|072|
 _________________________________________
5|000|010|020|030|040|050|060|070|080|090|
 _________________________________________
6|000|012|024|036|048|060|072|084|096|108|
 _________________________________________
7|000|014|028|042|056|070|084|098|112|126|
 _________________________________________
8|000|016|032|048|064|080|096|112|128|144|
 _________________________________________
9|000|018|036|054|072|090|108|126|144|162|
 _________________________________________

Please specify which 2D table plane to print from the 3D table of 10 layers (0 to quit):
Current layer is: 3
0

3.写一个程序，输出二维数组中每一个元素的内存地址。验证输出值是否与本书解释的存储方式一致。

#include <iostream>
#include <string>

using namespace std;

void printBoard(int tableSize, int **table, int maxEntrySize);
string numberWithPadding(long number, long maxSize);
int numberOfPaddingItems(long number, long maxSize);

int main()
{
    int tableSize = 8;

    cout << "Please specify the size of the multiplication table (Default is 8x8): ";
    cin >> tableSize;

    int **p_p_table;
    p_p_table = new int *[tableSize];

    for (int i = 0; i < tableSize; i++)
    {
        p_p_table[i] = new int[tableSize];
    }

    for (int i = 0; i < tableSize; i++)
    {
        for (int j = 0; j < tableSize; j++)
        {
            p_p_table[i][j] = i * j;
        }
    }
    int maxEntrySize = (tableSize - 1) * (tableSize - 1);
    printBoard(tableSize, p_p_table, maxEntrySize);

    for (int i = 0; i < tableSize; i++)
    {
        delete[] p_p_table[i];
    }
    delete[] p_p_table;
}

string numberWithPadding(long number, long maxSize)
{
    string numberAsString = to_string(number);
    string zeros;
    int paddingCount = numberOfPaddingItems(number, maxSize);
    if (paddingCount > 0)
    {
        for (int i = 0; i < paddingCount; i++)
        {
            zeros += '0';
        }
        numberAsString = zeros + numberAsString;
    }
    return numberAsString;
}

int numberOfPaddingItems(long number, long maxSize)
{
    string numberAsString = to_string(number);
    string maxSizeAsString = to_string(maxSize);

    return (maxSizeAsString.length() - numberAsString.length());
}

void printBoard(int tableSize, int **p_p_table, int maxEntrySize)
{
    string horizontalBar = " _";
    for (int i = 0; i < tableSize; i++)
    {
        horizontalBar += "__";
        int paddingCount = numberOfPaddingItems(1, 88888888888888);
        if (paddingCount > 0)
        {
            for (int j = 0; j < paddingCount; j++)
            {
                horizontalBar += "_";
            }
        }
    }

    for (int i = 0; i <= tableSize; i++)
    {
        if (i == 0)
        {
            for (int j = 0; j <= tableSize; j++)
            {
                if (j == 0)
                {
                    cout << " ";
                }
                else
                {
                    cout << " " << numberWithPadding(j - 1, 88888888888888);
                }
            }
            cout << "\n";
        }
        else
        {
            cout << horizontalBar << "\n";
            for (int j = 0; j <= tableSize; j++)
            {
                if (j == 0)
                {
                    cout << i - 1;
                }
                else
                {
                    cout << "|" << & ( p_p_table[i - 1][j - 1] );
                }
            }
            cout << "|\n";
        }
    }
    cout << horizontalBar << "\n\n";
}
显示结果如下
Please specify the size of the multiplication table (Default is 8x8): 8
  00000000000000 00000000000001 00000000000002 00000000000003 00000000000004 00000000000005 00000000000006 00000000000007
 _________________________________________________________________________________________________________________________
0|0x560b40c2f720|0x560b40c2f724|0x560b40c2f728|0x560b40c2f72c|0x560b40c2f730|0x560b40c2f734|0x560b40c2f738|0x560b40c2f73c|
 _________________________________________________________________________________________________________________________
1|0x560b40c2f750|0x560b40c2f754|0x560b40c2f758|0x560b40c2f75c|0x560b40c2f760|0x560b40c2f764|0x560b40c2f768|0x560b40c2f76c|
 _________________________________________________________________________________________________________________________
2|0x560b40c2f780|0x560b40c2f784|0x560b40c2f788|0x560b40c2f78c|0x560b40c2f790|0x560b40c2f794|0x560b40c2f798|0x560b40c2f79c|
 _________________________________________________________________________________________________________________________
3|0x560b40c2f7b0|0x560b40c2f7b4|0x560b40c2f7b8|0x560b40c2f7bc|0x560b40c2f7c0|0x560b40c2f7c4|0x560b40c2f7c8|0x560b40c2f7cc|
 _________________________________________________________________________________________________________________________
4|0x560b40c2f7e0|0x560b40c2f7e4|0x560b40c2f7e8|0x560b40c2f7ec|0x560b40c2f7f0|0x560b40c2f7f4|0x560b40c2f7f8|0x560b40c2f7fc|
 _________________________________________________________________________________________________________________________
5|0x560b40c2f810|0x560b40c2f814|0x560b40c2f818|0x560b40c2f81c|0x560b40c2f820|0x560b40c2f824|0x560b40c2f828|0x560b40c2f82c|
 _________________________________________________________________________________________________________________________
6|0x560b40c2f840|0x560b40c2f844|0x560b40c2f848|0x560b40c2f84c|0x560b40c2f850|0x560b40c2f854|0x560b40c2f858|0x560b40c2f85c|
 _________________________________________________________________________________________________________________________
7|0x560b40c2f870|0x560b40c2f874|0x560b40c2f878|0x560b40c2f87c|0x560b40c2f880|0x560b40c2f884|0x560b40c2f888|0x560b40c2f88c|
 _________________________________________________________________________________________________________________________

4.写一个程序，让用户跟踪他们最近一次跟每个朋友交谈的时间。
用户应该能够添加新朋友（数量没有限制）并保存最近一次跟朋友交谈距今的天数。
天数由用户更新（但是不能输入无效的数值，比如负数）。确保列表可以按照名称和时间排序进行显示。

#include <iostream>
#include <string>

using namespace std;

int arrayMaxLength = 8;

struct Talk
{
    string name;
    string daysSinceLastSpoken;
};

void updateArray(Talk *p_array, int size, string name, int daySinceLastSpoken);
Talk *addToArray(Talk *p_array, int *size, string name, int daySinceLastSpoken);
void disposeArray(Talk *p_array);
Talk *arraySortedByName(Talk *p_array, int size);
Talk *arraySortedByDate(Talk *p_array, int size);
bool nameExistsInArray(Talk *p_array, int size, string name);
string getName();
int getDaysSinceLastSpoken();
int getDaysSinceLastSpoken(int lastDaysSinceLastSpoken);
int lookUpDaysSinceLastSpoken(Talk *p_array, int size, string name);

string getNameToUpdate(Talk *p_array, int size);
void printFriends(Talk *p_array, int size);
void printFriendsByName(Talk *p_array, int size);
void printFriendsByDate(Talk *p_array, int size);

int findSmallestElementByName(Talk *p_array, int size, int index);
int findSmallestElementByDate(Talk *p_array, int size, int index);
void swap(Talk *p_array, int firstIndex, int secondIndex);
void sortByName(Talk *p_array, int size);
void sortByDate(Talk *p_array, int size);

int main()
{
    int arrayLength = 0;
    Talk *p_array = new Talk[ arrayMaxLength ];

    int option = 0;
    string name;
    int daysSinceLastSpoken;
    do
    {
        cout << "Please select an option:\n";
        cout << "(1) Add new friend\n";
        if(arrayLength > 0)
        {
            cout << "(2) Update friend\n";
            cout << "(3) List friends by name\n";
            cout << "(4) List friends by most recently spoken with\n";
        }
        cout << "(0) Exit\n";
        cin >> option;
        cin.clear();
        cin.ignore(80, '\n');

        cout << '\n';
        switch (option)
        {
        case 1:
            name = getName();
            daysSinceLastSpoken = getDaysSinceLastSpoken();
            p_array = addToArray(p_array, &arrayLength, name, daysSinceLastSpoken);
            cout << '\n';
            break;
        case 2:
            name = getNameToUpdate(p_array, arrayLength);
            daysSinceLastSpoken = lookUpDaysSinceLastSpoken(p_array, arrayLength, name);
            daysSinceLastSpoken = getDaysSinceLastSpoken(daysSinceLastSpoken);
            updateArray(p_array, arrayLength, name, daysSinceLastSpoken);
            cout << '\n';
            break;
        case 3:
            printFriendsByName(p_array, arrayLength);
            cout << '\n';
            break;
        case 4:
            printFriendsByDate(p_array, arrayLength);
            cout << '\n';
            break;
        case 0:
            break;
        default:
            break;
        }
    }
    while (option != 0);

    disposeArray(p_array);
}
string getName()
{
    string name;
    cout << "Friend name: ";
    getline(cin, name, '\n');
    cout << '\n';
    return name;
}
int getDaysSinceLastSpoken()
{
    int daysSinceLastSpokenInput = 0;
    do
    {
        cout << "Number of days ago you last spoke with them: ";
        cin >> daysSinceLastSpokenInput;
        cin.clear();
        cin.ignore(80, '\n');

        if (daysSinceLastSpokenInput < 0)
        {
            cout << "Please enter a value >= 0\n";
        }
    }
    while (daysSinceLastSpokenInput < 0);
    cout << '\n';
    return daysSinceLastSpokenInput;
}
int getDaysSinceLastSpoken(int lastDaysSinceLastSpoken)
{
    int daysSinceLastSpokenInput = 0;
    do
    {
        cout << "Number of days ago you last spoke with them: ";
        cin >> daysSinceLastSpokenInput;
        cin.clear();
        cin.ignore(80, '\n');

        if (daysSinceLastSpokenInput < 0)
        {
            cout << "Please enter a value >= 0\n\n";
        }
        if (daysSinceLastSpokenInput > lastDaysSinceLastSpoken)
        {
            cout << "You last spoke with your friend " << lastDaysSinceLastSpoken << " days ago.\n";
            cout << "You must enter a number less than or equal to this.\n\n";
        }
    }
    while ((daysSinceLastSpokenInput < 0) || (daysSinceLastSpokenInput > lastDaysSinceLastSpoken));
    cout << '\n';
    return daysSinceLastSpokenInput;
}
int lookUpDaysSinceLastSpoken(Talk *p_array, int size, string name)
{
    for (int i = 0; i < size; i++)
    {
        if (p_array[i].name == name)
        {
            return stoi( p_array[i].daysSinceLastSpoken );
        }
    }
    return -1;
}
string getNameToUpdate(Talk *p_array, int size)
{
    string name;
    do
    {
        printFriendsByName(p_array, size);
        cout << '\n';
        cout << "Please enter an existing name to update: ";
        getline(cin, name, '\n');
        cout << '\n';
    }
    while (!nameExistsInArray(p_array, size, name));
    return name;
}
bool nameExistsInArray(Talk *p_array, int size, string name)
{
    for (int i = 0; i < size; i++)
    {
        if (p_array[i].name == name)
        {
            return true;
        }
    }
    return false;
}
void updateArray(Talk *p_array, int size, string name, int daySinceLastSpoken)
{
    for (int i = 0; i < size; i++)
    {
        if (p_array[i].name == name)
        {
            p_array[i].daysSinceLastSpoken = to_string(daySinceLastSpoken);
            return;
        }
    }
}
Talk *addToArray(Talk *p_array, int *size, string name, int daySinceLastSpoken)
{
    if (*size >= arrayMaxLength)
    {
        Talk *p_newvalues = new Talk[ arrayMaxLength * 2 ];
        for (int j = 0; j < arrayMaxLength; j++)
        {
            p_newvalues[j] = p_array[j];
        }
        p_newvalues[arrayMaxLength].name = name;
        p_newvalues[arrayMaxLength].daysSinceLastSpoken = to_string(daySinceLastSpoken);
        disposeArray(p_array);
        *size += 1;
        arrayMaxLength *= 2;
        return p_newvalues;
    }
    else
    {
        p_array[*size].name = name;
        p_array[*size].daysSinceLastSpoken = to_string(daySinceLastSpoken);
        *size += 1;
        return p_array;
    }
}
void disposeArray(Talk *p_array)
{
    delete[] p_array;
}
Talk *arraySortedByName(Talk *p_array, int size)
{
    Talk *p_newArray = new Talk[size];
    for (int i = 0; i < size; i++)
    {
        p_newArray[i] = p_array[i];
    }
    sortByName(p_newArray, size);

    return p_newArray;
}

Talk *arraySortedByDate(Talk *p_array, int size)
{
    Talk *p_newArray = new Talk[size];
    for (int i = 0; i < size; i++)
    {
        p_newArray[i] = p_array[i];
    }
    sortByDate(p_newArray, size);

    return p_newArray;
}
void printFriendsByName(Talk *p_array, int size)
{
    Talk *sortedArray = arraySortedByName(p_array, size);
    printFriends(sortedArray, size);
    disposeArray(sortedArray);
}
void printFriendsByDate(Talk *p_array, int size)
{
    Talk *sortedArray = arraySortedByDate(p_array, size);
    printFriends(sortedArray, size);
    disposeArray(sortedArray);
}
void printFriends(Talk *p_array, int size)
{
    for (int i = 0; i < size; i++)
    {
        cout << p_array[i].name << ": " << p_array[i].daysSinceLastSpoken << " days since last spoken\n";
    }
}
void sortByName(Talk *p_array, int size)
{
    for (int i = 0; i < size; i++)
    {
        int index = findSmallestElementByName(p_array, size, i);
        swap(p_array, i, index);
    }
}
void sortByDate(Talk *p_array, int size)
{
    for (int i = 0; i < size; i++)
    {
        int index = findSmallestElementByDate(p_array, size, i);
        swap(p_array, i, index);
    }
}
int findSmallestElementByName(Talk *p_array, int size, int index)
{
    int indexOfSmallestValue = index;
    for (int i = index + 1; i < size; i++)
    {
            if ( p_array[i].name < p_array[indexOfSmallestValue].name )
            {
                indexOfSmallestValue = i;
            }
    }
    return indexOfSmallestValue;
}
int findSmallestElementByDate(Talk *p_array, int size, int index)
{
    int indexOfSmallestValue = index;
    for (int i = index + 1; i < size; i++)
    {
            int arrayCurrent = stoi( p_array[i].daysSinceLastSpoken );
            int arraySmallest = stoi( p_array[indexOfSmallestValue].daysSinceLastSpoken );
            if (arrayCurrent < arraySmallest)
            {
                indexOfSmallestValue = i;
            }
    }
    return indexOfSmallestValue;
}
void swap(Talk *p_array, int firstIndex, int secondIndex)
{
    if (firstIndex == secondIndex)
    {
        return;
    }
    Talk temp = p_array[firstIndex];
    p_array[firstIndex] = p_array[secondIndex];
    p_array[secondIndex] = temp;
}
显示结果如下
Please select an option:
(1) Add new friend
(0) Exit
1

Friend name: Mark Thomas

Number of days ago you last spoke with them: 0


Please select an option:
(1) Add new friend
(2) Update friend
(3) List friends by name
(4) List friends by most recently spoken with
(0) Exit
1

Friend name: Hello Peter

Number of days ago you last spoke with them: 1


Please select an option:
(1) Add new friend
(2) Update friend
(3) List friends by name
(4) List friends by most recently spoken with
(0) Exit
1

Friend name: World Smith

Number of days ago you last spoke with them: 0


Please select an option:
(1) Add new friend
(2) Update friend
(3) List friends by name
(4) List friends by most recently spoken with
(0) Exit
3

Hello Peter: 1 days since last spoken
Mark Thomas: 0 days since last spoken
World Smith: 0 days since last spoken

Please select an option:
(1) Add new friend
(2) Update friend
(3) List friends by name
(4) List friends by most recently spoken with
(0) Exit
4

Mark Thomas: 0 days since last spoken
World Smith: 0 days since last spoken
Hello Peter: 1 days since last spoken

Please select an option:
(1) Add new friend
(2) Update friend
(3) List friends by name
(4) List friends by most recently spoken with
(0) Exit
2

Hello Peter: 1 days since last spoken
Mark Thomas: 0 days since last spoken
World Smith: 0 days since last spoken

Please enter an existing name to update: Hello Peter

Number of days ago you last spoke with them: 0


Please select an option:
(1) Add new friend
(2) Update friend
(3) List friends by name
(4) List friends by most recently spoken with
(0) Exit
3

Hello Peter: 0 days since last spoken
Mark Thomas: 0 days since last spoken
World Smith: 0 days since last spoken

Please select an option:
(1) Add new friend
(2) Update friend
(3) List friends by name
(4) List friends by most recently spoken with
(0) Exit
0

5.写一个双人玩的四子棋游戏。用户可以设置棋盘的长和宽，每个玩家轮流落子。
在棋盘中分别用+和x表示双方的棋子，用空格表示空位。

#include <iostream>
#include <string>

using namespace std;

enum ConnectFourSquare
{
    C4_Blank,
    C4_Plus,
    C4_X
};

struct BoardCoordinate
{
    int X;
    int Y;
};

ConnectFourSquare **createGameBoard(int boardWidth, int boardHeight);
void printBoard(ConnectFourSquare **gameBoard, int boardWidth, int boardHeight);
string setPlayer(bool playerXInSession);
string translateEnumToString(ConnectFourSquare squareState);
bool validIndex(BoardCoordinate boardPosition, int boardWidth, int boardHeight);
bool choiceTaken(BoardCoordinate boardPosition, ConnectFourSquare **gameBoard);
void setChoice(BoardCoordinate boardPosition, ConnectFourSquare **gameBoard, bool playerXInSession);
ConnectFourSquare choiceSquare(bool playerXInSession);
bool choiceWins(bool playerXInSession, ConnectFourSquare **gameBoard, int boardWidth, int boardHeight);
bool choiceWinsDiagonalDownRight(ConnectFourSquare choiceCheck, BoardCoordinate boardPosition, ConnectFourSquare **gameBoard, int boardWidth, int boardHeight);
bool choiceWinsDiagonalUpRight(ConnectFourSquare choiceCheck, BoardCoordinate boardPosition, ConnectFourSquare **gameBoard, int boardWidth, int boardHeight);
bool boardIsFull(ConnectFourSquare **gameBoard, int boardWidth, int boardHeight);

void disposeArray2D(ConnectFourSquare **p_p_array2D, int arrayWidth);

int const minToWin = 4;

int main()
{
    bool gameFinished = false;
    bool playerXInSession = true;
    string player = "";
    int row = 0;
    int column = 0;

    const int boardWidth = 7;
    const int boardHeight = 6;

    ConnectFourSquare **gameBoard = createGameBoard(boardWidth, boardHeight);

    do
    {
        row = 0;
        column = 0;
        player = setPlayer(playerXInSession);

        printBoard(gameBoard, boardWidth, boardHeight);

        cout << "Player " << player << ", choose your next board position to claim:\n";

        cout << "Row: \n";
        cin >> row;
        row--;

        cout << "Column: \n";
        cin >> column;
        column--;

        BoardCoordinate boardPosition;
        boardPosition.X = row;
        boardPosition.Y = column;

        if (!validIndex(boardPosition, boardWidth, boardHeight))
        {
            cout << "That is an invalid choice. Please try again.\n";
            continue;
        }

        if (choiceTaken(boardPosition, gameBoard))
        {
            cout << "That square is already taken. Please try again.\n";
            continue;
        }

        setChoice(boardPosition, gameBoard, playerXInSession);

        if (choiceWins(playerXInSession, gameBoard, boardWidth, boardHeight))
        {
            cout << "Player " << player << " wins!\n";
            gameFinished = true;
        }

        if (boardIsFull(gameBoard, boardWidth, boardHeight))
        {
            cout << "Board is full. The game is a tie!\n";
            gameFinished = true;
        }

        playerXInSession = !playerXInSession;
    }
    while (!gameFinished);

    disposeArray2D(gameBoard, boardWidth);
}

void disposeArray2D(ConnectFourSquare **p_p_array2D, int arrayWidth)
{
    for (size_t j = 0; j < arrayWidth; j++)
    {
        delete[] p_p_array2D[j];
    }

    delete[] p_p_array2D;
}

void printBoard(ConnectFourSquare **gameBoard, int boardWidth, int boardHeight)
{
    cout << "Connect Four\n";
    cout << minToWin << "-in-a-row are needed to win!\n";
    string horizontalBar = " _";

    for (int i = 0; i < boardHeight; i++)
    {
        horizontalBar += "__";
    }

    for (int i = 0; i <= boardWidth; i++)
    {
        if (i == 0)
        {
            for (int j = 0; j <= boardHeight; j++)
            {
                if (j == 0)
                {
                    cout << " ";
                }
                else
                {
                    cout << " " << j;
                }
            }
            cout << "\n";
        }
        else
        {
            cout << horizontalBar << "\n";
            for (int j = 0; j <= boardHeight; j++)
            {
                if (j == 0)
                {
                    cout << i;
                }
                else
                {
                    cout << "|" << translateEnumToString(gameBoard[i - 1][j - 1]);
                }
            }
            cout << "|\n";
        }
    }
    cout << horizontalBar << "\n\n";
}

ConnectFourSquare **createGameBoard(int boardWidth, int boardHeight)
{
    ConnectFourSquare **gameBoard = new ConnectFourSquare*[boardWidth];
    for (int i = 0; i < boardWidth; i++)
    {
        gameBoard[i] = new ConnectFourSquare[boardHeight];
    }

    for (int i = 0; i < boardWidth; i++)
    {
        for (int j = 0; j < boardHeight; j++)
        {
            gameBoard[i][j] = C4_Blank;
        }
    }
    return gameBoard;
}

string setPlayer(bool playerXInSession)
{
    if (playerXInSession)
    {
        return "X";
    }
    return "+";
}

bool validIndex(BoardCoordinate boardPosition, int boardWidth, int boardHeight)
{
    return ( ( (boardPosition.X >= 0) && (boardPosition.Y >= 0) ) &&
            ( (boardPosition.X < boardWidth) && (boardPosition.Y < boardHeight) ) );
}

bool choiceTaken(BoardCoordinate boardPosition, ConnectFourSquare **gameBoard)
{
    return (gameBoard[boardPosition.X][boardPosition.Y] != C4_Blank);
}

void setChoice(BoardCoordinate boardPosition, ConnectFourSquare **gameBoard, bool playerXInSession)
{
    gameBoard[boardPosition.X][boardPosition.Y] = choiceSquare(playerXInSession);
}

ConnectFourSquare choiceSquare(bool playerXInSession)
{
    if (playerXInSession)
    {
        return C4_X;
    }
    return C4_Plus;
}

bool choiceWins(bool playerXInSession, ConnectFourSquare **gameBoard, int boardWidth, int boardHeight)
{
    ConnectFourSquare choiceCheck = choiceSquare(playerXInSession);;
    double score;

    for (int i = 0; i < boardWidth; i++)
    {
        score = 0;
        for (int j = 0; j < boardHeight; j++)
        {
            if (gameBoard[i][j] == choiceCheck)
            {
                score++;
                if (score >= minToWin)
                {
                    return true;
                }
            }
            else
            {
                score = 0;
            }
        }
    }

    for (int j = 0; j < boardHeight; j++)
    {
        score = 0;
        for (int i = 0; i < boardWidth; i++)
        {
            if (gameBoard[i][j] == choiceCheck)
            {
                score++;
                if (score >= minToWin)
                {
                    return true;
                }
            }
            else
            {
                score = 0;
            }
        }
    }

    BoardCoordinate boardPositionsDownRight[6];
    boardPositionsDownRight[0].X = 0;
    boardPositionsDownRight[0].Y = 2;

    boardPositionsDownRight[1].X = 0;
    boardPositionsDownRight[1].Y = 1;

    boardPositionsDownRight[2].X = 0;
    boardPositionsDownRight[2].Y = 0;

    boardPositionsDownRight[3].X = 1;
    boardPositionsDownRight[3].Y = 0;

    boardPositionsDownRight[4].X = 2;
    boardPositionsDownRight[4].Y = 0;

    boardPositionsDownRight[5].X = 3;
    boardPositionsDownRight[5].Y = 0;

    for (int i = 0; i < 6; i++)
    {
        if (choiceWinsDiagonalDownRight(choiceCheck, boardPositionsDownRight[i], gameBoard, boardWidth, boardHeight))
        {
            return true;
        }
    }

    BoardCoordinate boardPositionsUpRight[6];
    boardPositionsUpRight[0].X = 0;
    boardPositionsUpRight[0].Y = 3;

    boardPositionsUpRight[1].X = 0;
    boardPositionsUpRight[1].Y = 4;

    boardPositionsUpRight[2].X = 0;
    boardPositionsUpRight[2].Y = 5;

    boardPositionsUpRight[3].X = 1;
    boardPositionsUpRight[3].Y = 5;

    boardPositionsUpRight[4].X = 2;
    boardPositionsUpRight[4].Y = 5;

    boardPositionsUpRight[5].X = 3;
    boardPositionsUpRight[5].Y = 5;

    for (int i = 0; i < 6; i++)
    {
        if (choiceWinsDiagonalUpRight(choiceCheck, boardPositionsUpRight[i], gameBoard, boardWidth, boardHeight))
        {
            return true;
        }
    }

    return false;
}

bool choiceWinsDiagonalDownRight(ConnectFourSquare choiceCheck, BoardCoordinate boardPosition, ConnectFourSquare **gameBoard, int boardWidth, int boardHeight)
{
    int score = 0;
    while (validIndex(boardPosition, boardWidth, boardHeight))
    {
        if (gameBoard[boardPosition.X][boardPosition.Y] == choiceCheck)
        {
            score++;
            if (score >= minToWin)
            {
                return true;
            }
        }
        else
        {
            score = 0;
        }
        boardPosition.X++;
        boardPosition.Y++;
    }
    return false;
}

bool choiceWinsDiagonalUpRight(ConnectFourSquare choiceCheck, BoardCoordinate boardPosition, ConnectFourSquare **gameBoard, int boardWidth, int boardHeight)
{
    int score = 0;
    while (validIndex(boardPosition, boardWidth, boardHeight))
    {
        if (gameBoard[boardPosition.X][boardPosition.Y] == choiceCheck)
        {
            score++;
            if (score >= minToWin)
            {
                return true;
            }
        }
        else
        {
            score = 0;
        }
        boardPosition.X++;
        boardPosition.Y--;
    }
    return false;
}



bool boardIsFull(ConnectFourSquare **gameBoard, int boardWidth, int boardHeight)
{
    for (int i = 0; i < boardWidth; i++)
    {
        for (int j = 0; j < boardHeight; j++)
        {
            if (gameBoard[i][j] == C4_Blank)
            {
                return false;
            }
        }
    }
    return true;
}

string translateEnumToString(ConnectFourSquare squareState)
{
    switch (squareState)
    {
    case C4_Blank:
        return " ";
    case C4_Plus:
        return "+";
    case C4_X:
        return "X";
    default:
        return "~";
    }
}
显示结果如下
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | | | |
 _____________
2| | | | | | |
 _____________
3| | | | | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________
7| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
1
Column:
1
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| | | | | |
 _____________
2| | | | | | |
 _____________
3| | | | | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________
7| | | | | | |
 _____________

Player +, choose your next board position to claim:
Row:
1
Column:
6
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| | | | |+|
 _____________
2| | | | | | |
 _____________
3| | | | | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________
7| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
2
Column:
1
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| | | | |+|
 _____________
2|X| | | | | |
 _____________
3| | | | | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________
7| | | | | | |
 _____________

Player +, choose your next board position to claim:
Row:
3
Column:
1
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| | | | |+|
 _____________
2|X| | | | | |
 _____________
3|+| | | | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________
7| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
3
Column:
2
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| | | | |+|
 _____________
2|X| | | | | |
 _____________
3|+|X| | | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________
7| | | | | | |
 _____________

Player +, choose your next board position to claim:
Row:
4
Column:
3
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| | | | |+|
 _____________
2|X| | | | | |
 _____________
3|+|X| | | | |
 _____________
4| | |+| | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________
7| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
4
Column:
2
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| | | | |+|
 _____________
2|X| | | | | |
 _____________
3|+|X| | | | |
 _____________
4| |X|+| | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________
7| | | | | | |
 _____________

Player +, choose your next board position to claim:
Row:
2
Column:
2
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| | | | |+|
 _____________
2|X|+| | | | |
 _____________
3|+|X| | | | |
 _____________
4| |X|+| | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________
7| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
5
Column:
2
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| | | | |+|
 _____________
2|X|+| | | | |
 _____________
3|+|X| | | | |
 _____________
4| |X|+| | | |
 _____________
5| |X| | | | |
 _____________
6| | | | | | |
 _____________
7| | | | | | |
 _____________

Player +, choose your next board position to claim:
Row:
6
Column:
2
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| | | | |+|
 _____________
2|X|+| | | | |
 _____________
3|+|X| | | | |
 _____________
4| |X|+| | | |
 _____________
5| |X| | | | |
 _____________
6| |+| | | | |
 _____________
7| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
1
Column:
2
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X| | | |+|
 _____________
2|X|+| | | | |
 _____________
3|+|X| | | | |
 _____________
4| |X|+| | | |
 _____________
5| |X| | | | |
 _____________
6| |+| | | | |
 _____________
7| | | | | | |
 _____________

Player +, choose your next board position to claim:
Row:
3
Column:
3
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X| | | |+|
 _____________
2|X|+| | | | |
 _____________
3|+|X|+| | | |
 _____________
4| |X|+| | | |
 _____________
5| |X| | | | |
 _____________
6| |+| | | | |
 _____________
7| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
1
Column:
3
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X|X| | |+|
 _____________
2|X|+| | | | |
 _____________
3|+|X|+| | | |
 _____________
4| |X|+| | | |
 _____________
5| |X| | | | |
 _____________
6| |+| | | | |
 _____________
7| | | | | | |
 _____________

Player +, choose your next board position to claim:
Row:
1
Column:
4
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X|X|+| |+|
 _____________
2|X|+| | | | |
 _____________
3|+|X|+| | | |
 _____________
4| |X|+| | | |
 _____________
5| |X| | | | |
 _____________
6| |+| | | | |
 _____________
7| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
2
Column:
3
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X|X|+| |+|
 _____________
2|X|+|X| | | |
 _____________
3|+|X|+| | | |
 _____________
4| |X|+| | | |
 _____________
5| |X| | | | |
 _____________
6| |+| | | | |
 _____________
7| | | | | | |
 _____________

Player +, choose your next board position to claim:
Row:
5
Column:
3
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X|X|+| |+|
 _____________
2|X|+|X| | | |
 _____________
3|+|X|+| | | |
 _____________
4| |X|+| | | |
 _____________
5| |X|+| | | |
 _____________
6| |+| | | | |
 _____________
7| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
6
Column:
3
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X|X|+| |+|
 _____________
2|X|+|X| | | |
 _____________
3|+|X|+| | | |
 _____________
4| |X|+| | | |
 _____________
5| |X|+| | | |
 _____________
6| |+|X| | | |
 _____________
7| | | | | | |
 _____________

Player +, choose your next board position to claim:
Row:
2
Column:
4
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X|X|+| |+|
 _____________
2|X|+|X|+| | |
 _____________
3|+|X|+| | | |
 _____________
4| |X|+| | | |
 _____________
5| |X|+| | | |
 _____________
6| |+|X| | | |
 _____________
7| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
3
Column:
4
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X|X|+| |+|
 _____________
2|X|+|X|+| | |
 _____________
3|+|X|+|X| | |
 _____________
4| |X|+| | | |
 _____________
5| |X|+| | | |
 _____________
6| |+|X| | | |
 _____________
7| | | | | | |
 _____________

Player +, choose your next board position to claim:
Row:
4
Column:
4
Connect Four
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X|X|+| |+|
 _____________
2|X|+|X|+| | |
 _____________
3|+|X|+|X| | |
 _____________
4| |X|+|+| | |
 _____________
5| |X|+| | | |
 _____________
6| |+|X| | | |
 _____________
7| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
4
Column:
5
Player X wins!

6.写一个程序，输入宽（width）和高（height），根据这两个值动态地产生一个迷宫。

#include <cstdlib>
#include <ctime>
#include <iostream>
#include <string>

using namespace std;

enum Direction
{
    North,
    South,
    East,
    West
};

struct Position
{
    int row;
    int column;
};

struct Cell
{
    enum Wall
    {
        Wall_North = 0x0008,
        Wall_South = 0x0002,
        Wall_East = 0x0004,
        Wall_West = 0x0001,
        Wall_All = 0x000f,
        Wall_None = 0x0000
    };

    struct Position position;
    int walls;

    int getWalls() const
    {
        return walls & Wall_All;
    }
    void setWalls(const int w)
    {
        walls = w & Wall_All;
    }
    void removeWall(const int w)
    {
        if (w != Wall_North && w != Wall_East && w != Wall_South && w != Wall_West)
        {
            return;
        }
        walls &= ~w;
    }


    string print() const
    {
        string cell = "";
        if ( ( getWalls() & Wall_West ) != 0 )
        {
            cell += 'W';
        }
        else
        {
            cell += " ";
        }

        if ( ( getWalls() & Wall_South ) != 0 )
        {
            cell += 'S';
        }
        else
        {
            cell += " ";
        }

        if ( ( getWalls() & Wall_North ) != 0 )
        {
            cell += 'N';
        }
        else
        {
            cell += " ";
        }

        if ( ( getWalls() & Wall_East ) != 0 )
        {
            cell += 'E';
        }
        else
        {
            cell += " ";
        }

        return cell;
    }
};

struct VectorCell
{
    Cell *array = nullptr;
    int size = 0;
    int maxSize = 0;

    bool isEmpty() const
    {
        return (size == 0);
    }

    void clear()
    {
        size = 0;
        maxSize = 0;
        if (array != nullptr)
        {
            delete[] array;
            array = nullptr;
        }
    }

    void pushBack(Cell *cell)
    {
        if (size == maxSize)
        {
            if (maxSize == 0)
            {
                Cell *p_newvalues = new Cell[8];
                p_newvalues[size] = *cell;
                if (array != nullptr)
                {
                    delete[] array;
                    array = nullptr;
                }
                array = p_newvalues;
                size++;
                maxSize = 8;
            }
            else
            {
                Cell *p_newvalues = new Cell[maxSize * 2];
                for (int i = 0; i < size; i++)
                {
                    p_newvalues[i] = array[i];
                }
                p_newvalues[size] = *cell;
                if (array != nullptr)
                {
                    delete[] array;
                    array = nullptr;
                }
                array = p_newvalues;
                size++;
                maxSize *= 2;
            }
        }
        else
        {
            array[size] = *cell;
            size++;
        }
    }

    void popBack()
    {
        if (size > 0)
        {
            size--;
            if (size == 0)
            {
                clear();
            }
        }
    }
};

struct VectorDirection
{
    Direction *array = nullptr;
    int size = 0;
    int maxSize = 0;

    bool isEmpty() const
    {
        return (size == 0);
    }

    void clear()
    {
        size = 0;
        maxSize = 0;
        if (array != nullptr)
        {
            delete[] array;
            array = nullptr;
        }
    }

    void pushBack(Direction direction)
    {
        if (size == maxSize)
        {
            if (maxSize == 0)
            {
                Direction *p_newvalues = new Direction[8];
                p_newvalues[size] = direction;
                if (array != nullptr)
                {
                    delete[] array;
                    array = nullptr;
                }
                array = p_newvalues;
                size++;
                maxSize = 8;
            }
            else
            {
                Direction *p_newvalues = new Direction[maxSize * 2];
                for (int i = 0; i < size; i++)
                {
                    p_newvalues[i] = array[i];
                }
                p_newvalues[size] = direction;
                if (array != nullptr)
                {
                    delete[] array;
                    array = nullptr;
                }
                array = p_newvalues;
                size++;
                maxSize *= 2;
            }
        }
        else
        {
            array[size] = direction;
            size++;
        }
    }

    void popBack()
    {
        if (size > 0)
        {
            size--;
            if (size == 0)
            {
                clear();
            }
        }
    }
};

int main()
{
    srand( time(nullptr) );

    int mazeWidth = 6;
    int mazeHeight = 6;

    do
    {
        mazeWidth = 6;
        mazeHeight = 6;
        cout << "Please specify the dimensions of the maze (at least 6x6):\n";
        cout << "Width: ";
        cin >> mazeWidth;
        cin.clear();
        cin.ignore(80, '\n');

        cout << "Height: ";
        cin >> mazeHeight;
        cin.clear();
        cin.ignore(80, '\n');

        cout << '\n';
    }
    while ( (mazeWidth < 6) || (mazeHeight < 6) );

    Cell **maze = new Cell*[mazeWidth];
    for (int i = 0; i < mazeWidth; i++)
    {
        maze[i] = new Cell[mazeHeight];
    }

    for (int row = 0; row < mazeWidth; row++)
    {
        for (int column = 0; column < mazeHeight; column++)
        {
            maze[row][column].position.row = row;
            maze[row][column].position.column = column;
            maze[row][column].setWalls(Cell::Wall_All);
        }
    }

    int currentRow = rand() % mazeWidth;
    int currentColumn = rand() % mazeHeight;

    VectorCell trail;
    trail.pushBack( & ( maze[currentRow][currentColumn] ) );

    VectorDirection currentDirections;

    while ( !trail.isEmpty() )
    {
        currentDirections.clear();
        if (currentColumn > 0)
        {
            if (maze[currentRow][currentColumn - 1].getWalls() == Cell::Wall_All)
            {
                currentDirections.pushBack(West);
            }
        }

        if (currentColumn < mazeHeight - 1)
        {
            if (maze[currentRow][currentColumn + 1].getWalls() == Cell::Wall_All)
            {
                currentDirections.pushBack(East);
            }
        }

        if (currentRow > 0)
        {
            if (maze[currentRow - 1][currentColumn].getWalls() == Cell::Wall_All)
            {
                currentDirections.pushBack(North);
            }
        }

        if (currentRow < mazeWidth - 1)
        {
            if (maze[currentRow + 1][currentColumn].getWalls() == Cell::Wall_All)
            {
                currentDirections.pushBack(South);
            }
        }

        if ( !currentDirections.isEmpty() )
        {
            int randomDirectionIndex = rand() % currentDirections.size;

            switch (currentDirections.array[randomDirectionIndex])
            {
            case North:
                maze[currentRow][currentColumn].removeWall(Cell::Wall_North);
                maze[currentRow-1][currentColumn].removeWall(Cell::Wall_South);
                --currentRow;
                break;
            case South:
                maze[currentRow][currentColumn].removeWall(Cell::Wall_South);
                maze[currentRow+1][currentColumn].removeWall(Cell::Wall_North);
                ++currentRow;
                break;
            case East:
                maze[currentRow][currentColumn].removeWall(Cell::Wall_East);
                maze[currentRow][currentColumn+1].removeWall(Cell::Wall_West);
                ++currentColumn;
                break;
            case West:
                maze[currentRow][currentColumn].removeWall(Cell::Wall_West);
                maze[currentRow][currentColumn-1].removeWall(Cell::Wall_East);
                --currentColumn;
                break;
            default:
                break;
            }

            trail.pushBack( & ( maze[currentRow][currentColumn] ) );
        }
        else
        {
            trail.popBack();

            if ( !trail.isEmpty() )
            {
                currentRow = trail.array[trail.size - 1].position.row;
                currentColumn = trail.array[trail.size - 1].position.column;
            }
        }
    }


    for (int row = 0; row < mazeWidth; row++)
    {
        for (int column = 0; column < mazeHeight; column++)
        {
            if (column != 0)
            {
                cout << ", ";
            }
            cout << maze[row][column].print();
        }
        cout << "\n";
    }
}
显示结果如下
Please specify the dimensions of the maze (at least 6x6):
Width: 6
Height: 6

WSN ,  SN ,   N ,  SN ,  SN ,   NE
W N ,   NE, WS  ,  SNE, W N ,  S E
W  E, W  E, W N ,   NE, WS  ,   NE
W  E, WS  ,  S E, W  E, W N ,    E
WS  ,  SN ,  SNE, WS  ,  S E, W  E
WSN ,  SN ,  SN ,  SN ,  SN ,  S E
对应画好的图
ch14_p06.png

第15章 数据结构简介与链表
上一章介绍了如何通过分配内存动态地创建数组，这一章讲解如何更灵活地使用动态内存分配。
拥有大量内存最大的好处是，你会有很多位置来存放数据，可以存储相当多的东西。
但接下来的问题是：要怎么做才能迅速进行存储，并便捷地访问到这些数据呢？本章就是要讨论这个问题。
首先介绍术语数据结构，它是指内存中组织数据的一种方式。
例如， 数组就是一个非常简单的数据结构，它以线性方式组织内存中的数据。
数组中的各个元素就是数据结构中的各个元素。使用指向指针的指针实现的二维数组是一个较为复杂的数据结构。
问题是，使用数组时，如果该数组没有空位，就不能添加数据到该数组中。
此时，你就必须从头开始，重新分配一个数组，然后将现有数组中的所有元素都复制到新数组中。
这就是计算机程序员所说的昂贵操作――以计算机处理器的标准，这会花费很长时间。
但从用户的角度看，这实在没什么大不了的：计算机处理器的速度已经相当快，
如果这种操作不是经常进行，没有人会注意到有什么问题。但有时候，“昂贵操作”会带来严重的麻烦。
关于数组的第二个问题是，你不能轻易地在现有的数组元素之间插入数据。
举个例子，如果想在第一个元素和第二个元素之间插入一个新元素，而数组有1000个元素，那么必须把元素2至元素1000各向后挪一位！
这个操作也很昂贵。
有时候会遇到这种情况――电脑嘎嚓嘎嚓地响，让你痛苦地等待，怎 么回事呢？
这就是因为你的电脑在做某些昂贵操作。数据结构正是为了减轻这些问题，而创造出来的一种高效的进行数据存储的方式。
使用不同的数据结构的第二个原因是，它可以使你站在更高的层次来思考编程问题。
与其总是讨论烦琐的“循环”，我们开始从更高的层面开始讨论“列表”。
数据结构提供了组织数据的一种逻辑方式，以及交流程序所用到的基本操作的一种简便说辞。
比如说你需要一个“列表”，就很清楚地表达了：需要将数据以一种能够高效地增加和删除的方式进行存储。
了解了更多数据结构后，你会逐渐学会从数据角度思考程序，学会思考如何组织数据。
好了，不谈那些理论的东西了，让我们先来谈谈链表吧。
还记得那个问题吗：怎样简便地增加一个数据元素？用一个必须复制一遍原数组的数组来实现，感觉如何？
试想一下，如果有这样一个数据结构：其中的每一 项数据都能告诉你去哪里找下一项数据，会不会很赞？
这样的话，我们就可以通过让最后一个元素指向新添加的元素，轻而易举地在原有的数据结构末尾添加了新元素。
如果要在两个元素间插入新元素，也很简单：仅仅通过改变这两个元素之一的指向即可。
回忆下以前使用过的例子，存储游戏中的敌舰数据。很容易想到将敌舰以某种形式的列表来存储，
该列表中的每一个元素是一个存储了敌舰信息的结构体。为什么要将敌舰数据构成一个列表呢？
你会想要的，如果需要在每一轮游戏中都对所有的敌舰采取行动。
比如你想遍历列表中的所有敌舰，让每个敌舰移动下位置，就需要这个列表。
这不是一个像购物清单或班级学生花名册一样的“列表”，有时你只是用列表形式存储下自己拥有的所有东西，
就好像上述例子里的敌舰一样。另外，你还可能会希望能够快速地添加、删除敌舰。
那么，如果让每个敌舰都具有下一部敌舰的信息，会怎样？
先看一下下面的示意图。可以直观地看到，每个敌舰元素都包含其在屏幕的x坐标、y坐标，以及一定的武器火力值：
我们用结构体EnemySpaceShip来存储每个敌舰元素，其中，每个结构体都具有一个到下一个结构体的链接。这个链接会是什么呢？
对的，指针！每艘敌舰都有一个指向下一艘敌舰的指针：
struct EnemySpaceShip
{
    int x_coordinate;
    int y_coordinate;
    int weapon_power;
    EnemySpaceShip *p_next_enemy;
};
等一下！结构体EnemySpaceShip的定义中又使用了结构体EnemySpaceShip，这真的可以吗？
是的，没问题！C++完全有能力处理这种自我引用。你如果在结构体里写成下面这样才会出问题：
EnemySpaceShip next_enemy;
这样就形成了一个无限重复自身的结构体。
声明这样的一艘敌舰将 耗光系统的所有内存。因此请注意，我们写的是一个指向EnemySpaceShip的指针，
而不是一个真实的EnemySpaceShip。由于指针不一定要指向有效内存，所以这样写不会产生一个敌舰的无限列表，
而只是产生了一艘敌舰，这艘敌舰“有可能”会指向另一艘敌舰。
如果它指向的另一艘敌舰是真实的，那么这另一艘敌舰当然会占用一些额外的内存，
但在这之前，该结构体只多占用了一点点内存来存放指针――只有几字节而已。
指针仅仅是表示它有可能指向一块有效内存，指针本身的存储只需要一小块内存空间而已。
当声明一个EnemySpaceShip时，你需要足够的空间来容纳x_coordinate、y_coordinate、weapon_power，以及最后的指针。
你不需要容纳另一艘敌舰，只要容纳一个指针就可以了。
打个比方吧。想象一列火车，火车上的每一节车厢都有一个钩子，可以用来勾住另一节车厢。
要添加一节新车厢，你只需要把新车厢和它前面及后面的车厢都连接上即可。
如果没有车厢要连接，钩子也可以不用，这个钩子就相当于一个空指针。
我们已经讲述了生成这些类型列表的相关概念，现在来学习使用指针与结构体的一些细节和语法。
15.1 指针和结构体
要通过指针访问结构体的域，可以在使用“.”运算符的位置使用“->”运算 符：
p_my_struct->my_field;
结构体的每个成员变量具有不同的内存地址，通常距离结构体的起始地址若干字节――箭头语法能用来计算出这个偏移量。
对箭头语法而言，指针的其他所有属性仍然适用（比如一个指针指向的是一块内存、不能使用无效指针，等等），
它完全等价于下列写法：
(*p_my_struct).my_field;
但是，箭头语法更便于阅读，熟练掌握的话，书写也很方便。
如果一个函数接受指向结构体的指针为参数，那么，它就能够修改与该结构体相关联的内存地址。
也就是说，我们允许函数修改传入进来的结构体，这实际上跟把数组传递到函数中的情况是类似的。
来看看在结构体EnemySpaceShip中是怎样处理的：
#include <iostream>
#include <string>

using namespace std;

struct EnemySpaceShip
{
    int x_coordinate;
    int y_coordinate;
    int weapon_power;
    EnemySpaceShip *p_next_enemy;
};

EnemySpaceShip *getNewEnemy ()
{
    EnemySpaceShip *p_ship = new EnemySpaceShip;
    p_ship->x_coordinate = 0;
    p_ship->y_coordinate = 0;
    p_ship->weapon_power = 20;
    p_ship->p_next_enemy = nullptr;
    return p_ship;
}
void upgradeWeapons (EnemySpaceShip *p_ship)
{
    p_ship->weapon_power += 10;
}
int main ()
{
    EnemySpaceShip *p_enemy = getNewEnemy();
    upgradeWeapons( p_enemy );
    cout<<p_enemy->x_coordinate <<", " << p_enemy->y_coordinate << ", " 
           <<p_enemy->weapon_power<<endl;
    delete p_enemy;
}
示例代码 38: upgrade.cpp
显示结果如下
0, 0, 30

在getNewEnemy中，我们使用new来为一艘新敌舰分配新内存。 
在upgradeWeapons中，由于p_ship指向了一块包含结构体的所有成员变量的内存空间，因此我们能够修改结构体p_ship。
15.2 创建一个链表
现在，我们已经掌握了结合使用指针和结构体的语法，可以创建自己的列表了。
任何时候，我们通过使用包含一个指针指向下一个元素的结构体所创建出来的列表，都称为链表（linked list）。
为了总能找到这个链表，我们需要以某种方式，来记住该链表的起始位置。回到刚才的例子，可以给敌舰链表增加一个指向其起始点的指针：
struct EnemySpaceShip
{
    int x_coordinate;
    int y_coordinate;
    int weapon_power;
    EnemySpaceShip *p_next_enemy;
};

EnemySpaceShip* p_enemies = nullptr;
p_enemies是一个指针变量，指向整个敌舰列表。每当我们在游戏中增加一艘敌舰，就将该敌舰添加到此列表中。
（这个p_enemies将是在游戏中对所有敌舰做某件事时的出发站点。）
这个变量也可以命名 为p_first或p_head，以表明它是列表的第一个元素。
每当在游戏中添加一艘新敌舰，我们都将它添加到列表的最前面：
EnemySpaceShip *getNewEnemy ()
{
    EnemySpaceShip *p_ship = new EnemySpaceShip;
    p_ship->x_coordinate = 0;
    p_ship->y_coordinate = 0;
    p_ship->weapon_power = 20;
    p_ship->p_next_enemy = p_enemies;
    p_enemies = p_ship;
    return p_ship;
}
开始时，p_enemies为nullptr。
每当创建一艘新敌舰，我们都要使其指向链表的第一个元素（存储在p_enemies中），接着使p_enemies指向新建立的敌舰。
这相当于使列表中的其余元素向 后“滑动”一位，让新元素添加到了列表的前面。
这里的“滑动”并不需要任何的复制操作，我们只是修改了两个指针。
这可能有点令人不解。所以我们通过一系列步骤以及示意图来加深理解。
15.2.1 第一轮
在初始状态下，p_enemies一开始为nullptr。换句话说，此时没有敌舰 （我们总是用nullptr来表示列表的末尾）。
1.分配一艘新敌舰，用指针p_ship指向它。现在有了一个新的敌舰， 我称为SHIP1，它现在还未存储在列表中。
在图中可以看 到，p_next_enemy尚未确定，它指向未知的内存。
2.SHIP1的成员变量p_next_enemy设置为指向当前的敌舰列表（在本例中为p_enemies）。
3.更新p_enemies为指向新创建的敌舰。
4.函数返回p_ship给调用者，进行任何所需的使用，而p_enemies提供了访问整个列表的入口（当前，列表只有一个元素）。
15.2.2 第二轮
第二轮刚开始时，p_enemies指向着刚创建的敌舰。
1.分配一艘新的敌舰，用指针p_ship指向。现在有了第二艘敌舰，它 的p_next_enemy指向未知的内存。
2.p_next_enemy被设置为指向当前的敌舰列表。在本例中，p_next_enemy指向我们第一轮中创建的敌舰。
3.更新p_enemies指向最新创建的敌舰（p_enemies现在指向了第二艘敌 舰，而第二艘敌舰指向第一艘敌舰）。
4.函数返回p_ship给调用者，进行任何所需的使用，而p_enemies提供 了访问整个列表的入口（当前，列表中有两个元素）。
每当插入一个新元素时，你可以将这些操作视为向下“滑动”列表中所有的已有元素。
这种“滑动”不像数组中的那样，需要复制整个列表， 而只需要更新指向列表起始点的指针，使其指向新的开始元素。
列表中的第一个元素称为列表的头节点。通常要有一个指针指向列表的头节点，在本例中是p_enemies。
函数结束时，p_ship和p_enemies指向了同一位置，在这之前，我们需要用指针p_ship抓住新分配的内存，
这样就可以修改新节点的p_next_enemy指向存储在p_enemies中的列表的头节点。
虽然在刚才的函数中，我们将链表的头指针作为全局变量来使用，但你也可以把它作为参数传给函数，
这样，这个函数就能处理任何链表，而不只是一个全局链表了。以下是可行的代码：
EnemySpaceShip *addNewEnemyToList (EnemySpaceShip *p_list)
{
    EnemySpaceShip *p_ship = new EnemySpaceShip;
    p_ship->x_coordinate = 0;
    p_ship->y_coordinate = 0;
    p_ship->weapon_power = 20;
    p_ship->p_next_enemy = p_list;
    return p_ship;
}
由于addNewEnemyToList中既没有与列表相关联的全局变量，也无法修改传递到函数中的链表头指针（只能修改指针所指向的东西），
因此还需要一种方式来告知调用者列表的新起始点。调用者的代码可以这样写：
p_list = addNewEnemyToList( p_list );
另外，可以使用指向指针的指针而不是返回原来的值来解决同样的问题。
函数addNewEnemyToList的接口让其调用者可以选择所使用的列表以及在何处存储返回的列表。
用addNewEnemyToList函数也可以模拟之前p_enemies为全局变量的函数的行为，你可以这样写：
p_enemies = addNewEnemyToList( p_enemies );
15.3 遍历链表
到目前为止，一切都很好。现在知道了如何在列表中存储东西，使用列表来做些实实在在的事情吧。但做点什么好呢？
我们都知道如何使用for循环来迭代地访问数组的每个元素（迭代其实是循环的一种高端说法）。
来学习如何对链表做同样的事情，即遍历链表。
要取得列表中的下一个元素，只需要知道当前元素即可。你可以写一个循环，其中有一个变量持有指向列表的当前元素的指针，
每当对当前元素执行操作后，就更新它指向列表的下一个元素。
来看一段示例代码，它将升级游戏中所有敌舰的武器（可能因为玩家升到了下一级）：
EnemySpaceShip *p_current = p_enemies;

while ( p_current != nullptr )
{
    upgradeWeapons( p_current );
    p_current = p_current->p_next_enemy;
}
哇，代码行数跟遍历数组的几乎一样短呢！变量p_current用来跟踪列表的当前元素，
初始时，它指向列表的第一艘敌舰（无论p_enemies指向何处）。
只要p_current不为nullptr（意味着还没到列表的末尾），我们就升级当前敌舰的武器，并更新p_current指向列表中的下一艘敌舰。
请注意，整个程序中，只需要简单改变p_current的指向，而p_enemies和其他指针仍指向相同的位置。
这就是指针的强大之处！它让你仅通过修改指针的指向就可以沿着整个数据结构移动，不需要任何复制操作。
任何时候，每艘敌舰都只有一个副本。这使得我们的武器升级代码能够修改列表中原来的敌舰，而不是修改敌舰的副本。
下图是迭代遍历列表的过程中，数据结构和变量的可视化表示：
15.4 盘点链表
链表允许轻松地添加新的内存到数据结构中，而没有大量的内存复制和数组拼凑。
你还可以实现一些其他操作，比如添加元素到列表中间或删除元素。一个链表的完整实现，应该提供上述所有操作。
告诉你一个小秘密，你可能永远不会需要实现自己的链表！你可以使用标准模板库，而不是自己写一个链表。
我们很快就会讨论到标准模板库。然而，链表的重要之处在于，我们经常会使用类似的技术来创建更有趣的数据结构。
相信我，我没有让你误入歧途――这里学到的东西一定会有价值，即使你从来不编写自己的链表。
此外，通过了解一个链表是如何实现的，可以更好地理解使用链表和数组的利弊。
数组和链表的比较
链表优于数组的主要地方在于，链表可以轻松地调整大小或添加元素，而且这样做不需要移动每个元素。
例如，你很容易将新节点插入到链表中。
如果你想将新元素插入到一个排好序的列表中，同时要保持列表元素的顺序不变，会怎样呢？
假设这个列表为1、2、5、9、10，你想将元素6添加到5和9之间。
对于数组来说，需要调整数组大小，以便能够容纳新元素，因此你必须移动从9到列表末尾的每个元素。
如果列表在10之后有1000个元素，你必须将它们统统向后移动一位。
换句话说，将元素插入到数组中的性能，与数组的长度是成比例的。
如果用的是链表，你只需修改元素5指向新的元素，修改新元素指向元素9， 就大功告成了！
无论列表有多大，插入操作需要的时间都一样。
数组优于链表的地方主要在于，在数组中选择任意一个元素都很快， 只需提供该元素的索引即可。
而对于链表来说，需要遍历链表中的每个元素，直到查找到想要的元素为止。
不过，数组的这一优势，建立在数组的索引与元素中存储的值之间有关联的基础上。
否则，你还是得通过遍历数组来找到想要的元素。
例如，你可以用数组来创建一个选票计数器。其中，候选人从0~9进行编号，选民使用数字0至9来投票。
然后，每个数组索引对应一个候选人，数组在该位置上的值即是候选人的票数。
候选人与这些数字之间并没有内在联系，但我们通过对候选人编号简单地建立了一种联系。
接着我们使用这些数字来获得候选人的信息。
下面是使用数组的一个实现：
#include <iostream>

using namespace std;

int main ()
{
    int votes[ 10 ];

    for ( int i = 0; i < 10; ++i )
    {
        votes[ i ] = 0;
    }

    int candidate = 0;
    cout << "Vote for the candidate of your choice, Plese enter a number (1-10): \n";
    cout << "1) Joe 2) Bob 3) Mary 4) Suzy 5) Margaret 6) Eleanor 7) Alex 8) Thomas 8) Andrew 10) Ilene\n";
    cin >> candidate;

    while ( 1 <= candidate && candidate <= 10 )
    {
        votes[ candidate-1 ]++;
        candidate = 0;
        cout << "Vote for the candidate of your choice, Plese enter a number (1-10): \n";
        cout << "1) Joe 2) Bob 3) Mary 4) Suzy 5) Margaret 6) Eleanor 7) Alex 8) Thomas 8) Andrew 10) Ilene\n";
        cin >> candidate;
    }
    cout << "\n\n";
    for ( int i = 0; i < 10; ++i )
    {
        cout << votes[ i ] << '\n';
    }
}
示例代码39: vote.cpp
显示结果如下
Vote for the candidate of your choice, Plese enter a number (1-10):
1) Joe 2) Bob 3) Mary 4) Suzy 5) Margaret 6) Eleanor 7) Alex 8) Thomas 8) Andrew 10) Ilene
1
Vote for the candidate of your choice, Plese enter a number (1-10):
1) Joe 2) Bob 3) Mary 4) Suzy 5) Margaret 6) Eleanor 7) Alex 8) Thomas 8) Andrew 10) Ilene
1
Vote for the candidate of your choice, Plese enter a number (1-10):
1) Joe 2) Bob 3) Mary 4) Suzy 5) Margaret 6) Eleanor 7) Alex 8) Thomas 8) Andrew 10) Ilene
1
Vote for the candidate of your choice, Plese enter a number (1-10):
1) Joe 2) Bob 3) Mary 4) Suzy 5) Margaret 6) Eleanor 7) Alex 8) Thomas 8) Andrew 10) Ilene
3
Vote for the candidate of your choice, Plese enter a number (1-10):
1) Joe 2) Bob 3) Mary 4) Suzy 5) Margaret 6) Eleanor 7) Alex 8) Thomas 8) Andrew 10) Ilene
3
Vote for the candidate of your choice, Plese enter a number (1-10):
1) Joe 2) Bob 3) Mary 4) Suzy 5) Margaret 6) Eleanor 7) Alex 8) Thomas 8) Andrew 10) Ilene
7
Vote for the candidate of your choice, Plese enter a number (1-10):
1) Joe 2) Bob 3) Mary 4) Suzy 5) Margaret 6) Eleanor 7) Alex 8) Thomas 8) Andrew 10) Ilene
8
Vote for the candidate of your choice, Plese enter a number (1-10):
1) Joe 2) Bob 3) Mary 4) Suzy 5) Margaret 6) Eleanor 7) Alex 8) Thomas 8) Andrew 10) Ilene
8
Vote for the candidate of your choice, Plese enter a number (1-10):
1) Joe 2) Bob 3) Mary 4) Suzy 5) Margaret 6) Eleanor 7) Alex 8) Thomas 8) Andrew 10) Ilene
9
Vote for the candidate of your choice, Plese enter a number (1-10):
1) Joe 2) Bob 3) Mary 4) Suzy 5) Margaret 6) Eleanor 7) Alex 8) Thomas 8) Andrew 10) Ilene
q


3
0
2
0
0
0
1
2
1
0

使用一个结构体数组，每个结构体包含票数和候选人姓名。这种方法可以很容易地输出票数和候选人姓名。
试想一下，如果你试图用链表做同样的事情会怎么样呢？该代码必须一个元素接着一个元素地前进，直到抵达所选择的候选人为止。
通过索引访问数组的一个元素所花费的时间是恒定的，这意味着它不因数组的大小而变化。
相反，找到链表中的一个元素所花费的时间， 则是与列表的大小成正比。随着列表大小的增长，这将变得越来越慢。
如果打算使用链表来做的话，给候选人编号就没什么意义了，你也可以改为通过候选人姓名查找。
（姓名比较与索引比较相比速度要慢， 但既然选择了使用链表来实现，也许你不是很在乎代码的效率。）
1. 链表需要的存储空间大小
元素数量很大时，数据结构所占用的空间大小是一个不得不考虑的衡量因素。对于小型的数据结构，其差别并不大；
但是，如果数据结构本身就比较庞大，两倍的占用空间量可能是一个大问题。
数组的每个元素通常占用的空间较少。链表需要列表中的元素和一个指向列表的下一个元素的指针。
这意味着链表从一开始就需要大约两倍于每个元素的空间。不过，如果事先不知道要存储的元素数目的话，有时链表占用的空间反而比数组少。
与其分配一个大数组，然后让许多的数组元素空着，不如只在需要时才分配新的链表节点，这样就不会浪费没有使用到的额外空间。
（为了避免这个问题，可以动态地分配数组，但是这需要在每次分配更多内存时复制数组元素，从而抵消了一些占用空间小的优势。
不管怎样，你可以选择这种做法，特别是如果想要通过索引，在常量时间里访问到数组元素时。
对于数据结构，当你在比较几个不是明显糟糕的解决方案时，通常没有普遍正确的答案。
2. 其他考虑因素
数组也可以是多维的，例如，用数组很容易就能表示一个8乘8的棋盘。
然而，要用链表来表示这个棋盘就需要一个包含其他列表的列表，这使访问特定元素的速度慢了许多，而且更难理解。
3. 一般的经验法则
下面是两个关于何种情况下应该使用链表，何种情况下应该使用数组的经验法则：
1.当需要通过索引以常量时间访问元素，且预先知道需要存储多少元素，或当需要尽量减少每个元素所占用的空间时，建议使用数组；
2.当需要能够不断地增加新元素或需要在列表的中间做大量的插入时，建议使用链表。
3标准模板库（STL）中的vector类实际上使得增加元素到类数组的数据结构中变得很容易，从而使链表的这一优势不再明显。
因此，vector是一个比链表和数组更好的选择。稍后我们将讨论vector。
换句话说，链表和数组各有优点，选择使用链表还是数组取决于你想做什么。
问答题
1.链表相比于数组的优势是？
A. 链表的每个元素占用空间较少
B. 链表可以动态地扩展新元素而不用复制已有元素
C. 链表可以更快地找到特定元素
D. 链表可以将结构体容纳为元素

B
2.以下哪项是正确的？
A. 没有任何理由使用数组
B. 链表和数组具有相同的性能特点
C. 链表和数组都允许按索引以常量时间访问元素
D. 在链表中间插入元素比在数组中间插入速度要快

D
3.通常什么时候使用链表？
A. 只需要存储一个元素时
B. 需要存储的元素个数在编译时刻已知时
C. 需要动态地添加和删除元素时
D. 需要快速访问已排序的列表中的任何一个元素而无需做任何迭代时

C
4.为什么声明一个引用了自身元素类型 （struct Node { Node* p_next; };）的链表不会有问题？
A. 这是不允许的
B. 因为编译器能够弄清楚你实际上并不需要自引用元素的内存
C. 因为该类型是一个指针，你只需要足够的空间来容纳一个指针，实际的下一个节点的内存之后才会分配
D. 只有你实际上不分配p_next指向另一个结构体时才允许这么做

C
5.为什么在链表末尾有一个空指针（nullptr）很重要？
A. 它指示了链表结束的位置，防止代码访问未初始化的内存
B. 它能防止列表循环引用
C. 它能帮助调试，如果你试着偏离列表太远，程序将崩溃
D. 如果我们不存储nullptr，那么列表将因为自引用而需要无限的内存

A
6.链表和数组的有什么相似性？
A. 两者都允许你快速地在当前列表的中间添加元素
B. 两者都允许顺次地存储数据，并顺次访问数据
C. 两者都可以通过添加元素而变得更大
D. 两者都提供了对列表中的每个元素的快速访问

B
实践题
1.写一个程序，它能将元素从一个链表中删除；删除函数应该只移除要删除的元素。

#include <iostream>

using namespace std;

struct Item
{
    int ID;
    Item *nextItem;
    Item *previousItem;
};

Item *addToLinkedList(Item *p_list, int id);
Item *removeFromLinkedListWithTwoPointers(Item *p_item);
Item *removeFromLinkedListWithSinglePointer(Item *p_head, int target);

void printList(Item *p_list);

int main()
{
    Item *p_items = nullptr;
    Item *p_itemRemove = nullptr;
    Item *p_itemFirst = nullptr;
    Item *p_itemLast = nullptr;

    cout << "Create linked list of 10 items...\n";
    for (int i = 0; i < 10; i++)
    {
        p_items = addToLinkedList(p_items, i);
        if (i == 0)
        {
            p_itemFirst = p_items;
        }
        if (i == 5)
        {
            p_itemRemove = p_items;
        }
        if (i == 9)
        {
            p_itemLast = p_items;
        }
    }

    cout << "Remove ID 5 from the list\n";
    p_items = removeFromLinkedListWithTwoPointers(p_itemRemove);
    if (p_items != nullptr)
    {
        printList(p_items);
    }
    else
    {
        cout << "The list is empty.\n\n";
    }
    delete p_itemRemove;

    cout << "Remove ID 0 from the list\n";
    p_items = removeFromLinkedListWithTwoPointers(p_itemFirst);
    if (p_items != nullptr)
    {
        printList(p_items);
    }
    else
    {
        cout << "The list is empty.\n\n";
    }
    delete p_itemFirst;


    cout << "Remove ID 9 from the list\n";
    p_items = removeFromLinkedListWithTwoPointers(p_itemLast);
    if (p_items != nullptr)
    {
        printList(p_items);
    }
    else
    {
        cout << "The list is empty.\n\n";
    }
    delete p_itemLast;


    cout << "Remove ID 2 from the list\n";
    p_items = removeFromLinkedListWithSinglePointer(p_items, 2);
    if (p_items != nullptr)
    {
        printList(p_items);
    }
    else
    {
        cout << "The list is empty.\n\n";
    }

    cout << "Remove ID 12 from the list\n";
    p_items = removeFromLinkedListWithSinglePointer(p_items, 12);
    if (p_items != nullptr)
    {
        printList(p_items);
    }
    else
    {
        cout << "The list is empty.\n\n";
    }

    cout << "Remove ID 1 from the list\n";
    p_items = removeFromLinkedListWithSinglePointer(p_items, 1);
    if (p_items != nullptr)
    {
        printList(p_items);
    }
    else
    {
        cout << "The list is empty.\n\n";
    }

    cout << "Remove ID 8 from the list\n";
    p_items = removeFromLinkedListWithSinglePointer(p_items, 8);
    if (p_items != nullptr)
    {
        printList(p_items);
    }
    else
    {
        cout << "The list is empty.\n\n";
    }

    if (p_items != nullptr)
    {
        Item *p_current = p_items;
        Item *p_next;
        while (p_current != nullptr)
        {
            p_next = p_current->nextItem;
            delete p_current;
            p_current = p_next;
        }
    }
}

Item *addToLinkedList(Item *p_list, int id)
{
    Item *p_item = new Item;
    p_item->ID = id;
    p_item->previousItem = nullptr;
    p_item->nextItem = p_list;
    if (p_list != nullptr)
    {
        p_list->previousItem = p_item;
    }

    return p_item;
}

Item *removeFromLinkedListWithTwoPointers(Item *p_item)
{
    Item *p_nextItem = p_item->nextItem;
    Item *p_previousItem = p_item->previousItem;

    if (p_nextItem == nullptr && p_previousItem == nullptr)
    {
        p_item->nextItem = nullptr;
        p_item->previousItem = nullptr;
        return nullptr;
    }

    if (p_nextItem == nullptr && p_previousItem != nullptr)
    {
        p_previousItem->nextItem = nullptr;

        while (p_previousItem->previousItem != nullptr)
        {
            p_previousItem = p_previousItem->previousItem;
        }

        p_item->nextItem = nullptr;
        p_item->previousItem = nullptr;
        return p_previousItem;
    }


    if (p_previousItem == nullptr && p_nextItem != nullptr)
    {
        p_nextItem->previousItem = nullptr;
    }
    else if (p_previousItem != nullptr && p_nextItem != nullptr)
    {
        p_previousItem->nextItem = p_nextItem;
        p_nextItem->previousItem = p_previousItem;
    }

    while (p_nextItem->previousItem != nullptr)
    {
        p_nextItem = p_nextItem->previousItem;
    }

    p_item->nextItem = nullptr;
    p_item->previousItem = nullptr;
    return p_nextItem;
}

Item *removeFromLinkedListWithSinglePointer(Item *p_head, int target)
{
    Item *p_current = p_head;
    Item *p_previous = nullptr;
    Item *p_next = nullptr;

    while (p_current != nullptr && p_current->ID != target)
    {
        p_previous = p_current;
        p_current = p_current->nextItem;
    }

    if (p_current == nullptr)
    {
        cout << target << " is not in the list.\n";
        return p_head;
    }

    if (p_current == p_head)
    {
        p_head = p_current->nextItem;
        if (p_head != nullptr)
        {
            p_head->previousItem = nullptr;
        }
    }
    else
    {
        p_next = p_current->nextItem;
        p_previous->nextItem = p_next;
        if (p_next != nullptr)
        {
            p_next->previousItem = p_previous;
        }
    }
    p_current->nextItem = nullptr;
    p_current->previousItem = nullptr;

    delete p_current;

    return p_head;
}

void printList(Item *p_list)
{
    cout << "Printing the list...\n";

    Item *p_current = p_list;
    while (p_current != nullptr)
    {
        cout << "Item ID: " << p_current->ID << '\n';
        p_current = p_current->nextItem;
    }
    cout << '\n';
}
显示结果如下
Create linked list of 10 items...
Remove ID 5 from the list
Printing the list...
Item ID: 9
Item ID: 8
Item ID: 7
Item ID: 6
Item ID: 4
Item ID: 3
Item ID: 2
Item ID: 1
Item ID: 0

Remove ID 0 from the list
Printing the list...
Item ID: 9
Item ID: 8
Item ID: 7
Item ID: 6
Item ID: 4
Item ID: 3
Item ID: 2
Item ID: 1

Remove ID 9 from the list
Printing the list...
Item ID: 8
Item ID: 7
Item ID: 6
Item ID: 4
Item ID: 3
Item ID: 2
Item ID: 1

Remove ID 2 from the list
Printing the list...
Item ID: 8
Item ID: 7
Item ID: 6
Item ID: 4
Item ID: 3
Item ID: 1

Remove ID 12 from the list
12 is not in the list.
Printing the list...
Item ID: 8
Item ID: 7
Item ID: 6
Item ID: 4
Item ID: 3
Item ID: 1

Remove ID 1 from the list
Printing the list...
Item ID: 8
Item ID: 7
Item ID: 6
Item ID: 4
Item ID: 3

Remove ID 8 from the list
Printing the list...
Item ID: 7
Item ID: 6
Item ID: 4
Item ID: 3



2.写一个程序，它能将元素添加到有序的链表中，而不是添加在链表的开头。

#include <iostream>

using namespace std;

struct Item
{
    int ID;
    Item *nextItem;
    Item *previousItem;
};

Item *addToSortedLinkedList(Item *p_list, int id);

void printList(Item *p_list);

int main()
{
    Item *p_items = nullptr;
    int IDs[10];
    IDs[0] = 5;
    IDs[1] = 15;
    IDs[2] = 0;
    IDs[3] = 12;
    IDs[4] = -1;
    IDs[5] = 2;
    IDs[6] = 8;
    IDs[7] = 100;
    IDs[8] = 100;
    IDs[9] = 55;
    cout << "The list of items starts with the following IDs...\n";
    for (int i = 0; i < 10; i++)
    {
        if (i != 0)
        {
            cout << ", ";
        }
        cout << IDs[i];
    }
    cout << '\n';

    cout << "Create linked list of 10 items...\n";
    for (int i = 0; i < 10; i++)
    {
        p_items = addToSortedLinkedList(p_items, IDs[i]);
    }
    cout << '\n';

    cout << "Ordering the list...\n\n";
    printList(p_items);

    if (p_items != nullptr)
    {
        Item *p_current = p_items;
        Item *p_next;
        while (p_current != nullptr)
        {
            p_next = p_current->nextItem;
            delete p_current;
            p_current = p_next;
        }
    }
}
Item *addToSortedLinkedList(Item *p_list, int id)
{
    Item *p_item = new Item;
    p_item->ID = id;

    if (p_list == nullptr)
    {
        p_item->previousItem = nullptr;
        p_item->nextItem = nullptr;
        return p_item;
    }

    Item *p_current = p_list;
    Item *p_nextItem = p_list->nextItem;
    Item *p_previousItem = p_list->previousItem;
    while (p_current != nullptr)
    {
        if ( p_nextItem == nullptr && p_previousItem == nullptr )
        {
            if(p_item->ID >= p_current->ID)
            {
                p_item->previousItem = nullptr;
                p_item->nextItem = p_current;

                p_current->previousItem = p_item;
                return p_item;
            }
            else
            {
                p_item->previousItem = p_current;
                p_item->nextItem = nullptr;

                p_current->nextItem = p_item;
                return p_list;
            }
        }
        else if ( p_nextItem == nullptr && p_previousItem != nullptr)
        {
            if(p_item->ID >= p_current->ID)
            {
                p_item->previousItem = p_previousItem;
                p_item->nextItem = p_current;

                p_current->previousItem = p_item;
                p_previousItem->nextItem = p_item;
            }
            else
            {
                p_item->previousItem = p_current;
                p_item->nextItem = nullptr;

                p_current->nextItem = p_item;
            }
            return p_list;
        }
        else if ( p_nextItem != nullptr && p_previousItem == nullptr )
        {
            if (p_item->ID >= p_current->ID)
            {
                p_item->previousItem = nullptr;
                p_item->nextItem = p_current;

                p_current->previousItem = p_item;
                return p_item;
            }
            else
            {
                p_previousItem = p_current;
                p_current = p_nextItem;
                if (p_current != nullptr)
                {
                    p_nextItem = p_current->nextItem;
                }
                else
                {
                    p_nextItem = nullptr;
                }
            }
        }
        else if ( p_nextItem != nullptr && p_previousItem != nullptr )
        {
            if (p_item->ID >= p_current->ID && p_item->ID < p_previousItem->ID)
            {
                p_item->previousItem = p_previousItem;
                p_item->nextItem = p_current;

                p_current->previousItem = p_item;
                p_previousItem->nextItem = p_item;
                return p_list;
            }
            else
            {
                p_previousItem = p_current;
                p_current = p_nextItem;
                if (p_current != nullptr)
                {
                    p_nextItem = p_current->nextItem;
                }
                else
                {
                    p_nextItem = nullptr;
                }
            }
        }
    }
    return p_list;
}
void printList(Item *p_list)
{
    cout << "Printing the list...\n";

    Item *p_current = p_list;
    while (p_current != nullptr)
    {
        cout << "Item ID: " << p_current->ID << '\n';
        p_current = p_current->nextItem;
    }
    cout << '\n';
}
显示结果如下
The list of items starts with the following IDs...
5, 15, 0, 12, -1, 2, 8, 100, 100, 55
Create linked list of 10 items...

Ordering the list...

Printing the list...
Item ID: 100
Item ID: 100
Item ID: 55
Item ID: 15
Item ID: 12
Item ID: 8
Item ID: 5
Item ID: 2
Item ID: 0
Item ID: -1

3.写一个程序，它能通过名称找到链表中的元素。

#include <iostream>
#include <string>

using namespace std;

struct Item
{
    string name;
    Item *nextItem;
    Item *previousItem;
};

Item *addToLinkedList(Item *p_list, string name);
Item *getItemByName(Item *p_list, string name);

void printList(Item *p_list);

int main()
{
    Item *p_items = nullptr;
    Item *p_find = nullptr;
    string names[10];
    names[0] = "Sam";
    names[1] = "Sally";
    names[2] = "Sue";
    names[3] = "Mark";
    names[4] = "Phil";
    names[5] = "Brenton";
    names[6] = "Melissa";
    names[7] = "Charles";
    names[8] = "Quigly";
    names[9] = "Foo";

    cout << "Create linked list of 10 items...\n";
    for (int i = 0; i < 10; i++)
    {
        p_items = addToLinkedList(p_items, names[i]);
    }
    printList(p_items);

    cout << "Getting element for " << names[3] << "...\n";
    p_find = getItemByName(p_items, names[3]);
    if (p_find != nullptr)
    {
        printList(p_find);
    }
    else
    {
        cout << "Can not find the matching node.\n\n";
    }

    cout << "Getting non-existing name...\n";
    p_find = getItemByName(p_items, "Carmen");
    if (p_find != nullptr)
    {
        printList(p_find);
    }
    else
    {
        cout << "Can not find the matching node.\n\n";
    }

    if (p_items != nullptr)
    {
        Item *p_current = p_items;
        Item *p_next;
        while (p_current != nullptr)
        {
            p_next = p_current->nextItem;
            delete p_current;
            p_current = p_next;
        }
    }
}

Item *addToLinkedList(Item *p_list, string name)
{
    Item *p_item = new Item;
    p_item->name = name;
    p_item->previousItem = nullptr;
    p_item->nextItem = p_list;
    if (p_list != nullptr)
    {
        p_list->previousItem = p_item;
    }

    return p_item;
}

Item *getItemByName(Item *p_list, string name)
{
    Item *p_current = p_list;
    while (p_current != nullptr)
    {
        if (p_current->name == name)
        {
            return p_current;
        }
        p_current = p_current->nextItem;
    }
    return nullptr;
}
void printList(Item *p_list)
{
    cout << "Printing the list...\n";

    Item *p_current = p_list;
    while (p_current != nullptr)
    {
        cout << "Item Name: " << p_current->name << '\n';
        p_current = p_current->nextItem;
    }
    cout << '\n';
}
显示结果如下
Create linked list of 10 items...
Printing the list...
Item Name: Foo
Item Name: Quigly
Item Name: Charles
Item Name: Melissa
Item Name: Brenton
Item Name: Phil
Item Name: Mark
Item Name: Sue
Item Name: Sally
Item Name: Sam

Getting element for Mark...
Printing the list...
Item Name: Mark
Item Name: Sue
Item Name: Sally
Item Name: Sam

Getting non-existing name...
Can not find the matching node.

4.实现一个双人的井字棋游戏。使用链表来表示棋盘。

#include <iostream>
#include <string>

using namespace std;

enum SquareState
{
    TTTS_Blank,
    TTTS_O,
    TTTS_X
};

struct Position
{
    int row;
    int column;
};

struct TicTacToeSquare
{
    SquareState state;
    Position position;
    TicTacToeSquare *next;
    TicTacToeSquare *previous;
};

TicTacToeSquare *addToLinkedList(TicTacToeSquare *p_list, int row, int column, SquareState state);
TicTacToeSquare *createGameBoard(int size);
TicTacToeSquare *getSquare(Position boardPosition, TicTacToeSquare *gameBoard);
void drawBoard(int size, TicTacToeSquare &gameBoard);
string setPlayer(bool playerXInSession);
string translateEnumToString(SquareState squareState);
bool validIndex(Position boardPosition, int boardSize);
bool choiceTaken(TicTacToeSquare &currentSquare);
void setChoice(TicTacToeSquare *currentSquare, bool playerXInSession);
SquareState choiceSquare(bool playerXInSession);
bool squareMatches(TicTacToeSquare &gameBoard, SquareState choiceCheck, int row, int column);
bool choiceWins(bool playerXInSession, TicTacToeSquare &gameBoard, int size);
bool boardIsFull(TicTacToeSquare *gameBoard);

int const minToWin = 4;

int main()
{
    bool gameFinished = false;
    bool playerXInSession = true;
    string player = "";
    int row = 0;
    int column = 0;

    int sizeUsed = 4;

    cout << "Please specify the number of spaces to be used for the rows/columns of the square board:\n";
    cout << "(Default is " << minToWin << ")\n";
    cin >> sizeUsed;
    if (sizeUsed < minToWin)
    {
        sizeUsed = minToWin;
    }

    TicTacToeSquare *gameBoard = createGameBoard(sizeUsed);

    do
    {
        row = 0;
        column = 0;
        player = setPlayer(playerXInSession);

        drawBoard(sizeUsed, *gameBoard);

        cout << "Player " << player << ", choose your next board position to claim:\n";

        cout << "Row: \n";
        cin >> row;
        row--;

        cout << "Column: \n";
        cin >> column;
        column--;

        Position boardPosition = { row, column };
        if (!validIndex(boardPosition, sizeUsed))
        {
            cout << "That is an invalid choice. Please try again.\n";
            continue;
        }

        TicTacToeSquare *currentSquare = getSquare(boardPosition, gameBoard);
        if (currentSquare == nullptr)
        {
            cout << "You have selected a position that does not exist on the board. Please try again.\n";
            continue;;
        }

        if (choiceTaken(*currentSquare))
        {
            cout << "That square is already taken. Please try again.\n";
            continue;
        }

        setChoice(currentSquare, playerXInSession);

        if (choiceWins(playerXInSession, *gameBoard, sizeUsed))
        {
            cout << "Player " << player << " wins!\n";
            gameFinished = true;
        }

        if (boardIsFull(gameBoard))
        {
            cout << "Board is full. The game is a tie!\n";
            gameFinished = true;
        }

        playerXInSession = !playerXInSession;
    }
    while (!gameFinished);

    if (gameBoard != nullptr)
    {
        TicTacToeSquare *p_current = gameBoard;
        TicTacToeSquare *p_next;
        while (p_current != nullptr)
        {
            p_next = p_current->next;
            delete p_current;
            p_current = p_next;
        }
    }
}

TicTacToeSquare *addToLinkedList(TicTacToeSquare *p_list, int row, int column, SquareState state)
{
    TicTacToeSquare *p_item = new TicTacToeSquare;
    p_item->position.row = row;
    p_item->position.column = column;
    p_item->state = state;

    p_item->previous = nullptr;
    p_item->next = p_list;
    if (p_list != nullptr)
    {
        p_list->previous = p_item;
    }

    return p_item;
}

TicTacToeSquare *createGameBoard(int size)
{
    TicTacToeSquare *p_item = nullptr;
    for (int row = 0; row < size; row++)
    {
        for (int column = 0; column < size; column++)
        {
            p_item = addToLinkedList(p_item, row, column, TTTS_Blank);
        }
    }
    return p_item;
}

TicTacToeSquare *getSquare(Position boardPosition, TicTacToeSquare *gameBoard)
{
    TicTacToeSquare *p_current = gameBoard;
    while (p_current != nullptr)
    {
        if ( (p_current->position.row == boardPosition.row) &&
                (p_current->position.column == boardPosition.column) )
        {
            return p_current;
        }
        p_current = p_current->next;
    }
    return nullptr;
}

void drawBoard(int size, TicTacToeSquare &gameBoard)
{
    cout << "Tic-Tac-Toe\n";
    cout << minToWin << "-in-a-row are needed to win!\n";
    string horizontalBar = " _";
    for (int row = 0; row < size; row++)
    {
        horizontalBar += "__";
    }

    for (int row = 0; row <= size; row++)
    {
        if (row == 0)
        {
            for (int column = 0; column <= size; column++)
            {
                if (column == 0)
                {
                    cout << " ";
                }
                else
                {
                    cout << " " << column;
                }
            }
            cout << "\n";
        }
        else
        {
            cout << horizontalBar << "\n";
            for (int column = 0; column <= size; column++)
            {
                if (column == 0)
                {
                    cout << row;
                }
                else
                {
                    Position boardPosition = { row - 1, column - 1 };
                    TicTacToeSquare *currentSquare = getSquare(boardPosition, &gameBoard);
                    cout << "|" << translateEnumToString(currentSquare->state);
                }
            }
            cout << "|\n";
        }
    }
    cout << horizontalBar << "\n\n";
}

string setPlayer(bool playerXInSession)
{
    if (playerXInSession)
    {
        return "X";
    }
    return "O";
}

bool validIndex(Position boardPosition, int boardSize)
{
    return ( ( (boardPosition.row >= 0) && (boardPosition.column >= 0) ) &&
            ( (boardPosition.row < boardSize) && (boardPosition.column < boardSize) ) );
}

bool choiceTaken(TicTacToeSquare &gameSquare)
{
    return (gameSquare.state != TTTS_Blank);
}

void setChoice(TicTacToeSquare *gameSquare, bool playerXInSession)
{
    gameSquare->state = choiceSquare(playerXInSession);
}

SquareState choiceSquare(bool playerXInSession)
{
    if (playerXInSession)
    {
        return TTTS_X;
    }
    return TTTS_O;
}

bool choiceWins(bool playerXInSession, TicTacToeSquare &gameBoard, int size)
{
    SquareState choiceCheck = choiceSquare(playerXInSession);;
    double score;

    for (int row = 0; row < size; row++)
    {
        score = 0;
        for (int column = 0; column < size; column++)
        {
            if (squareMatches(gameBoard, choiceCheck, row, column))
            {
                score++;
                if (score >= minToWin)
                {
                    return true;
                }
            }
            else
            {
                score = 0;
            }
        }
    }

    for (int column = 0; column < size; column++)
    {
        score = 0;
        for (int row = 0; row < size; row++)
        {
            if (squareMatches(gameBoard, choiceCheck, row, column))
            {
                score++;
                if (score >= minToWin)
                {
                    return true;
                }
            }
            else
            {
                score = 0;
            }
        }
    }

    score = 0;
    for (int i = 0; i < size; i++)
    {
        if (squareMatches(gameBoard, choiceCheck, i, i))
        {
            score++;
            if (score >= minToWin)
            {
                return true;
            }
        }
        else
        {
            score = 0;
        }
    }

    int maxIndex = size - 1;
    score = 0;
    for (int i = 0; i < size; i++)
    {
        if (squareMatches(gameBoard, choiceCheck, i, maxIndex - i))
        {
            score++;
            if (score >= minToWin)
            {
                return true;
            }
        }
        else
        {
            score = 0;
        }
    }

    return false;
}

bool squareMatches(TicTacToeSquare &gameBoard, SquareState choiceCheck, int row, int column)
{
    Position boardPosition = { row, column };
    TicTacToeSquare *currentSquare = getSquare(boardPosition, &gameBoard);
    return (currentSquare->state == choiceCheck);
}

bool boardIsFull(TicTacToeSquare *gameBoard)
{
    TicTacToeSquare *p_current = gameBoard;
    while (p_current != nullptr)
    {
        if ((p_current->state == TTTS_Blank))
        {
            return false;
        }
        p_current = p_current->next;
    }
    return true;
}

string translateEnumToString(SquareState squareState)
{
    switch (squareState)
    {
    case TTTS_Blank:
        return " ";
    case TTTS_O:
        return "O";
    case TTTS_X:
        return "X";
    default:
        return "~";
    }
}
显示结果如下
Please specify the number of spaces to be used for the rows/columns of the square board:
(Default is 4)
6
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | | | |
 _____________
2| | | | | | |
 _____________
3| | | | | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
1
Column:
1
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| | | | | |
 _____________
2| | | | | | |
 _____________
3| | | | | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
3
Column:
3
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| | | | | |
 _____________
2| | | | | | |
 _____________
3| | |O| | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
1
Column:
3
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| |X| | | |
 _____________
2| | | | | | |
 _____________
3| | |O| | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
3
Column:
2
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| |X| | | |
 _____________
2| | | | | | |
 _____________
3| |O|O| | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
3
Column:
1
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| |X| | | |
 _____________
2| | | | | | |
 _____________
3|X|O|O| | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
2
Column:
1
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| |X| | | |
 _____________
2|O| | | | | |
 _____________
3|X|O|O| | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
2
Column:
2
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| |X| | | |
 _____________
2|O|X| | | | |
 _____________
3|X|O|O| | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
4
Column:
3
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| |X| | | |
 _____________
2|O|X| | | | |
 _____________
3|X|O|O| | | |
 _____________
4| | |O| | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
1
Column:
2
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X|X| | | |
 _____________
2|O|X| | | | |
 _____________
3|X|O|O| | | |
 _____________
4| | |O| | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
1
Column:
4
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X|X|O| | |
 _____________
2|O|X| | | | |
 _____________
3|X|O|O| | | |
 _____________
4| | |O| | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
2
Column:
3
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X|X|O| | |
 _____________
2|O|X|X| | | |
 _____________
3|X|O|O| | | |
 _____________
4| | |O| | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
5
Column:
3
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X|X|O| | |
 _____________
2|O|X|X| | | |
 _____________
3|X|O|O| | | |
 _____________
4| | |O| | | |
 _____________
5| | |O| | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
2
Column:
4
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X|X|O| | |
 _____________
2|O|X|X|X| | |
 _____________
3|X|O|O| | | |
 _____________
4| | |O| | | |
 _____________
5| | |O| | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
6
Column:
3
Player O wins!

第16章 递归
你已经见过许多基于循环的算法，它们一遍又一遍地执行某些任务。 
现在来讲另一类不使用循环却可以重复执行代码的方法，这种方法使用的是重复的函数调用，我们把它称为递归。
递归是一种在表达操作时会用到自身的技术，也就是说，递归意味着编写的函数会调用自身。
它跟循环类似，但功能更强大。它可以使某些几乎不可能用循环来完成的程序变成小事一桩！
递归尤其适合于应用在诸如链表、二叉树（马上就讲到了）这样的数据结构中。
接下来的两章内容，我们一起通过一些具体的例子，来探讨递归的基本思想。
16.1 如何看待递归
一个思考递归的有效方法是：把递归看做一个执行过程，这个执行过程的其中一条指令是“重复这个执行过程”。
这听起来跟循环非常类似，因为都是在重复相同的代码。递归和循环确实在某些方面是类似的，
但是，递归可以更容易地表达这样一种想法：执行过程的结果是完成执行过程所必需的。
当然，这个“执行过程”必须存在某个时刻可以不用再递归调用就能够完成。
举个简单的例子，砌筑一面10尺高墙。如果我想建造一面十英尺高的墙，我会先建造一个九英尺高的墙，然后添加一层额外的墙砖。
从概念上讲，这就好比说：“建墙”函数接受了一个高度值，如果这个高度值大于1，“建墙”函数首先要调用自身来建造一个稍低的墙，
然后添加一层额外的墙砖。
这个“建墙”函数的基本结构看起来应该如下面的代码所示。（这段代码有几个明显的缺陷，我们很快会讨论到。）
这里面最重要的思想是：建造一个特定高度的墙可以用建造一个更低的墙来表达。
void buildWall (int height)
{
    buildWall( height - 1 );
    addBrickLayer();
}
但这段代码有一个小问题，不是吗？什么时候会停止调用buildWall呢？
很遗憾，答案是，永远不。解决办法很简单：我们需要在墙高为0时停止递归调用。
墙的高度为0时，我们应该仅仅添加一层墙砖即可，不用建造任何更低的墙体。
void buildWall (int height)
{
    if ( height > 0 )
    {
        buildWall( height - 1 );
    }
    addBrickLayer();
}
函数不调用自身的情况称为函数的基线条件。在刚才的例子中，“建墙”函数知道如果已经到达地面，就只要添加一层墙砖就可以了
（建墙的基线条件）。否则，我们仍然需要建立一堵更低的墙，然后在上面添加一层砖。
如果你对这段代码还是疑惑不解（第一次见到递归时， 人们往往一头雾水），想想建造一堵墙的物理过程。
刚开始，你希望建造一堵特定高度的墙，接着就会说：“我需要一堵矮一层的墙，好让我把砖块放上去。”
最终，你就会说：“我不需要一堵更矮的墙了，我可以直接在地面上建造。”这就是基线条件。
基线条件有时也称为终止条件。
注意，这个算法先将一个大问题简化成更小的问题（建造一堵更矮的墙），然后去解决这个更小的问题。
在某些情况下，更小的问题（如在地面上建造一层高的墙体）小到不再需要进一步简化，而是可以马上就解决。
在现实生活中，这意味着可以建立一堵墙了；而在C++里，这确保了该函数将最终停止递归调用。
这很像之前看到过的自顶向下的设计过程，我们把问题分解成更小的子问题，创建出这些子问题的函数，
然后用它们来构建完整的程序。这种情况下，我们将问题分解成了不同的子问题，而不是一个正在解决的问题；
而在递归中，我们将一个问题分解成了相同问题的更小版本。
一旦函数调用了自己，当调用返回时，它会去执行调用点之后的下一行语句。
类似的，递归调用返回后，函数仍可以执行操作或调用其他函数。
在“建墙”的例子中，建造小墙后，函数将继续执行，添加一层新的砖块。
下面是一个实际可运行的例子，用来展示实际的输出。怎样写出一个 递归函数，来输出数字123 456 789 987 654 321呢？
我们可以先编写 一个函数，它接受一个数字，然后两次输出这个数字，一次在函数递 归之前，一次在递归之后。
#include <iostream>

using namespace std;

void printNum (int num)
{
    cout << num;
    if ( num < 9 )
    {
        printNum( num + 1 );
    }
    cout << num;
}

int main ()
{
    printNum( 1 );
}
示例代码40: printnum.cpp
显示结果如下
123456789987654321

你可以这样来理解整个过程：printNum函数每次输出数字后会再次调用printNum函数，结果是先依次输出了1到9。
当基线条件满足时，printNum将返回到每个递归调用，以函数返回的顺序再次输出数字。
最后一个函数调用的值为9，由于达到了基线条件，它将立即输出数字9，而不是再次调用函数。
当num为9的函数返回时，它将返回到num为8的函数进行递归调用的位置，接着num为8的函数接着输出数字8，然后返回；
接着num为7的函数继续执行，以此类推，直到完成所有的递归调用，返回到第一个递归调用的位置，此时num为1；
接着输出数字1，任务完成。 
16.2 递归和数据结构
有些数据结构会借用到递归算法，因为这些数据结构的组成可以描述成含有相同数据结构的更小版本。
既然递归算法通过将问题分解成原问题的更小版本来解决，数据结构也一样可以将原数据结构分解成相同数据结构的更小版本。
链表就是一种这样的数据结构。
之前已经说过，链表是这样一种列表：你可以在链表前面增添更多的新节点。但从另一个角度去思考，也可以认为，
链表由一个首节点构成，这个首节点指向了另一个更小版本的链表。
这一点很重要，因为它提供了一个非常有用的特性：可以编写这样一种处理链表的程序，它要么处理当前节点，
要么去处理“列表的其余部分”。例如，要找到列表中的一个特定节点，可以使用此基本算法：
如果我们在列表的末尾，返回NULL。
否则，如果当前节点就是查找的目标，将其返回。
否则，在列表的其余部分继续查找。
在代码中，应该是这样的：
struct node
{
    int value;
    node *next;
};

node *search (node *list, int value_to_find)
{
    if ( list == NULL )
    {
        return NULL;
    }
    if ( list->value == value to find )
    {
        return list;
    }
    else
    {
        return search( list->next, value_to_find );
    }
}
当考虑一个递归调用时，我们提到过，被调用函数中会做一些事情。 函数在给定的输入下所承诺要做的事，称为函数的契约。
函数契约总结了函数所要做的事情。search函数的契约是查找到列表中的一个给定的节点。
search函数的实现就相当于在说，“如果当前节点是我们想要找的，那么返回它；
否则，函数的契约还是在列表中查找某个节点，让我们用这个契约，来看看剩余的列表吧！”
在列表的剩余部分调用search函数，而不是整个列表，这一点很重要。
递归只有在满足以下两个条件时，才能够正确运行：
1.能够构造出一个通过解决同类型的较小问题来解决原问题的方案；
2.能够解决基线条件。
search函数的解决有两个可能的基线条件：要么到达列表的末尾，要 么找到想要的节点。
如果这两种情况都没有满足，那么使用search函数来解决相同问题的较小版本。
关键在于：我们能够递归地利用相同问题的较小版本的解决结果，来解决更大的原问题，只有这样，递归才能起到效果。
有时候，递归调用的返回值并不是马上被返回，而是被实际使用。让我们来看一个例子：数学上的阶乘函数。
Factorial( x ) = x * ( x - 1 ) *( x - 2 )...*1
或者，换种方式来表达：
Factorial( x ) =       
   If ( x == 1 ) 1   
   Else x * Factorial( x - 1 )
换句话说，任何数字的阶乘就是此数字乘以比此数字小1的数的阶乘。
在这种情况下，我们可以用递归调用的返回值做其他事情，比如将返回值乘以当前的数字，如下所示。
代码可以这样写：
int factorial (int x)
{
    if ( x == 1 )
    {
        return 1;
    }
    return x * factorial( x C 1 );
}
这个例子中，我们要么抵达x为1的基线条件，要么继续解决更小版本的相同问题，也即factorial(x - 1)，
然后使用factorial(x - 1)的返回值来计算x的阶乘。每一次调用factorial都将使x变得更小，所以最终肯定会到达基线条件。
请注意，使用递归的过程中，我们不断地求解子问题，然后用子问题的结果来做一些事。
在搜索一个链表时，我们只是返回子问题的求解结果。
递归用于两种方式：要么是仅靠递归调用就能够解决全部的问题，要么是获得子问题的求解结果，然后使用该结果做更多的计算。
16.3 循环和递归
在某些情况下，递归算法可以很容易地转化成用结构相同的循环来表示。例如，搜索列表的代码可以写成这样：
node *search (node *list, int value_to_find)
{
    while ( 1 )
    {
        if ( list == NULL )
        {
            return NULL;
        }
        if ( list->value == value_to_find )
        {
            return list;
        }
        else
        {
            list = list->next;
        }
    }
}
这段代码进行的检查实际上跟使用递归的版本是一样的，你很容易看出两者的差异。
两种算法的唯一区别是，这段代码使用了一个循环， 而不是递归。它没有使用递归调用来缩短列表的大小，
而是通过每次将它指向“列表的剩余部分”来实现的。这是一个递归的解决方案和迭代（基于循环）的解决方案有相似之处的例子。
当不需要对递归调用函数的返回值做任何处理时，通常很容易写出递归算法的循环版本，
反之亦然，我们也能很容易写出循环算法的递归版本。
这种情况就是尾递归（tail recursion）：递归调用是递归函数在函数尾部所做的最后一件事情。
由于递归调用是最后一个操作，这无异于循环中的下一步。一旦下一个调用完成，之前的调用就不再需要了。
列表搜索就是一个尾递归的例子。
然而，如果考虑将递归实现的阶乘函数改写成基于循环的实现时，问题就出现了：
int factorial (int x)
{
    while ( 1 )
    {
        if ( x == 1 )
        {
            return 1;
        }
        // 要返回 x * factorial( x C 1 );
        //  以下代码应该怎么写呢？
    }
}
我们需要用factorial( x C 1 )来做一些事，所以这里不能只是循环。 也就是说，我们需要真正地解决了子问题，才能够完成计算。
其实，如果重新从另外一个角度来思考，就会发现：阶乘函数很容易转换成用循环来实现。来考虑一下原来的定义：
Factorial( x ) = x * ( x - 1 ) *( x - 2 )...*1
如果能跟踪当前值，就可以通过将运行 中x * ( x - 1 ) * ( x - 2 ) ...乘法运算的结果存储下来，从而解决问题：
int factorial (int x)
{
    int cur = x;
    while ( x > 1 )
    {
        x--;
        cur *= x;
    }
    return cur;
}
注意，我们并非通过获得子问题（更小的阶乘）的结果来解决这个问题，而是以相反的顺序来做的。
例如，如果计算5的阶乘，递归的解决方案会以如下顺序相乘：
1 * 2 * 3 * 4 * 5
而迭代的解决方案则以相反的顺序做的乘法：
5 * 4 * 3 * 2 * 1
在这个例子中，递归和迭代两种解决方案都比较好找（虽然两者的结构差别较大）。
通过重新考虑算法的结构，我们可以写出阶乘函数的一个非常简单的循环实现。
但在某些情况下，想出循环版本的解决方案可能比本例要难得多。选择使用递归与否，将取决于发现迭代算法的难易程度。
在阶乘的例子中，这并不太难，但在某些情况下，可能非常困难。这种情况常会遇到。
16.4 栈
是时候来了解一下函数调用是如何进行的了。一旦了解了函数调用的工作方式，会更有利于你理解递归，
并且对于理解为什么有些算法很容易写出递归版本，却很难写出循环版本，会有直观的感受。
函数所使用的所有内部信息都存储在栈中。想象一叠盘子，你可以把新盘子放在这叠盘子的顶部，也可以从顶部取走盘子。
栈的工作原理与一叠盘子类似，不同的是，栈中存放的不是“盘子”，而是称为栈帧的东西。
当一个函数被调用时，它在栈的顶部得到一块新的栈帧，并使用这块栈帧来存储所有它要使用到的局部变量。
当这个函数调用了另外一个函数时，原始的栈帧空间被保留，新的栈帧被添加到栈顶， 用于为新近调用的函数存放自己的变量。
当前正在执行的函数总是使用栈顶的栈帧。
在最简单的情况下，只有main函数在执行，这时候的栈看起来像这样：
当前只有一个函数正在执行，即main函数；栈中只有main函数的变量。
现在，如果main函数调用了其他函数，那么新的函数将在main函数的顶部创建一个新的栈帧。看起来像这样：
当前的函数在自己的栈帧中存储自己的变量，不会干预到main函数所使用的变量。
如果第二个函数调用第三个函数，这时候的栈看起来就像这样：
每个新调用的函数都有自己的栈帧；每次函数调用都会创建新的栈 帧。一旦函数返回，栈将回到函数调用之前的样子：
如果第二个函数返回到main函数，此时栈回到了只有一个栈帧的样子：
当前正在执行的函数的栈帧处于活动状态，它始终在栈的顶部。
除了保存函数所用到的变量，栈帧中还包含了传递到函数的参数，以及函数结束时应该返回到的函数的代码行。
换句话说，栈帧中存储着函数从何处被调用的信息，以及函数使用的所有数据。
递归调用一个函数将为新调用的函数创建新的栈帧，即使是相同的函数也是如此。
这就是递归能正确工作的原因：每个函数调用都有自己独立的栈帧， 包括自己的参数和变量。
这使得每个函数调用拥有自己的信息，因此每个函数都可以把原问题的更小版本表示成自己的变量来处理。
正如示意图中所看到的，当函数结束后，该函数从栈顶中删除自己的栈帧，并返回到其调用函数的执行点。
通过删除该函数的栈帧，恢复出其调用函数所使用的栈帧。
关键在于：栈帧中保存着函数的返回位置，并且，函数执行结束后会从栈中删除其栈帧。
栈帧如果不正确，函数返回后，调用函数将不能继续正确执行。比如，调用函数的局部变量没有获得返回值。
不妨这样想：当新函数被调用时，之前的函数会把继续执行所需要的一切数据保留下来。
这就好比当你在做一个项目时，中途决定去吃饭，就会做个记号，标明项目做到哪儿了，以便饭后继续工作。
栈允许计算机在任何时刻对当前的运行信息做极其详细的记录。
这里有个栈，它演示了对buildWall函数的三次递归调用，从高度为2时开始执行。
可以看到，每个栈帧都保留传递到buildWall函数中的高度值。
（注意，当调用高度值为0的buildWall函数时，栈停止了增长，因为刚好到地面了。）
这种绘制栈的方法也常简写成这样：
buildWall( x = 0 )
buildWall( x = 1 )
buildWall( height = 2 )
main( )
每个函数都显示在其调用函数的顶部，函数的参数同时也显示出来。 
使用这种表示方法，可以帮助你理解一个特定的递归函数是如何工作的。
有时你会发现，除了显示函数名和函数参数外，在每个栈帧的旁边写上局部变量也很有用。
16.4.1 栈的力量
从递归中能够获得用于后续计算的关键值的主要原因是：在递归中你拥有的是一堆函数调用构成的栈，而不仅仅是一个栈帧。
递归算法可以利用存储在每个栈帧中的所有的额外信息，而循环只能获得一个栈帧里的一组局部变量。
因此，递归函数可以等待递归调用返回，从而接收到需要的值，然后从停止点继续执行。
要想写一个以这种方式工作的循环，你需要自己实现一个栈。
16.4.2 递归的缺点
栈的大小是固定的，这也就意味着不能有无限的递归。递归到某些时候，栈顶将会没有更多空间来添加新的栈帧，
就好像橱柜的空间被挤满，不能再增加一个盘子一样。
下面是一个简单的例子，理论上这个递归可以无限执行：
void recurse ()
{
    recurse(); // 函数调用自身
}

int main ()
{
    recurse(); // 开始递归
}
但最终，栈空间会消耗一空，程序将因栈溢出而崩溃。当栈空间不足时，就会发生栈溢出。
这时，没有任何空间来做函数调用，如果你的程序尝试此操作就会崩溃。
这种类型的崩溃比较罕见，通常是递归函数的基线条件没写好才导致的结果。
例如，前面我写的阶乘函数的例子就有一个小问题：它在基线条件中没有对负数进行检查。
如果调用函数传入-1，这几乎肯定会发生栈溢出。（试试看，别担心！栈溢出会导致程序崩溃，但不会损坏你的电脑。）
下面是一个简单的程序，向你展示一个很小的函数要递归调用多少次才会耗光栈空间。
（函数的栈帧越大，能进行的递归调用次数就越少。不过，如果基线条件编写正确，这种极限情况基本不会发生。）
#include <iostream>

using namespace std;

void recurse (int count)
{
    cout << count << "\n";
    recurse( count + 1 );
}

int main ()
{
    recurse( 1 );
}
16.4.3 调试栈溢出
当你尝试调试栈溢出时，最重要的是找出是哪个函数（或哪组函数） 在不断地增加栈帧。
例如，如果使用的是调试器（将在第20章讲 到），当程序最终崩溃时，你会看到上述例子中栈变成了类似如下的样子：
recurse( 10000 );
recurse( 9999 );
recurse( 9998 );
...
recurse( 1 )
main()
这种情况很容易分析，因为只有一个函数被调用。显然，这个函数缺失了某种基线条件。
有时候，会出现两个函数相互递归调用的情况。
再次以阶乘为例。这是一个人为的例子，我们使用两个函数来计算阶乘：一个用于计算偶数的，一个计算奇数的：
int factorial_odd (int x)
{
    if ( x <= 0 )
    {
        return 1;
    }
    return x * factorial_even( x C 1 );
}

int factorial_even (int x)
{
    if ( x <= 0 )
    {
        return 1;
    }
    return x * factorial_odd( x C 1 );
}

int factorial (int x)
{
    if ( x % 2 == 0 )
    {
        return factorial_even( x );
    }
    else
    {
        return factorial_odd( x );
    }
}

当你调试复杂的递归调用时，通过查看栈有助于发现不断重复的一系列函数，在这个例子中，只有factorial_even和factorial_odd。
但在某些情况下，重复的函数调用之间的时间间隔可能非常长。你必须找到整个重复的函数集合，然后揪出这些函数重复调用的原因。
16.4.4 性能
递归需要做许多函数调用，每个函数调用都需要设置一个栈帧，并传递参数，
这些都增加了时间开销，而这些开销在循环中并没有。
在绝大多数情况下，现代计算机中这些开销的影响并不显著。
但如果你的代码会频繁地执行（比如短时间内执行百万次甚至上亿次），你就必须关注函数调用的性能问题了。
16.5 盘点递归
递归使得我们能够创建出这类算法：将问题分解成更小版本的相同问题，从而解决原问题。
递归比循环更强大的地方还在于，递归函数维持着一个保存每次递归调用当前状态的栈，允许函数获得子问题的结果后继续处理。
算法的递归实现通常比等效的循环实现更加自然。下一章，我们会看到更多这样的例子，涵盖了二叉树的内容。
当你开发更多的代码时， 会发现使用递归比仅使用循环，更容易考虑更大范围的问题。
下面是一些何时使用递归或循环的经验法则。
适合用递归的情况：
1.问题的解决需要将问题分解成相同问题的较小版本，且存在一个明显能用循环来实现的方案；
2.你正在处理的数据结构是递归的（比如链表）。
适合用循环的情况：
1.很明显能用一个简单的循环来解决问题（例如，要将一串数字相加，你当然可以写一个递归函数，但这不值得）；
2.正在处理的数据结构使用数字进行索引时，如数组。
问答题
1.下列哪种情况是尾递归？
A.当你呼唤自己的狗时
B.当一个函数调用自身时
C.当一个递归函数所作的最后一件事是调用自身时
D.当你可以将一个递归算法改写成循环算法时

C
2.何种情况下适合使用递归？
A.当你不能使用循环来实现算法时
B.当从子问题角度要比从循环角度能更自然地表达一个算法时
C.永远不要，真的，它太难了
D.在使用数组和链表时

B
3.一个递归算法需要满足什么要素？
A.基线条件和递归调用
B.基线条件和将问题分解成问题本身的更小版本的方式
C.重组问题的较小版本的方式
D.以上皆是

D
4.当基线条件不完整时，会发生什么？
A.该算法可能提前完成
B.编译器将检测到这个问题并报错
C.这是没有问题的
D.可能会发生栈溢出

D
实践题
1.写一个递归函数来计算幂函数：pow(x, y) = x^y。

#include<iostream>

using namespace std;

int pow(int x, int y)
{
    if (y <= 0)
    {
        return 1;
    }
    else if (y == 1)
    {
        return x;
    }
    else
    {
        return x * pow(x, y - 1);
    }
}

int main()
{
    cout << "Let's calculate x^y\n";

    int x = 0;
    do
    {
        cout << "Enter a positive value for x: ";
        cin >> x;
    }
    while (x < 1);
    cin.clear();
    cin.ignore(80, '\n');

    int y = 0;
    do
    {
        cout << "Enter a positive value for y: ";
        cin >> y;
    }
    while (y < 1);
    cin.clear();
    cin.ignore(80, '\n');

    int result = pow(x, y);
    cout << "x^y = " << x << "^" << y << " = " << result << '\n';
}
显示结果如下
Let's calculate x^y
Enter a positive value for x: 3
Enter a positive value for y: 8
x^y = 3^8 = 6561

2.写一个递归函数，它接受一个数组，并以相反的顺序显示出数组元素。

#include <iostream>
#include <string>

using namespace std;

void printArrayItem(string item, int index);
void printArrayItemsReverse(string array[], int index, int arraySize);

int main()
{
    cout << "Creating array...\n\n";
    const int arraySize = 10;
    string array[arraySize];
    array[0] = "Happy";
    array[1] = "Go";
    array[2] = "Lucky";
    array[3] = "Doggy";
    array[4] = "Do";
    array[5] = "Foo";
    array[6] = "Bar";
    array[7] = "Minnie";
    array[8] = "Minie";
    array[9] = "Moe";

    cout << "Printing Array in order:\n";
    for (int i = 0; i < arraySize; i++)
    {
        printArrayItem(array[i], i);
    }
    cout << "\n\n";

    cout << "Printing Array in reverse order:\n";
    printArrayItemsReverse(array, 0, arraySize);
}

void printArrayItemsReverse(string array[], int index, int arraySize)
{
    if (index < 0)
    {
        return;
    }
    if (index < (arraySize - 1))
    {
        printArrayItemsReverse(array, index + 1, arraySize);
    }
    printArrayItem(array[index], index);
}

void printArrayItem(string item, int index)
{
    cout << "Array Item " << index << ": " << item << '\n';
}
显示结果如下
Creating array...

Printing Array in order:
Array Item 0: Happy
Array Item 1: Go
Array Item 2: Lucky
Array Item 3: Doggy
Array Item 4: Do
Array Item 5: Foo
Array Item 6: Bar
Array Item 7: Minnie
Array Item 8: Minie
Array Item 9: Moe


Printing Array in reverse order:
Array Item 9: Moe
Array Item 8: Minie
Array Item 7: Minnie
Array Item 6: Bar
Array Item 5: Foo
Array Item 4: Do
Array Item 3: Doggy
Array Item 2: Lucky
Array Item 1: Go
Array Item 0: Happy

3.写一个递归算法，从一个链表中删除元素；写一个递归算法，将元素添加到链表中。

#include <iostream>
#include <string>

using namespace std;

struct Item
{
    string name;
    Item *next;
    Item *previous;
};

Item *addToLinkedList(Item *p_list, string name);
Item *createLinkedList(string names[], int namesSize);
Item *createLinkedListRecursive(string names[], int namesSize, int nameIndex);
Item *removeCurrentFromLinkedList(Item *p_list, Item *p_current);
Item *removeFromLinkedList(Item *p_list, string name);
void removeFromLinkedListRecursive(Item *p_list, string name, Item **p_head);
void printList(Item *p_list);

int main()
{
    const int namesSize = 10;
    string names[namesSize];
    names[0] = "Sam";
    names[1] = "Sally";
    names[2] = "Sue";
    names[3] = "Mark";
    names[4] = "Phil";
    names[5] = "Brenton";
    names[6] = "Melissa";
    names[7] = "Charles";
    names[8] = "Quigly";
    names[9] = "Foo";


    cout << "Create linked list of " << namesSize << " items with a loop...\n";
    Item *p_items = createLinkedList(names, namesSize);
    printList(p_items);

    int const indexRemove = 5;
    cout << "Removing item " << indexRemove << ": " << names[indexRemove] << " from linked list with a loop...\n";
    p_items = removeFromLinkedList(p_items, names[indexRemove]);
    printList(p_items);

    if (p_items != nullptr)
    {
        Item *p_current = p_items;
        Item *p_next;
        while (p_current != nullptr)
        {
            p_next = p_current->next;
            delete p_current;
            p_current = p_next;
        }
    }

    cout << "Create linked list of " << namesSize << " items with a recursion...\n";
    Item *p_itemsRecursion = createLinkedListRecursive(names, namesSize, namesSize - 1);
    printList(p_itemsRecursion);

    cout << "Removing item " << indexRemove << ": " << names[indexRemove] << " from linked list with a recursion...\n";
    removeFromLinkedListRecursive(p_itemsRecursion, names[indexRemove], &p_itemsRecursion);
    printList(p_itemsRecursion);

    if (p_itemsRecursion != nullptr)
    {
        Item *p_current = p_itemsRecursion;
        Item *p_next;
        while (p_current != nullptr)
        {
            p_next = p_current->next;
            delete p_current;
            p_current = p_next;
        }
    }
}


Item *createLinkedList(string names[], int namesSize)
{
    Item *p_items = nullptr;
    for (int i = 0; i < namesSize; i++)
    {
        p_items = addToLinkedList(p_items, names[i]);
    }
    return p_items;
}

Item *createLinkedListRecursive(string names[], int namesSize, int nameIndex)
{
    Item *p_items = nullptr;
    if (nameIndex > 0 && nameIndex < namesSize)
    {
        p_items = createLinkedListRecursive(names, namesSize, nameIndex - 1);
    }

    if(nameIndex >= 0 && nameIndex < namesSize)
    {
        p_items = addToLinkedList(p_items, names[nameIndex]);
    }

    return p_items;
}

Item *addToLinkedList(Item *p_list, string name)
{
    Item *p_item = new Item;
    p_item->name = name;
    p_item->previous = nullptr;
    p_item->next = p_list;
    if (p_list != nullptr)
    {
        p_list->previous = p_item;
    }
    return p_item;
}

Item *removeFromLinkedList(Item *p_list, string name)
{
    Item *p_current = p_list;
    while (p_current != nullptr)
    {
        if (p_current->name == name)
        {
            return removeCurrentFromLinkedList(p_list, p_current);
        }
        p_current = p_current->next;
    }
    return p_list;
}
void removeFromLinkedListRecursive(Item *p_list, string name, Item **p_head)
{
    Item *p_current = p_list;
    if(p_current != nullptr)
    {
        if (p_current->name == name)
        {
            *p_head = removeCurrentFromLinkedList(*p_head, p_current);
            return;
        }
        removeFromLinkedListRecursive(p_current->next, name, p_head);
    }
}
Item *removeCurrentFromLinkedList(Item *p_list, Item *p_current)
{
    Item *p_previous = p_current->previous;
    Item *p_next = p_current->next;

    if (p_current == p_list)
    {
        if (p_next != nullptr)
       {
            p_next->previous = p_previous;
        }
        delete p_current;
        return p_next;
    }
    else
    {
        p_previous->next = p_next;
        if (p_next != nullptr)
       {
            p_next->previous = p_previous;
        }
        delete p_current;
        return p_list;
    }
}
void printList(Item *p_list)
{
    cout << "Printing the list...\n";

    Item *p_current = p_list;
    while (p_current != nullptr)
    {
        cout << "Item Name: " << p_current->name << '\n';
        p_current = p_current->next;
    }
    cout << '\n';
}
显示结果如下
Create linked list of 10 items with a loop...
Printing the list...
Item Name: Foo
Item Name: Quigly
Item Name: Charles
Item Name: Melissa
Item Name: Brenton
Item Name: Phil
Item Name: Mark
Item Name: Sue
Item Name: Sally
Item Name: Sam

Removing item 5: Brenton from linked list with a loop...
Printing the list...
Item Name: Foo
Item Name: Quigly
Item Name: Charles
Item Name: Melissa
Item Name: Phil
Item Name: Mark
Item Name: Sue
Item Name: Sally
Item Name: Sam

Create linked list of 10 items with a recursion...
Printing the list...
Item Name: Foo
Item Name: Quigly
Item Name: Charles
Item Name: Melissa
Item Name: Brenton
Item Name: Phil
Item Name: Mark
Item Name: Sue
Item Name: Sally
Item Name: Sam

Removing item 5: Brenton from linked list with a recursion...
Printing the list...
Item Name: Foo
Item Name: Quigly
Item Name: Charles
Item Name: Melissa
Item Name: Phil
Item Name: Mark
Item Name: Sue
Item Name: Sally
Item Name: Sam

4.写一个递归函数，它接受一个排好序的数组和一个目标元素，在数组中查找目标元素，返回目标元素在数组中的索引。
如果目标元素不在数组中的话，返回-1。

#include <iostream>
#include <string>

using namespace std;

int findArrayIndex(string itemToFind, string array[], int arraySize, int currentIndex)
{
    if (currentIndex < 0 || currentIndex >= arraySize)
    {
        return -1;
    }
    if (array[currentIndex] == itemToFind)
    {
        return currentIndex;
    }
    return findArrayIndex(itemToFind, array, arraySize, currentIndex - 1);
}

void printArray(string sortedArray[], int arraySize)
{
    for (int i = 0; i < arraySize; i++)
    {
        cout << "Index " << i << ": " << sortedArray[i] << '\n';
    }
    cout << '\n';
}

int main()
{
    const int arraySize = 10;
    cout << "Creating sorted array of " << arraySize << " elements.\n\n";
    string sortedArray[arraySize];
    sortedArray[0] = "Alpha";
    sortedArray[1] = "Beta";
    sortedArray[2] = "Charlie";
    sortedArray[3] = "Echo";
    sortedArray[4] = "Frank";
    sortedArray[5] = "Mark";
    sortedArray[6] = "Omega";
    sortedArray[7] = "Sally";
    sortedArray[8] = "Tango";
    sortedArray[9] = "Zeta";
    printArray(sortedArray, arraySize);

    const int arrayIndexFind = 6;
    cout << "Finding the index for item " << sortedArray[arrayIndexFind] << " in the sorted array...\n\n";

    int arrayIndex = findArrayIndex(sortedArray[arrayIndexFind], sortedArray, arraySize, arraySize - 1);
    cout << "The index found is " << arrayIndex << " while " << arrayIndexFind << " is the correct answer.\n\n";

    string nonExistingItem = "Slimer";
    cout << "Finding the index for non-existing item " << nonExistingItem << " in the sorted array...\n\n";

    int arrayIndexNonExisting = findArrayIndex(nonExistingItem, sortedArray, arraySize, arraySize - 1);
    cout << "The index found is " << arrayIndexNonExisting << " while " << -1 << " is the correct answer.\n\n";
}
显示结果如下
Creating sorted array of 10 elements.

Index 0: Alpha
Index 1: Beta
Index 2: Charlie
Index 3: Echo
Index 4: Frank
Index 5: Mark
Index 6: Omega
Index 7: Sally
Index 8: Tango
Index 9: Zeta

Finding the index for item Omega in the sorted array...

The index found is 6 while 6 is the correct answer.

Finding the index for non-existing item Slimer in the sorted array...

The index found is -1 while -1 is the correct answer.

5.写一个递归函数来解决汉诺塔问题。

#include <iostream>
#include <string>

using namespace std;

struct Disc
{
    int size = 0;
    Disc *next = nullptr;
    Disc *previous = nullptr;
};

Disc *getSmallestDisk(Disc *p_list);
int getSmallestDiskSize(Disc *p_list, Disc **p_smallest);

Disc *addNewToLinkedList(Disc *p_list, int size);
Disc *addToLinkedListBeginning(Disc *head, Disc *node);
Disc *addToLinkedListEnd(Disc *head, Disc *node);
Disc *removeFromLinkedList(Disc *p_list, Disc *p_item);

struct Discs
{
    Disc *head = nullptr;

    Disc *pop()
    {
        Disc *smallestDisk = getSmallestDisk(head);
        head = removeFromLinkedList(head, smallestDisk);
        return smallestDisk;
    }

    void push(Disc *disc)
    {
        head = addToLinkedListBeginning(head, disc);
    }
};

Discs *generatePegA(int size);
void moveDisc(int discSize, Discs *source, Discs *target, Discs *auxiliary);

void printList(Discs *p_list);
void printAllLists(Discs *pegA, Discs *pegB, Discs *pegC);

Discs *pegA;
Discs *pegB;
Discs *pegC;
int iteration = 0;

int main()
{
    const int minDiscSize = 2;
    int maxDiscSize = minDiscSize;
    do
    {
        cout << "Please enter the maximum disk size: ";
        cin >> maxDiscSize;
    }
    while (maxDiscSize < minDiscSize);

    pegA = generatePegA(maxDiscSize);
    pegB = new Discs;
    pegC = new Discs;

    printAllLists(pegA, pegB, pegC);

    cout << '\n';
    cout << "Solving the Tower of Hanoi Problem using recursion.\n\n";
    moveDisc(maxDiscSize, pegA, pegC, pegB);

    if (pegA->head != nullptr)
    {
        Disc *p_current = pegA->head;
        Disc *p_next;
        while (p_current != nullptr)
        {
            p_next = p_current->next;
            delete p_current;
            p_current = p_next;
        }
    }
    delete pegA;

    if (pegB->head != nullptr)
    {
        Disc *p_current = pegB->head;
        Disc *p_next;
        while (p_current != nullptr)
        {
            p_next = p_current->next;
            delete p_current;
            p_current = p_next;
        }
    }
    delete pegB;

    if (pegC->head != nullptr)
    {
        Disc *p_current = pegC->head;
        Disc *p_next;
        while (p_current != nullptr)
        {
            p_next = p_current->next;
            delete p_current;
            p_current = p_next;
        }
    }
    delete pegC;
}

Discs *generatePegA(int size)
{
    Disc *p_items = nullptr;
    for (int i = 1; i <= size; i++)
    {
        p_items = addNewToLinkedList(p_items, i);
    }

    Discs *pegA = new Discs;
    pegA->head = p_items;
    return pegA;
}

void moveDisc(int discSize, Discs *source, Discs *target, Discs *auxiliary)
{
    if (discSize > 0)
    {
        moveDisc(discSize - 1, source, auxiliary, target);

        target->push(source->pop());

        cout << "Iteration " << ++iteration;
        printAllLists(pegA, pegB, pegC);

        moveDisc(discSize - 1, auxiliary, target, source);
    }
}
Disc *getSmallestDisk(Disc *p_list)
{
    Disc *p_smallest = nullptr;

    getSmallestDiskSize(p_list, &p_smallest);

    return p_smallest;
}
int getSmallestDiskSize(Disc *p_list, Disc **p_smallest)
{
    Disc *p_current = p_list;
    Disc *p_temp;

    int minSize = p_current->size;
    p_temp = p_current;
    while (p_current != nullptr)
    {
        if (p_current->size < minSize)
        {
            minSize = p_current->size;
            p_temp = p_current;
        }
        p_current = p_current->next;
    }
    if (p_smallest != nullptr)
    {
        *p_smallest = p_temp;
    }
    return minSize;
}
Disc *addNewToLinkedList(Disc *p_list, int size)
{
    Disc *p_item = new Disc;
    p_item->size = size;

    return addToLinkedListEnd(p_list, p_item);
}
Disc *addToLinkedListEnd(Disc *head, Disc *node)
{
    if (head == nullptr)
    {
        node->previous = head;
        node->next = nullptr;
        return node;
    }
    else
    {
        Disc *temp = head;

        while (temp->next != nullptr)
        {
            temp = temp->next;
        }

        temp->next = node;
        node->previous = temp;
        node->next = nullptr;
        return head;
    }
}
Disc *addToLinkedListBeginning(Disc *head, Disc *node)
{
    if (head == nullptr)
    {
        node->previous = nullptr;
        node->next = head;
        return node;
    }
    else
    {
        Disc *temp = head;
        node->previous = nullptr;
        node->next = temp;
        temp->previous = node;
        return node;
    }
}
Disc *removeFromLinkedList(Disc *p_list, Disc *p_item)
{
    Disc *p_next = p_item->next;
    Disc *p_previous = p_item->previous;
    p_item->next = nullptr;
    p_item->previous = nullptr;

    if (p_next == nullptr && p_previous == nullptr)
    {
        return nullptr;
    }

    if ( p_next != nullptr && p_previous == nullptr )
    {
        p_next->previous = p_previous;
        return p_next;
    }

    if (p_next == nullptr && p_previous != nullptr)
    {
        p_previous->next = p_next;
    }
    else if (p_next != nullptr && p_previous != nullptr)
    {
        p_previous->next = p_next;
        p_next->previous = p_previous;
    }

    while (p_previous->previous != nullptr)
    {
        p_previous = p_previous->previous;
    }

    return p_previous;
}
void printAllLists(Discs *pegA, Discs *pegB, Discs *pegC)
{
    cout << '\n';
    cout << "Peg A:\n";
    printList(pegA);
    cout << '\n';

    cout << "Peg B:\n";
    printList(pegB);
    cout << '\n';

    cout << "Peg C:\n";
    printList(pegC);
    cout << '\n';
}
void printList(Discs *p_list)
{
    if (p_list == nullptr || p_list->head == nullptr)
    {
        cout << "Disk peg is empty.\n";
        return;
    }

    cout << "Printing the list...\n";
    Disc *p_current = p_list->head;
    while (p_current != nullptr)
    {
        cout << "Disk Size: " << p_current->size << '\n';
        p_current = p_current->next;
    }
    cout << '\n';
}
显示结果如下
Please enter the maximum disk size: 3

Peg A:
Printing the list...
Disk Size: 1
Disk Size: 2
Disk Size: 3


Peg B:
Disk peg is empty.

Peg C:
Disk peg is empty.


Solving the Tower of Hanoi Problem using recursion.

Iteration 1
Peg A:
Printing the list...
Disk Size: 2
Disk Size: 3


Peg B:
Disk peg is empty.

Peg C:
Printing the list...
Disk Size: 1


Iteration 2
Peg A:
Printing the list...
Disk Size: 3


Peg B:
Printing the list...
Disk Size: 2


Peg C:
Printing the list...
Disk Size: 1


Iteration 3
Peg A:
Printing the list...
Disk Size: 3


Peg B:
Printing the list...
Disk Size: 1
Disk Size: 2


Peg C:
Disk peg is empty.

Iteration 4
Peg A:
Disk peg is empty.

Peg B:
Printing the list...
Disk Size: 1
Disk Size: 2


Peg C:
Printing the list...
Disk Size: 3


Iteration 5
Peg A:
Printing the list...
Disk Size: 1


Peg B:
Printing the list...
Disk Size: 2


Peg C:
Printing the list...
Disk Size: 3


Iteration 6
Peg A:
Printing the list...
Disk Size: 1


Peg B:
Disk peg is empty.

Peg C:
Printing the list...
Disk Size: 2
Disk Size: 3


Iteration 7
Peg A:
Disk peg is empty.

Peg B:
Disk peg is empty.

Peg C:
Printing the list...
Disk Size: 1
Disk Size: 2
Disk Size: 3

第17章 二叉树
注意：本章我要介绍一个有趣而实用的基本数据结构――二叉 树。
二叉树是一个使用递归和指针的最完美例子，我们可以用它来做一些惊人的工作。
不过，开启二叉树的学习之旅前，你需要切实理解递归和链表的基本概念。
何出此言呢？我见过不止一个学生敷衍地看了下指针和链表，就匆匆进入二叉树的泥潭中苦苦挣扎。
二叉树本身没什么难的，理解它并不困难，但这建立在你有一个坚实的基础之上。
如果你对本章的概念理解上有困难，那就需要更深入地学习指针和递归――请重读之前几章并完成练习。
链表是一个伟大的技术，很适合进行列表操作，但在链表中查找一个特定元素可能会花费大量时间。
此外，哪怕用数组来存储，如果列表中的数据特别多，想查找一个特定元素也同样非常耗时。
或许你可以试试对数组进行排序，这样就能实现快速搜索。
但是，在数组中插入新元素就会变得很困难――如果要保持数组的排序，那么每次插入新元素时都要移动很多的元素。
另外，快速地查找到东西是很重要的， 举几个例子。
1.如果你正在创建一个《魔兽世界》那样的游戏（大型多人在线角色扮演游戏 ) ，要让玩家能够快速登录游戏，
就必须能够迅速查找玩家。
2.如果你正在编写信用卡处理软件，它需要支持每小时处理数以百万计的交易，就要求能够迅速地找到一个信用卡号码的账户余额。
3.如果你正在给智能手机那样的低功率设备写软件，需要将地址簿显示给用户，
又不希望用户因为你使用了一个缓慢的数据结构而苦苦等待。
本章将会介绍解决以上问题（但不仅限于这些问题 ) 所需要的工具。
解决此类问题的基本思路是，将元素存储在类似链表的结构中――也就是说，使用指针指向结构体类型的内存，
就像我们在链表中做的一样――但要以一种更容易搜索数值的方式。
为此，我们需要在内存中存储更精巧的结构化数据，而不仅仅是一个简单的列表。
来看看结构化的数据到底是什么。刚开始时，你只会使用数组，数组仅仅是一个顺序列表，没有能力来提供其他任何数据结构。
链表使用指针来逐步构建一个顺序列表，但它没有利用指针所具有的灵活性来构建更精巧的数据结构。
所谓的“更精巧的数据结构”指什么呢？首先，可以构建一个数据结构，它能够同时拥有不止一个“下一个节点”。
为什么要这么做呢？如果你有两个“下一个节点”，其中一个代表比当前元素小的元素，另一个代表比当前元素大的元素，
这种数据结构就称为二叉树。之所以如此命名，是因为在二叉树中，每个节点最多有两个分支。
这里的“下一个节点”称为子节点，指向一个子节点的节点称为该子节点的父节点。
一棵二叉树如下所示： 
                                                      10
                           6                                                      14
         5                           8                           11                           18
注意，在这棵树中，每个元素的左子节点都是一个比该元素小的值， 而每个元素的右子节点比该元素大。
节点10是整棵树的父节点。它的两个子节点，节点6和节点14，分别是自己衍生出的小二叉树的父节点。这些小二叉树称为子树。
二叉树的一个重要特性是，一个节点的每个子节点本身就是一棵完整的二叉树。
这一特征，结合上“左子节点比当前节点小，右子节点比当前节点大”这一规则，使得寻找一棵树中的某个节点的算法设计起来很容易。
首先，查看当前节点的值，如果它等于搜索目标，则搜索结束，大功告成；
如果搜索目标小于当前节点的值，你往左边的树中找；否则，到右边的树去找。
这个算法能够有效，主要因为左子树中的每个节点都小于当前节点，而右子树中的每个节点都大于当前节点。
最理想的二叉树是平衡树，即左子树与右子树的节点数量相同。对于一棵平衡树来说，每个子树是整棵树的一半大小，
如果你正在查找树中的某个值，每到一个子节点，你的搜索就可以排除掉一半的元素。 
所以，如果有一棵1000个元素的平衡树，你可以立即砍掉500个元 素。搜索就减少到在一棵500个元素的子树中进行。
对一棵500个元素 的树进行搜索，我们再次可以砍掉大约一半的元素，约250个。
继续这样每到一个节点就排除掉一半的元素，不用多久就能找到想要找的元素。
总共需要多少次拆分树的操作才能到达只有一个节点的树呢？ 答案是n以2为底的对数，log2 (n)，其中n为整棵树的节点数量。
这个值很小，即使对于非常大的树（对于一棵约有40亿个元素的树，log2 (n)为32，
这意味着，其搜索速度比对同等大小的链表进行同样的搜索要快近1亿倍，因为在链表中你必须要逐个地查看每个元素 ) 。
然而，如果这棵树不平衡， 可能就不能每次砍去树的一半元素。在最坏情况下，每个节点只有一个子节点，
也就是说这棵树本质上是一个链表，只是比普通的链表多了一些额外的指针，那么其搜索过程就会退化到要遍历全部的n个元素。
如你所见，当一棵树大致平衡时（没有必要一定要完全平衡 ) ，搜索节点的速度要远远快于在链表中的搜索。
这一切归根结底是因为我们可以根据自己的喜好来结构化内存，而不是止步于简单的列表。
此处讨论的基本二叉树，只有极少数情况下会最终与链表结构相同，这取决于节点的插入顺序。
还有更复杂的二叉树类型，它们总是迫使树适当的平衡，此种数据结构称为红黑树，但这超出了本书的讲述范围。
谈谈“树”
为了便于理解二叉树的示例代码，我们需要一种简便的方式来指代“树”的不同部分，因此要建立一些基本的规约来绘制和指代一棵“树”。
最基本的“树”是空树，用nullptr来表示。当我画“树”的示意图时，将不画出到空树的链接。
每当想提及一个特定的子树，我会说“<根为 [根节点的值] 的树>”。例如，在这棵树中：
                                                      10
                           6                                                      14
         5                           8                           11                           18
<根为6的树>指代的就是这个子树：
                           6
         5                           8
实现二叉树
让我们来看看简单实现一个二叉树所需的代码。首先，我们声明一个节点结构体：
struct node
{
    int key_value;
    node *p_left;
    node *p_right;
};
我们的节点可以将key_value的值作为一个简单的整数值存储下来，并且包含两个子树，分别是p_left和p_right。
这几个是你会在二叉树上执行的常用函数：插入节点到树中，搜索树中的某个值，从树中删除某个节点，删除整棵树以释放内存。
node *insert (node *p_tree, int key);
node *search (node *p_tree, int key);
void destroyTree (node *p_tree);
node *remove (node *p_tree, int key);
在树中插入新节点
首先学习使用递归算法来实现树节点的插入。递归算法能用在树上， 是因为每棵树都包含两棵更小的树，
所以整个数据结构本身就是递归的。（假设每棵树都包含一个数组或是一个指向链表的指针，那么这种数据结构就不是递归的了。 )
函数接受一个key值和一棵已存在的树（可能为空 ) ，返回包含此插入值的新树。
node *insert (node *p_tree, int key)
{
    if ( p_tree == nullptr )
    {
        node *p_new_tree = new node;
        p_new_tree->p_left = nullptr;
        p_new_tree->p_right = nullptr;
        p_new_tree->key_value = key;
        return p_new_tree;
    }
    if( key < p_tree->key_value )
    {
        p_tree->p_left = insert( p_tree->p_left, key );
    }
    else
    {
        p_tree->p_right = insert( p_tree->p_right, key );

    }
    return p_tree;
}
此算法的基本逻辑是：如果当前拥有的是一棵空树，那就创建一棵新的树。
若非空树，那么如果要插入的值小于当前节点，就将其插入左子树中，并用新创建的子树替换原来的左子树；
否则就将新节点插入右子树中，并做同样的替换。
让我们在实例中看看这段代码――将一棵空树构建成有两个节点的树。
如果将值10插入一棵空树（nullptr ) 中，立即达到了基线条件，其结果是一棵非常简单的树：
10
这棵树的两个子树都指向了nullptr。
如果再将值5插入到树中，将调用函数：
insert( <根为10的树>, 5 )
由于5比10小，我们将对左子树进行递归调用：
insert( nullptr, 5 )
insert( <根为10的树>, 5 )
函数insert( nullptr, 5 )将创建一棵新的树，并将它返回：
5
当函数insert( <根为10的树>, 5 )收到返回的树时，会将两棵树链接到一起。
在这种情况下，根为10的树的左子树原本为nullptr，被替换后就变成了一棵全新的树。
                           10
                  5
如果我们接着在树中插入7，将递归调用：
insert( nullptr, 7 )  
insert( <根为5的树>, 7 ) 
insert( <根为10的树>, 7 )
首先，insert( nullptr, 7 )返回一棵新树：
7
然后，insert( <根为5的树>, 7 )将根为7的新子树链接起来，就像这样：
5
         7
最后，这颗树被返回给insert( <根为10的树>, 7 )，并在insert( <根为10的树>, 7 )中被链接起来：
                  10
5
         7
由于节点10已经有一个指针指向了节点5，重新再链接节点10的左子树到根为5的树这一步骤并不是必需的，
但这么做省去了在代码中检查左子树是否为空这一额外的条件检查。
在树中搜索
现在，来看看如何实现在树中进行搜索，其基本逻辑与在树中插入新节点的算法几乎完全一样：
首先，检查两个基线条件（是否发现目标节点，或是否到达了一个空树 ) ；
如果基线条件不满足，就确定应该去哪个子树中搜索。
node *search (node *p_tree, int key)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    else if ( key == p_tree->key_value )
    {
        return p_tree;
    }
    else if ( key < p_tree->key_value )
    {
        return search( p_tree->p_left, key );
    }
    else
    {
        return search( p_tree->p_right, key );
    }
}
上面的search函数首先检查两个基线条件：是否到达树的分支末端或是否找到了值key。
无论哪种情况，我们都知道应该返回什么：如果到达树的分支末端，就返回nullptr；如果找到了key值，就返回这棵树本身。
如果基线条件不满足，我们就在子树中找key值，从而减小了问题。在左子树还是在右子树中查找，取决于key的值。
请注意，每次递归调用，树的大小正如本章开头所讲――约减少了一半。
在本章开头，我 们还看到，在一棵平衡二叉树中搜索所花费的时间正比于log2 (n)，
当数据量很大时，这远比通过链表或数组进行搜索要快得多。
删除树
destroy_tree函数也应该是递归的。该算法将先删除当前节点的两个子 树，然后再删除当前节点。
void destroy_tree (node *p_tree)
{
    if ( p_tree != nullptr )
    {
        destroy_tree( p_tree->p_left );
        destroy_tree( p_tree->p_right );
        delete p_tree;
    }
}
为了帮助理解整个递归调用过程，你可以在删除节点前输出节点的值：
void destroy_tree (node *p_tree)
{
    if ( p_tree != nullptr )
    {
        destroy_tree( p_tree->p_left );
        destroy_tree( p_tree->p_right );
        cout << "Deleting node: " << p_tree->key_value << '\n';
        delete p_tree;
    }
}
你会看到，树是“自下而上”被删除的。
                                                      10
                           6                                                      14
         5                           8                           11                           18
节点5和节点8首先被删除，接着是节点6；然后删除树的另一边，删除节点11和节点18，接着是节点14；
最后，当所有的子节点都被删除时，删除节点10。
树中的值并不重要，重要的是节点的位置。我在下面的二叉树中放置的是节点删除的顺序，而不是每个节点的值：
                                                      7
                           3                                                      6
         1                           2                           4                           5
手动运行代码时，这类型的图对于理解其删除过程相当有帮助，它使整个过程变得更加清晰。
删除树的递归算法就是一个递归算法难以用迭代实现的例子！你需要写出这样一个循环：它能以某种方式同时处理树的左支和右支！
也就是说，你需要能够在删除一棵子树的同时，跟踪到要删除的第二棵子树，并且得在树的每一层都要做到这一点。
栈可以用来记录你的位置。你可以这样可视化其过程，每个栈帧都有效地存储了树的哪一个分支已经被删除：
destroy_tree( <子树> )   知道这里的“子树”是左子树还是右子树
destroy_tree( <树> )
每个栈帧通过函数将要继续执行的位置，来获知树的哪个部分需要删除。
第一次调用destroy_tree时，栈帧告诉程序继续执行第二次。
第二次调用destroy_tree时，栈帧告诉程序继续删除树。
由于每次函数调用都有自己的栈帧，所以它跟踪了树被销毁的整个过程，每一层每一次它都有记录。
实现其非递归算法的唯一方式是，用一个数据结构来为我们保存相同数量的信息。
例如，你可以写一个模拟栈的函数，它维护着一个链表，在链表（模拟栈 ) 中记录正在销毁处理的子树。
子树的哪一边还未删除也在链表中记录着。接着，你可以写一个循环算法，将子树添加到链表中，
当子树被完全删除时，将其从列表中移除。换句话说， 递归可以利用内置的栈数据结构，而不必由你自己编写。
作为练习， 我建议你尝试完成destroy_tree的非递归实现。
你会看到，使用递归要比创建自己的栈更易于表达，从而对递归有更深的理解。
从树中删除节点
从二叉树中删除节点的算法就复杂多了。该算法的基本结构跟我们前面见过的模式差不多：
如果到达一棵空树，任务结束；
如果要删除的值在左子树中，到左子树中搜索并删除该值；
如果在右子树中，则到 右子树中搜索删除；
如果找到了这个值，将其删除。
node *remove (node *p_tree, int key)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->key_value == key )
    {
        // 这里要怎么做
    }
    else if ( key < p_tree->key_value )
    {
        p_tree->left = remove( p_tree->left, key);
        return p_tree;
    }
    else
    {
        p_tree->right = remove( p_tree->right, key);
        return p_tree;
    }
}
但这个看似完美的操作中隐藏的一个麻烦问题在于其中的一个基线条件。
当你真正找到了要删除的值时，究竟需要做些什么呢？别忘了， 二叉树要始终满足下列条件：
当前节点的左子树中的每个值都必须小于当前节点的值；当前节点的右子树中的每个值必须大于当前节点的值。
有三个基线条件需要考虑：
1.被删除的节点没有子节点；
2.被删除的节点只有一个子节点；
3.被删除的节点有两个子节点。
情况1最容易处理：如果要删除的节点没有任何子节点，返回nullptr即可；
情况2也不难：如果只有一个子节点，将该子节点返回；但是情况3就复杂多了。
我们不能随便选一个子节点提升上来，然后自以为万事大吉。
例如， 如果我们选择提升左子节点来替代要删除的元素，会怎样呢？
如果这么做，该节点的右边元素会发生什么？考虑下早期时候用过的这个例子：
                                                      10
                           6                                                      14
         5                           8                           11                           18
如果要删除的元素是节点10，该怎么办呢？不能只是提升元素6来替换10，因为这样会破坏二叉树的性质。
类似地，我们不能仅是提升右子节点。
二叉树要始终满足下列条件：
当前节点的左子树中的每个值都必须小于当前节点的值；当前节点的右子树中的每个值必须大于当前节点的值。
在二叉树中， 究竟提升哪个节点，需要慎之又慎。
所以，怎么办呢？既然一个节点的左边所有节点的值一定小于该节点的值，
那么，为什么不找出要删除的节点左边的所有节点中最大的值，并把它提升到这棵树的顶端呢？
由于它是这棵树左侧的最大值， 用它来替换当前节点是绝对安全的。
既保证了该节点比其左侧的其他节点都大，同时由于它本来就在这棵树的左侧，也肯定小于其右侧的每个节点。
同理，你也可以选择这棵树右侧值最小的节点。在实践中，一个好的算法不会始终选择同一个方向，否则会产生不平衡树。
但为了简便起见，我们将忽视这个随机化过程，而使用比较简单的版本。
在刚才的例子中，由于8是节点10左侧最大的值，最终的树会是这样：
                                      6
                  5                                       8
                                                                                   14
                                                                  11                           18
或者
                                                      8
                           6                                                      14
         5                                                       11                           18
为此，我们需要一个算法来找出一棵树左侧存储的最大值， 即find_max函数。
我们可以利用“更大的值总是出现在子树右侧”这一性质，来实现find_max函数。
因此可以沿着一棵树的右分支往下走，直到抵达nullptr为止。
换句话说，对于find_max函数而言，它接受一棵树，返回这棵树中的最大值。
我们可以把这棵树的所有右指针看做构成了一个链表：
node *find_max (node *p_tree)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->p_right == nullptr )
    {
        return p_tree;
    }
    else
    {
        return find_max( p_tree->p_right );
    }
}
node *remove_max_node (node *p_tree, node *p_max_node)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree == p_max_node )
    {
        return p_max_node->p_left;
    }
    p_tree->p_right = remove_max_node( p_tree->p_right, p_max_node);
    return p_tree;
}
不调用remove_max_node，并且删除之后的树如下
                                      6
                  5                                       8
                                                                                   14
                                                                  11                           18
node *remove (node *p_tree, int key)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->key_value == key )
    {
        if ( p_tree->p_left == nullptr )
        {
            node *p_right_subtree = p_tree->p_right;
            delete p_tree;
            return p_right_subtree;
        }
        if ( p_tree->p_right == nullptr )
        {
            node *p_left_subtree = p_tree->p_left;
            delete p_tree;
            return p_left_subtree;
        }
        node *p_left_subtree = p_tree->p_left;
        node *p_right_subtree = p_tree->p_right;
        node *p_max_node = find_max( p_left_subtree );
        p_max_node->p_right = p_right_subtree;
        delete p_tree;
        return p_left_subtree;
    }
    else if ( key < p_tree->key_value )
    {
        p_tree->left = remove( p_tree->left, key);
        return p_tree;
    }
    else
    {
        p_tree->right = remove( p_tree->right, key);
        return p_tree;
    }
}
调用remove_max_node，并且删除之后的树如下
                                                      8
                           6                                                      14
         5                                                       11                           18
node *remove (node *p_tree, int key)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->key_value == key )
    {
        if ( p_tree->p_left == nullptr )
        {
            node *p_right_subtree = p_tree->p_right;
            delete p_tree;
            return p_right_subtree;
        }
        if ( p_tree->p_right == nullptr )
        {
            node *p_left_subtree = p_tree->p_left;
            delete p_tree;
            return p_left_subtree;
        }
        node *p_left_subtree = p_tree->p_left;
        node *p_right_subtree = p_tree->p_right;
        node *p_max_node = find_max( p_left_subtree );
        p_max_node->p_left = remove_max_node( p_tree->p_left, p_max_node );
        p_max_node->p_right = p_right_subtree;
        delete p_tree;
        return p_max_node;
    }
    else if ( key < p_tree->key_value )
    {
        p_tree->p_left = remove( p_tree->p_left, key);
        return p_tree;
    }
    else
    {
        p_tree->p_right = remove( p_tree->p_right, key);
        return p_tree;
    }
}
来看看这段代码在之前作为例子的树中是如何执行的：
如果我们打算从树中删除节点10，remove函数将立即到达“找到目标节点”这一基线条件。
它会发现节点10既有左子树也有右子树，因此，它会到根为6的子树中找到其中值最大的节点――节点8，
然后将节点8的左指针指向根为6的新树，这棵新树不包含节点8。
从子树中很容易删除节点8。我们从这棵子树开始说起：
                  6
         5                  8
第一次调用remove_max_node函数，发现节点6不是想要删除的节点，因此，对根为8的子树再次递归调用remove_max_node函数。
由于节点8正是想找的节点，我们返回节点8的左子树（nullptr ) ，从而节点6的右指针更改成了指向nullptr。这棵子树现在变成这样：
                  6
         5                  
在remove函数的调用中，我们现在收到了从remove_max_node返回的树 （如上所示 ) ，并将节点8的左指针设置成指向这棵树。
现在，新树成了这样：
                            8
                  6
         5                  
最后，节点8的右指针被设置成指向根为14的右子树。此刻，树彻底重建好了：
                                                      8
                           6                                                      14
         5                                                       11                           18
于是我们释放原来的节点10所占用的空间。
你可以从本章中找到全部的源代码。在文件binary_tree.cpp中，还有一个简单的程序包含了树的各种操作。
17.1 在现实世界中使用二叉树
尽管我已经谈了很多与快速搜索相关的知识，但你可能还会犯嘀咕： 从一个数据结构中找到一个特定值的速度有多快真的很重要吗？
电脑速度不是已经够快了吗？我究竟什么时候需要用到快速搜索呢？
通常在两种情况下，搜索速度至关重要。第一种情况是检查是否存在一个特定的值。
例如，如果你有一个游戏，它允许用户注册用户名， 那就需要能够检查当前用户注册的用户名是否已被占用。
如果这个游戏是魔兽世界那样的大型游戏，就要求即使有高达百万计的用户，检查速度也得非常快。
由于用户名实际上是字符串，而不是整型数，因此对用户名的检查占用的时间更长，因为你需要对比每个字母。
如果这种检查只做几次，你不会觉得用时很长；但如果总共要做超过百万次的比较，这个速度将慢到无法忍受。
因此，使用二叉树来存储用户名肯定会使注册体验更好。如果你希望用户玩你的游戏，肯定得让注册快捷一些。
另一种情况是，你有一些与所存储的值相关联的额外数据。这种数据结构称为映射（map ) 。
一个map中存储了一个键（key ) 和一个与之相关联的值（value ) 
（这个值不一定是单一的数据值，它可以是一个结构体，甚至你需要存储很多信息的话，它也可以是列表或另一个映射 ) 。
以魔兽世界这样的游戏为例。任何大型多人在线游戏都需要一个从用户名到其密码的一个映射，来处理用户登录或加载角色状态。
你每次以用户名和密码登录时，魔兽世界都会到map中查找你的用户名和对应的密码，比对用户输入的密码是否有效，
若有效则检索其他角色信息，让用户进入游戏。
在实践中，密码本身不会存储在map中，而是存储为散列版本。
散列是一种算法，以某种方式将一个文本字符串转换成另一个文本字符串 （或数字 ) ，使原来的值不可恢复。
在这种情况下，密码的散列版本使我们根本不可能得到原密码。
以散列形式存储密码，能够防止密码被通过盗看存储密码的文件或数据库泄露。
密码的散列算法保证了两个密码极不可能存储成相同的字符串。
我们可以使用二叉树来实现这样一个map。
在这一过程中，可以使用键作为二叉树的插入节点（此例中为用户名 ) ，在同一节点中存储它的值（此例中为密码 ) 。
map的概念在生活中随处可见。举一个范围更大的例子，比如信用卡公司也会用到某种形式的map。
你每次使用信用卡购物，你账户里就有一些信息需要更改。成千上万的人使用信用卡，如果对每一笔信用卡交易都要遍历一次全部信用卡号码，
整个世界的商业将陷入瘫痪。 因此，对于给定的信用卡号码，我们必须能够快速地查找到其账户余额。
要做到这一点，同样可以使用二叉树来构建每个信用卡号码到对应的账户余额之间的map。
这样的话，每一笔信用卡交易就是一次简单的二叉树节点搜索。找到之后再更新存储在该节点中的余额。
如果总共有100万个信用卡号码，用二叉树来存储它们的话，这个查询平均要查看log2 (1000000)个节点，相当于大约20个节点。
这比线性扫描节点列表效率要高5万倍。毫无疑问，信用卡公司会使用比二叉树更复杂的数据结构来处理这些问题，
至少有一点：所有的账号信息需要永久保存在数据库中，而不能只是暂存在内存里。会有比简单的map更精巧，更复杂的数据结构来完成这项任务，
但重要的是二叉树的思想，以及映射的构建可以用于构建更复杂的结构。
最后，甚至在一个较小范围内查找，速度也很重要。
例如，手机一般具有显示来电姓名的功能。这是另一个快速查找的例子，你希望能够根据数字（在这个例子中是电话号码 ) 迅速查找到姓名。
我不知道这在手机上实际是如何实现的。地址簿可能没有大到足以利用二叉树的优势，但是你可能会想到利用map的概念来组织这些数据，
而map往往以二叉树结构来建立，以允许快速查找。
还有其他的数据结构，比如散列表 http://en.wikipedia.org/wiki/Hash_table，也可以用来实现map。
构建二叉树和map的代价
构建二叉树和映射有一定的时间开销。你必须将每个节点添加到树中，添加一个节点平均需要log2 (n)次操作
（跟搜索节点一样，因为添加和搜索每次都是把树砍掉一半 ) 。
这意味着，构建整棵树实际上需要n * log2 (n)次操作。
由于对链表的每次线性搜索平均需要大约n/2次操作， 如果这样的链表搜索做2 * log2 (n)次，
所花费的时间就与构建一棵二叉树的时间相同。
（何以见得呢？因为做链表搜索的总时间等于每次搜索平均花费的时间乘以搜索的次数：（n/2）*(2 * log2 (n) ) = n * log2 (n) ) 。
 换句话说，当你仅进行一次搜索时，没必要构建一棵二叉树；但是如果要进行多次搜索，就用二叉树吧
（一个有100万节点的映射，即使只进行大约40次查找，用二叉树也能提高平均性能。 )
对于要处理数百万笔交易的信用卡公司而言，答案更是显而易见。
对于一部手机，这取决于你有多少电话以及地址簿的大小。（试着做些数学计算，来看看手机是否值得用二叉树 。) 
问答题
1.二叉树的主要优点是？
A.使用指针
B.可以存储任意数量的数据
C.允许数据的快速查找
D.从二叉树中删除节点很容易

C
2.什么情况下适合使用链表而不是二叉树？
A.当你需要以某种方式存储数据，使得它可以快速查找时
B.当你希望能访问排好序的数据元素时
C.当你需要能够快速地将数据添加到前端或末端，但从不访问中间的元素时
D.当你不需要释放正在使用的内存时

C
3.以下哪一项表述正确？
A.数据添加到二叉树的顺序不同可以影响到最终树的结构
B.应该排好序后再将数据插入到二叉树中，以便获得最佳的树结构
C.如果元素是随机插入到二叉树中的，那么，链表查找节点的速度会比二叉树快
D.二叉树永远不可能退化到跟链表相同的结构

A
4.以下关于二叉树查找节点速度快的解释，哪一项是正确的？
A.速度一点都不快，每个节点有两个指针意味着你必须做更多的事来遍历树
B.每经过树的一层，你大约砍掉了剩余节点数量的一半
C.二叉树并不是真的比链表好
D.二叉树的递归调用比链表的循环遍历要快

B
二叉树的代码如下
struct node
{
    int key_value;
    node *p_left;
    node *p_right;
};

node *insert (node *p_tree, int key);
node *search (node *p_tree, int key);
void destroy_tree (node *p_tree);
node *remove (node *p_tree, int key);
node *find_max (node *p_tree);
node *remove_max_node (node *p_tree, node *p_max_node);

node *insert (node *p_tree, int key)
{
    if ( p_tree == nullptr )
    {
        node *p_new_tree = new node;
        p_new_tree->p_left = nullptr;
        p_new_tree->p_right = nullptr;
        p_new_tree->key_value = key;
        return p_new_tree;
    }
    if( key < p_tree->key_value )
    {
        p_tree->p_left = insert( p_tree->p_left, key );
        return p_tree;
    }
    else
    {
        p_tree->p_right = insert( p_tree->p_right, key );
        return p_tree;
    }
}

node *search (node *p_tree, int key)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    else if ( key == p_tree->key_value )
    {
        return p_tree;
    }
    else if ( key < p_tree->key_value )
    {
        return search( p_tree->p_left, key );
    }
    else
    {
        return search( p_tree->p_right, key );
    }
}

void destroy_tree (node *p_tree)
{
    if ( p_tree != nullptr )
    {
        destroy_tree( p_tree->p_left );
        destroy_tree( p_tree->p_right );
        delete p_tree;
    }
}

node *find_max (node *p_tree)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->p_right == nullptr )
    {
        return p_tree;
    }
    else
    {
        return find_max( p_tree->p_right );
    }
}
node *remove_max_node (node *p_tree, node *p_max_node)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree == p_max_node )
    {
        return p_max_node->p_left;
    }
    else
    {
       p_tree->p_right = remove_max_node( p_tree->p_right, p_max_node);
        return p_tree;
    }
}
node *remove (node *p_tree, int key)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->key_value == key )
    {
        if ( p_tree->p_left == nullptr )
        {
            node *p_right_subtree = p_tree->p_right;
            delete p_tree;
            return p_right_subtree;
        }
        if ( p_tree->p_right == nullptr )
        {
            node *p_left_subtree = p_tree->p_left;
            delete p_tree;
            return p_left_subtree;
        }
        node *p_left_subtree = p_tree->p_left;
        node *p_right_subtree = p_tree->p_right;
        node *p_max_node = find_max( p_left_subtree );
        p_max_node->p_left = remove_max_node( p_tree->p_left, p_max_node );
        p_max_node->p_right = p_right_subtree;
        delete p_tree;
        return p_max_node;
    }
    else if ( key < p_tree->key_value )
    {
        p_tree->p_left = remove( p_tree->p_left, key);
        return p_tree;
    }
    else
    {
        p_tree->p_right = remove( p_tree->p_right, key);
        return p_tree;
    }
}
实践题
1.写一个程序，显示二叉树的内容。你能写一个程序，将二叉树的节点按排序顺序输出吗？按反向顺序输出呢？

#include <cstdlib>
#include <ctime>
#include <iostream>
#include <string>

using namespace std;

struct node
{
    int key_value;
    node *p_left;
    node *p_right;
};

node *insert (node *p_tree, int key);
node *search (node *p_tree, int key);
void destroy_tree (node *p_tree);
node *remove (node *p_tree, int key);
node *find_max (node *p_tree);
node *remove_max_node (node *p_tree, node *p_max_node);

node *createBinaryTree(int numberOfNodes);
void printTree(node *tree, string level = "");
void printSorted(node *tree, int numberOfNodes);
void printReverseSorted(node *tree, int numberOfNodes);
void printNode(string level);
void InOrder (node *p_tree, int *currentCount, int nodeKeys[]);

const int maxNumberOfNodes = 100;

int main()
{
    srand( time(nullptr) );
    int numberOfNodes = maxNumberOfNodes;
    do
    {
        cout << "Please specify the number of nodes to create for the binary tree (between 1 and " << maxNumberOfNodes << "):\n";
        cin >> numberOfNodes;
    }
    while (numberOfNodes <= 0 || numberOfNodes > maxNumberOfNodes);
    cin.clear();
    cin.ignore(80, '\n');
    node *tree = createBinaryTree(numberOfNodes);

    cout << "Display the binary tree\n";
    printTree(tree);
    cout << '\n';

    cout << "Display tree in sorted order\n";
    printSorted(tree, numberOfNodes);
    cout << '\n';

    cout << "Display tree in reverse sorted order\n";
    printReverseSorted(tree, numberOfNodes);
    cout << '\n';

    destroy_tree(tree);
}
node *createBinaryTree(int numberOfNodes)
{
    node *tree = nullptr;
    for (int i = 0; i < numberOfNodes; i++)
    {
        tree = insert(tree, rand());
    }

    return tree;
}
void printTree(node *tree, string level)
{
    if (level != "")
    {
        level += "-";
    }
    if (tree == nullptr)
    {
        level += "null";
        printNode(level);
        return;
    }

    level += to_string(tree->key_value);
    printNode(level);

    cout << "Left\n";
    printTree(tree->p_left, level);

    cout << "Right\n";
    printTree(tree->p_right, level);
}
void printSorted(node *tree, int numberOfNodes)
{
    int currentCount = 0;
    int nodeKeys[maxNumberOfNodes];
    InOrder (tree, &currentCount, nodeKeys);

    for (int i = 0; i < numberOfNodes; i++)
    {
        printNode( to_string( nodeKeys[i] ) );
    }
}
void printReverseSorted(node *tree, int numberOfNodes)
{
    int currentCount = 0;
    int nodeKeys[maxNumberOfNodes];
    InOrder (tree, &currentCount, nodeKeys);

    for (int i = 0; i < numberOfNodes; i++)
    {
        printNode( to_string( nodeKeys[numberOfNodes - 1 - i] ) );
    }
}
void printNode(string level)
{
    cout << "Node: " << level << "\n";
}
node *insert (node *p_tree, int key)
{
    if ( p_tree == nullptr )
    {
        node *p_new_tree = new node;
        p_new_tree->p_left = nullptr;
        p_new_tree->p_right = nullptr;
        p_new_tree->key_value = key;
        return p_new_tree;
    }
    if( key < p_tree->key_value )
    {
        p_tree->p_left = insert( p_tree->p_left, key );
        return p_tree;
    }
    else
    {
        p_tree->p_right = insert( p_tree->p_right, key );
        return p_tree;
    }
}

node *search (node *p_tree, int key)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    else if ( key == p_tree->key_value )
    {
        return p_tree;
    }
    else if ( key < p_tree->key_value )
    {
        return search( p_tree->p_left, key );
    }
    else
    {
        return search( p_tree->p_right, key );
    }
}
void InOrder (node *p_tree, int *currentCount, int nodeKeys[])
{
    if (p_tree != nullptr)
    {
        InOrder (p_tree->p_left, currentCount, nodeKeys);
        nodeKeys[ (*currentCount) ] = p_tree->key_value;
        (*currentCount)++;
        InOrder (p_tree->p_right, currentCount, nodeKeys);
    }
}
void destroy_tree (node *p_tree)
{
    if ( p_tree != nullptr )
    {
        destroy_tree( p_tree->p_left );
        destroy_tree( p_tree->p_right );
        delete p_tree;
    }
}

node *find_max (node *p_tree)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->p_right == nullptr )
    {
        return p_tree;
    }
    else
    {
        return find_max( p_tree->p_right );
    }
}
node *remove_max_node (node *p_tree, node *p_max_node)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree == p_max_node )
    {
        return p_max_node->p_left;
    }
    else
    {
        p_tree->p_right = remove_max_node( p_tree->p_right, p_max_node);
        return p_tree;
    }
}
node *remove (node *p_tree, int key)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->key_value == key )
    {
        if ( p_tree->p_left == nullptr )
        {
            node *p_right_subtree = p_tree->p_right;
            delete p_tree;
            return p_right_subtree;
        }
        if ( p_tree->p_right == nullptr )
        {
            node *p_left_subtree = p_tree->p_left;
            delete p_tree;
            return p_left_subtree;
        }
        node *p_left_subtree = p_tree->p_left;
        node *p_right_subtree = p_tree->p_right;
        node *p_max_node = find_max( p_left_subtree );
        p_max_node->p_left = remove_max_node( p_tree->p_left, p_max_node );
        p_max_node->p_right = p_right_subtree;
        delete p_tree;
        return p_max_node;
    }
    else if ( key < p_tree->key_value )
    {
        p_tree->p_left = remove( p_tree->p_left, key);
        return p_tree;
    }
    else
    {
        p_tree->p_right = remove( p_tree->p_right, key);
        return p_tree;
    }
}
显示结果如下
Please specify the number of nodes to create for the binary tree (between 1 and 100):
7
Display the binary tree
Node: 425381525
Left
Node: 425381525-17225134
Left
Node: 425381525-17225134-null
Right
Node: 425381525-17225134-363244850
Left
Node: 425381525-17225134-363244850-312913949
Left
Node: 425381525-17225134-363244850-312913949-null
Right
Node: 425381525-17225134-363244850-312913949-null
Right
Node: 425381525-17225134-363244850-null
Right
Node: 425381525-899957508
Left
Node: 425381525-899957508-554178660
Left
Node: 425381525-899957508-554178660-null
Right
Node: 425381525-899957508-554178660-null
Right
Node: 425381525-899957508-1131747404
Left
Node: 425381525-899957508-1131747404-null
Right
Node: 425381525-899957508-1131747404-null

Display tree in sorted order
Node: 17225134
Node: 312913949
Node: 363244850
Node: 425381525
Node: 554178660
Node: 899957508
Node: 1131747404

Display tree in reverse sorted order
Node: 1131747404
Node: 899957508
Node: 554178660
Node: 425381525
Node: 363244850
Node: 312913949
Node: 17225134

2.写一个程序，计算二叉树的节点数。

#include <cstdlib>
#include <ctime>
#include <iostream>
#include <string>

using namespace std;

struct node
{
    int key_value;
    node *p_left;
    node *p_right;
};

node *insert (node *p_tree, int key);
node *search (node *p_tree, int key);
void destroy_tree (node *p_tree);
node *remove (node *p_tree, int key);
node *find_max (node *p_tree);
node *remove_max_node (node *p_tree, node *p_max_node);

node *createBinaryTree(int numberOfNodes);
void InOrder (node *p_tree, int *currentCount, int nodeKeys[]);
void InOrder (node *p_tree, int *currentCount);

const int maxNumberOfNodes = 100;

int main()
{
    srand( time(nullptr) );
    int numberOfNodes = maxNumberOfNodes;
    do
    {
        cout << "Please specify the number of nodes to create for the binary tree (between 1 and " << maxNumberOfNodes << "):\n";
        cin >> numberOfNodes;
    }
    while (numberOfNodes <= 0 || numberOfNodes > maxNumberOfNodes);
    cin.clear();
    cin.ignore(80, '\n');
    node *tree = createBinaryTree(numberOfNodes);

    int countOfNodes = 0;
    InOrder (tree, &countOfNodes);
    cout << "The number of nodes in the binary tree is: " << countOfNodes << '\n';

    destroy_tree(tree);
}
node *createBinaryTree(int numberOfNodes)
{
    node *tree = nullptr;
    for (int i = 0; i < numberOfNodes; i++)
    {
        tree = insert(tree, rand());
    }

    return tree;
}
node *insert (node *p_tree, int key)
{
    if ( p_tree == nullptr )
    {
        node *p_new_tree = new node;
        p_new_tree->p_left = nullptr;
        p_new_tree->p_right = nullptr;
        p_new_tree->key_value = key;
        return p_new_tree;
    }
    if( key < p_tree->key_value )
    {
        p_tree->p_left = insert( p_tree->p_left, key );
        return p_tree;
    }
    else
    {
        p_tree->p_right = insert( p_tree->p_right, key );
        return p_tree;
    }
}

node *search (node *p_tree, int key)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    else if ( key == p_tree->key_value )
    {
        return p_tree;
    }
    else if ( key < p_tree->key_value )
    {
        return search( p_tree->p_left, key );
    }
    else
    {
        return search( p_tree->p_right, key );
    }
}
void InOrder (node *p_tree, int *currentCount, int nodeKeys[])
{
    if (p_tree != nullptr)
    {
        InOrder (p_tree->p_left, currentCount, nodeKeys);
        nodeKeys[ (*currentCount) ] = p_tree->key_value;
        (*currentCount)++;
        InOrder (p_tree->p_right, currentCount, nodeKeys);
    }
}
void InOrder (node *p_tree, int *currentCount)
{
    if (p_tree != nullptr)
    {
        InOrder (p_tree->p_left, currentCount);
        (*currentCount)++;
        InOrder (p_tree->p_right, currentCount);
    }
}
void destroy_tree (node *p_tree)
{
    if ( p_tree != nullptr )
    {
        destroy_tree( p_tree->p_left );
        destroy_tree( p_tree->p_right );
        delete p_tree;
    }
}

node *find_max (node *p_tree)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->p_right == nullptr )
    {
        return p_tree;
    }
    else
    {
        return find_max( p_tree->p_right );
    }
}
node *remove_max_node (node *p_tree, node *p_max_node)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree == p_max_node )
    {
        return p_max_node->p_left;
    }
    else
    {
        p_tree->p_right = remove_max_node( p_tree->p_right, p_max_node);
        return p_tree;
    }
}
node *remove (node *p_tree, int key)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->key_value == key )
    {
        if ( p_tree->p_left == nullptr )
        {
            node *p_right_subtree = p_tree->p_right;
            delete p_tree;
            return p_right_subtree;
        }
        if ( p_tree->p_right == nullptr )
        {
            node *p_left_subtree = p_tree->p_left;
            delete p_tree;
            return p_left_subtree;
        }
        node *p_left_subtree = p_tree->p_left;
        node *p_right_subtree = p_tree->p_right;
        node *p_max_node = find_max( p_left_subtree );
        p_max_node->p_left = remove_max_node( p_tree->p_left, p_max_node );
        p_max_node->p_right = p_right_subtree;
        delete p_tree;
        return p_max_node;
    }
    else if ( key < p_tree->key_value )
    {
        p_tree->p_left = remove( p_tree->p_left, key);
        return p_tree;
    }
    else
    {
        p_tree->p_right = remove( p_tree->p_right, key);
        return p_tree;
    }
}
显示结果如下
Please specify the number of nodes to create for the binary tree (between 1 and 100):
7
The number of nodes in the binary tree is: 7

3.写一个程序，能够检查一棵二叉树是否平衡。

#include <cstdlib>
#include <ctime>
#include <iostream>
#include <string>

using namespace std;

struct node
{
    int depth_of_node;
    int count_of_nodes;
    int key_value;
    node *p_left;
    node *p_right;
};

node *insert (node *p_tree, int key);
node *search (node *p_tree, int key);
void destroy_tree (node *p_tree);
node *remove (node *p_tree, int key);
node *find_max (node *p_tree);
node *remove_max_node (node *p_tree, node *p_max_node);

node *createBinaryTree(int numberOfNodes);
void printTree(node *tree, string level = "");
void printSorted(node *tree, int numberOfNodes);
void printReverseSorted(node *tree, int numberOfNodes);
void printNode(string level);
void InOrder (node *p_tree, int *currentCount, int nodeKeys[]);
void InOrder (node *p_tree, int *currentCount);
void checkTreeBalanced(node* p_tree);

const int maxNumberOfNodes = 100;

int main()
{
    srand( time(nullptr) );
    int numberOfNodes = maxNumberOfNodes;
    do
    {
        cout << "Please specify the number of nodes to create for the binary tree (between 1 and " << maxNumberOfNodes << "):\n";
        cin >> numberOfNodes;
    }
    while (numberOfNodes <= 0 || numberOfNodes > maxNumberOfNodes);
    cin.clear();
    cin.ignore(80, '\n');
    node *tree = createBinaryTree(numberOfNodes);

    cout << "Display the binary tree\n";
    printTree(tree);
    cout << '\n';

    cout << "Display tree in sorted order\n";
    printSorted(tree, numberOfNodes);
    cout << '\n';

    cout << "Display tree in reverse sorted order\n";
    printReverseSorted(tree, numberOfNodes);
    cout << '\n';

    destroy_tree(tree);
}
node *createBinaryTree(int numberOfNodes)
{
    node *tree = nullptr;
    for (int i = 0; i < numberOfNodes; i++)
    {
        tree = insert(tree, rand());
    }

    return tree;
}
void printTree(node *tree, string level)
{
    if (level != "")
    {
        level += "-";
    }
    if (tree == nullptr)
    {
        level += "null";
        printNode(level);
        return;
    }

    level += to_string(tree->depth_of_node);
    level += ", ";
    level += to_string(tree->count_of_nodes);
    level += ": ";
    level += to_string(tree->key_value);
    printNode(level);
    checkTreeBalanced(tree);

    cout << "Left\n";
    printTree(tree->p_left, level);

    cout << "Right\n";
    printTree(tree->p_right, level);
}
void printSorted(node *tree, int numberOfNodes)
{
    int currentCount = 0;
    int nodeKeys[maxNumberOfNodes];
    InOrder (tree, &currentCount, nodeKeys);

    for (int i = 0; i < numberOfNodes; i++)
    {
        printNode( to_string( nodeKeys[i] ) );
    }
}
void printReverseSorted(node *tree, int numberOfNodes)
{
    int currentCount = 0;
    int nodeKeys[maxNumberOfNodes];
    InOrder (tree, &currentCount, nodeKeys);

    for (int i = 0; i < numberOfNodes; i++)
    {
        printNode( to_string( nodeKeys[numberOfNodes - 1 - i] ) );
    }
}
void printNode(string level)
{
    cout << "Node: " << level << "\n";
}
node *insert (node *p_tree, int key)
{
    int left_depth, right_depth;
    int left_count, right_count;

    if ( p_tree == nullptr )
    {
        node *p_new_tree = new node;
        p_new_tree->depth_of_node = 0;
        p_new_tree->count_of_nodes = 1;
        p_new_tree->p_left = nullptr;
        p_new_tree->p_right = nullptr;
        p_new_tree->key_value = key;
        return p_new_tree;
    }
    if ( key == p_tree->key_value )
    {
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
    else if( key < p_tree->key_value )
    {
        p_tree->p_left = insert( p_tree->p_left, key );
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
    else
    {
        p_tree->p_right = insert( p_tree->p_right, key );
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
}

node *search (node *p_tree, int key)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    else if ( key == p_tree->key_value )
    {
        return p_tree;
    }
    else if ( key < p_tree->key_value )
    {
        return search( p_tree->p_left, key );
    }
    else
    {
        return search( p_tree->p_right, key );
    }
}
void InOrder (node *p_tree, int *currentCount, int nodeKeys[])
{
    if (p_tree != nullptr)
    {
        InOrder (p_tree->p_left, currentCount, nodeKeys);
        nodeKeys[ (*currentCount) ] = p_tree->key_value;
        (*currentCount)++;
        InOrder (p_tree->p_right, currentCount, nodeKeys);
    }
}
void InOrder (node *p_tree, int *currentCount)
{
    if (p_tree != nullptr)
    {
        InOrder (p_tree->p_left, currentCount);
        (*currentCount)++;
        InOrder (p_tree->p_right, currentCount);
    }
}
void checkTreeBalanced(node* p_tree)
{
    int left_depth, right_depth;
    int left_count, right_count;
    int temp_depth, temp_count;

    if ( p_tree != nullptr )
    {
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            temp_depth = ( right_depth - left_depth );
        }
        else
        {
            temp_depth = ( left_depth - right_depth );
        }
        if (left_count < right_count)
        {
            temp_count = ( right_count - left_count );
        }
        else
        {
            temp_count = ( left_count - right_count );
        }
        if (temp_depth >= -1 && temp_depth <= 1)
        {
            cout << "checkTreeBalanced: " << temp_depth << ", " << temp_count << " is balanced\n";
        }
        else
        {
            cout << "checkTreeBalanced: " << temp_depth << ", " << temp_count << " is not balanced\n";
        }
    }
}
void destroy_tree (node *p_tree)
{
    if ( p_tree != nullptr )
    {
        destroy_tree( p_tree->p_left );
        destroy_tree( p_tree->p_right );
        delete p_tree;
    }
}

node *find_max (node *p_tree)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->p_right == nullptr )
    {
        return p_tree;
    }
    else
    {
        return find_max( p_tree->p_right );
    }
}
node *remove_max_node (node *p_tree, node *p_max_node)
{
    int left_depth, right_depth;
    int left_count, right_count;

    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree == p_max_node )
    {
        return p_max_node->p_left;
    }
    else
    {
        p_tree->p_right = remove_max_node( p_tree->p_right, p_max_node);
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
}
node *remove (node *p_tree, int key)
{
    int left_depth, right_depth;
    int left_count, right_count;

    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->key_value == key )
    {
        if ( p_tree->p_left == nullptr )
        {
            node *p_right_subtree = p_tree->p_right;
            delete p_tree;
            return p_right_subtree;
        }
        if ( p_tree->p_right == nullptr )
        {
            node *p_left_subtree = p_tree->p_left;
            delete p_tree;
            return p_left_subtree;
        }
        node *p_left_subtree = p_tree->p_left;
        node *p_right_subtree = p_tree->p_right;
        node *p_max_node = find_max( p_left_subtree );
        p_max_node->p_left = remove_max_node( p_tree->p_left, p_max_node );
        p_max_node->p_right = p_right_subtree;
        if (p_max_node->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_max_node->p_left->depth_of_node;
            left_count = p_max_node->p_left->count_of_nodes;
        }
        if (p_max_node->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_max_node->p_right->depth_of_node;
            right_count = p_max_node->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_max_node->depth_of_node = right_depth + 1;
        }
        else
        {
            p_max_node->depth_of_node = left_depth + 1;
        }
        p_max_node->count_of_nodes = left_count + right_count + 1;
        delete p_tree;
        return p_max_node;
    }
    else if ( key < p_tree->key_value )
    {
        p_tree->p_left = remove( p_tree->p_left, key);
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
    else
    {
        p_tree->p_right = remove( p_tree->p_right, key);
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
}
显示结果如下
Please specify the number of nodes to create for the binary tree (between 1 and 100):
7
Display the binary tree
Node: 4, 7: 55756359
checkTreeBalanced: 4, 6 is not balanced
Left
Node: 4, 7: 55756359-null
Right
Node: 4, 7: 55756359-3, 6: 1225722247
checkTreeBalanced: 1, 1 is balanced
Left
Node: 4, 7: 55756359-3, 6: 1225722247-2, 3: 232570607
checkTreeBalanced: 2, 2 is not balanced
Left
Node: 4, 7: 55756359-3, 6: 1225722247-2, 3: 232570607-null
Right
Node: 4, 7: 55756359-3, 6: 1225722247-2, 3: 232570607-1, 2: 816521192
checkTreeBalanced: 1, 1 is balanced
Left
Node: 4, 7: 55756359-3, 6: 1225722247-2, 3: 232570607-1, 2: 816521192-null
Right
Node: 4, 7: 55756359-3, 6: 1225722247-2, 3: 232570607-1, 2: 816521192-0, 1: 1155433106
checkTreeBalanced: 0, 0 is balanced
Left
Node: 4, 7: 55756359-3, 6: 1225722247-2, 3: 232570607-1, 2: 816521192-0, 1: 1155433106-null
Right
Node: 4, 7: 55756359-3, 6: 1225722247-2, 3: 232570607-1, 2: 816521192-0, 1: 1155433106-null
Right
Node: 4, 7: 55756359-3, 6: 1225722247-1, 2: 1342068111
checkTreeBalanced: 1, 1 is balanced
Left
Node: 4, 7: 55756359-3, 6: 1225722247-1, 2: 1342068111-null
Right
Node: 4, 7: 55756359-3, 6: 1225722247-1, 2: 1342068111-0, 1: 1790436034
checkTreeBalanced: 0, 0 is balanced
Left
Node: 4, 7: 55756359-3, 6: 1225722247-1, 2: 1342068111-0, 1: 1790436034-null
Right
Node: 4, 7: 55756359-3, 6: 1225722247-1, 2: 1342068111-0, 1: 1790436034-null

Display tree in sorted order
Node: 55756359
Node: 232570607
Node: 816521192
Node: 1155433106
Node: 1225722247
Node: 1342068111
Node: 1790436034

Display tree in reverse sorted order
Node: 1790436034
Node: 1342068111
Node: 1225722247
Node: 1155433106
Node: 816521192
Node: 232570607
Node: 55756359

4.写一个程序，它能检查一棵二叉树是否正确排序，即：对于一个给定的节点，是否其左侧节点都小于该节点的值，其右侧的节点都大于该节点的值。

#include <cstdlib>
#include <ctime>
#include <iostream>
#include <string>

using namespace std;

struct node
{
    int depth_of_node;
    int count_of_nodes;
    int key_value;
    node *p_left;
    node *p_right;
};

node *insert (node *p_tree, int key);
node *search (node *p_tree, int key);
void destroy_tree (node *p_tree);
node *remove (node *p_tree, int key);
node *find_max (node *p_tree);
node *remove_max_node (node *p_tree, node *p_max_node);

node *createBinaryTree(int numberOfNodes);
void printTree(node *tree, string level = "");
void printSorted(node *tree, int numberOfNodes);
void printReverseSorted(node *tree, int numberOfNodes);
void printNode(string level);
void InOrder (node *p_tree, int *currentCount, int nodeKeys[]);
void InOrder (node *p_tree, int *currentCount);
void checkTreeBalanced(node *p_tree);
bool checkTreeSorted(node *p_tree);

const int maxNumberOfNodes = 100;

int main()
{
    srand( time(nullptr) );
    int numberOfNodes = maxNumberOfNodes;
    do
    {
        cout << "Please specify the number of nodes to create for the binary tree (between 1 and " << maxNumberOfNodes << "):\n";
        cin >> numberOfNodes;
    }
    while (numberOfNodes <= 0 || numberOfNodes > maxNumberOfNodes);
    cin.clear();
    cin.ignore(80, '\n');
    node *tree = createBinaryTree(numberOfNodes);

    cout << "Display the binary tree\n";
    printTree(tree);
    cout << '\n';

    cout << "Display tree in sorted order\n";
    printSorted(tree, numberOfNodes);
    cout << '\n';

    cout << "Display tree in reverse sorted order\n";
    printReverseSorted(tree, numberOfNodes);
    cout << '\n';

    cout << "Check tree is sorted\n";
    if ( checkTreeSorted(tree) )
    {
        cout << "The tree is sorted\n";
    }
    else
    {
        cout << "The tree is not sorted\n";
    }

    destroy_tree(tree);
}
node *createBinaryTree(int numberOfNodes)
{
    node *tree = nullptr;
    for (int i = 0; i < numberOfNodes; i++)
    {
        tree = insert(tree, rand());
    }

    return tree;
}
void printTree(node *tree, string level)
{
    if (level != "")
    {
        level += "-";
    }
    if (tree == nullptr)
    {
        level += "null";
        printNode(level);
        return;
    }

    level += to_string(tree->depth_of_node);
    level += ", ";
    level += to_string(tree->count_of_nodes);
    level += ": ";
    level += to_string(tree->key_value);
    printNode(level);
    checkTreeBalanced(tree);

    cout << "Left\n";
    printTree(tree->p_left, level);

    cout << "Right\n";
    printTree(tree->p_right, level);
}
void printSorted(node *tree, int numberOfNodes)
{
    int currentCount = 0;
    int nodeKeys[maxNumberOfNodes];
    InOrder (tree, &currentCount, nodeKeys);

    for (int i = 0; i < numberOfNodes; i++)
    {
        printNode( to_string( nodeKeys[i] ) );
    }
}
void printReverseSorted(node *tree, int numberOfNodes)
{
    int currentCount = 0;
    int nodeKeys[maxNumberOfNodes];
    InOrder (tree, &currentCount, nodeKeys);

    for (int i = 0; i < numberOfNodes; i++)
    {
        printNode( to_string( nodeKeys[numberOfNodes - 1 - i] ) );
    }
}
void printNode(string level)
{
    cout << "Node: " << level << "\n";
}
node *insert (node *p_tree, int key)
{
    int left_depth, right_depth;
    int left_count, right_count;

    if ( p_tree == nullptr )
    {
        node *p_new_tree = new node;
        p_new_tree->depth_of_node = 0;
        p_new_tree->count_of_nodes = 1;
        p_new_tree->p_left = nullptr;
        p_new_tree->p_right = nullptr;
        p_new_tree->key_value = key;
        return p_new_tree;
    }
    if ( key == p_tree->key_value )
    {
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
    else if( key < p_tree->key_value )
    {
        p_tree->p_left = insert( p_tree->p_left, key );
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
    else
    {
        p_tree->p_right = insert( p_tree->p_right, key );
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
}

node *search (node *p_tree, int key)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    else if ( key == p_tree->key_value )
    {
        return p_tree;
    }
    else if ( key < p_tree->key_value )
    {
        return search( p_tree->p_left, key );
    }
    else
    {
        return search( p_tree->p_right, key );
    }
}
void InOrder (node *p_tree, int *currentCount, int nodeKeys[])
{
    if (p_tree != nullptr)
    {
        InOrder (p_tree->p_left, currentCount, nodeKeys);
        nodeKeys[ (*currentCount) ] = p_tree->key_value;
        (*currentCount)++;
        InOrder (p_tree->p_right, currentCount, nodeKeys);
    }
}
void InOrder (node *p_tree, int *currentCount)
{
    if (p_tree != nullptr)
    {
        InOrder (p_tree->p_left, currentCount);
        (*currentCount)++;
        InOrder (p_tree->p_right, currentCount);
    }
}
void checkTreeBalanced(node *p_tree)
{
    int left_depth, right_depth;
    int left_count, right_count;
    int temp_depth, temp_count;

    if ( p_tree != nullptr )
    {
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            temp_depth = ( right_depth - left_depth );
        }
        else
        {
            temp_depth = ( left_depth - right_depth );
        }
        if (left_count < right_count)
        {
            temp_count = ( right_count - left_count );
        }
        else
        {
            temp_count = ( left_count - right_count );
        }
        if (temp_depth >= -1 && temp_depth <= 1)
        {
            cout << "checkTreeBalanced: " << temp_depth << ", " << temp_count << " is balanced\n";
        }
        else
        {
            cout << "checkTreeBalanced: " << temp_depth << ", " << temp_count << " is not balanced\n";
        }
    }
}
bool checkTreeSorted(node *p_tree)
{
    bool temp_result;

    if (p_tree == nullptr)
    {
        return true;
    }
    if (p_tree->p_left == nullptr && p_tree->p_right == nullptr)
    {
        return true;
    }

    if (p_tree->p_left != nullptr && p_tree->p_left->key_value > p_tree->key_value)
    {

        cout << "checkTreeSorted left = " << p_tree->p_left->key_value << " > " << p_tree->key_value << '\n';
        return false;
    }
    if (p_tree->p_right != nullptr && p_tree->p_right->key_value < p_tree->key_value)
    {
        cout << "checkTreeSorted right = " << p_tree->p_right->key_value << " < " << p_tree->key_value << '\n';
        return false;
    }
    return ( checkTreeSorted(p_tree->p_left) && checkTreeSorted(p_tree->p_right) );
}
void destroy_tree (node *p_tree)
{
    if ( p_tree != nullptr )
    {
        destroy_tree( p_tree->p_left );
        destroy_tree( p_tree->p_right );
        delete p_tree;
    }
}

node *find_max (node *p_tree)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->p_right == nullptr )
    {
        return p_tree;
    }
    else
    {
        return find_max( p_tree->p_right );
    }
}
node *remove_max_node (node *p_tree, node *p_max_node)
{
    int left_depth, right_depth;
    int left_count, right_count;

    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree == p_max_node )
    {
        return p_max_node->p_left;
    }
    else
    {
        p_tree->p_right = remove_max_node( p_tree->p_right, p_max_node);
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
}
node *remove (node *p_tree, int key)
{
    int left_depth, right_depth;
    int left_count, right_count;

    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->key_value == key )
    {
        if ( p_tree->p_left == nullptr )
        {
            node *p_right_subtree = p_tree->p_right;
            delete p_tree;
            return p_right_subtree;
        }
        if ( p_tree->p_right == nullptr )
        {
            node *p_left_subtree = p_tree->p_left;
            delete p_tree;
            return p_left_subtree;
        }
        node *p_left_subtree = p_tree->p_left;
        node *p_right_subtree = p_tree->p_right;
        node *p_max_node = find_max( p_left_subtree );
        p_max_node->p_left = remove_max_node( p_tree->p_left, p_max_node );
        p_max_node->p_right = p_right_subtree;
        if (p_max_node->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_max_node->p_left->depth_of_node;
            left_count = p_max_node->p_left->count_of_nodes;
        }
        if (p_max_node->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_max_node->p_right->depth_of_node;
            right_count = p_max_node->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_max_node->depth_of_node = right_depth + 1;
        }
        else
        {
            p_max_node->depth_of_node = left_depth + 1;
        }
        p_max_node->count_of_nodes = left_count + right_count + 1;
        delete p_tree;
        return p_max_node;
    }
    else if ( key < p_tree->key_value )
    {
        p_tree->p_left = remove( p_tree->p_left, key);
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
    else
    {
        p_tree->p_right = remove( p_tree->p_right, key);
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
}
显示结果如下
Please specify the number of nodes to create for the binary tree (between 1 and 100):
7
Display the binary tree
Node: 4, 7: 1833506854
checkTreeBalanced: 3, 4 is not balanced
Left
Node: 4, 7: 1833506854-3, 5: 1086276514
checkTreeBalanced: 2, 2 is not balanced
Left
Node: 4, 7: 1833506854-3, 5: 1086276514-0, 1: 4521332
checkTreeBalanced: 0, 0 is balanced
Left
Node: 4, 7: 1833506854-3, 5: 1086276514-0, 1: 4521332-null
Right
Node: 4, 7: 1833506854-3, 5: 1086276514-0, 1: 4521332-null
Right
Node: 4, 7: 1833506854-3, 5: 1086276514-2, 3: 1768156313
checkTreeBalanced: 2, 2 is not balanced
Left
Node: 4, 7: 1833506854-3, 5: 1086276514-2, 3: 1768156313-1, 2: 1329903315
checkTreeBalanced: 1, 1 is balanced
Left
Node: 4, 7: 1833506854-3, 5: 1086276514-2, 3: 1768156313-1, 2: 1329903315-0, 1: 1207457301
checkTreeBalanced: 0, 0 is balanced
Left
Node: 4, 7: 1833506854-3, 5: 1086276514-2, 3: 1768156313-1, 2: 1329903315-0, 1: 1207457301-null
Right
Node: 4, 7: 1833506854-3, 5: 1086276514-2, 3: 1768156313-1, 2: 1329903315-0, 1: 1207457301-null
Right
Node: 4, 7: 1833506854-3, 5: 1086276514-2, 3: 1768156313-1, 2: 1329903315-null
Right
Node: 4, 7: 1833506854-3, 5: 1086276514-2, 3: 1768156313-null
Right
Node: 4, 7: 1833506854-0, 1: 2086782478
checkTreeBalanced: 0, 0 is balanced
Left
Node: 4, 7: 1833506854-0, 1: 2086782478-null
Right
Node: 4, 7: 1833506854-0, 1: 2086782478-null

Display tree in sorted order
Node: 4521332
Node: 1086276514
Node: 1207457301
Node: 1329903315
Node: 1768156313
Node: 1833506854
Node: 2086782478

Display tree in reverse sorted order
Node: 2086782478
Node: 1833506854
Node: 1768156313
Node: 1329903315
Node: 1207457301
Node: 1086276514
Node: 4521332

Check tree is sorted
The tree is sorted

5.写一个程序，不使用递归删除掉二叉树的所有节点。

#include <cstdlib>
#include <ctime>
#include <iostream>
#include <string>

using namespace std;

struct node
{
    int depth_of_node;
    int count_of_nodes;
    int key_value;
    node *p_parent;
    node *p_left;
    node *p_right;
};

node *insert (node *p_tree, int key);
node *search (node *p_tree, int key);
void destroy_tree (node *p_tree);
node *remove (node *p_tree, int key);
node *find_max (node *p_tree);
node *remove_max_node (node *p_tree, node *p_max_node);

node *createBinaryTree(int numberOfNodes);
void printTree(node *tree, string level = "");
void printSorted(node *tree, int numberOfNodes);
void printReverseSorted(node *tree, int numberOfNodes);
void printNode(string level);
void InOrder (node *p_tree, int *currentCount, int nodeKeys[]);
void InOrder (node *p_tree, int *currentCount);
void InOrderNonRecursive (node *p_tree, int *currentCount, int nodeKeys[]);
void postOrderNonRecursive (node *p_tree, int *currentCount, int nodeKeys[]);
void preOrderNonRecursive (node *p_tree, int *currentCount, int nodeKeys[]);
void destroyTreePostOrder (node *p_tree);
void checkTreeBalanced(node *p_tree);
bool checkTreeSorted(node *p_tree);

const int maxNumberOfNodes = 100;

int main()
{
    srand( time(nullptr) );
    int numberOfNodes = maxNumberOfNodes;
    do
    {
        cout << "Please specify the number of nodes to create for the binary tree (between 1 and " << maxNumberOfNodes << "):\n";
        cin >> numberOfNodes;
    }
    while (numberOfNodes <= 0 || numberOfNodes > maxNumberOfNodes);
    cin.clear();
    cin.ignore(80, '\n');
    node *tree = createBinaryTree(numberOfNodes);

    cout << "Display the binary tree\n";
    printTree(tree);
    cout << '\n';

    cout << "Display tree in sorted order\n";
    printSorted(tree, numberOfNodes);
    cout << '\n';

    cout << "Display tree in reverse sorted order\n";
    printReverseSorted(tree, numberOfNodes);
    cout << '\n';

    cout << "Check tree is sorted\n";
    if ( checkTreeSorted(tree) )
    {
        cout << "The tree is sorted\n";
    }
    else
    {
        cout << "The tree is not sorted\n";
    }

    destroyTreePostOrder(tree);
}
node *createBinaryTree(int numberOfNodes)
{
    node *tree = nullptr;
    for (int i = 0; i < numberOfNodes; i++)
    {
        tree = insert(tree, rand());
    }

    return tree;
}
void printTree(node *tree, string level)
{
    if (level != "")
    {
        level += "-";
    }
    if (tree == nullptr)
    {
        level += "null";
        printNode(level);
        return;
    }

    level += to_string(tree->depth_of_node);
    level += ", ";
    level += to_string(tree->count_of_nodes);
    level += ": ";
    level += to_string(tree->key_value);
    printNode(level);
    checkTreeBalanced(tree);

    cout << "Left\n";
    printTree(tree->p_left, level);

    cout << "Right\n";
    printTree(tree->p_right, level);
}
void printSorted(node *tree, int numberOfNodes)
{
    int currentCount = 0;
    int nodeKeys[maxNumberOfNodes];
    InOrder (tree, &currentCount, nodeKeys);

    for (int i = 0; i < numberOfNodes; i++)
    {
        printNode( to_string( nodeKeys[i] ) );
    }
    cout <<"\n\n";
    currentCount = 0;
    postOrderNonRecursive (tree, &currentCount, nodeKeys);
    for (int i = 0; i < numberOfNodes; i++)
    {
        printNode( to_string( nodeKeys[i] ) );
    }
    cout <<"\n\n";
    currentCount = 0;
    preOrderNonRecursive (tree, &currentCount, nodeKeys);
    for (int i = 0; i < numberOfNodes; i++)
    {
        printNode( to_string( nodeKeys[i] ) );
    }
}
void printReverseSorted(node *tree, int numberOfNodes)
{
    int currentCount = 0;
    int nodeKeys[maxNumberOfNodes];
    InOrderNonRecursive (tree, &currentCount, nodeKeys);

    for (int i = 0; i < numberOfNodes; i++)
    {
        printNode( to_string( nodeKeys[numberOfNodes - 1 - i] ) );
    }
}
void printNode(string level)
{
    cout << "Node: " << level << "\n";
}
node *insert (node *p_tree, int key)
{
    int left_depth, right_depth;
    int left_count, right_count;

    if ( p_tree == nullptr )
    {
        node *p_new_tree = new node;
        p_new_tree->depth_of_node = 0;
        p_new_tree->count_of_nodes = 1;
        p_new_tree->p_parent = nullptr;
        p_new_tree->p_left = nullptr;
        p_new_tree->p_right = nullptr;
        p_new_tree->key_value = key;
        return p_new_tree;
    }
    if ( key == p_tree->key_value )
    {
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
    else if( key < p_tree->key_value )
    {
        p_tree->p_left = insert( p_tree->p_left, key );
        if (p_tree->p_left != nullptr)
        {
            p_tree->p_left->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
    else
    {
        p_tree->p_right = insert( p_tree->p_right, key );
        if (p_tree->p_right != nullptr)
        {
            p_tree->p_right->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
}

node *search (node *p_tree, int key)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    else if ( key == p_tree->key_value )
    {
        return p_tree;
    }
    else if ( key < p_tree->key_value )
    {
        return search( p_tree->p_left, key );
    }
    else
    {
        return search( p_tree->p_right, key );
    }
}
void preOrderNonRecursive (node *p_tree, int *currentCount, int nodeKeys[])
{
   node *last_node;
    node *check_node;

    if (p_tree == nullptr)
    {
        return;
    }
    last_node = nullptr;
    check_node = p_tree;
    nodeKeys[ (*currentCount) ] = check_node->key_value;
    (*currentCount)++;
    if (check_node->p_left != nullptr)
    {
        last_node = check_node;
        check_node = check_node->p_left;
    }
    else
    {
        if (check_node->p_right != nullptr)
        {
            last_node = check_node;
            check_node = check_node->p_right;
        }
        else
        {
            return;
        }
    }
    while(last_node != nullptr && check_node != nullptr)
    {
        if(last_node == check_node->p_parent)
        {
            nodeKeys[ (*currentCount) ] = check_node->key_value;
            (*currentCount)++;
            if (check_node->p_left != nullptr)
            {
                last_node = check_node;
                check_node = check_node->p_left;
            }
            else
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
        }
        else
        {
            if(last_node == check_node->p_left)
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
            else
            {
                last_node = check_node;
                check_node = check_node->p_parent;
            }
        }
    }
}
void postOrderNonRecursive (node *p_tree, int *currentCount, int nodeKeys[])
{
    node *last_node;
    node *check_node;

    if (p_tree == nullptr)
    {
        return;
    }
    last_node = nullptr;
    check_node = p_tree;
    if (check_node->p_left != nullptr)
    {
        last_node = check_node;
        check_node = check_node->p_left;
    }
    else
    {
        if (check_node->p_right != nullptr)
        {
            last_node = check_node;
            check_node = check_node->p_right;
        }
        else
        {
            nodeKeys[ (*currentCount) ] = check_node->key_value;
            (*currentCount)++;
            return;
        }
    }
    while(last_node != nullptr && check_node != nullptr)
    {
        if(last_node == check_node->p_parent)
        {
            if (check_node->p_left != nullptr)
            {
                last_node = check_node;
                check_node = check_node->p_left;
            }
            else
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    nodeKeys[ (*currentCount) ] = check_node->key_value;
                    (*currentCount)++;
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
        }
        else
        {
            if(last_node == check_node->p_left)
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    nodeKeys[ (*currentCount) ] = check_node->key_value;
                    (*currentCount)++;
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
            else
            {
                nodeKeys[ (*currentCount) ] = check_node->key_value;
                (*currentCount)++;
                last_node = check_node;
                check_node = check_node->p_parent;
            }
        }
    }
}
void destroyTreePostOrder (node *p_tree)
{
    node *last_node;
    node *check_node;
    node *temp_node;

    if (p_tree == nullptr)
    {
        return;
    }
    last_node = nullptr;
    check_node = p_tree;
    if (check_node->p_left != nullptr)
    {
        last_node = check_node;
        check_node = check_node->p_left;
    }
    else
    {
        if (check_node->p_right != nullptr)
        {
            last_node = check_node;
            check_node = check_node->p_right;
        }
        else
        {
            temp_node = check_node;
            cout << temp_node->key_value << '\n';
            delete temp_node;
            return;
        }
    }
    while(last_node != nullptr && check_node != nullptr)
    {
        if(last_node == check_node->p_parent)
        {
            if (check_node->p_left != nullptr)
            {
                last_node = check_node;
                check_node = check_node->p_left;
            }
            else
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    temp_node = check_node;
                    last_node = check_node;
                    check_node = check_node->p_parent;
                    cout << temp_node->key_value << '\n';
                    delete temp_node;
                }
            }
        }
        else
        {
            if(last_node == check_node->p_left)
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    temp_node = check_node;
                    last_node = check_node;
                    check_node = check_node->p_parent;
                    cout << temp_node->key_value << '\n';
                    delete temp_node;
                }
            }
            else
            {
                temp_node = check_node;
                last_node = check_node;
                check_node = check_node->p_parent;
                cout << temp_node->key_value << '\n';
                delete temp_node;
            }
        }
    }
}
void InOrderNonRecursive (node *p_tree, int *currentCount, int nodeKeys[])
{
    node *last_node;
    node *check_node;

    if (p_tree == nullptr)
    {
        return;
    }
    last_node = nullptr;
    check_node = p_tree;
    if (check_node->p_left != nullptr)
    {
        last_node = check_node;
        check_node = check_node->p_left;
    }
    else
    {
        nodeKeys[ (*currentCount) ] = check_node->key_value;
        (*currentCount)++;
        if (check_node->p_right != nullptr)
        {
            last_node = check_node;
            check_node = check_node->p_right;
        }
        else
        {
            return;
        }
    }
    while(last_node != nullptr && check_node != nullptr)
    {
        if(last_node == check_node->p_parent)
        {
            if (check_node->p_left != nullptr)
            {
                last_node = check_node;
                check_node = check_node->p_left;
            }
            else
            {
                nodeKeys[ (*currentCount) ] = check_node->key_value;
                (*currentCount)++;
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
        }
        else
        {
            if(last_node == check_node->p_left)
            {
                nodeKeys[ (*currentCount) ] = check_node->key_value;
                (*currentCount)++;
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
            else
            {
                last_node = check_node;
                check_node = check_node->p_parent;
            }
        }
    }
}

void InOrder (node *p_tree, int *currentCount, int nodeKeys[])
{
    if (p_tree != nullptr)
    {
        InOrder (p_tree->p_left, currentCount, nodeKeys);
        nodeKeys[ (*currentCount) ] = p_tree->key_value;
        (*currentCount)++;
        InOrder (p_tree->p_right, currentCount, nodeKeys);
    }
}
void InOrder (node *p_tree, int *currentCount)
{
    if (p_tree != nullptr)
    {
        InOrder (p_tree->p_left, currentCount);
        (*currentCount)++;
        InOrder (p_tree->p_right, currentCount);
    }
}
void checkTreeBalanced(node *p_tree)
{
    int left_depth, right_depth;
    int left_count, right_count;
    int temp_depth, temp_count;

    if ( p_tree != nullptr )
    {
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            temp_depth = ( right_depth - left_depth );
        }
        else
        {
            temp_depth = ( left_depth - right_depth );
        }
        if (left_count < right_count)
        {
            temp_count = ( right_count - left_count );
        }
        else
        {
            temp_count = ( left_count - right_count );
        }
        if (temp_depth >= -1 && temp_depth <= 1)
        {
            cout << "checkTreeBalanced: " << temp_depth << ", " << temp_count << " is balanced\n";
        }
        else
        {
            cout << "checkTreeBalanced: " << temp_depth << ", " << temp_count << " is not balanced\n";
        }
    }
}
bool checkTreeSorted(node *p_tree)
{
    bool temp_result;

    if (p_tree == nullptr)
    {
        return true;
    }
    if (p_tree->p_left == nullptr && p_tree->p_right == nullptr)
    {
        return true;
    }

    if (p_tree->p_left != nullptr && p_tree->p_left->key_value > p_tree->key_value)
    {

        cout << "checkTreeSorted left = " << p_tree->p_left->key_value << " > " << p_tree->key_value << '\n';
        return false;
    }
    if (p_tree->p_right != nullptr && p_tree->p_right->key_value < p_tree->key_value)
    {
        cout << "checkTreeSorted right = " << p_tree->p_right->key_value << " < " << p_tree->key_value << '\n';
        return false;
    }
    return ( checkTreeSorted(p_tree->p_left) && checkTreeSorted(p_tree->p_right) );
}
void destroy_tree (node *p_tree)
{
    if ( p_tree != nullptr )
    {
        destroy_tree( p_tree->p_left );
        destroy_tree( p_tree->p_right );
        delete p_tree;
    }
}

node *find_max (node *p_tree)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->p_right == nullptr )
    {
        return p_tree;
    }
    else
    {
        return find_max( p_tree->p_right );
    }
}
node *remove_max_node (node *p_tree, node *p_max_node)
{
    int left_depth, right_depth;
    int left_count, right_count;

    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree == p_max_node )
    {
        return p_max_node->p_left;
    }
    else
    {
        p_tree->p_right = remove_max_node( p_tree->p_right, p_max_node);
        if (p_tree->p_right != nullptr)
        {
            p_tree->p_right->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
}
node *remove (node *p_tree, int key)
{
    int left_depth, right_depth;
    int left_count, right_count;

    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->key_value == key )
    {
        if ( p_tree->p_left == nullptr )
        {
            node *p_right_subtree = p_tree->p_right;
            delete p_tree;
            return p_right_subtree;
        }
        if ( p_tree->p_right == nullptr )
        {
            node *p_left_subtree = p_tree->p_left;
            delete p_tree;
            return p_left_subtree;
        }
        node *p_left_subtree = p_tree->p_left;
        node *p_right_subtree = p_tree->p_right;
        node *p_max_node = find_max( p_left_subtree );
        p_max_node->p_left = remove_max_node( p_tree->p_left, p_max_node );
        if (p_max_node->p_left != nullptr)
        {
            p_max_node->p_left->p_parent = p_max_node;
        }
        p_max_node->p_right = p_right_subtree;
        if (p_max_node->p_right != nullptr)
        {
            p_max_node->p_right->p_parent = p_max_node;
        }
        if (p_max_node->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_max_node->p_left->depth_of_node;
            left_count = p_max_node->p_left->count_of_nodes;
        }
        if (p_max_node->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_max_node->p_right->depth_of_node;
            right_count = p_max_node->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_max_node->depth_of_node = right_depth + 1;
        }
        else
        {
            p_max_node->depth_of_node = left_depth + 1;
        }
        p_max_node->count_of_nodes = left_count + right_count + 1;
        delete p_tree;
        return p_max_node;
    }
    else if ( key < p_tree->key_value )
    {
        p_tree->p_left = remove( p_tree->p_left, key);
        if (p_tree->p_left != nullptr)
        {
            p_tree->p_left->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
    else
    {
        p_tree->p_right = remove( p_tree->p_right, key);
        if (p_tree->p_right != nullptr)
        {
            p_tree->p_right->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
}
显示结果如下
Please specify the number of nodes to create for the binary tree (between 1 and 100):
7
Display the binary tree
Node: 3, 7: 1519458534
checkTreeBalanced: 1, 0 is balanced
Left
Node: 3, 7: 1519458534-1, 3: 511732848
checkTreeBalanced: 0, 0 is balanced
Left
Node: 3, 7: 1519458534-1, 3: 511732848-0, 1: 46182614
checkTreeBalanced: 0, 0 is balanced
Left
Node: 3, 7: 1519458534-1, 3: 511732848-0, 1: 46182614-null
Right
Node: 3, 7: 1519458534-1, 3: 511732848-0, 1: 46182614-null
Right
Node: 3, 7: 1519458534-1, 3: 511732848-0, 1: 625710536
checkTreeBalanced: 0, 0 is balanced
Left
Node: 3, 7: 1519458534-1, 3: 511732848-0, 1: 625710536-null
Right
Node: 3, 7: 1519458534-1, 3: 511732848-0, 1: 625710536-null
Right
Node: 3, 7: 1519458534-2, 3: 1768592983
checkTreeBalanced: 2, 2 is not balanced
Left
Node: 3, 7: 1519458534-2, 3: 1768592983-null
Right
Node: 3, 7: 1519458534-2, 3: 1768592983-1, 2: 1996110060
checkTreeBalanced: 1, 1 is balanced
Left
Node: 3, 7: 1519458534-2, 3: 1768592983-1, 2: 1996110060-0, 1: 1840412424
checkTreeBalanced: 0, 0 is balanced
Left
Node: 3, 7: 1519458534-2, 3: 1768592983-1, 2: 1996110060-0, 1: 1840412424-null
Right
Node: 3, 7: 1519458534-2, 3: 1768592983-1, 2: 1996110060-0, 1: 1840412424-null
Right
Node: 3, 7: 1519458534-2, 3: 1768592983-1, 2: 1996110060-null

Display tree in sorted order
Node: 46182614
Node: 511732848
Node: 625710536
Node: 1519458534
Node: 1768592983
Node: 1840412424
Node: 1996110060


Node: 46182614
Node: 625710536
Node: 511732848
Node: 1840412424
Node: 1996110060
Node: 1768592983
Node: 1519458534


Node: 1519458534
Node: 511732848
Node: 46182614
Node: 625710536
Node: 1768592983
Node: 1996110060
Node: 1840412424

Display tree in reverse sorted order
Node: 1996110060
Node: 1840412424
Node: 1768592983
Node: 1519458534
Node: 625710536
Node: 511732848
Node: 46182614

Check tree is sorted
The tree is sorted
46182614
625710536
511732848
1840412424
1996110060
1768592983
1519458534

6.实现一个简单的映射，它以二叉树形式保存地址簿。该映射的键值应该是联系人的姓名，映射的值是联系人的邮箱地址。
可以在映射中添加、删除，修改、查看邮箱地址。

#include <cstdlib>
#include <ctime>
#include <iostream>
#include <string>

using namespace std;

struct node
{
    int depth_of_node;
    int count_of_nodes;
    string key;
    string value;
    node *p_parent;
    node *p_left;
    node *p_right;
};

node *insert (node *p_tree, string key, string value);
node *search (node *p_tree, string key);
void destroy_tree (node *p_tree);
node *remove (node *p_tree, string key);
node *find_max (node *p_tree);
node *remove_max_node (node *p_tree, node *p_max_node);

node* add_entry(node* p_tree);
node* update_entry(node* p_tree);
node* delete_entry(node* p_tree);
void display_entry(node* p_tree);

void printSorted(node *tree);
void InOrder (node *p_tree, int *currentCount, string nodeKeys[]);
void InOrderNonRecursive (node *p_tree, int *currentCount, string nodeKeys[]);
void postOrderNonRecursive (node *p_tree, int *currentCount, string nodeKeys[]);
void preOrderNonRecursive (node *p_tree, int *currentCount, string nodeKeys[]);
void destroyTreePostOrder (node *p_tree);

const int maxNumberOfNodes = 100;

int main()
{
    node *tree = nullptr;
    bool exitProgram = false;
    int choice = 0;
    int numberOfNodes = 0;

    while(!exitProgram)
    {
        choice = 0;
        if (tree == nullptr)
        {
            numberOfNodes = 0;
        }
        else
        {
            numberOfNodes = tree->count_of_nodes;
        }
        cout << "Please choose from the following options:\n";
        cout << "0. Exit\n";
        cout << "1. Add entry\n";
        if (numberOfNodes > 0)
        {
            cout << "2. Update entry\n";
            cout << "3. Delete entry\n";
            cout << "4. Display entry\n";
        }
        cin >> choice;
        cin.clear();
        cin.ignore(80, '\n');

        cout << '\n';

        switch (choice)
        {
        case 0:
            exitProgram = true;
            break;
        case 1:
            tree = add_entry(tree);
            cout << "Display tree in sorted order\n";
            printSorted(tree);
            cout << '\n';
            break;
        case 2:
            tree = update_entry(tree);
            cout << "Display tree in sorted order\n";
            printSorted(tree);
            cout << '\n';
            break;
        case 3:
            tree = delete_entry(tree);
            cout << "Display tree in sorted order\n";
            printSorted(tree);
            cout << '\n';
            break;
        case 4:
            display_entry(tree);
            break;
        default:
            exitProgram = true;
            break;
        }
    }

    destroyTreePostOrder(tree);
}

void printSorted(node *tree)
{
    int currentCount = 0;
    string nodeKeys[maxNumberOfNodes];
    InOrder (tree, &currentCount, nodeKeys);

    for (int i = 0; i < currentCount; i++)
    {
        cout << "key | value = " << nodeKeys[i] << '\n';
    }
    cout <<"\n\n";
}

node *insert (node *p_tree, string key, string value)
{
    int left_depth, right_depth;
    int left_count, right_count;

    if ( p_tree == nullptr )
    {
        node *p_new_tree = new node;
        p_new_tree->depth_of_node = 0;
        p_new_tree->count_of_nodes = 1;
        p_new_tree->p_parent = nullptr;
        p_new_tree->p_left = nullptr;
        p_new_tree->p_right = nullptr;
        p_new_tree->key = key;
        p_new_tree->value = value;
        return p_new_tree;
    }
    if ( key == p_tree->key )
    {
        p_tree->value = value;
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
    else if( key < p_tree->key )
    {
        p_tree->p_left = insert( p_tree->p_left, key, value);
        if (p_tree->p_left != nullptr)
        {
            p_tree->p_left->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
    else
    {
        p_tree->p_right = insert( p_tree->p_right, key, value );
        if (p_tree->p_right != nullptr)
        {
            p_tree->p_right->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
}

node *search (node *p_tree, string key)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    else if ( key == p_tree->key )
    {
        return p_tree;
    }
    else if ( key < p_tree->key )
    {
        return search( p_tree->p_left, key );
    }
    else
    {
        return search( p_tree->p_right, key );
    }
}
void preOrderNonRecursive (node *p_tree, int *currentCount, string nodeKeys[])
{
   node *last_node;
    node *check_node;

    if (p_tree == nullptr)
    {
        return;
    }
    last_node = nullptr;
    check_node = p_tree;
    nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
    (*currentCount)++;
    if (check_node->p_left != nullptr)
    {
        last_node = check_node;
        check_node = check_node->p_left;
    }
    else
    {
        if (check_node->p_right != nullptr)
        {
            last_node = check_node;
            check_node = check_node->p_right;
        }
        else
        {
            return;
        }
    }
    while(last_node != nullptr && check_node != nullptr)
    {
        if(last_node == check_node->p_parent)
        {
            nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
            (*currentCount)++;
            if (check_node->p_left != nullptr)
            {
                last_node = check_node;
                check_node = check_node->p_left;
            }
            else
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
        }
        else
        {
            if(last_node == check_node->p_left)
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
            else
            {
                last_node = check_node;
                check_node = check_node->p_parent;
            }
        }
    }
}
void postOrderNonRecursive (node *p_tree, int *currentCount, string nodeKeys[])
{
    node *last_node;
    node *check_node;

    if (p_tree == nullptr)
    {
        return;
    }
    last_node = nullptr;
    check_node = p_tree;
    if (check_node->p_left != nullptr)
    {
        last_node = check_node;
        check_node = check_node->p_left;
    }
    else
    {
        if (check_node->p_right != nullptr)
        {
            last_node = check_node;
            check_node = check_node->p_right;
        }
        else
        {
            nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
            (*currentCount)++;
            return;
        }
    }
    while(last_node != nullptr && check_node != nullptr)
    {
        if(last_node == check_node->p_parent)
        {
            if (check_node->p_left != nullptr)
            {
                last_node = check_node;
                check_node = check_node->p_left;
            }
            else
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
                    (*currentCount)++;
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
        }
        else
        {
            if(last_node == check_node->p_left)
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
                    (*currentCount)++;
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
            else
            {
                nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
                (*currentCount)++;
                last_node = check_node;
                check_node = check_node->p_parent;
            }
        }
    }
}
void destroyTreePostOrder (node *p_tree)
{
    node *last_node;
    node *check_node;
    node *temp_node;

    if (p_tree == nullptr)
    {
        return;
    }
    last_node = nullptr;
    check_node = p_tree;
    if (check_node->p_left != nullptr)
    {
        last_node = check_node;
        check_node = check_node->p_left;
    }
    else
    {
        if (check_node->p_right != nullptr)
        {
            last_node = check_node;
            check_node = check_node->p_right;
        }
        else
        {
            temp_node = check_node;
            cout << temp_node->key << '\n';
            delete temp_node;
            return;
        }
    }
    while(last_node != nullptr && check_node != nullptr)
    {
        if(last_node == check_node->p_parent)
        {
            if (check_node->p_left != nullptr)
            {
                last_node = check_node;
                check_node = check_node->p_left;
            }
            else
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    temp_node = check_node;
                    last_node = check_node;
                    check_node = check_node->p_parent;
                    cout << temp_node->key << '\n';
                    delete temp_node;
                }
            }
        }
        else
        {
            if(last_node == check_node->p_left)
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    temp_node = check_node;
                    last_node = check_node;
                    check_node = check_node->p_parent;
                    cout << temp_node->key << '\n';
                    delete temp_node;
                }
            }
            else
            {
                temp_node = check_node;
                last_node = check_node;
                check_node = check_node->p_parent;
                cout << temp_node->key << '\n';
                delete temp_node;
            }
        }
    }
}
void InOrderNonRecursive (node *p_tree, int *currentCount, string nodeKeys[])
{
    node *last_node;
    node *check_node;

    if (p_tree == nullptr)
    {
        return;
    }
    last_node = nullptr;
    check_node = p_tree;
    if (check_node->p_left != nullptr)
    {
        last_node = check_node;
        check_node = check_node->p_left;
    }
    else
    {
        nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
        (*currentCount)++;
        if (check_node->p_right != nullptr)
        {
            last_node = check_node;
            check_node = check_node->p_right;
        }
        else
        {
            return;
        }
    }
    while(last_node != nullptr && check_node != nullptr)
    {
        if(last_node == check_node->p_parent)
        {
            if (check_node->p_left != nullptr)
            {
                last_node = check_node;
                check_node = check_node->p_left;
            }
            else
            {
                nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
                (*currentCount)++;
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
        }
        else
        {
            if(last_node == check_node->p_left)
            {
                nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
                (*currentCount)++;
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
            else
            {
                last_node = check_node;
                check_node = check_node->p_parent;
            }
        }
    }
}

void InOrder (node *p_tree, int *currentCount, string nodeKeys[])
{
    if (p_tree != nullptr)
    {
        InOrder (p_tree->p_left, currentCount, nodeKeys);
        nodeKeys[ (*currentCount) ] = p_tree->key + " | " + p_tree->value;
        (*currentCount)++;
        InOrder (p_tree->p_right, currentCount, nodeKeys);
    }
}

void destroy_tree (node *p_tree)
{
    if ( p_tree != nullptr )
    {
        destroy_tree( p_tree->p_left );
        destroy_tree( p_tree->p_right );
        delete p_tree;
    }
}

node *find_max (node *p_tree)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->p_right == nullptr )
    {
        return p_tree;
    }
    else
    {
        return find_max( p_tree->p_right );
    }
}
node *remove_max_node (node *p_tree, node *p_max_node)
{
    int left_depth, right_depth;
    int left_count, right_count;

    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree == p_max_node )
    {
        return p_max_node->p_left;
    }
    else
    {
        p_tree->p_right = remove_max_node( p_tree->p_right, p_max_node);
        if (p_tree->p_right != nullptr)
        {
            p_tree->p_right->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
}
node *remove (node *p_tree, string key)
{
    int left_depth, right_depth;
    int left_count, right_count;

    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->key == key )
    {
        if ( p_tree->p_left == nullptr )
        {
            node *p_right_subtree = p_tree->p_right;
            delete p_tree;
            return p_right_subtree;
        }
        if ( p_tree->p_right == nullptr )
        {
            node *p_left_subtree = p_tree->p_left;
            delete p_tree;
            return p_left_subtree;
        }
        node *p_left_subtree = p_tree->p_left;
        node *p_right_subtree = p_tree->p_right;
        node *p_max_node = find_max( p_left_subtree );
        p_max_node->p_left = remove_max_node( p_tree->p_left, p_max_node );
        if (p_max_node->p_left != nullptr)
        {
            p_max_node->p_left->p_parent = p_max_node;
        }
        p_max_node->p_right = p_right_subtree;
        if (p_max_node->p_right != nullptr)
        {
            p_max_node->p_right->p_parent = p_max_node;
        }
        if (p_max_node->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_max_node->p_left->depth_of_node;
            left_count = p_max_node->p_left->count_of_nodes;
        }
        if (p_max_node->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_max_node->p_right->depth_of_node;
            right_count = p_max_node->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_max_node->depth_of_node = right_depth + 1;
        }
        else
        {
            p_max_node->depth_of_node = left_depth + 1;
        }
        p_max_node->count_of_nodes = left_count + right_count + 1;
        delete p_tree;
        return p_max_node;
    }
    else if ( key < p_tree->key )
    {
        p_tree->p_left = remove( p_tree->p_left, key);
        if (p_tree->p_left != nullptr)
        {
            p_tree->p_left->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
    else
    {
        p_tree->p_right = remove( p_tree->p_right, key);
        if (p_tree->p_right != nullptr)
        {
            p_tree->p_right->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
}

void display_entry(node *p_tree)
{
    string name = "";
    node *temp_node;

    do
    {
        name = "";
        cout << "Please enter a name from the address book to display:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( temp_node = search(p_tree, name) ) == nullptr )
        {
            cout << "The name can not find in the address book.\n";
            continue;
        }

        cout << '\n';
        cout << name << " | " << temp_node->value << "\n\n";
    }
    while (name != "");
}
node *add_entry(node *p_tree)
{
    string name = "";
    string email = "";
    node *temp_node;

    do
    {
        name = "";
        cout << "Please enter a name for the address book:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( temp_node = search(p_tree, name) ) != nullptr )
        {
            cout << "The name already exists.\n";
            cout << "Please enter a unique name to add.\n";
            continue;
        }
        email = "";
        cout << "Please enter an email address for the name:\n";
        getline(cin, email, '\n');
        if (email == "")
        {
            break;
        }

        p_tree = insert(p_tree, name, email);
        cout << "\n\n";
    }
    while (name != "");

    return p_tree;
}
node *update_entry(node *p_tree)
{
    string name = "";
    string email = "";
    node *temp_node;

    do
    {
        name = "";
        cout << "Please enter a name to update:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( temp_node = search(p_tree, name) ) == nullptr )
        {
            cout << "The name can not find in the address book.\n";
            cout << "Please enter an existing name to update.\n";
            continue;
        }
        email = "";
        cout << "Please enter a new email address for the name:\n";
        getline(cin, email, '\n');
        if (email == "")
        {
            break;
        }

        p_tree = insert(p_tree, name, email);
        cout << "\n\n";
    }
    while (name != "");

    return p_tree;
}
node *delete_entry(node *p_tree)
{
    string name = "";
    node *temp_node;

    do
    {
        name = "";
        cout << "Please enter a name to delete:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( temp_node = search(p_tree, name) ) == nullptr )
        {
            cout << "The name can not find in the address book.\n";
            cout << "Please enter an existing name to delete.\n";
            continue;
        }

        p_tree = remove(p_tree, name);
        cout << name << " has been removed from the address book.\n\n";
    }
    while (name != "");

    return p_tree;
}
显示结果如下
Please choose from the following options:
0. Exit
1. Add entry
1

Please enter a name for the address book:
WEIYAYUN
Please enter an email address for the name:
1043836212@qq.com


Please enter a name for the address book:
Peter Smith
Please enter an email address for the name:
123456789@qq.com


Please enter a name for the address book:
Hello world
Please enter an email address for the name:
abcdefg@qq.com


Please enter a name for the address book:

Display tree in sorted order
key | value = Hello world | abcdefg@qq.com
key | value = Peter Smith | 123456789@qq.com
key | value = WEIYAYUN | 1043836212@qq.com



Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
2

Please enter a name to update:
WEIYAYUN
Please enter a new email address for the name:
hijklmn@qq.com


Please enter a name to update:

Display tree in sorted order
key | value = Hello world | abcdefg@qq.com
key | value = Peter Smith | 123456789@qq.com
key | value = WEIYAYUN | hijklmn@qq.com



Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
4

Please enter a name from the address book to display:
Peter Smith

Peter Smith | 123456789@qq.com

Please enter a name from the address book to display:
Hello world

Hello world | abcdefg@qq.com

Please enter a name from the address book to display:

Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
3

Please enter a name to delete:
Hello world
Hello world has been removed from the address book.

Please enter a name to delete:
Peter Smith
Peter Smith has been removed from the address book.

Please enter a name to delete:

Display tree in sorted order
key | value = WEIYAYUN | hijklmn@qq.com



Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
3

Please enter a name to delete:
WEIYAYUN
WEIYAYUN has been removed from the address book.

Please enter a name to delete:

Display tree in sorted order



Please choose from the following options:
0. Exit
1. Add entry
0

第18章 标准模板库
能够写自己的数据结构简直是太棒了。不过，后面几章你会发现，我 们很少亲自写数据结构。
别担心，我不会让你白用功的。你现在学会了很多如何在需要时构建自己的数据结构的知识，了解了几种常见的数据结构的特点。
有时候，构建自己的数据结构是很有必要的。
C++较之C语言强大的功能之一是，C++编译器自带了大量的可复用代码库，我们称为标准模板库（standard template library）STL。
标准模板库是一套常用的数据结构的集合，包括链表和一些基于二叉树的数据结构。
这些数据结构允许你在创建时指定它们的数据类型，所以可以使用它们来存储任何类型的数据――整型、字符串、或结构体等都可以。
因为这种灵活性，在很多情况下我们可以不用为了完成基本的编程需求构建自己的数据结构，而是用标准模板库来代替。
STL可以在几个重要方面提高你的代码层次：
1.你可以开始从需要的数据结构角度来思考问题，而不必担心自己想要的数据结构能否实现；
2.你可以随时使用这些顶级的数据结构，对大多数问题而言，其性能都非常好，所占空间也很少；
3.你不用担心所使用的数据结构进行内存分配和释放等操作的细节。
不过，使用标准模板库也有一些代价：
1.你需要了解标准模板库的各种接口，并学习如何使用它们；
2.错误使用标准模板库所造成的编译错误理解起来不是很容易；
3.并不是每一个你想要的数据结构标准模板库中都有。
标准模板库是一个很大的话题――有些书专讲STL，所以我的讲述不可能面面俱到。
本章的目的是向你介绍一下标准模板库中最常用的数据结构。在这以后，我会在适当的时候使用这些数据结构。
18.1 vector，大小可变的数组
在STL中有一个称为vector的数据结构，可以用来代替数组。
vector跟数组非常相似，只不过vector的大小可以自动调整，不需要编程人员关心内存分配和已存在元素的移动等细节问题。
使用vector的语法和使用数组的语法不一样。以下是声明一个数组和声明一个vector的对比：
int an_array[ 10 ];
与：
#include <vector>  
 
using namespace std;

vector<int> a_vector( 10 );
首先，你需要包含（include）头文件vector，以便能随时使用vector数据结构。
你还需要使用命名空间（namespace）std，因为vector跟cin和cout类似，都是标准库的一部分。
其次，当你声明一个vector时，必须在尖括号中标识出想要在vector中存储的数据类型：
vector<int> 
这个语法使用了C++的一个特性――模板（故名标准模板库）。 
vector的实现方式允许它存储任何类型的数据，只要告诉编译器，该vector将存储哪种类型的数据即可。
换句话说，这里实际上涉及两种类型：一种是所使用的数据结构的类型，它决定了数据的组织方式，
另一种是存储在该数据结构中的数据的类型。模板可以组合不同类型的数据结构与存储在该数据结构中的不同的数据类型。
最后，vector的大小放在圆括号中，而不是方括号：
vector<int> a_vector( 10 );
我们使用到这个语法来初始化某个类型的变量。在此例中，我们将值10传给一个初始化例程，称为构造函数，
该构造函数将构建一个大小为10的vector。接下来的几章中，我们将了解更多关于构造函数和对象的知识。
一旦构建好了自己的vector，你便能用和访问数组的同样方式来访问 vector中的每个元素了：
for ( int i = 0; i < 10; i++ )
{
    a_vector[ i ] = 0;
    an_array[ i ] = 0;
}
18.1.1 vector的方法调用
vector中提供的功能比数组要多得多。你可以做诸如在vector的末尾添加新元素这样的事情，vector提供了执行这些操作的函数。
使用这些函数的语法和你以前所见过的不同。vector利用了C++的一个特性， 叫做方法（method），它是一个随着变量类型
（在此例中，这个变量类型为vector）一起声明的函数。调用一个方法要使用新的语法，如下：
a_vector.size();
这段代码调用了a_vector的方法size，返回该vector的大小。这有点像访问一个结构体的域，所不同的是，你访问的不是域，
而是该结构的方法。尽管size方法显然要对a_vector做一些操作，但你并不需要将a_vector作为一个参数传递给size方法。
方法的语法知道要将a_vector作为一个隐含的参数传给size方法。
你可以看做这样的语法：
<variable>.<function call>( <args> );
就好像调用一个属于variable类型的函数一样。换句话说，它有点像写成这样：
<function call>( <variable>, <args> );
本例中，
a_vector.size();
就像是：
size( a_vector );
接下来的几章会继续介绍方法，以及如何声明和使用它们。
现在你只需要知道，在vector中有很多方法可以调用，并且调用它们需要使用特殊的语法。
这个特殊的语法是进行这种函数调用的唯一方式――你不能写成size(a_vector)。
18.1.2 vector的其他功能
vector还有哪些强大的功能呢？vector可以很容易地增加它所存储的值的数目，无需做任何烦琐的内存分配操作。
例如，你若想添加更多的元素到vector中，可以这样写：
a_vector.push_back( 10 );
这个语句增加一个新元素到vector中。具体来说，它指的是，“添加元素10到当前vector的末尾”。
vector本身会处理所有的调整大小操作。 要是在数组中做这件事，你就必须分配新内存，将所有的值复制过去，最后再添加上你的新元素。当然，vector内部也要分配内存和复制元素，但它会选择一种聪明的大小分配方式，
使得如果你不断地添加新元素的话，vector不会每次都重新调整内存大小。
提醒一句：尽管你可以使用push_back添加新元素到vector的末尾，但不能简单地使用方括号来获得相同的效果。
这是语言定义的一个怪癖：方括号只能用来处理已经分配的内存。究其原因可能是为了避免用户代码在无意识下进行内存分配。
因此，像这样的代码：
vector<int> a_vector( 10 );
a_vector[ 10 ] = 10;
实际上其效果不会实现，反倒可能会使程序崩溃，是相当危险的。然而，这样写：
vector<int> a_vector( 10 );
a_vector.push_back( 10 );
vector的大小会重新调整，成为11。
18.2 map
我们已经初步介绍了一下map的概念――根据一个值来找到另一个 值。这种例子在编程中随处可见：
实现一个可以按名称查找邮箱地址的电子邮件地址簿，通过账号查找账户信息，或是允许用户登录游戏，等等。
STL提供了非常方便的map类型，允许指定键（key）和值（value） 的类型。
例如，一个用来保存简单的电子邮件地址簿的数据结构，类似于你在上一章练习中做过的，可以这样来实现：
#include <map>
#include <string>  
 
using namespace std;  
 
map<string, string> name_to_email;
这里，我们需要告诉map数据结构两个不同的类型：第一个类型string，指的是键的类型；
第二个类型也是string，指的是值的类型，本例中指邮箱地址。
STL的map有一个很大的特点是，你可以使用跟数组相同的语法，来真正的使用map。
添加一个值到map中的语法跟数组一样，所不同的是，方括号内还可以是一个有效的key：
name_to_email[ "Alex Allain" ] = "webmaster@cprogramming.com";
访问map中的值的语法几乎完全一样：
cout << name_to_email[ "Alex Allain" ];
真是太方便了！跟使用数组一样简单，却可以存储任何类型的数据。 
更妙的是，与vector不同，你甚至不需要在使用[]操作符来添加元素之前，先设置map的大小。
你还可以很轻松地从map中删除元素。
如果不想再给我发邮件了，就可以用erase方法把我从你的地址簿中删 除：
name_to_email.erase( “Alex Allain” );
你也可以用size方法来查看map的大小：
name_to_address.size();
还可以用empty方法来检查一个map是否为空：
if ( name_to_address.empty() )
{
    cout << "You have an empty address book\n";
}
使用clear方法可以将map真正清除，这太直观了，你肯定不会弄错：
name_to_address.clear();
顺便说一下，STL容器使用一致的命名约定，因此你也可以在vector 上使用clear、empty和size方法，跟在map上使用的方式一样。 
18.3 迭代器（Iterator） 
除了存储数据和访问单个元素，有时你可能只是希望遍历某个特定的数据结构中的每个元素。
对于数组或vector容器，你可以利用数组的长度来读取每个单独的元素。但是，对于map容器，该怎么办呢？
由于map里的键常常不是数字，所以我们不能总是通过一个计数器变量来遍历map中的所有键值。
STL有一个称为迭代器（iterator）的变量专门解决上述问题。
迭代器允许你顺次访问任何给定的数据结构中的每个元素，即使该数据结构并未提供做这件事的简单方法。
我们先来看看怎样使用一个vector的迭代器，然后再学习如何使用一个迭代器来访问map的元素。
迭代器的基本思想是：迭代器变量中存储了数据结构的某个元素的位置，使得你能够访问该位置上的元素。
通过调用迭代器提供的方法，可以继续访问数据结构中的下一个元素。
声明一个整型vector的迭代器需要用到特殊的语法，示例如下：
vector<int>::iterator
这个语法大意是说：现在有了一个整型的vector（vector<int>），
我们还希望拥有一个能处理它的迭代器，因此用::iterator来表示。
那么，迭代器要如何使用呢？由于迭代器中存储着数据结构的某个元素的位置，可以像这样来请求该数据结构的一个迭代器：
vector<int> vec;
vec.push_back( 1 );
vec.push_back( 2 );  
 
vector<int>::iterator itr = vec.begin();
调用begin方法将返回一个迭代器，通过它能访问到vector的第一个元素。
实际上，可以把迭代器看做一个指针――你可以通过它得到数据结构的某个元素的位置，亦可以使用它来访问该元素。
回到刚才的例 子，我们可以使用如下语法来访问vector的第一个元素：
cout << *itr;   // 输出vector的第一个元素
这里对*运算符的使用，仿佛是在使用指针似的。 这真是太棒了：迭代器跟指针一样，都是位置存储的一种方式。
要获得vector的下一个元素，只需要增加你的迭代器即可：
itr++;
这相当于命令迭代器前往vector的下一个元素。
也可以使用前缀运算符：
++itr;
这种做法在某些迭代器中效率会更高一些。
其原因是，前缀运算符（++itr）先做增量，然后返回表达式的值， 
而如果你使用后缀运算符（itr++），它返回的是增量前的itr值，这意味着可能有保存旧值的需要。
前缀运算符已经具有需要返回的值，因为它包含着运算的结果。
通过对比当前的迭代器和末端迭代器，我们可以检查是否已经到达迭代遍历的结尾。调用迭代器的end方法可以获得末端迭代器：
vec.end();
因此，循环遍历整个vector的代码可以这样写：
for ( vector<int>::iterator itr = vec.begin(); itr != vec.end(); ++itr )
{
    cout << *itr << endl;
}
这段代码表示：创建一个迭代器，并获得整型vector的第一个元素； 
当前迭代器不等于末端迭代器时，继续对vector的迭代。输出每个元素。
我们要对这个循环做几个小小的改进。应该避免每次循环时都调用一 次vec.end()：
vector<int>::iterator end = vec.end();
for ( vector<int>::iterator itr = vec.begin(); itr != end; ++itr )
{
    cout << *itr << endl;
}
实际上，可以将多个变量放到循环的第一个部分中，使代码看起来更整洁些：
for ( vector<int>::iterator itr = vec.begin(), end = vec.end(); itr != end; ++itr )
{
    cout << *itr << endl;
}
我们可以用非常相似的方法来遍历一个map。不过，map的一个元素里不仅仅只有一个值，而是两个：键和值。
这样的话，该怎样使用map的迭代器呢？当你间接引用map的迭代器时，它有两个域：first 和second。
域first为键，而second为对应的值。
string key = itr->first;   // 从迭代器中获得键
string value = itr->second;   // 从迭代器中获得值
来看一段代码，它将map中的内容以较强的可读性输出出来：
void displayMap (map<string, string> map_to_print)
{
    for ( map<string, string>::iterator itr = map_to_print.begin(), end = map_to_print.end(); itr != end; ++itr )
    {
        cout << itr->first << " --> " << itr->second << endl;
    }
}
这段代码与遍历vector的代码极其相似，真正唯一的区别是map数据结构的使用和迭代器的first和second域的使用。
检查一个值是否在map中
有时候，你会想要检查给定的键是否已经存储在一个map中了。
例如，如果你正在通讯簿中查找某人，可能想知道那个人是否真的在通讯簿中。
这时，find方法正是你需要的。find方法返回一个迭代器：
map<string, string>::iterator itr = name_to_email.find( "Alex Allain" );
if ( itr != name_to_email.end() )
{
    cout << "How nice to see Alex again. His email is: " << itr->second << '\n';
}
如果给定的键存在，则返回的是一个持有该键对应的对象位置的迭代器；如果给定的键不存在，返回末端迭代器。
另外，如果你尝试使用普通的方括号运算符访问一个map中不存在的元素：
name_to_email[ "John Doe" ];
那么，map会为你插入这个新的元素，对应的值为空。
所以，如果你真的需要知道一个值是否在map中，请使用find方法；除此之外，可以安全地使用方括号运算符。
18.4 盘点STL
我们还有很多STL的知识没有讲，但你现在已经掌握了充分利用STL类型的许多基础知识。
vector类型是数组的完美替代品。当不需要太在乎插入和修改列表的时间开销时，vector也可以用来取代链表。
只有在极少数高级应用，如文件输入输出的情况下，你会选择使用数组而不是vector。
map可能是目前为止最好的一个数据类型了。我经常使用类似map的结构，它使得编写复杂的程序变得更自然，
因为你不再需要担心如何创建许多的数据类型。相反，你可以专注于如何解决要解决的问题。
在许多方面，map可以取代基本的二叉树――大多数情况下你不用实现自己的二叉树，
除非为了特定的性能要求，或者真的需要使用树形结构。
这就是STL真正厉害之处――大多数情况下，STL提供了核心的数据结构，因此你可以马上动手编写代码，解决特定问题；
其他情况下，可能需要自己实现数据结构。
在大多数情况下，你不应该自己去实现数据结构――自带的数据结构通常比自己写的要好，速度更快且更完整。 
但知道如何建立它们会让你更深入地了解如何使用它们，以及如何在确实需要的时候创建自己的数据结构。
那么，何时需要自己实现数据结构呢？
假设你想写一个小型计算器， 它可以让用户输入算术表达式并依照正确的计算顺序求出表达式的值。
例如，读入5 * 8 + 9 / 3这样的表达式，然后计算它的值，计算顺序是先乘除、后加减。
事实证明，人们往往自然而然地想到采用树状结构来解决这个问题：
                           +
                  *                  /
         5         8         9         3
以下面这两种方式来计算每个节点：
1.如果是一个数字，则返回它的值。
2.如果是一个运算符，则计算两个子树的值，并执行该运算。
建立这样一棵树，需要使用原始的数据结构。这时候，仅使用map是不够的。
如果你唯一的工具是STL，就很难解决这个问题了。但如果你懂二叉树和递归，问题就简单多了。
18.5 进一步学习STL
如果你想更多地了解STL，以下是一些很好的资源。
SGI是一个包含大量STL文档的网站：http://www.sgi.com/tech/stl/； 
Scott Meyer的著作Effective STL同样很精彩，它介绍了很多STL的概念和惯用语。
网站http://en.cppreference.com/w/cpp也有很多关于STL的优秀文档。
但它提供的不是STL的入门资料，而是C++标准库的实用参考材料。
问答题
1.什么时候适合使用vector？
A.当你需要存储一个键和一个值之间的关联时
B.当你为了最大限度地提高性能而需要改变元素的集合时
C.当你不想关心数据结构进行更新的细节时
D.就好像面试要穿西装一样，使用vector总是没错的

C
2.怎样从一个map中一次性删除所有元素？
A.将元素设置为空
B.调用erase方法
C.调用empty方法
D.调用clear方法

D
3.什么时候你应该实现自己的数据结构？
A.当你速度要求很快的时候
B.当你需要鲁棒性强的时候
C.当你想要利用原始数据结构的优势时，比如建立一棵表达式树
D.你永远不需要实现自己的数据结构，除非你喜欢这么干

C
4.以下哪一项正确地声明了一个vector<int>的迭代器？
A. iterator<int> itr;
B. vector::iterator itr;
C. vector<int>::iterator itr;
D. vector<int>::iterator<int> itr;

C
5.以下哪一项正在访问一个map的迭代器的键？
A. itr.first
B. itr->first
C. itr->key
D. itr.key

B
6.怎样知道一个迭代器是否可用？
A.跟NULL进行比较
B.跟迭代的对象调用end()的结果进行比较
C.检查它是否等于0
D.跟迭代的对象调用begin()的结果进行比较

B
实践题
1.实现一个小型通讯录程序，用户可以输入姓名和电子邮件地址，删除或更新条目，以及显示通讯录中的所有条目。

#include <iostream>
#include <string>
#include <vector>
#include <map>

using namespace std;

map<string, string> &add_entry(map<string, string> &myMap);
map<string, string> &update_entry(map<string, string> &myMap);
map<string, string> &delete_entry(map<string, string> &myMap);
void display_entry(map<string, string> &myMap);
void print_all_entry(map<string, string> &myMap);
void get_all_entry(map<string, string> &myMap, vector<string> &entrys);

int main()
{
    map<string, string> myMap;

    bool exitProgram = false;
    int choice = 0;
    int numberOfNodes = 0;

    while (!exitProgram)
    {
        choice = 0;
        numberOfNodes = myMap.size();

        cout << "Please choose from the following options:\n";
        cout << "0. Exit\n";
        cout << "1. Add entry\n";
        if (numberOfNodes > 0)
        {
            cout << "2. Update entry\n";
            cout << "3. Delete entry\n";
            cout << "4. Display entry\n";
        }
        cin >> choice;
        cin.clear();
        cin.ignore(80, '\n');

        cout << '\n';

        switch (choice)
        {
        case 0:
            exitProgram = true;
            break;
        case 1:
            myMap = add_entry(myMap);
            cout << "Display address book\n";
            print_all_entry(myMap);
            break;
        case 2:
            myMap = update_entry(myMap);
            cout << "Display address book\n";
            print_all_entry(myMap);
            break;
        case 3:
            myMap = delete_entry(myMap);
            cout << "Display address book\n";
            print_all_entry(myMap);
            break;
        case 4:
            display_entry(myMap);
            break;
        default:
            exitProgram = true;
            break;
        }
    }

    myMap.clear();
}

void print_all_entry(map<string, string> &myMap)
{
    int numberOfNodes = myMap.size();
    if (numberOfNodes == 0)
    {
        return;
    }

    vector<string> entrys;
    get_all_entry(myMap, entrys);

    for (int i = 0; i < entrys.size(); i++)
    {
        cout << "key | value = " << entrys[i] << '\n';
    }
    cout << "\n\n";
}

void get_all_entry(map<string, string> &myMap, vector<string> &entrys)
{
    for (map<string, string>::iterator itr = myMap.begin(), end = myMap.end(); itr != end; ++itr)
    {
        entrys.push_back ( itr->first + " | " + itr->second );
    }
}


void display_entry(map<string, string> &myMap)
{
    string name = "";
    map<string, string>::iterator itr;

    do
    {
        name = "";
        cout << "Please enter a name from the address book to display:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( itr = myMap.find(name) ) == myMap.end() )
        {
            cout << "The name can not find in the address book.\n";
            continue;
        }

        cout << '\n';
        cout << name << " | " << itr->second << "\n\n";
    }
    while (name != "");
}

map<string, string> &add_entry(map<string, string> &myMap)
{
    string name = "";
    string email = "";
    map<string, string>::iterator itr;

    do
    {
        name = "";
        cout << "Please enter a name for the address book:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( itr = myMap.find(name) ) != myMap.end() )
        {
            cout << "The name already exists.\n";
            cout << "Please enter a unique name to add.\n";
            continue;
        }
        email = "";
        cout << "Please enter an email address for the name:\n";
        getline(cin, email, '\n');
        if (email == "")
        {
            break;
        }

        myMap[name] = email;
        cout << "\n\n";
    }
    while (name != "");

    return myMap;
}

map<string, string> &update_entry(map<string, string> &myMap)
{
    string name = "";
    string email = "";
    map<string, string>::iterator itr;

    do
    {
        name = "";
        cout << "Please enter a name to update:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( itr = myMap.find(name) ) == myMap.end() )
        {
            cout << "The name can not find in the address book.\n";
            cout << "Please enter an existing name to update.\n";
            continue;
        }
        email = "";
        cout << "Please enter a new email address for the name:\n";
        getline(cin, email, '\n');
        if (email == "")
        {
            break;
        }

        itr->second = email;
        cout << "\n\n";
    }
    while (name != "");

    return myMap;
}

map<string, string> &delete_entry(map<string, string> &myMap)
{
    string name = "";
    map<string, string>::iterator itr;

    do
    {
        name = "";
        cout << "Please enter a name to delete:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( itr = myMap.find(name) ) == myMap.end() )
        {
            cout << "The name can not find in the address book.\n";
            cout << "Please enter an existing name to delete.\n";
            continue;
        }

        myMap.erase(itr);
        cout << name << " has been removed from the address book.\n\n";
    }
    while (name != "");

    return myMap;
}
显示结果如下
Please choose from the following options:
0. Exit
1. Add entry
1

Please enter a name for the address book:
WEIYAYUN
Please enter an email address for the name:
1043836212@qq.com


Please enter a name for the address book:
Peter Smith
Please enter an email address for the name:
123456789@qq.com


Please enter a name for the address book:
Hello world
Please enter an email address for the name:
abcdefg@qq.com


Please enter a name for the address book:

Display address book
key | value = Hello world | abcdefg@qq.com
key | value = Peter Smith | 123456789@qq.com
key | value = WEIYAYUN | 1043836212@qq.com


Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
4

Please enter a name from the address book to display:
WEIYAYUN

WEIYAYUN | 1043836212@qq.com

Please enter a name from the address book to display:

Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
2

Please enter a name to update:
WEIYAYUN
Please enter a new email address for the name:
hijklmn@qq.com


Please enter a name to update:

Display address book
key | value = Hello world | abcdefg@qq.com
key | value = Peter Smith | 123456789@qq.com
key | value = WEIYAYUN | hijklmn@qq.com


Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
3

Please enter a name to delete:
Peter Smith
Peter Smith has been removed from the address book.

Please enter a name to delete:

Display address book
key | value = Hello world | abcdefg@qq.com
key | value = WEIYAYUN | hijklmn@qq.com


Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
0

2.实现一个电子游戏的高分榜。

#include <iostream>
#include <string>
#include <vector>
#include <map>

using namespace std;

map<string, double> &add_entry(map<string, double> &myMap);
map<string, double> &update_entry(map<string, double> &myMap);
map<string, double> &delete_entry(map<string, double> &myMap);
void display_entry(map<string, double> &myMap);
void print_all_entry(map<string, double> &myMap);
void get_all_entry(map<string, double> &myMap, vector<string> &entrys);

int main()
{
    map<string, double> myMap;

    bool exitProgram = false;
    int choice = 0;
    int numberOfNodes = 0;

    while (!exitProgram)
    {
        choice = 0;
        numberOfNodes = myMap.size();

        cout << "Please choose from the following options:\n";
        cout << "0. Exit\n";
        cout << "1. Add entry\n";
        if (numberOfNodes > 0)
        {
            cout << "2. Update entry\n";
            cout << "3. Delete entry\n";
            cout << "4. Display entry\n";
        }
        cin >> choice;
        cin.clear();
        cin.ignore(80, '\n');

        cout << '\n';

        switch (choice)
        {
        case 0:
            exitProgram = true;
            break;
        case 1:
            myMap = add_entry(myMap);
            cout << "Display high scores\n";
            print_all_entry(myMap);
            break;
        case 2:
            myMap = update_entry(myMap);
            cout << "Display high scores\n";
            print_all_entry(myMap);
            break;
        case 3:
            myMap = delete_entry(myMap);
            cout << "Display high scores\n";
            print_all_entry(myMap);
            break;
        case 4:
            display_entry(myMap);
            break;
        default:
            exitProgram = true;
            break;
        }
    }

    myMap.clear();
}

void print_all_entry(map<string, double> &myMap)
{
    int numberOfNodes = myMap.size();
    if (numberOfNodes == 0)
    {
        return;
    }

    vector<string> entrys;
    get_all_entry(myMap, entrys);

    for (int i = 0; i < entrys.size(); i++)
    {
        cout << "key | value = " << entrys[i] << '\n';
    }
    cout << "\n\n";
}

void get_all_entry(map<string, double> &myMap, vector<string> &entrys)
{
    for (map<string, double>::iterator itr = myMap.begin(), end = myMap.end(); itr != end; ++itr)
    {
        entrys.push_back ( itr->first + " | " + to_string ( itr->second ) );
    }
}


void display_entry(map<string, double> &myMap)
{
    string name = "";
    map<string, double>::iterator itr;

    do
    {
        name = "";
        cout << "Please enter a name to display:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( itr = myMap.find(name) ) == myMap.end() )
        {
            cout << "The name doesn't exist.\n";
            continue;
        }

        cout << '\n';
        cout << name << " | " << to_string ( itr->second ) << "\n\n";
    }
    while (name != "");
}

map<string, double> &add_entry(map<string, double> &myMap)
{
    string name = "";
    double score = 0.0;
    map<string, double>::iterator itr;

    do
    {
        name = "";
        cout << "Please enter a name:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( itr = myMap.find(name) ) != myMap.end() )
        {
            cout << "The name already exists.\n";
            cout << "Please enter a unique name to add.\n";
            continue;
        }
        score = 0.0;
        cout << "Please enter an score for the name:\n";
        cin >> score;
        cin.clear();
        cin.ignore(80, '\n');


        myMap[name] = score;
        cout << "\n\n";
    }
    while (name != "");

    return myMap;
}

map<string, double> &update_entry(map<string, double> &myMap)
{
    string name = "";
    double score = 0.0;
    map<string, double>::iterator itr;

    do
    {
        name = "";
        cout << "Please enter a name to update:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( itr = myMap.find(name) ) == myMap.end() )
        {
            cout << "The name doesn't exist.\n";
            cout << "Please enter an existing name to update.\n";
            continue;
        }
        score = 0.0;
        cout << "Please enter a new score for the name:\n";
        cin >> score;
        cin.clear();
        cin.ignore(80, '\n');

        itr->second = score;
        cout << "\n\n";
    }
    while (name != "");

    return myMap;
}

map<string, double> &delete_entry(map<string, double> &myMap)
{
    string name = "";
    map<string, double>::iterator itr;

    do
    {
        name = "";
        cout << "Please enter a name to delete:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( itr = myMap.find(name) ) == myMap.end() )
        {
            cout << "The name doesn't exist.\n";
            cout << "Please enter an existing name to delete.\n";
            continue;
        }

        myMap.erase(itr);
        cout << name << " has been removed.\n\n";
    }
    while (name != "");

    return myMap;
}
显示结果如下
Please choose from the following options:
0. Exit
1. Add entry
1

Please enter a name:
WEIYAYUN
Please enter an score for the name:
99


Please enter a name:
Peter Smith
Please enter an score for the name:
98


Please enter a name:
Hello world
Please enter an score for the name:
88


Please enter a name:

Display high scores
key | value = Hello world | 88.000000
key | value = Peter Smith | 98.000000
key | value = WEIYAYUN | 99.000000


Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
2

Please enter a name to update:
WEIYAYUN
Please enter a new score for the name:
100


Please enter a name to update:

Display high scores
key | value = Hello world | 88.000000
key | value = Peter Smith | 98.000000
key | value = WEIYAYUN | 100.000000


Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
4

Please enter a name to display:
WEIYAYUN

WEIYAYUN | 100.000000

Please enter a name to display:

Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
3

Please enter a name to delete:
Peter Smith
Peter Smith has been removed.

Please enter a name to delete:

Display high scores
key | value = Hello world | 88.000000
key | value = WEIYAYUN | 100.000000


Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
0

3.写一个程序，它有两个选项：用户注册和用户登录。
用户注册允许新用户创建一个登录名和密码。
用户登录允许用户登录并显示两个选项：修改密码和退出。
修改密码允许用户修改其密码，退出将使用户返回到原来的界面。

#include <iostream>
#include <string>
#include <map>

using namespace std;

void registerUser(map<string, string> &users);
string createName(map<string, string> &users);
bool validateName(string name, map<string, string> &users);
string createPassword();
bool validatePassword(string password);

void login(map<string, string> &users);
string validLoginName(map<string, string> &users);
bool validateLoginName(string name, map<string, string> &users);
string validLoginPassword(string name, map<string, string> &users);
bool validateLoginPassword(string name, string password, map<string, string> &users);
void loginAction(string name, map<string, string> &users);
void changePassword(string name, map<string, string> &users);

bool nameExists(string name, map<string, string> &users);
void printUsers(map<string, string> &users);

int main()
{
    int choice = 0;
    bool exitProgram = false;
    map<string, string> users;

    while (!exitProgram)
    {
        choice = 0;

        cout << "Please select from the following options:\n";
        cout << "0. Exit\n";
        cout << "1. Register User\n";
        if (users.size() > 0)
        {
            cout << "2. Login\n";
        }
        cin >> choice;
        cin.clear();
        cin.ignore(80, '\n');

        cout << '\n';

        switch (choice)
        {
        case 0:
            exitProgram = true;
            break;
        case 1:
            registerUser(users);
            printUsers(users);
            break;
        case 2:
            login(users);
            printUsers(users);
            break;
        default:
            exitProgram = true;
            break;
        }
    }

    users.clear();
}
void registerUser(map<string, string> &users)
{
    string name = createName(users);
    if (name == "")
    {
        return;
    }
    string password = createPassword();
    if (password == "")
    {
        return;
    }
    users[name] = password;
}

string createName(map<string, string> &users)
{
    string name = "";
    bool validName = false;

    while (!validName)
    {
        name = "";
        cout << "Please create a login name: \n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        validName = validateName(name, users);
        if (!validName)
        {
            cout << "The name provided already exist.\n\n";
        }
    }

    cout << '\n';
    return name;
}

bool validateName(string name, map<string, string> &users)
{
    if (name == "")
    {
        return false;
    }
    return !nameExists(name, users);
}

string createPassword()
{
    string password = "";
    bool validPassword = false;

    while (!validPassword)
    {
        password = "";
        cout << "Please create a password at least 6 characters long: \n";
        getline(cin, password, '\n');
        if (password == "")
        {
            break;
        }

        validPassword = validatePassword(password);
        if (!validPassword)
        {
            cout << "The password provided is not valid.\n\n";
        }
    }

    cout << '\n';
    return password;
}

bool validatePassword(string password)
{
    return (password.length() >= 6);
}

void login(map<string, string> &users)
{
    bool logout = false;

    while (!logout)
    {
        string name = validLoginName(users);
        if (name == "")
        {
            return;
        }
        string password = validLoginPassword(name, users);
        if (password == "")
        {
            return;
        }
        loginAction(name, users);
        logout = true;
    }
}

string validLoginName(map<string, string> &users)
{
    string name = "";
    bool validName = false;

    while (!validName)
    {
        name = "";
        cout << "Please provide a login name: \n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        validName = validateLoginName(name, users);
        if (!validName)
        {
            cout << "The name provided does not exist.\n\n";
        }
    }

    cout << '\n';
    return name;
}

bool validateLoginName(string name, map<string, string> &users)
{
    return nameExists(name, users);
}

string validLoginPassword(string name, map<string, string> &users)
{
    string password = "";
    bool validPassword = false;

    while (!validPassword)
    {
        password = "";
        cout << "Please provide a password: \n";
        getline(cin, password, '\n');
        if (password == "")
        {
            break;
        }

        validPassword = validateLoginPassword(name, password, users);
        if (!validPassword)
        {
            cout << "The password provided is incorrect.\n\n";
        }
    }

    cout << '\n';
    return password;
}

bool validateLoginPassword(string name, string password, map<string, string> &users)
{
    string actualPassword = users[name];
    return (password == actualPassword);
}


void loginAction(string name, map<string, string> &users)
{
    int choice = 0;
    bool logout = false;

    while (!logout)
    {
        choice = 0;

        cout << "Please select from the following options:\n";
        cout << "1. Change password for " << name << "\n";
        cout << "2. Log Out\n";
        cin >> choice;
        cin.clear();
        cin.ignore(80, '\n');

        cout << '\n';

        switch (choice)
        {
        case 0:
            logout = true;
            break;
        case 1:
            changePassword(name, users);
            break;
        case 2:
            logout = true;
            break;
        default:
            logout = true;
            break;
        }
        cout << '\n';
    }
}

void changePassword(string name, map<string, string> &users)
{
    string password = "";
    bool validPassword = false;

    while (!validPassword)
    {
        password = "";
        cout << "Please create a new password at least 6 characters long: \n";
        getline(cin, password, '\n');
        if (password == "")
        {
            break;
        }

        validPassword = validatePassword(password);
        if (validPassword)
        {
            users[name] = password;
        }
        else
        {
            cout << "The password provided is not valid.\n\n";
        }
    }
}

bool nameExists(string name, map<string, string> &users)
{
    return (users.find(name) != users.end());
}
void printUsers(map<string, string> &users)
{
    cout << "Display  Users\n";
    for (map<string, string>::iterator itr = users.begin(), end = users.end(); itr != end; ++itr)
    {
        cout << itr->first << " | " << itr->second << '\n';
    }
    cout << '\n';
}
显示结果如下
Please select from the following options:
0. Exit
1. Register User
1

Please create a login name:
WEIYAYUN

Please create a password at least 6 characters long:
08@AiLk0328

Display  Users
WEIYAYUN | 08@AiLk0328

Please select from the following options:
0. Exit
1. Register User
2. Login
1

Please create a login name:
Peter Smith

Please create a password at least 6 characters long:
123456789

Display  Users
Peter Smith | 123456789
WEIYAYUN | 08@AiLk0328

Please select from the following options:
0. Exit
1. Register User
2. Login
1

Please create a login name:
Hello world

Please create a password at least 6 characters long:
abcdefg

Display  Users
Hello world | abcdefg
Peter Smith | 123456789
WEIYAYUN | 08@AiLk0328

Please select from the following options:
0. Exit
1. Register User
2. Login
2

Please provide a login name:
WEIYAYUN

Please provide a password:
123456789
The password provided is incorrect.

Please provide a password:
08@AiLk0328

Please select from the following options:
1. Change password for WEIYAYUN
2. Log Out
1

Please create a new password at least 6 characters long:
hijklmn

Please select from the following options:
1. Change password for WEIYAYUN
2. Log Out
2


Display  Users
Hello world | abcdefg
Peter Smith | 123456789
WEIYAYUN | hijklmn

Please select from the following options:
0. Exit
1. Register User
2. Login
2

Please provide a login name:
Peter world
The name provided does not exist.

Please provide a login name:


Display  Users
Hello world | abcdefg
Peter Smith | 123456789
WEIYAYUN | hijklmn

Please select from the following options:
0. Exit
1. Register User
2. Login
0

第19章 更多关于字符串的内容
哇,我们已经学完了许多难懂的知识，恭喜你历经九九八十一难到达了这里！
本章我们来休息片刻，不再学习新的数据结构了，而是回头看一个你已经知道的数据结构：字符串。
尽管很不起眼，但字符串被随处使用，许多程序所做的工作几乎全是在读入和修改字符串。
你经常要读入字符串然后显示给用户，并且也经常需要知道一个字符串的内容。
例如，你可能想实现字符串的搜索功能，能够在字符串中查找某个特定的值。
你可能想读入一串以逗号分隔的表格数据，实现一个高分榜，或者创建一个基于文本界面的冒险游戏。
你每天最常用的一个应用――浏览器，很大程度上就是一个超大的字符串处理器，它处理各种HTML网页。
所有这些问题都要求你除了能够读入和输出整个字符串外，还得会做其他工作。
字符串可能很大，占用极大的内存空间，因此我们可以利用之前学过的一些特性，来写出即使在函数之间传递字符串也能有很高效率的程序。
具体来说，就是使用引用。本章将介绍各种可用于处理字符串的操作，以及讨论如何在使用这些操作时保持程序的高效率。
在实践题中，你将有机会写一些有趣的字符串处理代码，学习到操纵字符串的强大能力。
19.1 读入字符串
当读取字符串到程序中时，有时候会想要读入一整行，而不是像以前一样，使用空格来做分隔符，这使得你每次只能读入一个单词。
一个特殊的函数getline，可以一次读取一整行。它接受一个“输入流”（input stream），从该输入流中读取一行文本。
cin就是输入流的 一个例子，你以前常常用它一次读取一个单词。
（告诉你一个小秘密：cin其实是个对象，就好像string或者vector一样。它是一种称为输入流的类型，而cin>>是读入数据的方法。
在第一章就把这一切都统统交代出来，似乎并不好！）
下面的程序将演示怎样从用户的输入中读入整行文本：
#include <iostream>
#include <string>

using namespace std;

int main ()
{
    string input;
    cout << "Please enter a line of text: ";
    getline( cin, input, '\n' );
    cout << "You typed in the line " << '\n' << input << '\n';
}
示例代码41：getline.cpp
显示结果如下
Please enter a line of text: Hello, world!
You typed in the line
Hello, world!

这个程序读入一行字符序列到字符串input中，直到换行符（\n）―― 换句话说，直到用户按下回车键。
换行符本身将被丢弃，而只保存换行符之前用户的输入部分。
如果你想保留字符串中的换行符，必须自己手动添加。
你不仅可以使用换行符，还可以用任何需要的字符作为停止读入字符串的标记（这个字符称为“分隔符”，因为它标识了字符串读取的界限）。
用户仍然需要按回车键让getline函数返回，但只有分隔符之前的文本被读入。
来看一个例子吧，这个例子演示了如何读取以逗号分隔的格式化文本 （CSV格式）。CSV格式的数据看起来像这样：
Sam, Jones, 40 Asparagus Ave, New York, New York, USA 
每个逗号分隔数据的一节，看起来就像一个电子表格，但和电子表格不同，它使用逗号来分隔列。
让我们来写一个程序，读入用户输入的 CSV数据，这些数据是网络游戏中玩家的名单，以这样的格式表示：
 <player first name>,<player last name>,<player class>  
学习了第28章后，你就可以对这个程序做一些修改，使得它能够从磁盘中读取CSV文件，但现在仅是读取用户输入的数据。
first_name为空时，程序结束退出。
#include <iostream>
#include <string>

using namespace std;

int main ()
{
    while ( 1 )
    {
        cout << "Please enter <player first name>,<player last name>,<player class>: \n";

        string first_name;
        getline( cin, first_name, ',' );
        if ( first_name.size() == 0 )
        {
            break;
        }

        string last_name;
        getline( cin, last_name, ',' );

        string player_class;
        getline( cin, player_class, '\n' );

        cout << first_name << " " << last_name << " is a " << player_class << endl;
    }
}
示例代码42：csv.cpp
显示结果如下
Please enter <player first name>,<player last name>,<player class>:
Peter,Smith,Programmer
Peter Smith is a Programmer
Please enter <player first name>,<player last name>,<player class>:

注意，这里使用字符串的size方法，来检测一个字符串是否为空。这只是字符串中可用的众多方法之一。
19.2 字符串长度和访问单个元素
要查找字符串的长度，可以用length方法或你刚才见过的size方法。 
这两个方法都是string类的一部分，都能够返回字符串中的字符数：
string my_string1 = "ten chars.";
int len = my_string1.length();   // 或 my_string1.size();
这里的size和length没有任何区别，任意选择一个你感觉自然的来用就好。
这两种方法都存在的原因是：所有的STL容器对象都使用size方法， 因此使用size可以保持一致性；
但对大多数程序员来说，使用length来处理字符串更自然些。
字符串可以像数组一样被索引化。例如，你可以通过索引访问每个字符，故而遍历到字符串中的所有字符，
就好像字符串就是一个数组一样。如果你想处理字符串中的单个字符，比如查找像逗号这样的特殊字符，此方法非常有用。
这时候，配合使用length或size方法很重要，这样你就不会试图越界访问字符串结尾后的内容。
跟数组一样，越界访问字符串结尾后的内容是很危险的。
这里有一个小例子，演示如何循环一个字符串，并将它显示出来：
for( int i = 0; i < my_string.length(); i++ )
{
    cout << my_string[ i ];
}
19.3 字符串搜索与子字符串
string类支持简单的子串搜索和取子串操作，所用的方法是find、rfind以及substr。
find方法接受一个子串和原始字符串的一个位置，找到给定的子串从指定位置开始的第一个匹配项。
其结果要么是返回该子串的第一个匹配项的索引，要么是一个特殊的整数值string::npos，表示没有找到该子串。
以下示例代码在给定字符串中搜索子串“cat”的每一个匹配项，并对匹配项的数目进行计数：
#include <iostream>
#include <string>

using namespace std;

int main ()
{
    string input;
    int i = 0;
    int cat_appearances = 0;

    cout << "Please enter a line of text: ";
    getline( cin, input, '\n' );

    for ( i = input.find( "cat", 0 ); i != string::npos; i = input.find( "cat", i ) )
    {
        cat_appearances++;
        i++;
    }
    cout << "The word cat appears " << cat_appearances << " in the string " << input << '\n';
}
示例代码43：search.cpp
显示结果如下
Please enter a line of text: I have a cat, you have a cat, how many cats we have?
The word cat appears 3 in the string I have a cat, you have a cat, how many cats we have?

search_rfind.cpp
#include<iostream>

using namespace std;

int main()
{
    string st = "1111111111";		//10个字符
    cout << st.rfind("1111", 9) << endl;	//返回6
    cout << st.rfind("1111", 7) << endl;	//返回6
    cout << st.rfind("1111", 5) << endl;	//返回5
    cout << st.rfind("1111", 2) << endl;	//返回2

    return 0;
}

显示结果如下
6
6
5
2

rfind方法
strA.rfind(strB, pos)
从右向左查找，首次查找的位置为( strA.size() - 1 ) - strB.size() + 1。
Find last occurrence of content in string
Searches the string for the last occurrence of the sequence specified by its arguments.
When pos is specified, the search only includes sequences of characters that begin at or before position pos, 
ignoring any possible match beginning after pos.
substr方法会创建一个新的字符串，它是原字符串从给定位置开始的给定长度的切片：
// 示例原型
string substr (int position, int length);
例如，要提取一个字符串的前10个字符，你可以这样写：
substr.cpp

#include <iostream>
#include <string>

using namespace std;

int main ()
{
    string my_string = "abcdefghijklmnop";
    string first_ten_of_alphabet = my_string.substr( 0, 10 );
    cout << "The first ten letters of the alphabet are " << first_ten_of_alphabet << '\n';
}
显示结果如下
The first ten letters of the alphabet are abcdefghij

19.4 通过引用传递
字符串可能很大，包含大量数据。当然，并不是每个字符串都会很大，但总体上，通过引用来接受字符串参数是个很好的习惯：
void printString (string& str);
回顾一下：引用参数跟指针类似，它不用复制原来的字符串变量，而是将该字符串变量的引用传递给函数：
string str_to_show = "there is one x in this string";
printString( str_to_show );
这里，printString函数并没有复制变量str_to_show，而是获得了该变量的地址；我们可以像使用原始字符串一样地使用参数str。
但引用传递可能有一个缺点：引用使得函数获得了原始变量的地址， 所以在函数中可以修改该变量。
虽然你第一次写这个函数时，可能不想改变传递进来的引用变量，但是，如果事后又回头去更新它，
比如添加新功能之类的，你可能已经忘了，于是修改了引用变量的值，结果就会很糟糕。
有人调用这个函数时会惊讶地发现：它们的数据被修改了！
C++提供了一种防止引用参数被意外修改的机制：在函数中可以指定一个引用为常量。
const是C++中的特殊关键字，用来指定一个引用为常量。我们不可以修改const指定的引用参数，但可以读取。
void print_string (const string &str)
{
    cout << str; // 合法，没有修改str
    str = "abc"; // 不合法！
}
每当你添加一个引用参数到函数中时，考虑清楚函数是否应该能够修改引用参数。
如果你不希望修改这个参数，请将它标记为const，以确保函数不会且不能修改它。
使用const可以很清楚地表明参数不会被修改。
const并不仅限于引用，你也可以用const来标记一个指针指向的内存。在这种情况下，程序可以写成类似这样的代码：
注意，编译器是非常聪明的，它能分辨出代码是否在对一个指针所指 向的内存进行赋值。它不仅仅只关注指针本身，还关注指针的间接引 用正在做的事情。由于在参数传递时指针的值是被复制进来的，因此 修改指针本身是完全合法的；改变p_val的值不会影响到传递到函数的 原始变量。
void print_ptr (const int *p_val)
{
    if ( p_val == nullptr )
    {
        return;
    }
    cout << *p_val; // 没问题，内存访问没有修改内存
    *p_val = 20; // 出错，p_val指向的内存被修改了
    p_val = nullptr; // 没问题，只是修改了指针本身，并没修改指针所指向的内存
}
const的使用还可以更广泛。可以用const来标记和强制任何给定的变量不会被修改。
如果你试图修改它，编译器会告诉你，你正在做一件不打算做的事情。
当你声明一个const变量时，必须立即给它赋值（因 为再也不能够修改它了）。
const int x = 4; // 没问题，变量创建的同时进行赋值 
x = 4; // 出错，x不能被修改
尽可能使用const是很好的编程风格。将变量标记为const使得剩下的代码更易于阅读，
因为你知道没有人会修改它，所以一旦你看到一个对该变量的赋值，就可以肯定它不会被改变。
你不必跟踪这个变量有没有被赋予其他的值，从而专注于非const的变量正在发生的事情，它们是否被修改，等等。
const还能确保你以后不会意外地修改这个变量，防止发生诡异的代码行为，
原代码假定了该变量的值不会变，它应该跟开始时的值始终相同。
例如有一段代码，它提示用户输入名字和姓氏，然后创建一个包含用户的全名的字符串，
你应该将全名变量标记为const，因为它不应该被改变。
19.4.1 const传播
const可能会像病毒一样传播。一旦将一个变量声明为const，你就不能通过引用将它传递给接受非const引用的函数，
也不能通过指针传递给接受非const指针的函数，因为在函数中可能会试图通过指针修改该变量的值。
const X*和X*是不同的类型，const X&（声明一个到X的引用）和X&也是不同的类型。
我们可以将一个X*转换成const X*，或者将 一个X &转换成const X &，反之却不行。
例如，如果写了如下的函数， 将会编译出错：
void print_nonconst_val (int &p_val)
{
    cout << p_val;
}

const int x = 10;

print_nonconst_val( x );   // 无法编译
// 不能将一个const int类型的变量传递给一个接受非const引用的函数
这一限制只适用于引用和指针，因为在引用或指针中，原始的值在函数中被共享了。
如果变量是以复制方式传到函数中的，比如值传递， 就不需要将函数参数标记为const了：
void print_nonconst_val (int val)
{
    cout << val;
}

const int x = 10;

print_nonconst_val( x );   // 没问题，x被复制一份到函数中
// val是print_nonconst_val函数的局部变量，因此，它是不是const并不要紧
因此，只要你把一个变量标记成const，就需要考虑下其他变量是否也需要标记成const，特别是函数的指针和引用参数。
使用const需要小心。如果你正在使用的库或辅助方法里没有使用const，可能会有些麻烦。
从另一个角度来说，你应该在自己写的库或辅助方法里使用const，这样别人使用你的代码才不会因为const出问题。
C++的标准库考虑了const的问题，因此你可以放心地在自己的代码中将变量标记为const，并使用这些变量和标准库。
本书其余部分，我会适时地使用const变量。
还有一点要注意的是，你可以在循环内部声明一个变量为const，即使每次循环都修改（重置）该变量：
for ( int i = 0; i < 10; i++ )
{
    const i_squared = i * i;
    cout << i_squared;
}
变量i_squared可以声明为const，即使它每次循环都被修改。
这是因为，变量i_squared的作用域范围在整个循环体里。从编译器角度来看，每次循环时变量i_squared都被重新创建。
19.4.2 const和STL
在关于STL的最后一章，我们展示了一个显示map的函数。你可能注意到了，map是以值传递方式传给函数的，
这意味着整个map需要被复制一份传递到displayMap函数中。再来看一下这个函数：
void displayMap (map<string, string> map_to_print)
{
    for ( map<string, string>::iterator itr = map_to_print.begin(), end = map_to_print.end(); itr != end; ++itr )
    {
        cout << itr->first << " --> " << itr->second << endl;
    }
}
这里如果用引用的话，就更完美了。那样的话，我们就可以不用复制整个map，而是使用map的引用了。
甚至，我们可以使用一个const引用，很清楚地表明这是一个纯粹的显示函数，不能以任何方式修改这个map。
void displayMap (const map<string, string> &map_to_print)
{
    for ( map<string, string>::iterator itr = map_to_print.begin(), end = map_to_print.end(); itr != end; ++itr )
    {
        cout << itr->first << " --> " << itr->second << endl;
    }
}
如果这样做的话，恭喜你，编译错误！出问题的原因是：通过将map标记为const，
表明没有任何人能够修改map中的元素，但是，迭代器本身是允许修改map的。例如，下面的代码：
if ( itr->first == "Alex Allain" )
{
    itr->second = "webmaster2@cprogramming.com"
}
这段代码就通过迭代器修改了你的地址簿里我的地址。
幸运的是， STL对const是很友好的，所有的STL容器都有第二种特别的迭代器类型，叫做const_iterator。
你可以像使用普通的迭代器一样地使用const_iterator，除了不能够通过const_iterator来修改正在迭代的容器：
void displayMap (const map<string, string> &map_to_print)
{
    for ( map<string, string>::const_iterator itr = map_to_print.begin(), end = map_to_print.end(); itr != end; ++itr )
    {
        cout << itr->first << " --> " << itr->second << endl;
    }
}
当被迭代的容器被标记为const时，你必须始终使用const_iterator来对其迭代。
无论何时使用迭代器，都只用它来访问数据，而不要通过它来修改被迭代对象的内容，这是一种很好的习惯。
问答题
1.下面的代码哪些是合法的？
A. const int &x;
B. const int x = 3; int *p_int = & x;
C. const int x = 12; const int *p_int = & x;
D. int x = 3; const int y = x; int& z = y;

C
2.下面的函数签名中，哪一项可以让代码const int x = 3; fun( x ); 编译通过：
A. void fun (int x);
B. void fun (int& x);
C. void fun (const int& x);
D. A 和 C

D
3.判断一个字符串搜索没有成功找到目标元素的最好方式是？ 
A. 比较结果位置和0
B. 比较结果位置和-1
C. 比较结果位置和string::npos
D. 检查结果位置是否大于字符串长度

C
4.如何为一个const的STL容器创建迭代器？
A. 声明迭代器为const
B. 使用索引来循环遍历，不使用迭代器
C. 使用const_iterator
D. 声明模板类型为const

C
实践题
1.写一个程序，它读入两个字符串，计数第一个字符串在第二个字符串中出现的次数。

#include <iostream>
#include <string>

using namespace std;

int numberOfNeedlesInHaystack(const string &haystack, const string &needle);

int main()
{
    string needle;
    cout << "Please enter a line of text to find: "<<endl;
    getline(cin, needle, '\n');

    string haystack;
    cout << "Please enter a line of text to search for the number of occurrences: "<<endl;
    getline(cin, haystack, '\n');

    int needleAppearances = numberOfNeedlesInHaystack(needle, haystack);
    cout << "The word " << needle << " appears " << needleAppearances << " in the string " << haystack << endl;
}

int numberOfNeedlesInHaystack(const string &needle, const string &haystack)
{
    int i = 0;
    int needleAppearances = 0;

    for (i = haystack.find(needle, 0); i != string::npos; i = haystack.find(needle, i))
    {
        needleAppearances++;
        i++;
    }
    return needleAppearances;
}
显示结果如下
Please enter a line of text to find:
abc
Please enter a line of text to search for the number of occurrences:
Hello, world!ababcabcefg
The word abc appears 2 in the string Hello, world!ababcabcefg

2.写一个程序，允许用户输入类似CSV文件的表格数据，但是不使用逗号来做分隔符，而是由程序来检测有效的分隔符。
首先，用户输入几行表格数据；接着，程序通过遍历输入数据中的所有非数字、非字母、非空格字符，检测出可能的分隔符。
找到每一行出现的可能的分隔符后，显示给用户，并向用户询问使用哪一个字符作为分隔符。例如， 如果用户输入：
Alex Allain, webmaster@cprogramming.com
John Smith, john@nowhere.com
应该提示用户从逗号“，”@“和“・”中选择一个作为分隔符。

erase函数可以用于删除vector容器中的一个或者一段元素，在删除一个元素的时候，其参数为指向相应元素的迭代器，
而在删除一段元素的时候，参数为指向一段元素的开头的迭代器以及指向结尾元素的下一个元素的迭代器。
在进行单个元素删除后，传入的迭代器指向不变，仍然指向被删除元素的位置，而被删除元素之后的所有元素都向前移动一位，
删除一段元素后，传入的迭代器指向也是不变的，仍然指向原来传进去时候的位置，修改的是删除段后面的元素的位置。
删除段后面的元素都前移了。被删除段用被删除段的下一个元素代替了。也就是该迭代器实际上是指向了原来被删除元素的下一个元素。

iterator erase(iterator position);
iterator erase(iterator first, iterator last);

iterator remove(iterator first, iterator last，val);
remove函数会将范围内所有等于val的值移动位置

erase和remove的区别在于执行函数之后返回值不同，被执行的vector的大小会不会改变
vector中erase的作用是删除掉某个位置position或一段区域（begin, end)中的元素，减少其size，返回被删除元素下一个元素的位置。
vector中remove的作用是将范围内为val的值都remove到后面，返回新的end()值（非val部分的end）,
但传入的原vector的end并没有发生改变，因此size也就没有变化

执行remove之后返回新的end()迭代器，但是不改变原来数组的end()迭代器的值。
也就是原先数组中新的end()至原end()范围内的值不可靠。
begin()到新的end()这部分是不等于val的值。

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

void print(const vector<string> &input);
vector<char> getPotentialDemarcators(const vector<string> &input);
void removeCharacterIfNotPresent(const vector<string> &input, char character, vector<char> &potentialDemarcators);
bool isValidDemarcator(char character, vector<char> potentialDemarcatorsBase);
bool charIsInVector(char character, vector<char> &characters);
int charIsInString(char character, const string &str);

int main()
{
    vector<string> input =
    {
        "Alex Allain, webmaster@cprogramming.com",
        "John Smith, john@nowhere.com",
        "Foo Bar, foo@bar.com"
    };

    print(input);

    vector<char> potentialDemarcators = getPotentialDemarcators(input);

    int choice = 0;
    int maxChoice = potentialDemarcators.size();
    if (maxChoice == 0)
    {
        cout << "No possible demarcators were found in the file.\n";
        return 1;
    }
    bool validChoice = false;
    while (!validChoice)
    {
        cout << "Please enter the number for the desired demarcator:\n";
        int i = 1;
        for (vector<char>::iterator itr = potentialDemarcators.begin(), end = potentialDemarcators.end(); itr != end; ++itr)
        {
            cout << i << ": " << *itr << '\n';
            i++;
        }
        choice = 0;
        cin >> choice;
        cin.clear();
        cin.ignore(80, '\n');

        validChoice = ((0 < choice) && (choice <= maxChoice));
        if (!validChoice)
        {
            cout << "The number your entered is invalid choice.\n\n";
        }
    }
    cout << '\n';

    cout << "The demarcator used in this file is: " << potentialDemarcators[choice - 1] << endl;
}

void print(const vector<string> &input)
{
    for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
    {
        cout << *itr << endl;
    }
    cout << '\n';
}


vector<char> getPotentialDemarcators(const vector<string> &input)
{
    vector<char> potentialDemarcators;
    vector<char> potentialDemarcatorsBase;
    if (input.size() == 0)
    {
        return potentialDemarcators;
    }

    string firstLine = input[0];
    for (int i = 0; i < firstLine.length(); i++)
    {
        if (isValidDemarcator(firstLine[i], potentialDemarcatorsBase))
        {
            potentialDemarcatorsBase.push_back(firstLine[i]);
            potentialDemarcators.push_back(firstLine[i]);
        }
    }

    for (vector<char>::iterator itrChar = potentialDemarcatorsBase.begin(), endChar = potentialDemarcatorsBase.end();
            itrChar != endChar; ++itrChar)
    {
        removeCharacterIfNotPresent(input, *itrChar, potentialDemarcators);
    }
    return potentialDemarcators;
}

void removeCharacterIfNotPresent(const vector<string> &input, char character, vector<char> &potentialDemarcators)
{
    for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
    {
        if (charIsInString(character, *itr) == 0)
        {
            const char removeChar = character;
            potentialDemarcators.erase(
                remove(potentialDemarcators.begin(), potentialDemarcators.end(), removeChar),
                potentialDemarcators.end());
            return;
        }
    }
}

bool isValidDemarcator(char character, vector<char> potentialDemarcatorsBase)
{
    return ( !isalnum(character) && !isblank(character) && !charIsInVector(character, potentialDemarcatorsBase) );
}

bool charIsInVector(char character, vector<char> &characters)
{
    for (vector<char>::iterator itrChar = characters.begin(), endChar = characters.end(); itrChar != endChar; ++itrChar)
    {
        if (character == *itrChar)
        {
            return true;
        }
    }
    return false;
}

int charIsInString(char character, const string &str)
{
    int i = 0;
    int numberOfOccurrences = 0;

    for (i = str.find(character, 0); i != string::npos; i = str.find(character, i))
    {
        numberOfOccurrences++;
        i++;
    }
    return numberOfOccurrences;
}
显示结果如下
Alex Allain, webmaster@cprogramming.com
John Smith, john@nowhere.com
Foo Bar, foo@bar.com

Please enter the number for the desired demarcator:
1: ,
2: @
3: .
1

The demarcator used in this file is: ,

Alex Allain, webmaster@cprogramming.com
John Smith, john@nowhere.com
Foo Bar, foo@bar.com

Please enter the number for the desired demarcator:
1: ,
2: @
3: .
2

The demarcator used in this file is: @

Alex Allain, webmaster@cprogramming.com
John Smith, john@nowhere.com
Foo Bar, foo@bar.com

Please enter the number for the desired demarcator:
1: ,
2: @
3: .
3

The demarcator used in this file is: .

3.写一个程序，它读入用户输入的HTML文本。（别担心，我们以后 会介绍如何从文件中读入文本。）
它应该支持如下的HTML标 签：<html>、 <head>、 <body>、 <b>、<i>以及<a>。
每个HTML标签都有一个开始标签，如<html>，以及一个闭合标签，它有一个斜杠在前面，如</html>。
标签里面是该标签控制的文本，比 如”<b>这里的文本是粗体的</b>“，或者”<i>这里的文本是斜体的</i>“。
<head></head>标签里面的文本是元数据，<body></body>里面的是要显示的文本。
<a>标签用来表示超链接， 里面有一个URL地址，按以下格式来表示：<a href=URL>文本</a>。
程序读入HTML文本后，应该简单地忽略掉<html>。然后，移除<head> 部分的所有文本，它不应该在你的输出中出现。
接着，程序应该显示出<body>里的所有文本，将<b>和</b>之间的文本以星号（*）围绕的方式显示，
<i>和</i>里面的文本以下划线(_)围绕的方式显示，
<a href=linkurl>link text</a>这样的标签内的文本以链接文本 （linkurl）的形式显示。

#include <iostream>
#include <string>
#include <vector>

using namespace std;

void print(const vector<string>& input);
vector<string> parseHTMLStringToVector(const string& htmlDOMStream);
vector<string> mergeChildElements(const vector<string>& input, const string& tagName);
vector<string> stripTag(const vector<string>& input, const string& tagName);
vector<string> stripTagAttributes(const vector<string>& input, const string& tagName);
vector<string> stripText(const vector<string>& input, const string& tagName);
vector<string> substituteTag(const vector<string>& input, const string& tagName, const string& tagNameSubstitute);
vector<string> formatBold(const vector<string>& input);
vector<string> formatItalic(const vector<string>& input);
vector<string> formatHyperlink(const vector<string>& input);
string getLinkURL(const string& hrefTag);

const string openTagStart = "<";
const string closeTagStart = "</";
const string tagEnd = ">";

int main()
{
	string htmlDOMStream = "<html xmlns=\"http://www.w3.org/1999/xhtml\" itemscope=\"\" itemtype=\"http://schema.org/WebPage\">";
		htmlDOMStream += "<head>";
		htmlDOMStream += "<meta property=\"og : image\" content=\"https ://lh3.googleusercontent.com/-mln6PaqJChw/UOIaqjWmkgI/AAAAAAABno0/sck_C8SCr-0/s240/DSCN6032a.jpg\" />";
		htmlDOMStream += "<script type=\"text / javascript\">";
		htmlDOMStream += "  window.jstiming.load.tick('cl');";
		htmlDOMStream += "</script>";
		htmlDOMStream += "</head>";
		htmlDOMStream += "<body xmlns=\"http://www.google.com/ns/jotspot\" id=\"body\" class=\" en            \">";
		htmlDOMStream += " This is an html text file that is parsed to handle text such as <b>bold text</b>, <i>italic text</i>, and even <a href=\"www.google.com\">hyperlink text</a>.";
		htmlDOMStream += "</body>";
		htmlDOMStream += "</html>";

	vector<string> htmlDOM = parseHTMLStringToVector(htmlDOMStream);
	const string body = "body";

	cout << "Original HTML: \n";
	vector<string> htmlDOMPrint = mergeChildElements(htmlDOM, body);
	print(htmlDOMPrint);

	const string html = "html";
	htmlDOM = stripTag(htmlDOM, html);

	const string head = "head";
	htmlDOM = stripText(htmlDOM, head);

	htmlDOM = stripTagAttributes(htmlDOM, body);
	htmlDOM = formatBold(htmlDOM);
	htmlDOM = formatItalic(htmlDOM);
	htmlDOM = formatHyperlink(htmlDOM);

	cout << "Parsed HTML:\n";
	htmlDOMPrint = mergeChildElements(htmlDOM, body);
	print(htmlDOMPrint);
}

void print(const vector<string>& input)
{
	for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
	{
		cout << *itr << endl;
	}
	cout << '\n';
}

vector<string> mergeChildElements(const vector<string>& input, const string& tagName)
{
	string openingTag = openTagStart + tagName;
	string closingTag = closeTagStart + tagName + tagEnd;
	bool isInMergeRegion = false;
	
	vector<string> output;
	string currentMerge = "";
	for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
	{
		string itrOpening = itr->substr(0, openingTag.length());
		if (itrOpening == openingTag)
		{
			isInMergeRegion = true;
			output.push_back(*itr);
		}
		else if (isInMergeRegion && *itr == closingTag)
		{
			isInMergeRegion = false;
			if (currentMerge != "")
			{
				output.push_back(currentMerge);
			}
			output.push_back(*itr);
		}
		else if (isInMergeRegion)
		{
			currentMerge += *itr;
		}
		else
		{
			output.push_back(*itr);
		}
	}
	return output;
}

vector<string> parseHTMLStringToVector(const string& htmlDOMStream)
{
	bool isInOpenTag = false;
	bool isInCloseTag = false;

	vector<string> htmlDOM;
	string currentEntry = "";

	for (int i = 0; i < htmlDOMStream.length(); i++)
	{
		string currentLetter(1, htmlDOMStream[i]);
		
		string previousLetter = "";
		if (i - 1 >= 0)
		{
			previousLetter.push_back(htmlDOMStream[i-1]);
		}
		
		string nextLetter = "";
		if (i + 1 < htmlDOMStream.length())
		{
			nextLetter.push_back(htmlDOMStream[i + 1]);
		}

		if (currentLetter + nextLetter == closeTagStart)
		{
			isInCloseTag = true;
			if (currentEntry != "")
			{
				htmlDOM.push_back(currentEntry);
			}
			currentEntry = htmlDOMStream[i];
		}
		else if(currentLetter == openTagStart)
		{
			isInOpenTag = true;
			if (currentEntry != "")
			{
				htmlDOM.push_back(currentEntry);
			}
			currentEntry = htmlDOMStream[i];
		}
		else if (isInOpenTag && previousLetter == tagEnd)
		{
			isInOpenTag = false;
			if (currentEntry != "")
			{
				htmlDOM.push_back(currentEntry);
			}
			currentEntry = htmlDOMStream[i];
		}
		else if (isInCloseTag && currentLetter == tagEnd)
		{
			isInCloseTag = false;
			currentEntry += htmlDOMStream[i];
			if (currentEntry != "")
			{
				htmlDOM.push_back(currentEntry);
			}
			currentEntry = "";
		}
		else
		{
			currentEntry += htmlDOMStream[i];
		}
	}
	return htmlDOM;
}

vector<string> stripTag(const vector<string>& input, const string& tagName)
{
	string openingTag = openTagStart + tagName;
	string closingTag = closeTagStart + tagName + tagEnd;
	bool isInStripRegion = false;

	vector<string> output;
	for(vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
	{
		string itrOpening = itr->substr(0, openingTag.length());
		if (!isInStripRegion && itrOpening == openingTag)
		{
			isInStripRegion = true;
		}
		else if (isInStripRegion && *itr == closingTag)
		{
			isInStripRegion = false;
		}
		else
		{
			output.push_back(*itr);
		}
	}
	return output;
}

vector<string> stripTagAttributes(const vector<string>& input, const string& tagName)
{
	string openingTag = openTagStart + tagName;

	vector<string> output;
	for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
	{
		string itrOpening = itr->substr(0, openingTag.length());
		if (itrOpening == openingTag)
		{
			output.push_back(openingTag + tagEnd);
		}
		else
		{
			output.push_back(*itr);
		}
	}
	return output;
}

vector<string> stripText(const vector<string>& input, const string& tagName)
{
	string openingTag = openTagStart + tagName;
	string closingTag = closeTagStart + tagName + tagEnd;
	bool isInStripRegion = false;

	vector<string> output;
	for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
	{
		string itrOpening = itr->substr(0, openingTag.length());
		if (!isInStripRegion && itrOpening == openingTag)
		{
			isInStripRegion = true;
			output.push_back(*itr);
		}
		else if (isInStripRegion && *itr == closingTag)
		{
			isInStripRegion = false;
			output.push_back(*itr);
		}
		else if (!isInStripRegion)
		{
			output.push_back(*itr);
		}
	}
	return output;
}

vector<string> formatBold(const vector<string>& input)
{
	return substituteTag(input, "b", "*");
}

vector<string> formatItalic(const vector<string>& input)
{
	return substituteTag(input, "i", "_");
}

vector<string> substituteTag(const vector<string>& input, const string& tagName, const string& tagNameSubstitute)
{
	string openingTag = openTagStart + tagName + tagEnd;
	string closingTag = closeTagStart + tagName + tagEnd;

	vector<string> output;
	for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
	{
		if (*itr == openingTag || *itr == closingTag)
		{
			output.push_back(tagNameSubstitute);
		}
		else
		{
			output.push_back(*itr);
		}
	}
	return output;
}

vector<string> formatHyperlink(const vector<string>& input)
{
	const string hyperlink = "a";
	bool insidetag = false;

	string openingTag = openTagStart + hyperlink;
	string closingTag = closeTagStart + hyperlink + tagEnd;

	vector<string> output;
	for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
	{
		string itrOpening = itr->substr(0, openingTag.length());
		if (itrOpening == openingTag)
		{
			insidetag = true;

			string linkURL = getLinkURL(*itr);

			vector<string>::const_iterator next = itr;
			++next;
			string innerText = *next;

			output.push_back(innerText + "(" + linkURL + ")"); 
		}
		else if (*itr == closingTag)
		{
			insidetag = false;
		}
		else if (!insidetag)
		{
			output.push_back(*itr);
		}
	}
	return output;
}

string getLinkURL(const string& hrefTag)
{
	const string hyperlinkURL = "href=";
	int position = hrefTag.find(hyperlinkURL, 0) + hyperlinkURL.length();
	
	string linkURL = "";
	char endDemaractor;
	if (hrefTag[position] == '\"')
	{
		endDemaractor = '\"';
		position++;
	}
	else
	{
		endDemaractor = ' ';
	}

	for (int i = position; i < hrefTag.length(); i++)
	{
		if (hrefTag[i] == endDemaractor)
		{
			break;
		}
		linkURL += hrefTag[i];
	}
	return linkURL;
}
显示结果如下
Original HTML:
<html xmlns="http://www.w3.org/1999/xhtml" itemscope="" itemtype="http://schema.org/WebPage">
<head>
<meta property="og : image" content="https ://lh3.googleusercontent.com/-mln6PaqJChw/UOIaqjWmkgI/AAAAAAABno0/sck_C8SCr-0/s240/DSCN6032a.jpg" />
<script type="text / javascript">
  window.jstiming.load.tick('cl');
</script>
</head>
<body xmlns="http://www.google.com/ns/jotspot" id="body" class=" en            ">
 This is an html text file that is parsed to handle text such as <b>bold text</b>, <i>italic text</i>, and even <a href="www.google.com">hyperlink text</a>.
</body>
</html>

Parsed HTML:
<head>
</head>
<body>
 This is an html text file that is parsed to handle text such as *bold text*, _italic text_, and even hyperlink text(www.google.com).
</body>

第20章 使用Code::Blocks进行调试
现在，你已经学会了很多强大的编程技术，但是在更加复杂的程序中追踪bug可能还是一件很困难的事情。
幸运的是，一个称为调试器的工具可以帮你解决这些问题。调试器是一个用来检查程序运行状态的工具，
它使得程序正在做的事情变得更容易让人理解。程序员新手往往排斥学习使用调试器，因为它看起来既烦琐又没必要。
确实，为了使用工具而必须学习它是令人生厌的。但是不学习使用调试器是一种“捡了芝麻，丢了西瓜”的行为。
调试器能节省大量时间，使用调试器就像放弃爬行，学习走路。你需要做一些练习，刚开始时会跌跌撞撞。
但是当你适应之后，肯定会激动得“手舞足蹈”。
本章将介绍Code::Blocks的调试器。如果你使用的是Windows系统， 应该已经安装Code::Blocks并且使用一段时间了。
虽然有很多不同的调试器，然而这些概念都是相通的。我提供了大量的截图，这样即使你用的不是Windows系统，
也能够理解本文的内容，看到编译器是什么样子的。几乎所有的开发环境都有自己的调试器，你的也不例外。
如果用的是Linux系统，可以使用GDB；如果你使用的是Visual Studio或Visual Studio Express，它们也都自带非常不错的调试器。 
还有许多其他的独立调试器可以使用，不过这些超出了本书的范围， 例如WinDbg，它是微软的Windows系统调试工具的一部分。
苹果的Xcode也提供了一个调试器。
贯穿本章，我将会使用有bug的程序来展示真实的调试过程。
如果你想跟随每个调试过程的话，每个示例你都可以在Code::Blocks中创建该程序的新项目（或者在选择的开发环境中创建）。
下面是第一个程序，用来计算特定数额资金的利率（interest rate）、 年利息（compounded annually）。
遗憾的是，里面有一个bug导致程序输出有误。
#include <iostream>

using namespace std;

double computeInterest (double base_val, double rate, int years)
{
    double final_multiplier;
    //double final_multiplier = 1.0;
    for ( int i = 0; i < years; i++ )
    {
        final_multiplier *= (1 + rate);
    }
    return base_val * final_multiplier;
}

int main ()
{
    double base_val;
    double rate;
    int years;
    cout << "Enter a base value: ";
    cin >> base_val;
    cout << "Enter an interest rate: ";
    cin >> rate;
    cout << "Enter the number of years to compound: ";
    cin >> years;
    cout << "After " << years << " you will have " << computeInterest( base_val, rate, years ) << " money" << endl;
}
示例代码44：bug1.cpp
这是该程序的运行结果：
Enter a base value: 100
Enter an interest rate: 0.1
Enter the number of years to compound: 1
After 1 you will have 1.40619e-306 money
不对！1.40619e-306绝对是错误的资金金额！很明显，这个程序有 bug。
让我们尝试在调试器中运行程序，看看问题出自哪里。
20.1 踏上调试之旅
首先，我们要确保Code::Blocks的配置正确，调试工作才能进行得更顺利。
为此，我们需要生成所谓的调试符号。调试符号可以让调试器知道代 码的哪一行正在执行，这样你就可以知道程序运行到哪里了。为确保调试符号设置正确，请在Code::Blocks中选择项目|编译选项 （Project|Build Options），会看到这样一个对话框：
你需要确保调试（Debug）目标里的生成调试符号（Produce debugging symbols）选项被勾选上。
还需要在编译|选择目标|调试 （Build|Select Target|Debug）中，确保调试（Debug）作为项目的目标被选中。
以上操作确保了目标是对项目进行调试，调试器将使用调试符号来编译你的程序。
如果你既没有调试（Debug）目标，也没有发布（Release）目标， 也可以只勾选上生成调试符号
（Produce debugging symbols）选项作为当前的编译目标，并且确保“从二进制中去除所有的符号（最小大小）[-s]”
（Strip all symbols from binary（minimizes size）[-s]）选项未选中。
（通常，项目创建时默认生成这些编译目标类型。因此， 确保你的配置正确的最简单方法是，
保留项目创建时Code::Blocks的默认设置。）
如果使用的是g++，那么你需要在命令行参数中加上-g参数，以便让编译器能产生调试符号。
如果你使用的是Xcode，它会自动生成调试符号。
万事俱备，只欠东风了。如果你的程序创建得比较早，但又必须改变它的配置，现在就先重建它吧。
一切准备就绪后，我们可以开始调试了！
20.2 设置断点
调试器的价值在于，它能让我们看到程序正在做的事情――哪些代码正在执行，以及变量的值是多少。
为了看到这些信息，我们需要“闯 入”程序之中，不是那种入室抢劫的“闯入”，而是指我们让调试器暂停住程序的执行。
为此，我们在程序的某个地方设置断点，然后在调试器下运行该程序。
调试器将执行程序，直到到达设置了断点的代码行。
此时，调试器便可以让你查看程序，或者一步步地执行程序，检查代码的每一行是如何影响你的变量的。
让我们在程序的前面，也就是main函数开始的地方，设置一个断点。 
这样，我们就可以查看整个程序的执行过程。要设置一个断点，先把光标移到这一行：
double base_val;
然后选择调试|设置断点（Debug|Toggle Breakpoint）或者按下F5。 
这会在该代码行旁边的侧边栏中设置了一个小红点，表明这一行有一个断点：
你可以使用设置断点命令或者单击小红点，来设置或取消设置该断点。
现在，我们设置了一个断点，可以运行程序了！选择调试|开始 （Debug|Start）或者按下F8。
这样，程序将正常执行，直到遇到断点。在这个例子中，程序会立即达到断点，因为我们将断点设置在了程序的第一行。
现在应该看到了打开的调试器，它看起来大体是这样：
（可能也有其他窗口打开，我们稍后再讲。）
首先要注意的是小圆点下面的三角形，它表示接下来要执行的代码行。
它跟小红点之间相隔着若干行。它之所以没有紧挨着小红点，是因为变量的声明不产生任何的机器代码
（机器代码是代码编译之后生成的可用于处理器执行的代码），因此，尽管断点看起来是在第17行，但实际上它在第20行 
（小圆点和三角形的左边的数字表示行号）。
应该还有一个监视（Watches）窗口打开了，如下图（数字可能不同）：
如果你没有看到这个窗口，四处找找看。它可能躲在其他窗口后面。
我已经展开了监视窗口的两个子项：局部变量（Local variables）和 函数参数（Function Arguments）。
监视窗口会显示出所有当前可用的变量，包括局部变量和函数参数，以及这些变量的值。
注意，这里的值看起来像乱码！这是因为我们还没有对它们进行初始化，这也是接下来的几行程序所要做的事情。
为了执行接下来的几行代码，我们需要告诉调试器向下执行一行（也就是三角形所标识的那 一行）。
Code::Blocks调试器调用下一行指令：
也可以按下F7，它是下一行指令的键盘快捷键。
你可能会奇怪，为什么既有下一行（Next line），又有下一条指令 （Next instruction），我们将始终使用下一行。
下一条指令用于没有调试符号的调试，超出本书讲述范围。
一旦走到下一行，程序就会执行cout语句，输出一条信息到屏幕中， 要求你输入一个值。
如果你尝试输入一个值，没任何效果――因为程序还在调试器的控制之下。
让我们再次按下F7，执行下一行代码。按下F7后，程序会等待用户输入，因为这时候cin函数还未返回。
cin函数需要在返回前得到用户的输入。继续输入值100（跟报告bug的输入用例相一致）。
重复这一过程，分别提供输入值（同样，要跟报告bug的输入用例相一致）给接下来的两个变量，
即输入0.1给利率，输 入1给年数。
现在，到达了这一行代码：
    cout << "After " << years << " you will have " << computeInterest( base_val, rate, years ) << " money" << endl;
再次确认输入是否正确。我们可以通过监视窗口来检查局部变量的值。
目前为止，一切都很好：base的值是100，rate的值是0.1，而years的 值是1。
你说什么？rate不是0.1？是的，它确实不是0.1，而是0.10000000000000001。
不过，这最末尾的1只是浮点数的一种怪异的表示方式（还记得么，浮点数并不是精确的），
它实在太小了，对大多数程序来说不会造成很大影响。
浮点错误可能会累积，在一些程序中引发严重问题。但在这个例子中，它的影响很小。
现在，我们确定一切都没问题，来调查一下computeInterest函数中会发生什么。
做到这一点的方法是使用另一个调试器命令，单步执行 （Step into）：
单步执行会进入当前行的函数里面去执行，而不像下一行命令，只是执行函数然后显示给你最终的结果，
就如刚才在cin函数那里所见的那样。当你需要单步进入一个函数之中进行调试时，使用单步执行命令，
就像我们接下来要做的一样。
单步进入computeInterest函数吧。可是，等等，你可能会奇怪：这条语句里有一堆的函数调用呀？
我们会单步进入cout函数吗？Code::Blocks调试器是很聪明的，它不会单步进入标准库的函数。
在这个例子中，它会绕过那些我们毫无兴趣的函数（标准库的函数），直接单步进入computeInterest函数中。 开始吧。
现在，我们进入了computeInterest函数之中。第一件事是确认函数参数是否正确。
也许我们弄混了参数的顺序。请展开监视窗口里的函数参数部分：
一切正常！
现在，来看看局部变量：
看到什么奇怪的东西了吗？变量i和final_multiplier的值根本就不对劲嘛！
不过，别忘了我们上一次在监视窗口中也看到了局部变量的值很奇怪的情况，那是因为该变量还没被初始化。
使用下一行命令 （F7），执行循环语句，由于它与一些初始化操作相关联，我们看看会发生什么。
循环中的初始化操作只有一行，因此现在可以再次检查局部变量。此时，这两个变量看起来是这样的：
好的，i的值很好，不过，final_multiplier的值是怎么回事儿？它看起来没有正确初始化啊。
而且，接下来要执行的语句即将要用到final_multiplier：
final_multiplier *= (1 + rate);
这条语句的意思是，将final_multiplier乘以 (1 + rate)，再把结果重新赋值给final_multiplier。
但是我们看到final_multiplier并没有被初始化，因此这个乘法的结果将会是个莫名其妙的值。
如何修复这个bug呢？
我们需要在声明final_multiplier变量的语句中，把它也初始化。在这个例子中，它应该被初始化为1。
就是这样，我们发现了问题并解决了它。太感谢你了，调试器！
20.2.1 调试崩溃问题
让我们来看看另一种bug――程序崩溃。崩溃往往是新手程序员最害怕的，因为它们看起来似乎很严重。
但随着时间的推移，崩溃将会成为你最喜欢追踪的bug。这是因为，你会很容易找到发生问题的位置。
程序崩溃是因为数据损坏，所以你可以在程序崩溃的地方停止下 来，调查出到底是哪个数据出现了问题，然后找到问题根源。
下面是一个简单但有问题的程序，它创建了一个有两个节点的链表， 然后输出列表里的每个值。
#include <iostream>

using namespace std;

struct LinkedList
{
    int val;
    LinkedList *next;
};

void printList (const LinkedList *lst)
{
    if ( lst != nullptr )
    {
        cout << lst->val;
        cout << "\n";
        printList( lst->next );
    }
}

int main ()
{
    LinkedList *lst;
    lst = new LinkedList;
    lst->val = 10;
    lst->next = new LinkedList;
    lst->next->val = 11;
    //lst->next->next = nullptr;
    printList( lst );
    //LinkedList *curr;
    //LinkedList *next;
    //curr = lst;
    //while (curr != nullptr)
    //{
    //    next = curr->next;
    //    delete curr;
    //    curr = next;
    //}

    return 0;
}
示例代码45：bug2.cpp
当你运行这个程序时，很遗憾，出问题了。它可能会崩溃，或者进入 一个无限循环。总之，有些事情不对劲！
让我们在调试器里运行它，看看能否有所帮助。选择调试|开始 （Debug|Start），或者按下F8。
几乎是与此同时，调试器弹出一条消息：
发生了一个段错误。段错误发生于不合法的指针使用。
通常，这意味着程序试图引用一个空指针（NULL）或不合法的指针
（要么是一个已经释放的指针，要么是一个从未初始化过的指针）。
你可以把它想象成是程序试图访问一段它没有获得的内存。
我们要怎样才能找出错误指针是从何而来的呢？想一想，编译器在崩溃发生的代码行中停止了。
我们单击对话框中的OK，然后，找到程序中的三角形那一行，看看发生崩溃的代码行：
cout << lst->val;
这一行代码中只有一个指针，即lst。让我们使用监视窗口，看看lst的值是多少。
从监视窗口中，我们可以看到，lst的值是0xbaadf00d8！ 很奇怪的数字，不是吗？
这其实是调试器用来初始化内存分配时使用的一个特殊值。
这一特性只有在调试器下运行时才会使用，这就是为什么你在调试器下运行程序跟在调试器外运行可能会看到不同的行为的原因。
调试器使用一个一致的值来获知你访问了一个不合法的指针，从而立即发起一个段错误，帮助你进行调试。
你可能对这个语法不熟悉，它是一个十六进制数字。十六进制数通常使用0x为前缀，并使用字母A~F来表示数字10~15。
因此，十六进制的0xA跟十进制的10是一样的。
另外一种替代方案是，使用以前存储在变量中的值来定位指针的存储位置。
由于内存是不可预测的，它甚至可能看起来就是合法的，这会使得程序行为非常奇怪，因而难以追踪。
例如，程序不是立即崩溃，而是读到一些不该访问的内存，然后在后来使用该内存时才崩溃。
调试器通过使程序行为一致和确保程序尽可能早地崩溃，这样你就能够尽可能地接近原始的问题，事情就变得简单多了。
现在，我们知道了lst尚未初始化。但是，为什么它没有被初始化呢？ 
来使用编译器的另一个功能――调用栈（call stack）。调用栈显示了 当前所有正在执行中的函数。
以下是在窗口中看到的调用栈的样子：
其中有几列：编号（Nr）是用来指代每个栈帧的数字；地址 （Address）是函数的地址。
函数（Function）是函数的名称及其参数（事实上，你只通过调用栈也可以看到lst=0xbaadf00d）；
最后还有文件（File）和代码行（Line），以便让你找到正在执行的代码行。
当你对程序进行汇编级别的调试时，函数地址能派上大用场。但大多数情况下，你不太需要用到它。
调用栈顶部的函数即为当前正在执行的函数，下面的函数调用了它， 以此类推。
调用栈最底部的函数是main函数，因为它是程序开始执行的第一个函数。
可以看到，对函数printList的调用有三次。前两次调用所拥有的指针是合法的，而第三次调用的指针值是0xbaadf00d。
还记得么，main函数在列表中创建了两个节点。前两次调用printList一定是在使用这两 个节点，
而第三次调用使用的是一个未初始化的指针。我们现在再看看初始化列表的代码，
发现从来没有为列表末尾的节点设置指向下一个节点的值为nullptr。
虽然这个问题解决了，不过你有时候还会想要找到不同的栈帧的更多信息。
你可以切换调试器的上下文到任何一个栈帧，以便检查其局部变量。
请右键单击你感兴趣的栈帧，并选择切换到此栈帧（Switch to this frame）：
调试器将移动三角形，向你显示该栈帧正在进行函数调用的地方。这时你还可以使用监视窗口检查这个栈帧的局部变量。
20.2.2 强行进入一个“悬停”程序
有时候，你碰到的不是简单的崩溃，而是程序“被困住了”，可能是进入了一个无限循环，也可能是在等待一些耗时的系统调用完成。
遇到这种情况，你可以让程序在调试器下执行，等遇到该问题时，让调试器“强行进入”该程序中。
使用一段示例代码来看看要怎么做：
#include <iostream>

using namespace std;

int main ()
{
    int factorial = 1;
    for ( int i = 0; i < 10; i++ )
    {
        factorial *= i;
    }
    int sum = 0;
    for ( int i = 0; i < 10; i++ )
    {
        sum += i;
    }
    int factorial_without_two = 1;
    for ( int i = 0; i < 10; i++ )
    {
        if ( i == 2 )
        {
            continue;
        }
        factorial_without_two *= i;
    }
    int sum_without_two = 0;
    for ( int i = 0; i < 10; i++ )
    {
        if ( i = 2 )
        // if ( i == 2 )
        {
            continue;
        }
        sum_without_two += i;
    }
}
示例代码46：bug3.cpp
当你运行这个程序时，它永远不会退出。它在某些地方“被困住了”。 为了找到这个地方，我们将让它在调试器下运行，等到它被卡住时， 再检查。
首先，编译程序并将它在调试器下运行（选择Debug|Start或按下 F8）。一旦程序开始运行，你会发现它不会退出；
你应该在某些地方被困住了，大概是某种无限循环。让调试器强行进入正在执行的程序，这样我们就可以看到正在发生的事情。
为此，我们选择调试|停止调试器（Debug|Stop Debugger）。停止调试器会导致调试器强行进 入该程序，让你查看当前执行点的信息。（如果程序已经在调试器中 运行的话，你也可以用这种方法来结束调试会话。）
一旦停止程序，你应该看到调用栈变成这个样子（不过，这个例子的调用栈看起来非常地奇怪）：
这里根本没有我们的代码！到底是怎么回事儿呢？你所看到的是“强行进入”一个正在执行的程序所导致的结果。
注意到该调用栈的顶部是ntdll!DbgUiConnectToDbg了吗？ntdll是Windows核心的动态链接库，正在被调用的函数
（即DbgUiConnectToDbg）被用来强行进入一个正在运行的进程。那么，我们正在执行的程序代码在哪里呢？
事实 是，为了强行进入一个进程，调试器创建了另外一个线程（线程是一 种并发执行代码的方式）。
为了闯入该进程，调试器需要能够在我们的原始代码执行的同时，执行一些其他代码。
它通过创建一个新线程来执行闯入进程的代码，从而做到这一点。
我们在前面的例子中没有碰到第二个线程，是因为该进程一开始就设置了断点，所以调试器有足够的控制力，不用创建第二个线程。在这个例子中，我们想要在某个时间点强行进入该程序，以便找出正在执行的代码，而不是在某一行特定代码设置断点。
现在为了找到自己的代码，我们需要切换到正确的线程中。
为了切换线程，我们需要调出线程窗口。选择调试|调试窗口|运行的线程（Debug|Debugging windows|Running threads）：
在线程窗口中，我们看到两个线程：
在活动（Active）这一列中，使用*表示当前线程。在这个例子中，当前线程即为用来强行进入进程的线程。
我们需要切换到其他线程，以便查看关于它的信息。为此，右键单击其他线程，选择切换到此线程 （Switch to this thread）：
现在，可以回到调用栈，看到更多可以理解的信息：
这就是我们的代码了。你将看到，调试器将三角形放在了第29行，指示接下来要执行的代码行。
以下是此段代码：
for ( int i = 0; i < 10; i++ )
{
    if ( i = 2 )
    {
        continue;
    }
    sum_without_two += i;
}
由于程序被困住了，而且现在在一个循环中，一个很自然的猜想是， 这个循环可能没有终止。
怎样证明这个猜想呢？我们一起来看看程序。
不过要小心一点。如果我们只是在调试器中进行下一行这个命令，它将会执行那个用来强行进入进程的线程的代码，
因为它是当前的执行线程。不要执行“下一行”这个命令，而是在自己的代码中设置一个断点，然后让程序运行，直到它到达断点。
我们在if语句这一行放置一个断点，然后继续执行程序（Ctrl-F7）。当程序遇到断点而停止时，我们已经在正确的线程中了，
这时你可以使用下一行这个命令单步执行程序，看到程序正在发生的事情。
有些调试器允许你通过“冻结”线程，选择控制哪个线程为正在运行。但Code::Blocks没有这个选项。
你将总是碰到if ( i = 2 )这条语句，然后回到循环的起始点。
到底怎么回事儿呢？来看看监视窗口里的局部变量i的值。在执行到循环体之中时，i的值为2。
执行完循环代码后，i的值为3。接着，当我们执行if语句这一行时，你会发现，i的值又回到了2。
看来是有人总在把i的值设置成2――这里肯定是if语句无疑。事实上，这是一个常见的等号错误，这里应该用双等号。
顺便提一句，你可能会奇怪：为什么程序从来没有真正到达过continue这一行，为什么它只是直接从if语句跳回到for循环？
这是调试器搞的鬼，有时，一行特定的代码很难有直接匹配的机器代码。
在这个例子中，编译器很难区分if ( x = 2 )语句和continue语句。你以后会时不时看到调试器中执行的代码仿佛跟期望的不一样。
当你调试时，会开始注意到这些特殊的情况，比如刚才遇到的这个。
20.2.3 修改变量
调试时，有时候你可能希望修改变量的值――例如为了确认如果把一个变量设置为特定值后，剩下的代码就能够正常地工作。
你可以使用监视窗口做到这一点：右键单击一个变量，选择改变值（Change Value），然后任意设置想要的值。
但要注意，不要在变量马上要被初始化或被覆盖之前做这件事。
20.2.4 总结
Code::Blocks是一个可以使你迅速上手的调试器。如果你使用的是非Windows的系统，
许多相同的概念同样适用，虽然形式可能稍微不一样。
调试的基本思路是：了解更多程序的状态，使用像断点这样的工具，逐句穿过程序到达合适的位置，
然后通过了解调用栈和各个不同变量的值来理解程序正在做的事情。
实践题
与其他章不同，本章提供一些有问题的程序让你调试，每个程序都存在一些不当行为。
问题1：指数问题
#include <iostream>

using namespace std;

int exponent (int base, int exp)
{
    int running_value;
    // int running_value = 1;
    for ( int i = 0; i < exp; i++ )
    {
        running_value *= base;
    }
    return base;
}

int main()
{
    int base;
    int exp;

    cout << "Enter a base value: ";
    cin >> base;
    cout << "Enter an exponent: ";
    cin >> exp;
    exponent( base, exp );
    // cout << base << "^" << exp << " = " << exponent(base, exp) << endl;
}
示例代码47：practice1.cpp

问题2：相加问题
#include <iostream>

using namespace std;

int sumValues (int *values, int n)
{
    int sum;
    // int sum = 0;
    for ( int i = 0; i <= n; i++ )
    // for ( int i = 0; i < n; i++ )
    {
        sum += values[ i ];
    }
    return sum;
}

int main()
{
    int size;
    cout << "Enter a size: ";
    cin >> size;
    int *values = new int[ size ];
    //for (int i = 0; i < size; i++)
    //{
    //    values[i] = 0;
    //}
    int i;
    // int i = 0;
    while ( i < size )
    {
        cout << "Enter value to add: ";
        cin >> values[ ++i ];
        // cin >> values[ i ];
        // ++i;
    }
    cout << "Total sum is: " << sumValues( values, size ) << endl;

    delete [] values;
}
示例代码48：practice2.cpp

问题3：斐波那契程序的bug
如果不熟悉斐波那契数列，请查阅： http://en.wikipedia.org/wiki/Fibonacci_number。
#include <iostream>

using namespace std;

int fibonacci (int n)
{
    if ( n == 0 )
    // if ( n <= 1 )
    {
        return 1;
        // return n;
    }
    return fibonacci( n - 1 ) + fibonacci( n - 2 );
}

int main()
{
    int n;
    cout << "Enter the number to compute fibonacci for: " << endl;
    cin >> n;
    cout << fibonacci( n ) << endl;
}

示例代码49：practice3.cpp

问题4：列表的错误读取和错误输出
#include <iostream>

using namespace std;

struct Node
{
    int val;
    Node *p_next;
};

int main()
{
    int val;
    Node *p_head;
    // Node *p_head = nullptr;
    while ( 1 )
    {
        cout << "Enter a value, 0 to quit: " << endl;
        cin >> val;
        if ( val = 0 )
        // if ( val == 0 )
        {
            cout << '\n';
            break;
        }
        Node *p_temp = new Node;
        p_temp = p_head;
        // p_temp->p_next = p_head;
        p_temp->val = val;
        p_head = p_temp;
    }
    Node *p_itr = p_head;
    // Node *p_next;
    while ( p_itr != nullptr )
    {
        cout << p_itr->val << endl;
        //p_next = p_itr->p_next;
        // delete p_itr;
        p_itr = p_itr->p_next;
        delete p_itr;
        // p_itr = p_next;
    }
}
示例代码50：practice4.cpp

第三部分 编写大规模程序
注意：如果你从本书的开头一直看到现在，而连一道实践习题都没有做，那么先停下来吧。
如果你没有写过一些代码的话，根本无法理解并运用这一部分的知识。
你将要接触的是本书中最重要的一些知识，但对于没有实践经验的人这些知识没有意义。
从开始到现在我们已经介绍过很多概念，你可以借助它们来实现新的想法。
而现在，我们不仅要讨论如何实现新想法，还要介绍如何实现更大规模的程序。
到目前为止，你还只是写过一些很短的程序，我猜大部分不超过几百行。
当程序规模不是很大的时候，还好，你能凭大脑记住它们；但是，你可能已经发现越长的代码处理起来越困难。
就算你还没有注意这点，也将会在某个时候遇到程序规模太大的情况。
对有些人来说几百行就算长了，对有些人来说则是几千行或者更多， 
然而你记得再多也没用，好记性是个不错的技能，但是没人可以光凭记忆就能完成任何想要做的事。
所有的程序都会随着规模的增大变得无法凭记忆完全理解。打算写个游戏？写个科学仿真程序？还是写个操作系统？
你需要掌握一些更容易设计和理解大规模程序的技巧。
幸运的是，很多程序员涉足这一领域并且开发出了让我们更容易构建大规模程序的技术。
接下来几章中介绍的原理就能让我们写出规模更大、复杂性更高的程序。这些理论同样可以让小程序的设计更加简单。
让我们先来研究一下几个在讨论如何设计大规模程序的时候会反复用到的概念。
我们将从代码本身开始介绍；也就是如何在硬盘上存放代码，让它不只是单个庞大的C++文件。
然后，我们会讲述程序的逻辑设计：如何才能够在写程序的时候不再需要记住每段代码实现的功能细节。
第 21 章 将程序分解
当程序规模越来越庞大的时候，你不会愿意让整个程序都在单个源文件中。
要做改动会很困难，而且当你要找某个东西的时候会找不着北。
一旦程序达到数千行的时候，你肯定想要把它们分开放到几个不同的源文件中。
使用多个源文件，你会更容易知道要找的东西在哪里，因为每个文件都相对较小，
并且所包含的代码也是和程序的某个功能相关的。
多个源文件同样便于程序的设计，因为每个头文件都只包含了与它相关的源代码的接口声明，
这样别的程序就不能调用那些没有在它们头文件中声明的方法或者数据结构。
这听起来可能像是个限制，但是在现实 中，它可以让你更容易把程序的每个子系统自身和那些它们提供给别的子系统的功能分开。
21.1 理解C++的构建过程
在将代码分解到不同的文件中去之前，你需要更多地了解一下C++的编译过程。
其实，编译这个说法并不准确――编译甚至都不包含生成一个可执行文件。
生成一个可执行文件是需要好几个步骤的过程；最重要的步骤是预处理、编译和链接。
从源代码到可执行文件的整个过程最好用构建这个词来表示。
编译只是构建过程中的一部分，不能代表整个构建过程。但是，你会经常看到有人用编译这个词来表示整个过程。
通常情况下，你不需要为每个步骤都单独执行一个命令――比如编译器就会自动调用预处理程序。
21.1.1 预处理
构建过程的第一步就是编译器运行C++语言的预处理程序。C++语言预处理程序的目的是在编译之前对源文件做一些文本的替换。
预处理程序能够理解预处理指令，预处理指令（preprocessor directive）就是那些直接写到源文件中的命令，
它们由预处理程序来处理而不是编译器。
所有的预处理指令都以符号 # 开头。编译器从头到尾都不会看到预处理指令！
例如，下面的这句声明：
#include <iostream>
它告诉预处理程序直接把iostream中的内容放到当前的文件中。每次你包含了一个头文件，
这个头文件都会在编译器看到它之前被全部复制到当前的文件中，并且#include指令会被移除。
预处理程序同样会展开宏指令。宏指令就是一串文字，它将会被别的内容代替，
这些代替它的内容通常比宏指令更复杂一些，是一大串字符。
宏指令可以让你将常量放在合适的地方，以便于更方便地修改。
例如，你可以这样写：
#define MY_NAME "Alex"
然后可以在整个源文件中用MY_NAME来代替"Alex"。
cout << "Hello " << MY_NAME << '\n';
编译器看到的就是：
cout << "Hello " << "Alex" << '\n';
如果你要修改名字，那么只需要修改包含#define的那一行代码，而不是必须对全部的代码来个查找/替换。
宏指令把一些信息集中到一个地 方，这样你在修改它们的时候就更方便了。
如果想要给程序加个代码中任何地方都可以引用的版本号，可以用宏指令来定义它：
#define VERSION 4
...
cout << “The version is ” << VERSION
因为预处理发生在代码编译之前，所以它还可以用来移除代码，有时你想要能够让某些特定的代码只在调试构建的时候才被编译。
为此，你可以告诉预处理程序，只有在某个宏指令定义了的情况下才包含某段代码。
然后，你想要保留这段代码，就定义个宏指令，如果不想要这段代码，就删掉相应的宏指令。
比如，你可能有些用来调试的代码会输出一些变量的值，但是不想让这些代码在任何时候都不停地输出。
你可以实现这样的效果，让调试代码在一定条件下才被包含进构建的过程中。
#include <iosteam>

#define DEBUG

using namespace std;

int main ()
{
    int x;
    int y;
    cout << "Enter value for x :";
    cin >> x;
    cout << "Enter value for y :";
    cin >> y;
    x *= y;
#ifdef DEGUG
    cout << "Variable x: " << x << '\n' << "Variable y: " << y << '\n';
#endif
    // 接下来继续使用x和y
}
示例代码51：define.cpp
如果想要关闭变量值的输出，只要把#define DEBUG注释掉就可以了：
// #define DEBUG
C++语言的预处理程序还支持检测某个宏指令是不是没有定义过。
例如，你可以用#ifndef（是否未定义）指令，来执行只有在DEBUG没有被设置的情况下才需要执行的代码。
我们在讲到使用多个头文件的时候会用到这个知识。
21.1.2 编译
编译是指将源文件（a.cpp）转换为目标文件（a.o或者a.obj）。目标文件以一种计算机处理器能够理解的形式包含了你的程序，
也就是机器语言指令，源代码中的每一个函数都在其中。
每一个源文件都会单独编译，这表示对应的目标文件只包含编译过的源文件所对应的机器语言。
举个例子，如果你编译了（不包括链接的步骤）三个独立的源文件，将得到三个输出的目标文件，
每个目标文件的名字都是.o或者.obj（扩展名取决于所用的编译器）。这些文件每一个都含有从相应的源文件翻译来的机器语言。
但是现在还无法运行它们。你需要把它们转换成操作系统能够使用的可执行文件。这时候链接器就派上用场了。
21.1.3 链接
链接是指使用一堆目标文件再加上库文件来生成一个可执行文件（比如一个exe或者DLL文件）。
链接器以相应的格式先创建一个可执行文件，然后把每个目标文件的内容转移到这个可执行文件中去。
链接器还会处理那些引用了源文件中没有定义过的函数的目标文件。
例如，目标文件中引用了C++标准库当中的函数。每当你调用C++标准库的时候（如cout << “Hi”），
就是在使用自己代码中没有定义过的函 数。库函数当中的函数同样是定义在目标文件中的，
只不过这些目标文件不是你自己写的，它们是编译器厂商提供的。
在编译的时候，正因为你引入了iostream头文件，所以编译器知道对库函数的调用是合法的，
但是又由于这些函数不属于你的cpp文件，所以编译器在调用它们的地方仅仅留下一个标记。
链接器会把所有的目标文件都过一 遍，在每个编译器留下过标记的地方，
它会找到正确的该调用函数的地址然后用这些链接过来的其他文件中的正确的地址把编译器留下的标记都替换掉。
如果你只有一个源文件的话，就只有一个目标文件。链接的步骤一直存在，哪怕是只有单个文件的简单程序。
这步操作有时称为整理。当把程序分散到不同的源文件中时，你就是利用了编译器可以整理所有调用其他源文件中的函数的功能。
如果链接器找不到某个函数的定义，那么它就生成一个未定义函数的错误， 即使代码通过了编译器那关，也不能表示它们没有错误。在链接器那 里，整个程序会第一次被以一种能够发现上述问题的方式查看一遍。
21.1.4 把编译和链接分开的原因
因为不是每个函数都需要定义在同一个目标文件中，将所有的源文件一次编译，之后再把它们链接起来是可行的。
如果你改变了其中的某一个文件（FrequentlyUpdate.cpp），但是没有修改另一个文件（InfrequentlyChanged.cpp），
那么InfrequentlyChanged.cpp所对应的目标文件并不需要重新编译。
在构建项目的时候跳过那些不必要的编译可以省下大量的时间。代码量越大，可以省下的时间就越多。
要想获得按条件编译的最大好处，你需要一个可以记住某个特定的目标文件是否失效的工具，
也就是在上次编译之后改变了这个目标文件所对应的源文件（或者改变了该源文件所包含的某个头文件）。
如果是在Windows上并且使用Code::Blocks，那么你已经有了这一功能。 
如果你用的Mac，那么XCode在你通过File|New|New file…新建文件的时候会自动处理这个问题。
如果用的是Linux，你可以使用一个叫make http://www.gnu.org/software/make/make.html的工具，
可以到这里获得更多的关于makefiles的知识： http://www.cprogramming.com/tutorial/makefiles.html。
 21.2 如何把程序分开到不同的文件中
那么你该如何组织代码来利用分开编译的优势呢？
让我们来看看一个在程序Orig.cpp中有公共代码的简单例子，你现在想要一个新的程序中重用它。
我将以一种按部就班的方式来描述这一过程，这样你可以看到每一步操作，然而在现实当中好多步骤是可以一次搞定的。
21.2.1 第一步：将声明和定义分开
如果没有试过把代码分到不同的文件中去，你可能在函数的声明和函数的定义之间没有一个明显的界限，
那么第一步就是确保所有的函数都有对应的声明，然后把这些声明移到文件的最上面，看上去就像这样：
21.2.2 第二步：找出哪些函数需要共享出去
现在函数声明和函数定义已经分开了，你可以过一遍并找出哪些是这个文件独有的，哪些应该放在公共文件中。
21.2.3 第三步：把共用的函数移到新的文件中
现在你可以把共用的声明移到一个新的文件Shared.h中去了，共用的函数实现也可以移到Shared.cpp。
同时，你需要在Orig.cpp中引入Shared.h。你可以继续调用那些共用的函数，因为它们的声明都在Shared.h中了。
你需要像上述这样来配置，然后构建Orig.cpp时，程序就会把目标文件Shared.obj也链接进来。
我们在下面描述一下这些操作的细节。
21.2.4 看一个完整的例子
下面是一段实现了通用链表的小程序，正好写在了Orig.cpp文件中。 
我们就选择这段代码，并且把它分成一个可以重用的头文件和源文件。
orig.cpp
#include <iostream>

using namespace std;

struct Node
{
    Node *p_next;
    int value;
};

Node *addNode (Node *p_list, int value)
{
    Node *p_new_node = new Node;
    p_new_node->value = value;
    p_new_node->p_next = p_list;

    return p_new_node;
}

void printList (const Node *p_list)
{
    const Node *p_cur_node = p_list;
    while ( p_cur_node != nullptr )
    {
        cout << p_cur_node->value << endl;
        p_cur_node = p_cur_node->p_next;
    }
}

int main ()
{
    Node *p_list = nullptr;
    for ( int i = 0; i < 10; ++i )
    {
        int value;
        cout << "Enter value for list node: ";
        cin >> value;
        p_list = addNode(p_list, value);
    }
    printList(p_list);
}
示例代码52：orig.cpp
首先，我们来把声明和定义分开。简单起见，我只把真正声明的部分 列在下面，其余部分没有变化。
orig.cpp
struct Node
{
    Node *p_next;
    int value;
};

Node *addNode (Node *p_list, int value);
void printList (const Node *p_list);
因为这里不存在文件独有的声明，我们也就不需要做把它们分出去的工作；
可以立刻把这些声明都放到一个新的头文件Shared.h中（或者，就这个例子而言，把这个头文件叫做linkedlist.h）。
我将完整地列出每个文件。
linkedlist.h
struct Node
{
    Node *p_next;
    int value;
};

Node *addNode (Node *p_list, int value);
void printList (const Node *p_list);
示例代码53：linkedlist.h
linkedlist.cpp
#include <iostream>
#include "linkedlist.h" 
 
using namespace std; 

Node *addNode (Node *p_list, int value)
{
    Node *p_new_node = new Node;
    p_new_node->value = value;
    p_new_node->p_next = p_list;

    return p_new_node;
}

void printList (const Node *p_list)
{
    const Node *p_cur_node = p_list;
    while ( p_cur_node != nullptr )
    {
        cout << p_cur_node->value << endl;
        p_cur_node = p_cur_node->p_next;
    }
}

示例代码54：linkedlist.cpp
orig.cpp
#include <iostream>
#include "linkedlist.h" 
 
using namespace std;

int main ()
{
    Node *p_list = nullptr;
    for ( int i = 0; i < 10; ++i )
    {
        int value;
        cout << "Enter value for list node: ";
        cin >> value;
        p_list = addNode(p_list, value);
    }
    printList(p_list);
}

示例代码55：orig_new.cpp
要注意头文件不应该含有任何函数的定义，如果我们在头文件中加了函数的定义，
然后将这个头文件包含进多个源文件中，那么该函数的定义在链接的时候就会出现两次。
这会使链接器感到混乱并且会带来不好的后果。
我们同样需要确保函数的声明在同一个源文件中不能重复出现。 Orig.cpp可能会引入更多的头文件，这些头文件中有些可能也引入了linkedlist.h：
newheader.h
#include "linkedlist.h"
orig.cpp
#include "linkedlist.h"
#include "newheader.h"

orig.cpp引入了两次linkedlist.h，一次直接引入，一次是通过newheader.h的引入而间接的引入。
解决这个问题需要一个引用防护（include guard）。引用防护利用 C++预处理器来控制是否需要引入一个文件。基本的思想是说：
if <我们还没有引入这个文件>       
 <标记一下我们已经引入了这个文件>    
   <引入这个文件>
可以放心地使用这种模式，因为永远都不需要多次引入一个文件。
要实现一个引用防护，我们需要使用#ifndef这个在之前遇到过的预处理命令。
#ifndef语句就是说"if not defined"，对下一个#endif出现之前的代码块都有作用。
#ifndef ORIG_H
#define ORIG_H
//头文件的内容
#endif
这段代码的意思是,如果没人定义过ORIG_H，那么往下执行直到遇见#endif。
想象一下如果有人把这个头文件引入了两次会发生什么，第一次的时候ORIG_H是未定义的，
所以#ifndef的作用域包含了该文件剩下的部分，包括定义ORIG_H的那部分。
（当然，它将ORIG_H定义为空，但 是ORIG_H仍然属于被定义过的）。
下一次该文件被引入的时候，#ifndef是不成立的，这样就没有代码被引入。
你需要为你的头文件引用防护起唯一的名称，一个很好的办法就是在头文件的后面加上_H。
这么做应该能够保证你的引用防护是唯一的， 并且不会和别人的#define值或者引用防护冲突。
如果把代码共享出去或者自己使用了很多共享的代码，你可能还需要在#define中加入自己的名字或者公司的名称。
因为别人可能也创建了一个叫做链表（linked list）的文件。
21.2.5 关于头文件其他要注意的地方
永远不要直接引入.cpp文件。引入.cpp文件会导致问题发生，
因为编译器会把a.cpp文件中的每个函数定义都编译出一个副本放到引入它的那些目标文件中，
然后链接器就会看到同一个函数的很多的定义， 不能这样。
即使非常小心地引入了.cpp文件，你也会享受不到分开编译节省时间的好处。
关于这个规则有一点值得注意，即你应当只有每个函数的一个副本：
 对于每次构建，你都应只有一个包含main函数的源文件。main是程序的入口点，所以只应有它的一个版本。
21.2.6 在开发环境中处理多个源文件
如何设置正确的多文件链接取决于开发环境。我会演示一遍各个开发环境里的设置流程，从Code::Blocks开始。
1. Code::Blocks
在Code::Blocks中，往项目中添加新的源文件你需要选择 File|New|Empty Source File…。
你会被询问是否要将新建的文件加入到当前项目中：
选择Yes。
然后你需要选择一个文件名。当文件名选好之后Code::Blocks会提示让你选择哪个构建配置需要用到这个文件。
对于源文件来说，这是真正的将该文件加入链接的步骤。
选择所有的选项（最典型的是Debug和Release）。尽管你不会需要链接头文件，
但是新建头文件时选择这两个选项也是可以的，因为Code::Blocks很智能不会将头文件添加到链接的选项中。
要使用新的文件，你需要同时添加一个头文件和一个源文件，然后把代码改成像之前讲过的那样。
2. g++
如果使用的是g++，你除了在命令行新建一个文件并且给它一个文件名以外不需要做其他特别的事。
例如，如果有orig.cpp、shared.cpp两个源文件和一个shared.h头文件，你可以用下面的命令编译这两个源文件：
g++ orig.cpp shared.cpp
你不需要在命令行里提到头文件，它应当已经被需要它的.cpp文件包含了。
这个命令会把给出的文件全部重新编译。如果你想要充分利用分开编译的好处，你可以使用-c标识分别编译每个文件：
g++ -c orig.cpp
g++ -c shared.cpp
然后将它们链接起来：
g++ orig.o shared.o
手动来控制分开编译是件单调乏味的过程。使用makefile来实现它就会简单很多。
makefile是你的程序构建过程的描述，它能够为不同的源文件之间的依赖关系编码，
这样只要你改动了一个源文件， makefile就能将任何与这个文件有依赖关系的源文件都重新编译。
makefile超出了本书所要讲述的范围了，但是你可以在 http://www.cprogramming.com/tutorial/makefiles.htm上学习。
就算你不打算学习makefile，现在仍然可以使用下面这个命令继续一次编译所有的C++文件：
g++ orig.cpp shared.cpp
3. XCode
要向XCode项目中添加一个新的源文件可以使用File|New File菜单选项。
如果你要确保新文件显示在左边树形视图的Source文件夹下，那就在点开File|New File…之前选择main.cpp所在的Source目录。
这么做不是必须的，但是可以帮助你保持一切有序。
选择了File|New之后，你会有几个文件类型的选项：
在左边的面板上选择C and C++，然后在右边选择C++ file（或者，如果只是想要添加一个头文件，那就选择Header file）。
如果你想要同时添加一个头文件和一个C++文件，那么就选择C++ file。
在下一个界 面你将有选择同时创建头文件的选项。单击Next。
填写文件的名字，如果你不愿意将文件放在默认的路径下，可以填一个新的路径。
如果你喜欢，接受默认的设置就行了，在这个例子中， 我把它直接添加到add_file目录下了，
add_file与一个叫做add_file的项目相关联。
如果选择创建C++文件，你可以选择同时创建一个头文件；
我在上面的截图中用方框把它框出来了。如果选了它，头文件会在你单击Finish之后自动打开。
XCode会自动设置构建过程来编译你新建的.cpp文件并把它和别的文件链接起来。
问答题
1.下列那个不属于C++构建过程中的一部分？
A. 链接
B. 编译
C. 预处理
D. 后续处理

D
2.你在什么时候会遇到一个关于未定义函数的错误？
A. 在链接的过程中
B. 在编译的过程中
C. 在程序启动时
D. 在你调用方法的时候

A
3.下列哪项会在你重复引入头文件时发生？
A. 重复声明的错误
B. 没有异常，头文件总是只会被载入一次
C. 与头文件本身是如何实现的有关
D. 头文件一次只能被一个源文件引入，所以不会出现问题

A
4.把编译和链接分开有什么好处？
A. 没有好处，这样做会让人感到迷惑并且有可能很慢因为有多个程序要运行
B. 更容易分析错误因为你可以知道问题出自链接器还是编译器
C. 这样做只让有改动的文件重新编译，节省了编译和链接的时间
D. 这样做只让有改动的文件重新编译，节省了编译时间

D
实践题
1.写一个程序包含add、subtract、multiply和divide的函数。
这些函数每个都接收两个整型参数，然后返回相应操作的结果。
用这些函数创造一个计算器。把这些函数的声明放到一个头文件中，但是把函数实现的代码直接写在你的源文件中 。
calculator.h
#pragma once
#ifndef CALCULATOR_H_
#define CALCULATOR_H_

double add(double left, double right);

double subtract(double left, double right);

double multiply(double left, double right);

double divide(double left, double right);

#endif

ch21_p01.cpp
#include <cmath>
#include <iostream>
#include <string>
#include "calculator.h"

using namespace std;

double add(double left, double right)
{
    return (left + right);
}

double subtract(double left, double right)
{
    return (left - right);
}

double multiply(double left, double right)
{
    return (left * right);
}

double divide(double left, double right)
{
    if (right == 0)
    {
        return INFINITY;
    }
    return (left / right);
}

int main()
{
    while (true)
    {
        int choice = 0;
        bool isValidChoice = false;
        while (!isValidChoice)
        {
            choice = 0;

            cout << "Choose from the following operations:\n";
            cout << "0. Exit\n";
            cout << "1. Add\n";
            cout << "2. Subtract\n";
            cout << "3. Multiply\n";
            cout << "4. Divide\n";
            cin >> choice;
            cin.clear();
            cin.ignore(80, '\n');

            if (choice == 0)
            {
                return 0;
            }
            isValidChoice = (0 <= choice && choice <= 4);
            if (!isValidChoice)
            {
                cout << "Please enter a valid number.\n";
            }
            cout << '\n';
        }

        double left = 0;
        cout << "Left-hand side value: ";
        cin >> left;
        cin.clear();
        cin.ignore(80, '\n');
        cout << '\n';

        double right = 0;
        cout << "Right-hand side value: ";
        cin >> right;
        cin.clear();
        cin.ignore(80, '\n');
        cout << '\n';

        double result;
        string operatorSymbol;
        switch (choice)
        {
        case 1:
            result = add(left, right);
            operatorSymbol = "+";
            break;
        case 2:
            result = subtract(left, right);
            operatorSymbol = "-";
            break;
        case 3:
            result = multiply(left, right);
            operatorSymbol = "*";
            break;
        case 4:
            result = divide(left, right);
            operatorSymbol = "/";
            break;
        default:
            result = add(left, right);
            operatorSymbol = "+";
            break;
        }
        cout << left << " " << operatorSymbol << " " << right << " = " << result << "\n\n";
    }
}
显示结果如下
Choose from the following operations:
0. Exit
1. Add
2. Subtract
3. Multiply
4. Divide
1

Left-hand side value: 3

Right-hand side value: 6

3 + 6 = 9

Choose from the following operations:
0. Exit
1. Add
2. Subtract
3. Multiply
4. Divide
2

Left-hand side value: 3

Right-hand side value: 6

3 - 6 = -3

Choose from the following operations:
0. Exit
1. Add
2. Subtract
3. Multiply
4. Divide
3

Left-hand side value: 3

Right-hand side value: 6

3 * 6 = 18

Choose from the following operations:
0. Exit
1. Add
2. Subtract
3. Multiply
4. Divide
4

Left-hand side value: 3

Right-hand side value: 6

3 / 6 = 0.5

Choose from the following operations:
0. Exit
1. Add
2. Subtract
3. Multiply
4. Divide
0

2.将上面所写程序中的加减乘除的函数实现从你的计算器程序代码中拿出来，放到一个单独的源文件中。
calculator.h
#pragma once
#ifndef CALCULATOR_H_
#define CALCULATOR_H_

double add(double left, double right);

double subtract(double left, double right);

double multiply(double left, double right);

double divide(double left, double right);

#endif

calculator.cpp
#include <cmath>
#include "calculator.h"

double add(double left, double right)
{
    return (left + right);
}

double subtract(double left, double right)
{
    return (left - right);
}

double multiply(double left, double right)
{
    return (left * right);
}

double divide(double left, double right)
{
    if (right == 0)
    {
        return INFINITY;
    }
    return (left / right);
}

ch21_p02.cpp
#include <cmath>
#include <iostream>
#include <string>
#include "calculator.h"

using namespace std;

int main()
{
    while (true)
    {
        int choice = 0;
        bool isValidChoice = false;
        while (!isValidChoice)
        {
            choice = 0;

            cout << "Choose from the following operations:\n";
            cout << "0. Exit\n";
            cout << "1. Add\n";
            cout << "2. Subtract\n";
            cout << "3. Multiply\n";
            cout << "4. Divide\n";
            cin >> choice;
            cin.clear();
            cin.ignore(80, '\n');

            if (choice == 0)
            {
                return 0;
            }
            isValidChoice = (0 <= choice && choice <= 4);
            if (!isValidChoice)
            {
                cout << "Please enter a valid number.\n";
            }
            cout << '\n';
        }

        double left = 0;
        cout << "Left-hand side value: ";
        cin >> left;
        cin.clear();
        cin.ignore(80, '\n');
        cout << '\n';

        double right = 0;
        cout << "Right-hand side value: ";
        cin >> right;
        cin.clear();
        cin.ignore(80, '\n');
        cout << '\n';

        double result;
        string operatorSymbol;
        switch (choice)
        {
        case 1:
            result = add(left, right);
            operatorSymbol = "+";
            break;
        case 2:
            result = subtract(left, right);
            operatorSymbol = "-";
            break;
        case 3:
            result = multiply(left, right);
            operatorSymbol = "*";
            break;
        case 4:
            result = divide(left, right);
            operatorSymbol = "/";
            break;
        default:
            result = add(left, right);
            operatorSymbol = "+";
            break;
        }
        cout << left << " " << operatorSymbol << " " << right << " = " << result << "\n\n";
    }
}
编译命令如下
 g++ -o ch21_p02 ch21_p02.cpp calculator.cpp
显示结果如下
Choose from the following operations:
0. Exit
1. Add
2. Subtract
3. Multiply
4. Divide
1

Left-hand side value: 3

Right-hand side value: 9

3 + 9 = 12

Choose from the following operations:
0. Exit
1. Add
2. Subtract
3. Multiply
4. Divide
2

Left-hand side value: 3

Right-hand side value: 9

3 - 9 = -6

Choose from the following operations:
0. Exit
1. Add
2. Subtract
3. Multiply
4. Divide
3

Left-hand side value: 3

Right-hand side value: 9

3 * 9 = 27

Choose from the following operations:
0. Exit
1. Add
2. Subtract
3. Multiply
4. Divide
4

Left-hand side value: 3

Right-hand side value: 9

3 / 9 = 0.333333

Choose from the following operations:
0. Exit
1. Add
2. Subtract
3. Multiply
4. Divide
0

3.找出你在二叉树那一章的练习中实现的二叉树代码，把其中所有的结构体声明和函数声明移到单独的头文件中。
将所有的函数实现都放到同一个源文件中。写一个小程序来测试二叉树的基本功能。
把ch17_p06.cpp拆开分成3个文件
binarytree.h
#pragma once
#ifndef BINARYTREE_H_
#define BINARYTREE_H_
#include <string>

using namespace std;

struct node
{
    int depth_of_node;
    int count_of_nodes;
    string key;
    string value;
    node *p_parent;
    node *p_left;
    node *p_right;
};

static const int maxNumberOfNodes = 100;

node *insert (node *p_tree, string key, string value);
node *search (node *p_tree, string key);
void destroy_tree (node *p_tree);
node *remove (node *p_tree, string key);
node *find_max (node *p_tree);
node *remove_max_node (node *p_tree, node *p_max_node);

node* add_entry(node* p_tree);
node* update_entry(node* p_tree);
node* delete_entry(node* p_tree);
void display_entry(node* p_tree);

void printSorted(node *tree);
void InOrder (node *p_tree, int *currentCount, string nodeKeys[]);
void InOrderNonRecursive (node *p_tree, int *currentCount, string nodeKeys[]);
void postOrderNonRecursive (node *p_tree, int *currentCount, string nodeKeys[]);
void preOrderNonRecursive (node *p_tree, int *currentCount, string nodeKeys[]);
void destroyTreePostOrder (node *p_tree);

#endif

binarytree.cpp
#include <cstdlib>
#include <ctime>
#include <iostream>
#include "binarytree.h"

using namespace std;

void printSorted(node *tree)
{
    int currentCount = 0;
    string nodeKeys[maxNumberOfNodes];
    InOrder (tree, &currentCount, nodeKeys);

    for (int i = 0; i < currentCount; i++)
    {
        cout << "key | value = " << nodeKeys[i] << '\n';
    }
    cout <<"\n\n";
}

node *insert (node *p_tree, string key, string value)
{
    int left_depth, right_depth;
    int left_count, right_count;

    if ( p_tree == nullptr )
    {
        node *p_new_tree = new node;
        p_new_tree->depth_of_node = 0;
        p_new_tree->count_of_nodes = 1;
        p_new_tree->p_parent = nullptr;
        p_new_tree->p_left = nullptr;
        p_new_tree->p_right = nullptr;
        p_new_tree->key = key;
        p_new_tree->value = value;
        return p_new_tree;
    }
    if ( key == p_tree->key )
    {
        p_tree->value = value;
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
    else if( key < p_tree->key )
    {
        p_tree->p_left = insert( p_tree->p_left, key, value);
        if (p_tree->p_left != nullptr)
        {
            p_tree->p_left->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
    else
    {
        p_tree->p_right = insert( p_tree->p_right, key, value );
        if (p_tree->p_right != nullptr)
        {
            p_tree->p_right->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
}

node *search (node *p_tree, string key)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    else if ( key == p_tree->key )
    {
        return p_tree;
    }
    else if ( key < p_tree->key )
    {
        return search( p_tree->p_left, key );
    }
    else
    {
        return search( p_tree->p_right, key );
    }
}
void preOrderNonRecursive (node *p_tree, int *currentCount, string nodeKeys[])
{
   node *last_node;
    node *check_node;

    if (p_tree == nullptr)
    {
        return;
    }
    last_node = nullptr;
    check_node = p_tree;
    nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
    (*currentCount)++;
    if (check_node->p_left != nullptr)
    {
        last_node = check_node;
        check_node = check_node->p_left;
    }
    else
    {
        if (check_node->p_right != nullptr)
        {
            last_node = check_node;
            check_node = check_node->p_right;
        }
        else
        {
            return;
        }
    }
    while(last_node != nullptr && check_node != nullptr)
    {
        if(last_node == check_node->p_parent)
        {
            nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
            (*currentCount)++;
            if (check_node->p_left != nullptr)
            {
                last_node = check_node;
                check_node = check_node->p_left;
            }
            else
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
        }
        else
        {
            if(last_node == check_node->p_left)
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
            else
            {
                last_node = check_node;
                check_node = check_node->p_parent;
            }
        }
    }
}
void postOrderNonRecursive (node *p_tree, int *currentCount, string nodeKeys[])
{
    node *last_node;
    node *check_node;

    if (p_tree == nullptr)
    {
        return;
    }
    last_node = nullptr;
    check_node = p_tree;
    if (check_node->p_left != nullptr)
    {
        last_node = check_node;
        check_node = check_node->p_left;
    }
    else
    {
        if (check_node->p_right != nullptr)
        {
            last_node = check_node;
            check_node = check_node->p_right;
        }
        else
        {
            nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
            (*currentCount)++;
            return;
        }
    }
    while(last_node != nullptr && check_node != nullptr)
    {
        if(last_node == check_node->p_parent)
        {
            if (check_node->p_left != nullptr)
            {
                last_node = check_node;
                check_node = check_node->p_left;
            }
            else
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
                    (*currentCount)++;
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
        }
        else
        {
            if(last_node == check_node->p_left)
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
                    (*currentCount)++;
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
            else
            {
                nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
                (*currentCount)++;
                last_node = check_node;
                check_node = check_node->p_parent;
            }
        }
    }
}
void destroyTreePostOrder (node *p_tree)
{
    node *last_node;
    node *check_node;
    node *temp_node;

    if (p_tree == nullptr)
    {
        return;
    }
    last_node = nullptr;
    check_node = p_tree;
    if (check_node->p_left != nullptr)
    {
        last_node = check_node;
        check_node = check_node->p_left;
    }
    else
    {
        if (check_node->p_right != nullptr)
        {
            last_node = check_node;
            check_node = check_node->p_right;
        }
        else
        {
            temp_node = check_node;
            cout << temp_node->key << '\n';
            delete temp_node;
            return;
        }
    }
    while(last_node != nullptr && check_node != nullptr)
    {
        if(last_node == check_node->p_parent)
        {
            if (check_node->p_left != nullptr)
            {
                last_node = check_node;
                check_node = check_node->p_left;
            }
            else
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    temp_node = check_node;
                    last_node = check_node;
                    check_node = check_node->p_parent;
                    cout << temp_node->key << '\n';
                    delete temp_node;
                }
            }
        }
        else
        {
            if(last_node == check_node->p_left)
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    temp_node = check_node;
                    last_node = check_node;
                    check_node = check_node->p_parent;
                    cout << temp_node->key << '\n';
                    delete temp_node;
                }
            }
            else
            {
                temp_node = check_node;
                last_node = check_node;
                check_node = check_node->p_parent;
                cout << temp_node->key << '\n';
                delete temp_node;
            }
        }
    }
}
void InOrderNonRecursive (node *p_tree, int *currentCount, string nodeKeys[])
{
    node *last_node;
    node *check_node;

    if (p_tree == nullptr)
    {
        return;
    }
    last_node = nullptr;
    check_node = p_tree;
    if (check_node->p_left != nullptr)
    {
        last_node = check_node;
        check_node = check_node->p_left;
    }
    else
    {
        nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
        (*currentCount)++;
        if (check_node->p_right != nullptr)
        {
            last_node = check_node;
            check_node = check_node->p_right;
        }
        else
        {
            return;
        }
    }
    while(last_node != nullptr && check_node != nullptr)
    {
        if(last_node == check_node->p_parent)
        {
            if (check_node->p_left != nullptr)
            {
                last_node = check_node;
                check_node = check_node->p_left;
            }
            else
            {
                nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
                (*currentCount)++;
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
        }
        else
        {
            if(last_node == check_node->p_left)
            {
                nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
                (*currentCount)++;
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
            else
            {
                last_node = check_node;
                check_node = check_node->p_parent;
            }
        }
    }
}

void InOrder (node *p_tree, int *currentCount, string nodeKeys[])
{
    if (p_tree != nullptr)
    {
        InOrder (p_tree->p_left, currentCount, nodeKeys);
        nodeKeys[ (*currentCount) ] = p_tree->key + " | " + p_tree->value;
        (*currentCount)++;
        InOrder (p_tree->p_right, currentCount, nodeKeys);
    }
}

void destroy_tree (node *p_tree)
{
    if ( p_tree != nullptr )
    {
        destroy_tree( p_tree->p_left );
        destroy_tree( p_tree->p_right );
        delete p_tree;
    }
}

node *find_max (node *p_tree)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->p_right == nullptr )
    {
        return p_tree;
    }
    else
    {
        return find_max( p_tree->p_right );
    }
}
node *remove_max_node (node *p_tree, node *p_max_node)
{
    int left_depth, right_depth;
    int left_count, right_count;

    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree == p_max_node )
    {
        return p_max_node->p_left;
    }
    else
    {
        p_tree->p_right = remove_max_node( p_tree->p_right, p_max_node);
        if (p_tree->p_right != nullptr)
        {
            p_tree->p_right->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
}
node *remove (node *p_tree, string key)
{
    int left_depth, right_depth;
    int left_count, right_count;

    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->key == key )
    {
        if ( p_tree->p_left == nullptr )
        {
            node *p_right_subtree = p_tree->p_right;
            delete p_tree;
            return p_right_subtree;
        }
        if ( p_tree->p_right == nullptr )
        {
            node *p_left_subtree = p_tree->p_left;
            delete p_tree;
            return p_left_subtree;
        }
        node *p_left_subtree = p_tree->p_left;
        node *p_right_subtree = p_tree->p_right;
        node *p_max_node = find_max( p_left_subtree );
        p_max_node->p_left = remove_max_node( p_tree->p_left, p_max_node );
        if (p_max_node->p_left != nullptr)
        {
            p_max_node->p_left->p_parent = p_max_node;
        }
        p_max_node->p_right = p_right_subtree;
        if (p_max_node->p_right != nullptr)
        {
            p_max_node->p_right->p_parent = p_max_node;
        }
        if (p_max_node->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_max_node->p_left->depth_of_node;
            left_count = p_max_node->p_left->count_of_nodes;
        }
        if (p_max_node->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_max_node->p_right->depth_of_node;
            right_count = p_max_node->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_max_node->depth_of_node = right_depth + 1;
        }
        else
        {
            p_max_node->depth_of_node = left_depth + 1;
        }
        p_max_node->count_of_nodes = left_count + right_count + 1;
        delete p_tree;
        return p_max_node;
    }
    else if ( key < p_tree->key )
    {
        p_tree->p_left = remove( p_tree->p_left, key);
        if (p_tree->p_left != nullptr)
        {
            p_tree->p_left->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
    else
    {
        p_tree->p_right = remove( p_tree->p_right, key);
        if (p_tree->p_right != nullptr)
        {
            p_tree->p_right->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
}

void display_entry(node *p_tree)
{
    string name = "";
    node *temp_node;

    do
    {
        name = "";
        cout << "Please enter a name from the address book to display:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( temp_node = search(p_tree, name) ) == nullptr )
        {
            cout << "The name can not find in the address book.\n";
            continue;
        }

        cout << '\n';
        cout << name << " | " << temp_node->value << "\n\n";
    }
    while (name != "");
}
node *add_entry(node *p_tree)
{
    string name = "";
    string email = "";
    node *temp_node;

    do
    {
        name = "";
        cout << "Please enter a name for the address book:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( temp_node = search(p_tree, name) ) != nullptr )
        {
            cout << "The name already exists.\n";
            cout << "Please enter a unique name to add.\n";
            continue;
        }
        email = "";
        cout << "Please enter an email address for the name:\n";
        getline(cin, email, '\n');
        if (email == "")
        {
            break;
        }

        p_tree = insert(p_tree, name, email);
        cout << "\n\n";
    }
    while (name != "");

    return p_tree;
}
node *update_entry(node *p_tree)
{
    string name = "";
    string email = "";
    node *temp_node;

    do
    {
        name = "";
        cout << "Please enter a name to update:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( temp_node = search(p_tree, name) ) == nullptr )
        {
            cout << "The name can not find in the address book.\n";
            cout << "Please enter an existing name to update.\n";
            continue;
        }
        email = "";
        cout << "Please enter a new email address for the name:\n";
        getline(cin, email, '\n');
        if (email == "")
        {
            break;
        }

        p_tree = insert(p_tree, name, email);
        cout << "\n\n";
    }
    while (name != "");

    return p_tree;
}
node *delete_entry(node *p_tree)
{
    string name = "";
    node *temp_node;

    do
    {
        name = "";
        cout << "Please enter a name to delete:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( temp_node = search(p_tree, name) ) == nullptr )
        {
            cout << "The name can not find in the address book.\n";
            cout << "Please enter an existing name to delete.\n";
            continue;
        }

        p_tree = remove(p_tree, name);
        cout << name << " has been removed from the address book.\n\n";
    }
    while (name != "");

    return p_tree;
}

ch21_p03.cpp
#include <iostream>
#include <string>
#include "binarytree.h"

using namespace std;

int main()
{
    node *tree = nullptr;
    bool exitProgram = false;
    int choice = 0;
    int numberOfNodes = 0;

    while(!exitProgram)
    {
        choice = 0;
        if (tree == nullptr)
        {
            numberOfNodes = 0;
        }
        else
        {
            numberOfNodes = tree->count_of_nodes;
        }
        cout << "Please choose from the following options:\n";
        cout << "0. Exit\n";
        cout << "1. Add entry\n";
        if (numberOfNodes > 0)
        {
            cout << "2. Update entry\n";
            cout << "3. Delete entry\n";
            cout << "4. Display entry\n";
        }
        cin >> choice;
        cin.clear();
        cin.ignore(80, '\n');

        cout << '\n';

        switch (choice)
        {
        case 0:
            exitProgram = true;
            break;
        case 1:
            tree = add_entry(tree);
            cout << "Display tree in sorted order\n";
            printSorted(tree);
            cout << '\n';
            break;
        case 2:
            tree = update_entry(tree);
            cout << "Display tree in sorted order\n";
            printSorted(tree);
            cout << '\n';
            break;
        case 3:
            tree = delete_entry(tree);
            cout << "Display tree in sorted order\n";
            printSorted(tree);
            cout << '\n';
            break;
        case 4:
            display_entry(tree);
            break;
        default:
            exitProgram = true;
            break;
        }
    }

    destroyTreePostOrder(tree);
}
编译命令如下
g++ -o ch21_p03 ch21_p03.cpp binarytree.cpp

显示结果如下
Please choose from the following options:
0. Exit
1. Add entry
1

Please enter a name for the address book:
WEIYAYUN
Please enter an email address for the name:
1043836212@qq.com


Please enter a name for the address book:
Peter Smith
Please enter an email address for the name:
123456789@qq.com


Please enter a name for the address book:
Hello world
Please enter an email address for the name:
abcdefg@qq.com


Please enter a name for the address book:

Display tree in sorted order
key | value = Hello world | abcdefg@qq.com
key | value = Peter Smith | 123456789@qq.com
key | value = WEIYAYUN | 1043836212@qq.com



Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
4

Please enter a name from the address book to display:
Peter Smith

Peter Smith | 123456789@qq.com

Please enter a name from the address book to display:

Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
2

Please enter a name to update:
WEIYAYUN
Please enter a new email address for the name:
hijklmn@qq.com


Please enter a name to update:

Display tree in sorted order
key | value = Hello world | abcdefg@qq.com
key | value = Peter Smith | 123456789@qq.com
key | value = WEIYAYUN | hijklmn@qq.com



Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
3

Please enter a name to delete:
Hello world
Hello world has been removed from the address book.

Please enter a name to delete:

Display tree in sorted order
key | value = Peter Smith | 123456789@qq.com
key | value = WEIYAYUN | hijklmn@qq.com



Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
0

Peter Smith
WEIYAYUN

第22章 程序设计方法介绍
既然已经解决了如何在硬盘上以一种便于大规模程序编写的方式来存储代码，
那么我们可以把注意力集中在这个问题的下一步――如何在逻辑上组织代码，让它们便于编辑和处理。
我们先看一些最常见的问题，这些问题都是在程序规模越来越大时会遇到的。
22.1 冗余代码
尽管在介绍函数的时候简单地提及了冗余代码的问题，但是我们现在还需要更深入地看看这个问题。
随着程序规模越来越大，逻辑会一遍一遍地重复。
比如，你在写一个游戏，就需要代码把不同的图形元素绘制到屏幕上（例如，飞船或者子弹）。
在能够绘制飞船之前，你需要最基本的功能来绘制一个像素，一个像素就是屏幕上使用二维坐标来定位的一个有颜色的点。
大部分时候， 可以借助于图形库来进行这种绘制。
你还需要代码来实现使用这些像素点（或者图形库可以提供的别的基本图形，如线段和圆）绘制出飞船、子弹等。
你可能需要在代码中很频繁地进行这样的绘制――每次飞船或者子弹移动时它们肯定需要被重新绘制。
如果每次需要绘制子弹的时候都写一段绘制子弹的代码，那么你就写了很多冗余代码。
这些冗余代码给程序带来了不必要的复杂度，让程序难以让人理解。 
你需要有标准的方式来做某些事情，像绘制飞船或者子弹，而不是让代码任意的部分都可以去重复这些过程。这样做道理何在呢？
我们假设要修改一个东西――也许是子弹的颜色吧。如果在10个不同的地方都有显示子弹的代码，你最后不得不修改每个地方，
而这仅仅为了修改一下子弹的颜色。这太痛苦了！
每次要绘制一颗子弹，你得重新写一遍绘制子弹的代码，或者去找一段现成的代码复制粘贴过来，
也许还要修改一些变量名来避免冲突。 
哪种方式你都得想想“如何绘制一颗子弹”而不是“给我绘制一颗子弹”。 
此外，在回头看代码时，你还要去弄清楚这段代码是实现什么功能的 ――相对来说很难弄清楚下面这段代码：
circle( 10, 10, 5);
fillCircle(10, 10, RED);
是在绘制一颗子弹，而这样表示：
displayBullet(10, 10);
更容易让人明白这是在绘制一颗子弹。
函数可以赋予代码块有意义的名字，这样在阅读代码时你可以记得这段代码是实现什么功能的。
也许你尚未体会到，当构建更大规模的程序时，花在阅读代码上的时间将比写代码的时间还多，
所以好的命名和好的函数会产生很大的影响。
22.2 假定数据是如何存储的
冗余的问题不光会影响到算法。我们来看看另外一段有隐藏冗余的示例代码。
假使你想要实现一个棋类程序，其中棋盘上的位置用数组来表示如何呢？每次访问棋盘，你可以简单地访问一下数组。
初始化数组的第二列，让它存储所有的白色卒子，你可能这样写：
enum ChessPiece { WHITE_PAWN, WHITE_ROOK, /* 其他变量 */ };

// ... 很多代码

for ( int i = 0; i < 8; i++ )
{
    board[i][1] = WHITE_PAWN;
}
过后，如果想要查看某个方格上放的是什么棋子，可以直接从数组中读取：
// ... 很多代码
if ( board[0][0] == WHITE_ROOK )
{
    /* 运行某些代码 */
}
随着程序规模的扩大，越来越多的访问棋盘的代码会乱七八糟到处都是。这有什么害处呢？
你每次从数组中读取数据时并不是在做重复的事，仅仅需要一行代码，对吧？
但是，你又确实在做重复的事――在 重复使用同样的数据结构。
重复地使用相同的数据结构时，你的代码其实是已经假设了棋盘是如何存储的。
你不是在重复算法逻辑，而是在重复数据是如何存储的这一假设。
这么来思考吧，这里因为凑巧只需要一行代码来访问棋盘，这并不意味着在什么时候访问棋盘都是只需要一行代码。
如果你以不同的方式来实现棋盘，也许需要更复杂的技巧来访问棋盘。
复杂的棋类程序使用一种不同于数组的方式来表示棋盘。
（它们使用Bitboard而不是数组，Bitboard每次访问的时候都需要不止一行代码。）
如果要写一个棋类程序，我可能开始时先使用数组，这样可以专注于基本的算法，然后再去考虑代码优化得更快的问题。
但是为了更方便地改变棋盘的存储，我会把数组隐藏起来。可是，如何隐藏数组呢？
上一次需要隐藏某些实现逻辑时，我们是想要隐藏绘制子弹的细节。
 我们是通过使用一个可以调用的函数，而不是直接写出绘制子弹到屏幕上的代码来实现的。
这里同样可以使用一个函数来隐藏棋盘存储的细节。不直接访问数组，而是调用一个访问数组的函数。
例如，你可以写一个像下面这个getPiece一样的函数：
int getPiece (int x, int y)
{
    return board[x][y];
}
我们发现上面的函数需要两个参数，然后它返回一个数值，就像访问数组一样。
这样做并没有让你少写代码，因为需要传入的参数和之前 一样――一个x坐标和一个y坐标。
所不同的是访问棋盘的方式现在被隐藏在这个函数中了。你其余的代码中可以（并且应该）调用这个函数来访问数组。
你可能还需要几个在棋盘上设置棋子的函数，如果你决定改变棋盘的存储方式，可以仅仅修改这几个函数。
使用函数来隐藏细节的思想有时称为函数抽象。应用函数抽象意味着你应当把任何重复的操作放到一个函数中。
让这个函数为调用者指定输入和输出，但避免让调用者知道这个函数是如何实现的。
这里的如何实现可以是使用的算法，或者是使用的数据结构。
该函数允许它的调用者利用它所提供的接口的可靠性承诺，从而不需要知道这个函数是如何实现的。
这里有一些使用函数来隐藏数据和算法的好处。
1.让以后的工作更加轻松。你只需要使用一个之前写的函数就行了， 而不是一直记着怎样实现算法逻辑。
只要你相信该函数对于合法的输入都能正常工作，就可以信任它的输出而不需要记得它是如何工作的。
2.一旦你能够信任某个函数“可以工作”，就可以开始一遍遍地使用它来写代码解决问题。
你无需担心任何细节（像如何访问棋盘），这样就可以专注于解决新的问题（比如如何实现AI）。
3.如果发现逻辑中有个错误，你不需要修改代码中的很多地方，只需要修改一个函数而已。
4.如果通过函数来隐藏数据结构，你同样也会增强自己存储和表现数据的灵活性。
你可以先用效率不高但是便于编写的方式，然后如果有需要的话，再把它替换成更快速高效的实现方式，
完成这些只需要修改少数几个函数，别的都不用动。
22.3 设计和注释
在写精心设计的函数同时，你还应该给它们注释。虽然给函数添加注释不是听起来那么简单。
好的注释可以解答读者的疑问。
本书示例中你看到的那些注释――像这个：
// 声明变量i并初始化为3
int i = 3;
可不是真正需要写的注释！这样的注释只是为了回答编程初学者的疑问；
但是在现实环境中，阅读你代码的人是已经了解了C++的。
还有更糟糕的情况，随着时间的推移注释过期了。
如果有人读了这样的注释，不光浪费了他们的时间，还可能让他们完全误解了代码的意义。
写一些表达疑问的注释会好很多，比如“啊，这貌似是个奇怪的方式。 他们为什么这么做呢”，
或者“这个函数可以接受哪些参数值，它们又代表什么意思呢？”
下面是一个注释的示例，你应当努力为所写的函数加上这样的注释：
/*  
* 根据给定的正整数n计算斐波那契数列值。如果n的值小于1，  
* 该函数返回 1 
*/   
int fibonacci (int n);
好的注释并不是嗦的注释――你不应该每一行代码都加注释。
我通常给那些为了在文件以外调用的函数添加注释，并且我会给特别绕人或者看起来怪异的代码添加解释性的注释。
有一个过分精简注释的坏习惯，那就是在开发周期的最后再来添加注 释。
一旦编码都已完成，再去回顾并且添加有意义的注释就显得太晚 了；
你所做的只是添加你在阅读代码时所能了解到的信息。在写代码的同时就添加的注释是最有用的。
问答题
1.使用函数而不直接访问数据的好处是什么？
A. 函数可以被编译器优化来提供更快的访问速度
B. 函数可以对调用者隐藏自己的实现逻辑，这样便于改变该函数的调用者
C. 使用函数是在多个源文件之间共享同一个数据结构的唯一途径
D. 没有什么好处

B
2.在什么情况下应该把代码放进一个通用的函数中呢？
A. 在你需要调用它的时候
B. 在你开始从很多地方调用同一段代码的时候
C. 在编译器开始抱怨函数太大而不能编译的时候
D. B和C

B
3.为什么要隐藏数据结构的表示方式？
A. 让数据结构更便于替换
B. 让使用该数据结构的代码更容易让人理解
C. 让代码中别的地方使用该数据结构时更容易
D. 以上都正确

D
第23章 隐藏结构化数据的表示
到目前为止，你已经看到如何隐藏存储在全局变量或者数组中的数据。
隐藏数据并不局限于这几个例子。创建结构体时往往是你最想隐藏数据的时候之一。
这可能让你觉得奇怪：毕竟一个结构体有一个非常特殊的布局和可以存储的一系列数值。
当你以一组字段的方式看待它们时，结构体无法提供隐藏实现细节的方式（例如它们以何种形式存储哪些字段）。
实际上，你可能觉得奇怪：“难道一个结构体的全部意义不是为了提供一些特定的数据吗？为什么要隐藏这些数据的表示呢？”
事实证明，还可以用另外一种方式来思考结构体，在这种方式下的确需要隐藏数据。
大部分时候，当有一堆相关的数据，真正重要的并不是你如何存储这些数据而是用这些数据做什么。
这一点非常重要，它可以成为一个观念变革。所以我将再重复一遍：真正重要的并不是如何存储数据，而是如何使用数据。
让我们举一个简单例子―― 字符串。
除非你真正自己实现字符串类，否则无所谓怎么存储字符串。
对于任何一段运用字符串的代码，重要的是如何得到字符串的长度、访问单个字符或者显示字符串。
字符串的实现可能使用一个字符数组，然后用另一个变量来存储长度，也可以使用一个链表，
或者使用一个你从来没听说过的C++的特性。
作为字符串的使用者，无所谓字符串是怎么实现的，重要的是可以用字符串做什么。
你可以做许多事，C++标准库提供的字符串类可以做约35种操作，而且大部分时候它们中的大部分操作都是用不到的。
你经常需要在不暴露实现某个数据类型的原始数据的基础上创建某个该数据类型。
例如，当创建一个字符串时，你不需要担心保存字符的缓冲区。
STL中的vector和map正是这样工作的；你不需要为了使用它们而去了解它们的实现方式。
使用函数来隐藏结构的布局
你可以通过创建与结构体相关联的函数来隐藏具体的字段。
例如，想象一个小棋盘代表局势和双方的移动（白色或黑色）。我们将使用枚举类型来存储棋子和将要走棋的玩家：
enum ChessPiece { EMPTY_SQUARE, WHITE_PAWN /* 其他变量 */ };
enum PlayerColor { PC_WHITE, PC_BLACK };

struct ChessBoard
{
    ChessPiece board[ 8 ][ 8 ];
    PlayerColor whose_move;
};
你可以创建操作棋盘的函数，把棋盘作为该函数的参数：
ChessPiece getPiece (const ChessBoard *p_board, int x, int y)
{
    return p_board->board[ x ][ y ];
}

PlayerColor getMove (const ChessBoard *p_board)
{
    return p_board->whose_move;
}
void makeMove (ChessBoard *p_board, int from_x, int from_y, int to_x, int to_y)
{
    p_board->board[ to_x ][ to_y ] = p_board->board[ from_x ][ from_y ];
    p_board->board[ from_x ][ from_y ] = EMPTY_SQUARE;
}
你可以把它们当做其他任何一个函数一样使用：
ChessBoard b;
// 首先需要初始化棋盘 
 
// 接下来就可以像下面这样使用它了
getMove( & b ); 
 
makeMove( & b, 0, 0, 1, 0 );
// 把一个棋子从0，0 移动到1，0
这是一个好方式，事实上，C语言程序员使用这种方式已经很多年 了。
另一方面，这些函数只与ChessBoard结构体相关联，因为它们正好把ChessBoard作为一个参数。
没有地方明确地表示："这类函数应该被当做该结构体的核心部分。"
一个结构体不仅包含数据，还包含操纵数据的函数，这样不是很好吗？
C++认真考虑了这个想法并且直接把它构建到了语言中。
为了支持这种风格，C++引入了方法的概念――方法就是作为某个结构体的一部分来声明的函数
（在之前关于STL的部分我们接触过方法）。
不像不受约束的函数和结构体没有什么关联，方法可以很简单地操作存储在结构中的数据。
方法的作者把方法作为结构体的一部分来声明，这样就直接把方法与结构体联系在了一起。
声明了结构体的方法部分以后，方法的调用者就不需要把该结构体作为一个单独的参数了！虽然这需要特殊的语法 。
方法声明和调用的语法
来看看如果把函数变成方法会怎么样：
enum ChessPiece { EMPTY_SQUARE, WHITE_PAWN /* 其他变量 */ };
enum PlayerColor { PC_WHITE, PC_BLACK };

struct ChessBoard
{
    ChessPiece board[ 8 ][ 8 ];
    PlayerColor whose_move;
    ChessPiece getPiece (int x, int y)
    {
        return board[ x ][ y ];
    }
    PlayerColor getMove ()
    {
        return whose_move;
    }
    void  makeMove (int from_x, int from_y, int to_x, int to_y)
    {
        board[ to_x ][ to_y ] = board[ from_x ][ from_y ];
        board[ from_x ][ from_y ] = EMPTY_SQUARE;
    }
};
示例代码56：method.cpp
首先可以看到，方法是在结构体里面声明的。这很明显，这些方法应被作为该结构体的基本组成部分来看待。
此外，这些方法声明不需要单独接收一个ChessBoard类型的参数――在方法里面，结构体所有的字段都可以直接使用。
写下board[ x ][ y ]就可以直接访问该方法所在结构体的棋盘。可是代码怎么知道它所使用的方法属于哪个结构体的实例呢？
（如果有不止一个ChessBoard怎么办？）
像下面这样调用一个方法：
ChessBoard b;
// 初始化棋盘的代码

b.getMove();
调用与某个结构体相关联的函数时看上去和访问该结构体的字段几乎是一样的。
在内部，是编译器在处理如何让方法访问它所在结构体中的数据的细节。
从概念上讲，< variable >.< method >的语法是将< variable >传递给< method >的简写形式。
现在你明白了为什么在讲STL那一章中我们需要这个语法了吧，那些函数就像这些方法一样运作。
把方法的定义从结构体中移出来
把所有的函数体都包含在结构体中真的会很乱而且让人难以理解。
所幸，你可以把方法拆分成一个在结构体中的声明和一个放在结构体之外的定义。例子如下：
enum ChessPiece { EMPTY_SQUARE, WHITE_PAWN /* 其他变量*/ };
enum PlayerColor { PC_WHITE, PC_BLACK };

struct ChessBoard
{
    ChessPiece board[ 8 ][ 8 ];
    PlayerColor whose_move;
    ChessPiece getPiece (int x, int y);
    PlayerColor getMove ();
    void makeMove (int from_x, int from_y, int to_x, int to_y);
};
现在方法的声明在结构体内部了，但是其他方面看上去像普通函数的原型。
方法的定义需要一些方式回头来把它们自身与结构体联系起来。
我们可以使用一个特殊的“范围”语法来表示该方法是属于某个结构体的。
这个语法就是像<structure name>::<method name>这样来写方法的名字，但是从其他方面来看代码没有变化：
ChessPiece ChessBoard::getPiece (int x, int y)
{
    return board[ x ][ y ];
}

PlayerColor ChessBoard::getMove ()
{
    return whose_move;
}

void  ChessBoard::makeMove (int from_x, int from_y, int to_x, int to_y)
{
    board[ to_x ][ to_y ] = board[ from_x ][ from_y ];
    board[ from_x ][ from_y ] = EMPTY_SQUARE;
}
本书的后面部分，我会把行数稍微多一点的方法的声明和定义分开。
有些业内人士建议永远不要在结构体内部定义方法因为这样会暴露方法是如何实现的，而这是不必要的。
你暴露的方法实现越多，就越可能有人依赖方法的具体实现细节来写代码而不是仅仅依靠方法的接口。
本书中，我有时会把方法声明放在类中就是为了节省点空间。
问答题
1.你为什么需要使用方法而不是直接使用结构体的字段？
A.因为方法更加易读
B.因为使用方法程序会更快
C.你不应该使用方法，就应该直接使用字段
D.这样做你可以修改数据的表现形式

D
2.下列哪个定义了与结构体struct MyStruct { int func(); };相关联的方法？
A.int func() { return 1; }
B.MyStruct::int func() { return 1; }
C.int MyStruct::func() { return 1; }
D.int MyStruct func () { return 1; }

C
3.你为什么想要把方法的定义内联在一个类中？
A.这样可以让该类的使用者看到这个方法是怎么工作的
B.因为这样会让代码跑得更快
C.你不能这么做！这样会泄漏方法实现的细节
D.你不能这么做，这会让程序跑得更慢

C
实践题
1.写一个结构体为井字棋的棋盘提供接口。用基于该结构体的方法来实现一个双人对战的井字棋。
要求像走棋和检测是否某个玩家胜利这样的基本操作都属于该结构体的接口。
TicTacToe.h
#pragma once
#ifndef TICTACTOE_H_
#define TICTACTOE_H_

#include <string>

using namespace std;

enum SquareState
{
	TTTS_Blank,
	TTTS_O,
	TTTS_X
};

struct Position
{
	int row = 0;
	int column = 0;
};

struct TicTacToeSquare
{
	SquareState state = TTTS_Blank;
	Position position;
};

struct TicTacToeBoard
{
	static int const minToWin = 4;
	static int const maxSize = 50;
	TicTacToeSquare gameBoard[maxSize][maxSize];
	int size = maxSize;
	bool playerXInSession;

	void populateGameBoard();
	static TicTacToeSquare createSquare(int row, int column, SquareState state);
	TicTacToeSquare getSquare(Position boardPosition);
	string setPlayer(bool playerXInSession);
	
	bool validIndex(Position boardPosition);
	bool choiceTaken(Position boardPosition);
	void setChoice(Position boardPosition);

	SquareState choiceSquare();
	bool choiceWins();
	bool boardIsFull();

	static string translateEnumToString(SquareState squareState);
	void drawBoard();
};

#endif

TicTacToe.cpp
#include <iostream>
#include <string>
#include "TicTacToe.h"

using namespace std;

void TicTacToeBoard::populateGameBoard()
{
    for (int i = 0; i < maxSize; i++)
    {
        for (int j = 0; j < maxSize; j++)
        {
            gameBoard[i][j] = createSquare(i, j, TTTS_Blank);
        }
    }
}

TicTacToeSquare TicTacToeBoard::createSquare(int row, int column, SquareState state)
{
    TicTacToeSquare newSquare;
    newSquare.position.row = row;
    newSquare.position.row = column;
    newSquare.state = state;

    return newSquare;
}

TicTacToeSquare TicTacToeBoard::getSquare(Position boardPosition)
{
    if (validIndex(boardPosition))
    {
        return gameBoard[boardPosition.row][boardPosition.column];
    }
    TicTacToeSquare empty;
    return empty;
}

string TicTacToeBoard::setPlayer(bool playerXInSession)
{
    this->playerXInSession = playerXInSession;
    if (playerXInSession)
    {
        return "X";
    }
    return "O";
}

bool TicTacToeBoard::validIndex(Position boardPosition)
{
    return ( ( (boardPosition.row >= 0) && (boardPosition.column >= 0) ) &&
             ( (boardPosition.row < size) && (boardPosition.column < size) ) );
}

bool TicTacToeBoard::choiceTaken(Position boardPosition)
{
    return (gameBoard[boardPosition.row][boardPosition.column].state != TTTS_Blank);
}

void TicTacToeBoard::setChoice(Position boardPosition)
{
    gameBoard[boardPosition.row][boardPosition.column].state = choiceSquare();
}

SquareState TicTacToeBoard::choiceSquare()
{
    if (playerXInSession)
    {
        return TTTS_X;
    }
    return TTTS_O;
}

bool TicTacToeBoard::choiceWins()
{
    SquareState choiceCheck = choiceSquare();;
    double score;

    for (int i = 0; i < size; i++)
    {
        score = 0;
        for (int j = 0; j < size; j++)
        {
            if (gameBoard[i][j].state == choiceCheck)
            {
                score++;
                if (score >= minToWin)
                {
                    return true;
                }
            }
            else
            {
                score = 0;
            }
        }
    }

    for (int j = 0; j < size; j++)
    {
        score = 0;
        for (int i = 0; i < size; i++)
        {
            if (gameBoard[i][j].state == choiceCheck)
            {
                score++;
                if (score >= minToWin)
                {
                    return true;
                }
            }
            else
            {
                score = 0;
            }
        }
    }

    score = 0;
    for (int i = 0; i < size; i++)
    {
        if (gameBoard[i][i].state == choiceCheck)
        {
            score++;
            if (score >= minToWin)
            {
                return true;
            }
        }
        else
        {
            score = 0;
        }
    }

    score = 0;
    int maxIndex = size - 1;
    for (int i = 0; i < size; i++)
    {
        if (gameBoard[i][maxIndex - i].state == choiceCheck)
        {
            score++;
            if (score >= minToWin)
            {
                return true;
            }
        }
        else
        {
            score = 0;
        }
    }

    return false;
}

bool TicTacToeBoard::boardIsFull()
{
    for (int i = 0; i < size; i++)
    {
        for (int j = 0; j < size; j++)
        {
            if (gameBoard[i][j].state == TTTS_Blank)
            {
                return false;
            }
        }
    }
    return true;
}

string TicTacToeBoard::translateEnumToString(SquareState squareState)
{
    switch (squareState)
    {
    case TTTS_Blank:
        return " ";
    case TTTS_O:
        return "O";
    case TTTS_X:
        return "X";
    default:
        return "~";
    }
}

void TicTacToeBoard::drawBoard()
{
    cout << "Tic-Tac-Toe\n";
    cout << minToWin << "-in-a-row are needed to win!\n";
    string horizontalBar = " _";
    for (int row = 0; row < size; row++)
    {
        horizontalBar += "__";
    }

    for (int row = 0; row <= size; row++)
    {
        if (row == 0)
        {
            for (int column = 0; column <= size; column++)
            {
                if (column == 0)
                {
                    cout << " ";
                }
                else
                {
                    cout << " " << column;
                }
            }
            cout << "\n";
        }
        else
        {
            cout << horizontalBar << "\n";
            for (int column = 0; column <= size; column++)
            {
                if (column == 0)
                {
                    cout << row;
                }
                else
                {
                    Position boardPosition;
                    boardPosition.row = row - 1;
                    boardPosition.column = column - 1;
                    TicTacToeSquare currentSquare = getSquare(boardPosition);
                    cout << "|" << translateEnumToString(currentSquare.state);
                }
            }
            cout << "|\n";
        }
    }
    cout << horizontalBar << "\n\n";
}

ch23_p01.cpp
#include <iostream>
#include <string>
#include "TicTacToe.h"

using namespace std;

int main()
{
    bool gameFinished = false;
    bool playerXInSession = true;
    string player = "";
    int row = 0;
    int column = 0;

    int sizeUsed = 4;
    TicTacToeBoard gameBoard;

    cout << "Please specify the number of spaces to be used for the rows/columns of the square board:\n";
    cout << "(Default is " << gameBoard.minToWin << " and max is " << gameBoard.maxSize << ")\n";
    cin >> sizeUsed;
    cin.clear();
    cin.ignore(80, '\n');

    if (sizeUsed < gameBoard.minToWin)
    {
        sizeUsed = gameBoard.minToWin;
    }
    if (sizeUsed > gameBoard.maxSize)
    {
        sizeUsed = gameBoard.maxSize;
    }

    gameBoard.size = sizeUsed;
    gameBoard.populateGameBoard();

    do
    {
        row = 0;
        column = 0;
        player = gameBoard.setPlayer(playerXInSession);

        gameBoard.drawBoard();

        cout << "Player " << player << ", choose your next board position to claim:\n";

        cout << "Row: \n";
        cin >> row;
        cin.clear();
        cin.ignore(80, '\n');
        row--;

        cout << "Column: \n";
        cin >> column;
        cin.clear();
        cin.ignore(80, '\n');
        column--;

        Position boardPosition;
        boardPosition.row = row;
        boardPosition.column = column;

        if (!gameBoard.validIndex(boardPosition))
        {
            cout << "That is an invalid choice. Please try again.\n";
            continue;
        }

        if (gameBoard.choiceTaken(boardPosition))
        {
            cout << "That square is already taken. Please try again.\n";
            continue;
        }

        gameBoard.setChoice(boardPosition);

        if (gameBoard.choiceWins())
        {
            cout << "Player " << player << " wins!\n";
            gameFinished = true;
        }
        else if (gameBoard.boardIsFull())
        {
            cout << "Board is full. The game is a tie!\n";
            gameFinished = true;
        }

        playerXInSession = !playerXInSession;
    }
    while (!gameFinished);
}
编译命令如下
g++ -o ch23_p01 ch23_p01.cpp TicTacToe.cpp

显示结果如下
Please specify the number of spaces to be used for the rows/columns of the square board:
(Default is 4 and max is 50)
6
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | | | |
 _____________
2| | | | | | |
 _____________
3| | | | | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
3
Column:
3
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | | | |
 _____________
2| | | | | | |
 _____________
3| | |X| | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
3
Column:
1
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | | | |
 _____________
2| | | | | | |
 _____________
3|O| |X| | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
2
Column:
4
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | | | |
 _____________
2| | | |X| | |
 _____________
3|O| |X| | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
4
Column:
1
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | | | |
 _____________
2| | | |X| | |
 _____________
3|O| |X| | | |
 _____________
4|O| | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
1
Column:
5
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | |X| |
 _____________
2| | | |X| | |
 _____________
3|O| |X| | | |
 _____________
4|O| | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
4
Column:
2
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | |X| |
 _____________
2| | | |X| | |
 _____________
3|O| |X| | | |
 _____________
4|O|O| | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
3
Column:
4
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | |X| |
 _____________
2| | | |X| | |
 _____________
3|O| |X|X| | |
 _____________
4|O|O| | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
5
Column:
1
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | |X| |
 _____________
2| | | |X| | |
 _____________
3|O| |X|X| | |
 _____________
4|O|O| | | | |
 _____________
5|O| | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
4
Column:
4
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | |X| |
 _____________
2| | | |X| | |
 _____________
3|O| |X|X| | |
 _____________
4|O|O| |X| | |
 _____________
5|O| | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
6
Column:
1
Player O wins!

第24章 类
Bjarne Stroustrup在创造C++的时候，真正想强化的是由方法来定义结构体的思想，而不是实现结构体时碰巧用到的那些数据。
他本来可以通过扩展已有结构体的概念来实现他想要的，但是他没有，相反他创造了一个新的概念：类。
类就如同一个结构体，只不过它能够定义哪些方法和数据是属于类内部，哪些方法是为了提供给该类的使用者的。
你应当把类的意思想作和种类一样，定义一个类的时候就是在创造一个新类别的东西或者说新种类的东西。
它不再具有作为结构化数据的内涵性，相反，类是由那些它作为接口向外部提供的方法来定义的。
类甚至能够防止你不小心使用其具体的实现细节。
是这样的――在C++中，阻止不属于某个类的方法使用该类的内部数据是可以实现的。
实际上，当你声明一个类的时候，默认情况就是除了该类自身的那些方法以外，没有人能够使用该类的任何内容！
你得明确地表示哪些内容可以被公共访问。
使数据在类以外不可访问的功能可以让编译器检查程序员没有在使用那些他们不该碰的数据。
这对于程序的可维护性来说可谓是神来之笔。你可以修改类的一些基本的东西，比如棋盘的存储方式，
而不用担心这样会破坏类以外的代码。
就算项目只有你一个人在做，保证没有人能“作弊”以及看到方法的内部实现，实际上也是一件美事。
其实，说方法很有用还有另外一个原因，你很快就会看到的，只有方法才能访问“内部”数据。
从这里往后，在我想要隐藏数据存储方式的时候我都会使用类，在绝对没理由隐藏的时候我会使用结构体。
你可能会惊讶于结构体用的有多稀少――数据隐藏就是这么有价值。
在实现类并且需要一个辅助性的结构体来存放部分数据时，是唯一要使用结构体的时候。
由于辅助性的结构体仅仅是针对这一个类的，并且不需要公开暴露，所以通常没有必要把它写成一个完整的类。
如我所说，没有硬性的需求一定要这样做，但是这么做是约定俗成的。
24.1 隐藏数据的存储方式
我们来研究一下类里面隐藏数据的语法――你如何使用一个类来隐藏一些数据同时把一些方法提供给所有人呢？
类可以让你把每个方法和字段（通常被称为类的成员）归结为公共或者私有――公共成员所有人都可以访问，
私有成员只有该类中其他的成员可以访问。还有第三种类型，叫做protected，我们稍后会讨论到。
下面是个例子，将方法都声明为公共的，而所有的数据都声明成私有的：
enum ChessPiece { EMPTY_SQUARE, WHITE_PAWN /* 及其他 */ };
enum PlayerColor { PC_WHITE, PC_BLACK };

class ChessBoard
{
public:
    ChessPiece getPiece (int x, int y);
    PlayerColor getMove ();
    void makeMove (int from_x, int from_y, int to_x, int to_y);

private:
    ChessPiece _board[ 8 ][ 8 ];
    PlayerColor _whose_move;
};

// 方法的定义和之前完全相同！
ChessPiece ChessBoard::getPiece (int x, int y)
{
    return _board[ x ][ y ];
}

PlayerColor ChessBoard::getMove ()
{
    return _whose_move;
}

void  ChessBoard::makeMove (int from_x, int from_y, int to_x, int to_y)
{
    _board[ to_x ][ to_y ] = _board[ from_x ][ from_y ];
    _board[ from_x ][ from_y ] = EMPTY_SQUARE;
}
示例代码57：class.cpp
我们发现这个类的声明和之前结构体的声明看上去很像，除了一个主要的区别。我使用了两个新的关键字：public和private。
任何在public关键字之后声明的东西，所有人都可以通过该类的对象来使用
（在这里就是getPiece、getMove 和makeMove这些方法）。
任何出现在private之后的东西，都只能被ChessBoard类自身的方法访问到 （_board和_whose_move）。
我还在类的每个私有元素之前加了下划线，以便分别出哪些是私有的，但是这不是C+＋的要求。
这么做一开始看上去有点丑陋，但是在阅读代码的时候你会发现它作用可大了！
如果你要遵守这个习惯，就要确保在下划线后面没有紧跟着一个大写字母；那样做可能会在编译器那里产生冲突。
只要你保证声明私有变量或者方法时在下划线后面跟一个小写字母，就不会出乱子。
顺便说一下，你可以随意调换public和private的位置。下面的这个类和前面的那个类声明了相同的公共内容：
class ChessBoard
{
public:

    ChessPiece getPiece (int x, int y);

private:
    ChessPiece _board[ 8 ][ 8 ];
    PlayerColor _whose_move;

public:
    int getMove ();
    void makeMove (int from_x, int from_y, to_x, to_y);
};
我自己写代码的时候，总是先以一个public区块开始，跟着来个private区块。
这么做是在强调public区块是为了使用这个类的人而写的（也就是别的程序员），
因为它会是使用这个类的人首先会看到的东西。
这些用户当然是指别的程序员，而不是软件的用户。很多情况下， 你将会是自己所写类的用户。
24.2 声明一个类的实例
声明一个类的实例就如同声明一个结构体的实例一样：
ChessBoard b;
在类上进行方法的调用也是和结构体的一模一样：
b.getMove();
虽然有一个小的术语上的差别。你声明某个类的一个变量时，那个变量通常被称为对象。
对象这个词应当代表现实世界中事物的抽象，比如方向盘――这种暴露一个很小的接口而后面隐藏了很多复杂的东西。
当你要把汽车往左转的时候，只需要打方向盘――不必担心那些齿轮是怎么工作的。
你所要做的就是转动方向盘并且踩油门。所有的细节都被隐藏在一个基本的用户界面之后。
在C++中，一个对象所有的实现细节都被隐藏在一系列公共方法的调用之后――这些方法就是组成类的“用户接口”的东西。
一旦你定义了一个接口，类可以随意地去实现它――怎么存储数据以及方法如何去实现，都由你来决定。 
24.3 类的职责
在你创建一个C++类的时候，相当于创建了一个新的数据类型。
你的新数据类型就如同一个整型或者一个字符串，但是功能更强大。
你已经看到过这种思想――在C++中，字符串是一个类，实际上，字符串类是你可以使用的一个新的数据类型。
公共和私有的思想在你想要创建新的数据类型时非常有意义：你是想要为外部提供一些特定的功能和一些特定的接口。
举个例子，一个字符串提供了显示自己，处理子字符串或者单个的字符，以及获取字符串长度这样的基本属性等功能。
字符串自身是如何实现真的无关紧要了。
如果把创建一个类想作是在定义一个新的类型，那么首先需要做的就是弄清哪些需要设为公共的：你想要类做哪些事。
公共的任何东西都可以被使用这个类的人所用――你应当把它作为接口来对待，
就像一个函数，有一个接口包含了所要接收的参数和返回值。
这是你需要仔细思考的东西，因为一旦开始使用这个接口，再去改变这个接口的话，就需要同时修改所有的这个接口的使用者。
由于方法是公共的，就会有很多很多的调用者――你无法找到一个轻松的方式来限制接口被调用的次数。
没有人会发明一个全新的开车方法因为这样的话所有人都要重新学习一遍怎么开车！
但是发明一个新型的引擎是完全可以的， 比如从纯汽油过渡到混合动力，因为这并没有改变接口，这改变的只是具体实现。
一旦你提出了一个公共接口，就应该开始思考如何去实现组成接口的这些公共方法。
任何用来实现公共方法的方法或者字段，如果不需要设为public就应该设为private。
与公共接口相反，私有方法和数据是很便于修改的。
只有该类的方法可以使用类的这些私有成员（公共方法和私有方法都可以）。
把实现细节设为私有，在以后如果决定要重新实现类的功能，你就有机会修改它们。
（第一次就把它都写对是很困难的）记住混合动力的汽车就是个例子！
我的建议很简单：永远不要把数据字段设为public，将方法默认都设为private，
如果你确信哪些方法应该设为pubic，那么再把它们移到公共接口中。
从private到public简单，从public到private很难――正所谓覆水难收。
如果你需要为某个特定的字段提供访问接口，那么就写一些方法来获取以及设置它们的数值：
如果它们是用来读取变量的， 那么这些方法通常称为获取方法（getter），
如果是用来写入变量 的，则称为设置方法（setter）。
从不把字段设为public的做法有时看上去有点迂腐。你不是得写很多获取方法和设置方法，
写很多像getMove这样的函数什么都不做只是返回一个如 _whose_move这样的私有字段吗？
不错，有时确实是这么回事。在你意识到需要修改一个不起眼的获取方法来添加某种功能却发现自己陷入困境的时候，
写这些方法消耗的少量精力就不值一提了。
举个例子，你可能会决定从把一个值存储在变量中修改为通过其他的一些变量来计算出这个值。
如果没写获取方法，而是让所有人都是以public字段的形式来访问该数据，这时你就傻眼了。
可能你会想出一些例子，其中有些字段可以很安全地设为public。但是我的建议是不要去尝试。
在前期为自己省下一点敲键盘的时间， 但是却给以后埋藏了一个潜在的大问题，
而且尝试这种错误的后果是产生一个糟糕设计，你还无法轻易地修改它。
private真正的意义是什么
某个东西被声明成private并不意味着就有了全面的安全保障。
一个类的私有字段都被存储在内存中，就像公共字段一样，通常私有字段紧挨着公共字段；
任何代码都可以用神奇指针的把戏来读取这些数据。
操作系统和编程语言不会为保护私有数据免受恶意的第三方攻击做出任何保证。
把数据设为私有可以让编译器阻止对于私有数据的意外使用――不是为了增强安全保障。
虽然这么做没有提供安全保障，但是仍然很有用。
顺便说一下，有一个广泛使用的编程术语来形容使用公共方法来隐藏私有数据：封装。
封装意味着隐藏你的实现（封装它），这样使用类的人只需要处理构成类的接口的那一系列方法就行了。
也许使用像“数据隐藏”或者“实现细节”的词组来形容更形象一点，但是封装是你会时常遇到的术语。
现在你已经知道它是什么意思了。
24.4 小结
类是现实中大部分C++程序的一个基本的组成部分。类可以让程序员创建易于理解和操作的大规模的设计。
现在你已经学过了类的一个强大特性――隐藏数据的能力――接下来的几章会介绍更多类的特性。
问答题
1.为什么要使用私有数据？
A.为了让数据更安全，免受黑客攻击
B.为了防止其他程序员接触那些数据
C.为了分清楚哪些数据是应该只用来实现类的
D.你不应使用私有数据，那样会使程序更难写

C
2.类和结构体有什么不同？
A.没什么不同
B.类默认所有成员都是公共的
C.类默认所有成员都是私有的
D.类可以让你指定字段是公共的还是私有的，结构体不能

C
3.你应该怎样处理类当中的数据字段？
A.把它们默认设为公共的
B.把它们默认设为私有，如果有需要就移到公共的部分
C.永远不要把它们设为公共的
D.类通常都没有数据，但是如果有， 直接使用

C
4.你如何决定一个方法是否应该设为公共的？
A.永远不要把方法设为公共的
B.一直把方法设为公共的
C.如果需要使用这些方法来实现类的主要特性就把它设为公共的，否则设为私有的
D.如果有人可能会想要使用这个方法，那么就把它设为公共的

C
实践题
1.把上一章结尾实践题中的结构体（表示一个井字棋盘的）拿出来并且用类来重新实现它，
把有公共作用的方法设为公共的，把数据和辅助性的方法设为私有的。再看看你需要修改多少代码？
TicTacToe.h
#pragma once
#ifndef TICTACTOE_H_
#define TICTACTOE_H_

#include <string>

using namespace std;

enum SquareState
{
	TTTS_Blank,
	TTTS_O,
	TTTS_X
};

struct Position
{
	int row = 0;
	int column = 0;
};

struct TicTacToeSquare
{
	SquareState state = TTTS_Blank;
	Position position;
};

class TicTacToeBoard
{
public:
    static int const minToWin = 4;
    static int const maxSize = 50;
    int size = maxSize;

    void populateGameBoard();
    string setPlayer(bool playerXInSession);

    bool validIndex(Position boardPosition);
    bool choiceTaken(Position boardPosition);
    void setChoice(Position boardPosition);

    bool choiceWins();
    bool boardIsFull();

    void drawBoard();

private:
    bool _playerXInSession = true;
    TicTacToeSquare _gameBoard[maxSize][maxSize];

    static TicTacToeSquare createSquare(int row, int column, SquareState state);
    TicTacToeSquare getSquare(Position boardPosition);
    SquareState choiceSquare();
    static string translateEnumToString(SquareState squareState);
};

#endif

TicTacToe.cpp
#include <iostream>
#include <string>
#include "TicTacToe.h"

using namespace std;

void TicTacToeBoard::populateGameBoard()
{
    for (int i = 0; i < maxSize; i++)
    {
        for (int j = 0; j < maxSize; j++)
        {
            _gameBoard[i][j] = createSquare(i, j, TTTS_Blank);
        }
    }
}

TicTacToeSquare TicTacToeBoard::createSquare(int row, int column, SquareState state)
{
    TicTacToeSquare newSquare;
    newSquare.position.row = row;
    newSquare.position.row = column;
    newSquare.state = state;

    return newSquare;
}

TicTacToeSquare TicTacToeBoard::getSquare(Position boardPosition)
{
    if (validIndex(boardPosition))
    {
        return _gameBoard[boardPosition.row][boardPosition.column];
    }
    TicTacToeSquare empty;
    return empty;
}

string TicTacToeBoard::setPlayer(bool playerXInSession)
{
    _playerXInSession = playerXInSession;
    if (_playerXInSession)
    {
        return "X";
    }
    return "O";
}

bool TicTacToeBoard::validIndex(Position boardPosition)
{
    return ( ( (boardPosition.row >= 0) && (boardPosition.column >= 0) ) &&
             ( (boardPosition.row < size) && (boardPosition.column < size) ) );
}

bool TicTacToeBoard::choiceTaken(Position boardPosition)
{
    return (_gameBoard[boardPosition.row][boardPosition.column].state != TTTS_Blank);
}

void TicTacToeBoard::setChoice(Position boardPosition)
{
    _gameBoard[boardPosition.row][boardPosition.column].state = choiceSquare();
}

SquareState TicTacToeBoard::choiceSquare()
{
    if (_playerXInSession)
    {
        return TTTS_X;
    }
    return TTTS_O;
}

bool TicTacToeBoard::choiceWins()
{
    SquareState choiceCheck = choiceSquare();;
    double score;

    for (int i = 0; i < size; i++)
    {
        score = 0;
        for (int j = 0; j < size; j++)
        {
            if (_gameBoard[i][j].state == choiceCheck)
            {
                score++;
                if (score >= minToWin)
                {
                    return true;
                }
            }
            else
            {
                score = 0;
            }
        }
    }

    for (int j = 0; j < size; j++)
    {
        score = 0;
        for (int i = 0; i < size; i++)
        {
            if (_gameBoard[i][j].state == choiceCheck)
            {
                score++;
                if (score >= minToWin)
                {
                    return true;
                }
            }
            else
            {
                score = 0;
            }
        }
    }

    score = 0;
    for (int i = 0; i < size; i++)
    {
        if (_gameBoard[i][i].state == choiceCheck)
        {
            score++;
            if (score >= minToWin)
            {
                return true;
            }
        }
        else
        {
            score = 0;
        }
    }

    score = 0;
    int maxIndex = size - 1;
    for (int i = 0; i < size; i++)
    {
        if (_gameBoard[i][maxIndex - i].state == choiceCheck)
        {
            score++;
            if (score >= minToWin)
            {
                return true;
            }
        }
        else
        {
            score = 0;
        }
    }

    return false;
}

bool TicTacToeBoard::boardIsFull()
{
    for (int i = 0; i < size; i++)
    {
        for (int j = 0; j < size; j++)
        {
            if (_gameBoard[i][j].state == TTTS_Blank)
            {
                return false;
            }
        }
    }
    return true;
}

string TicTacToeBoard::translateEnumToString(SquareState squareState)
{
    switch (squareState)
    {
    case TTTS_Blank:
        return " ";
    case TTTS_O:
        return "O";
    case TTTS_X:
        return "X";
    default:
        return "~";
    }
}

void TicTacToeBoard::drawBoard()
{
    cout << "Tic-Tac-Toe\n";
    cout << minToWin << "-in-a-row are needed to win!\n";
    string horizontalBar = " _";
    for (int row = 0; row < size; row++)
    {
        horizontalBar += "__";
    }

    for (int row = 0; row <= size; row++)
    {
        if (row == 0)
        {
            for (int column = 0; column <= size; column++)
            {
                if (column == 0)
                {
                    cout << " ";
                }
                else
                {
                    cout << " " << column;
                }
            }
            cout << "\n";
        }
        else
        {
            cout << horizontalBar << "\n";
            for (int column = 0; column <= size; column++)
            {
                if (column == 0)
                {
                    cout << row;
                }
                else
                {
                    Position boardPosition;
                    boardPosition.row = row - 1;
                    boardPosition.column = column - 1;
                    TicTacToeSquare currentSquare = getSquare(boardPosition);
                    cout << "|" << translateEnumToString(currentSquare.state);
                }
            }
            cout << "|\n";
        }
    }
    cout << horizontalBar << "\n\n";
}

ch24_p01.cpp
#include <iostream>
#include <string>
#include "TicTacToe.h"

using namespace std;

int main()
{
    bool gameFinished = false;
    bool playerXInSession = true;
    string player = "";
    int row = 0;
    int column = 0;

    int sizeUsed = 4;
    TicTacToeBoard gameBoard;

    cout << "Please specify the number of spaces to be used for the rows/columns of the square board:\n";
    cout << "(Default is " << gameBoard.minToWin << " and max is " << gameBoard.maxSize << ")\n";
    cin >> sizeUsed;
    cin.clear();
    cin.ignore(80, '\n');

    if (sizeUsed < gameBoard.minToWin)
    {
        sizeUsed = gameBoard.minToWin;
    }
    if (sizeUsed > gameBoard.maxSize)
    {
        sizeUsed = gameBoard.maxSize;
    }

    gameBoard.size = sizeUsed;
    gameBoard.populateGameBoard();

    do
    {
        row = 0;
        column = 0;
        player = gameBoard.setPlayer(playerXInSession);

        gameBoard.drawBoard();

        cout << "Player " << player << ", choose your next board position to claim:\n";

        cout << "Row: \n";
        cin >> row;
        cin.clear();
        cin.ignore(80, '\n');
        row--;

        cout << "Column: \n";
        cin >> column;
        cin.clear();
        cin.ignore(80, '\n');
        column--;

        Position boardPosition;
        boardPosition.row = row;
        boardPosition.column = column;

        if (!gameBoard.validIndex(boardPosition))
        {
            cout << "That is an invalid choice. Please try again.\n";
            continue;
        }

        if (gameBoard.choiceTaken(boardPosition))
        {
            cout << "That square is already taken. Please try again.\n";
            continue;
        }

        gameBoard.setChoice(boardPosition);

        if (gameBoard.choiceWins())
        {
            cout << "Player " << player << " wins!\n";
            gameFinished = true;
        }
        else if (gameBoard.boardIsFull())
        {
            cout << "Board is full. The game is a tie!\n";
            gameFinished = true;
        }

        playerXInSession = !playerXInSession;
    }
    while (!gameFinished);
}
编译命令如下
g++ -o ch24_p01 ch24_p01.cpp TicTacToe.cpp

显示结果如下
Please specify the number of spaces to be used for the rows/columns of the square board:
(Default is 4 and max is 50)
6
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | | | |
 _____________
2| | | | | | |
 _____________
3| | | | | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
3
Column:
2
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | | | |
 _____________
2| | | | | | |
 _____________
3| |X| | | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
2
Column:
3
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | | | |
 _____________
2| | |O| | | |
 _____________
3| |X| | | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
3
Column:
3
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | | | |
 _____________
2| | |O| | | |
 _____________
3| |X|X| | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
3
Column:
4
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | | | |
 _____________
2| | |O| | | |
 _____________
3| |X|X|O| | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
4
Column:
3
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | | | |
 _____________
2| | |O| | | |
 _____________
3| |X|X|O| | |
 _____________
4| | |X| | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
4
Column:
5
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | | | |
 _____________
2| | |O| | | |
 _____________
3| |X|X|O| | |
 _____________
4| | |X| |O| |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
5
Column:
3
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | | | |
 _____________
2| | |O| | | |
 _____________
3| |X|X|O| | |
 _____________
4| | |X| |O| |
 _____________
5| | |X| | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
5
Column:
6
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | | | |
 _____________
2| | |O| | | |
 _____________
3| |X|X|O| | |
 _____________
4| | |X| |O| |
 _____________
5| | |X| | |O|
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
6
Column:
3
Player X wins!

第25章 类的生命周期
创建一个类的时候，你会想让它尽可能地易于使用。有三个基本的操作可能所有的类都需要支持：
1.初始化自己； 2.清理占用的内存或者别的资源； 3.复制自己。
这三点对于创建一个好的数据类型来说都很重要。拿字符串来做个例子：
字符串需要能够初始化自身，哪怕初始化成一个空字符串。
这个操作不应该依赖某些外部代码来完成――只要你声明了一个字符串， 它立刻就可以为你所用。
而且，在你用完字符串之后，它需要自我清理，因为字符串是分配过内存的。
使用字符串时，你并不需要调用一个方法来做清理的工作；清理是自动搞定的。
最后，允许变量之间相互复制也是需要的，就像一个整型数据可以从一个变量复制到另一个变量一样。
综上所述，这三个功能应当成为每个类的组成部分，这样的话这些类就很容易被正确地使用并且不易被误用。
我们一个个来分析这三个特性，从初始化对象开始，看看C++是如何让初始化很简单地实现的。
25.1 对象构造
可能之前你就注意到在ChessBoard的接口（类的公共部分）中并没有初始化棋盘的代码。来修正一下这个问题。
当你声明一个类的变量时，需要有一些初始化这个变量的方式：
ChessBoard board;
在C++中，在一个对象被声明时运行的代码称为构造函数。
构造函数中应该会设置好相应的对象，这样在使用这个对象的时候就不需要再做进一步的初始化了。
构造函数也可以接收参数，在声明特定大小的vector时你已经见识过了。
vector <int> v( 10 );
这行代码带着参数10去调用vector的构造函数；vector的构造函数初始化一个新的vector这样它就立即可以存放10个整数。
要创建一个构造函数，你只需简单地声明一个和类有着同样名字的方法，不接受参数也没有返回值（不是void，不需要为返回值指定一个类型）。
enum ChessPiece { EMPTY_SQUARE, WHITE_PAWN /* and others */ };
enum PlayerColor { PC_WHITE, PC_BLACK };

class ChessBoard
{
public:
    ChessBoard ();
    PlayerColor getMove ();
    ChessPiece getPiece (int x, int y);
    void makeMove (int from_x, int from_y, int to_x, int to_y);

private:
    ChessPiece _board[8][8];
    PlayerColor _whose_move;
};

ChessBoard::ChessBoard ()
{
    _whose_move = PC_WHITE;
    for ( int i = 0; i < 8; i++ )
    {
        for (int j = 0; j < 8; j++ )
        {
            _board[i][j] = EMPTY_SQUARE;
        }
    }
}
示例代码58：constructor.cpp
注意，构造函数是属于类当中公共区域的一部分。如果ChessBoard构造函数不是公共的，那么就无法创建出该对象的实例。
何以如此呢？ 每次创建对象的时候都会调用到构造函数，但是如果它是私有的，那就意味着类之外没有人能够调用到这个构造函数！
由于所有的对象都必须调用构造函数来初始化，如果构造函数是私有的你根本就无法声明对象了。
调用构造函数的地方正是创建对象的那行代码：
ChessBoard board;   // 调用 ChessBoard 的构造函数
或者在分配内存的地方：
ChessBoard *board = new board;   // 调用ChessBoard的构造函数
如果你声明了多个对象：
ChessBoard a;
ChessBoard b;
构造函数的运行顺序和对象声明顺序一致（先a然后b）。
就像普通函数一样，构造函数可以接收任意数量的参数，并且你也可以有多个参数类型不同的重载构造函数，
如果想要对象可以用不同的方式来初始化的话。举个例子，你可以再写个ChessBoard的构造函数，接收棋盘的大小作为参数：
Class ChessBoard
{
public:
    ChessBoard ();
    ChessBoard (int board_size);
    PlayerColor getMove ();
    ChessPiece getPiece (int x, int y);
    void makeMove (int from_x, int from_y, int to_x, int to_y);

private:
    ChessPiece _board[8][8];
    PlayerColor _whose_move;
};
构造函数的定义和类当中其他任何方法一样：
ChessBoard::ChessBoard (int size)
{
    // ...代码
}
像下面这样通过构造函数来传递参数：
当使用new关键字时，参数的传递就像你直接调用构造函数一样：
ChessBoard *p_board = new ChessBoard( 8 );
ChessBoard board( 8 );   // 8 是传递给ChessBoard构造函数的一个参数
语法上有个小的注意点――尽管你是使用括号来将参数传递给构造函数的，
但是在声明一个构造函数不接受参数的对象时可不能还使用括号。
错误代码
ChessBoard board();
上面代码正确的写法是：
ChessBoard board;
然而，在使用 new 来创建对象时使用括号是没有问题的：
ChessBoard *board = new board();
上面的这种情况是由于C++解析时的一个不好的怪招导致的（个中细节太过晦涩难懂）。
在声明一个没有传参构造函数的对象时要避免使用括号。
25.1.1 没有新建构造函数的结果
如果你没有写构造函数，那么C++就会很友好地创造一个。
自动创造的这个构造函数不接收参数，但是它会调用你类中所有字段的默认构造函数来初始化它们
（虽然它不会初始化原始类型如整型或者字符串――所以要留心这一点）。
我通常会建议写自己的构造函数，以确保所有的东西都按你的意愿来初始化。
一旦为类声明了一个构造函数，C++就再也不会为你自动生成默认的构造函数了。
编译器就会假定你知道自己在做什么，并且假定你是想要为这个类创建所有的构造函数。
尤其是，如果创建了一个接收参数的构造函数，代码就再也不会有一个默认的构造函数，除非你特地声明一个。
如果代码先前是使用自动生成的默认构造函数，然后你添加了一个自己的、接收一个或者更多参数的非默认构造函数，
依赖之前自动生成的默认构造函数的代码将再也无法编译。你不得不手动地提供一个默认构造函数，因为编译器不再为你创造了。
25.1.2 初始化类的成员
类的每一个成员都需要在构造函数中来完成初始化。假设有个字符串变量_whose_move作为ChessBoard类的一个成员：
class ChessBoard
{
public:

    ChessBoard ();

    string getMove ();
    ChessPiece getPiece (int x, int y);
    void makeMove (int from_x, int from_y, int to_x, int to_y);

private:
    PlayerColor _board[8][8];
    string _whose_move;
};
可以简单地给_whose_move变量赋值：
ChessBoard::ChessBoard ()
{
    _whose_move = "white";
    // ...其他初始化代码
}
尽管真正在这里执行的代码可能有点出乎我们的意料。
首先， 在ChessBoard构造函数刚开始的时候，_whose_move的构造函数将会被调用。
这样是有好处的因为它意味着在构造函数中你可以安全地使用类当中任何的字段，
如果那些成员的构造函数不被调用，它们就无法使用――构造函数的全部意义就是让对象可以使用！
可以给类成员的构造函数传参，如果你打算这么做，而不是直接使用默认构造函数的话。
尽管这个操作的语法有点不同寻常，但是它是有效的：
//   跟在冒号后面的是变量的列表，带着传递给构造函数的参数 
ChessBoard::ChessBoard () : _whose_move( "white" )
{
    // 代码运行到这里的时候，_whose_move的构造函数已经被调用了，并且它已经有了值“white”
    ...
}
上面语法的术语叫做初始化列表。我们后面会有几次遇到它们，并且我通常都会用这个语法来初始化类的成员。
初始化列表的成员之间使用逗号分隔开。举个例子，如果给ChessBoard增加一个新的成员_move_count来计算已经走过的步数，
可以像这样在初始化列表中对它进行初始化：
class ChessBoard
{
public:

    ChessBoard ();

    string getMove ();
    ChessPiece getPiece (int x, int y);
    void makeMove (int from_x, int from_y, int to_x, int to_y);

private:
    PlayerColor _board[8][8];
    string _whose_move;
    int _move_count;
};
ChessBoard::ChessBoard () : _whose_move( "white" ), _move_count( 0 )
{
    ...
}
25.1.3 用初始化列表初始化常量字段
如果定义了类中的一个字段为常量，那么这个字段就必须在初始化列表中完成初始化工作：
class ConstHolder
{
public:
    ConstHolder (int val);

private:
    const int _val;
};

ConstHolder::ConstHolder (int val) : _val( val )
{
    //   ... 其他初始化代码
}
你无法通过直接赋值来初始化一个常量字段因为那些常量字段都已经被固化了。
初始化列表是类尚未完全形成的唯一的地方，所以在这里设置一些不可改变的对象是安全的。
同样道理，如果你有个字段是引用类型的，那么它同样必须在初始化列表中完成初始化的操作。
在讲到继承的时候我们会学到初始化列表的又一个用途。
25.2 解构对象
正如同需要构造函数来初始化一个对象一样，有时你也需要有代码来清理那些不再需要使用的对象。
举个例子，如果构造函数申请分配了内存（或者其他的任何资源），
然后当你的对象不再使用的时候，这些资源最终需要归还给操作系统。
进行这种清除的操作称为摧毁对象，它是在一个叫作析构方法的特殊的方法内部发生的。
在一个对象不再需要的时候会调用析构方法――例如在对指向一个对象的指针调用delete时。
我们来看一个例子，假设有个类用来表示一个链表。要实现这个类， 可能需要有一个字段来存储列表当前的头节点：
struct LinkedListNode
{
    int val;
    LinkedListNode *p_next;
};

class LinkedList
{
public:
    LinkedList ();
    void insert (int val);

private:
    LinkedListNode *_p_head;
};
如之前所见到的，链表中的头节点就如同别的元素一样，指向使用 new LinkedListNode 分配出的内存。
这表示在某个时候，如果不再需要使用这个LinkedList对象了，要有一个清理它们的方式。这就是析构函数要干的活。
我们来看看为这个数据类型加一个析构函数会是什么样子。 
和构造函数一样，析构方法也有个特殊的名称：就是在类的名字之前加一个波浪号（~），
如同构造函数，析构函数也没有返回值。和构造函数所不同的是，析构函数永远不会接收任何参数。
class LinkedList
{
public:
    LinkedList ();
    ~LinkedList ();

    void insert (int val);

private:
    LinkedListNode *_p_head;
};

LinkedList::~LinkedList ()
{
    LinkedListNode *p_itr = _p_head;
    while ( p_itr != nullptr )
    {
        LinkedListNode *p_tmp = p_itr->p_next;
        delete p_itr;
        p_itr = p_tmp;
    }
}
析构函数的代码和之前见过的删除链表中所有条目的代码相似，唯一不同的就是利用了一个类中的一个特殊方法来专门做清理工作。但是等等， 每个节点都去清除它自己的数据不是更有意义吗？这难道不是析构函数存在的所有意义吗？
如果我们这么做会怎样呢？
class LinkedListNode
{
public:
    ~LinkedListNode ();
    int val;
    LinkedListNode *p_next;
};

LinkedListNode::~LinkedListNode ()
{
    if (p_next != nullptr)
    {
        delete p_next;
    }
}
不管你信不信，这段代码触发了一系列的函数递归调用。
这里发生的事是，使用delete就调用了p_next所指向的对象的析构函数（如果p_next为空的话就什么都不做）。
那个被调用的析构函数紧接着又去调用delete也就是调用下一个析构函数。这一系列的析构函数调用如何结束呢？
最终p_next将会为空，在那个时候调用delete就什么也不做了。
一旦我们的LinkedListNode有了这个析构函数，LinkedList自己的析构函数只需要简单地加上这句代码：
LinkedList::~LinkedList ()
{
    if (_p_head != nullptr)
    {
        delete _p_head;
    }
}
这里调用delete开始了递归调用，直到链表的最后。
现在你可能在思考――这么做是个很好的模式，但是为什么需要一个析构函数呢？
难道我们就不能写个自己的方法然后按喜好来命名它吗？
当然可以，但是使用析构函数有个好处：在对象不再需要的时候它会被自动调用。
那么说一个对象“不再需要了”到底是什么意思呢？它意味着下面三种情况中的一种：
1.当你删除了一个指向对象的指针； 
2.当这个对象超出了作用域；
 3.当拥有这个对象的类的析构函数被调用了的时候。
25.2.1 delete时的解构
调用delete很明显地反应了什么时候会调用析构函数，就如同你已经见过的：
LinkedList *p_list = new LinkedList;
delete p_list;   // p_list 的~LinkedList (析构函数)被调用了
25.2.2 超出作用域时的解构
第二种情况，一个对象超出了作用域，这是个隐含的操作。每当对象声明在大括号中时，在括号结束以后它们就超出作用域了。
if ( 1 )
{
    LinkedList list;
    ...
}
// 链表的析构函数在这里调用
有种稍微复杂一点的例子就是当一个对象是在函数内部声明的时候。 
如果函数有返回语句，析构函数就会作为离开函数所进行的操作的一部分来调用。
我想，对于在代码块中声明的对象的析构函数，它是在程序离开该代码块时“在走到右括号的地方”执行的。
代码块的结束是在最后一个语句执行完毕的时候，或者由一个return语句或者break语句来实现退出代码块：
void foo ()
{
    LinkedList list;
    //   ... 一些代码
    if ( /* 某个条件 */ )
    {
        return;
    }
}
// 链表的析构函数在这里调用
这种情况下，即使return是在if语句当中的，我也认为析构函数在函数走到最后一个大括号时才运行。
但是，对你而言要掌握的最重要的是析构函数只在对象超出作用域时才执行――当它一被引用就出现编译错误的时候。
如果在某段代码块的末尾有多个对象需要执行析构函数的话，那些析构函数的运行顺序是正好与对象们的构建顺序相反的。
举个例子，在下面的代码中：
{
    LinkedList a;
    LinkedList b;
}
b的析构函数是在a的析构函数之前执行的。
25.2.3 由其他析构函数导致的解构
最后，如果有个对象包含在另一个类当中，那个对象的析构函数是在类的析构函数调用之后被调用的。
举个例子，如果你有个很简单的类：
class NameAndEmail
{
    /* 正常情况下这里会有一些方法 */
private:
    string _name;
    string _email;
};
在这里，_name和_email字段的析构函数会在NameAndEmail的析构函数运行结束时被调用。
这很方便――你无需做任何特殊的操作来清理类中的任何对象！
你真的只需要调用一下delete来清理那些指针（或者别的资源如文件引用或者网络连接）。
顺便说一下，即使没有给类加个析构函数，这种情况下编译器同样会确保去执行你类中所有对象的析构函数。
使用构造函数来初始化一个类并且使用析构函数来清理属于这个类的内存或者别的资源，这个思想有个名称：
资源分配既初始化或者叫RAII。基本的意思就是在C++中，你应该通过创建类来处理资源，
并且在你创建类的时候，构造函数应当负责所有初始化的工作同时析构函数需要处理所有的清理工作。
不应该要求使用这个类的人去做什么特定的处理。
通常，这会导致像上面NameAndEmail那样的类：两个字符串在完成使命以后会自己进行清理，
这样NameAndEmail自身就不需要来实现析构函数了。
25.3 复制类
我们关于类的重要概念之旅的第三站就是处理复制类的实例。
在 C++中，创建可供复制的新类是经常要做的事――举个例子，你可能会这样写：
LinkedList list_one;
LinkedList list_two; 
 
list_two = list_one;
LinkedList list_three = list_two;
在C++中，有两个函数可以定义用来确保这些复制操作能正常运行。
一个函数是赋值操作符，另外一个是复制构造函数。我们先看一下赋值操作符，然后再讨论复制构造函数。
你可能会疑惑：为什么需要这些函数，不是直接写就可以了吗？
答案是可以直接写，有时候就管用，因为C++会提供默认版本的复制构造函数和赋值操作符。
然而，有些情况下你不能依赖默认的版本――有时编译器也不是那么聪明，它可能不知道你的意图。
例如，默认版本的复制构造函数和赋值操作符会执行叫做浅层指针复制的操作。
浅层指针复制就是将第二个指针赋值让其指向第一个指针所指向的内存地址。
这种操作称为浅层是因为那些被指向的内存并没有被复制，复制的仅仅是指针而已。 
有时浅层复制可能是没问题的，但是有些情况下它就会导致问题。
举个例子，用之前的LinkedList类写下面的这些代码：
LinkedList list_one;
LinkedList list_two; 
 
list_one = list_two;
这里的问题在于默认的赋值操作符会生成下面这样的代码：
list_one._p_head = list_two._p_head;
你可以像下面这样用图来描述这个过程：
现在两个对象有着相同的指针值，而且每个对象的析构函数都会试图释放同一个指针所指向的内存。
当list_two的析构函数运行的时候，它会删除list_two._p_head。 
（list_two的析构函数会先运行因为析构函数的运行顺序和构造函数正好相反。）
然后list_one 的析构函数会接着运行，去删除list_one._p_head。问题出现了，list_two._p_head已经被删除了，
而如果要删除同一个指针两次， 你的程序就要崩溃了！
很明显一旦其中的一个析构函数运行过以后，另外一个链表就不可用了！
赋值操作符正好是处理这种问题的一个方式。所以，让我们来看看它到底是什么样子的。
25.3.1 赋值操作符
在将一个对象赋值给一个已经存在的对象时赋值操作符会被调用，比如这么写的时候：
list_two = list_one;
要实现赋值操作符，需要少量的可以用来定义操作符的新语法。所幸，这还不是太麻烦：
LinkedList& operator= (LinkedList& lhs, const LinkedList& rhs);
这跟普通的函数声明看上去很像――它接收两个参数：一个 是LinkedList的非常量引用，另一个是LinkedList常量引用，
并且返回一个LinkedList的引用。唯一怪异的地方就是函数的名字：operator=。 
这里的意思不是定义一个新函数，我们是定义了等号在LinkedList类中的用法。
第一个参数是在等号左边的，也就是被赋值的，所以它不是常量。第二个参数是等号右边的，它是要赋给左边的值
（并且它应当是常量，因为你没有理由要去修改它，尽管并没有严格要求它是常量）：
lhs = rhs;
之所以返回一个LinkedList引用，是因为这样你可以将赋值语句链接 起来：
linked_list = lhs = rhs;
现在，大多数时候，一个类会特地将operator=函数作为它的成员函数而不是一个单独存在的函数，
这样operator=就可以操作类的私有字段了（相对于我上面那样只是声明一个游离于类之外的函数）。来看看具体的代码：
class LinkedList
{
public:
    LinkedList ();
    ~LinkedList ();
    LinkedList &operator= (const LinkedList &other);

    void insert (int val);
private:
    LinkedListNode *_p_head;
};
注意少了一个参数：这是因为类的所有成员函数都隐式地将该类作为一个参数。
在这里，operator=方法是在该类自身作为赋值操作左边元素的时候使用的。换句话说，在代码里这样表示：
lhs = rhs;
operator=函数是在变量 lhs 身上调用的。就如同这样写：
lhs.operator= ( rhs );
在函数执行完毕以后，lhs就会和rhs有相同的值。好，那么我们就来谈谈如何为LinkedList类写个operator=函数。
LinkedList &LinkedList::operator= (const LinkedList &other)
{
    // 这里会是什么呢
}
通过上面的讨论，我们已经知道仅仅复制指针地址并不完全正确。
我们真正要做的是复制整个结构。逻辑是这样的：首先释放已有的列表（因为它已经不需要了），
然后复制每个列表节点，这样就有了两个相互独立的列表。最后，由于需要返回一个值，我们会返回被复制的这个类的一个副本。
最后一步需要一个新的语法――需要有一些指向当前对象的方式。
在 C++中要实现这个功能，我们可以使用一个特殊的变量，叫做this指针。
this指针是指向当前类的实例的一个指针。例如，假使写list_one.insertElement(2);
那么在insertElement内部，你就可以使用关键字this，它指向list_one。我们还将使用this指针为方法增加一点安全性。
LinkedList &LinkedList::operator= (const LinkedList &other)
{
    if ( this == & other )
    {
        return *this;
    }
    if ( _p_head != nullptr )
    {
        delete _p_head;
        _p_head = nullptr;
    }

    LinkedListNode *p_itr = other._p_head;
    while ( p_itr != nullptr )
    {
        insert( p_itr->val );
        p_itr = p_itr->p_next;
    }
    return *this;
}
这个函数有几个注意点：首先，注意我们做了自身赋值的检查。像下面这样写：
a = a;
应该是完全没问题的，并且不改变任何东西。
接下来，我们需要释放原来的列表所占用的内存，因为已经不用它了：删除_p_head就可以删除整个列表，就像在析构函数里一样。
最后，我们要使用右边的新数值来重新生成列表，可以通过循环遍历整个旧的列表然后把它的每一个值都插入到自己的列表中。
现在看看，我们有一个可以复制的类了！
所幸，不是所有的类都需要这样复杂的复制操作。如果类的成员中没有一个是指针，你可能根本就不需要一个赋值操作符！
没错――这就 是C++，仁慈而细心，它会默认提供一个赋值操作符，该赋值操作符会通过运行每个元素自身的赋值操作符
（如果这个元素是一个类的对象）或者复制它的值（如果这个元素是指针或者别的数值）。
所以如果类中没有指针，在大多数情况下你都可以依赖默认的赋值操作符。
有个好的法则，那就是如果你需要写自己的析构函数，那么恐怕也要自己写赋值操作符。
这个法则的道理是如果你有自己的析构函数，那么它可能是用来清理释放内存的，
而如果有释放内存的操作，就需要确保类的副本都有它们自己的内存。
25.3.2 复制构造函数
最后还有一种要考虑的情况，假使你想要依照另一个对象来构造一个相同的对象会怎样：
LinkedList list_one;
LinkedList list_two( list_one );
这只是构造函数使用的一个特殊情况――构造函数接收的参数是和正在构造的对象属于同一类型的对象。
这样的构造函数称为复制构造函数。复制构造函数应当能够使新的对象是原有对象的一个直接复制。
这里就是list_two应当初始化成和list_one一模一样。
这有点像赋值操作符，除了这里是直接从一个未初始化的类开始的操作而不是已经有一个类存在了。
这是个好事因为它意味着无需浪费任何CPU资源来构建类，你只要重写一下相应的值就行了。
复制构造函数通常实现起来很简单并且看上去和赋值操作符很像。对于LinkedList它是这样的：
class LinkedList
{
public:
    LinkedList ();
    ~LinkedList ();
    LinkedList &operator= (const LinkedList &other);
    LinkedList (const LinkedList &other);

    void insert (int val);

private:
    LinkedListNode *_p_head;
};

LinkedList::LinkedList (const LinkedList &other) : _p_head( nullptr )
{
    LinkedListNode *p_itr = other._p_head;
    while ( p_itr != nullptr )
    {
        insert( p_itr->val );
        p_itr = p_itr->p_next;
    }
}
如果你自己不写的话，编译器会提供一个默认的复制构造函数。这个 默认的复制构造函数所做的操作和默认赋值操作符一样：
它会执行类的每个对象各自的复制构造函数，并且它对像整型和指针这样的值会进行常规的复制。
大多数情况下，如果需要自己实现一个赋值操作符，你恐怕也要顺带实现一个复制构造函数。
关于复制构造函数有件事你需要知道，它有时会惊呆初学的小伙伴 ――当然在第一次遇到的时候它也惊到我了。
如果写了下面的代码：
LinkedList list_one;
LinkedList list_two = list_one;
你觉得会发生什么――它会调用赋值操作符吗？
不，结果是编译器足够智能可以识别出list_two正在基于list_one进行初始化，
实际上它会给你调用复制构造函数，免去一个没有必要的对象初始化。这是不是很好呢？
25.3.3 所有编译器生成的方法
现在你已经见过编译器自动生成的每一个方法了：
1.默认构造函数； 2.默认析构函数； 3.赋值操作符； 4.复制构造函数。
对于创建的每一个类，你都应当考虑一下是否能接收编译器默认为你实现的这些方法。
很多时候可以用它们，但是如果你有指针需要操作，就经常要声明自己的析构函数，赋值操作符以及复制构造函数。
 （通常情况下，如果需要它们中的某一个，那么你就需要它们所有的。）
25.3.4 彻底地阻止复制
有些时候根本不需要复制对象的功能。“不许这个对象被复制”，这么 说不也很好吗？
这么做可以避免实现复制构造函数或者赋值操作符， 并且也不要承担编译器会生成这些方法的危险版本的风险。
也有些情况下复制对象就是错误的。举个例子，假设有个游戏其中一个类代表当前玩家的飞船，
你实在不想这个飞船有另外的副本――只想要个唯一的飞船，且其中包含了当前玩家的所有信息。
你可以通过声明复制构造函数和赋值操作符，却不去实现它们来做到阻止复制。
一旦你声明了一个方法，编译器就不再自动生成它了。
如果试图去使用它，将会在链接时得到一个错误因为你使用了一个未定义的函数。
这可能有点让人费解，因为链接器不会告诉你问题到底出在哪一行代码上。
你也可以通过把这些方法设为私有来获得更好的报错信息；
这样，大部分情况下错误就会发生在编译的阶段，可以给出更容易理解的错误信息。来看看具体怎么做：
class Player
{
public:
    Player ();
    ~Player ();

private:
    operator= (const Player &other);
    Player (const Player &other);

    PlayerInformation *_p_player_info;
};
// 没有赋值操作符或者复制构造函数相关的实现
总结一下，应当总是选择下面这些操作中的一个：
1.同时使用默认的复制构造函数和赋值操作符；
 2.同时创建自己的复制构造函数和赋值操作符；
 3.将复制构造函数和赋值操作符都设为私有，并且不去实现它们。
如果你什么都不做，由于编译器的默认生成你相当于选择了第一个选项。
通常最简单的是选择第三种方案，然后如果发现有需要时再去实现赋值操作符和复制构造函数。
问答题
1.你在什么时候需要给类写一个构造函数？
A.总是需要写，没有构造函数你就不能使用这个类
B. 在你需要以非默认值来初始化类的时候
C.永远不需要，编译器总是会为你提供一个
D.只有你同时需要一个析构函数的时候

B
2.析构函数和赋值操作符之间的关系是什么？
A.它们没什么关系
B.类的析构函数会在运行赋值操作符之前被调用
C.赋值操作符需要指出哪些内存应当被析构函数删除掉
D.赋值操作符必须确保运行被复制类的析构函数和运行新类的析构函数都是安全的

D
3.在什么时候需要使用一个初始化列表？
A.在你想要让构造函数尽可能地高效以及想要避免构造空的对象时
B.在你初始化一个常量时
C.在你想要运行类的某个字段的非默认构造函数的时候
D.上面所有的都成立

D
4.下面代码的第二行执行时哪个函数会运行？
string str1;
string str2 = str1;
A.str2的构造函数和str1的赋值操作符
B.str2的构造函数和str2的赋值操作符
C.str2的复制构造函数
D.str2的赋值操作符

C
5.下面代码中哪些函数被调用了，顺序是怎样的？
{
    string str1;
    string str2;
}
A.str1的构造函数，str2的构造函数
B.str1的析构函数，str2的构造函数
C.str1的构造函数，str2的构造函数，str1的析构函数，str2的析构函数
D.str1的构造函数，str2的构造函数，str2的析构函数，str1的析构函数

D
6.如果已知一个类有个非默认的构造函数，下列关于它的赋值操作符哪个应该是正确的？
A.它应当有个默认的赋值操作符
B.它应当有个非默认的赋值操作符
C.它应当有个声明了但是没有实现的赋值操作符
D. B 或 C 正确

D
实践题
1.实现一个 vector的替代品，让其只能操作整型，叫vectorOfInt。类应当包含下列这些接口：
一个分配32个元素vector的无参数构造函数
一个接收初始化大小作为参数的构造函数
一个get方法，接收一个索引并返回该索引对应的值
一个set方法，接收一个索引和一个值，将索引对应的值设为传入的值
一个pushback方法，向数组的末尾添加一个元素，如有必要重新给数组定义大小
一个pushfront方法，向数组的开头添加一个元素
一个复制构造函数以及一个赋值操作符
类应该不存在内存泄漏；任何分配的内存都应当被释放。试着仔细想想类可能被怎样误用，以及你该如何处理这些误用。
如果用户给了个负的初始化大小你要怎么做？如果用户访问了负的索引值怎么办？

VectorOfInt.h
#pragma once
#ifndef VECTOROFINT_H_
#define VECTOROFINT_H_

class VectorOfInt
{
public:
	VectorOfInt();
	VectorOfInt(int initialSize);
	VectorOfInt(const VectorOfInt& other);
	~VectorOfInt();

	int* GetInt(int index) const;
	void SetInt(int index, int value);

	void PushBack(int value);
	void PushFront(int value);
	void Clear();
	int size() const;

	VectorOfInt& operator=(const VectorOfInt& other);
private:
	int* _integers;
	int _integersLengthUsed;
	int _integersLength;

	void CopyValues(const VectorOfInt& other);
	static int* growArray(int* p_values, int* size);
};

#endif

VectorOfInt.cpp
#include "VectorOfInt.h"

VectorOfInt::VectorOfInt()
{
    _integersLength = 32;
    _integersLengthUsed = 0;
    _integers = new int[_integersLength];
}

VectorOfInt::VectorOfInt(int initialSize)
{
    if (initialSize < 32)
    {
        initialSize = 32;
    }
    _integersLength = initialSize;
    _integersLengthUsed = 0;
    _integers = new int[_integersLength];
}

VectorOfInt::VectorOfInt(const VectorOfInt &other)
{
    CopyValues(other);
}

VectorOfInt::~VectorOfInt()
{
    if ( _integers != nullptr )
    {
        delete[] _integers;
    }
}

int *VectorOfInt::GetInt(int index) const
{
    if ( (index < 0) || (index >= _integersLengthUsed) )
    {
        return nullptr;
    }

    return &_integers[index];
}

void VectorOfInt::SetInt(int index, int value)
{
    if ( (index < 0) || (index >= _integersLengthUsed) )
    {
        return;
    }

    _integers[index] = value;
}

void VectorOfInt::PushBack(int value)
{
    if (_integersLengthUsed >= _integersLength)
    {
        _integers = growArray(_integers, &_integersLength);
    }
    _integers[_integersLengthUsed] = value;
    _integersLengthUsed++;
}

void VectorOfInt::PushFront(int value)
{
    if (_integersLengthUsed >= _integersLength)
    {
        _integers = growArray(_integers, &_integersLength);
    }

    for (int i = _integersLengthUsed; i > 0; i--)
    {
        _integers[i] = _integers[i - 1];
    }
    _integers[0] = value;
    _integersLengthUsed++;
}

void VectorOfInt::Clear()
{
    _integersLengthUsed = 0;
}
int VectorOfInt::size() const
{
    return _integersLengthUsed;
}

VectorOfInt &VectorOfInt::operator=(const VectorOfInt &other)
{
    if( this == &other)
    {
        return *this;
    }
    if (_integers != nullptr)
    {
        delete[] _integers;
        _integers = nullptr;
    }

    CopyValues(other);

    return *this;
}

void VectorOfInt::CopyValues(const VectorOfInt &other)
{
    _integersLength = other._integersLength;
    _integers = new int[_integersLength];

    _integersLengthUsed = other._integersLengthUsed;
    for (int i = 0; i < _integersLengthUsed; i++)
    {
        int *value = other.GetInt(i);
        if (value != nullptr)
        {
            _integers[i] = *value;
        }
    }
}

int *VectorOfInt::growArray(int *p_values, int *size)
{
    *size *= 2;

    int *p_newvalues = new int[*size];
    for (int i = 0; i < *size; i++)
    {
        p_newvalues[i] = p_values[i];
    }

    delete[] p_values;

    return p_newvalues;
}

ch25_p01.cpp
#include <iostream>
#include "VectorOfInt.h"

using namespace std;

void print(VectorOfInt &vector);

int main()
{
    VectorOfInt basicVector;
    for (int i = 0; i < 32; i++)
    {
        basicVector.PushBack(i + 1);
    }
    cout << "Basic Vector\n";
    print(basicVector);

    int vectorSize = 10;
    VectorOfInt sizedVector(vectorSize);
    for (int i = 0; i < vectorSize; i++)
    {
        sizedVector.PushBack(i * i);
    }
    cout << "Vector Sized to " << vectorSize << '\n';
    print(sizedVector);

    VectorOfInt copiedVector(sizedVector);
    cout << "Copied Vector Upon Initialization from Sized Vector\n";
    print(copiedVector);

    VectorOfInt copiedVectorOperator;
    copiedVectorOperator = basicVector;
    cout << "Copied Vector Operator from Basic Vector\n";
    print(copiedVectorOperator);

    int value1 = 50;
    cout << "Adding " << value1 << " to the end of Sized Vector\n";
    sizedVector.PushBack(value1);

    int value2 = -12;
    cout << "Adding " << value2 << " to the end of Sized Vector\n";
    sizedVector.PushBack(value2);
    print(sizedVector);

    int value3 = -666;
    cout << "Adding " << value3 << " to the beginning of Copied Vector\n";
    copiedVector.PushFront(value3);

    int value4 = 999;
    cout << "Adding " << value4 << " to the beginning of Copied Vector\n";
    copiedVector.PushFront(value4);
    print(copiedVector);

    cout << "Clearing Basic Vector\n";
    basicVector.Clear();
    print(basicVector);
}

void print(VectorOfInt &vector)
{
    if (vector.size() <= 0)
    {
        cout << "Vector is empty.\n";
        return;
    }
    cout << "Vector Values...\n";
    int *p_value;
    int index = 0;
    while ( ( p_value = vector.GetInt(index) ) != nullptr )
    {
        cout << *p_value << '\n';
        index++;
    }
    cout << '\n';
}

编译命令如下
g++ -o ch25_p01 ch25_p01.cpp VectorOfInt.cpp

显示结果如下
Basic Vector
Vector Values...
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32

Vector Sized to 10
Vector Values...
0
1
4
9
16
25
36
49
64
81

Copied Vector Upon Initialization from Sized Vector
Vector Values...
0
1
4
9
16
25
36
49
64
81

Copied Vector Operator from Basic Vector
Vector Values...
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32

Adding 50 to the end of Sized Vector
Adding -12 to the end of Sized Vector
Vector Values...
0
1
4
9
16
25
36
49
64
81
50
-12

Adding -666 to the beginning of Copied Vector
Adding 999 to the beginning of Copied Vector
Vector Values...
999
-666
0
1
4
9
16
25
36
49
64
81

Clearing Basic Vector
Vector is empty.

第26章 继承和多态
到目前为止我们一直在讨论如何通过能提供干净利落的公共接口和具有对像新建、复制、清除功能的类，
来创造一个完整的，有用的数据类型。现在让我们来更进一步地探讨一下接口的思想。
假设你有一辆汽车，它有点破旧缓慢。遗憾的是，几乎每家汽车厂商都有各自不同的控制机制。
每次你要使用汽车，你都得重新去学习怎么控制它。每次想要租或者买一辆新车，你都得重新学习如何驾驶它。
所幸的是，汽车都会追随一定的标准。任何时候你上了一辆车，它都是同样的接口――方向盘，油门。
唯一的不同就是有些车是自动挡， 有些车是手动档。一辆车可以有两个接口：自动或者手动。
只要知道怎么使用自动挡，你就可以驾驶任何自动挡的车。在你开车的时候，引擎的细节并不重要。
重要的是它要提供和其他汽车相同的打方向、加速以及刹车的方法。
这些和C++有什么关系呢？在C++当中，事实上写代码的时候希望有特定的，定义良好的接口来直接使用是可能的。
（用上面的来作类比，你就是代码，汽车的驾驶机制就是接口）,接口（汽车自身）的实现并不重要，
接口的任何特定的实现（任何你选择的汽车），都可以为外部代码（被你，司机）所用，
因为它实现了一个代码能够理解的接口。你，作为司机，可能相比于一些车来说更喜欢另外一些车，但是你都可以驾驶它们。
好了，在什么时候会写具有和上面相同性质的代码呢？
假设有一个游戏――你可能有很多不同的对象需要绘制到屏幕上――子弹、飞船、 敌人。
在游戏的主循环中，每一帧你都要把它们中的每个绘制到各自新的位置上。
清除屏幕
遍历可以绘制的对象列表
对于每个可绘制对象，绘制它
可绘制对象列表理想状态下可以存储各种你可以绘制到屏幕上的对象。
它们都需要实现一些通用接口，这些接口可以允许把它们绘制到屏幕上。
但是你还想让子弹、飞船和敌人各自是一个不同的类――它们有各自不同的内部数据
（玩家的飞船需要有生命值，敌人的飞船需要有AI来移动它们，而子弹则需要存储它所能造成的伤害）。
对于绘制对象的循环来说，这些具体的东西都是无关紧要的。最重要的是这些不同的类都要支持一个允许绘制的接口。
怎样来做到这些呢？首先，来定义一下怎么才叫做可以被绘制：
class Drawable
{
public:
    void draw ();
};
这个简单的Drawable类，只定义了单独的一个方法――draw。这个方法绘制当前的对象。
如果写个vector<Drawable*>，然后把所有实现了draw方法的东西都存放在其中，这种做法是不是很好呢？
如果可以这么做，我们就可以写代码通过遍历vector中所有的东西，调用draw方法来将它们都绘制到屏幕上。
如果你在纳闷我何以把指针放入vector中，这里的原因就是我们需要使用指针来获取我们将要看到的操作。
任何使用vector中存储的对象的人都只能使用那些构成Drawable接口的方法，但是不管怎么说，这就是这里所要做的一切。
你猜怎么着？C++事实上就支持这个！让我们来看看如何实现它。 
26.1 C++中的继承
首先，我们介绍一个新的术语：继承。继承的意思是一个类从另一个类那里获得一些特性。
在上面的例子里，被继承的特性将会是Drawable类的接口，具体地说就是draw方法。
一个从别的类那里继承特性的类称为子类。被继承的那个类是父类。
一个父类通常会定义一个接口方法（或者多个方法），这些方法可以被各个子类以不同的方式来实现。
在我们的例子中，Drawable就是个父类。游戏中每个Drawable对象都将是Drawable的子类；
每个类都会继承拥有draw方法这一特性，让获取Drawable对象的代码能够知道draw方法是可用的。 
然后每个类都会实现它们自己的draw方法版本――实际上，它必须实现自己的draw方法版本，
要保证Drawable的所有子类都有一个正确的draw方法。
有时使用超类来代替父类，使用派生类代替子类。本书中将使用父类和子类。使用父类和子类可能比较符合习惯。
好了，了解基本概念了吧？继续来看看语法：
class Ship : public Drawable
{

};
class Ship : public Drawable表示Ship类继承自Drawable类。
这么写，Ship从它的父类也就是Drawable那里继承了所有的公共方法和公共数据。
现在，Ship就已经继承了draw方法。如果这样写：
Ship s;
s.draw();
对draw方法的调用会调用到写在Drawable里面的draw方法的实现。
在这里这不是我们想要的，因为Ship类应当有它自己的绘制方式，而不是使用用来作为Drawable接口一部分的那个版本。
要让Ship类能够实现这个想法，Drawable类必须标示draw方法可以被子类重写。
你可以使用虚方法（virtual）；虚方法是父类的一个组成部分，但是它可以被不同的子类所重写。
class Drawable
{
public:
    virtual void draw ();
};
很多情况下，你并不需要父类提供任何的具体方法实现，而是需要强制子类要有它们自己的实现。
（比如说，并不存在一个“默认”的方式来绘制一个对象。）
你可以通过把函数设为纯虚函数来达到强制目的，就像下面这样（注意那个 = 0）：
class Drawable
{
public:
    virtual void draw () = 0;
};
这个语法第一次看上去肯定是怪异的！尽管这么写是遵循逻辑的―― 把方法设为0是表示它不存在的一种方式。
如果一个类有纯虚方法， 那么它的子类就必须实现这个纯虚方法。
要实现它，子类需要再次声明这个方法，不要在后面加 = 0 。这表示该类将会提供一个这个方法的真正的实现：
class Ship : public Drawable
{
public:
    virtual draw ();
};
现在这个方法就可以像任何普通的方法一样来定义了：
Ship::draw ()
{
    /* 执行绘制的代码 */
}
你也许会问，如果所要做的只是让draw方法没有任何实现，那么到底为何还需要一个像Drawable这样的父类？
关键点就在于需要父类是为了定义所有子类都要实现的接口。
然后我们就能写代码，这些代码准备着使用Drawable接口而不需要知道正在使用的类到底是什么类型的。
有些编程语言允许你把任何对象传递给任何函数，并且只要传进去的对象实现了该函数需要使用到的方法，一切都能正常运行。
然而，C++要求函数公开它们参数的接口。如果我们没有Drawable接口，开始甚至都不能把这些类都放到同一个vector中；
没有任何“共同 的”东西可以用来识别哪些可以放进vector中。来看看使用vector并且绘制所有对象的代码：
vector<Drawable *> drawables;

drawables.push_back( new Ship() );

for ( vector<Drawable *>::iterator itr = drawables.begin(), end = drawables.end(); itr != end; ++itr )
{
    (*itr)->draw();
}
我们可以把不同类型的Drawable对象添加到vector （假设有个同样继承自Drawable的Enemy类）：
drawables.push_back( new Ship() );
drawables.push_back( new Enemy() );
一切都会正常运行――对于飞船我们调用的是Ship::draw，而对于敌人调用的是Enemy::draw。
顺便说一下，我们使用vector<Drawable*>而不是vector<Drawable>这一点很重要。
指针有着很大的意义；如果不是用指针，这些都将歇菜。
要看看为什么，比如我们写下不是使用指针来保存对象的代码时：
vector<Drawable> drawables;
在内存中，我们现在会开辟存储着不同Drawable对象的内存，所有的都是相同大小：
[Drawable 1][Drawable 2][Drawable 3]     
如果不是使用指针的话 vector就必须要存储下整个的对象。但是每个对象可能大小并不一样，
一个Ship和一个Enemy可能有不同的字段， 并且可能都比基本的Drawable小。这样代码就不能正确地运行了。
相反指针一直是相同的大小。我们可以这么说：
[Pointer to Drawable][Pointer to Drawable][Pointer to Drawable]
如果我们有一个[Pointer to Ship]，它所要占的内存和指向一个Drawable的指针是完全一样大的。这也是为什么要这么写：
vector<Drawable*> drawables;
现在我们可以凭意愿把任何类型的指针放到vector中，只要这个指针是指向一个继承自Drawable的类的，
在循环之内，所有这些对象都会被绘制到屏幕上，使用的是子类的draw方法。
（从技术上讲，任何指针都是合法的，但是不能仅仅因为它合法就把它放到我们的vector当中。
这里vector的全部意义就在于存放一系列可以被绘制的东西。放进来一些无法被绘制的东西将会成为可怕的麻烦。）
要记住：任何时候想要用一个继承了父类接口的类，你都需要使用指针来传递它。
现在既然都已经看过了这个例子的所有细枝末节，那么让回头来看看我们都做了些什么。
1.首先定义了一个Drawable接口，它可以被子类继承。 
2.任何把Drawable当做参数的函数，或者任何可以使用Drawable的代码，都可以调用其所指向的对象实现的draw方法。
3.这允许已有的代码使用新类型的对象，只要这些对象实现了Drawable接口。
我们可以向游戏中添加新的东西――增加力量的钱币或者额外的生命，背景图片，无论什么，
处理它们的代码除了要求它们是Drawable之外不需要知道关于它们的任何情况。
这些都涉及重用。这里的重用指的是自已有的代码可以对新创建的类进行操作。
可以写新的类，和已有代码（如绘制游戏中各个元素的循环）兼容，而不需要修改已有代码来配合新的类。
（我们确实需要把新类的对象加到存放Drawable的vector中，但是循环本身不需要修改。）
这种行为叫做多态。顾名思义，多就是代表很多，而态呢就代表格式形态――合起来就是很多形态。
换句话说，每个实现特定接口的类就是一种形态，并且由于有些代码写出来就是仅仅为了使用接口的，
这样它们就能处理很多不同的类，这些代码也就可以支持特定接口的多种形态，
就如同一个会开车的人就能开汽油动力的，混合动力的， 或者是纯电动的汽车。
26.1.1 继承的别的作用以及误用的情况
多态取决于继承，但是继承并不是仅仅可以继承一个接口。如我之前提到的，还可以利用继承来获得一个函数实现。
举个例子，如果Drawable接口还有另外一个非虚方法，这个方法将会被每个继承Drawable的对象继承过去。
有时候人们相信继承是为了通过继承方法来实现重用（这样避免了为每个子类都去写同样的方法）。
然而这是一个局限性很大的重用方式。你确实可以通过继承完整的方法实现来节省一些时间或者空间；
但是如果这么做了，那么你就有了个大的挑战：怎么去确保那个方法的实现对于每个子类来说都是正确的呢？
这需要仔细的思考是否某个东西一直都是正确的。
来看看为什么这很困难。假设有Player和Ship两个对象，它们都实现了Drawable接口，同时这些类都有个getName的方法。
你也许要决定把getName方法添加到Drawable类当中，这样这两个类就可以共享这个方法相同的实现。
class Drawable
{
public:
    string getName ();
    virtual void draw () = 0;
};
由于getName不是虚的，所有的子类都会继承这个方法的实现。
如果你决定要加入一个新的类，一个想要绘制出来的，比如说Bullet，会发生什么事？
每个子弹都需要有个名字吗？当然不是！让Bullet类拥有一个没用的getName方法看上去似乎没什么大不了的，
而对一个类来说，这不是多了一个不好的方法这么简单。问题在于一次又一次地这么做会造成令人费解的复杂的类层级，
这时候接口的目的就显得不太清楚了。
26.1.2 继承、对象构建和销毁
当继承一个父类的时候，子类的构造函数会调用父类的构造函数―― 就像它调用类的所有字段的那些构造函数一样。
举个例子，看看下面的代码：
#include <iostream>

using namespace std;

class Foo
{
public:
    Foo ()
    {
        cout << "Foo's constructor" << endl;
    }
};

class Bar : public Foo
{
public:
    Bar ()
    {
        cout << "Bar's constructor" << endl;
    }
};

int main ()
{
    Bar bar;
}
示例代码59：constructor.cpp
在bar被初始化的时候，首先Foo的构造函数会运行然后Bar的构造函数再运行。这段代码的输出是：
Foo's constructor
Bar's constructor
让父类的构造函数先运行，这样可以在子类可能使用父类的字段之前，先初始化父类的所有字段。
在运行子类的构造函数之前运行父类的构造函数可以确保在子类可能使用父类字段的时候，事先知道那些字段都已经初始化过了。
这些工作编译器都自动为你做好了――你不需要做任何事来让父类的构造函数被调用。
相似地，在子类的析构函数运行以后，父类的析构函数会被自动调用。下面这段代码就是一个例子：
#include <iostream>

using namespace std;

class Foo
{
public:
    Foo ()
    {
        cout << "Foo's constructor" << endl;
    }
    ~Foo ()
    {
        cout << "Foo's destructor" << endl;
    }
};

class Bar : public Foo
{
public:
    Bar ()
    {
        cout << "Bar's constructor" << endl;
    }
    ~Bar ()
    {
        cout << "Bar's destructor" << endl;
    }
};

int main ()
{
    Bar bar;
}
示例代码60：destructor.cpp
这里是上面代码的输出：
Foo's constructor
Bar's constructor
Bar's destructor
Foo's destructor
注意，构造函数和析构函数被调用的顺序是相反的；这样可以保证Bar的析构函数能够安全地使用继承自Foo的方法，
因为那些方法操作的数据仍然处在一个合法、可用的状态。这和父类构造函数要在子类构造函数之前运行背后的理由是很相似的。
在有些情况下，你也许希望调用一个非默认的父类构造函数。初始化列表可以允许你这么做，通过在列表中提供父类的名字来实现。
class FooSuperclass
{
public:
    FooSuperclass (const string &val);
};
class Foo : public FooSuperclass
{
public:
    Foo ()         : FooSuperclass( "arg" )
    {}
};
父类构造函数的调用在初始化列表中应当出现在该类的字段之前。
26.1.3 多态和对象销毁
对象销毁以及当一个对象通过接口被销毁的时候它是如何运行的，这些是容易弄错的地方。
举个例子，你可能写了像下面这样的代码：
class Drawable
{
public:
    virtual void draw () = 0;
};

class  MyDrawable : public Drawable
{
public:
    virtual void draw ();
    MyDrawable ();
    ~MyDrawable ();

private:
    int *_my_data;
};

MyDrawable::MyDrawable ()
{
    _my_data = new int;
}

MyDrawable::~MyDrawable ()
{
    delete _my_data;
}

void deleteDrawable (Drawable *drawable)
{
    delete drawable;
}

int main ()
{
    deleteDrawable( new MyDrawable() );
}
那么在deleteDrawable里面会发生什么呢？记住析构函数是在delete使用的时候被调用的。
那么这行代码：
delete drawable;
就是在调用该对象的析构函数。但是编译器怎么知道如何去找到MyDrawabe的析构函数呢？
它并不知道这个drawable变量的具体类型 ――它只能知道这个变量是个Drawable一个含有名称为draw的方法的东西。
它只知道如何去找到与Drawable相关联的析构函数，而不 是MyDrawable自己的析构函数。
不幸的是，这里由于MyDrawable类在它的构造函数中分配了内存，运行MyDrawable的析构函数来释放那段内存是很重要的。
你也许会想：这不正好是虚函数应该去处理的问题吗？没错，正是如此！
我们所需要做的就是在Drawable类中把析构函数声明为虚的，
这样在一个指向Drawable的指针被调用delete的时候，编译器就知道去寻找一个重写的析构函数了。
class Drawable
{
public:
    virtual void draw ();
    virtual ~Drawable ();
};

class MyDrawable : public Drawable
{
public:
    virtual void draw ();
    MyDrawable ();
    virtual ~MyDrawable ();
private:
    int *_my_data;
};
通过在父类中将析构函数标志为虚的，在使用delete释放一个Drawable接口的时候，重写的析构函数就会被调用。
和通常的规则一样，当你把父类中的任何方法设为虚时，就应该把父类的析构函数设为虚的。
当你将一个单独的方法设为虚的时候，就是在说人们可以把这个类传到接收一个接口为参数的方法中。
那些方法可以做任何它们想要做的，包括删除传进来的对象，所以将析构函数设为虚的用来保证对象会被正确地清理掉。
26.1.4 对象切割的问题
对象切割是在处理继承时需要注意的另一个问题。对象切割常在你写出下面这样的代码时发生：
class Superclass {};

class Subclass : public Superclass
{
    int val;
};
int main()
{
    Subclass sub;
    Superclass super = sub;
}
来自子类的val字段并没有作为赋值操作的一部分赋给父类！
遗憾的是，这通常不是你想要的（尽管事实上C++允许这种操作）因为在父类变量那里只有子类对象的一部分。
这种对象切割有时能够运行，但是它会经常导致程序崩溃。尤其是该类有想要使用子类字段的虚函数的时候。
幸运的是，有个方式可以让编译器告诉你有这类问题发生。你可以把父类的复制构造函数声明为私有的并且不要去实现它：
class Superclass
{
public:
    Superclass () {}
private:
    Superclass (const Superclass &other);
};

class Subclass : public Superclass
{
    int val;
};

int main ()
{
    Subclass sub;
    Superclass super = sub;
}
但是假如真的需要有个复制构造函数怎么办呢？
另外一种避免这个问题的方式是让所有父类都至少有一个纯虚函数。这样可以保证就算你这么写：
Superclass super;
代码都不会通过编译，因为你不能创建一个有着纯虚函数的对象。另 一方面，这么写仍然是可以的：
 Superclass *super = & sub;
这样就可以利用多态的好处同时避免对象切割的问题。
26.1.5 与子类共享代码
到目前为止我们已经讨论了public修饰符和private修饰符的保护――public方法对于类以外的任何人都是可用的，
private方法和数据只对于同一个类当中的其他方法可用。
但是如果想要一个父类能够提供子类可以调用的方法，而又不是通过内部的类来实现，该怎么做呢？首先，你会有这么做的需求吗？可能会的。父类共享出一些实现的代码是很常见的事。
举个例子，假设有个通过清除屏幕上某块区域来帮助对象绘制自身的方法。我们称这个方法为clearRegion：
class Drawable
{
public:
    virtual void draw ();
    virtual ~Drawable ();
    void clearRegion (int x1, int y1, int x2, int y2);
};
这里继承的使用不是为了继承接口，而是为了子类能够访问通用的实现代码。
这是继承的一个合法使用，因为子类要么需要使用这个方法要么可能需要使用它。
由于它不是公共接口的一部分，它只是所创建的类层级中的一个实现细节。
但是怎么来避免这个方法成为类的接口的一部分呢？
如上面展示的一 样，把它设为public允许任何人调用这个方法――哪怕它本不应该是这样的。
另一方面，你又不能把它设为private，因为子类不能访问父类的私有字段和方法，而且阻止子类的访问会使我们的整个目的失败！
26.1.6 protected的数据
答案就是使用第三种也是最后一种访问修饰符――protected。
任何在类的protected区域的方法都可以被子类访问，不像private方法那样， 但是在类之外又是不可访问的，不像public方法那样。protected所用的语法和public与private是一样的：
class Drawable
{
public:
    virtual void draw ();
    virtual ~Drawable ();
protected:
    void clearRegion (int x1, int y1, int x2, int y2);
};
现在只有Drawable的子类可以访问clearRegion。
protected方法通常很有用，但是我可从来不会推荐使用protected修饰的数据。
没有必要把数据的全部访问权限暴露给整个的类层级，原因和不想要把数据暴露到其他别的地方一样，
因为想要在以后能够修改它。取而代之，可以使用protected方法来提供子类中对父类数据的访问。
26.1.7 属于类的数据
到现在为止，对一个类你所能做的都是把数据存储在单独的对象实例中。
很多情况下，这就足够了，但是还有一些情况确实需要存储不仅仅是属于某个特定对象的数据，而是属于整个类的数据。
有个例子就是如果想要创建一个类，它要求每个对象有个唯一的序列号。每个对象都应该有它自己的序列号，
但是怎样跟踪想要赋值的下一个序列号呢？你需要有地方在类的层次上来存储“下一个序列号”，
这样每当一个新的对象创建的时候，就知道要赋给它什么值。
（为什么要做类似这样的事呢：首先有一点，使用每个对象的序列号能够更简单地在日志语句中识别这些对象。
序列号可以用来在不同行数的日志文件中跟踪某个对象。）
你创建属于类的数据的方式是使用一个该类的静态成员。不像普通的实例数据，静态数据不是任何单个对象的一部分；
它对于类的所有对象都可用，如果是public那就对所有人都可用。
实际上，静态变量和全局变量很相似，除了在类的外部访问静态变量时你需要在变量名之前添加类名作为前缀。
来看看它写出来是什么样子。下面是声明了一个静态变量的类：
class Node
{
public:
    static int serial_number;
};
static int Node::serial_number = 0;
不仅可以使用静态变量，你还可以使用静态方法――作为类的一部分的方法，它可以在没有实例对象的情况下使用。
让我们来看看通过添加一个叫做_getNextSerialNumber的私有静态方法来创建序列号。
class Node
{
public:
    Node ();
    int getSerialNumber () const;

private:
    static int _getNextSerialNumber ();

    static int _next_serial_number;
    int _serial_number;
};

int Node::_next_serial_number = 0;

Node::Node () : _serial_number( _getNextSerialNumber() )
{
}
int Node::getSerialNumber () const
{
    return _serial_number;
}
int Node::_getNextSerialNumber ()
{
    return _next_serial_number++;
}
要记住，当你使用静态方法的时候，它是类的一部分，但是它没有权限访问对象特有的字段。
它只能访问静态的数据。静态方法在调用的时候没有this指针传递给它。
26.1.8 如何实现多态
注意：编译器怎么实现多态是个很高级的话题，同时它会带你深入到C++在这方面的实现。
我把这一部分包含进来是因为它是个优雅的实现技巧，我想和你分享它。
在你第一次（或者第二次）接触多态的时候就去学习这个知识并不是必要的。
如果你对于多态的魔法是怎么实现的感到好奇，那就继续读下去；如果头皮发麻，就不要再费劲了。
以后你需要理解更多细节的时候，随时可以返回到这部分。
多态的核心思想是在接口上执行函数，而不是在一个具体的子类上， 这样对应一行给出的机器码就不需要确切知道要调用哪个函数。举个 例子，下面的代码中：
vector<Drawable *> drawables;

void drawEverything ()
{
    for ( int i = 0; i < drawables.size(); i++ )
    {
        drawables[ i ]->draw();
    }
}
对drawables[ i ]->draw()的调用无法被编译成对一个特定方法的调用，因为draw方法是虚的。
根据不同的继承自Drawable的对象，它可能调用任意个不同的方法：绘制一发子弹，玩家的飞船，一个敌方飞 船，
或者一个大力药丸。
此外，drawEverything对于它调用的代码一无所知。调用draw方法的那行代码只要看到Drawable接口就行了。
它不需要了解任何真正实现Drawable的对象。但是这样它又怎么去调用Drawable子类的方法呢？
对象持有一个虚方法的列表作为它的隐藏字段――在这个例子当中， 有一个入口，含有draw方法的地址。
接口中的每个方法都被赋予了一个数字（draw是方法 0）；当调用一个虚方法的时候，
与该方法相关联的数字会被用来作为访问该对象虚方法列表的索引。对虚方法的调用被编译为一个对虚方法列表的查找，
后面紧跟着一个对所查找的方法的调用。在上面的代码中，对于draw方法的调用会变成在方法表中对方法0的一个查找，
跟随着对方法0的地址的调用。这里的虚方法列表称为vtable（虚拟表的简称）。
这里是它的示意图： 
由于对象持有着它自己使用的方法表，编译器在编译不同的类的时候可以改变表中的地址来提供虚方法的一个指定的实现。
当然，这不用自己做――编译器都帮你做了。使用方法表的代码只需要确切地知道表中寻找每个虚方法的索引。
虚方法表只会包含那些被声明为虚的方法――非虚方法不需要这个机制，所以它们也就没有虚方法表的入口。
如果你写的类根本就没有虚方法，那么它就不会有虚表。
当一个虚方法被调用的时候，这就相当于执行访问虚表并且通过索引找到方法的代码。这样写：
drawables[ i ]->draw();
编译器会做如下理解。
1.获取存储在drawables[ i ]中的指针。
2.通过这个指针找到与Drawable类型的接口相关的那组方法所在虚表的地址（这个例子中只有一个方法）。
3.在函数表中找到给定名称（这里就是draw）的函数。函数表在字面上就是存储着每个函数在内存中的地址的集合。
4.带着相关的参数去调用所找到的函数。
通常第2步不是通过使用函数真正的名称来完成的，而是通过编译器把每个函数名转换为表中的一个索引来实现的。
这样保证了在运行时进行虚函数的调用操作会快得难以置信――执行虚函数的调用操作和调用正常的函数在性能上只有很小的差别。
你可以把编译器生成的代码看成是这样的（当然，我杜撰了调用的语法） ：
call drawables[ i ]->vtable[ 0 ];
另一方面，使用虚函数也存在着一个真实的弊端。你的对象大约需要为每个继承的接口持有一个虚表。
这意味着每个虚的接口都会将对象的大小扩大几字节。在现实中，只有代码中出现了大量的对象，
同时 这些对象中的成员变量又很少时，虚函数才会带来性能上的问题。
问答题
1.父类的析构函数在什么时候运行？
A. 只有对一个指向父类的指针调用 delete 来销毁对象的时候
B. 在子类的析构函数被调用之前
C. 在子类的析构函数被调用之后
D. 在子类的析构函数被调用的时候

C
2.给定下列的类层级，在Cat的构造函数中你需要做什么？
class Mammal
{
public:
    Mammal (const string &species_name);
};
class Cat : public Mammal
{
public:
    Cat();
};
A. 没什么特别要做的
B. 使用初始化列表来调用Mammal的构造函数同时带上参数 "cat"
C. 在Cat的构造函数中调用Mammal的构造函数，带上参数 "cat"
D. 你应当删除Cat的构造函数并且使用默认的版本，默认构造函数会 为你解决这个问题

B
3.下面的这个类定义哪里错了？
class Nameable
{
    virtual string getName();
};
A. 它没有把getName方法设为 public
B. 它没有虚的析构函数
C. 它没有getName方法的实现，但是又没有把getName声明为纯虚的
D. 上面说得都对

D
4.在一个接口类中声明一个虚方法时，另外的一个函数需要怎么做才 可以使用这个接口方法来在子类上调用方法？
A. 把接口当做一个指针参数（或者一个引用参数）
B. 什么都不用做，它会自动复制对象
C. 它需要知道被调用方法所在子类的名字
D. 我迷惑了！虚方法是什么？

A
5.继承是如何改善重用的？
A. 通过允许代码从父类继承方法
B. 通过允许父类为子类实现虚方法
C. 通过允许代码期待接收一个接口，而不是一个具体的类，允许新的 类来实现接口同时保持旧的代码可用
D. 通过允许新的类继承一个具体的类的特性，这些特性可以为虚方法 所使用

C
6.下列关于类的访问级别哪个是正确的？
A. 子类只能访问父类的 public 方法和数据
B. 子类能够访问父类的private 方法和数据
C. 子类只能访问父类的protected 方法和数据
D. 子类可以访问父类的protected 或者public 方法和数据

D
实践题
1.实现一个排序函数，该函数接收一个存放着指向HighScoreElement类的指针的vector，
HighScoreElement类定义一个compare(HighScoreElement & other)方法，
如果两个对象一样则返回0，对象大于另外一个则返回1，小于另一个则返回-1。
HighScoreElement类，它包含一个名称和一个分数，
先按照分数进行排序，如果两个分数相同，就接着按名称来排序。

HighScoreElement.h
#pragma once
#ifndef HIGHSCOREELEMENT_H_
#define HIGHSCOREELEMENT_H_

#include <string>

using namespace std;

class HighScoreElement
{
public:
	HighScoreElement(string name, int score);

	string getName() const;
	int getScore() const;

	int compare(HighScoreElement& other);
private:
	string _name;
	int _score;
};

#endif

HighScoreElement.cpp
#include <iostream>
#include <string>
#include "HighScoreElement.h"

using namespace std;

HighScoreElement::HighScoreElement(std::string name, int score)
{
    _name = name;
    _score = score;
}

int HighScoreElement::compare(HighScoreElement &other)
{
    if (this->_score < other._score)
    {
        return -1;
    }
    else if(this->_score > other._score)
    {
        return 1;
    }
    else if (this->_name < other._name)
    {
        return -1;
    }
    else if(this->_name > other._name)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}


string HighScoreElement::getName() const
{
    return _name;
}

int HighScoreElement::getScore() const
{
    return _score;
}

ch26_p01.cpp
#include <iostream>
#include <list>
#include "HighScoreElement.h"

using namespace std;

void print(const list<HighScoreElement *> &scores);
list<HighScoreElement *> sortDescending(const list<HighScoreElement *> &scores);
list<HighScoreElement *> sortAscending(const list<HighScoreElement *> &scores);
HighScoreElement *getMinElement(const list<HighScoreElement *> &scores);

int main()
{
    list<HighScoreElement *> scores;
    scores.push_back(new HighScoreElement("Mark", 666));
    scores.push_back(new HighScoreElement("Char", 999));
    scores.push_back(new HighScoreElement("Moe", 50));
    scores.push_back(new HighScoreElement("Foo", 123));
    scores.push_back(new HighScoreElement("Bar", 321));
    scores.push_back(new HighScoreElement("Gnar", 50));

    cout << "Creating score elements added out of order...\n";
    print(scores);

    cout << "Sorting score elements by descending score and by name\n";
    scores = sortDescending(scores);
    print(scores);

    cout << "Sorting score elements by ascending score and by name\n";
    scores = sortAscending(scores);
    print(scores);

    HighScoreElement *tempElement = nullptr;
    for (list<HighScoreElement *>::const_iterator itr = scores.begin(), end = scores.end(); itr != end; ++itr)
    {
        tempElement = *itr;

        if (tempElement != nullptr)
        {
            delete tempElement;
        }
    }
}

list<HighScoreElement *> sortDescending(const list<HighScoreElement *> &scores)
{
    list<HighScoreElement *> sortedScores;
    list<HighScoreElement *> unsortedScores(scores);
    while (unsortedScores.size() != 0)
    {
        HighScoreElement *minElement = getMinElement(unsortedScores);
        sortedScores.push_front(minElement);
        unsortedScores.remove(minElement);
    }
    return sortedScores;
}

list<HighScoreElement *> sortAscending(const list<HighScoreElement *> &scores)
{
    list<HighScoreElement *> sortedScores;
    list<HighScoreElement *> unsortedScores(scores);
    while (unsortedScores.size() != 0)
    {
        HighScoreElement *minElement = getMinElement(unsortedScores);
        sortedScores.push_back(minElement);
        unsortedScores.remove(minElement);
    }
    return sortedScores;
}

HighScoreElement *getMinElement(const list<HighScoreElement *> &scores)
{
    HighScoreElement *minElement = nullptr;
    for (list<HighScoreElement *>::const_iterator itr = scores.begin(), end = scores.end(); itr != end; ++itr)
    {
        if (minElement == nullptr)
        {
            minElement = *itr;
        }
        else if ((*itr)->compare(*minElement) == -1)
        {
            minElement = *itr;
        }
        else if ((*itr)->compare(*minElement) == 0)
        {
            cout << (*itr)->getName() << ": " << (*itr)->getScore() << " is repeated.\n";
        }
    }
    return minElement;
}

void print(const list<HighScoreElement *> &scores)
{
    for (list<HighScoreElement *>::const_iterator itr = scores.begin(), end = scores.end(); itr != end; ++itr)
    {
        cout << (*itr)->getName() << ": " << (*itr)->getScore() << '\n';
    }
    cout << '\n';
}
编译命令如下
g++ -o ch26_p01 ch26_p01.cpp HighScoreElement.cpp

显示结果如下
Creating score elements added out of order...
Mark: 666
Char: 999
Moe: 50
Foo: 123
Bar: 321
Gnar: 50

Sorting score elements by descending score and by name
Char: 999
Mark: 666
Bar: 321
Foo: 123
Moe: 50
Gnar: 50

Sorting score elements by ascending score and by name
Gnar: 50
Moe: 50
Foo: 123
Bar: 321
Mark: 666
Char: 999

2.为你的排序函数提供另一个实现，这次接收一个叫做Comparator的接 口，
其中有个方法compare(const string& lhs, const string& rhs)和之 前的比较方法遵循相似的规则：
如果两个值相同就返回0，lhs > rhs就返回1，lhs < rhs就返回-1。
写两个不同的类来做比较：一个不区分大小写，一个区分大小写。

Comparator.h
#pragma once
#ifndef COMPARATOR_H_
#define COMPARATOR_H_

#include<string>

using namespace std;

class Comparator
{
public:
    virtual ~Comparator();
    virtual int compare(const string &lhs, const string &rhs) = 0;
};

#endif

Comparator.cpp
#include <iostream>
#include "Comparator.h"

Comparator::~Comparator()
{
    cout << "Comparator's destructor\n";
}

CaseInsensitiveSort.h
#pragma once
#ifndef CASEINSENSITIVESORT_H_
#define CASEINSENSITIVESORT_H_

#include <string>
#include "Comparator.h"

using namespace std;

class CaseInsensitiveSort : public Comparator
{
public:
    virtual ~CaseInsensitiveSort();
    virtual int compare(const string &lhs, const string &rhs);
};

#endif

CaseInsensitiveSort.cpp
#include <iostream>
#include <string>
#include "CaseInsensitiveSort.h"

using namespace std;

CaseInsensitiveSort::~CaseInsensitiveSort()
{
    cout << "CaseInsensitiveSort's destructor\n";
}

int CaseInsensitiveSort::compare(const string &lhs, const string &rhs)
{
    int lhsLength = lhs.length();
    int rhsLength = rhs.length();

    if (lhsLength == 0 && rhsLength != 0)
    {
        return -1;
    }
    else if (lhsLength != 0 && rhsLength == 0)
    {
        return 1;
    }
    else if (lhsLength == 0 && rhsLength == 0)
    {
        return 0;
    }

    char lc, rc;
    int minLength;
    lhsLength < rhsLength ? minLength = lhsLength : minLength = rhsLength;
    for (int i = 0; i < minLength; i++)
    {
        if ( ( lc = tolower(lhs[i]) ) != ( rc = tolower(rhs[i]) ) )
        {
            if (lc < rc)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }
    }

    if (lhsLength == rhsLength)
    {
        return 0;
    }
    else if (lhsLength < rhsLength)
    {
        return -1;
    }
    else
    {
        return 1;
    }
}

ReverseSort.h
#pragma once
#ifndef REVERSESORT_H_
#define REVERSESORT_H_

#include <string>
#include "Comparator.h"

using namespace std;

class ReverseSort : public Comparator
{
public:
    virtual ~ReverseSort();
    virtual int compare(const string &lhs, const string &rhs);
};

#endif

ReverseSort.cpp
#include <iostream>
#include <string>
#include "ReverseSort.h"

using namespace std;

ReverseSort::~ReverseSort()
{
    cout << "ReverseSort's destructor\n";
}

int ReverseSort::compare(const string &lhs, const string &rhs)
{
    if (lhs < rhs)
    {
        return -1;
    }
    else if (lhs > rhs)
    {
        return 1;
    }
    return 0;
}

ch26_p02.cpp
#include <iostream>
#include <list>
#include "CaseInsensitiveSort.h"
#include "ReverseSort.h"

using namespace std;

void print(const list<string> &items);
list<string> sort(const list<string> &items, Comparator &sorter);
string getMinElement(const list<string> &items, Comparator &sorter);

int main()
{
    list<string> items;
    items.push_back("Mark");
    items.push_back("Char");
    items.push_back("Moe");
    items.push_back("Foo");
    items.push_back("maRk");
    items.push_back("Bar");
    items.push_back("Gnar");

    cout << "Creating strings added out of order...\n";
    print(items);

    cout << "Sorting string elements by case insensitive rank\n";
    CaseInsensitiveSort caseInsensitiveSorter;
    list<string> itemsSortedCaseInsensitive = sort(items, caseInsensitiveSorter);
    print(itemsSortedCaseInsensitive);

    cout << "Sorting string elements reverse alphabetical order\n";
    ReverseSort reverseSorter;
    list<string> itemsSortedReverseAlphabetical = sort(items, reverseSorter);
    print(itemsSortedReverseAlphabetical);
}

list<string> sort(const list<string> &items, Comparator &sorter)
{
    list<string> sortedScores;
    list<string> unsortedScores(items);
    while (unsortedScores.size() != 0)
    {
        string minElement = getMinElement(unsortedScores, sorter);
        sortedScores.push_front(minElement);
        unsortedScores.remove(minElement);
    }
    return sortedScores;
}


string getMinElement(const list<string> &items, Comparator &sorter)
{
    string minElement = "";
    for (list<string>::const_iterator itr = items.begin(), end = items.end(); itr != end; ++itr)
    {
        if (minElement == "")
        {
            minElement = *itr;
        }
        else if (sorter.compare(*itr, minElement) == -1)
        {
            minElement = *itr;
        }
    }
    return minElement;
}

void print(const list<string> &items)
{
    for (list<string>::const_iterator itr = items.begin(), end = items.end(); itr != end; ++itr)
    {
        cout << *itr << '\n';
    }
    cout << '\n';
}
编译命令如下
g++ -o ch26_p02 ch26_p02.cpp Comparator.cpp CaseInsensitiveSort.cpp ReverseSort.cpp

显示结果如下
Creating strings added out of order...
Mark
Char
Moe
Foo
maRk
Bar
Gnar

Sorting string elements by case insensitive rank
Moe
maRk
Mark
Gnar
Foo
Char
Bar

Sorting string elements reverse alphabetical order
maRk
Moe
Mark
Gnar
Foo
Char
Bar

ReverseSort's destructor
Comparator's destructor
CaseInsensitiveSort's destructor
Comparator's destructor

3.实现一个日志方法，一个接口类StringConvertable含有一个将对象转换成一个表示自身的字符串的toString方法。
日志方法应该同时也能够输出数据和时间。
再次注意我们是如何通过简单地实现一个接口来重用日志方法的。

StringConvertable.h
#pragma once
#ifndef STRINGCONVERTABLE_H_
#define STRINGCONVERTABLE_H_

#include <string>

using namespace std;

class StringConvertable
{
public:
    virtual ~StringConvertable();
    virtual string toString() = 0;
};

#endif

StringConvertable.cpp
#include <iostream>
#include "StringConvertable.h"

StringConvertable::~StringConvertable()
{
    cout << "StringConvertable's destructor\n";
}

Foo.h
#pragma once
#ifndef FOO_H_
#define FOO_H_

#include <string>
#include "StringConvertable.h"

using namespace std;

class Foo : public StringConvertable
{
public:
    virtual ~Foo();
    virtual string toString();
};

#endif

Foo.cpp
#include <iostream>
#include <string>
#include "Foo.h"

using namespace std;

Foo::~Foo()
{
    cout << "Foo's destructor\n";
}

string Foo::toString()
{
    return  "Foo";
}

Bar.h
#pragma once
#ifndef BAR_H_
#define BAR_H_

#include <string>
#include "StringConvertable.h"

using namespace std;

class Bar : public StringConvertable
{
public:
    virtual ~Bar();
    virtual string toString();
};

#endif

Bar.cpp
#include <iostream>
#include <string>
#include "Bar.h"

using namespace std;

Bar::~Bar()
{
    cout << "Bar's destructor\n";
}

string Bar::toString()
{
    return  "Bar";
}

ch26_p03.cpp
#include <ctime>
#include <iomanip>
#include <iostream>
#include "Foo.h"
#include "Bar.h"

using namespace std;

void logging(StringConvertable &object);

int main()
{
    Foo foo;
    Bar bar;

    cout << "Writing objects with logger...\n";
    logging(foo);
    cout << '\n';
    logging(bar);
    cout << '\n';
}

void logging(StringConvertable &object)
{
    time_t cur_time = time(nullptr);
    struct tm timeInfo;
    localtime_r(&cur_time, &timeInfo);

    cout << put_time(&timeInfo, "%d-%m-%Y %H-%M-%S") << endl;
    cout << object.toString() << endl;
}
编译命令如下
g++ -o ch26_p03 ch26_p03.cpp StringConvertable.cpp Foo.cpp Bar.cpp

显示结果如下
Writing objects with logger...
07-10-2020 11-58-51
Foo

07-10-2020 11-58-51
Bar

Bar's destructor
StringConvertable's destructor
Foo's destructor
StringConvertable's destructor

第27章 命名空间
开始创建越来越多的类时，你也许要疑惑了：“难道没有人写过实现这个功能的代码吗？如果有，我可以拿来用吗？”
有时，确实会有人已经实现过。很多核心算法和数据结构，像链表或者二叉树，已经有很稳定的、可重用的实现，
而且你会需要使用那些代码。但是如果使用别人写的代码，你得注意避免命名冲突。
举个例子，你可能需要写一个叫做LinkedList的类来实现链表。
但是存在这样的可能，就是你使用的代码中已经有个类叫同样的名字，但是具体实现跟你的不一样。
两者必有所取舍――你不能有两个类叫同样的名字。
要避免这个冲突，你可以通过创建一个命名空间来扩展类型的基本名称。
举个例子，我可以把我的链表类放到一个叫做com::cprogramming的命名空间中去，
这样我这个类型的完整的标准名称就是com::cprogramming::LinkedList。
使用命名空间从根本上减少了命名冲突的几率。这里的操作符::和之前用来访问类的静态成员或者声明一个方法时的::是一样的，
但是这里它不是用来访问类的元素，而是用来访问一个命名空间中的元素。
现在你可能又要疑惑了，如果命名空间真的这么好，为什么标准库的代码不使用呢？难道我们只是敲了很多没用的东西吗？
结果是你已经见过命名空间了。在每个程序的顶上都有：
using namespace std;
这样在引用像cin或者cout这些对象的时候可以避免使用完整的名称。 
如果不写这句声明，在每次使用那些对象的时候我们都要写std::cin或者std::cout。
这个技巧在不需要用命名空间来避免某个文件中命名冲突时仍然有用，
这时它可以提供一个便捷的方式让你知道文件中没有命名冲突。
当文件中有命名冲突的时候，你要做的只是省略命名空间的使用声明然后把文件中的每个类型写成完整的形式就行了。
来看看如何把它用在之前的那个例子上。如果有两个不同的类都叫LinkedList，大部分文件都会在开始的时候使用命名空间com::cprogramming。
如果某个文件中名称之间有了冲突，我们修改那个文件让它以com::cprogramming::LinkedList的方式来引用我的LinkedList类。
我不需要修改所有的代码，我只要修改同时用到两种LinkedList的地方对应的代码。
在那些文件中，我要使用完整的名称并且把使用using namespace com::cprogramming命名空间的声明去掉。
下面是个例子，你可以看看怎么把一些代码声明为某个命名空间的一部分――这里只有一个单独的变量：
namespace cprogramming
{
    int x;
}
// <-- 注意这里不需要分号
现在必须以cprogramming::x来引用x或者：
using namespace cprogramming;
这样在使用了命名空间cprogramming的文件中只要写x就行了。
还可以嵌套命名空间，把一个放在另一个里面。如果是在一家大公司，有着很多不同的小组，每个小组都要做各自不同的开发，
这时候你就可能会用到嵌套命名空间。在那样的情况下，你可能要使用公司的名字作为外部命名空间，
然后公司内部的每个小组各自使用一个内部的命名空间。
下面是个声明嵌套命名空间的例子：
namespace com
{
    namespace cprogramming
    {
        int x;
    }
}
现在x的全名就是com::cprogramming::x。
你这样写：
using namespace com::cprogramming;
来访问该命名空间中的元素。
命名空间是“开放的”，也就是说可以把处于不同文件中的代码放到同一个命名空间中。
举个例子，如果写了个头文件来放一个类，同时把那个类又放到了一个命名空间中：
namespace com
{
    namespace cprogramming
    {
        class MyClass
        {
        public:
            MyClass ();
        };
    }
}
在对应的源文件中，你可以这样写：
#include "MyClass.h" 
 
namespace com
{
    namespace cprogramming
    {
        MyClass::MyClass ()
        {
            // ...
        }
    }
}
两个文件都可以在命名空间中添加代码。你想怎么加就怎么加。
什么时候需要写using namespace
通常，你应该只把使用声明（using namespace）放在cpp文件中，不要放在头文件中。
问题在于每个使用头文件的文件都会受到命名冲突的影响，而每个独立的cpp文件就可以控制它所使用的命名空间。
一般来说，我建议在头文件中使用完整的名称然后只在cpp文件中包含使用命名空间的声明。
对于这一规则也存在着一些广为人知的例外。标准库自己事实上就违 背了它，虽然是因为它有一个说得过去的理由。
如果这样写：
#include <iostream.h>
而不是这样：
#include <iostream>
那么你就不需要再包含一个std的使用声明了。原因是iostream.h的内容基本上就是：
#include <iostream>
using namespace std;
这是为了兼容在命名空间还没有添加到C++ 语言之前写的那些程序， 所以如果你有个这样的程序：
#include <iostream.h>

int main ()
{
    cout << "Hello world";
}
示例代码61：iostream_h.cpp
这段代码在命名空间被加入到标准库之后仍然可以编译成功。
对于新写的代码，我推荐使用新的头文件（没有.h的）这样就不会有命名空间的污染。
在每个文件中加入一句using namespace std;也不会花你太多的时间，而且这样可以让你使用“最新的”C++。
在什么情况下需要创建一个命名空间
一般情况下，如果你要处理的程序仅有几个文件，那么创建自己的命名空间可能就没什么必要。
命名空间实际上是为了在你开始创建有几十个或者数百个处于不同目录下的文件，并且确实已经能看到有命名冲突的时候使用的。
简单的单个文件或者几个文件的程序真的不需要有自己的命名空间。
我建议你在觉得以后会重用到代码或者程序已经大到需要拆分到不同的目录下的时候再开始把代码放到命名空间中。
任何时候代码达到了这种复杂程度，你都应该使用所有可以利用的工具来保证它的条理性。
尽管命名空间在你所学到的C++特性中几乎是无关紧要的一个，但它们在你处理大规模代码库的时候会派上用场。
理解命名空间的作用， 以及别人为什么使用它们，这些会帮助你把他人的代码整合到自己的代码中。
问答题
1 什么情况下需要使用using namespace指令？
A. 在所有头文件中，紧跟着include指令后面
B. 根本不能用，它们是危险的
C. 可以用在任何没有命名空间冲突的cpp文件顶端
D. 在你使用来自那个命名空间的变量之前

C
2.我们何以需要命名空间呢？
A. 为了给编译器的作者增加一些有趣的工作
B. 为代码提供更好的封装
C. 为了阻止大规模代码库中的命名冲突
D. 为了帮助阐明一个类的作用

C
3.在什么情况下应当把代码放到命名空间中？
A. 代码什么时候都应该放在命名空间中
B. 当你在开发一个有超过数十个文件的大规模程序的时候
C. 在你开发一个用来与别人共享的函数库的时候
D. B和C都正确

D
4.为什么不能把使用命名空间的声明放在头文件中？
A. 这么做是非法的
B. 没有理由不放在头文件中，使用的声明只有在头文件中才是合法的
C. 这么做会把使用声明强加给任何包含了这个头文件的人，即使这样会导致冲突
D. 如果多个头文件包含了使用声明就会导致冲突

C
实践题
把你在之前实践题中实现的vector拿出来，然后把它添加到一个命名空间中。

VectorOfInt.h
#pragma once
#ifndef VECTOROFINT_H_
#define VECTOROFINT_H_

namespace WEIYY
{
    namespace JICPP
    {
        class VectorOfInt
        {
        public:
            VectorOfInt();
            VectorOfInt(int initialSize);
            VectorOfInt(const VectorOfInt &other);
            ~VectorOfInt();

            int *GetInt(int index) const;
            void SetInt(int index, int value);

            void PushBack(int value);
            void PushFront(int value);
            void Clear();
            int size() const;

            VectorOfInt &operator=(const VectorOfInt &other);
        private:
            int *_integers;
            int _integersLengthUsed;
            int _integersLength;

            void CopyValues(const VectorOfInt &other);
            static int *growArray(int *p_values, int *size);
        };
    }
}

#endif

VectorOfInt.cpp
#include "VectorOfInt.h"

namespace WEIYY
{
    namespace JICPP
    {
        VectorOfInt::VectorOfInt()
        {
            _integersLength = 32;
            _integersLengthUsed = 0;
            _integers = new int[_integersLength];
        }

        VectorOfInt::VectorOfInt(int initialSize)
        {
            if (initialSize < 32)
            {
                initialSize = 32;
            }
            _integersLength = initialSize;
            _integersLengthUsed = 0;
            _integers = new int[_integersLength];
        }

        VectorOfInt::VectorOfInt(const VectorOfInt &other)
        {
            CopyValues(other);
        }

        VectorOfInt::~VectorOfInt()
        {
            if ( _integers != nullptr )
            {
                delete[] _integers;
            }
        }

        int *VectorOfInt::GetInt(int index) const
        {
            if ( (index < 0) || (index >= _integersLengthUsed) )
            {
                return nullptr;
            }

            return &_integers[index];
        }

        void VectorOfInt::SetInt(int index, int value)
        {
            if ( (index < 0) || (index >= _integersLengthUsed) )
            {
                return;
            }

            _integers[index] = value;
        }

        void VectorOfInt::PushBack(int value)
        {
            if (_integersLengthUsed >= _integersLength)
            {
                _integers = growArray(_integers, &_integersLength);
            }
            _integers[_integersLengthUsed] = value;
            _integersLengthUsed++;
        }

        void VectorOfInt::PushFront(int value)
        {
            if (_integersLengthUsed >= _integersLength)
            {
                _integers = growArray(_integers, &_integersLength);
            }

            for (int i = _integersLengthUsed; i > 0; i--)
            {
                _integers[i] = _integers[i - 1];
            }
            _integers[0] = value;
            _integersLengthUsed++;
        }

        void VectorOfInt::Clear()
        {
            _integersLengthUsed = 0;
        }
        int VectorOfInt::size() const
        {
            return _integersLengthUsed;
        }

        VectorOfInt &VectorOfInt::operator=(const VectorOfInt &other)
        {
            if( this == &other)
            {
                return *this;
            }
            if (_integers != nullptr)
            {
                delete[] _integers;
                _integers = nullptr;
            }

            CopyValues(other);

            return *this;
        }

        void VectorOfInt::CopyValues(const VectorOfInt &other)
        {
            _integersLength = other._integersLength;
            _integers = new int[_integersLength];

            _integersLengthUsed = other._integersLengthUsed;
            for (int i = 0; i < _integersLengthUsed; i++)
            {
                int *value = other.GetInt(i);
                if (value != nullptr)
                {
                    _integers[i] = *value;
                }
            }
        }

        int *VectorOfInt::growArray(int *p_values, int *size)
        {
            *size *= 2;

            int *p_newvalues = new int[*size];
            for (int i = 0; i < *size; i++)
            {
                p_newvalues[i] = p_values[i];
            }

            delete[] p_values;

            return p_newvalues;
        }
    }
}

ch27_p01.cpp
#include <iostream>
#include "VectorOfInt.h"

using namespace std;
using namespace WEIYY;

void print(JICPP::VectorOfInt &vector);

int main()
{
    JICPP::VectorOfInt basicVector;
    for (int i = 0; i < 32; i++)
    {
        basicVector.PushBack(i + 1);
    }
    cout << "Basic Vector\n";
    print(basicVector);

    int vectorSize = 10;
    JICPP::VectorOfInt sizedVector(vectorSize);
    for (int i = 0; i < vectorSize; i++)
    {
        sizedVector.PushBack(i * i);
    }
    cout << "Vector Sized to " << vectorSize << '\n';
    print(sizedVector);

    JICPP::VectorOfInt copiedVector(sizedVector);
    cout << "Copied Vector Upon Initialization from Sized Vector\n";
    print(copiedVector);

    JICPP::VectorOfInt copiedVectorOperator;
    copiedVectorOperator = basicVector;
    cout << "Copied Vector Operator from Basic Vector\n";
    print(copiedVectorOperator);

    int value1 = 50;
    cout << "Adding " << value1 << " to the end of Sized Vector\n";
    sizedVector.PushBack(value1);

    int value2 = -12;
    cout << "Adding " << value2 << " to the end of Sized Vector\n";
    sizedVector.PushBack(value2);
    print(sizedVector);

    int value3 = -666;
    cout << "Adding " << value3 << " to the beginning of Copied Vector\n";
    copiedVector.PushFront(value3);

    int value4 = 999;
    cout << "Adding " << value4 << " to the beginning of Copied Vector\n";
    copiedVector.PushFront(value4);
    print(copiedVector);

    cout << "Clearing Basic Vector\n";
    basicVector.Clear();
    print(basicVector);
}

void print(JICPP::VectorOfInt &vector)
{
    if (vector.size() <= 0)
    {
        cout << "Vector is empty.\n";
        return;
    }
    cout << "Vector Values...\n";
    int *p_value;
    int index = 0;
    while ( ( p_value = vector.GetInt(index) ) != nullptr )
    {
        cout << *p_value << '\n';
        index++;
    }
    cout << '\n';
}
编译命令如下
g++ -o ch27_p01 ch27_p01.cpp VectorOfInt.cpp

显示结果如下
Basic Vector
Vector Values...
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32

Vector Sized to 10
Vector Values...
0
1
4
9
16
25
36
49
64
81

Copied Vector Upon Initialization from Sized Vector
Vector Values...
0
1
4
9
16
25
36
49
64
81

Copied Vector Operator from Basic Vector
Vector Values...
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32

Adding 50 to the end of Sized Vector
Adding -12 to the end of Sized Vector
Vector Values...
0
1
4
9
16
25
36
49
64
81
50
-12

Adding -666 to the beginning of Copied Vector
Adding 999 to the beginning of Copied Vector
Vector Values...
999
-666
0
1
4
9
16
25
36
49
64
81

Clearing Basic Vector
Vector is empty.

第28章 文件I/O
文件如同计算机的命脉――如果没有文件，计算机做的任何工作最终都只能是暂时的，只能持续到用户重启计算机之前，或者应用程序运行终止的时候。
C++天生就具有读写文件的能力。对文件的操作称为文件I/O（I/O表示输入和输出）。
 28.1 文件I/O基础
文件的读写看上去很像使用cout和cin那样。与全局变量cin和cout不同的地方是你必须要声明自己的对象来读写文件。
这就意味着你需要知道具体的数据类型。
为了方便起见，我有时称它们为函数，但是它们确实是对象，我们会去调用它们的方法。
操作文件的两种数据类型是ifstream和ofstream。这两个名称的意思是文件输入流和文件输出流。
流就是一串你可以读取或者写入的数据。 这两个类型所做的工作就是接收一个文件，然后把它转换成一个可以访问的长数据流，
就像是你在与用户进行交互一样。使用它们都需要fstream头文件（fstream代表文件流）。
读取文件
先来讨论如何读取文件。要读取一个文件，我们会使用到ifstream类型。
可以带着一个想要读取的文件名来初始化一个ifsteam实例：
#include <fstream>

using namespace std;

int main ()
{
    ifstream file_reader( "myfile.txt" );
}
示例代码62：ifstream.cpp
这段小程序会去尝试打开myfile.txt文件，它会在程序运行的目录（这 个目录叫做程序的工作目录）下寻找myfile.txt文件。
如果愿意的话， 你也可以给定一个完整的路径，如c:\myfile.txt。
注意我说的是这段程序尝试去打开文件。它所要打开的文件可能并不存在。
你可以通过调用is_open方法来检查创建的ifstream是否成功地打开了一个文件。
#include <fstream>
#include <iostream>

using namespace std;

int main ()
{
    ifstream file_reader( "myfile.txt" );
    if ( ! file_reader.is_open() )
    {
        cout << "Could not open file!" << '\n';
    }
}
示例代码63：ifstream_error_checking.cpp
在操作文件的时候，你必须要写代码来处理可能存在的失败情况，别无选择。
文件可能不存在，或者已经被损坏，又或者正在被系统中的另一个进程使用。
在上述这些情况下，某些文件操作可能会失败。无论何时，只要进行文件操作，你都需要做好失败的准备，
磁盘访问失败，文件是损坏的，突然断电，硬盘分区坏死，所有这些都会导致文件操作失败。
文件一旦打开了，你就可以像使用cin一样来使用一个ifstream。下面的代码从一个文本文件中读取一个数字：
#include <fstream>
#include <iostream>

using namespace std;
int main ()
{
    ifstream file_reader( "myfile.txt" );
    if ( ! file_reader.is_open() )
    {
        cout << "Could not open file!" << '\n';
    }
    int number;
    file_reader >> number;
}
示例代码64：read_file.cpp
就像它在读取用户的输入一样，这行代码会一直从文件中读取数字， 直到它发现一个空格或者别的分隔符。
举个例子，如果文件中有这样的文本：
 12 a b c
那么number变量在程序运行起来之后就会存储12 。
由于是在操作文件，我们需要知道是否有错误发生。
在C++中，检查你是否已经成功地读取到了一个值的方式是去检查执行读取操作的函数的返回值。可以像这样做：
#include <fstream>
#include <iostream>

using namespace std;

int main ()
{
    ifstream file_reader( "myfile.txt" );
    if ( ! file_reader.is_open() )
    {
        cout << "Could not open file!" << '\n';
    }
    int number;
    if ( file_reader >> number )
    {
        cout << "The value is: " << number;
    }
}
示例代码65：read_error_checking.cpp
通过检查调用file_reader >> number的结果，我们会发现读取磁盘介质时产生的问题以及所读取的数据格式导致的问题。
记得前面本书开始的时候我们讨论过当想要一个数字的时候用户却输入了一个字母的情况吗？
这就是你如何去防止那类问题的方法。检查输入例程的返回值，如果返回true，那么一切OK，你可以信任所读取到的数据；
如果返回false，那么就是某个地方出现异常了你需要把它当做错误来处理。
28.2 文件格式
向用户请求输入的时候，你可以告诉用户你想要什么，如果用户给出了错误的输入你可以提供引导，告诉用户怎么修正它。
当从一个文件中读取数据的时候，你可就没有这么舒服的享受了。文件都是已经写好了的，甚至可能在你写程序之前就已经存在了。要把数据读过来你就需要知道文件格式。文件的格式就是文件的布局，虽然它没有必要弄得很复杂。
举个例子，假设有个高分列表，你想要在程序一次一次的运行之间保存它。
简单的文件格式可能就是含有多行，每行有个单独的数字。
一个简单的高分列表可能看上去是这样的：
1000
987
864
766
744
500
453
321
201
98
5
示例文件1：highscores.txt
你可以写个程序来读取这个高分列表：
#include <fstream>
#include <iostream>
#include <vector>

using namespace std;

int main ()
{
    ifstream file_reader( "highscores.txt" );
    if ( ! file_reader.is_open() )
    {
        cout << "Could not open file!" << '\n';
    }
    vector<int> scores;
    for ( int i = 0; i < 10; i++ )
    {
        int score;
        file_reader >> score;
        scores.push_back( score );
    }
}
示例代码66：highscore.cpp
这段代码很简单――它就是打开文件然后一次读入一个分数――实际上，它都不需要依赖被换行符分开的分数――它连空格都可以处理。 
但是这是个实现过程中的意外，不是文件格式的特性。别的处理文件格式的程序可能就不会这么宽容地对待它们所要读入的东西了。
处理文件格式有个好的原则叫做Postel法则，就是“宽进严出”。
换句话说， 生成文件的代码应当小心谨慎地遵循规格说明，但是读取文件格式的代码应当足够强壮来抵抗那些由不是特别优秀的代码所造成的错误。
在上面的示例程序中，我们在接收换行分隔符的同时宽容地接收了空格分隔符。
文件的结束（EOF）
上面这段代码是遵循一个很特别的文件格式而写的，而且你会注意到它根本没有尝试进行错误处理。
比如，假使没有10个条目怎么办，这 段代码不会停止读取文件，哪怕它已经读到了文件的最后。
打个比 方，假如游戏才只被玩过两次，它就还没有10个分数记录，文件中也就没有10个条目。
EOF这个词常用来表示已经到达了文件的最后的状态。
我们可以通过处理文件不足10个条目的情况，来让代码变得健壮（对接收的数据要求宽泛）。
通过再一次地检查用来读取输入的方法的返回值，我们就可以处理不足10条的情况了。
#include <fstream>
#include <iostream>
#include <vector>

using namespace std;

int main ()
{
    ifstream file_reader( "myfile.txt" );
    if ( ! file_reader.is_open() )
    {
        cout << "Could not open file!" << '\n';
    }
    vector<int> scores;
    for ( int i = 0; i < 10; i++ )
    {
        int score;
        if ( ! file_reader >> score )
        {
            break;
        }
        scores.push_back( score );
    }
}
示例代码67：highscore_eof.cpp
当这段代码处理的文件不足10个条目的时候，它在读到文件末尾的时候会立即停止。
通过使用vector而不是用固定长度的数组，我们可以轻松地处理短一点的文件。vector会准确地存储着读进来的东西，没有别的。
如果用数组来完成了同样的工作，我们得需要有变量来存储数组中条目的数量――我们不能假定整个数组都被存储满了。
有些情况下你操作文件的时候，会想要把文件中所有的数据都读进来直到文件结束。
在这样的情况下，你需要能够辨别出由于到达文件末尾而导致的读入失败和由于文件中的错误而导致的读入失败。
eof方法会指示出是否到达了文件的末尾。你可以写个循环来不停地读入数据，检查每次读入的结果，直到出现读入失败。
接着你可以检测eof是不是返回true；如果是的，那么已经读到文件结尾了；如果不是，那就是文件有问题。
你可以通过调用fail方法来检查别的原因导致的失败，如果有非法的输入或者从设备中读取的时候出了问题就会返回true。
一旦你读到了文件的最后，你必须调用clear方法以便执行进一步的文件操作。
我们很快会见到一个使用所有这些方法的例子，就在下面这部分，把一个新的分数写到高分列表。
读取文件和与用户交互还有另一个重要的区别。如果我们改一下高分列表，在分数的基础上再加上玩家的名字会怎样呢？
我读取分数时也要读取玩家的名字――我们得改改代码来处理这个问题。我们老版本的程序将会无法读取新的文件格式。
如果你有很多的用户并且你想要修改文件的格式，那么这就成为主要的麻烦了。
有一些技巧可以为文件格式提供前瞻性，可以添加一些可选的字段或者给老版本的程序加上忽略文件格式中新元素的功能。
但是这些技巧都超出了本书的范围。现在而言，只要明白定义一个文件格式（在某些方面）比定义一个基本接口更加需要慎重。
28.3 写文件
我们写文件要用的数据类型叫做ofstream，表示文件输出系统。这个类型和ifstream几乎是一样的，除了你要像使用cout那样来用它，而不是像使用cin那样。
我们来看个简单的程序，将0到9的值写出到叫做highscores.txt的文件中（我们很快会让这段代码能制造出像一个高分列表的东西）。
#include <fstream>
#include <iostream>

using namespace std;

int main ()
{
    ofstream file_writer( "highscores.txt" );
    if ( ! file_writer.is_open() )
    {
        cout << "Could not open file!" << '\n';
        return 0;
    }

    for ( int i = 0; i < 10; i++ )
    {
        file_writer << 10 - i << '\n';
    }
}
示例代码68：ofstream.cpp
这段代码中就无需担心到达文件末尾的问题了。当你向文件中写入并且写到文件的末尾了，ofstream会为你扩展文件。这叫做向文件进行添加。
新建文件
当你使用ofstream写入一个文件时，默认情况下，如果文件不存在它会创建一个，或者在文件存在的情况下会重写文件。
如果是在保存一个高分列表，你可能不会介意每次去重写文件因为你会写入所有的数据。
但是，如果在维护一个运行日志――比如要保存每次用户打开程序的日期和时间――你肯定不想每次写入都覆盖你的日志。
ofstream构造函数接收第二个参数，它指定了文件应该被如何处理：
ios::app 在原来文件结尾追加新的输出，在每次写入之前把位置设到最后
ios::ate 在原来文件结尾追加新的输出，在打开文件后立即把位置设为最后
ios::trunc 在打开文件后删除原来文件的内容
ios::out 为了输出而打开文件
ios::binary 以二进制模式打开文件

app seek to the end of stream before each write 
ate seek to the end of stream immediately after open 
trunc discard the contents of the stream when opening 
in open for reading 
out open for writing 
binary open in binary mode 

如果你要选择多个选项，比如打开一个文件来添加内容并且使用二进制IO（我们很快会讲到），你可以用 | 把这些操作结合起来。
每个ios::操作都会设置一个位为 true，你可以使用 | 来组合这些操作。
ofstream a_file( "test.txt", ios::app | ios::binary );
这段代码打开文件而不毁坏文件当前的内容，允许把二进制数据写到文件的末尾。
28.4 文件位置
当程序读入一个文件（或者写入一个文件）时，文件I/O的代码需要知道读或者写发生在什么地方。
把它想作屏幕上的光标，它会告诉你下一个输入的字母会出现在什么地方。
对于基本的操作无需担心位置问题――你可以写代码去读取文件的任何地方，或者将数据写入到文件的任何地方。
然而你可以在不做读取操作的情况下在文件中改变位置。在处理存储着复杂数据，如ZIP文件或者PDF文件，
或者你有一个庞大的文件，读取每个字节都会很慢或者不可能读取到每个字节（假设你在实现一个数据库），
这时候移动在文件中的读取位置就很重要了。
事实上一个文件有两个不同的位置――一个代表程序下一个要读取的地方，一个代表着程序下一个要写入的地方。
你可以使用tellg和tellp方法来获取当前的位置。这两个方法给你返回当前读取（g代表get） 和写入（p代表put）的位置。
你也可以在当前位置的基础上移动来设置你在文件中的位置，使用seekp和seekg。
你可能已经从名字上猜到了，在文件中移动叫做seeking。
当在一个文件中搜寻的时候，你会把读的位置或者写位置移动到一个新的地方。
这两个方法接收两个参数，一个是搜寻的距离，一个是搜寻操作的源头。
搜寻的距离是用字节来度量的，而源头则不是你当前的位置、文件的开头就是文件的结尾。
在搜寻操作之 后，你将可以在文件中新的位置开始读取（或者写入）。通过搜寻来改变一个位置对别的位置不会产生影响。
文件中位置的三个标志位：
ios_base::beg 从文件的开始的地方进行搜寻
ios_base::cur 从当前位置开始搜寻
ios_base::end 从文件的末尾开始搜寻
举个例子，要在开始写入之前移动到文件开始的地方，可以这样写：
file_writer.seekp( 0, ios_base::beg );
tellp和tellg的返回值是标准库中定义的一个特殊的类型叫做streampos。它可以与整型进行相互之间的转换，
但是使用streampos，我们能够更加明确地表示该数据的类型。整型可以在任何地方使用，但是streampos意味着有个特殊的目的。
一个streampos类型的变量可以存储文件中的位置和用来搜寻到那些位置。在我们的代码中使用正确的变量类型可以让变量的作用清楚明了。
streampos pos = file_reader.tellg();
在有些情况下，你不会需要在文件中进行搜寻――将一个文件从开始读到最后就足够了。
然而，很多文件的格式为了可以向文件中添加新的数据而做了优化。当你向文件中添加新数据的时候，在文件末尾添加会比插入到文件的中间位置快很多。
向文件中间插入的问题就在于你必须要移动文件中插入点之后所有的东西――就像在数组的中间插入一个元素一样。
有一个特殊情况：如果相同长度的新数据来覆盖已有的数据，你就不需要移动什么，这就和写在文件的末尾速度一样快。
来修改之前的读取高分的程序，让它可以在文件中添加新的高分。为 了让它更有趣，我们会把值插入到文件中正确的地方。
要实现这个，我们需要能够读和写文件，所以将会使用fstream类，它同时允许读和写的操作。就把它想作ofstream和ifstream缠绵在一起吧。
首先我们将从用户那里读入一个新的高分，然后会读入文件中的每一行，直到发现一个低于前面输入的分数。这儿就是要插入新分数的地方。
我们会保存这个位置，将文件中剩余的行都读入到一个vector中，然后再回到这个地址。
写出新的分数，接着再把剩余的分数写回到文件中，替换掉原先在那里的一行行数据。
由于使用的是fstream，我们会得到能够同时读和写的所有好处，但是现在需要明确地告诉构造函数同时以读和写的目的去打开文件。我们会使用标志位ios::in|ios::out标明。在运行程序之前需要创建一个高分列表文件；这里的程序不会为你创建一个空文件。
#include <fstream>
#include <iostream>
#include <vector>

using namespace std;

int main ()
{
    fstream file ( "highscores.txt", ios::in | ios::out );
    if ( ! file.is_open() )
    {
        cout << "Could not open file!" << '\n';
        return 0;
    }
    int new_high_score;
    cout << "Enter a new high score: ";
    cin >> new_high_score;

    streampos pre_score_pos = file.tellg();
    int cur_score;
    while ( file >> cur_score )
    {
        if ( cur_score < new_high_score )
        {
            break;
        }
        pre_score_pos = file.tellg();
    }

    if ( ! file.eof() && file.fail()  )
    {
        cout << "Bad score, could not read, exit\n";
        return 0;
    }

    file.clear();

    file.seekg( pre_score_pos );

    vector<int> scores;
    while ( file >> cur_score )
    {
        scores.push_back( cur_score );
    }
    if ( ! file.eof() && file.fail()  )
    {
        cout << "Bad score, could not read, exit\n";
        return 0;
    }

    file.clear();

    file.seekp( pre_score_pos );
    if ( pre_score_pos != 0 )
    {
        file << endl;
    }
    file << new_high_score << endl;
    for ( vector<int>::iterator itr = scores.begin(); itr != scores.end(); ++itr )
    {
        file << *itr << endl;
    }
}
示例代码69：file_position.cpp
编译命令如下
g++ -o file_position file_position.cpp

显示结果如下
最开始的highscores.txt
cat highscores.txt
10
9
8
7
6
5
4
3
2
1


Enter a new high score: 66
第一次运行程序后的highscores.txt
cat highscores.txt
66
10
9
8
7
6
5
4
3
2
1

Enter a new high score: -66
第二次运行程序后的highscores.txt
cat highscores.txt
66
10
9
8
7
6
5
4
3
2
1
-66

Enter a new high score: 0
第三次运行程序后的highscores.txt
cat highscores.txt
66
10
9
8
7
6
5
4
3
2
1
0
-66

Enter a new high score: 33
第四次运行程序后的highscores.txt
cat highscores.txt
66
33
10
9
8
7
6
5
4
3
2
1
0
-66

28.5 接受命令行参数
当写文件交互的程序时，你通常想让用户提供文件名作为命令行的一个参数。
这么做通常会让程序更好用，并且让写脚本来调用你的程序也变得更简单。
我们先短暂地暂停一下研究文件的读写，这样就可以利用命令行参数的特性让程序更漂亮。
命令行参数在程序的名称之后给出并且是由操作系统传递给程序：
C:\my_program\my_program.exe arg1 arg2
命令行参数直接被传递到主函数中――要使用命令行参数，你必须提供完整的主函数声明（之前我们看到的所有主函数都只有空的参数列表）。
实际上，主函数接收两个参数：一个参数是命令行参数的个数，另一个参数是所有命令行参数的一个完整列表。
主函数完整的声明像这样：
int main (int argc, char *argv[])
整型的argc是参数的个数。它是从命令行传递给程序的参数个数，包括了程序名称。
你也许想知道为什么不需要在每个程序中都包含这些参数；答案很简单，如果你不把它们加进来，编译器就会忽略它们被传递到程序中的事实。
字符指针数组是所有参数的列表。argv[0]是程序的名称，或者是个空字符串如果程序名不可用的话。
在它之后，每个比arc小的元素都是个命令行参数。你可以把每个argv元素就像字符串一样使用。argv[argc]是个空指针。
来看一个示例程序，它接收一个命令行参数――在这个例子中，程序接收一个文件名然后把整个的文本输出到屏幕上。
#include <fstream>
#include <iostream>

using namespace std;

int main (int argc, char *argv[])
{

    if ( argc != 2 )
    {
        cout << "usage: " << argv[ 0 ] << " <filename>" << endl;
    }
    else
    {
        ifstream the_file( argv[ 1 ] );
        if ( ! the_file.is_open() )
        {
            cout << "Could not open file " << argv[ 1 ] << endl;
            return 1;
        }
        char x;
        while ( the_file.get( x ) )
        {
            cout << x;
        }
    }
}
示例代码70：catfile.cpp
编译命令如下
g++ -o catfile catfile.cpp


第一次运行程序
catfile
usage: catfile <filename>

第二次运行程序
catfile highscores.txt
66
33
10
9
8
7
6
5
4
3
2
1
0
-66

这段程序使用完整的主函数声明以便使用命令行参数。首先它会检查确保用户提供了一个文件名。然后程序试着打开它来看看文件是否合法。
如果文件是合法的，那么它就是被打开的――如果不是，程序向用户报告一个错误。如果文件成功打开了，那么它就会把文件的每个字符输出到屏幕上。
处理数字命令行参数
如果希望接收一个命令行参数并且把它作为一个数字来使用，你可以通过把它作为一个字符串读入接着调用atoi函数（atoi代表 ASCII转换到整型）。
atoi函数接收一个char*然后返回该字符串所表示的整型，要使用它你必须包含cstdlib头文件。
举个例子，下面的程序读入一个命令行参数，把它转换成一个数字，并且输出那个数字的平方：
#include <cstdlib>
#include <iostream>

using namespace std;

int main (int argc, char *argv[])
{
    if ( argc != 2 )
    {
        cout << "usage: " << argv[ 0 ] << " <number>" << endl;
    }
    else
    {
        int val = atoi(argv[1]);
        cout << val *val;
    }
    return 0;
}
示例代码71：atoi.cpp
编译命令如下
g++ -o atoi atoi.cpp

第一次运行程序
atoi
usage: atoi <number>

第二次运行程序
atoi 3
9

28.6 二进制文件I/O
到目前为止我们已经学过如何去处理含有文本数据的文件；现在把注意力转向处理二进制文件，我们经常为了追求最高效率而去使用二进制文件。
二进制文件需要不同于文本文件的编程技术。现在，不要被迷惑――系统中任何一个文件都是以二进制的形式存储的。
但是在很多情况下，文件是以一种用户可以阅读的方式来写入的。举个例子， C++源文件全部都是由基本的编辑器就可以阅读的字符组成的。
这种文件，它的每个字节都是可阅读字符的一部分，这就叫做文本文件。
然而，不是所有的文件都仅仅包含文本。有些文件是由无法输出字符的字节组成的。
取而代之的是，这些文件只是由一个或者多个结构体直接写到磁盘上的二进制数据。
举个例子，假设有个代表运动员的结构体：
struct player
{
    int age;
    int high_score;
    string name;
};
如果要把这个结构体写入到一个文件中，关于如何去做你有两个选择。
首先，可以以文本字段的形式来记录年龄和最高分，把它们和姓名放在一起，这样文件就可以在记事本中打开。它看上去可能像这样：
19     120000     Tom
这种表示方法使用了6个字符来代表最高分。我们已经学过，一个字符需要1字节来存储，这就意味着存储最高分会占用6字节。
但是最高分是个整型，而一个整型通常只有4字节（在32位操作系统上），所以不是应该只用4字节来存储它吗？你说对了！
但是如果只使用4字节去写数字，我们就不能在文本编辑器中打开这个文件去看它到底是什么数字了。为什么呢？
因为在以字符串的形式把120000写入文件的时候，它通过编码使每个字符占用1字节来存储实际的数字为字符的形式。
在你把数字直接写入文件时，那些字节根本没有被编码成字符。 所以你现在有4字节组成的整型写入到文件中了。
如果文本编辑器去读取这个文件，它会把那4字节当做4字符来对待，但是它输出的字符和我们所要展示的数字没有任何关系！
打开的结果也会毫无意义因为我们是在以不同的方式为文件编码。
二进制文件格式占用更少的空间。在上面的例子中，我们看到以字符存储120000比使用二进制表示多占用50%的空间。
你能够想象到，如果在通过网络传输数据或者硬盘不是很快或者足够大的话，这会产生很大的影响。
另一方面，二进制文件不易于阅读和理解――你不能简单地在文本编辑器中打开一个二进制文件去看它里面是什么数据。
文件格式的设计者面临着创造高效的格式与创建任何人都可以理解并易于修改的文件格式，要这两者之间取平衡点。
基于文本的标记性语言如XML通常用来创建占用更多空间，但是非常易于人们理解的文件格式。
在存储空间有限，处理器足够快速时，可以使用像ZIP这样的压缩技术来减少存储文本文件所需要的空间。
由于解压一个文件很容易，这些文件仍然是方便处理的，同时比没有压缩过的文本文件小了很多。
尽管如此，二进制文件还是很常见的――很多已有的文件格式就是二进制的，而且很多文件格式真的必须是二进制的，
任何存储图像， 视频或者音频的文件都不具备有意义的，精确的文本表示。而且在需要追求最大性能或者节省空间时，二进制文件仍然会胜出。
举个例子，在Office2007中微软引入了新的文件格式，基于ZIP内部的XML文 件。但是他们也在Excel（.xlsb）中添加了一种二进制格式，为了方便那些追求最大性能的用户。
换句话说，二进制文件就在这里，在任何需要设计一个文件格式的时候，你都必须评估更简单的实现和表示 （基于文本的格式）与性能和大小（二进制格式）之间的平衡。
所以，你也许会问，到底怎么去处理一个二进制文件呢？
28.6.1 处理二进制文件
第一步就是以二进制模式打开一个文件：
ofstream a_file( "test.bin", ios::binary );
一旦文件打开了，你不能使用前面用的输入输出函数――要使用专门处理二进制数据的函数。
我们需要直接把一块内存中的字节写入到文件中。我们将要使用的方法叫做write，它接收一个指向一块内存的指针和要写入到文件中的内存的大小。
指针的类型是char*，但是你的数据不必须是字符。
为了把一个整型写入到文件中，你得把它当做一系列字节，也就是char*，并且把这个指针传递给将来自内存的字节直接写入到文件中的方法。
为了实现这个功 能，write方法会把字符一个一个写出，每个字节，按顺序一个接一 个。例如，假设你有个数字255。在内存中，它会以字节0xFF来表示 （十六进制的255）。如果有个整型变量存储着0xFF的字节，在内存中它会是这样的：
0x000000FF
或者，一字节一字节地，
 00 00 00 FF
要把一个整型写入文件中，我们需要一个直接引用这一系列字节的方式。这就是使用一个char*的原因：这不是因为它可以代表ASCII；是因为它可以处理字节。
我们还将需要有一个方式来告诉编译器它应该像对待一个字符数组一样对待我们的数据。
28.6.2 转换到char*
那么我们怎么告诉编译器把一个变量当做指向字符的指针，而不是指向它真正类型的指针呢？
要求编译器以不同的类型来处理一个变量叫做类型转换。类型转换告诉编译器――“不，说真的，我知道自己在干什么；我真的想以这种方式使用这个变量”。
我们想要把一个变量当做 一系列单独的字节来处理，所以需要使用一个转换来强制编译器支持访问每个字节。
两个最基本的类型转换是static_cast和reinterpret_cast。static_cast是你想要在相关的类型之间做转换时使用的。
举个例子，告诉编译器把双精度型当做整型来处理这样你就可以截取它――比如static_cast<int>(3.4)。
要被转换成的类型在尖括号内给出，跟在转换方法的名字后面。
尽管在这个例子中，我们想要完全忽略类型系统并且让编译器用一个完全不相干的类型来重新解释一系列的字节。
要完成这个操作，我 们需要reinterpret_cast。举个例子，把一个整型数组当做字符数组来用，可以这么写：
int x[ 10 ];
reinterpret_cast<char*>( x );
顺便说一下，处理二进制数据是少数几个合理使用reinterpret_cast的地方。无论何时你见到reinterpret_cast的时候，要带着怀疑的态度！ 
这是让编译器去做它正常情况下不做的事的一个强大的方式，并且， 作为结果，编译器不会像检查别的代码那样去仔细地检查使用强制转换的代码。
在这个特别的例子中，我们确实需要得到1字节序列的内存，所以这就是我们想要的；但是如果那不是你的意图，使用reinterpret_cast就不是个好的主意了。
28.6.3 二进制I/O的一个例子
最后，我们终于可以展示二进制输入输出了！这个示例代码填充一个数组然后把它写到文件中。
它使用我们之前见过的write方法，接收一 个char*作为源数据，还有从那个源写出的数据的大小。
在这个例子中，源是数组，数组的大小就是数组的字节长度。
int nums[ 10 ];

for ( int i = 0; i < 10; i++ )
{
    nums[ i ] = i;
}
a_file.write( reinterpret_cast<char *>( nums ), sizeof( nums ) );
以一个整型数组开始，但是通过把它转换成一个char*，它会简单地被当做字节数组来处理，这个字节数组会直接被写到磁盘上。
当我们之后再读入这些字节的时候，内存里就正好是同样的字节集合，并且可以把这段内存重新转换成整型来获取和原来一样的数值。
注意，要写入的大小是以sizeof操作符来提供的。sizeof命令在获取一个特定变量的大小时很有用。在这个例子中，它返回组成数组nums的所有字节数。
尽管如此，在对指针使用sizeof的时候还是要小心。当给它一个指 针，它会给你指针的大小，而不是指针所指向的内存的大小。
上面的代码可以正常工作是因为nums是被声明为数组而不是指针，而sizeof知道整个数组的大小。
如果有个指针变量int *p_num，这个变量的大小是（通常情况下）4字节，因为保存一个地址只需要这么多。
如果你想得到所指向的东西的大小，你可以写sizeof(*p_num)。在这里，结果会和sizeof(int)一样。
如果指针指向一个数组（如果你写 了int *p_num = new int[length]），可以这样去获取总的大小：sizeof(*p_num)*length。
你还可以使用write方法直接把一个结构体写到文件中去。例如，假设有这么个结构体：
struct PlayerRecord
{
    int age;
    int score;
};
你可以简单地创建一个PlayerRecord的实例，然后把它写入到文件中：
struct PlayerRecord
{
    int age;
    int score;
};

PlayerRecord rec;
rec.age = 10;
rec.score = 890;

a_file.write( reinterpret_cast<char *>( & rec ), sizeof( rec ) )
注意，在这个示例中我们获取了rec的地址，为的是传入指向结构体的指针。
28.6.4 把类存储到文件中
如果想要在结构体中添加一个非基础的数据类型呢？举个例子，我们 在结构体中加入一个字符串会怎样呢？
struct PlayerRecord
{
    int age;
    int score;
    string name;
};
在这个例子中，我们简单地以字符串的形式将运动员的名字添加到结构体中。
但是如果要把它写入到文件中去，在写到字符串的时候会发 生什么？
它会把存储在字符串中的信息写出去――但是可能写的不是字符串本身的内容。
字符串类型是以指向一个字符串的指针来实现的（可能和一些别的数据一起，比如字符串的长度）。
在我们以二进制数据的形式写出结构体的时候，它会直接写出字符串中存储的东西――指针和长度。
但是指针只有程序在运行的时候才有意义！指针本身的值――内存地址，一旦程序退出以后就没用了。
因为那个地址已经没有任何东西了。 下一次有人读入这个结构体，它会得到一个指向没有正确分配内存的指针，
或者指向与我们的字符串毫无关系的数据。
我们需要想出一个固定的，定义良好的格式来在磁盘上表示二进制数据，而不是盲目地将结构体本身直接写到磁盘上。
我们的格式是写出字符串里面的字符和字符串的大小（需要大小的原因很快就会清楚）。来看看那会是什么样子。
PlayerRecord rec;
rec.age = 11;
rec.score = 200;
rec.name = "John";

fstream a_file( "records.bin", ios::trunc | ios::binary | ios::in | ios::out );

a_file.write( reinterpret_cast<char *>( & rec.age ), sizeof( rec.age ) );
a_file.write( reinterpret_cast<char *>( & rec.score ), sizeof( rec.score ) );
int len = rec.name.length();
a_file.write( reinterpret_cast<char *>( & len ), sizeof( len ) );
a_file.write( rec.name.c_str(), len + 1 );

首先，注意到使用c_str方法来获取内存中字符串的指针，而不是在内存中没有确定的布局的字符串对象本身。
如果字符串是“abc”，那么调用c_str会给你一个带有字母“abc”的字符序列的地址。
字符串会以一个 值为0的字符结尾；这个值为0的字符叫做空结束符，并且它标示着字符串的结尾。
这种格式的字符串叫做C字符串，因为在C语言中C字符串是全局都可用的字符串格式。
有时你会看到空结束符写作'\0'。这完全是正确的写法。0和'\0'之 间的区别就在于'\0'本来的类型就是字符，
而0则是将要被转换成字符的整型。在我们这里，两者都可以。
我们把字符数据写入到二进制文件中是没有问题的；就算是在写入字符到文件中，这仍然是在写二进制数据，
仅仅是碰巧二进制数据同时也是人类可读的。
文件格式是数据的一种表示方式；结构体是数据的另外一种表示方式。
两者存储着同样的数据，但是内存中的结构体的格式没有必要和文件中的数据格式一模一样。
28.6.5 读取二进制文件
要读入一个二进制文件，我们会使用read方法。read方法的参数几乎和write方法是一样的：
一个存放数据的地方以及要读取的数据量。要从文件中读取一个整数，可以这样写代码：
int x = 3;
a_file.write( reinterpret_cast<char*>( & x ), sizeof( x ) );

int y;
a_file.read( reinterpret_cast<char*>( & y ), sizeof( y ) );
有个值得注意的是传入write的指针可能是一个指向const对象的指针。
这种情况下， 你需要使用reinterpret_cast<const char*>（注意const在类型转换中）。
在处理文件的时候，你需要有一些方式同时写入和读取各种想要存储在文件中的数据结构。
我们来看看如何读取一个PlayerRecord。
首先， 我们从简单的开始，重置文件位置，接着读入直接写到磁盘而没有修改过格式的age和score字段。
a_file.seekg( 0, ios::beg );
PlayerRecord in_rec;
if ( ! a_file.read( reinterpret_cast<char *>( & in_rec.age ), sizeof( in_rec.age ) ) )
{
    // handle error
}
if ( ! a_file.read( reinterpret_cast<char *>( & in_rec.score ), sizeof( in_rec.score ) ) )
{
    // handle error
}
那么读入字符串又是什么情况呢？我们必须先读入字符串的长度，然后根据读入的长度创建一个新的字符串。
int str_len;
if ( ! a_file.read( reinterpret_cast<char *>( & str_len ), sizeof( str_len ) ) )
{
    // handle error
}
else if ( str_len > 0 && str_len < 10000 )
{
    char *p_str_buf = new char[ str_len ];
    if ( ! a_file.read( p_str_buf, str_len + 1 ) )
    {
        // handle error
    }
    if ( p_str_buf[ str_len ] == 0 )
    {
        in_rec.name = string( p_str_buf );
    }
    delete p_str_buf;
}
cout << in_rec.age << " " << in_rec.score << " " << in_rec.name << endl;
现在知道为什么要存储字符串的长度了吧：我们需要知道存储char*要分配多少空间。
我们会读入字符串的长度，然后为它分配内存，最后会把字符串读入到这段内存中。
下面这个完整的可以正常运行的程序由你来做验证：
#include <fstream>
#include <iostream>
#include <string>

using namespace std;

struct PlayerRecord
{
    int age;
    int score;
    string name;
};

int main ()
{
    PlayerRecord rec;
    rec.age = 11;
    rec.score = 200;
    rec.name = "John";

    fstream a_file( "records.bin", ios::trunc | ios::binary | ios::in | ios::out );

    a_file.write( reinterpret_cast<char *>( & rec.age ), sizeof( rec.age ) );
    a_file.write(reinterpret_cast<char *>(  & rec.score ), sizeof( rec.score ) );

    int len = rec.name.length();
    a_file.write(reinterpret_cast<char *>( & len ), sizeof( len ) );
    a_file.write( rec.name.c_str(), rec.name.length() + 1 );

    PlayerRecord in_rec;

    a_file.seekg( 0, ios::beg );
    if ( ! a_file.read( reinterpret_cast<char *>( & in_rec.age ), sizeof( in_rec.age ) ) )
    {
        cout << "Error reading from file" << endl;
        return 1;
    }
    if ( ! a_file.read( reinterpret_cast<char *>(& in_rec.score ), sizeof( in_rec.score ) ) )
    {
        cout << "Error reading from file" << endl;
        return 1;
    }

    int str_len;
    if ( ! a_file.read( reinterpret_cast<char *>( & str_len ), sizeof( str_len ) ) )
    {
        cout << "Error reading from file" << endl;
        return 1;
    }

    if ( str_len > 0 && str_len < 10000 )
    {
        char *p_str_buf = new char[ str_len + 1];
        if ( ! a_file.read( p_str_buf, str_len + 1 ) )
        {
            delete p_str_buf;
            cout << "Error reading from file" << endl;
            return 1;
        }
        if ( p_str_buf[ str_len ] == 0 )
        {
            in_rec.name = string( p_str_buf );
        }
        delete p_str_buf;
    }
    cout << in_rec.age << " " << in_rec.score << " " << in_rec.name << endl;
}
示例代码72：binaryfile.cpp
编译命令如下
g++ -o binaryfile binaryfile.cpp

运行程序binaryfile

显示结果如下
11 200 John

你运行了这段程序之后，试试在记事本或者别的文本编辑器中打开生成的文件。
你可以读到姓名John，因为它是以字符串来存储的，但是除此之外的都没有意义。
问答题
1.哪个数据类型可以用来读取文件？
A. ifstream
B. ofstream
C. fstream
D. A 和 C

D
2.下列哪句是正确的？
A. 文本文件比二进制文件占用更少的内存空间
B. 二进制文件更易于调试
C. 二进制文件比文本文件更节省空间
D. 文本文件太慢了，不能在真实的程序中使用

C
3.在写入二进制文件的时候，为什么不能传入一个指向字符串对象的指针？
A. 你每次都要传入一个char*到write方法中
B. 内存中可能没有保存字符串对象
C. 我们不知道字符串对象的布局，它可能含有会被写入到文件中的指针
D. 字符串太大了必须一点一点地写入

C
4.下列关于文件格式哪个是正确的？
A. 文件格式和别的输入一样易于修改
B. 修改文件格式需要考虑旧版本的程序读取文件时会发生什么事
C. 设置文件格式时需要考虑新版本的程序打开旧版本的文件会发生什么事
D. B 和 C

D
实践题
1.重新实现插入分数到正确的位置的最高分程序，但是使用二进制文件格式而不是文本文件格式。
你如何辨别程序是正常工作的呢？额外创建一个文本文件对应二进制文件。

#include <fstream>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

vector<int> readBinaryFile(string fileName);
vector<int> readTextFile(string fileName);
int writeBinaryFile(string fileName, const vector<int> &scores);
int writeTextFile(string fileName, const vector<int> &scores);
int insertBinaryFile(string fileName);
void print(const vector<int> &scores);

int main()
{
    string fileName = "highScores";
    cout << "Writing base file " << fileName << '\n';
    vector<int> scores
    {
        1000,
        987,
        864,
        766,
        744,
        500,
        453,
        321,
        201,
        98,
        5
    };
    writeTextFile(fileName, scores);
    writeBinaryFile(fileName, scores);
    print(scores);

    if (insertBinaryFile(fileName) != 0)
    {
        cout << "Error inserting into binary file. Program will exit...\n";
        return 1;
    }

    vector<int> newScores = readBinaryFile(fileName);
    writeTextFile(fileName, newScores);
    print(newScores);
}

vector<int> readBinaryFile(string fileName)
{
    cout << "Opening binary file " << fileName << '\n';
    ifstream aFile(fileName + ".bin", ios::binary);
    if (!aFile.is_open())
    {
        cout << "Could not open file!" << '\n';
        vector<int> scoresEmpty;
        return scoresEmpty;
    }
    else
    {
        cout << "File is opened!\n";
    }

    cout << "Reading file...\n";

    int numberOfScores;
    if( !aFile.read( reinterpret_cast<char *>(&numberOfScores), sizeof(numberOfScores) ) )
    {
        cout << "Error reading from file." << endl;
        vector<int> scoresEmpty;
        return scoresEmpty;
    }

    vector<int> scores(numberOfScores);
    aFile.read( reinterpret_cast<char *>(&scores[0]), numberOfScores * sizeof(int) );

    return scores;
}

vector<int> readTextFile(string fileName)
{
    cout << "Opening text file " << fileName << '\n';
    ifstream fileReader(fileName + ".txt");
    if (!fileReader.is_open())
    {
        cout << "Could not open file!" << '\n';
        vector<int> scoresEmpty;
        return scoresEmpty;
    }
    else
    {
        cout << "File is opened!\n";
    }

    cout << "Reading file...\n";
    vector<int> scores;
    int score;
    while (fileReader >> score)
    {
        scores.push_back(score);
    }

    return scores;
}

int writeBinaryFile(string fileName, const vector<int> &scores)
{
    if (scores.size() <= 0)
    {
        cout << "Vector is empty.\n";
        return 0;
    }
    cout << "Writing file to binary format..." << '\n';
    ofstream aFile(fileName + ".bin", ios::trunc | ios::binary );
    if (!aFile.is_open())
    {
        cout << "Could not open file!" << '\n';
        return 1;
    }

    int numberOfScores = scores.size();
    if ( !aFile.write( reinterpret_cast<char *>(&numberOfScores), sizeof(numberOfScores) ) )
    {
            cout << "Error writing to file." << endl;
            return 1;
    }
    aFile.write( reinterpret_cast<const char *>(&scores[0]), numberOfScores * sizeof(int) );

    return 0;
}

int writeTextFile(string fileName, const vector<int> &scores)
{
    if (scores.size() <= 0)
    {
        cout << "Vector is empty.\n";
        return 0;
    }
    cout << "Writing file to text format..." << '\n';
    ofstream fileWriter(fileName + ".txt", ios::trunc);
    if (!fileWriter.is_open())
    {
        cout << "Could not open file!" << '\n';
        return 1;
    }

    for (vector<int>::const_iterator itr = scores.begin(), end = scores.end(); itr != end; ++itr)
    {
        fileWriter << *itr << '\n';
    }

    return 0;
}

int insertBinaryFile(string fileName)
{
    cout << "Inserting data into binary file..." << '\n';
    fstream aFile(fileName + ".bin", ios::binary | ios::out | ios::in);

    if (!aFile.is_open())
    {
        cout << "Could not open file!" << '\n';
        return 1;
    }

    int newHighScore;
    cout << "Enter a new high score: ";
    cin >> newHighScore;

    int numberOfScores;
    if ( !aFile.read( reinterpret_cast<char *>(&numberOfScores), sizeof(numberOfScores) ) )
    {
        cout << "Error reading from file." << endl;
        return 1;
    }

    streampos preScorePosition = aFile.tellg();
    int currentScore = 0;
    while ( aFile.read( reinterpret_cast<char *>(&currentScore), sizeof(currentScore) ) )
    {
        if (currentScore < newHighScore)
        {
            break;
        }
        preScorePosition = aFile.tellg();
    }

    if ( !aFile.eof() && aFile.fail() )
    {
        cout << "Bad score, could not read, exit.\n";
        return 1;
    }

    aFile.clear();

    aFile.seekg(preScorePosition);

    vector<int> scores;
    while ( aFile.read( reinterpret_cast<char *>(&currentScore), sizeof(currentScore) ) )
    {
        scores.push_back(currentScore);
    }

    if ( !aFile.eof() && aFile.fail() )
    {
        cout << "Bad score, could not read, exit.\n";
        return 1;
    }

    aFile.clear();

    aFile.seekp(preScorePosition);

    aFile.write( reinterpret_cast<char *>(&newHighScore), sizeof(newHighScore) );
    if (scores.size() > 0)
    {
        aFile.write( reinterpret_cast<char *>(&scores[0]), scores.size() * sizeof(int) );
    }

    numberOfScores++;
    aFile.seekp(0, ios_base::beg);
    if ( !aFile.write( reinterpret_cast<char *>(&numberOfScores), sizeof(numberOfScores) ) )
    {
            cout << "Error writing to file." << endl;
            return 1;
    }

    return 0;
}

void print(const vector<int> &scores)
{

    cout << "File contents are: \n";
    for (vector<int>::const_iterator itr = scores.begin(), end = scores.end(); itr != end; ++itr)
    {
        cout << *itr << '\n';
    }
}
显示结果如下
Writing base file highScores
Writing file to text format...
Writing file to binary format...
File contents are:
1000
987
864
766
744
500
453
321
201
98
5
Inserting data into binary file...
Enter a new high score: 888
Opening binary file highScores
File is opened!
Reading file...
Writing file to text format...
File contents are:
1000
987
888
864
766
744
500
453
321
201
98
5

cat highScores.txt
1000
987
888
864
766
744
500
453
321
201
98
5

2.修改你在第19章中实现的HTML解析器，让它能够从磁盘上的文件读取数据。

#include <fstream>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

string readHTMLFileAsStream(string fileName);
int writeHTMLFile(string fileName, const vector<string> &lines);

void print(const vector<string> &input);
vector<string> parseHTMLStringToVector(const string &htmlDOMStream);
vector<string> mergeChildElements(const vector<string> &input, const string &tagName);
vector<string> stripTag(const vector<string> &input, const string &tagName);
vector<string> stripTagAttributes(const vector<string> &input, const string &tagName);
vector<string> stripText(const vector<string> &input, const string &tagName);
vector<string> substituteTag(const vector<string> &input, const string &tagName, const string &tagNameSubstitute);
vector<string> formatBold(const vector<string> &input);
vector<string> formatItalic(const vector<string> &input);
vector<string> formatHyperlink(const vector<string> &input);
string getLinkURL(const string &hrefTag);

const string openTagStart = "<";
const string closeTagStart = "</";
const string tagEnd = ">";

int main()
{
    string fileName = "sampleHTML";
    string htmlDOMStream = readHTMLFileAsStream(fileName);

    vector<string> htmlDOM = parseHTMLStringToVector(htmlDOMStream);
    const string body = "body";

    cout << "Original HTML: \n";
    vector<string> htmlDOMPrint = mergeChildElements(htmlDOM, body);
    print(htmlDOMPrint);

    const string html = "html";
    htmlDOM = stripTag(htmlDOM, html);

    const string head = "head";
    htmlDOM = stripText(htmlDOM, head);

    htmlDOM = stripTagAttributes(htmlDOM, body);
    htmlDOM = formatBold(htmlDOM);
    htmlDOM = formatItalic(htmlDOM);
    htmlDOM = formatHyperlink(htmlDOM);

    cout << "Parsed HTML:\n";
    htmlDOMPrint = mergeChildElements(htmlDOM, body);
    print(htmlDOMPrint);

    string newFileName = fileName + "_parsed";
    writeHTMLFile(newFileName, htmlDOMPrint);
}

string readHTMLFileAsStream(string fileName)
{
    string stream;

    cout << "Opening HTML file " << fileName << '\n';
    ifstream fileReader(fileName + ".html");
    if (!fileReader.is_open())
    {
        cout << "Could not open file!" << '\n';
        return stream;
    }
    else
    {
        cout << "File is opened!\n";
    }

    cout << "Reading file...\n";
    string line;
    while (getline(fileReader, line, '\n'))
    {
        stream += line;
    }

    return stream;
}

int writeHTMLFile(string fileName, const vector<string> &lines)
{
    cout << "Writing file to HTML format..." << '\n';
    ofstream fileWriter(fileName + ".html");
    if (!fileWriter.is_open())
    {
        cout << "Could not open file!" << '\n';
        return 1;
    }

    for (vector<string>::const_iterator itr = lines.begin(), end = lines.end(); itr != end; ++itr)
    {
        fileWriter << *itr << '\n';
    }
    return 0;
}

void print(const vector<string> &input)
{
    for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
    {
        cout << *itr << endl;
    }
    cout << '\n';
}

vector<string> mergeChildElements(const vector<string> &input, const string &tagName)
{
    string openingTag = openTagStart + tagName;
    string closingTag = closeTagStart + tagName + tagEnd;
    bool isInMergeRegion = false;

    vector<string> output;
    string currentMerge = "";
    for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
    {
        string itrOpening = itr->substr(0, openingTag.length());
        if (itrOpening == openingTag)
        {
            isInMergeRegion = true;
            output.push_back(*itr);
        }
        else if (isInMergeRegion && *itr == closingTag)
        {
            isInMergeRegion = false;
            if (currentMerge != "")
            {
                output.push_back(currentMerge);
            }
            output.push_back(*itr);
        }
        else if (isInMergeRegion)
        {
            currentMerge += *itr;
        }
        else
        {
            output.push_back(*itr);
        }
    }
    return output;
}

vector<string> parseHTMLStringToVector(const string &htmlDOMStream)
{
    bool isInOpenTag = false;
    bool isInCloseTag = false;

    vector<string> htmlDOM;
    string currentEntry = "";

    for (int i = 0; i < htmlDOMStream.length(); i++)
    {
        string currentLetter(1, htmlDOMStream[i]);

        string previousLetter = "";
        if (i - 1 >= 0)
        {
            previousLetter.push_back(htmlDOMStream[i - 1]);
        }

        string nextLetter = "";
        if (i + 1 < htmlDOMStream.length())
        {
            nextLetter.push_back(htmlDOMStream[i + 1]);
        }

        if (currentLetter + nextLetter == closeTagStart)
        {
            isInCloseTag = true;
            if (currentEntry != "")
            {
                htmlDOM.push_back(currentEntry);
            }
            currentEntry = htmlDOMStream[i];
        }
        else if(currentLetter == openTagStart)
        {
            isInOpenTag = true;
            if (currentEntry != "")
            {
                htmlDOM.push_back(currentEntry);
            }
            currentEntry = htmlDOMStream[i];
        }
        else if (isInOpenTag && previousLetter == tagEnd)
        {
            isInOpenTag = false;
            if (currentEntry != "")
            {
                htmlDOM.push_back(currentEntry);
            }
            currentEntry = htmlDOMStream[i];
        }
        else if (isInCloseTag && currentLetter == tagEnd)
        {
            isInCloseTag = false;
            currentEntry += htmlDOMStream[i];
            if (currentEntry != "")
            {
                htmlDOM.push_back(currentEntry);
            }
            currentEntry = "";
        }
        else
        {
            currentEntry += htmlDOMStream[i];
        }
    }
    return htmlDOM;
}

vector<string> stripTag(const vector<string> &input, const string &tagName)
{
    string openingTag = openTagStart + tagName;
    string closingTag = closeTagStart + tagName + tagEnd;
    bool isInStripRegion = false;

    vector<string> output;
    for(vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
    {
        string itrOpening = itr->substr(0, openingTag.length());
        if (!isInStripRegion && itrOpening == openingTag)
        {
            isInStripRegion = true;
        }
        else if (isInStripRegion && *itr == closingTag)
        {
            isInStripRegion = false;
        }
        else
        {
            output.push_back(*itr);
        }
    }
    return output;
}

vector<string> stripTagAttributes(const vector<string> &input, const string &tagName)
{
    string openingTag = openTagStart + tagName;

    vector<string> output;
    for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
    {
        string itrOpening = itr->substr(0, openingTag.length());
        if (itrOpening == openingTag)
        {
            output.push_back(openingTag + tagEnd);
        }
        else
        {
            output.push_back(*itr);
        }
    }
    return output;
}

vector<string> stripText(const vector<string> &input, const string &tagName)
{
    string openingTag = openTagStart + tagName;
    string closingTag = closeTagStart + tagName + tagEnd;
    bool isInStripRegion = false;

    vector<string> output;
    for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
    {
        string itrOpening = itr->substr(0, openingTag.length());
        if (!isInStripRegion && itrOpening == openingTag)
        {
            isInStripRegion = true;
            output.push_back(*itr);
        }
        else if (isInStripRegion && *itr == closingTag)
        {
            isInStripRegion = false;
            output.push_back(*itr);
        }
        else if (!isInStripRegion)
        {
            output.push_back(*itr);
        }
    }
    return output;
}

vector<string> formatBold(const vector<string> &input)
{
    return substituteTag(input, "b", "*");
}

vector<string> formatItalic(const vector<string> &input)
{
    return substituteTag(input, "i", "_");
}

vector<string> substituteTag(const vector<string> &input, const string &tagName, const string &tagNameSubstitute)
{
    string openingTag = openTagStart + tagName + tagEnd;
    string closingTag = closeTagStart + tagName + tagEnd;

    vector<string> output;
    for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
    {
        if (*itr == openingTag || *itr == closingTag)
        {
            output.push_back(tagNameSubstitute);
        }
        else
        {
            output.push_back(*itr);
        }
    }
    return output;
}

vector<string> formatHyperlink(const vector<string> &input)
{
    const string hyperlink = "a";
    bool insidetag = false;

    string openingTag = openTagStart + hyperlink;
    string closingTag = closeTagStart + hyperlink + tagEnd;

    vector<string> output;
    for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
    {
        string itrOpening = itr->substr(0, openingTag.length());
        if (itrOpening == openingTag)
        {
            insidetag = true;

            string linkURL = getLinkURL(*itr);

            vector<string>::const_iterator next = itr;
            ++next;
            string innerText = *next;

            output.push_back(innerText + "(" + linkURL + ")");
        }
        else if (*itr == closingTag)
        {
            insidetag = false;
        }
        else if (!insidetag)
        {
            output.push_back(*itr);
        }
    }
    return output;
}

string getLinkURL(const string &hrefTag)
{
    const string hyperlinkURL = "href=";
    int position = hrefTag.find(hyperlinkURL, 0) + hyperlinkURL.length();

    string linkURL = "";
    char endDemaractor;
    if (hrefTag[position] == '\"')
    {
        endDemaractor = '\"';
        position++;
    }
    else
    {
        endDemaractor = ' ';
    }

    for (int i = position; i < hrefTag.length(); i++)
    {
        if (hrefTag[i] == endDemaractor)
        {
            break;
        }
        linkURL += hrefTag[i];
    }
    return linkURL;
}
显示结果如下
Opening HTML file sampleHTML
File is opened!
Reading file...
Original HTML:
<html xmlns="http://www.w3.org/1999/xhtml" itemscope="" itemtype="http://schema.org/WebPage">
<head>
<meta property="og : image" content="https ://lh3.googleusercontent.com/-mln6PaqJChw/UOIaqjWmkgI/AAAAAAABno0/sck_C8SCr-0/s240/DSCN6032a.jpg" />
<script type="text / javascript">
  window.jstiming.load.tick('cl');
</script>
</head>
<body xmlns="http://www.google.com/ns/jotspot" id="body" class=" en            ">
 This is an html text file that is parsed to handle text such as <b>bold text</b>, <i>italic text</i>, and even <a href="www.google.com">hyperlink text</a>.
</body>
</html>

Parsed HTML:
<head>
</head>
<body>
 This is an html text file that is parsed to handle text such as *bold text*, _italic text_, and even hyperlink text(www.google.com).
</body>

Writing file to HTML format...

cat sampleHTML.html
<html xmlns="http://www.w3.org/1999/xhtml" itemscope="" itemtype="http://schema.org/WebPage">
<head>
<meta property="og : image" content="https ://lh3.googleusercontent.com/-mln6PaqJChw/UOIaqjWmkgI/AAAAAAABno0/sck_C8SCr-0/s240/DSCN6032a.jpg" />
<script type="text / javascript">
  window.jstiming.load.tick('cl');
</script>
</head>
<body xmlns="http://www.google.com/ns/jotspot" id="body" class=" en            ">
 This is an html text file that is parsed to handle text such as <b>bold text</b>, <i>italic text</i>, and even <a href="www.google.com">hyperlink text</a>.
</body>
</html>

cat sampleHTML_parsed.html
<head>
</head>
<body>
 This is an html text file that is parsed to handle text such as *bold text*, _italic text_, and even hyperlink text(www.google.com).
</body>

3.创建一个简单的XML解析器。XML是个基础的格式化语言，和HTML相似。
它的文档是树形结构的节点，格式是<node>[data] </node>，[data]不是文本就是另外嵌套的节点。
XML节点可能有属性，格式是<node attribute="value">。
（真正的XML说明包含了更多的细节，但是那需要费很大的劲来实现。）
你的解析器应当接收一个有几个方法的接口类，下列这些事发生时它会调用这些方法。
1. 当读入节点的时候，它会带着节点的名字调用nodeStart。 
2. 当读入属性的时候，它会调用attributeRead；这个方法应当总是在针对属性相关联的节点nodeStart之后立即被调用。
3. 当节点有文本正文时，调用nodeTextRead，带着文本的内容，以字符串的形式作为参数。
如果你遇到像这样的情 况<node>text<sub-node>text</sub-node>more text</node>，
 在sub-node之前和之后的文本需要分别调用nodeTextRead 。 
4. 当读到end-node的时候，带着节点的名字去调用nodeEnd。
 5. 你可以把任何<或>当做节点的开始。如果XML文件的作者要让<或 >出现在文本中，它应当被写作&lt;或&gt;
（意思是大于和小 于）。
由于符号与 & 也是必须避免的，它们必须以&amp;的形式出现 。在代码中你无需翻译&lt;和&gt;或者&amp;。
下面是一些XML示例文档让你作为输入的测试数据：
<address-book>
  <entry>
    <name>Alex Allain</name>
    <email>webmaster@cprogramming.com</email>
  </entry>
  <entry>
    <name>Joe Doe</name>
    <email>john@doe.com</email>
  </entry>
</address-book>

还有：
<html>
  <head>
    <title>Doc title</title>
  </head>
  <body>This is a nice <a href="http://www.cprogramming.com">link</a> to a website.</body>
</html>

为了测试解析器能正常工作，你可以写段代码来显示文件中每个解析出来的元素，然后认证它获取的就是你想要的元素。
或者可以实现下一个习题，它会展示你的解析器在使用中的一个例子。

XmlNode.h
#pragma once
#ifndef XMLNODE_H_
#define XMLNODE_H_

#include <map>
#include <vector>
#include <string>

class XmlNode
{
public:
    char TagOpen() const;
    char CloseTagStart() const;
    char TagClose() const;
    std::string Name() const;
    std::vector<std::string> Attributes();
    std::string AttributeValue(std::string attribute);
    std::string InnerText() const;
    int NumberOfChildren() const;
    XmlNode *Child(int index);

    XmlNode();
    XmlNode(char tagOpen, char tagClose, char nodeClose);
    ~XmlNode();

    static XmlNode *createNode(const std::string &input);
    void nodeStart(const std::string &input);
    std::string print(int level = 0, const std::string &spacer = "");
private:
    const std::string _spacer = "  ";

    char _tagOpen;
    char _closeTagStart;
    char _tagClose;
    std::string _name;
    std::map<std::string, std::string> _attributes;
    std::vector<XmlNode *> _children;
    std::string _innerText;

    void attributeRead(const std::string &attributesStream);
    void nodeTextRead(const std::string &innerText);
    std::string nodeEnd(const std::string &nameNode) const;
    static std::string clearEmpty(std::string &text);
};

#endif

XmlNode.cpp
#include <map>
#include <vector>
#include <string>
#include "XmlNode.h"

using namespace std;

char XmlNode::TagOpen() const
{
    return _tagOpen;
}

char XmlNode::CloseTagStart() const
{
    return _closeTagStart;
}

char XmlNode::TagClose() const
{
    return _tagClose;
}

string XmlNode::Name() const
{
    return _name;
}

vector<string> XmlNode::Attributes()
{
    vector<string> attributeKeys;
    for (map<string, string>::iterator itr = _attributes.begin(), end = _attributes.end(); itr != end; ++itr)
    {
        attributeKeys.push_back(itr->first);
    }
    return attributeKeys;
}

string XmlNode::AttributeValue(string attribute)
{
    return _attributes[attribute];
}

string XmlNode::InnerText() const
{
    return _innerText;
}

int XmlNode::NumberOfChildren() const
{
    return _children.size();
}

XmlNode *XmlNode::Child(int index)
{
    return _children[index];
}

XmlNode::XmlNode()
{
    _tagOpen = '<';
    _closeTagStart = '/';
    _tagClose = '>';
}

XmlNode::XmlNode(char tagOpen, char tagClose, char nodeClose)
{
    _tagOpen = tagOpen;
    _tagClose = tagClose;
    _closeTagStart = nodeClose;
}

XmlNode::~XmlNode()
{
    for (vector<XmlNode *>::iterator itr = _children.begin(), end = _children.end(); itr != end; ++itr)
    {
        delete *itr;
    }
    _children.clear();
}

XmlNode *XmlNode::createNode(const string &input)
{
    XmlNode *node = new XmlNode();
    node->nodeStart(input);
    return node;
}

void XmlNode::nodeStart(const string &input)
{
    int startTagOpenIndex = input.find_first_of(_tagOpen);
    int spaceIndex = input.find_first_of(' ', startTagOpenIndex);
    int startTagCloseIndex = input.find_first_of(_tagClose, startTagOpenIndex);
    if (spaceIndex != string::npos && spaceIndex < startTagCloseIndex)
    {
        _name = input.substr(startTagOpenIndex + 1, (spaceIndex - 1) - startTagOpenIndex);
        attributeRead(input.substr(spaceIndex + 1, (startTagCloseIndex - 1) - spaceIndex));
    }
    else
    {
        _name = input.substr(startTagOpenIndex + 1, (startTagCloseIndex - 1) - startTagOpenIndex);
    }

    string closeTag = nodeEnd(_name);
    int endTagOpenIndex = input.find_last_of(closeTag);
    string innerText = input.substr( startTagCloseIndex + 1, (endTagOpenIndex - 1) - startTagCloseIndex - ( closeTag.length() - 1 ) );
    nodeTextRead(innerText);
}

void XmlNode::attributeRead(const string &attributesStream)
{
    string currentKey = "";
    string currentEntry = "";
    bool isInValue = false;
    for (int i = 0; i < attributesStream.length(); i++)
    {
        if (attributesStream[i] == '=')
        {
            currentKey = currentEntry;
            currentEntry.clear();
        }
        else if (attributesStream[i] == '"' && !isInValue)
        {
            isInValue = true;
        }
        else if (attributesStream[i] == '"' && isInValue)
        {
            isInValue = false;
            currentEntry = clearEmpty(currentEntry);
            _attributes[currentKey] = currentEntry;
            currentKey.clear();
            currentEntry.clear();
        }
        else if (attributesStream[i] != '=' &&
                 attributesStream[i] != '"' &&
                 !(attributesStream[i] == ' ' && !isInValue))
        {
            currentEntry += attributesStream[i];
        }
    }
}

void XmlNode::nodeTextRead(const string &innerText)
{
    int startTagOpenIndex = innerText.find_first_of(_tagOpen);
    if (startTagOpenIndex == string::npos)
    {
        _innerText = innerText;
        _innerText = clearEmpty(_innerText);
        return;
    }

    _innerText += innerText.substr(0, startTagOpenIndex);
    int openTagCount = 0;
    int tagCount = 0;
    string innerInnerText;
    for (int i = startTagOpenIndex; i < innerText.length(); i++)
    {
        char currentCharacter = innerText[i];
        if (currentCharacter == _tagOpen)
        {
            tagCount++;
            if ( (i + 1) < innerText.length() && innerText[i + 1] == _closeTagStart)
            {
                openTagCount--;
            }
            else
            {
                openTagCount++;
            }
        }
        else if (currentCharacter == _tagClose)
        {
            tagCount--;
        }

        if (openTagCount == 0 && tagCount == 0 && currentCharacter != _tagClose)
        {
            _innerText.push_back(currentCharacter);
        }
        else
        {
            innerInnerText.push_back(currentCharacter);
        }

        if (currentCharacter == _tagClose && openTagCount == 0)
        {
            _children.push_back(createNode(innerInnerText));
            innerInnerText.clear();
        }
    }
    _innerText = clearEmpty(_innerText);
}


string XmlNode::nodeEnd(const string &nameNode) const
{
    string nodeEndTag;
    nodeEndTag.push_back(_tagOpen);
    nodeEndTag.push_back(_closeTagStart);
    return (nodeEndTag + nameNode + _tagClose);
}

string XmlNode::print(int level, const string &spacer)
{
    string tabs = "";
    string currentSpacer;
    spacer.empty() ? currentSpacer = _spacer : currentSpacer = spacer;
    for (int i = 0; i < level; i++)
    {
        tabs += currentSpacer;
    }
    string currentNode = tabs;

    currentNode.push_back(_tagOpen);
    currentNode += _name;
    vector<string> attributes = Attributes();
    for (vector<string>::iterator itr = attributes.begin(), end = attributes.end(); itr != end; ++itr)
    {
        currentNode += " " + *itr + "=\"" + _attributes[*itr] + "\"";
    }
    currentNode += _tagClose;

    if (!_innerText.empty())
    {
        currentNode += '\n' + tabs + currentSpacer;
        currentNode += _innerText;
    }

    int children = NumberOfChildren();
    for (int i = 0; i < children; i++)
    {
        currentNode += '\n';
        currentNode += _children[i]->print(level + 1);
    }

    currentNode += '\n' + tabs;
    currentNode += nodeEnd(_name);

    return currentNode;
}

string XmlNode::clearEmpty(string &text)
{
    if (text.find_first_not_of(' ') == string::npos)
    {
        return "";
    }
    return text;
}

XmlParser.cpp
#include <fstream>
#include <iostream>
#include <string>
#include <vector>
#include "XmlNode.h"

using namespace std;

string readXMLFileAsStream(string &fileName);

int main()
{
    string xmlToString;
    string xmlDOMStream;
    string fileName;
    XmlNode *root;
    vector<string> fileNames =
    {
        "addresses",
        "books",
        "attributesSample"
    };

    for(vector<string>::iterator itr = fileNames.begin(), end = fileNames.end(); itr != end; ++itr)
    {
        cout << "Reading & parsing " << *itr << ".xml\n";
        xmlDOMStream = readXMLFileAsStream(*itr);
        if (!xmlDOMStream.empty())
        {
            root = XmlNode::createNode(xmlDOMStream);
            cout << "Printing XML object...\n\n";
            xmlToString = root->print();
            cout << xmlToString;
            delete root;
        }
        cout << "\n\n";
    }
}

string readXMLFileAsStream(string &fileName)
{
    cout << "Opening XML file " << fileName << '\n';
    ifstream fileReader(fileName + ".xml");
    if (!fileReader.is_open())
    {
        cout << "Could not open file!" << '\n';
        return "";
    }
    cout << "File is opened!\n";

    cout << "Reading file...\n";
    string stream;
    string line;
    while (getline(fileReader, line, '\n'))
    {
        stream += line;
    }

    return stream;
}
编译命令如下
g++ -o XmlParser XmlParser.cpp XmlNode.cpp

显示结果如下
Reading & parsing addresses.xml
Opening XML file addresses
File is opened!
Reading file...
Printing XML object...

<address-book>
  <entry>
    <name>
      Alex Allain
    </name>
    <email>
      webmaster@cprogramming.com
    </email>
  </entry>
  <entry>
    <name>
      Joe Doe
    </name>
    <email>
      john@doe.com
    </email>
  </entry>
</address-book>

Reading & parsing books.xml
Opening XML file books
File is opened!
Reading file...
Printing XML object...

<html>
  <head>
    <title>
      Doc title
    </title>
  </head>
  <body>
    This is a nice  to a website.
    <a href="http://www.cprogramming.com">
      link
    </a>
  </body>
</html>

Reading & parsing attributesSample.xml
Opening XML file attributesSample
File is opened!
Reading file...
Printing XML object...

<model documentation_status="not applicable" is_bug="no" is_public="yes" status="done" xmlns="http://www.csiberkeley.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.csiberkeley.com http://www.csiamerica.com/sites/default/files/schemas/model_database_model_V0_4.xsd">
  <id>
    387
  </id>
  <id_secondary>
  </id_secondary>
  <title>
    Template - Steel Deck
  </title>
  <path type="relative">
        models\0387.edb        
    <database_file_name attribute1="value with spaces" attribute_2="valueWithoutSpaces">
      <another_child>
      </another_child>
    </database_file_name>
  </path>
</model>

cat addresses.xml

<address-book>
  <entry>
    <name>Alex Allain</name>
    <email>webmaster@cprogramming.com</email>
  </entry>
  <entry>
    <name>Joe Doe</name>
    <email>john@doe.com</email>
  </entry>
</address-book>

cat books.xml

<html>
  <head>
    <title>Doc title</title>
  </head>
  <body>This is a nice <a href="http://www.cprogramming.com">link</a> to a website.</body>
</html>

cat attributesSample.xml

<model is_public="yes" is_bug="no" status="done" xmlns="http://www.csiberkeley.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.csiberkeley.com http://www.csiamerica.com/sites/default/files/schemas/model_database_model_V0_4.xsd" documentation_status="not applicable">
  <id  >387</id   >
  <id_secondary>
  </id_secondary>
  <title>Template - Steel Deck</title>
  <path type="relative">
    models\0387.edb
      <database_file_name attribute1="value with spaces" attribute_2="valueWithoutSpaces">
        <another_child>
        </another_child>
      </database_file_name>
  </path>
</model>

4.重写HTML解析器让它使用你的XML解析器，而不是之前的手动解析。
添加对列表显示的支持。你应当能够读取<ul>标签或者<nl>标签，来识别无序和有序的列表。
各个列表项应当在<li>和</li>标签之间。
<ul>
<li>first item</li>
<li>second item</li>
</ul>
显示出来的应该是：
* first item
* second item
对于：
<nl>
<li>first item</li>
<li>second item</li>
</nl>
则是：
1.first item
2.second item
如果有第二个有序列表出现，请确保重启标序功能。

XmlNode.h
#pragma once
#ifndef XMLNODE_H_
#define XMLNODE_H_

#include <map>
#include <vector>
#include <string>

class XmlNode
{
public:
    char TagOpen() const;
    char CloseTagStart() const;
    char TagClose() const;
    std::string Name() const;
    std::vector<std::string> Attributes();
    std::string AttributeValue(std::string attribute);
    std::string InnerText() const;
    int NumberOfChildren() const;
    XmlNode *Child(int index);

    XmlNode();
    XmlNode(const std::string &input);
    XmlNode(char tagOpen, char tagClose, char nodeClose);
    virtual ~XmlNode();

    static XmlNode *createNode(const std::string &input);
    void nodeStart(const std::string &input);
    virtual std::string print(XmlNode *node, int indentLevel = 0, const std::string &spacer = "");
protected:
    const std::string _spacer = "  ";
    const std::string _textNode = "#text";

    virtual std::string printOpeningTag(XmlNode *node, const std::string &tabs = "");
    virtual std::string printClosingTag(XmlNode *node, const std::string &tabs = "");
    virtual std::string printInnerText(XmlNode *node, const std::string &tabs = "", const std::string &currentSpacer = "");
    virtual std::string printChildNodes(XmlNode *node, int childIndex, int indentLevel);

    std::string nodeEnd(const std::string &nameNode) const;
    std::string getTabs(int indentationLevel, const std::string &spacer = "") const;
private:
    char _tagOpen;
    char _closeTagStart;
    char _tagClose;
    std::string _name;
    std::map<std::string, std::string> _attributes;
    std::vector<XmlNode *> _children;
    std::string _innerText;

    static XmlNode *createTextNode(const std::string &input);
    void attributeRead(const std::string &attributesStream);
    void nodeTextRead(const std::string &innerText);
    static std::string clearEmpty(std::string &text);
};

#endif

XmlNode.cpp
#include <map>
#include <vector>
#include <string>
#include "XmlNode.h"

using namespace std;

char XmlNode::TagOpen() const
{
    return _tagOpen;
}

char XmlNode::CloseTagStart() const
{
    return _closeTagStart;
}

char XmlNode::TagClose() const
{
    return _tagClose;
}

string XmlNode::Name() const
{
    return _name;
}

vector<string> XmlNode::Attributes()
{
    vector<string> attributeKeys;
    for (map<string, string>::iterator itr = _attributes.begin(), end = _attributes.end(); itr != end; ++itr)
    {
        attributeKeys.push_back(itr->first);
    }
    return attributeKeys;
}

string XmlNode::AttributeValue(string attribute)
{
    return _attributes[attribute];
}

string XmlNode::InnerText() const
{
    return _innerText;
}

int XmlNode::NumberOfChildren() const
{
    return _children.size();
}

XmlNode *XmlNode::Child(int index)
{
    return _children[index];
}

XmlNode::XmlNode()
{
    _tagOpen = '<';
    _closeTagStart = '/';
    _tagClose = '>';
}

XmlNode::XmlNode(const string &input) : XmlNode()
{
    _name = _textNode;
    _innerText = input;
}

XmlNode::XmlNode(char tagOpen, char tagClose, char nodeClose)
{
    _tagOpen = tagOpen;
    _tagClose = tagClose;
    _closeTagStart = nodeClose;
}

XmlNode::~XmlNode()
{
    for (vector<XmlNode *>::iterator itr = _children.begin(), end = _children.end(); itr != end; ++itr)
    {
        delete *itr;
    }
    _children.clear();
}

XmlNode *XmlNode::createNode(const string &input)
{
    XmlNode *node = new XmlNode();
    node->nodeStart(input);
    return node;
}

XmlNode *XmlNode::createTextNode(const string &input)
{
    XmlNode *node = new XmlNode(input);
    return node;
}

void XmlNode::nodeStart(const string &input)
{
    int startTagOpenIndex = input.find_first_of(_tagOpen);
    int spaceIndex = input.find_first_of(' ', startTagOpenIndex);
    int startTagCloseIndex = input.find_first_of(_tagClose, startTagOpenIndex);
    if (spaceIndex != string::npos && spaceIndex < startTagCloseIndex)
    {
        _name = input.substr(startTagOpenIndex + 1, (spaceIndex - 1) - startTagOpenIndex);
        attributeRead(input.substr(spaceIndex + 1, (startTagCloseIndex - 1) - spaceIndex));
    }
    else
    {
        _name = input.substr(startTagOpenIndex + 1, (startTagCloseIndex - 1) - startTagOpenIndex);
    }

    string closeTag = nodeEnd(_name);
    int endTagOpenIndex = input.find_last_of(closeTag);
    string innerText = input.substr( startTagCloseIndex + 1, (endTagOpenIndex - 1) - startTagCloseIndex - ( closeTag.length() - 1 ) );
    nodeTextRead(innerText);
}

void XmlNode::attributeRead(const string &attributesStream)
{
    string currentKey = "";
    string currentEntry = "";
    bool isInValue = false;
    for (int i = 0; i < attributesStream.length(); i++)
    {
        if (attributesStream[i] == '=')
        {
            currentKey = currentEntry;
            currentEntry.clear();
        }
        else if (attributesStream[i] == '"' && !isInValue)
        {
            isInValue = true;
        }
        else if (attributesStream[i] == '"' && isInValue)
        {
            isInValue = false;
            currentEntry = clearEmpty(currentEntry);
            _attributes[currentKey] = currentEntry;
            currentKey.clear();
            currentEntry.clear();
        }
        else if (attributesStream[i] != '=' &&
                 attributesStream[i] != '"' &&
                 !(attributesStream[i] == ' ' && !isInValue))
        {
            currentEntry += attributesStream[i];
        }
    }
}

void XmlNode::nodeTextRead(const string &innerText)
{
    if (innerText.empty())
    {
        return;
    }
    int startTagOpenIndex = innerText.find_first_of(_tagOpen);
    if (startTagOpenIndex == string::npos)
    {
        _innerText = innerText;
        _innerText = clearEmpty(_innerText);
        return;
    }

    if (startTagOpenIndex > 0)
    {
        _innerText += innerText.substr(0, startTagOpenIndex);
    }

    int openTagCount = 0;
    int tagCount = 0;
    string innerInnerText;
    for (int i = startTagOpenIndex; i < innerText.length(); i++)
    {
        char currentCharacter = innerText[i];
        if (currentCharacter == _tagOpen)
        {
            if (openTagCount == 0 && !_innerText.empty())
            {
                _innerText = clearEmpty(_innerText);
                if (!_innerText.empty())
                {
                    _children.push_back(createTextNode(_innerText));
                    _innerText.clear();
                }
            }
            tagCount++;
            if ( (i + 1) < innerText.length() && innerText[i + 1] == _closeTagStart)
            {
                openTagCount--;
            }
            else
            {
                openTagCount++;
            }
        }
        else if (currentCharacter == _tagClose)
        {
            tagCount--;
        }

        if (openTagCount == 0 && tagCount == 0 && currentCharacter != _tagClose)
        {
            _innerText.push_back(currentCharacter);
            if ( (i + 1) >= innerText.length() && !_innerText.empty() )
            {
                _innerText = clearEmpty(_innerText);
                if (!_innerText.empty())
                {
                    _children.push_back(createTextNode(_innerText));
                    _innerText.clear();
                }
            }
        }
        else
        {
            innerInnerText.push_back(currentCharacter);
        }

        if (currentCharacter == _tagClose && openTagCount == 0)
        {
            _children.push_back(createNode(innerInnerText));
            innerInnerText.clear();
        }
    }
    _innerText = clearEmpty(_innerText);
}


string XmlNode::nodeEnd(const string &nameNode) const
{
    string nodeEndTag;
    nodeEndTag.push_back(_tagOpen);
    nodeEndTag.push_back(_closeTagStart);
    return (nodeEndTag + nameNode + _tagClose);
}

string XmlNode::getTabs(int indentationLevel, const string &spacer) const
{
    string tabs = "";
    string currentSpacer;
    spacer.empty() ? currentSpacer = _spacer : currentSpacer = spacer;
    for (int i = 0; i < indentationLevel; i++)
    {
        tabs += currentSpacer;
    }
    return tabs;
}

string XmlNode::printOpeningTag(XmlNode *node, const string &tabs)
{
    string currentNode = tabs;
    currentNode.push_back(_tagOpen);
    currentNode += node->Name();
    vector<string> attributes = node->Attributes();
    for (vector<string>::iterator itr = attributes.begin(), end = attributes.end(); itr != end; ++itr)
    {
        currentNode += " " + *itr + "=\"" + node->AttributeValue(*itr) + "\"";
    }
    currentNode += _tagClose;
    return currentNode;
}

string XmlNode::printInnerText(XmlNode *node, const string &tabs, const string &currentSpacer)
{
    string currentNode;
    if (!node->InnerText().empty())
    {
        currentNode += '\n' + tabs + currentSpacer;
        currentNode += node->InnerText();
    }
    return currentNode;
}

string XmlNode::printChildNodes(XmlNode *node, int childIndex, int indentLevel)
{
    string currentNode;
    currentNode += '\n';
    currentNode += print(node->Child(childIndex), indentLevel + 1);
    return currentNode;
}

string XmlNode::printClosingTag(XmlNode *node, const string &tabs)
{
    string currentNode = '\n' + tabs;
    currentNode += nodeEnd(node->Name());
    return  currentNode;
}

string XmlNode::print(XmlNode *node, int indentLevel, const string &spacer)
{
    string currentSpacer;
    spacer.empty() ? currentSpacer = _spacer : currentSpacer = spacer;
    string tabs = getTabs(indentLevel, currentSpacer);

    string currentNode = printOpeningTag(node, tabs);

    currentNode += printInnerText(node, tabs, currentSpacer);

    int children = node->NumberOfChildren();
    for (int i = 0; i < children; i++)
    {
        currentNode += printChildNodes(node, i, indentLevel);
    }

    currentNode += printClosingTag(node, tabs);

    return currentNode;
}

string XmlNode::clearEmpty(string &text)
{
    if (text.find_first_not_of(' ') == string::npos)
    {
        return "";
    }
    if (text.find_first_not_of('\t') == string::npos)
    {
        return "";
    }
    return text;
}

HtmlPrinter.h
#pragma once
#ifndef HTMLPRINTER_H_
#define HTMLPRINTER_H_

#include <string>
#include "XmlNode.h"

class HtmlPrinter : public XmlNode
{
public:
    HtmlPrinter(const std::string &XmlDOMStream);

    static HtmlPrinter *createNode(const std::string &input);
    std::string print(XmlNode *node, int indentLevel = 0, const std::string &spacer = "");
protected:
    std::string printOpeningTag(XmlNode *node, const std::string &tabs = "");
    std::string printClosingTag(XmlNode *node, const std::string &tabs = "");
    std::string printInnerText(XmlNode *node, const std::string &tabs = "", const std::string &currentSpacer = "");
    std::string printChildNodes(XmlNode *node, int childIndex, int indentLevel);
};

#endif

HtmlPrinter.cpp
#include <string>
#include "HtmlPrinter.h"

using namespace std;

HtmlPrinter *HtmlPrinter::createNode(const string &XmlDOMStream)
{
    HtmlPrinter *node = new HtmlPrinter(XmlDOMStream);
    return node;
}

HtmlPrinter::HtmlPrinter(const string &XmlDOMStream)
{
    nodeStart(XmlDOMStream);
}

string HtmlPrinter::print(XmlNode *node, int indentLevel, const string &spacer)
{
    string currentSpacer;
    spacer.empty() ? currentSpacer = _spacer : currentSpacer = spacer;
    string tabs = getTabs(indentLevel, currentSpacer);

    string currentNode = printOpeningTag(node, tabs);

    currentNode += printInnerText(node, tabs, currentSpacer);

    int children = node->NumberOfChildren();
    for (int i = 0; i < children; i++)
    {
        currentNode += printChildNodes(node, i, indentLevel);
    }

    currentNode += printClosingTag(node, tabs);

    return currentNode;
}

string HtmlPrinter::printOpeningTag(XmlNode *node, const string &tabs)
{
    string currentNode;
    if (node->Name() == _textNode)
    {
        return "";
    }
    if (node->Name() == "html")
    {
        return "";
    }
    if (node->Name() == "br")
    {
        return "";
    }
    if (node->Name() == "a")
    {
        return "";
    }
    if (node->Name() == "ul")
    {
        return "\n";
    }
    if (node->Name() == "ol")
    {
        return "\n";
    }
    if (node->Name() == "li")
    {
        return "";
    }
    if (node->Name() == "b")
    {
        return "*";
    }
    if (node->Name() == "i")
    {
        return "_";
    }
    if (node->Name() == "body")
    {
        currentNode = "\n" + tabs;
        currentNode.push_back(TagOpen());
        currentNode += node->Name() + TagClose() + '\n';
        return currentNode;
    }
    return XmlNode::printOpeningTag(node, tabs);
}

string HtmlPrinter::printClosingTag(XmlNode *node, const string &tabs)
{
    if (node->Name() == _textNode)
    {
        return "";
    }
    if (node->Name() == "html")
    {
        return "";
    }
    if (node->Name() == "br")
    {
        return "";
    }
    if (node->Name() == "a")
    {
        return "";
    }
    if (node->Name() == "ul")
    {
        return "";
    }
    if (node->Name() == "ol")
    {
        return "";
    }
    if (node->Name() == "li")
    {
        return "";
    }
    if (node->Name() == "b")
    {
        return "*";
    }
    if (node->Name() == "i")
    {
        return "_";
    }
    return XmlNode::printClosingTag(node, tabs);
}

string HtmlPrinter::printInnerText(XmlNode *node, const string &tabs, const string &currentSpacer)
{
    if (node->Name() == _textNode)
    {
        return node->InnerText();
    }
    if (node->Name() == "head")
    {
        return "";
    }
    if (node->Name() == "br")
    {
        return "\n";
    }
    if (node->Name() == "b")
    {
        return node->InnerText();
    }
    if (node->Name() == "i")
    {
        return node->InnerText();
    }
    if (node->Name() == "ul")
    {
        return "";
    }
    if (node->Name() == "ol")
    {
        return "";
    }
    if (node->Name() == "li")
    {
        return node->InnerText() + '\n';
    }
    if (node->Name() == "a")
    {
        return node->InnerText() + '(' + node->AttributeValue("href") + ')';
    }
    return XmlNode::printInnerText(node, tabs, currentSpacer);
}

string HtmlPrinter::printChildNodes(XmlNode *node, int childIndex, int indentLevel)
{
    string currentNode;
    XmlNode *childNode = node->Child(childIndex);
    if (node->Name() == _textNode)
    {
        return "";
    }
    if (node->Name() == "html")
    {
        return print(childNode, indentLevel + 1);
    }
    if (node->Name() == "head")
    {
        return "";
    }
    if (node->Name() == "b")
    {
        return print(childNode);
    }
    if (node->Name() == "i")
    {
        return print(childNode);
    }
    if (node->Name() == "a")
    {
        return print(childNode);
    }
    if (node->Name() == "ul" && childNode->Name() == "li")
    {
        string tabs = getTabs(indentLevel, _spacer);
        currentNode += tabs;
        currentNode += "* ";
        currentNode += print(childNode, indentLevel + 1);
        return currentNode;
    }
    if (node->Name() == "ol" && childNode->Name() == "li")
    {
        string tabs = getTabs(indentLevel, _spacer);
        currentNode += tabs;
        currentNode += to_string(childIndex + 1) + ". ";
        currentNode += print(childNode, indentLevel + 1);
        return currentNode;
    }

    currentNode += print(childNode, indentLevel + 1);
    return currentNode;
}

HtmlParser.cpp
#include <fstream>
#include <iostream>
#include <string>
#include <vector>
#include "XmlNode.h"
#include "HtmlPrinter.h"

using namespace std;

string readFileAsStream(const string &fileName, const string &fileExtension);
int writeToTextFile(const string &fileName, const string &content);

int main()
{
    string XmlToString;
    string XmlDOMStream;
    HtmlPrinter *root;
    map<string, string> files;
    files["addresses"] = "xml";
    files["books"] = "xml";
    files["attributesSample"] = "xml";
    files["sampleHTML"] = "html";

    for (map<string, string>::iterator itr = files.begin(), end = files.end(); itr != end; ++itr)
    {
        string fileName = itr->first;
        string fileExtension = itr->second;
        cout << "Reading & parsing " << fileName << "." << fileExtension << "\n";
        XmlDOMStream = readFileAsStream(fileName, fileExtension);
        if (!XmlDOMStream.empty())
        {
            root = HtmlPrinter::createNode(XmlDOMStream);
            cout << "Printing XML object...\n\n";
            XmlToString = root->print(root);
            writeToTextFile(fileName + "_output", XmlToString);
            cout << XmlToString;
            delete root;
        }
        cout << "\n\n";
    }
}

string readFileAsStream(const string &fileName, const string &fileExtension)
{
    cout << "Opening '" << fileExtension << "' file " << fileName << '\n';
    ifstream fileReader(fileName + "." + fileExtension);
    if (!fileReader.is_open())
    {
        cout << "Could not open file!" << '\n';
        return "";
    }
    cout << "File is opened!\n";

    cout << "Reading file...\n";
    string stream;
    string line;
    while (getline(fileReader, line, '\n'))
    {
        stream += line;
    }

    return stream;
}

int writeToTextFile(const string &fileName, const string &content)
{
    cout << "Writing file to text format..." << '\n';
    ofstream fileWriter(fileName + ".txt");
    if (!fileWriter.is_open())
    {
        cout << "Could not open file!" << '\n';
        return 1;
    }

    fileWriter << content;
    return 0;
}
编译命令如下
g++ -o HtmlParser HtmlParser.cpp HtmlPrinter.cpp XmlNode.cpp

显示结果如下
Reading & parsing addresses.xml
Opening 'xml' file addresses
File is opened!
Reading file...
Printing XML object...

Writing file to text format...
<address-book>  <entry>    <name>
      Alex Allain
    </name>    <email>
      webmaster@cprogramming.com
    </email>
  </entry>  <entry>    <name>
      Joe Doe
    </name>    <email>
      john@doe.com
    </email>
  </entry>
</address-book>

Reading & parsing attributesSample.xml
Opening 'xml' file attributesSample
File is opened!
Reading file...
Printing XML object...

Writing file to text format...
<model documentation_status="not applicable" is_bug="no" is_public="yes" status="done" xmlns="http://www.csiberkeley.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.csiberkeley.com http://www.csiamerica.com/sites/default/files/schemas/model_database_model_V0_4.xsd">  <id>387
  </id>  <id_secondary>
  </id_secondary>  <title>
    Template - Steel Deck
  </title>  <path type="relative">    models\0387.edb          <database_file_name attribute1="value with spaces" attribute_2="valueWithoutSpaces">      <another_child>
      </another_child>
    </database_file_name>
  </path>
</model>

Reading & parsing books.xml
Opening 'xml' file books
File is opened!
Reading file...
Printing XML object...

Writing file to text format...
  <head>
  </head>
  <body>
This is a nice link(http://www.cprogramming.com) to a website.
  </body>

Reading & parsing sampleHTML.html
Opening 'html' file sampleHTML
File is opened!
Reading file...
Printing XML object...

Writing file to text format...
  <head>
  </head>
  <body>
        This is an html text file that is parsed to handle text such as *bold text*, _italic text_, and even hyperlink text(www.google.com).
  Even new lines.
    * first item
    * second item

    1. first item
    2. second item
  Blah blah blah.
    1. first item
    2. second item

  </body>

cat addresses.xml
<address-book>
  <entry>
    <name>Alex Allain</name>
    <email>webmaster@cprogramming.com</email>
  </entry>
  <entry>
    <name>Joe Doe</name>
    <email>john@doe.com</email>
  </entry>
</address-book>

cat books.xml
<html>
  <head>
    <title>Doc title</title>
  </head>
  <body>This is a nice <a href="http://www.cprogramming.com">link</a> to a website.</body>
</html>

cat attributesSample.xml
<model is_public="yes" is_bug="no" status="done" xmlns="http://www.csiberkeley.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.csiberkeley.com http://www.csiamerica.com/sites/default/files/schemas/model_database_model_V0_4.xsd" documentation_status="not applicable">
  <id  >387</id   >
  <id_secondary>
  </id_secondary>
  <title>Template - Steel Deck</title>
  <path type="relative">
    models\0387.edb
      <database_file_name attribute1="value with spaces" attribute_2="valueWithoutSpaces">
        <another_child>
        </another_child>
      </database_file_name>
  </path>
</model>

cat sampleHTML.html
<html xmlns="http://www.w3.org/1999/xhtml" itemscope="" itemtype="http://schema.org/WebPage">
<head>
        <meta property="og : image" content="https ://lh3.googleusercontent.com/-mln6PaqJChw/UOIaqjWmkgI/AAAAAAABno0/sck_C8SCr-0/s240/DSCN6032a.jpg" ></meta>
        <script type="text / javascript">
                window.jstiming.load.tick('cl');
        </script>
</head>
<body xmlns="http://www.google.com/ns/jotspot" id="body" class=" en            ">
        This is an html text file that is parsed to handle text such as <b>bold text</b>, <i>italic text</i>, and even <a href="www.google.com">hyperlink text</a>.
  <br></br>
  Even new lines.
  <ul>
    <li>first item</li>
    <li>second item</li>
  </ul>
  <ol>
    <li>first item</li>
    <li>second item</li>
  </ol>
  Blah blah blah.
  <ol>
    <li>first item</li>
    <li>second item</li>
  </ol>
</body>
</html>

 cat addresses_output.txt
<address-book>  <entry>    <name>
      Alex Allain
    </name>    <email>
      webmaster@cprogramming.com
    </email>
  </entry>  <entry>    <name>
      Joe Doe
    </name>    <email>
      john@doe.com
    </email>
  </entry>
</address-book>

cat books_output.txt
  <head>
  </head>
  <body>
This is a nice link(http://www.cprogramming.com) to a website.
  </body>

cat attributesSample_output.txt
<model documentation_status="not applicable" is_bug="no" is_public="yes" status="done" xmlns="http://www.csiberkeley.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.csiberkeley.com http://www.csiamerica.com/sites/default/files/schemas/model_database_model_V0_4.xsd">  <id>387
  </id>  <id_secondary>
  </id_secondary>  <title>
    Template - Steel Deck
  </title>  <path type="relative">    models\0387.edb          <database_file_name attribute1="value with spaces" attribute_2="valueWithoutSpaces">      <another_child>
      </another_child>
    </database_file_name>
  </path>
</model>

cat sampleHTML_output.txt
  <head>
  </head>
  <body>
        This is an html text file that is parsed to handle text such as *bold text*, _italic text_, and even hyperlink text(www.google.com).
  Even new lines.
    * first item
    * second item

    1. first item
    2. second item
  Blah blah blah.
    1. first item
    2. second item

  </body>

第29章 C++中的模板
到目前为止你必须要为C++中的任何东西指定类型。如何声明一个变量呢？你需要一个类型。
声明一个函数，你需要给出所有参数的类型，还有返回值以及函数所有的局部变量的类型。
不过，有时候你可能想写通用的代码――使用什么类型无关紧要，因为逻辑对于所有的类型都是一样的。
你已经见过别人写的这类代码的一些例子，就是STL。STL是一个以通用方式操作的数据结构（也有算法）的集合。
它们可以持有任何程序员所要求的类型。往STL vector中存储条目的时候，告诉vector它将要存储的数据类型；
不需要局限于预先定义好的类型。STL的作者写了一个vector的实现能够存储所有的数据类型。
他们是如何实现这么棒的特性的呢？原来他们使用了C++的一个叫做模板的特性。
模板允许你写个函数或者类的“模板”，而不需要给出其中所有元素的类型；
然后当需要支持一个特定类型的时候，编译器可以创建或者初始化一个包含所需类型的模板的版本。
这就是发生在你写vector<int> vec;的时候，编译器用int类型来填充vector模板，创建一个可用的类。
如你已经见过的，使用模板是很简单的。本章都是关于创建自己的模板函数和模板类的内容。先来看一看模板函数。
29.1 模板函数
模板是创造更为通用的函数的完美解决方案。举个例子，你可能想要写个小的帮助函数来计算三角形的面积：
int triangleArea (int base, int height)
{
    return base * height * 0.5;
}
如果你要得出一个高为0.5，底也是0.5的三角形面积，怎么办？
由于两 个参数都是整型的传入的数据会被截取成0，所以即使面积不为0函数也会返回0。
另外一个选择是再写一个方法：
double triangleAreaDouble (double base, double height)
{
    return base * height * .5;
}
这段代码看起来和第一个函数一样，除了我们把所有的类型声明成double而不是int的那一行。
如果要对另外一个类型的参数做同样的操作――也许是个自定义的数字类――我们就得写该函数的第三种实现了。
C++模板是解决这种问题的完美方案。模板允许你把数据类型“提取出来”。
函数调用者列出要使用的类型，作为交换，编译器会为每个调用者要求的类型生成一个函数。
模板声明的语法上起来有一点吓人，但是我会把它拆开来解释，这样你就明白它的意思了。下面使用模板的语法来写上面那个函数：
template <typename T>
T triangleArea (T base, T height)
{
    return base * height * 0.5;
}
首先，我们使用template关键字来声明这个函数为模板。
接着，我们 在尖括号中列出了模板参数――这些参数是模板的使用者将要给定的值（比如，在vector<int>中的int ) 。
模板的参数应该是一个类型而不是值，所以我们使用typename关键字。
紧跟着typename我们写了参数的名字T，整个和声明函数的参数很相似。
当函数的调用者提供了一个模板的参数时，模板会把任何的引用当做这个参数T来处理，就如同它正是要处理的类型一样。
同样的，就像使用函数参数一样来获取传递到函数中的值。
举个例子，如果调用者这么写：
triangleArea<double>( 0.5, 0.5 );
那么代码中出现T的任何地方，它都会被double代替。就仿佛我们写了triangleAreaDouble函数一样。
我们写的代码在字面上就是个编译器用来创建处理double类型的函数的模板。
换句话说，下面这行：
template <typename T>
可以这样理解：“接下来的函数（或者类 )是个模板，在它内部，它将会使用字母T作为一个类型，就像int、double、char，
或者某个其他类的名字。当有人需要使用这个模板时，必须为T提供一个特定的类型。
通过把类型放在函数（或者类）名之前的尖括号（<> )中来实现。”
29.1.1 类型推断
在有些情况下，模板函数的调用者甚至都不需要显式地提供模板参数 ――编译器通常可以根据函数的参数来推断模板参数的值。
举个例 子，如果你这么写：
triangleArea( 0.5, 0.5);
编译器应当能够弄清楚T就应该是double。这是因为模板的参数T就是用来声明函数参数的。
由于编译器知道了函数参数的类型，它就能推断出T应该是什么。
在任何时候，只要模板参数被用作函数的一个参数类型，类型推断就可以正常工作。
29.1.2 鸭子类型
有句话说如果它“看上去像只鸭子，走起来像只鸭子，说起话来也像只鸭子，那么它就是只鸭子”。
神奇的是，这句话通常可以用来形容C++模板相关的东西，原因如下：
当你传入一个模板参数时，编译器需要判断该模板参数对于模板来说是否合法。
举个例子，在我们的compute_equation模板中，传入函数的值的类型必须能够支持数值运算符来进行加和乘的操作：
template <typename T>
T compute_equation(T x, T y, T z)
{
    return x * y * 4 * z + y * z + x;
}
但是有些类型不能进行乘法操作。整型和双精度型，作为不同种类的数字，它们能够相乘。但如果是vector<int>怎么办呢？
对一个vector进行乘法操作是很荒谬的――这没有任何意义而且vector类也不支持这个操作。
如果尝试传入三个vector 到上面的compute_equation 中，函数是无法编译通过的：
错误代码
int main ()
{
    vector<int> a, b, c;
    compute_equation( a, b, c );
}
实际上，编译器是很精准的，并且它还会告诉你哪些操作vector<int> 是不支持的：
template_compile.cc: In function 'T compute_equation(T, T, T) [with T = std::vector<int, std::allocator<int> >]': 
template_compile.cc:13:   instantiated from here 
template_compile.cc:5: error: no match for 'operator*' in 'y * z' 
template_compile.cc:5: error: no match for 'operator*' in 'x * y' 
这个错误信息很长，不过可以把它拆开来看。第一行告诉你哪个模板函数出了问题（compute_equation）；
第二行告诉你哪一行代码在尝试使用该模板函数。这通常是你实际中要到代码中去看的那一行。
（顺便说一下，词语“instantiated from here”只是在说“这是你尝试使用模板的地方”。
在这个例子中，你尝试使用模板参数vector<int>去创建一个compute_equation的实现。 )
下面的两行确切地告诉你为什么编译失败。在这个例子中，它 说“no match for 'operator*' in 'x * y'”。
这句话的意思是它无法弄清怎么去把x和y相乘（vector 没有定义 * 操作符 ) 。
由于两个变量都是 vector ，你可以猜测这就意味着vector不支持乘法操作。
你可能会疑惑为什么编译器不在vector相加的时候报错。其实它会的，只是它还没能走到那一步。
编译器看到了乘法操作存在问题并且在到达相加之前就退出了。
vector换句话说，表现得不像一个数字――它没有“看上去像个数字， 走起来像个数字，或者说起话来像个数字”。
在使用一个模板函数的时 候，编译器会去决定所给定的类型能不能在模板内部正常工作。
它不关心别的，除了所给的类型是否支持需要调用的方法和操作。它只要“看上去像”一个可以正常工作的类型。
鸭子类型和多态函数的工作方式很不一样；一个多态函数接收一个指向接口类的指针并且只能够调用那个接口类里定义的方法。
对于模板来说，模板参数不需要遵循预先定义的接口。只要是模板类型，那个类型的变量就能以函数所写的方式使用，函数会成功编译。
换句话说，如果模板类型“看起来像个鸭子，走起路来像个鸭子，而且叫起来也像个鸭子”，我们的模板就会把它当做鸭子来处理。
正常情况下，模板很少期待模板参数传入水生动物的描述，但是希望你现在明白为什 么我们要说模板使用鸭子类型，
重要之处就是传入的类型要能支持让模板正常工作的那些方法。
29.2 模板类
模板类通常是创建如vector和map这样的类的库函数作者用到的东西。 
但是日常编程也可以从创建更加通用的代码中获得好处。不要仅仅因为你会用模板就到处去使用模板，
要注意寻找机会移除那些只有处理的类型不同，而其他都一样的类。
模板类没有模板方法使用得普遍， 但是知道怎么使用模板类很有好处――比如当你想要实现自己定制的数据结构时。
声明一个模板类和声明一个模板函数很像。
举个例子，可以创建一个小型的类来封装一个数组：
在编程中，封装这个术语使用的时候通常是，一个函数调用另一个函数来实现大部分的功能，
但是外围的函数同时又去做一些不重要的想输出日志或者错误检查这样的额外工作。
在这个例子中，主方法是用来实现外围方法的，而外围函数就可以说是封装了主方法。
template <typename T>
class ArrayWrapper
{
private:
    T *_p_mem;
};
就像写模板函数一样，一开始我们使用template关键字声明将要引入 一个模板，然后在后面加上模板参数列表。
这个例子中只有一个模板参数T。我们在需要使用用户给定的类型的地方都用T，就像使用模板函数一样。
为模板类定义一个函数的时候，你必须也要使用模板语法。假设要在ArrayWrapper模板中添加一个构造函数：
template <typename T>
class ArrayWrapper
{
public:
    ArrayWrapper (int size);
private:
    T *_p_mem;
};
template <typename T>
ArrayWrapper<T>::ArrayWrapper (int size)     : _p_mem( new T[ size ] )
{
}
我们以相同的模板前奏为开始，再一次声明了模板参数。
和之前唯一的不同就是类名包含了模板（ArrayWrapper<T>），明确地表示了这是模板类的一部分，
而不是一个叫做ArrayWrapper的非模板类的模板函数。
在这个方法实现中，我们可以用模板参数来代替调用者所要提供的类型，就像写模板函数时一样。
和模板函数有所不同的是，模板类中的函数的调用者永远都不需要提供模板参数――参数是从初始的模板类型声明那里获取的。
举个例子，当获取存储整型的vector的大小时， 你不需要写vec.size<int>()或者vec<int>.size();，只要写vec.size()。
29.3 使用模板的一些小技巧
通常先为一个特定的类型写一个类，然后再用模板重写代码会更简单一些。
举个例子，你可能声明一个使用整型的类，然后从这个声明想出一个通用的模板。
这种方式不是必须的，如果你能很熟练地写模板的话就不需要用这个方式。
但是在写自己的第一个模板时，它可以帮你把模板语法方面的问题从算法的问题中分离开来。
举个例子，来看一个起初只能处理整型的计算器类：
class Calc
{
public:
    Calc ();
    int multiply (int x, int y);
    int add (int x, int y);
};

Calc::Calc () {}

int Calc::multiply (int x, int y)
{
    return x * y;
}

int Calc::add (int x, int y)
{
    return x + y;
}
这个小巧的类能很好地处理整型。现在可以把它转成一个模板，那样就能创建非整型数据的计算器：
#include <iostream>

using namespace std;

template <typename Type>
class Calc
{
public:
    Calc ();
    Type multiply (Type x, Type y);
    Type add (Type x, Type y);
};

template <typename Type>
Calc<Type>::Calc () {}

template <typename Type>
Type Calc<Type>::multiply (Type x, Type y)
{
    return x * y;
}

template <typename Type>
Type Calc<Type>::add (Type x, Type y)
{
    return x + y;
}
int main ()
{
    Calc<int> c;
    cout << c.multiply(3, 6) << '\n';
    cout << c.add(3, 6) << '\n';

    return 0;
}
显示结果如下
18
9

示例代码73：calc.cpp
这样的转换需要做几处修改：我们得声明有个模板类型叫做Type：
template <typename Type>
然后要在类以及函数定义之前加上这个模板声明：
template <typename Type>
class Calc 
 
template <typename Type>
int Calc::multiply (int x, int y)
同样需要修改各个函数的定义来表明它是属于一个模板类：
 template <typename Type>
int Calc<Type>::multiply (int x, int y);

最后，我们要把所有int的地方都换成Type：
template <typename Type>
Type Calc::multiply (Type x, Type y);
当你习惯了模板之后，把一个为特定类型而定义的类转换成一个很多类型都可以使用的模板类就是一个机械式地转换了。
随着时间的推移，你会熟练地使用模板的语法来从头写模板类而不需要任何的中间过渡代码。
要小心避免过度范型化。例如，你有个循环计数器也是整型的，你 不需要改变它的类型。
模板和头文件
到目前为止我们看到的都是直接写在.cpp文件中的模板。如果想要把模板声明放到一个头文件中会怎样呢？
问题在于使用模板函数（或者模板类）的代码对于每一次模板函数的调用（以及每次调用模板类的成员函数）都必须能够访问整个模板的定义。
这和普通的函数工作原理很不一样，普通函数只要求调用者知道函数的声明。
举个例子，假如你把Calc类放到了它自己的头文件中，你还得把构造函数的整个定义跟add方法也放到头文件中，而不是像平时一样把这些定义放到.cpp文件中。
否则，任何使用Calc的尝试都会失败。
模板的这个让人遗憾的性质和模板被编译的方式有关；编译器通常在第一次解析它们的时候会忽略这些模板。
只有在你带着一个特定的具体类型来使用模板的时候（写Calc<int>的时候）编译器才会以这个特定的类型（在这个示例中就是int）来为模板生成代码。
为了生成代码，大部分的编译器需要可以生成代码的模板。所以，你必须在每个使用模板的文件中包含所有的模板代码。
再有就是，编译含有模板的文件时，你可能不会知道模板中的语法错误，直到第一次有人尝试使用这个模板。
当你创建一个模板类的时候，通常最简单的方式是单纯地把模板所有的定义都放到头文件中。
使用一个不同于.h的扩展名来标明文件是个模板，这样会起到一定的帮助，比如，使用.hxx。 
29.4 模板小结
模板让你可以创建通用的代码――可以服务于任何类型的代码，而不是被局限于，比如说，整型。
模板被频繁地用来实现C++函数库（例如标准模板库）。你可能会发现不是经常需要写模板代码，但是要留意那些结构相同而只是处理的数据类型不同的代码。
举个例子，你可能会发现自己在写遍历不同类型的vector的代码，而且所执行的操作对每一个vector都是一样的。
实际上，很多时候你需要模板，都是由于要处理另一个已经模板化的类型，例如STL的那些容器。
举个例子，你可能写了个函数来把vector中的数值加起来，还有一个函数把vector中的字符串拼接起来。
这两个函数都有相同的基础结构，遍历一个vector以及使用+操作符，但是它们操作不同的数据类型。
如果你见到这样的代码，遵循“不要重复自己”的原则。如果你写代码为两个不同的类型做同样的事，那就使用一个模板来代替写两种不同的实现吧。
诊断模板的错误信息
模板不好的一面就是大部分的编译器在你误用模板时都会给出难以理解的错误信息――哪怕模板不是你自己写的（比如说，这可能发生在使用STL的时候）。
你可能因为一个失误导致被错误信息刷屏。模板错误信息很难读懂是因为它们把模板参数扩展成它们完整的类型了 ――甚至是你通常不会去使用的模板参数
（因为它们被当成了默认参数）。
举个例子，看看这个貌似无辜的vector声明吧：
vector<int, int> vec;
这句声明有个小小的问题――它应该只有一个模板参数。不过你编译它的时候，会发现有超多的错误：
到底出了什么状况？是谁在搞鬼，是谁故意给出这个错误信息的呢？ 
问题是这样的：vector有第二个参数，它是个默认的模板参数――正常情况下编译器自动提供它。
但是当你填入第二个int的时候，编译器会尝试使用int来作为第二个模板参数，然而这个参数又不能是个int。
编译器实际上在错误列表开始的附近告诉你：
error: 'int' is not a class, struct, or union type
举个例子，如果有这样的代码：
template <typename T>
class Foo
{
    Foo ()
    {
        T x;
        x.val = 1;
    }
};
那么T就不能是个整型，因为x（T类型的）必须有个字段叫做val而整型根本没有任何字段，它们也就当然不存在叫做val的字段了。
如果这么写：
Foo<int> a;
代码就会编译失败。
这里又是鸭子类型（参见 29.1.2节）――模板并不在意给它的确切类型，但是它在意所给的类型是否“适用于”代码。
在这个例子中，一个整型无法支持“x.val”的语法，编译器没有让它通过。
vector模板对于它的第二个参数有个相似的约束――它需要一个能够比基础的整型支持更多功能的类型。
所有的错误都是在抱怨，从很多方面来判断，int在这里是非法的类型！
面对着这么一大堆文字时，通常最好是从头开始查看错误信息并每次去尝试修复一个错误。我会略过别的信息直到我看到“error”的地方。
好了，看起来好多了，对吧？只有几行了――很像我们之前关于鸭子类型的一节中看到的（参见29.1.2节 ) 。这个我们能处理！
我们从头到尾看一下这个简单的错误信息。注意，第一行说"In instantiation of 'std::_Vector_base<int, int>'"
表示“当尝试带着这一系列参数来编译模板的时候”。
这个错误表示用那些参数来创建模板时出了问题（Vector_base是个用来实现vector的辅助类 ) 。 
下面一行表示Vector_bae模板编译失败是因为一个创建vector<int, int>的尝试，
并且它告诉你这个尝试来自template_err.cc的第6行；template_err.cc是我们自己的代码，所以现在知道导致错误的代码了。
找出有问题的那行代码通常是弄清楚出了什么错误的第一步。
通常你只需看着自己的代码就可以辨别出什么地方出了错。
如果第一眼看上 去不是很明显，你可以继续追踪初始化的列表，直到找到真正的错误信息：
error: 'int' is not a class, struct, or union type。
这句话表明编译器希望你给的int能是一个类或者结构体，而不是语言自带的像int这样的类型。
vector应当能够保存任意的类型，所以这暗示给vector的模板参数存在问题。
到了这一步，你应当再次检查如何声明一个vector，然后会看到其实只需要一个模板参数。
既然对第一个问题有了诊断结果，是时候修正它并且重新编译了。
正常情况下你要一次处理至少几个编译错误，但是，对于模板而言第一个错误通常会导致其他所有的错误。
最好一次修正一个问题，这样它们就不会再让你头疼了，然后你再接着修正其他的。
在这个例子里，超过一页的错误信息中，每个错误都是由于添加了第二个int模板参数。
问答题
1.什么时候应该使用模板？
A. 想要节省时间的时候
B. 想要代码运行得更快的时候
C. 需要为不同类型多次写相同代码的时候
D. 需要确保之后可以重用代码的时候

C
2.你什么时候需要为模板参数提供一个类型？
A. 总是需要
B. 只有在声明一个模板类的实例的时候
C. 只有类型无法推断出来的时候
D. 对于模板函数，只有在类型无法推断的时候，对于模板类，一直都需要

D
3.编译器如何辨别一个模板参数可以用于一个给定的模板？
A. 它会实现一个特定的C++接口
B. 声明模板的时候你必须指定约束条件
C. 它会尝试使用模板参数；如果参数类型支持所有需要的操作，编译器就会接受它
D. 在声明模板的时候你必须列出所有合法的模板类型

C
4.把模板类放在头文件中和把一个常规的类放在头文件中有什么不同？
A. 没什么区别
B. 常规类不能在头文件中定义它的任何方法
C. 模板类必须把所有的方法在头文件中定义
D. 模板类不需要有对应的.cpp文件，但是常规的类需要有

C
5.什么时候应该把函数写成模板函数？
A. 一开始的时候――你永远不会知道什么时候需要对不同的类型使用 相同的逻辑，所以你应当总是写模板方法
B. 只有在你无法把所给的类型转换成函数当前需要的类型的时候
C. 当你写了几乎一样的逻辑，但是处理的是一个与第一个函数所使用的类型有着相似特性的不同的类型的时候
D. 当两个函数做“几乎是”相同的事，而且你可以通过几个额外的 Boolean 参数就能把逻辑修改过来的时候

C
6.你什么时候会知道所写模板存在的大部分错误？
A. 在你编译模板的时候
B. 在链接的阶段
C. 在你运行代码的时候
D. 在你第一次编译初始化模板的代码时

D
实践题
1.写个函数接收一个vector并且把vector中所有值求和，不管vector中存储的是什么类型的数值。

#include <iostream>
#include <string>
#include <vector>

using namespace std;

template <typename  Type>
class VectorSum
{
public:
    VectorSum();
    Type sum(const std::vector<Type> &vector);
};

template <typename Type>
VectorSum<Type>::VectorSum()
{
}

template <typename Type>
Type VectorSum<Type>::sum(const std::vector<Type> &vector)
{
    Type sum = 0;
    for (typename std::vector<Type>::const_iterator itr = vector.begin(), end = vector.end(); itr != end; ++itr)
    {
        sum += *itr;
    }

    return sum;
}

int main()
{
    vector<int> vectorInt;

    vectorInt.push_back(5);
    vectorInt.push_back(4);
    vectorInt.push_back(3);
    vectorInt.push_back(2);
    vectorInt.push_back(1);
    vectorInt.push_back(0);

    VectorSum<int> calcInt;

    cout << "Integer type:\n";
    cout << "Sum(vector) = " << calcInt.sum(vectorInt) << '\n';

    vector<double> vectorDbl;

    vectorDbl.push_back(5.5);
    vectorDbl.push_back(4.4);
    vectorDbl.push_back(3.3);
    vectorDbl.push_back(2.2);
    vectorDbl.push_back(1.1);
    vectorDbl.push_back(0);

    VectorSum<double> calcDbl;

    cout << "Double type:\n";
    cout << "Sum(vector) = " << calcDbl.sum(vectorDbl) << '\n';
}
显示结果如下
Integer type:
Sum(vector) = 15
Double type:
Sum(vector) = 16.5

2.修改在第24章中实现的vector替代类，把它变成一个模板让它可以存储任意的类型。

#include <iostream>
#include <string>
#include <typeinfo>

using namespace std;

template <typename  Type>
class VectorOf
{
public:
    VectorOf();
    VectorOf(int initialSize);
    VectorOf(const VectorOf<Type> &other);
    ~VectorOf();

    Type *Get(int index) const;
    void Set(int index, Type value);

    void PushBack(Type value);
    void PushFront(Type value);
    void Clear();
    int size() const;

    VectorOf<Type> &operator=(const VectorOf<Type> &other);
private:
    Type *_values;
    int _valuesLengthUsed;
    int _valuesLength;

    void CopyValues(const VectorOf<Type> &other);
    static Type *growArray(Type *p_values, int *size);
};

template <typename Type>
VectorOf<Type>::VectorOf()
{
    _valuesLength = 32;
    _valuesLengthUsed = 0;
    _values = new Type[_valuesLength];
}

template <typename Type>
VectorOf<Type>::VectorOf(int initialSize)
{
    if (initialSize < 32)
    {
        initialSize = 32;
    }
    _valuesLength = initialSize;
    _valuesLengthUsed = 0;
    _values = new Type[_valuesLength];
}

template <typename Type>
VectorOf<Type>::VectorOf(const VectorOf<Type> &other)
{
    CopyValues(other);
}

template <typename Type>
VectorOf<Type>::~VectorOf()
{
    if ( _values != nullptr )
    {
        delete[] _values;
    }
}

template <typename Type>
Type *VectorOf<Type>::Get(int index) const
{
    if ( (index < 0) || (index >= _valuesLengthUsed) )
    {
        return nullptr;
    }

    return &_values[index];
}

template <typename Type>
void VectorOf<Type>::Set(int index, Type value)
{
    if ( (index < 0) || (index >= _valuesLengthUsed) )
    {
        return;
    }

    _values[index] = value;
}

template <typename Type>
void VectorOf<Type>::PushBack(Type value)
{
    if (_valuesLengthUsed >= _valuesLength)
    {
        _values = growArray(_values, &_valuesLength);
    }
    _values[_valuesLengthUsed] = value;
    _valuesLengthUsed++;
}

template <typename Type>
void VectorOf<Type>::PushFront(Type value)
{
    if (_valuesLengthUsed >= _valuesLength)
    {
        _values = growArray(_values, &_valuesLength);
    }

    for (int i = _valuesLengthUsed; i > 0; i--)
    {
        _values[i] = _values[i - 1];
    }
    _values[0] = value;
    _valuesLengthUsed++;
}

template <typename Type>
void VectorOf<Type>::Clear()
{
    _valuesLengthUsed = 0;
}

template <typename Type>
int VectorOf<Type>::size() const
{
    return _valuesLengthUsed;
}

template <typename Type>
VectorOf<Type> & VectorOf<Type>::operator=(const VectorOf<Type> & other)
{
    if( this == &other)
    {
        return *this;
    }
    if (_values != nullptr)
    {
        delete[] _values;
        _values = nullptr;
    }

    CopyValues(other);

    return *this;
}

template <typename Type>
void VectorOf<Type>::CopyValues(const VectorOf<Type> &other)
{
    _valuesLength = other._valuesLength;
    _values = new Type[_valuesLength];

    _valuesLengthUsed = other._valuesLengthUsed;
    for (int i = 0; i < _valuesLengthUsed; i++)
    {
        Type *value = other.Get(i);
        if (value != nullptr)
        {
            _values[i] = *value;
        }
    }
}

template <typename Type>
Type *VectorOf<Type>::growArray(Type *p_values, int *size)
{
    int oldSize = *size;
    *size *= 2;

    Type *p_newvalues = new Type[*size];
    for (int i = 0; i < oldSize; i++)
    {
        p_newvalues[i] = p_values[i];
    }

    delete[] p_values;

    return p_newvalues;
}

template <typename Type>
void print(VectorOf<Type> &vector)
{
    if (vector.size() <= 0)
    {
        cout << "Vector is empty.\n";
        return;
    }
    cout << "Vector Values...\n";
    int index = 0;
    Type *temp;
    while ( ( temp = vector.Get(index) ) != nullptr )
    {
        cout << *temp << '\n';
        index++;
    }
    cout << '\n';
}


template <typename Type>
void run(Type *defaultInitializationValues, const Type *sizedValues, int sizedSize, Type value1, Type value2, Type value3, Type value4)
{
    cout << "Testing Template VectorOf<T> class of T = " << typeid(Type).name() << '\n';

    VectorOf<Type> basicVector;
    for (int i = 0; i < 32; i++)
    {
        basicVector.PushBack(defaultInitializationValues[i]);
    }
    cout << "Basic Vector\n";
    print(basicVector);

    VectorOf<Type> sizedVector(sizedSize);
    for (int i = 0; i < sizedSize; i++)
    {
        sizedVector.PushBack(sizedValues[i]);
    }
    cout << "Vector Sized to " << sizedSize << '\n';
    print(sizedVector);

    VectorOf<Type> copiedVector(sizedVector);
    cout << "Copied Vector Upon Initialization from Sized Vector\n";
    print(copiedVector);

    VectorOf<Type> copiedVectorOperator;
    copiedVectorOperator = basicVector;
    cout << "Copied Vector Operator from Basic Vector\n";
    print(copiedVectorOperator);

    cout << "Adding " << value1 << " to the end of Sized Vector\n"; // This should also resize the vector.
    sizedVector.PushBack(value1);

    cout << "Adding " << value2 << " to the end of Sized Vector\n"; // This should not resize the vector.
    sizedVector.PushBack(value2);
    print(sizedVector);

    cout << "Adding " << value3 << " to the beginning of Copied Vector\n"; // This should also resize the vector.
    copiedVector.PushFront(value3);

    cout << "Adding " << value4 << " to the beginning of Copied Vector\n"; // This should not resize the vector.
    copiedVector.PushFront(value4);
    print(copiedVector);

    cout << "Clearing Basic Vector\n";
    basicVector.Clear();
    print(basicVector);
}

int main()
{
    int arraySize = 10;

    int *defaultInitializationValuesInt = new int[32];
    for (int i = 0; i < 32; i++)
    {
        defaultInitializationValuesInt[i] = i + 1;
    }

    int *sizedValuesInt = new int[arraySize];
    for (int i = 0; i < arraySize; i++)
    {
        sizedValuesInt[i] = i * i;
    }

    int valueInt1 = 50;
    int valueInt2 = -12;
    int valueInt3 = -666;
    int valueInt4 = 999;

    run(defaultInitializationValuesInt, sizedValuesInt, arraySize, valueInt1, valueInt2, valueInt3, valueInt4);

    double counter = 0;
    double *defaultInitializationValuesDbl = new double[32];
    for (int i = 0; i < 32; i++)
    {
        defaultInitializationValuesDbl[i] = counter + (1.3 / (counter + 1));
        counter++;
    }

    counter = 0;
    double *sizedValuesDbl = new double[arraySize];
    for (int i = 0; i < arraySize; i++)
    {
        sizedValuesDbl[i] = counter * (counter / (counter + 1)) + 0.1;
        counter++;
    }

    double valueDbl1 = 50.342;
    double valueDbl2 = -12.99;
    double valueDbl3 = -666.99;
    double valueDbl4 = 999.66;

    run(defaultInitializationValuesDbl, sizedValuesDbl, arraySize, valueDbl1, valueDbl2, valueDbl3, valueDbl4);
}
显示结果如下
Testing Template VectorOf<T> class of T = i
Basic Vector
Vector Values...
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32

Vector Sized to 10
Vector Values...
0
1
4
9
16
25
36
49
64
81

Copied Vector Upon Initialization from Sized Vector
Vector Values...
0
1
4
9
16
25
36
49
64
81

Copied Vector Operator from Basic Vector
Vector Values...
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32

Adding 50 to the end of Sized Vector
Adding -12 to the end of Sized Vector
Vector Values...
0
1
4
9
16
25
36
49
64
81
50
-12

Adding -666 to the beginning of Copied Vector
Adding 999 to the beginning of Copied Vector
Vector Values...
999
-666
0
1
4
9
16
25
36
49
64
81

Clearing Basic Vector
Vector is empty.
Testing Template VectorOf<T> class of T = d
Basic Vector
Vector Values...
1.3
1.65
2.43333
3.325
4.26
5.21667
6.18571
7.1625
8.14444
9.13
10.1182
11.1083
12.1
13.0929
14.0867
15.0813
16.0765
17.0722
18.0684
19.065
20.0619
21.0591
22.0565
23.0542
24.052
25.05
26.0481
27.0464
28.0448
29.0433
30.0419
31.0406

Vector Sized to 10
Vector Values...
0.1
0.6
1.43333
2.35
3.3
4.26667
5.24286
6.225
7.21111
8.2

Copied Vector Upon Initialization from Sized Vector
Vector Values...
0.1
0.6
1.43333
2.35
3.3
4.26667
5.24286
6.225
7.21111
8.2

Copied Vector Operator from Basic Vector
Vector Values...
1.3
1.65
2.43333
3.325
4.26
5.21667
6.18571
7.1625
8.14444
9.13
10.1182
11.1083
12.1
13.0929
14.0867
15.0813
16.0765
17.0722
18.0684
19.065
20.0619
21.0591
22.0565
23.0542
24.052
25.05
26.0481
27.0464
28.0448
29.0433
30.0419
31.0406

Adding 50.342 to the end of Sized Vector
Adding -12.99 to the end of Sized Vector
Vector Values...
0.1
0.6
1.43333
2.35
3.3
4.26667
5.24286
6.225
7.21111
8.2
50.342
-12.99

Adding -666.99 to the beginning of Copied Vector
Adding 999.66 to the beginning of Copied Vector
Vector Values...
999.66
-666.99
0.1
0.6
1.43333
2.35
3.3
4.26667
5.24286
6.225
7.21111
8.2

Clearing Basic Vector
Vector is empty.


3.写个搜索方法，接收一个任意类型的vector以及一个任意类型的值，如果值在vector中就返回true，否则返回false。

#include <iostream>
#include <string>
#include <vector>

using namespace std;

template <typename Type>
bool isInVector(const Type &searchItem, const vector<Type> &vectorToSearch)
{
    for (typename vector<Type>::const_iterator itr = vectorToSearch.begin(), end = vectorToSearch.end(); itr != end; ++itr)
    {
        if (searchItem == *itr)
        {
            return true;
        };
    }
    return false;
}

string isInVectorToString(int result)
{
    string stringResult;
    result == 0 ? stringResult = "False" : stringResult = "True";
    return stringResult;
}

int main()
{
    vector<int> vectorInt;

    vectorInt.push_back(5);
    vectorInt.push_back(4);
    vectorInt.push_back(3);
    vectorInt.push_back(2);
    vectorInt.push_back(1);
    vectorInt.push_back(0);

    cout << "Integer type:\n";
    for (int i = 0; i < 6; i++)
    {
        cout << vectorInt[i] << '\n';
    }
    int searchTrueInt = 2;
    int seachFalseInt = 6;
    cout << "Is " << searchTrueInt << " in the list? Answer: " << isInVectorToString(isInVector(searchTrueInt, vectorInt)) << '\n';
    cout << "Is " << seachFalseInt << " in the list? Answer: " << isInVectorToString(isInVector(seachFalseInt, vectorInt)) << '\n';
    cout << endl;

    vector<double> vectorDbl;

    vectorDbl.push_back(5.5);
    vectorDbl.push_back(4.4);
    vectorDbl.push_back(3.3);
    vectorDbl.push_back(2.2);
    vectorDbl.push_back(1.1);
    vectorDbl.push_back(0);

    cout << "Double type:\n";
    for (int i = 0; i < 6; i++)
    {
        cout << vectorDbl[i] << '\n';
    }

    double searchTrueDbl = 3.3;
    double seachFalseDbl = 5.6;
    cout << "Is " << searchTrueDbl << " in the list? Answer: " << isInVectorToString(isInVector(searchTrueDbl, vectorDbl)) << '\n';
    cout << "Is " << seachFalseDbl << " in the list? Answer: " << isInVectorToString(isInVector(seachFalseDbl, vectorDbl)) << '\n';
    cout << endl;
}
显示结果如下
Integer type:
5
4
3
2
1
0
Is 2 in the list? Answer: True
Is 6 in the list? Answer: False

Double type:
5.5
4.4
3.3
2.2
1.1
0
Is 3.3 in the list? Answer: True
Is 5.6 in the list? Answer: False

4.实现一个排序函数，接收一个任意类型的vector然后根据自然顺序给vector中的值排序（你通过<或>得出的顺序 ) 。

#include <iostream>
#include <string>
#include <vector>

using namespace std;

template <typename Type>
int compare(const Type &itemA, const Type &itemB)
{
    if (itemA < itemB)
    {
        return -1;
    }
    else if (itemA > itemB)
    {
        return 1;
    }
    return 0;
}

template <typename Type>
int getMinElementIndex(const vector<Type> &vectorToSearch)
{
    int minElementIndex = 0;
    Type minElement = vectorToSearch[0];
    int vectorSize = vectorToSearch.size();
    for (int i = 0; i < vectorSize; i++)
    {
        int compareResult = compare(vectorToSearch[i], minElement);
        if (compareResult == -1)
        {
            minElement = vectorToSearch[i];
            minElementIndex = i;
        }
    }
    return minElementIndex;
}

template <typename Type>
vector<Type> sortVector(const vector<Type> &vectorToSort)
{
    vector<Type> sortedVector;
    vector<Type> unsortedVector(vectorToSort);
    while (unsortedVector.size() != 0)
    {
        int minElementIndex = getMinElementIndex(unsortedVector);
        sortedVector.push_back(unsortedVector[minElementIndex]);
        unsortedVector.erase(unsortedVector.begin() + minElementIndex);
    }
    return sortedVector;
}

int main()
{
    vector<int> vectorInt;

    vectorInt.push_back(2);
    vectorInt.push_back(5);
    vectorInt.push_back(4);
    vectorInt.push_back(3);
    vectorInt.push_back(0);
    vectorInt.push_back(1);

    cout << "Integer type:\n";
    for (int i = 0; i < vectorInt.size(); i++)
    {
        cout << vectorInt[i] << '\n';
    }
    cout << endl;

    cout << "Sorting Vector:\n";
    vector<int> vectorIntSorted = sortVector(vectorInt);
    for (int i = 0; i < vectorIntSorted.size(); i++)
    {
        cout << vectorIntSorted[i] << '\n';
    }
    cout << endl;

    vector<double> vectorDbl;

    vectorDbl.push_back(1.1);
    vectorDbl.push_back(5.5);
    vectorDbl.push_back(2.2);
    vectorDbl.push_back(0);
    vectorDbl.push_back(4.4);
    vectorDbl.push_back(3.3);
    cout << "Double type:\n";

    for (int i = 0; i < vectorDbl.size(); i++)
    {
        cout << vectorDbl[i] << '\n';
    }
    cout << endl;

    cout << "Sorting Vector:\n";
    vector<double> vectorDblSorted = sortVector(vectorDbl);
    for (int i = 0; i < vectorDblSorted.size(); i++)
    {
        cout << vectorDblSorted[i] << '\n';
    }
    cout << endl;

    vector<string> vectorStr;

    vectorStr.push_back("Value = 2.2");
    vectorStr.push_back("Value = 5.5");
    vectorStr.push_back("Value = 4.4");
    vectorStr.push_back("Foo");
    vectorStr.push_back("Value = 3.3");
    vectorStr.push_back("Value = 1.1");
    vectorStr.push_back("Value = 0");
    vectorStr.push_back("Bar");
    cout << "String type:\n";
    for (int i = 0; i < vectorStr.size(); i++)
    {
        cout << vectorStr[i] << '\n';
    }
    cout << endl;

    cout << "Sorting Vector:\n";
    vector<string> vectorStrSorted = sortVector(vectorStr);
    for (int i = 0; i < vectorStrSorted.size(); i++)
    {
        cout << vectorStrSorted[i] << '\n';
    }
    cout << endl;
}
显示结果如下
Integer type:
2
5
4
3
0
1

Sorting Vector:
0
1
2
3
4
5

Double type:
1.1
5.5
2.2
0
4.4
3.3

Sorting Vector:
0
1.1
2.2
3.3
4.4
5.5

String type:
Value = 2.2
Value = 5.5
Value = 4.4
Foo
Value = 3.3
Value = 1.1
Value = 0
Bar

Sorting Vector:
Bar
Foo
Value = 0
Value = 1.1
Value = 2.2
Value = 3.3
Value = 4.4
Value = 5.5

第四部分 其他
你已经了解了编写有趣的、大规模的程序所需要的工具。还有几个主题，虽然有用，但不适合在本书中叙述；
这些主题包括从命令行得到参数以及执行良好的输入和输出格式化。
这些主题相对于算法逻辑而言，与用户界面程序的相关性更大，但它们同样重要。只有与用户交流，程序才会变得非常有趣！
你可以按任意顺序阅读这部分的主题，这取决于想要完成的任务。
你甚至应该在完成本书其他部分之前，先读这部分的一些内容，尤其是你在课堂学习的部分涉及这些主题时。

第30章 使用iomanip格式化输出
“讨厌”的终端用户通常要求你创建干净整齐的格式化输出。（下一件事你知道的，就是让程序能够正常工作！）
在C++里面，你可以使用iomanip头文件里的函数配合cout创建漂亮的格式化输出。
30.1 处理空间问题
最常见的格式问题是间距处理不当。良好格式化的输出使用的间隔看起来刚刚好。列的文本不会太长或太短，一切都对齐得当。
所以，让我们看看如何做到吧！
30.1.1 使用setw设置字段宽度
setw函数使你能够通过插入操作符设置下一个输出的最小宽度。
如果下一个输出小于最小宽度，就使用空格填充输出。
如果输出比最小宽度长，什么也不做――重要的是，输出是不会被截断的。
实际使用setw有点奇怪――你调用该函数并把数值传递到cout：
#include <iostream>
#include <iomanip>

using namespace std;

int main()
{
    cout << setw( 10 ) << "ten" << endl;
    cout << setw( 10 ) << "ten" << "four" << "four";
}
显示结果如下
       ten
       tenfourfour
示例代码74：setw.cpp
如果你调用setw但是没有把它传递给cout，无论如何都没有任何效果。
正如你从示例程序中看到的，对于setw的调用仅仅影响紧接着的下一个输出。
你会发现，在默认情况下，字符串是右对齐的（填充是放在字符串的左边）。
换而言之，字符串以填充字符作为前缀。你可以通过传递对齐的方向left或者right到cout中，来设置想要的输出对齐方式。
这个示例程序将文本左对齐，而不是右对齐，使输出更加可读。
#include <iostream>
#include <iomanip>

using namespace std;

int main()
{
    cout << setw( 10 ) << "ten" << endl;
    cout << setw( 10 ) << "ten" << "four" << "four"<< endl;
    cout << setw( 10 ) << left << "ten" << "four" << "four"<< endl;
}
显示结果如下
       ten
       tenfourfour
ten       fourfour

示例代码75：setw_left.cpp
setw允许你在运行时决定输出的列的宽度。例如，为了显示几列的数据，你可以找出每一列最宽字符串，填补该列的每个条目，
这样每一个条目都比该列最长的元素稍宽一点。
30.1.2 改变填充字符
有些时候，你可能不希望使用空格填充。你可以调用setfill改变填充字符。setfill的工作模式类似setw，你也可以直接传递给cout。
如果我们还是使用原先填充的例子，但添加一个破折号的setfill：
#include <iostream>
#include <iomanip>

using namespace std;

int main()
{
    cout << setfill( '-' )<< setw( 10 ) << "ten" << endl;
    cout << setfill( '-' )<< setw( 10 ) << "ten" << "four" << "four"<< endl;
    cout << setfill( '-' )<< setw( 10 ) << left << "ten" << "four" << "four"<< endl;
}
显示结果如下
-------ten
-------tenfourfour
ten-------fourfour

30.1.3 永久改变设置
你也可以使用cout的fill成员函数来全局改变填充字符。例如，这个代码：
cout.fill( '-' ); 
cout << setw( 10 ) << "A" << setw( 10 ) << "B" << setw( 10 ) << "C" << endl; 
将输出：
---------A---------B---------C
fill方法返回之前的填充字符，这样之后你就可以恢复它。如果你意欲避免多次setfill的调用，那么它的返回是可以利用的。例如：
#include <iostream>
#include <iomanip>

using namespace std;

int main()
{
    cout << setfill( '-' ) << setw( 10 ) << "ten" << endl;
    cout << setfill( '-' ) << setw( 10 ) << "ten" << "four" << "four" << endl;
    cout << setfill( ' ' ) << setw( 10 ) << left << "ten" << "four" << "four" << endl;
    const char last_fill = cout.fill( '-' );
    cout << setw( 10 ) << right << "A" << setw( 10 ) << "B" << setw( 10 ) << "C" << endl;
    cout.fill( last_fill );
    cout << setw( 10 ) << "D" << endl;
}
显示结果如下
-------ten
-------tenfourfour
ten       fourfour
---------A---------B---------C
         D

你可以通过调用cout的setf成员函数永久设置填充文本的对齐。
你可以把标志位传递到setf来设定向左或者向右的功能，使用标志位ios_base::left或者ios_base::right。
setf表示set flag，也就是设置标志位。
cout.setf( ios_base::left );
使用fill，这个访问就可以返回上一个值，以便你之后可能想要恢复它。
试着把上面的对setf的调用添加到之前的例子来看一下格式的不同之处。
30.2 把你的iomanip知识汇总到一起
让我们把上面的一些方法放在一起，并且编写代码使姓和名成为两列，保证这两列对齐良好，就像这样：
我们需要正确的设置列宽，仅仅比每一列最大的元素大一点点。我们可以遍历代码，发现最大的长度，
然后使用setw设置最大长度（选择性地增加一些填充）来展示这些名字。来看看实现它的代码:
#include <iostream>
#include <vector>
#include <iomanip>

using namespace std;

struct Person
{
    Person (const string &firstname, const string &lastname) : _firstname( firstname ), _lastname( lastname )
    {
    }

    string _firstname;
    string _lastname;
};

int main ()
{
    vector<Person> people;

    people.push_back( Person( "Joe", "Smith" ) );
    people.push_back( Person( "Tonya", "Malligans" ) );
    people.push_back( Person( "Jerome", "Noboggins" ) );
    people.push_back( Person( "Mary", "Suzie-Purple" ) );

    int firstname_max_width = 0;
    int lastname_max_width = 0;

    for ( vector<Person>::iterator iter = people.begin();   iter != people.end();   ++iter )
    {
        if ( iter->_firstname.length() > firstname_max_width )
        {
            firstname_max_width = iter->_firstname.length();
        }
        if ( iter->_lastname.length() > lastname_max_width )
        {
            lastname_max_width = iter->_lastname.length();
        }
    }

    for ( vector<Person>::iterator iter = people.begin();   iter != people.end();   ++iter )
    {
        cout << setw( firstname_max_width ) << left << iter->_firstname;
        cout << " ";
        cout << setw( lastname_max_width ) << left << iter->_lastname;
        cout << endl;
    }
}
显示结果如下
Joe    Smith
Tonya  Malligans
Jerome Noboggins
Mary   Suzie-Purple

示例代码76：column_alignment.cpp
30.2.1 输出数字
创建漂亮的输出有时需要正确格式化数字；当输出一个十六进制值， 加一个前缀0x来显示数值的进制就很好。
如果你把小数点后面0的个数与应用程序相适应（例如设置为2，如果在处理与金钱有关的程序）那就更好了。
30.2.2 使用setprecision来设置数值输出的精度 
setprecision函数用来在输出一个数字时设置数字位数的最大值。就像setw，setprecision的返回值应该插入到流中。
实际上，它的使用在各方面都与setw相似。设定数字2.71828输出时总共有3位：
std::cout << setprecision( 3 ) << 2.71828;
调用setprecision将会适当地近似化输出――因此，这里的输出是 2.72，而不是直接缩短变成2.71。
另一方面，如果要输出的是2.713， 那结果将变成2.71。
不像其他插入到流中的命令，setprecision将改变精确度直到下一次它被传递到一个给定的流。所以像这样改变上面的例子：
cout << setprecision( 3 ) << 2.71828 << endl;
cout << 1.412 << endl;
将输出：
2.72
1.41
如果输出的数值在小数点前面比setprecision所提供的精度有更多的数字，你可能会好奇结果会变成什么。
答案取决于是否输出一个浮点数 或整数。整数全部输出，浮点数按照要求位数的数字以科学记数法输出：
cout << setprecision( 2 ) << 1234.0 << endl;
文本中的结果为：
1.2e3
顺便提一下，这个e3指的是10的3次方。
然而
cout << setprecision( 2 ) << 1234 << endl;
文本中的结果则为：
1234

#include <iostream>
#include <iomanip>

using namespace std;

int main()
{
    cout << setprecision( 3 ) << 2.71828 << endl;
    cout << 1.412 << endl;
    cout << setprecision( 2 ) << 1234.0 << endl;
    cout << setprecision( 2 ) << 1234 << endl;
}
显示结果如下
2.72
1.41
1.2e+03
1234

30.2.3 如何处理货币
到现在为止你可能已经注意到，还没有一个好的办法可以输出代表货币的数值，通常你总是想在小数点后有两位数字，但是又不想要任何的近似。
简短的回答是，可能无论如何你都不应该将货币存储为double！原因是double不完全精确，所以可能会引入小的近似误差，不是在这儿就是在那儿去除掉几分钱。
对于大部分应用程序来说，一个更好的存储货币的方式是把总的美分数存储为整数。当你想要显示该数值时，为了更高的精确度，可以除以100来得到美元数，
然后取模来得到美分数，同时分开显示每一个值。
int cents = 1001;   // $10.01
cout << cents / 100 << "." << cents % 100;
当然，创建一个标准的帮助函数来为你进行这种计算，并且创建一个类来存储货币，隐藏使用数值格式的具体细节，这么做是有意义的。
30.2.4 按不同的进制输出
编程的时候，你经常想用八进制或十六进制显示数字。你可以使用setbase函数来完成。当插入一个流时，setbase设置进制为8、10或 者16。举个例子，
cout << "0x" << setbase(16) << 32 << endl;
将输出为：
 0x20
这是32的十六进制写法。注意你可以分别使用dec、oct和hex分别作为setbase(10)、setbase(8)和setbase(16)的缩写来插入到流中。
尽管上面的代码明确的输出0x，你可以使用setiosflags指示cout应该自动显示进制。
如果你把setiosflags(ios_base::showbase)的结果传递到cout，然后十进制将正常显示，
十六进制数字将使用0x前缀，八进制数字将前缀0。
cout << setiosflags( ios_base::showbase ) << setbase( 16 ) << 32 << endl; 
将输出：
 0x20
类似setprecision，由setiosflags产生的变化是永久性的。你可以使用noshowbase作为参数来禁用前缀。
有这些工具在手，你应该能够创建更加合意的输出。

第 31 章 异常和错误报告
构建更大的程序时，将需要一个简洁的方式来处理函数的错误报告。 
报告错误有两个经典方式：使用错误代码和使用异常。
使用错误代码不需要任何新的语言特性，但是这意味着每个函数（可能会失败的） 要返回一个错误代码（或成功的代码），
表示函数运行的结果。这种技术的优点是相对容易理解：
int failableFunction ();

int result = failableFunction();

if ( result != 0 )
{
    cout << "Function call failed: " << result;
}
另一方面，这个错误代码的处理技术具有要求每个函数返回一个错误代码的缺点，即使你想要从函数中获得另一个的值。
为了使函数返回一个计算后的值，你需要使用一个引用或指针参数：
int failableFunction (int &out_val);

int res_val;

int result = failableFunction( res_val );

if ( result != 0 )
{
    cout << "Function call failed: " << result;
}
else
{
    // 利用 res_val 做点儿什么
}
虽然这个方法可行，但是代码再也不能显示你所期待的自然的流程。
另一方面，异常是一个全新的语言特征。异常作用的方式是当一个函数想报告一个错误时，它立即停止执行，并且抛出异常。
当一个异常被抛出时，程序搜索一个异常处理器，它将处理这个异常。
一种理解异常的方式是假设函数立即返回，而且没有返回值。
此外， 不同于返回到函数的调用者，程序的执行返回到可以真正的处理异常的地方。
如果没有可以返回的地方，那么程序将会由于一个未处理的异常而崩溃。
否则，它将返回到处理异常的地方，程序将从该处继续执行。
这允许您编写代码，在失败“返回”到的地方，立即处理所有这些问题。
为了指定一个执行失败的函数应该返回的地方，你可以使用一 个try {} catch (...) {}代码块：
try
{
    // 可能失败并抛出异常的代码
}
catch ( ... )
{
    // 处理异常的地方（也就是，函数返回到的地方） }

任何在try代码块的函数都可以抛出一个异常，该异常随后会在catch代码块得到处理。
可以有许多种异常，每一个类别都不一样，这样使你可以写多个catch区块，每个catch区块处理不同种类的失败。
如果你使用catch ( ... )，正如上面的代码那样，那么任何一个没有被别的更具体的catch区块捕获到的异常都会被那个catch区块处理。
你可以把 ... 想成捕获所有的。
第一个能够处理某异常的catch代码块将处理该异常， 这样如果你想有一个catch all，
你应该把它放在最后，在所有catch代码块的后面：
try
{
    // 可能失败并抛出异常的代码
}
catch ( const FileNotFoundException &e )
{
    // 处理由于找不到文件导致的异常
}
catch ( const HardDriveFullException &e )
{
    // 处理硬盘空间不够导致的异常
}
catch ( ... )
{
    // 处理其他异常的地方
}
异常时释放资源
如果调用的函数抛出了一个异常，不是非要去捕获它，
这个异常将从你的函数传递出来，它可能会在一个更上层的函数中找到一个catch代码块。
只要不需要对异常做出任何反应，这样是完全正确的。
实际上，你通常是不需要做任何事情，因为当函数由于一个异常而退出时，所有的本地对象的析构函数将被调用。例如：
int callFailableFunction ()
{
    const string val( "abc" );
    failableFunction();
}
int main ()
{
    try
    {
        callFailableFunction();
    }
    catch ( ... )
    {
        // 处理异常
    }
}
这里，如果failableFunction抛出一个异常，那么构建于callFailableFunction的val字符串将会被销毁，
所有分配用来存储字符串的资源将会被清理。这一特性称为栈展开（stack unwinding） ，
通过调用在该结构内每个对象的析构函数，各个没有捕捉到异常的堆栈结构都被清除，或者展开。
记住，即使你没有显式地写一个析构函数，这些对象也有默认的析构函数做一些清理工作。
手动在catch区块中清理资源
有时抛出一个异常时，你确实需要手动的清理一些资源。
大部分情况下，你应该尝试写一个保护对象来清理该资源，但是如果没有做这个选择，你可以总是捕捉异常，清理资源，
然后重新抛出异常。例如：
int callFailableFunction ()
{
    const int *val = new int;
    try
    {
        failableFunction();
    }
    catch ( ... )
    {
        delete val;
        throw;
    }
    delete val;
}

int main ()
{
    try
    {
        callFailableFunction();
    }
    catch ( ... )               // 失败处理
    {
    }
}
抛出异常
目前为止，你已经看到了很多有关如何捕捉或者处理异常的例子―― 但是如何创建和抛出异常呢？
创建一个异常类没什么特别的――它只是一个普通的类。你把任何觉得重要的字段都放入该异常中，
并且提供访问方法来读取异常相关的信息。一个典型的异常将有类似这样的接口：
class Exception
{
public:
    virtual ~Exception () = 0;
    virtual int getErrorCode () = 0;
    virtual string getErrorReport () = 0;
};
然后各个具体类型的错误都去继承Exception并且实现这些虚方法：
class FileNotFoundException : public Exception
{
public:
    FileNotFoundException (int err_code, const string &details) : _err_code( err_code ), _details( details ) {}
    virtual ~FileNotFoundException ()     {}

    virtual int getErrorCode ()
    {
        return _err_code;
    }
    virtual string getErrorReport ()
    {
        return _details;
    }

private:
    int _err_code;
    string _details;
};

接着你可以抛出异常，就好像是在构造这个类的一个实例：
throw FileNotFoundException( 1, "File not found" );
从通用的基类继承所有异常的一个优势是这些异常可以被父类捕捉到。例如，可以写：
catch ( const Exception& e ) { }
接着，它将捕捉继承自Exception类的任何异常。
使用一个精心定义的异常层次结构可以让你在单个catch代码块中处理各种各样的错误。
例如，所有输入和输出错误可能会继承叫做IOException的一个类，从而允许所有IO异常作为一个单独的单元来处理。
在具体的情况下，不同的子类需要不同的处理，这段代码仍然可以捕捉IOException的特定子类。
在标准库中构建的原生的C++标准异常父类是std::exception。你不需要以它作为父类来定义自己的异常层次结构，
但是如果要使用标准库，使用std::exception作为一个公共基础类就很有意义，
这样可以使 用它来捕捉程序中抛出的所有异常――包括来自标准库的和自己代码的。
异常抛出说明
好了，现在当遇一个错误你可以抛出一个异常，并且如果知道一个函数将会失败你可以捕获到一个异常。
好吧，但是怎么知道一个函数是否会抛出异常呢？在C++中，你可以通过throw spec来指定你期望你的函数可能抛出的异常。
throw spec是一个出现在函数声明和函数定义末尾的异常的列表，它可能是空的。
在头文件中：
void canFail () throw (FileNotFoundException);
void cannotFail () throw ();
在 cpp 文件中：
void canFail () throw (FileNotFoundException)
{
    throw FileNotFoundException();
}

void cannotFail () throw () { }
异常说明的问题是，它们在编译时是不检查的；它们只有在运行时才被检查。
更糟的是，如果一个函数抛出一个预期之外的异常，程序可能会立即终止。
这意味着你不能真正的依赖于异常说明的准确性，但倒是完全可以期待它们引发你的程序崩溃。
一些工具，例如PCLint（http://www.gimpel.com/html/pcl.htm），提供编译时的异常检查，
并且缓解了人们使用异常说明时遇到的许多问题。在新的C++标准中，也就是C++11，完整的异常说明已经被弃用，
这意味着它们在未来不太可能继续作为语言的一部分了。
异常说明保留着一个功能，就是说明一个函数肯定不会抛出异常， 这有时能够改善性能。
这导致的最终结果是，你必须依靠函数的作者来正确地注明函数可能抛出的异常，
如果写的一个函数会抛出一个异常，需要注明它会抛出一个异常。
异常的好处
异常有两个主要的好处，
一是通过把错误都放进一个单一的catch代码块，而不是必须去做很多的返回码检查，这样简化了错误处理逻辑；
二是通过给出更多信息而不只是一个错误码来改善错误报告。
第一个好处，允许错误在单个catch区块中处理，可以把这样的代码：
if ( funCall1() == ERROR )
{
    // 处理错误
}
if ( funCall2() == ERROR )
{
    // 处理错误
}
if ( funCall3() == ERROR )
{
    // 处理错误
}
转变成：
try
{
    funCall1();
    funCall2();
    funCall3();
}
catch ( const Exception &e )
{
    // 处理错误
}
所有的错误处理代码在一个地方，并且主线使用示例遵循起来非常简单。
第二个好处，允许错误报告附加信息也非常有用。使用一个错误代码，你也只能得到该错误代码。
使用异常时，每个错误可以提供相关的附加信息。例如一个FileNotFoundException可以包含文件的名字。
异常的错误使用
尽管异常是报告错误的神奇工具，但是由于它们具有从函数中立即返回到堆栈上的一个更早的调用者的能力，它们也可能被滥用。
总的来 说，你不应该用异常来处理预期的，非错误的状况。
例如，理论上来讲你可以使用一个异常来报告一个函数执行的结果而不是返回一个值。
但是这样做比返回值更慢（需要一些运行时间成本来处理一个抛出的异常）并且会令人困惑。
正如你在上面见到的，使用异常报告错误简化了函数的主线逻辑。
如果开始使用异常作为你主线逻辑的一部分，那么就失去了那个简化作用。
来看一下你如何用解析器代码的一个片段作为例子，把使用异常的主线使用案例的代码，在不使用异常的情况下重新编写。
解析器是一段代码，它读入一个定义良好的语言――例如HTML――并解释其结构。
通常一个解析器会有解析程序结构中的单个元素的函数。例如， 在HTML中，就可能有函数来解析链接和表格。
一种编写解析器的方式是使每个函数，即parseLink和parseTable报告它们是否能够解析下一段文本，如果不能则使用一个异常：
try
{
    parseLink();
    return;
}
catch ( const ParseException &e )
{
    // 不是链接，试试下一个类型
}
try
{
    parseTable();
    return;
}
catch ( const ParseException &e )
{
    // 不是表格，试试下一个类型
}
这里的问题是，如果第二块文本不是一个链接或一个表，这并不是一个错误，而是正常情况。最好这样写解析器：
if ( expectLink() )
{
    parseLink();
}
else if ( expectTable() )
{
    parseTable();
}
由于HTML通常使用几个字符来表明页面上的下一个元素是什么，你可以轻松地写个方法检查文档的下一个部分是否为链接或表格，
然后就可以使用简单的if语句，而不是复杂的异常。
异常的总结
异常是报告错误的一种简洁的方式，无需因为特定错误处理逻辑把代码弄得乱七八糟。
归功于清理对象的栈展开和析构函数，异常允许你的大部分代码遵循算法的主线逻辑而不要检查错误代码。
抛出异常确实有一些性能影响，所以你应当在错误发生时使用异常， 而不是作为算法控制流程的一部分。
例如，如果读入非法的字符，解析器可能会抛出异常；在遇到属于正常文件格式的字符的情况下，它不应该抛出异常。
这使得哪种情况才是真正的错误变得很清楚。只有在罕见的，有一个真正的问题出现时才运行异常处理，这也保证了代码的最佳性能。
这些情况几乎总是会导致算法的终止，所以如果它们比平时运行得慢也没关系。
在许多真实的程序中，错误处理在产品开发所需的时间上占据着主要的比重，所以当看过了我们在这本书中提到的基础内容后，
你会看到和听到更多关于异常的内容。

第32章 最后的话
现在你已经学到了关于C++的很多知识，但是学习之旅并未结束。说实在的，你真的还处在终生学习编程的开始阶段。
现在你掌握了可以编写很多有趣的、复杂的程序的工具，下一步就是放手去做：构建复杂的系统以及练习实现算法和数据结构。
在你所使用的语言之外还有很多关于编程的话题：如何设计程序、如何设计算法、如何设计用户界面、应该使用哪些类库、
如何组织程序员团队，甚至还有如何确定第一步要构建什么。
换句话说，有许多软件项目需要去做。本书已经涉及这些领域中的一部分，但它们本身都是一些完整的主题，不可小觑。
如同学习任何一门人类语言，除了语言的基础语法和句式还有太多东西要学习。你无法从会说英语直接跳到可以写一部伟大的小说。
同样，你也无法从会写C++直接到可以创建一个操作系统。
但重要的是，现在你已经具备了学习更多概念和思想的基础，这些概念和思想是进入下一个境界所需要的。
下面是关于接下来应当做些什么的建议。
1. 读一些关于软件工程和算法设计方面的书。
像Jon Bentley的《编程珠玑》（Programming Pearls）对一些非编程语言层面的编程知识进行了生动有趣的介绍，
包括基本的算法分析、设计和评估。
2. 多写程序。
从模仿已有的软件开始，写一些已有工具的克隆版本， 学习开发这类工具所需要用到的那些类库。
接着参与到开发中―― 找一个实习职位或者参加一个开源项目。
代码量越大，越可能写出糟糕的代码，但只有通过写糟糕的代码才能最终学会写优秀的代码。
3. 阅读其他方面的知识――不仅仅是编程。
学习软件测试、项目管理、产品管理、市场营销；最终，你对整个软件开发过程理解得越多，
距离成为一名全面的开发者、架构师或总经理就越近。
4. 找到别的程序员，和他们一起工作，向他们学习。这是在大学里上一门课程或者找个实习工作的一个好处。
5. 找一个过来人做导师。书本上的文字无法回答作者没有想过的问题；找到一个像你一样的人可以帮你跳过很多障碍。
要足够恭敬有礼，但是不要怕问问题，也不要怕暴露你所未知的东西。迷惑不解的时候是个学习的好机会。
6. 享受编程。如果你没感受到乐趣，那么可能不想把它当做职业生涯全职去做。保持乐趣，不要去做那些让你不想写程序的无聊的事。
现在本书的阅读行将结束，但你的生涯才刚刚开始。祝你好运！

C++ Primer Plus 第6版 中文版
第1章 预备知识
1.1 C++简介
1.2 C++简史
1.2.1 C语言
1.2.2 C语言编程原理
1.2.3 面向对象编程
1.2.4 C++和泛型编程
1.2.5 C++的起源
1.3 可移植性和标准
1.3.1 C++的发展
1.3.2 本书遵循的C++标准
1.4 程序创建的技巧
1.4.1 创建源代码文件
1.4.2 编译和链接
1.5 总结
本章内容包括：
C语言和C++语言的发展历史和基本原理。
过程性编程和面向对象编程。
C++是如何在C语言的基础上添加面向对象概念的。
C++是如何在C语言的基础上添加泛型编程概念的。
编程语言标准。
创建程序的技巧。
欢迎进入C++世界！这是一种令人兴奋的语言，它在C语言的基础上添加了对面向对象编程和泛型编程的支持，
在20世纪90年代便是最重要的编程语言之一，并在21世纪仍保持强劲势头。
C++继承了C语言高效、简洁、快速和可移植性的传统。
C++面向对象的特性带来了全新的编程方法，这种方法是为应付复杂程度不断提高的现代编程任务而设计的。
C++的模板特性提供了另一种全新的编程方法―泛型编程。
这三件法宝既是福也是祸，一方面让C++语言功能强大，另一方面则意味着有更多的东西需要学习。
本章首先介绍C++的背景，然后介绍创建C++程序的一些基本原则。本书其他章节将讲述如何使用C++语言，
从最浅显的基本知识开始，到面向对象的编程（OOP）及其支持的新术语――对象、类、封装、数据隐藏、多态和继承等，
然后介绍它对泛型编程的支持（当然，随着您对C++的学习，这些词汇将从花里胡哨的词语变为论述中必不可少的术语）。
1.1 C++简介
C++融合了3种不同的编程方式：C语言代表的过程性语言、C++在C语言基础上添加的类代表的面向对象语言、C++模板支持的泛型编程。
本章将简要介绍这些传统。不过首先，我们来看看这种传统对于学习C++来说意味着什么。
使用C++的原因之一是为了利用其面向对象的特性。要利用这种特性，必须对标准C语言知识有较深入的了解，因为它提供了基本类型、运算符、控制结构和语法规则。
所以，如果已经对C有所了解，便可以学习C++了，但这并不仅仅是学习更多的关键字和结构，从C过渡到C++的学习量就像从头学习C语言一样大。
另外，如果先掌握了C语言，则在过渡到C++时，必须摈弃一些编程习惯。
如果不了解C语言，则学习C++时需要掌握C语言的知识、OOP知识以及泛型编程知识，但无需挨弃任何编程习惯。
如果您认为学习C++可能需要扩展思维，这就对了。本书将以清晰的、帮助的方式，引导读者一步一个脚印地学习，
因此扩展思维的过程是温和的，不至于让您的大脑接受不了。
本书通过传授C语言基础知识和C++新增的内容，带您步入C++的世界，因此不要求读者具备C语言知识。
首先学习C++与C语言共有的一些特性。即使已经了解C语言，也会发现阅读本书的这一部分是一次很好的复习。
另外，本章还介绍了一些对后面的学习十分重要的概念，指出了C++和C之间的区别。
在牢固地掌握了C语言的基础知识后，就可以在此基础上学习C++方面的知识了。
那时将学习对象和类以及C++是如何实现它们的；另外还将学习模板。
本书不是完整的C++参考手册，不会探索该语言的每个细节，但将介绍所有的重要特性，包括模板、异常和名称空间等。
下面简要地介绍一下C++的背景知识。
1.2 C++简史
在过去的几十年，计算机技术以令大惊讶的速度发展着，当前，笔记本电脑的计算速度和存储信息的能力超过了20世纪60年代的大型机。
很多程序员可能还记得，将数叠穿孔卡片提交给充斥整个房间的大型计算机系统的时代，而这种系统只有100KB的内存，比当今智能手机的内存都少得多。
计算机语言也得到了发展，尽管变化可能不是天翻地覆的，但也是非常重要的。
体积更大、功能更强的计算机引出了更大、更复杂的程序，而这些程序在程序管理和维护方面带来了新的问题。
在20世纪70年代，C和Pascal这样的语言引领人们进入了结构化编程时代，这种机制把秩序和规程带进了迫切需要这种性质的领域中。
除了提供结构化编程工具外，C还能生成简洁、快速运行的程序，并提供了处理硬件问题的能力，如管理通信端口和磁盘驱动器。
这些因素使C语言成为20世纪80年代占统治地位的编程语言。同时，20世纪80年代，人们也见证了一种新编程模式的成长：面向对象编程（OOP）。
SmallTalk和C++语言具备这种功能。下面更深入地介绍C和OOP。
1.2.1 C语言
20世纪70年代早期，贝尔实验室的Dennis Ritchie致力于开发UNIX操作系统（操作系统是能够管理计算机资源、处理计算机与用户产之间交互的一组程序。
例如，操作系统将系统提示符显示在屏幕上以提供终端式界面、提供管理窗口和鼠标的图形界面以及运行程序）。
为完成这项工作，Ritchie需要一种语言，它必须简洁，能够生成简洁、快速的程序，并能有效地控制硬件。
传统上，程序员使用汇编语言来满足这些需求，汇编语言依赖于计算机的内部机器语言。
然而汇编语言是低级（low-level）语言，即直接操作硬件，如直接访CPU寄存器和内存单元。
因此汇编语言针对于特定的计算机处理器，要将汇编程序移植到另一种计算机上，必须使用不同的汇编语言重新编写程序。
这有点像每次购买新车时，都发现设计大量改变了控制系统的位置和功能，客户不得不重新学习驾驶。
然而，UNIX是为在不同的计算机（或平台）上工作而设计的，这意味着它需要一种高级语言。
高级（high-level）语言致力于解决问题，而不针对特定的硬件。一种被称为编译器的特殊程序将高级语言翻译成特定计算机的内部语言。
这样，就可以通过对每个平台使用不同的编译器来在不同的平台上使用同一个高级语言程序了。
Ritchie希望有一种语言能将低级语言的效率、硬件访问能力和高级语言的通用性、可移植性融合在一起，于是他在旧语言的基础上开发了C语言。
1.2.2 C语言编程原理
由于C++在C语言的基础上移植了新的编程理念，因此我们首先来看一看C所遵循的旧的理念。
一般来说，计算机语言要处理两个概念：数据和算法。数据是程序使用和处理的信息，而算法是程序使用的方法（参见图1.1）。
C语言与当前最主流的语言一样，在最初面世时也是过程性（procedural）语言，这意味着它强调的是编程的算法方面。
从概念上说，过程化编程首先要确定计算机应采取的操作，然后使用编程语言来实现这些操作。
程序命令计算机按一系列流程生成特定的结果，就像菜谱指定了厨师做蛋糕时应遵循的一系列步骤一样。
随着程序规模的扩大，早期的程序语言（如FORTRAN和BASIC）都会遇到组织方面的问题。
例如，程序经常使用分支语句，根据某种测试的结果，执行一组或另一组指令。很多旧式程序的执行路径很混乱（被称为“意大利面条式编程”），
几乎不可能通过阅读程序来理解它，修改这种程序简直是一场灾难。为了解决这种问题，计算机科学家开发了一种更有序的编程方法：结构化编程（structured programming）。
C语言具有使用这种方法的特性。例如，结构化编程将分支（决定接下来应执行哪个指令）限制为一小组行为良好的结构。
C语言的词汇表中就包含了这些结构（for循环、while循环、do while循环和if else语句）。
另一个新原则是自顶向下（top-down）的设计。在C语言中，其理念是将大型程序分解成小型、便于管理的任务。
如果其中的一项任务仍然过大，则将它分解为更小的任务。这一过程将一直持续下去，直到将程序划分为小型的、易于编写的模块
（整理一下书房。先整理桌子、桌面、档案柜，然后整理书架。好，先从桌子开始，然后整理每个抽屉，从中间的那个抽屉开始整理。也许我都可以管理这项任务）。
C语言的设计有助于使用这种方法，它鼓励程序员开发程序单元（函数）来表示各个任务模块。
如上所述，结构化编程技术反映了过程性编程的思想，根据执行的操作来构思一个程序。
1.2.3面向对象编程
虽然结构化编程的理念提高了程序的清晰度、可靠性，并使之便于维护，但它在编写大型程序时，仍面临着挑战。
为应付这种挑战，OOP提供了一种新方法。与强调算法的过程性编程不同的是，OOP强调的是数据。
OOP不像过程性编程那样，试图使问题满足语言的过程性方法，而是试图让语言来满足问题的要求。其理念是设计与问题的本质特性相对应的数据格式。
在C++中，类是一种规范，它描述了这种新型数据格式，对象是根据这种规范构造的特定数据结构。
例如，类可以描述公司管理人员的基本特征（姓名、头衔、工资、特长等），而对象则代表特定的管理人员。
通常，类规定了可使用哪些数据来表示对象以及可以对这些数据执行哪些操作。
例如，假设正在开发一个能够绘制矩形的计算机绘图程序，则可以定义一个描述矩形的类。定义的数据部分应包括顶点的位置、长和宽、4条边的颜色和样式、
矩形内部的填充颜色和图案等；定义的操作部分可以包括移动、改变大小、旋转、改变颜色和图案、将矩形复制到另一个位置上等操作。
这样，当使用该程序来绘制矩形时，它将根据类定义创建一个对象。该对象保存了描述矩形的所有数据值，因此可以使用类方法来修改该矩形。
如果绘制两个矩形，程序将创建两个对象，每个矩形对应一个。
OOP程序设计方法首先设计类，它们准确地表示了程序要处理的东西。例如，绘图程序可能定义表示矩形、直线、圆、画刷、画笔的类。
类定义描述了对每个类可执行的操作，如移动圆或旋转直线。然后您便可以设计一个使用这些类的对象的程序。
从低级组织（如类）到高级组织（如程序）的处理过程叫做自下向上（bottom-up）的编程。
OOP编程并不仅仅是将数据和方法合并为类定义。例如，OOP还有助于创建可重用的代码，这将减少大量的工作。
信息隐藏可以保护数据，使其免遭不适当的访问。多态让您能够为运算符和函数创建多个定义，通过编程上下文来确定使用哪个定义。
继承让您能够使用旧类派生出新类。正如接下来将看到的那样，OOP引入了很多新的理念，使用的编程方法不同于过程性编程。
它不是将重点放在任务上，而是放在表示概念上。有时不一定使用自上向下的编程方法，而是使用自下向上的编程方法。
本书将通过大量易于掌握的示例帮助读者理解这些要点。
设计有用、可靠的类是一项艰巨的任务，幸运的是，OOP语言使程序员在编程中能够轻松地使用已有的类。
厂商提供了大量有用的类库，包括设计用于简化Windows或Macintosh环境下编程的类库。
C++真正的优点之一是：可以方便地重用和修改现有的、经过仔细测试的代码。
1.2.4 C++和泛型编程
泛型编程（generic programming）是C+支持的另一种编程模式。它与OOP的目标相同，都使得重用代码和抽象通用概念的技术更简单。
不过OOP强调的是编程的数据方面，而泛型编程强调的是独立于特定数据类型。它们的侧重点不同。
OOP是一个管理大型项目的工具，而泛型编程提供了执行常见任务（如对数据排序或合并链表）的工具。
术语泛型（generic）指的是创建独立于类型的代码。C++的数据表示有多种类型――整数、小数、字符、字符串、用户定义的、由多种类型组成的复合结构。
例如，要对不同类型的数据进行排序，通常必须为每种类型创建一个排序函数。
泛型编程需要对语言进行扩展，以便可以只编写一个泛型（即不是特定类型的）函数，并将其用于各种实际类型。C++模板提供了完成这种任务的机制。
1.2.5 C++的起源
与C语言一样，C++也是在贝尔实验室诞生的，Bjarne Stroustrup于20世纪80年代在这里开发出了这种语言。
用他自己的话来说，“C++主要是为了我的朋友和我不必再使用汇编语言、C语言或其他现代高级语言来编程而设计的。
它的主要功能是可以更方便地编写出好程序，让每个程序员更加快乐”。
Bjarne Stroustrup设计并实现了C+编程语言，他是权威参考手册《The C++ Programming Language》和《The design and Evolution of C++》的作者。
Bjarne Stroustrup之所以在C的基础上创建C++，是因为C语言简洁、适合系统编程、使用广泛且与UNIX操作系统联系紧密。
Stroustrup加入了OOP特性和泛型编程支持，但并没有对C的组件作很大的改动。
因此，C++是C语言的超集，这意味着任何有效的C程序都是有效的C++程序。它们之间有些细微的差异，但无足轻重。
C++程序可以使用已有的C软件库。库是编程模块的集合，可以从程序中调用它们。
库对很多常见的编程问题提供了可靠的解决方法，因此能节省程序员大量的时间和工作量。这也有助于C++的广泛传播。
名称C++来自C语言中的递增运算符++，该运算符将变量加1。名称C++表明，它是C的扩充版本。
计算机程序将实际问题转换为计算机能够执行的一系列操作。OOP部分赋予了C++语言将问题所涉及的概念联系起来的能力，
C部分则赋予了C++语言紧密联系硬件的能力（参见图l.2），这种能力上的结合成就了C++的广泛传播。
另外，C++是在C语言的基础土添加OOP特性，您可以忽略C++的面向对象特性，但将错过很多有用的东西。
在C++获得一定程度的成功后，Stroustrup才添加了模板，这使得进行泛型编程成为可能。
在模板特性被使用和改进后，人们才逐渐认识到，它们和OOP同样重要――甚至比OOP还重要，但有些人不这么认为。
C++融合了OOP、泛型编程和传统的结构化编程，这表明C++强调的是实用价值，而不是意识形态方法，这也是该语言获得成功的原因之一。
1.3 可移植性和标准
假设您为运行Windows2000的老式奔腾PC编写了一个很好用的C++程序，而管理人员决定使用不同操作系统和处理器的计算机替换它。
该程序是否可以在新平台上运行呢？当然，必须使用为新平台设计的C++编译器对程序重新编译。但是否需要修改编写好的代码呢？
如果在不修改代码的情况下，重新编译程序后，程序将运行良好，则该程序是可移植的。
在可移植性方面存在两个障碍，其中的一个是硬件。硬件特定的程序是不可移植的。
将依赖于硬件的部分放在函数模块中可以最大限度地降低可移植性问题，这样只需重新编写这些模块即可。本书将避免这种编程。
可移植性的第二个障碍是语言上的差异。Windows XP的C++实现与Red Hat Linux或Macintosh OSX的C++实现相同吗？
虽然多数C++实现都希望其C++版本与其他版本兼容，但如果没有准确描述语言工作方式的公开标准，这将很难做到。
因此，美国国家标准局（American National Standards Institute，ANSI）在1990年设立了一个委员会，专门负责制定C++标准（ANSI制定了C语言标准）。
国际标准化组织（ISO）很快通过自己的委员会（ISO-WG-21）加入了这个行列，创建了联合组织ANSI/ISO，致力于制定C++标准。
经过多年的努力，制定出了一个国际标准ISO/IEC14882：1998，并于1998年获得了ISO、IEC
（International Electrotechnical Committee，国际电工技术委员会）和ANSI的批准。
该标准常被称为C++98，它不仅描述了已有的C++特性，还对该语言进行了扩展，添加了异常、运行阶段类型识别（RTTl）、模板和标准模板库（STL）。
2003年，发布了C++标准第二版（IOS/IEC14882：2003）；这个新版本是一次技术性修订，这意味着它对第一版进行了整理，修订错误、减少多义性等，但没有改变语言特性。
这个版本常被称为C++03。由于C++03没有改变语言特性，因此我们使用C++98表示C++98/C++2003。
C++在不断发展。ISO标准委员会于2011年8月批准了新标准ISO/IEC14882：2011，该标准被称为C++11。
与C++98一样，C++11也新增了众多特性，其目标是消除不一致性；让C++学习和使用起来更容易。
ISO C++标准还吸收了ANSI C语言标准，因为C++应尽量是C语言的超集。这意味着在理想情况下，任何有效的C程序都应是有效的C++程序。
ANSI C与对应的C++规则之间存在一些差别，但这种差别很小。实际上，ANSI C加入了C++首次引入的一些特性，如函数原型和类型限定符const。
在ANSI C出现之前，C语言社区遵循一种事实标准，该标准基于Kernighan和Ritchie编写的《The C Programming Language》一书，通常被称为K&R C；
ANSI C出现后，更简单的K&R C有时被称为经典C。
ANSI C标准不仅定义了C语言，还定义了一个ANSI C实现必须支持的标准C库。C++也使用了这个库；本书将其称为标准C库。
另外，ANSI/ISO C++标准还提供了一个C++标准类库。
最新的C标准为C99，ISO和ANSl分别于1999年和2000年批准了该标准。该标准在C语言中添加了一些C++编译器支持的特性，如新的整型。
1.3.1 C++的发展
Stroustrup编写的《The C++ Programming Language》包含65页的参考手册，它成了最初的C++事实标准。
下一个事实标准是Stroustrup编写的《The Annotated C++Reference Manual》。
C++98标准新增了大量特性，其篇幅将近800页，且包含的说明很少。
C++11标准的篇幅长达1350页，对旧标准做了大量的补充。
1.3.2 本书遵循的C++标准
当代的编译器都对C++98提供了很好的支持。编写本书期间，有些编译器还支持一些C++11特性：随着新标准获批，对这些特性的支持将很快得到提高。
本书反映了当前的情形，详尽地介绍了C++98，并涵盖了C++11新增的一些特性。
在探讨相关的C++98主题时顺便介绍了一些C++新特性，而第18章专门介绍新特性，它总结了本书前面提到的一些特性，并介绍了其他特性。
在编写本书期间，对C++11的支持还不全面，因此难以全面介绍C++11新增的所有特性。
考虑到篇幅限制，即使这个新标准获得了全面支持，也无法在一本书中全面介绍它。本书重点介绍大多数编译器都支持的特性，并简要地总结其他特性。
详细介绍C++之前，先介绍一些有关程序创建的基本知识。
1.4 程序创建的技巧
假设您编写了一个C++程序。如何让它运行起来呢？具体的步骤取决于计算机环境和使用的C++编译器，但大体如下（参见图1.3）。
1.使用文本编辑器编写程序，并将其保存到文件中，这个文件就是程序的源代码。
2.编译源代码。这意味着运行一个程序，将源代码翻译为主机使用的内部语言――机器语言。包含了翻译后的程序的文件就是程序的目标代码（object code）。
3.将目标代码与其他代码链接起来。例如，C++程序通常使用库。C++库包含一系列计算机例程（被称为函数）的目标代码，
这些函数可以执行诸如在屏幕上显示信息或计算平方根等任务。
链接指的是将目标代码同使用的函数的目标代码以及一些标准的启动代码（startup code）组合起来，生成程序的可执行版本。包含该最终产品的文件被称为可执行代码。
本书将不断使用术语源代码；请记住该术语。
本书的程序都是通用的，可在任何支持C++98的系统中运行；但第18章的程序要求系统支持C++11。
编写本书期间，有些编译器要求您使用特定的标记，让其支持C++11特性。
例如，g++要求您编译源代码文件时使用标记-std=c++11
g++ -std=c++11 use_auto.cpp
创建程序的步骤可能各不相同，下面深入介绍这些步骤。
1.4.1创建源代码文件
本书余下的篇幅讨论源代码文件中的内容：本节讨论创建源代码文件的技巧。
有些C++实现（如Microsoft Visual C++、C++Builder、Apple Xcode、Open Watcom C++、
Digital Mars C++和Freescale Code Warrior）提供了集成开发环境（integrated development environments，IDE），
让您能够在主程序管理程序开发的所有步骤，包括编辑。
有些实现（如用于UNIX和Linux的GNU C/C++、用于AlX的IBM XL C/C++、Borland C/C++以及Digital Mars C/C++）
只能处理编译和链接阶段，要求在系统命令行输入命令。
在这种情况下，可以使用任何文本编辑器来创建和修改源代码。
例如，在UNIX系统上，可以使用nano、vim、emacs。
如果将文件保存为标准ASCII文本文件（而不是特殊的字处理器格式），甚至可以使用字处理器。
另外，还可能有IDE选项，让您能够使用这些命令行编译器。
给源文件命名时，必须使用正确的后缀，将文件标识为C++文件。这不仅告诉您该文件是C+源代码，还将这种信息告知编译器。
后缀由一个句点和一个或多个字符组成，这些字符被称作扩展名。（参见图1.4）。
使用什么扩展名取决于C++实现，表1.1列出了一些常用的扩展名。
表1.1 源代码文件的扩展名
C++实现         源代码文件的扩展名
GNU C++       cpp、cxx、cc
Visual C++     cpp、cxx、cc
1.4.2编译和链接
最初，Stroustrup实现C++时，使用了一个C++到C的编译器程序，而不是开发直接的C++到目标代码的编译器。
前者叫做cfront（表示C前端，Cfrontend），它将C++源代码翻译成C源代码，然后使用一个标准C编译器对其进行编译。
这种方法简化了向C的领域引入C++的过程。其他实现也采用这种方法将C++引入到其他平台。
随着C++的日渐普及，越来越多的实现转向创建C++编译器，直接将C++源代码生成目标代码。
这种直接方法加速了编译过程，并强调C++是一种独立（虽然有些相似）的语言。
编译的机理取决于实现，接下来的几节将介绍一些常见的形式。这些总结概括了基本步骤，但对于具体步骤，必须查看系统文档。
1.UNIX 编译和链接
最初，UNIX命令CC调用cfront，但cfront未能紧跟C++的发展步伐，其最后一个版本发布于1993年。
当今的UNIX上有商用的C++编译器或开源免费的C++编译器。
如果UNIX上有C++编译器，很多情况下命令CC仍然管用，只是启动的编译器随系统而异。
出于简化的目的，读者应假设命令CC可用，但必须认识到这一点，即对于下述讨论中的CC，可能必须使用其他命令来代替。
请用CC命令来编译程序，名称采用大写字母。
CC编译器是命令行编译器，这意味着需要在UNIX命令行上输入编译命令。
例如，要编译C++源代码文件spiffy.cpp，则应在UNIX提示符下输入如下命令：
CC spiffy.cpp
如果程序没有错误，编译器将生成一个扩展名为o的目标代码文件。
在这个例子中，编译器将生成目标代码文件spiffy.o。
接下来，编译器自动将目标代码文件传递给系统链接程序，该程序将代码与库代码结合起来，生成一个可执行文件。
在默认情况下，可执行文件为a.out。如果只使用一个源文件，链接程序还将删除spiffy.o文件，因为这个文件不再需要了。
要运行该程序，只要输入可执行文件的文件名即可：
a.out
注意，如果编译新程序，新的可执行文件a.out将覆盖已有的a.out
（这是因为可执行文件占据了大量空间，因此覆盖旧的可执行文件有助于降低存储需求）。
然而，如果想保留可执行文件，只需使用UNIX的mv命令来修改可执行文件的文件名即可。
与在C语言中一样，在C++中，程序也可以包含多个文件（本书第8~第16章的很多程序都是这样）。
在这种情况下，可以通过在命令行上列出全部文件来编译程序：
cc my.cpp precious.cpp
如果只修改了my.cpp文件，则可以用下面的命令重新编译该程序：
cc my.cpp precious.o
这将重新编译my.cpp文件，并将它与前面编译的precious.o文件链接起来。
可能需要显式地指定一些库。例如，要访问数学库中定义的函数，必须在命令行中加上-lm标记：
cc -lm usingmath.cpp
2.Linux编译和链接
Linux系统中最常用的编译器是g++，这是来自Free Software Foundation的GNU C++编译器。
Linux的多数版本都包括该编译器，但并不一定总会安装它。g++编译器的工作方式很像标准UNIX编译器。
例如，下面的命令将生成可执行文件a.out
g++ spiffy.cpp
要编译多个源文件，只需将它们全部放到命令行中即可：
g++ my.cpp precious.cpp
这将生成一个名为a.out的可执行文件和两个目标代码文件my.o和precious.o。
如果接下来修改了其中的某个源代码文件，如my.cpp，则可以使用my.cpp和precious.o来重新编译：
g++ my.cpp precious.o
GNU编译器可以在很多平台上使用，包括基于Windows的PC和在各种平台上运行的UNIX系统。
3.Windows命令行编译器
要在Windows上编译C++程序，最便宜的方法是下载一个在Windows命令提示符模式
（在这种模式下，将打开一个类似于MS-DOS的窗口）下运行的免费命令行编译器。
Cygwin和MinGW都包含编译器GNU C++，且可免费下载；它们使用的编译器名为g++。
要使用g++编译器，首先需要打开一个命令提示符窗口。启动程序Cygwin和MinGW时，它们将自为您打开一个命令提示符窗口。
要编译名为great.cpp的源代码文件，请在提示符下输入如下命令：
g++ great.cpp
如果程序编译成功，则得到的可执行文件名为a.exe。
4.Windows编译器
Windows产品很多且修订频繁，无法对它们分别进行介绍。
当前，最流行是Microsoft Visual C++2010，可通过免费的Microsoft Visual C++ 2010学习版获得。
虽然设计和目标不同，但大多数基于Windows的C++编译器都有一些相同的功能。
通常，必须为程序创建一个项目，并将组成程序的一个或多个文件添加到该项目中。
每个厂商提供的IDE（集成开发环境）都包含用于创建项目的菜单选项（可能还有自动帮助）。
必须确定的非常重要的一点是，需要创建的是什么类型的程序。
通常，编译器提供了很多选择，如Windows应用程序、MFC Windows应用程序、动态链接库、ActiveX控件、
DOS或字符模式的可执行文件、静态库或控制台应用程序等。其中一些可能既有32位版本，又有64位版本。
由于本书的程序都是通用的，因此应当避免要求平台特定代码的选项，如Windows应用程序。
相反，应让程序以字符模式运行。具体选项取决于编译器。一般而言，应选择包含字样“控制台”、“字符模式”
或“DOS可执行文件”等选项。例如，在Microsoft Visual C++2010中，应选择Win32 Console Application
（控制台应用程序）选项，单击Application Settings（应用程序设置），并选择Empty Project（空项目）。
创建好控制台项目后，需要对程序进行编译和链接。IDE通常提供了多个菜单项，如Compile（编译）、Build
（建立）、Make（生成）、Build All（全部建立）、Link（链接）、Execute（执行）、Run（运行）和Debug（调试），
不过同一个IDE中，不一定包含所有这些选项。
Compile通常意味着对当前打开的文件中的代码进行编译。
Build和Make通常意味着编译项目中所有源代码文件的代码。这通常是一个递增过程，也就是说，
如果项目包含3个文件，而只有其中一个文件被修改，则只重新编译该文件。
BuildAll 通常意味着重新编译所有的源代码文件。
Link意味着（如前所述）将编译后的源代码与所需的库代码组合起来。
Run或Execute意味着运行程序。通常，如果您还没有执行前面的步骤，Run将在运行程序之前完成这些步骤。
Debug意味着以调试方式执行程序。
编译器可能让您选择要生成调试版还是发布版。调试版包含额外的调试符号，这会增大程序、降低执行速度，但可提供详细的调试信息。
如果程序违反了语言规则，编译器将生成错误消息，指出在在问题的行。
遗憾的是，如果不熟悉语言，将难以理解这些消息的含义。
有时，真正的问题可能在标识行之前；有时，一个错误可能引发一连串的错误消息。
提示：改正错误时，应首先改正第一个错误。如果在标识为有错误的那一行上找不到错误，请查看前一行。
需要注意的是，程序能够通过某个编译器的编译并不意味着它是合法的C+程序；
同样，程序不能通过某个编译器的编译也并不意味着它是非法的C++程序。
与几年前相比，现在的编译器更严格地遵循了C++标准。另外，编译器通常提供了可用于控制严格程度的选项。
提示：有时，编译器在不完全地构建程序后将出现混乱，它显示无法改正的、无意义的错误消息。
在这种情况下，可以选择BuildAll，重新编译整个程序，以清除这些错误消息。
遗憾的是，这种情况和那些更常见的情况（即错误消息只是看上去无意义，实际上有意义）很难区分。
通常，IDE允许在辅助窗口中运行程序。程序执行完毕后，有些IDE将关闭该窗口，而有些IDE不关闭。
如果编译器关闭窗，将难以看到程序输出，除非您眼疾手快、过目不忘。
为查看输出，必须在程序的最后加上一些代码：
cin.get();   //读取输入后遗留在缓冲区中的换行符
cin.get();   //获取一次键击

return 0;
cin.get语句读取下一次键击，因此上述语句让程序等待，直到按下了Enter键
（在按下Enter键之前，键击将不被发送给程序，因此按其他键都不管用）。
如果程序在其常规输入后留下一个没有被处理的键击，则第二条语句是必需的。
例如，如果要输入一个数字，则需要输入该数字，然后按Enter键。
程序将读取该数字，但Enter键不被处理，这样它将被第一个cin.get读取。
5.Macintosh上的C++
当前，Apple随操作系统Mac OS X提供子开发框架Xcode，该框架是免费的，但通常不会自动安装。
要安装它，可使用操作系统安装盘，也可从Apple网站免费下载（但需要注意的是，它超过4GB）。
Xcode远不仅提供了支持多种语言的IDE，还自带了两个命令行编译器（g++和clang），可在UNIX模式下运行它们。
而要进入UNIX模式，可通过实用程序Terminate。
提示：为节省时间，可对所有示例程序使用同一个项目。
方法是从项目列表中删除前一个示例程序的源代码文件；并添加当前的源代码。这样可节省时间、工作量和磁盘空间。
1.5 总结
随着计算机的功能越来越强大，计算机程序越来越庞大而复杂。
为应对这种挑战，计算机语言也得到了改进，以便编程过程更为简单。
C语言新增了诸如控制结构和函数等特性，以便更好地控制程序流程，支持结构化和模块化程度更高的方法；
而C++增加了对面向对象编程和泛型编程的支持，这有助于提高模块化和创建可重用代码，从而节省编程时间并提高程序的可靠性。
C++的流行导致大量用于各种计算平台的C++实现得以面世；而ISO C++标准为确保众多实现的相互兼容提供了基础。
这些标准规定了语言必须具备的特性、语言呈现出的行为、标准库函数、类和模板，
旨在实现该语言在不同计算平台和实现之间的可移植性。
要创建C++程序，可创建一个或多个源代码文件，其中包含了以C++语言编写的程序。
这些文件是文本文件，它们经过编译和链接后将得到机器语言文件，后者构成了可执行的程序。
上述任务通常是在IDE中完成的，IDE提供了用于创建源代码文件的文本编辑器、用于生成可执行文件的编译器和链接器以及其他资源，
如项目管理和调试功能。然而，这些任务也可以在命令行环境中通过调用合适的工具来完成。

第2章 开始学习C++
2.1 进入C+ +
2.1.1 main函数
2.1.2 C++注释
2.1.3 C++预处理器和iostream文件
2.1.4 头文件名
2.1.5 名称空间
2.1.6 使用cout进行C++输出
2.1.7 C++源代码的格 式化
2.2 C++语句
2.2.1 声明语句和变量
2.2.2 赋值语句
2.2.3 cout的新花样
2.3 其他C++语句
2.3.1 使用cin
2.3.2 使用cout进行拼接
2.3.3 类简介
2.4 函数
2.4.1 使用有返回值的函数
2.4.2 函数变体
2.4.3 用户定义的函数
2.4.4 用户定义的有返回值的函数
2.4.5 在多函数程序中使用using编译指令
2.5 总结
2.6 复习题
2.7 编程练习
本章内容包括：
创建C++程序。
C++程序的一般格式。
#include编译指令。
main函数。
使用cout对象进行输出。
在C++程序中加入注释。
何时以及如何使用endl。
声明和使用变量。
使用cin对象进行输入。
定义和使用简单函教。
要建造简单的房屋，首先要打地基、搭框架。如果一开始没有牢固的结构，后面就很难建造窗子、门框、圆屋顶和镶木地板的舞厅等。
同样，学习计算机语言时，应从程序的基本结构开始学起，只有这样，才能一步步了解其具体细节，如循环和对象等。
本章对C+程序的基本结构做一概述，并预览后面将介绍的主题，如函数和类。
（这里的理念是，先介绍一些基本概念，这样可以激发读者接下去学习的兴趣。）
2.1进入C++
首先介绍一个显示消息的简单C++程序。程序清单2.1使用C++工具cout生成字符输出。
源代码中包含一些供读者阅读的注释，这些注释都以//打头，编译器将忽略它们。
C++对大小写敏感，也就是说区分大写字符和小写字符。这意味着大小写必须与示例中相同。
例如，该程序使用的是cout，如果将其替换为Cout，程序将无法通过编译。
程序清单2.1 myfirst.cpp
#include <iostream>

using namespace std;

int main()
{
    cout << "Come up and C++ me some time.";
    cout << endl;
    cout << "You won't regret it!" << endl;

    return 0;
}
显示结果如下
Come up and C++ me some time.
You won't regret it!

2.2 C++语句
C++程序是一组函数，而每个函数又是一组语句。C++有好几种语句，下面介绍其中的一些。
程序清单2.2提供了两种新的语句。声明语句创建变量，赋值语句给该变量提供一个值。另外，该程序还演示了cout的新功能。
程序清单2.2 carrots.cpp
#include <iostream>

using namespace std;

int main()
{
    int carrots;

    carrots = 25;
    cout << "I have " << carrots << " carrots.";
    cout << endl;
    carrots = carrots - 1;
    cout << "Crunh, Crunch. Now I have " << carrots << " carrots." << endl;

    return 0;
}
显示结果如下
I have 25 carrots.
Crunh, Crunch. Now I have 24 carrots.

2.3其他C++语句
再来看几个C++语句的例子。程序清单2.3中的程序对前一个程序进行了扩展，要求在程序运行时输入一个值。
为实现这项任务，它使用了cin，这是与cout对应的用于输入的对象。另外，该程序还演示了cout对象的多功能性。
程序清单2.3 getinfo.cpp
#include <iostream>

using namespace std;

int main()
{
    int carrots = 0;

    cout << "How many carrots do you have?" << endl;
    cin >> carrots;
    cout << "Here are two more. ";
    carrots = carrots + 2;
    cout << "Now you have " << carrots << " carrots." << endl;

    return 0;
}
显示结果如下
How many carrots do you have?
66
Here are two more. Now you have 68 carrots.

2.4 函数
由于函数用于创建C++程序的模块，对C++的OOP定义至关重要，因此必须熟悉它。函数的某些方面属于高级主题，将在第7章和第8章重点讨论函数。
然而，现在了解函数的一些基本特征，将使得在以后的函数学习中更加得心应手。本章剩余的内容将介绍函数的一些基本知识。
C++函数分两种：有返回值的和没有返回值的。在标准C++函数库中可以找到这两类函数的例子，您也可以自己创建这两种类型的函数。
下面首先来看一个有返回值的库函数，然后介绍如何编写简单的函数。
2.4.1使用有返回值的函数
有返回值的函数将生成一个值，而这个值可赋给变量或在其他表达式中使用。例如，标准C/C++库包含一个名为sqrt的函数，它返回平方根。
程序清单2.4演示了库函数sqrt的用法，它通过包含cmath文件来提供该函数的原型：
程序清单2.4 sqrt.cpp
#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    double area;
    cout << "Enter the floor area, in square feet, of your hone: ";
    cin >> area;
    double side;
    side = sqrt(area);
    cout << "That's the equivalent of a square " << side
         << " feet to the side." << endl;
    cout << "How fascinating!" << endl;

    return 0;
}
显示结果如下
Enter the floor area, in square feet, of your hone: 9.9
That's the equivalent of a square 3.14643 feet to the side.
How fascinating!

标准C库提供了140多个预定义的函数。如果其中的函数能满足要求，则应使用它们。
但用户经常需要编写自己的函数，尤其是在设计类的时候。无论如何，设计自己的函数很有意思，下面来介绍这一过程。
前面已经使用过好几个用户定义的函数，它们都叫main。每个C++程序都必须有一个main函数，用户必须对它进行定义。
假设需要添加另一个用户定义的函数。和库函数一样，也可以通过函数名来调用用户定义的函数。
对于库函数，在使用之前必须提供其原型，通常把原型放到main定义之前。但现在您必须提供新函数的源代码。
最简单的方法是，将代码放在main的后面。程序清单2.5演示了这些元素。
程序清单2.5 ourfunc.cpp
#include <iostream>
#include <cmath>

using namespace std;

void simon(int);

int main()
{
    simon(3);
    cout << "Pick an integer: ";
    int count;
    cin >> count;
    simon(count);
    cout << "Done!" << endl;

    return 0;
}

void simon(int n)
{
    cout << "Simon says touch your toes " << n << " times." << endl;
}
显示结果如下
Simon says touch your toes 3 times.
Pick an integer: 6
Simon says touch your toes 6 times.
Done!

我们再深入一步，编写一个使用返回语句的函数。main函数已经揭示了有返回值的函数的格式：在函数头中指出返回类型，在函数体结尾处使用return。
可以用这种形式为在英国观光的人解决重量的问题。
在英国，很多浴室都以stone为单位，不像美国以磅或公斤为单位。一stone等于14磅，程序清单2.6使用一个函数来完成这样的转换。
程序清单2.6 convert.cpp
#include <iostream>
#include <cmath>

using namespace std;

int stonetopound(int);

int main()
{
    int stone;
    cout << "Enter the weight in stone: ";
    cin >> stone;
    int pounds = stonetopound(stone);
    cout << stone << " stone = ";
    cout << pounds << " pounds." << endl;

    return 0;
}

int stonetopound(int stone)
{
    return 14 * stone;
}
显示结果如下
Enter the weight in stone: 8
8 stone = 112 pounds.

2.5总结
C++程序由一个或多个被称为函数的模块组成。程序从main函数（全部小写）开始执行，因此该函数必不可少。
函数由函数头和函数体组成。函数头指出函数的返回值（如果有的话）的类型和函数期望通过参数传递给它的信息的类型。
函数体由一系列位于花括号 { } 中的C++语句组成。
有多种类型的C++语句，包括下述6种。
声明语句：定义函数中使用的变量的名称和类型。
赋值语句：使用赋值运算符（=）给变量赋值。
消息语句：将消息发送给对象，激发某种行动。
函数调用：执行函数。被调用的函数执行完毕后，程序返回到函数调用语句后面的语句。
函数原型：声明函数的返回类型、函数接受的参数数量和类型。
返回语句：将一个值从被调用的函数那里返回到调用函数中。
类是用户定义的数据类型规范，它详细描述了如何表示信息以及可对数据执行的操作。
对象是根据类规范创建的实体，就像简单变量是根据数据类型描述创建的实体一样。
C++提供了两个用于处理输入和输出的预定义对象（cin和cout），它们是istream和ostream类的实例，这两个类是在iostream文件中定义的。
为ostream类定义的插入运算符（<<）使得将数据插入到输出流成为可能；
为istream类定义的抽取运算符（>>）能够从输入流中抽取信息。
cin和cout都是智能对象，能够根据程序上下文自动将信息从一种形式转换为另一种形式。
C++可以使用大量的C库函数。要使用库函数，应当包含提供该函数原型的头文件。
至此，读者对简单的C++程序有了大致的了解，可以进入下一章，了解程序的细节。

2.6 复习题
1.C++程序的模块叫什么？
函数

2.下面的预处理器编译指令是做什么用的？
#include <iostream>
使用iostream文件的内容替换该编译指令

3.下面的语句是做作么用的？
using namespace std；
使得程序可以使用std名称空间中的定义

4.什么语句可以用来打印短语“Hello, world”，然后开始新的一行？
cout << "Hello, world\n";
cout << "Hello, world" << endl；

5.什么语句可以用来创建名为cheeses的整数变量？
int cheeses;

6.什么语句可以用来将值32赋给变量cheeses？
cheeses = 32;

7.什么语句可以用来将从键盘输入的值读入变量cheeses中？
cin>>cheeses;

8.什么语句可以用来打印"We have X varieties of cheese"，其中X为变量cheeses的当前值。
cout<<"We have "<< cheeses <<"varieties of cheese";

9.下面的函数原型指出了关于函数的哪些信息？
int froop (double t);
void rattle (int n);
int prune (void);
函数froop接受一个double参数，返回一个int值。
函数rattle接受一个int参数，没有返回值。
函数prune不接受任何参数，返回一个int值。

10.定义函数时，在什么情况下不必使用关键字retun？
当函数的返回类型为void时，如果不需要只执行一部分就从函数返回，则不用在函数中使用return

11.假设您编写的main函数包含如下代码：
cout << "Please enter you PIN: ";
而编译器指出cout是一个未知标识符。导致这种问题的原因很可能是什么？指出修复这种问题的方法

#include <iostream>

using namespace std;

2.7 编程练习
1.编写一个C++程序它显示您的姓名和地址。
#include <iostream>

int main()
{
    std::cout << "YAYUN WEI" << std::endl;
    std::cout << "FuZhou, JiangXi, China" << std::endl;

    return 0;
}
显示结果如下
YAYUN WEI
FuZhou, JiangXi, China

2.编写一个C+程序；它要求用户输入一个以long为单位的距离，然后将它转换为码（一long等于220码）。

#include <iostream>

int main()
{
    std::cout << "Enter the number of frolongs " << std::endl;

    int frolong = 0;
    std::cin >> frolong;

    int yard = frolong * 220;
    std::cout << frolong << " Frolong = " << yard << " yard" << std::endl;

    return 0;
}
显示结果如下
Enter the number of frolongs
6
6 Frolong = 1320 yard

3.编写一个C++程序，它使用3个用户定义的函数（包括main），并生成下面的输出
Three blind mice
Three blind mice
See how they run
See how they run
其中一个函数要调用两次，该函数生成前两行；一另个函数也被调用两次，并生成其余的输出

#include <iostream>

void function1();
void function2();

int main()
{

    function1();
    function1();
    function2();
    function2();

    return 0;
}

void function1()
{
    std::cout << "Three blind mice" << std::endl;
}

void function2()
{
    std::cout << "See how they run" << std::endl;
}
显示结果如下
Three blind mice
Three blind mice
See how they run
See how they run

4.编写一个程序；让用户输入其年龄；然后显示该年龄包含多少个月。

#include <iostream>

int age_months(int age);

int main()
{
    std::cout << "Enter your age: ";

    int age = 0;
    std::cin >> age;

    std::cout << "Your age in months is " << age_months(age) << std::endl;

    return 0;
}

int age_months(int age)
{
    return age * 12;
}
显示结果如下
Enter your age: 9
Your age in months is 108

5.编写一个程序，其中，main调用一个用户定义的函数（以摄氏温度值为参数，并返回相应的华氏温度值）。

#include <iostream>

double celsius_to_fahrenheit(double celsius);

int main()
{
    std::cout << "Please enter a celsius value: ";

    double celsius = 0;
    std::cin >> celsius;

    std::cout << celsius << " degrees Celsius is " << celsius_to_fahrenheit(celsius) << " degrees fahrenheit\n";

    return 0;
}

double celsius_to_fahrenheit(double celsius)
{
    return (1.8 * celsius + 32.0);
}
显示结果如下
Please enter a celsius value: 33
33 degrees Celsius is 91.4 degrees fahrenheit

6.编写一个程序，其中，main调用一个用户定义的函数（以光年值为参数，并返回对应天文单位的值）。
天文单位是从地球到太阳的平均距离（约150000000公里或93000000英里），
光年是光一年走的距离（约10万亿公里或6万亿英里）（除太阳外，最近的恒星大约离地球4.2光年）。
请使用double类型（参见程序清单2.4），转换公式为：1光年=63240天文单位

#include <iostream>

double light_years(double light_years);

int main()
{
    std::cout << "Enter the number of light years: ";

    double lightyears = 0;
    std::cin >> lightyears;

    std::cout << lightyears << " light year = " << light_years(lightyears) << " astronomical units\n";

    return 0;
}

double light_years(double light_years)
{
    return light_years * 63240;
}
显示结果如下
Enter the number of light years: 3
3 light year = 189720 astronomical units

7.编写一个程序，要求用户输入小时数和分钟数。在main函数中，将这两个值传递给一个用户定义的函数（返回值类型为void）。

#include <iostream>

void display_time(int hour, int minutes);

int main()
{

    std::cout << "Enter the number of hours: ";
    int hour = 0;
    std::cin >> hour;

    std::cout << "Enter the number of minutes: ";
    int minutes = 0;
    std::cin >> minutes;

    display_time (hour, minutes);

    return 0;
}

void display_time(int hour, int minutes)
{
    std::cout << "Time: " << hour << ":" << minutes << std::endl;
}
显示结果如下
Enter the number of hours: 9
Enter the number of minutes: 28
Time: 9:28

第3章 处理数据
3.1 简单变量
3.1.1变量名
3.1.2 整型
3.1.3 整型short、int、long和long long
3.14 无符号类型
3.1.5 选择整型类型
3.1.6 整型字面值
3.1.7 C++如何确定常量的类型
3.1.8 char类型：字符和小整数
3.1.9 bool类型
3.2 const 限定符
3.3 浮点数
3.3.1 书写浮点数
3.3.2 浮点类型
3.3.3 浮点常量
3.3.4 浮点数的优缺点
3.4 C++算术运算符
3.4.1 运算符优先级和结合性
3.4.2 除法分支
3.4.3 求模运算符
3.4.4 类型转换.
3.4.5 C++11中的auto声明
3.5 总结
3.6 复习题
3.7 编程练习
本章内容包括
C++变量的命名规则
C++内置的整型
unsigned long, long, unsigned int, int, unsigned short, short, char, unsigned char, signed char和bool
C++11新增的整型：unsigned long long和long long
表示各种整型的系统限制的climits文件
各种整型的数字字面值（常量）。
使用const限定符来创建符号常量。
C++内置的浮点类型：float，double和long double
表示各种浮点类型的系统限制的cfloat文件。
各种浮点类型的数字字面值。
C++的算术运算符。
自动类型转换。
强制类型转换。
面向对象编程（OOP）的本质是设计并扩展自己的数据类型。设计自己的数据类型就是让类型与数据匹配。
如果正确做到了这一点，将会发现以后使用数据时会容易得多。
然而，在创建自己的类型之前，必须了解并理解C++内置的类型，因为这些类型是创建自己类型的基本组件。
内置的C++类型分两组：基本类型和复合类型。本章将介绍基本类型，即整数和浮点数。
似乎只有两种类型，但C++知道，没有任何一种整型和浮点型能够满足所有的编程要求，
因此对于这两种数据，它提供了多种变体。
第4章将介绍在基本类型的基础上创建的复合类型，包括数组、字符串、指针和结构。
当然，程序还需要一种标识存储的数据的方法，本章将介绍这样一种方法――使用变量；
然后介绍如何在C++中进行算术运算；最后，介绍C++如何将值从一种类型转换为另一种类型。
3.1 简单变量
程序通常都需要存储信息，为把信息存储在计算机中，程序必须记录3个基本属性：
信息将存储在哪里、要存储什么值、存储何种类型的信息。
到目前为止，本书的示例采取的策略都是声明一个变量。
声明中使用的类型描述了信息的类型和通过符号来表示其值的变量名。
int braincount;
brainicount = 5;
这些语句告诉程序，它正在存储整数，并使用名称braincount来表示该整数的值（这里为5）。
实际上，程序将找到一块能够存储整数的内存，将该内存单元标记为braincount，并将5复制到该内存单元中。
然后，您可在程序中使用braincount来访问该内存单元。这些语句没有告诉您，这个值将存储在内存的什么位置，
但程序确实记录了这种信息。实际上，可以使用&运算符来检索braincount的内存地址。
下一章介绍另一种标识数据的方法（使用指针）时，将介绍这个运算符。
3.1.1变量名
C++提倡使用有一定含义的变量名。C++变量名必须遵循几种简单的命名规则。
在名称中只能使用字母字符、数字和下划线（）.
名称的第一个字符不能是数字
区分大写字符与小写字符
不能将C+关键字用作名称。
以两个下划线或一个下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用
以一个下划线开头的名称被保留给实现，用作全局标识符。
C++对于名称的长度没有限制，名称中所有的字符都有意义，但有些平台有长度限制。
最后一点使得C++与ANSI C（C99标准）有所区别，后者只保证名称中的前63个字符有意义
（在ANSI C中，前63个字符相同的名称被认为是相同的，即使第64个字符不同）
如果想用两个或更多的单词组成一个名称，通常的做法是用下划线字符将单词分开，
或者从第二个单词开始将每个单词的第一个字母大写。
C程序员倾向于按C语言的方式使用下划线，而Pascal程序员喜欢采用大写方式。
3.1.2整型
C++提供好几种整型，这样便能够根据程序的具体要求选择最合适的整型。
不同C++整型使用不同的内存量来存储整数。使用的内存量越大，可以表示的整数值范围也越大。
另外，有的类型（符号类型）可表示正值和负值，而有的类型（无符号类型）不能表示负值。
术语宽度（width）用于描述存储整数时使用的内存量。使用的内存越多，则越宽。
C++的基本整型（按宽度递增的顺序排列）分别是char，short，int，long和C++11新增的long long，
其中每种类型都有符号版本和无符号版本，因此总共有10种类型可供选择。
下面更详细地介绍这些整数类型。由于char类型有一些特殊属性（它最常用来表示字符，而不是数字），
因此本章将首先介绍其他类型。
3.1.3 整型short，int，long和long long
计算机内存由一些叫做位（bit）的单元组成，C++的short，int，long和long long类型通过使用不同数目的位来存储值，
最多能够表示4种不同的整数宽度。如果在所有的系统中，每种类型的宽度都相同，则使用起来将非常方便。
例如，如果short总是16位，int总是32位，等等。不过生活并非那么简单，没有一种选择能够满足所有的计算机设计要求。
C++提供了一种灵活的标准，它确保了最小长度（从C语言借鉴而来），如下所示：
short至少16位；int至少与short一样长；long至少32位，且至少与int一样长；long long至少64位，且至少与long一样长。
位与宇节
计算机内存的基本单元是位（bit）。可以将位看作电子开关，可以开，也可以关，关表示值0，开表示值1。
8位的内存块可以设置出256种不同的组合，因为每一位都可以有两种设置，所以8位的总组合数为2的8次方（256），
因此，8位单元可以表示0-255或者-128到127，每增加一位，组合数便加倍。
这意味着可以把16位单元设置成65 536个不同的值，把32位单元设置成4294 672 296个不同的值，
把64位单元设置为18446 744073 709 551 616个不同的值。
作为比较，unsigned long存储不了地球上当前的人数和银河系的星星数，而long long能够，
字节（byte）通常指的是8位的内存单元。从这个意义上说，字节指的就是描述计算机内存量的度量单位，
1KB等于1024字节，1MB等于1024KB，然而，C++对字节的定义与此不同。
C+字节由至少能够容纳实现的基本字符集的相邻位组成，也就是说，可能取值的数目必须等于或超过字符数目。
在美国，基本字符集通常是ASCII和EBCDIC字符集，它们都可以用8位来容纳，所以在使用这两种字符集的系统中
C++字节通常包含8位。然而，国际程可能需要使用更大的字符集，如Unicode，
因此有些实现可能使用16位甚至32位的字节。有些人使用术语八位组（octet）表示8位字节。
类型的宽度随实现而异，这可能在将C++程序从一种环境移到另一种环境
（包括在同一个系统中使用不同编译器）时引发问题。
但只要小心一点（如本章后面讨论的那样），就可以最大限度地减少这种问题。
实际上，short是short int的简称，而long是long int的简称，但是程序设计者们几乎都不使用比较长的形式。
这4种类型（int，short，long和long long）都是符号类型，这意味着每种类型的取值范围中，负值和正值几乎相同。
例如，16位的int的取值范围为-32768到+32767。
要知道系统中整数的最大长度，可以在程序中使用C++工具来检查类型的长度。
首先，sizeof运算符返回类型或变量的长度，单位为字节。
前面说过，“字节”的含义依赖于实现，因此在一个系统中，两字节的int可能是16位，而在另一个系统中可能是32位。
其次，头文件climits（在老式实现中为limits.h）中包含了关于整型限制的信息。
具体地说，它定义了表示各种限制的符号名称。例如，INT_MAX为int的最大取值，CHAR_BIT为字节的位数。
程序清单3.1演示了如何使用这些工具。该程序还演示如何初始化，即使用声明语句将值赋给变量。
程序清单3.1 limits.cpp
#include <climits>
#include <iostream>

using namespace std;

int main()
{
    int n_int = INT_MAX;
    short n_short = SHRT_MAX;
    long n_long = LONG_MAX;
    long long n_llong = LLONG_MAX;

    cout << "int is " << sizeof(int) << " bytes." << endl;
    cout << "short is " << sizeof n_short << " bytes." << endl;
    cout << "long is " << sizeof n_long << " bytes." << endl;
    cout << "long long is " << sizeof n_llong << " bytes." << endl;
    cout << endl;

    cout << "Maximum values: " << endl;
    cout << "int: " << n_int << endl;
    cout << "short: " << n_short << endl;
    cout << "long: " << n_long << endl;
    cout << "long long: " << n_llong << endl;
    cout << endl;

    cout << "Minimum int values: = " << INT_MIN << endl;
    cout << "Bits per byte: = " << CHAR_BIT << endl;

    return 0;
}
显示结果如下
int is 4 bytes.
short is 2 bytes.
long is 8 bytes.
long long is 8 bytes.

Maximum values:
int: 2147483647
short: 32767
long: 9223372036854775807
long long: 9223372036854775807

Minimum int values: = -2147483648
Bits per byte: = 8

我们来看一下该程序的主要编程特性。
1.运算符sizeof和头文件limits
可对类型名或变量名使用sizeof运算符。对类型名使用sizeof运算符时，应将名称放在括号中；但对变量名使用该运算符，括号是可选的。
头文件climits定义了符号常量表示类型的限制。如前所述，INT_MAX表示类型int能够存储的最大值。
2.初始化
初始化将赋值与声明合并在一起。例如，下面的语句声明了变量n_int，并将int的最大取值赋给它int n_int = INT_MAX;
也可以使用字面值常量来初始化。可以将变量初始化为另一个变量，条件是后者已经定义过。
甚至可以使用表达式来初始化变量，条件是当程序执行到该声明时，表达式中所有的值都是已知的。
C++还有另一种C语言没有的初始化语法：
int owls=10;   // owls初始化为10
int wrens (432);   // wrens初始化为432
注意，如果不对函数内部定义的局部变量进行初始化，该变量的值将是不确定的。
这意味着该变量的值将是它被创建之前，相应内存单元保存的值。
如果知道变量的初始值应该是什么，则应对它进行初始化。
将变量声明和赋值分开，可能会带来瞬间悬而未决的问题：
short year;
year = 1492;
然而，在声明变量时对它进行初始化，可避免以后忘记给它赋值的情况发生。
3.C++11初始化方式
还有另一种初始化方式，这种方式用于数组和结构，但在C++98中，也可用于单值变量：
int hamburgers = {24};   //hamburgers初始化为24
将大括号初始化器用于单值变量的情形还不多，但C++11标准使得这种情形更多了。
首先，采用这种方式时，可以使用等号（=），也可以不使用
int emus {7};   // emus初始化为7
int rheas = {12};   //rheas初始化为12
其次，大括号内可以不包含任何东西。在这种情况下，变量将被初始化为零：
int rocs = {};   // rocs初始化为0
int psychics {};   // psychics初始化为0
第三，这有助于更好地防范类型转换错误，这个主题将在本章末尾讨论
为何需要更多的初始化方法？有充分的理由吗？原因是让新手更容易学习C++，这可能有些奇怪。
以前，C++使用不同的方式来初始化不同的类型：初始化类变量的方式不同于初始化常规结构的方式，
而初始化常规结构的方式又不同于初始化简单变量的方式；通过使用C++新增的大括号初始化器，
初始化常规变量的方式与初始化类变量的方式更像。
C++11使得可将大括号初始化器用于任何类型（可以使用等号，也可以不使用），这是一种通用的初始化语法。
以后，教材可能介绍使用大括号进行初始化的方式，并出于向后兼容的考虑，顺便提及其他初始化方式。
3.1.4无符号类型
前面介绍的4种整型都有一种不能存储负数值的无符号变体，其优点是可以增大变量能够存储的最大值。
例如，如果short表示的范围为-32768到+32767，则无符号版本的表示范围为0-65535。
当然，仅当数值不会为负时才应使用无符号类型。
要创建无符号版本的基本整型，只需使用关键字unsigned来修改声明即可。
注意，unsigned本身是unsigned int的缩写。
程序清单3.2演示了如何使用无符号类型，并说明了程序试图超越整型的限制时将产生的后果。
程序清单3.2 exceed.cpp
#include <climits>
#include <iostream>

#define ZERO 0

using namespace std;

int main()
{
    short sam = SHRT_MAX;
    unsigned short sue = sam;

    cout << "Sam has " << sam << " dollars and Sue has " << sue << " dollars deposited." << endl;
    cout << "Add $1 to each account." << endl << "Now ";
    sam = sam + 1;
    sue = sue + 1;
    cout << "Sam has " << sam << " dollars and Sue has " << sue << " dollars deposited.\n" << endl;
    sam = ZERO;
    sue = ZERO;
    cout << "Sam has " << sam << " dollars and Sue has " << sue << " dollars deposited." << endl;
    cout << "Take $1 from each account." << endl << "Now ";
    sam = sam - 1;
    sue = sue - 1;
    cout << "Sam has " << sam << " dollars and Sue has " << sue << " dollars deposited.\n" << endl;

    return 0;
}
显示结果如下
Sam has 32767 dollars and Sue has 32767 dollars deposited.
Add $1 to each account.
Now Sam has -32768 dollars and Sue has 32768 dollars deposited.

Sam has 0 dollars and Sue has 0 dollars deposited.
Take $1 from each account.
Now Sam has -1 dollars and Sue has 65535 dollars deposited.

3.1.5选择整型类型
C++提供了大量的整型，应使用哪种类型呢？通常，int被设置为对目标计算机而言最为“自然”的长度。
自然长度（natural-size）指的是计算机处理起来效率最高的长度。如果没有非常有说服力的理由来选择其他类型，则应使用int。
现在来看看可能使用其他类型的原因。如果变量表示的值不可能为负，则可以使用无符号类型，这样变量可以表示更大的值。
如果知道变量可能表示的整数值大于16位整数的最大可能值，则使用long。即使系统上int为32位，也应这样做。
这样，将程序移植到16位系统时，就不会突然无法正常工作（参见图3.2），如果要存储的值超过20亿，可使用long long。
如果short比int小，则使用short可以节省内存。例如，假设要将程序从int为16位的系统移到int为32位的系统，
则用于存储int数组的内存量将加倍，但short数组不受影响。如果只需要一个字节，可使用char，这将稍后介绍。
3.1.6 整型字面值
整型字面值（常量）是显式书写的整型常量，与C相同，C++能够以三种不同的计数方式来书写整数：基数为10、基数为8和基数为16。
C++使用前一（两）位来标识数字常量的基数。
如果第一位为1~9，则基数为10（十进制）；因此93是以10为基数的。
如果第一位是0，第二位为1~7，则基数为8（八进制）；因此042的基数是8，它相当于十进制数34。
如果前两位为0x或0X，则基数为16（十六进制）；因此0x42为十六进制数，相当于十进制数66，
对于十六进制数，字符a~f和A-F对应于10-15，0xF为15，0xA5为165，程序清单3.3演示了这三种基数。
程序清单3.3 hexoct.cpp
#include <iostream>

using namespace std;

int main()
{
    int chest = 42;
    int waist = 0x42;
    int inseam = 042;

    cout << "Monsieur cuts a striking figure!\n";
    cout << "Chest = " << chest << " (42 in decimal)\n";
    cout << "Waist = " << waist << " (0x42 in hex)\n";
    cout << "inseam = " << inseam << " (042 in octal)\n";

    return 0;
}
显示结果如下
Monsieur cuts a striking figure!
Chest = 42 (42 in decimal)
Waist = 66 (0x42 in hex)
inseam = 34 (042 in octal)

顺便说一句，如果要以十六进制或八进制方式显示值，则可以使用cout的一些特殊特性。
前面指出过，头文件iostream提供了控制符endl，用于指示cout重起一行。
同样，它还提供了控制符dec、hex和oct，分别用于指示cout以十进制、十六进制和八进制格式显示整数。
程序清单3.4使用了hex和oct以上述三种格式显示十进制值42，默认格式为十进制，在修改格式之前，原来的格式将一直有效。
程序清单3.4 hexoct2.cpp
#include <iostream>

using namespace std;

int main()
{
    int chest = 42;
    int waist = 42;
    int inseam = 42;

    cout << "Monsieur cuts a striking figure!\n";
    cout << "Chest = " << chest << " (decimal for 42)\n";
    cout << hex << "Waist = " << waist << " (hexadecimal for 42)\n";
    cout << oct << "inseam = " << inseam << " (octal for 42)\n";

    return 0;
}
显示结果如下
Monsieur cuts a striking figure!
Chest = 42 (decimal for 42)
Waist = 2a (hexadecimal for 42)
inseam = 52 (octal for 42)

3.1.7 C++如何确定常量的类型
变量声明时指明了类型，但是，编译器如何知道常量的类型呢？
假设在程序中使用常量1492表示一个数字，程序将把1492存储为int，long还是其他整型呢？
答案是，除非有理由存储为其他类型（如使用了特殊的后缀来表示特定的类型，或者值太大，不能存储为int），否则C++将整型常量存储为int类型。
先来看看后缀。后缀是放在数字常量后面的字母，用于表示类型。
整数后面的l或L后缀表示该整数为long常量，u或U后缀表示unsigned int常量，
ul（可以采用任何一种顺序，大写小写均可）表示unsigned long常量（由于小写l看上去像数字1，因此应使用大写L作后缀）。
C++11提供了用于表示类型long long的后缀ll和LL，还提供了用于表示类型unsigned long long的后缀ull，Ull，uLL和ULL。
接下来考察长度。在C++中，对十进制整数采用的规则，与十六进制和八进制稍微有些不同。
对于不带后缀的十进制整数，将使用下面几种类型中能够存储该数的最小类型来表示：int，long或long long。
对于不带后缀的十六进制或八进制整数，将使用下面几种类型中能够存储该数的最小类型来表示：
int，unsigned int，long，unsigned long，long long或unsigned long long。
3.1.8 char类型：字符和小整数
下面介绍最后一种整型：char类型。顾名思义，char类型是专为存储字符（如字母和数字）而设计的。
现在，存储数字对于计算机来说算不了什么，但存储字母则是另一回事。编程语言通过使用字母的数值编码解决了这个问题。
因此，char类型是另一种整型。它足够长，能够表示目标计算机系统中的所有基本符号（所有的字母、数字、标点符号等）。
实际上，很多系统支持的字符都不超过128个，因此用一个字节就可以表示所有的符号。
因此，虽然char最常被用来处理字符，但也可以将它用做比short更小的整型。
在美国，最常用的符号集是ASCII字符集（参见附录C），字符集中的字符用数值编码（ASCII码）表示。
例如，字符A的编码为65，字母M的编码为77，为方便起见，本书在示例中使用的是ASCII码。
然而，C++实现使用的是其主机系统的编码-例如，IBM大型机使用EBCDIC编码。
ASCII和EBCDIC都不能很好地满足国际需要，C++支持的宽字符类型可以存储更多的值，如国际Unicode字符集使用的值。
本章稍后将介绍wchar_t类型。程序清单3.5使用了char类型
程序清单3.5 chartype.cpp
#include <iostream>

using namespace std;

int main()
{
    char ch;

    cout << "Enter a character: " << endl;
    cin >> ch;
    cout << "Hola! ";
    cout << "Thank you for the " << ch << " character." << endl;

    return 0;
}
显示结果如下
Enter a character:
A
Hola! Thank you for the A character.

程序清单3.6 morechar.cpp
#include <iostream>

using namespace std;

int main()
{
    char ch = 'M';
    int i = ch;
    cout << "The ASCII code for " << ch << " is " << i << endl;

    cout << "Add one to the character code: " << endl;
    ch = ch + 1;
    i = ch;
    cout << "The ASCII code for " << ch << " is " << i << endl;

    cout << "Display char ch using cout.put(ch): ";
    cout.put(ch);

    cout.put('!');

    cout << endl << "Done" << endl;

    return 0;
}
显示结果如下
The ASCII code for M is 77
Add one to the character code:
The ASCII code for N is 78
Display char ch using cout.put(ch): N!
Done

程序清单3.7演示了一些转义序列。
程序清单3.7 bondini.cpp
#include <iostream>

using namespace std;

int main()
{
    cout << "\aOperation \"HyperHype\" is now activated!\n";
    cout << "Enter your agent code:________\b\b\b\b\b\b\b\b";
    long code = 0;
    cin >> code;
    cout << "\aYou entered " << code << "\n";
    cout << "\aCode varified! Proceed with Plan Z3!\n";

    return 0;
}
显示结果如下
Operation "HyperHype" is now activated!
Enter your agent code:123_____
You entered 123
Code varified! Proceed with Plan Z3!

C++通用字符名（universal character name）
通用字符名类似于转义序列。但是，普通的转义序列只能出现于字符常量和字符串字面量中，
而通用字符名还可以用于标识符。这个特性允许程序员在为变量、函数等命名时使用他们的本国语言。
可以用两种方式书写通用字符名（\udddd和\Udddddddd），每个d都是一个十六进制的数字。
在格式\Udddddddd中，8个d组成一个8位的十六进制数用于标识目标字符的UCS码点。
格式\udddd可以用于码点的十六进制值为FFFF或更小的字符。
并不是所有的通用字符名都可以用于标识符，C++标准列出了哪些通用字符名可以用于标识符。
此外，标识符不能以表示数字的通用字符名开头。

signed char和unsigned char
与int不同的是，char在默认情况下既不是没有符号，也不是有符号。
是否有符号由C++实现决定，这样编译器开发人员可以最大限度地将这种类型与硬件属性匹配起来。
如果char有某种特定的行为对您来说非常重要，则可以显式地将类型设置为signed char或unsigned char。
如果将char用作数值类型，则unsigned char和signed char之间的差异将非常重要。
unsigned char类型的表示范围通常为0~255，而signed char的表示范围为-128到127，
例如，假设要使用一个char变量来存储像200这样大的值，则在某些系统上可以，而在另一些系统上可能不可以。
但使用unsigned char可以在任何系统上达到这种目的。
wchar_t
程序需要处理的字符集可能无法用一个8位的字节表示，如日文汉字系统。对于这种情况，C++的处理方式有两种。
首先，如果大型字符集是实现的基本字符集，则编译器厂商可以将char定义为一个16位的字节或更长的字节。
其次，一种实现可以同时支持一个小型基本字符集和一个较大的扩展宝符集。
8位char可以表示基本字符集，另一种类型wchar_t（宽字符类型）可以表示扩展字符集。
wchar_t类型是一种整数类型，它有足够的空间，可以表示系统使用的最大扩展字符集。
这种类型与另一种整型（底层（underlying）类型）的长度和符号属性相同。
对底层类型的选择取决于实现，因此在一个系统中，它可能是unsigned short，而在另一个系统中，则可能是int。
cin和cout将输入和输出看作是char流，因此不适于用来处理wchar t类型。
iostream头文件的最新版本提供了作用相似的工具wcin和wcout，可用于处理wchar_t流。
另外，可以通过加上前缀L来指示宽字符常量和宽字符串。下面的代码将字母P的wchar_t版本存储到变量bob电，并显示单词tall的wchar_t版本：
wchar_t bob =L'p'；
wcout << L"tall" << endl;
在支持两字节wchar_t的系统中，上述代码将把每个字符存储在一个两个字节的内存单元中。
本书不主用宽字符类型，但读者应知道有这种类型，尤其是在进行国际编程或使用Unicode或ISO 10646时。
7，C++11新增的类型：char16_t和char32_t
随着编程人员日益熟悉Unicode，类型wchar_t显然不再能够满足需求。
事实上，在计算机系统上进行字符和字符串编码时，仅使用Unicode码点并不够。
具体地说，进行字符串编码时，如果有特定长度和符号特征的类型，将很有帮助，而类型wchar_t的长度和符号特征随实现而定。
因此，C++11新增了类型char16_t和char32_t，其中前者是无符号的，长16位，而后者也是无符号的，但长32位。
C++11使用前缀u表示char16_t字符常量和字符串常量，如u'C'和u"be good"；
并使用前缀U表示char32_t常量，如U'R'和U"dirty rat"，类型char16_t与\udddd形式的通用字符名匹配，
而类型char32_t与\Udddddddd形式的通用字符名匹配
前缀u和U分别指出字符字面值的类型为char16_t和char32_t
char16_t ch1 = u'q';
char32_t ch2 = U'\U0000222B';
与wchart一样，char16_t和char32_t也都有底层类型（一种内置的整型），但底层类型可能随系统而定。
3.1.9 bool类型
ANSI/ISO C++标准添加了一种名叫bool的新类型（对C++来说是新的），
过去，C++和C一样，也没有布尔类型。在第5章和第6章中将会看到，C++将非零值解释为true，将零解释为false。
然而，现在可以使用bool类型来表示真和假了，它们分别用预定义的字面值true和false表示。
也就是说，可以这样编写语句：
bool is_ready = true;
字面值true和false都可以通过提升转换为int类型，true被转换为1，而false被转换为0：
int ans = true;   //ans初始化为1
int promise = false;   //promise初始化为0
另外，任何数字值或指针值都可以被隐式转换（即不用显式强制转换）为bool值。
任何非零值都被转换为true，而零被转换为false。
在第6章介绍if语句后，示例中将经常使用数据类型bool。
3.2 const限定符
现在回过头来介绍常量的符号名称。符号名称指出了常量表示的内容。
另外，如果程序在多个地方使用同一个常量，则需要修改该常量时，只需修改一个符号定义即可。
本章前面关于#define语句的说明指出过，C++有一种更好的处理符号常量的方法，
这种方法就是使用const关键字来修改变量声明和初始化。
例如，假设需要一个表示一年中月份数的符号常量，请在程序中输入下面这行代码：
const int Months =12;
这样便可以在程序中使用Months，而不是12了。
常量（如Months）被初始化后，其值就被固定了，编译器将不允许再修改该常量的值。
如果您这样做，g++将指出程序试图给一个只读变量赋值。
关键字const叫做限定符，因为它限定了声明的含义。
一种常见的做法是将名称的首字母大写，以提醒您Months是个常量。
这决不是一种通用约定，但在阅读程序时有助于区分常量和变量。
另一种约定是将整个名称大写，使用#define创建常量时通常使用这种约定。
创建常量的通用格式如下：
const type name-value;
注意，应在声明中对const进行初始化。如果在声明常量时没有提供值，则该常量的值将是不确定的，且无法修改。
如果以前使用过C语言，您可能觉得前面讨论的#define语句已经足够完成这样的工作了。
但const比#defien好。首先，它能够明确指定类型。
其次，可以使用C++的作用域规则将定义限制在特定的函数或文件中
（作用域规则描述了名称在各种模块中的可知程度，将在第9章讨论），
第三，可以将const用于更复杂的类型，如第4章将介绍的数组和结构。
提示：如果读者在学习C++之前学习过C语言，并打算使用#define来定义符号常量，请不要这样做，而应使用const。
ANSI C也使用const限定符，这是从C++借鉴来的。
如果熟悉ANSI C版本，则应注意，C++版本稍微有些不同。
区别之一是作用域规则，这将在第9章讨论；另一个主要的区别是，在C++（而不是C）中可以用const值来声明数组长度，
第4章将介绍一些这样的例子。
3.3浮点数
了解各种C++整型后，来看看浮点类型，它们是C++的第二组基本类型。
浮点数能够表示带小数部分的数字，它们提供的数字范围也更大。
如果数字很大，无法表示为long类型，则可以使用浮点类型来表示。
计算机将浮点数分成两部分存储。一部分表示值，另一部分用于对值进行放大或缩小。
下面扛个比方。对于数字34.1245和34124.5，它们除了小数点的位置不同外，其他都是相同的。
可以把第一个数表示为0.341245（基准值）和100（缩放因子），
而将第二个数表示为0.341245（基准值相同）和10000（缩放因子更大），
缩放因子的作用是移动小数点的位置，术语浮点因此而得名。
C++内部表示浮点数的方法与此相同，只不过它基于二进制数，因此缩放因子是2的幂，不是10的幂。
浮点数能够表示小数值、非常大和非常小的值，它们的内部表示方法与整数完全不同。
3.3.1 书写浮点数
C++有两种书写浮点数的方式。第一种是使用常用的标准小数点表示法：
即使小数部分为0（如8.0），小数点也将确保该数字以浮点格式（而不是整数格式）表示。
第二种表示浮点值的方法叫做E表示法，其外观是像这样的：3.45E6，这指的是3.45与1000000相乘的结果；
E6指的是10的6次方，即1后面6个0。因此，3.45E6表示的是3450000。
6被称为指数，3.45被称为尾数。读者可能注意到了，E表示法最适合于非常大和非常小的数。
E表示法确保数字以浮点格式存储，即使没有小数点。
注意，既可以使用E也可以使用e，指数可以是正数也可以是负数。（参见图3.3）
然而，数字中不能有空格，因此7.2 E6是非法的。
指数为负数意味着除以10的乘方，而不是乘以10的乘方。因此，8.33E-4表示8.33/10000，即0.000833。
注意，-8.33E4指的是-83300，前面的符号用于数值，而指数的符号用于缩放。
记住：d.dddE+n指的是将小数点向右移n位；而d.dddE-n指的是将小数点向左移n位。
之所以称为“浮点"，就是因为小数点可移动。
3.3.2 浮点类型
和ANSIC一样，C++也有3种浮点类型：float，double和long double，
这些类型是按它们可以表示的有效数位和允许的指数最小范围来描述的。
有效位（significant figure）是数字中有意义的位。
例如，加利福尼亚的Shasta山脉的高度为14179英尺，该数字使用了5个有效位，指出了最接近的英尺数。
然而，将Shasta山脉的高度写成约14000英尺时，有效位数为2位，因为结果经过四舍五入精确到了千位。
在这种情况下，其余的3位只不过是占位符而已。有效位数不依赖于小数点的位置。
例如，可以将高度写成14.162千英尺。这样仍有5个有效位，因为这个值精确到了第5位。
事实上，C和C++对于有效位数的要求是，float至少32位，double至少48位，且不少于float，
long double至少和double一样多。这三种类型的有效位数可以一样多。
然而，通常，float为32位，double为64位，long double为80、96或128位。
另外，这3种类型的指数范围至少是-37到37，可以从头文件cfloat或float.h中找到系统的限制。
（cfloat是C语言的float.h文件的C++版本。）
程序清单3.8演示了float和double类型及它们表示数字时在精度方面的差异（即有效位数）。
该程序预览了将在第17章介绍的ostream方法setf()。
这种调用迫使输出使用定点表示法，以便更好地了解精度，它防止程序把较大的值切换为E表示法，
并使程序显示到小数点后6位。参数ios_base::fixed和ios_base::floatfield是通过包含iostream来提供的常量。
程序清单3.8 floatnum.cpp
#include <iostream>

using namespace std;

int main()
{
    cout.setf(ios_base::fixed, ios_base::floatfield);
    float tub = 10.0 / 3.0;
    double mint = 10.0 / 3.0;
    const float million = 1.0e6;
    cout << "tub = " << tub << ", a million tubs = " << million *tub << ", \n";
    cout << "and ten million tubs = " << 10 * million *tub << endl;
    cout << "mint = " << mint << ", a million mints = " << million *mint << endl;

    return 0;
}
显示结果如下
tub = 3.333333, a million tubs = 3333333.250000,
and ten million tubs = 33333332.000000
mint = 3.333333, a million mints = 3333333.333333

1.程序说明
通常cout会删除结尾的零。例如，将3333333.250000显示为3333333.25。
调用cout.setf()将覆盖这种行为，至少在新的实现中是这样的。
这里要注意的是，为何float的精度比double低。tub和mint都被初始化为10.0/3.0。
由于cout打印6位小数，因此tub和mint都是精确的。但当程序将每个数乘以一百万后，tub在第7个3之后就与正确的值有了误差。
tub在7位有效位上还是精确的（该系统确保float至少有6位有效位，但这是最糟糕的情况）。
然而，double类型的变量显示了13个3，因此它至少有13位是精确的。由于系统确保15位有效位，因此这就没有什么好奇怪的了。
另外，将tub乘以一百万，再乘以10后，得到的结果不正确，这再一次指出了float的精度限制。
cout所属的ostream类有一个类成员函数，能够精确地控制输出的格式字段宽度、小数位数、采用小数格式还是E格式等。
第17章将介绍这些选项。为简单起见，本书的例子通常只使用<<运算符。有时候，这种方法显示的位数比需要的位数多，但这只会影响美观。
如果您介意这种问题，可以浏览第17章，了解如何使用格式化方法。然而，在这里就不作过多的解释了。
3.3.3浮点常量
在程序中书写浮点常量的时候，程序将把它存储为哪种浮点类型呢？
在默认情况下，像8.24和2.4E8这样的浮点常量都属于double类型。
如果希望常量为foat类型，请使用f或F后缀。
对于long double类型，可使用l或L后缀（由于l看起来像数字1，因此L是更好的选择），下面是一些示例：
1.234f
2.45E20F
2.345324E28
2.2L
3.3.4 浮点数的优缺点
与整数相比，浮点数有两大优点。首先，它们可以表示整数之间的值。
其次，由于有缩放因子，它们可以表示的范围大得多。
另一方面，浮点运算的速度通常比整数运算慢，且精度将降低。程序清单3.9说明了最后一点。
程序清单3.9 fltadd.cpp
#include <iostream>

using namespace std;

int main()
{
    float a = 2.34E+22F;
    float b = a + 1.0F;

    cout << "a = " << a << endl;
    cout << "b - a = " << b - a << endl;

    return 0;
}
显示结果如下
a = 2.34e+22
b - a = 0

问题在于，2.34E+22是一个小数点左边有23位的数字。加上1，就是在第23位加1。
但float类型只能表示数字中的前6位或前7位，因此修改第23位对这个值不会有任何影响。
将类型分类
C++对基本类型进行分类，形成了若干个族。类型signed char，short，int和long统称为符号整型；
它们的无符号版本统称为无符号整型；C++11新增了long long。
bool，char，wchar_t、符号整数和无符号整型统称为整型；C++11新增了char16_t和char32_t。
float，double和long double统称为浮点型。整数和浮点型统称算术（arithmetic）类型
3.4 C++算术运算符
读者可能还对学校里作的算术练习记忆犹新，在计算机上也能够获得同样的乐趣。C++使用运算符来运算。
它提供了几种运算符来完成5种基本的算术计算：加法、减法、乘法、除法以及求模。
每种运算符部使用两个值（操作数）来计算结果。运算符及其操作数构成了表达式。
例如，在下面的语句中
int wheels = 4 +2;
4和2都是操作数，+是加法运算符，4 + 2则是一个表达式，其值为6。
下面是5种基本的C++算术运算符。
+运算符对操作数执行加法运算。例如，4+20等于24。
-运算符从第一个数中减去第二个数。例如，12-3等于9。
*运算符将操作数相乘。例如，28*4等于112。
/运算符用第一个数除以第二个数。例如，1000/5等于200，如果两个操作数都是整数，则结果为商的整数部分。
例如，17/3等于5，小数部分被丢弃。
%运算符求模。也就是说，它生成第一个数除以第二个数后的余数。
例如，19%6为1，因为19是6的3倍余1，两个操作数必须都是整型，将该运算符用于浮点数将导致编译错误。
如果其中一个是负数，则结果的符号满足如下规则：
（a/b）*b + a%b =a
当然，变量和常量都可以用作操作数，程序清单3.10说明了这一点。
由于%的操作数只能是整数，因此将在后面的例子中讨论它。
程序清单3.10 arith.cpp
#include <iostream>

using namespace std;

int main()
{
    double hats, heads;

    cout.setf(ios::fixed, ios::floatfield);
    cout << "Enter number: ";
    cin >> hats;
    cout << "Enter another number: ";
    cin >> heads;
    cout << "hats = " << hats << ", heads = " << heads << endl;
    cout << "hats + heads = " << hats + heads << endl;
    cout << "hats - heads = " << hats - heads << endl;
    cout << "hats * heads = " << hats *heads << endl;
    cout << "hats / heads = " << hats / heads << endl;

    return 0;
}
显示结果如下
Enter number: 50.25
Enter another number: 11.17
hats = 50.250000, heads = 11.170000
hats + heads = 61.420000
hats - heads = 39.080000
hats * heads = 561.292500
hats / heads = 4.498657

3.4.1运算符优先级和结合性
很多表达式都包含多个运算符。这样将产生一个问题：究竟哪个运算符最先被使用呢？
例如，请看下面的语句：
int flyingpigs = 3 + 4 * 5;
操作数4旁边有两个运算符：+和*。
当多个运算符可用于同一个操作数时，C++使用优先级规则来决定首先使用哪个运算符。
算术运算符遵循通常的代数优先级，先乘除，后加减，因此3+4 * 5指的是3 + (4 * 5)，结果为23，而不是35。
当然，可以使用括号来执行自己定义的优先级。附录D介绍了所有C++运算符的优先级。
其中，*、/和%位于同一行，这说明它们的优先级相同。同样，加和减的优先级也相同，但比乘除低。
有时，优先级列表并不够用。请看下面的语句：
float logs = 120 / 4* 5;
操作数4也位于两个运算符中间，但运算符/和*的优先级相同，
因此优先级本身并不能指出程序究竟是先计算120除以4，还是先计算4乘以5，
因为第一种选择得到的结果是150，而第二种选择的结果是6。因此选择十分重要。
当两个运算符的优先级相同时，C++将看操作数的结合性：（associativity）是从左到右，还是从右到左。
从左到右的结合性意味着如果两个优先级相同的运算符被同时用于同一个操作数，则首先应用左侧的运算符。
从右到左的结合性则首先应用右侧的运算符。附录D也列出了结合性方面的信息。
从中可以看出乘除都是从左到右结合的。这说明应当先对4使用左侧的运算符，
也就是说，用120除以4，得到的结果为30，然后再乘以5，结果为150。
注意：仅当两个运算符被用于同一个操作数时，优先级和结合性规则才有效。请看下面的表达式：
int dues = 20 * 5 + 24 * 6;
运算符优先级表明了两点："程序必须在做加法之前计算20*5，必须在做加法之前计算24*6。
但优级和结合性都没有指出应先计算哪个乘法。读者可能认为，结合性表明应先做左侧的乘法，
但是在这种情况下，两个*运算符并没有用于同一个操作数，所以该规则不适用。
事实上，C++把这个问题留给了实现，让它来决定在系统中的最佳顺序。
对于这个例子来说，两种顺序的结果是一样的，但是也有两种顺序结果不同的情况。
在第5章讨论递增运算符时，将介绍一个这样的例子。
34.2除法运算符
除法运算符（/）的行为取决于操作数的类型。如果两个操作数都是整数；则C++将执行整数除法。
这意味着结果的小数部分将被丢弃，使得最后的结果是一个整数。
如果其中有一个（或两个）操作数是浮点值，则小数部分将保留，结果为浮点数。
程序清单3.11演示了C++除法如何处理不同类型的值。
和程序清单3.10一样，该程序也调用setf成员函数来修改结果的显示方式。
程序清单3.11 divide.cpp
#include <iostream>

using namespace std;

int main()
{
    cout.setf(ios::fixed, ios::floatfield);
    cout << "Integer division: 9/5 = " << 9 / 5 << endl;
    cout << "Floating-point division: 9.0/5.0 = " << 9.0 / 5.0 << endl;
    cout << "Mixed division: 9.0/5 = " << 9.0 / 5 << endl;
    cout << "double constant: 1e7/9.0 = " << 1e7 / 9.0 << endl;
    cout << "float constant: 1e7f/9.0f = " << 1e7f / 9.0f << endl;

    return 0;
}
显示结果如下
Integer division: 9/5 = 1
Floating-point division: 9.0/5.0 = 1.800000
Mixed division: 9.0/5 = 1.800000
double constant: 1e7/9.0 = 1111111.111111
float constant: 1e7f/9.0f = 1111111.125000

3.4.3求模运算符
求模运算符返回整数除法的余数。它与整数除法相结合，尤其适用于解决要求将一个量分成不同的整数单元的问题，
例如将英寸转换为英尺和英寸，或者将美元转换为元、角、分、厘。
第2章的程序清单2.6将重量单位英右转换为磅。程序清单3.12则将磅转换为英石。记住，一英石等于14磅，多数英国浴室都使用这种单位。
该程序使用整数除法来计算合多少英石，再用求模运算符来计算余下多少磅。
程序清单3.12 modulus.cpp
#include <iostream>

using namespace std;

int main()
{
    const int Lbs_per_stn = 14;

    cout << "Enter your weight in pounds: ";
    int lbs = 0;
    cin >> lbs;
    int stone = lbs / Lbs_per_stn;
    int pounds = lbs % Lbs_per_stn;
    cout << lbs << " pounds are " << stone << " stone, " << pounds << " pound(s).\n";

    return 0;
}
显示结果如下
Enter your weight in pounds: 128
128 pounds are 9 stone, 2 pound(s).

34.4 类型转换
C++丰富的类型允许根据需求选择不同的类型，这也使计算机的操作更复杂。
例如，将两个short值相加涉及到的硬件编译指令可能会与将两个long值相加不同。
由于有11种整型和3种浮点类型，因此计算机需要处理大量不同的情况，尤其是对不同的类型进行运算时。
为处理这种潜在的混乱，C++自动执行很多类型转换：
将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进行转换
表达式中包含不同的类型时，C++将对值进行转换
将参数传递给函数时，C+将对值进行转换。
如果不知道进行这些自动转换时将发生的情况，将无法理解一些程序的结果，因此下面详细地介绍这些规则。
1.初始化和赋值进行的转换
C++允许将一种类型的值赋给另一种类型的变量。这样做时，值将被转换为接收变量的类型。
例如，假设so_long的类型为long，thirty的类型为short，而程序中包含这样的语句：
so_long = thirty;
则进行赋值时，程序将thirty的值（通常是16位）扩展为long值（通常为32位），
扩展后将得到一个新值，这个值被存储在so_long中，而thirty的内容不变。
将一个值赋给值取值范围更大的类型通常不会导致什么问题。
例如，将short值赋给long变量并不会改变这个值，只是占用的字节更多而已。
然而，将一个很大的long值赋给float变量将降低精度。因为float只有6位有效数字。
因此，有些转换是安全的，有些则会带来麻烦。表3.3列出了一些可能出现的转换问题。
将较大的浮点类型转换为较小的浮点类型，如将double转换为float，
精度（有效数位）降低，值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的。
将浮点类型转换为整型
小数部分丢失，原来的值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的。
将较大的整型转换为较小的整型，如将long转换为short
原来的值可能超出目标类型的取值范围，通常只复制右边的字节。
将0赋给bool变量时，将被转换为false；而非零值将被转换为true。
将浮点值赋给整型将导致两个问题。
首先，将浮点值转换为整型会将数字截短（除掉小数部分），其次，float值对于int变量来说可能太大了。
在这种情况下，C++并没有定义结果应该是什么；这意味着不同的C++实现得到的结果可能不同。
传统初始化的行为与赋值相同，程序清单3.13演示了一些初始化进行的转换。
程序清单3.13 assign.cpp
#include <iostream>

using namespace std;

int main()
{
    cout.setf(ios::fixed, ios::floatfield);
    float tree = 3;
    int guess = 3.9832;
    int debt = 7.2E12;

    cout << "tree = " << tree << endl;
    cout << "guess = " << guess << endl;
    cout << "debt = " << debt << endl;

    return 0;
}
编译结果如下
g++ -o assign assign.cpp
assign.cpp: In function ‘int main()’:
assign.cpp:10:16: warning: overflow in conversion from ‘double’ to ‘int’ changes value from ‘7.2e+12’ to ‘2147483647’ [-Woverflow]
   10 |     int debt = 7.2E12;
      |                ^~~~~~

显示结果如下
tree = 3.000000
guess = 3
debt = 2147483647

以{}方式初始化时进行的转换（C++11）
C++11将使用大括号的初始化称为列表初始化（list-initialization），
因为这种初始化常用于给复杂的数据类型提供值列表。
与程序清单13.3所示的初始化方式相比，它对类型转换的要求更严格。
具体地说，列表初始化不允许缩窄（narrowing），即变量的类型可能无法表示赋给它的值。
例如，不允许将浮点型转换为整型。在不同的整型之间转换或将整型转换为浮点型可能被允许，
条件是编译器知道目标变量能够正确地存储赋给它的值。
例如，可将long变量初始化为int值，因为long总是至少与int一样长；
相反方向的转换也可能被允许，只要int变量能够存储赋给它的long常量。
const int code = 66;
int x = 66;
char c1 {31325};   //narrowing，not allowed
char c2 = {66};   // allowed because char can hold 66
char c3 {code};   // allowed because char can hold 66
char c4 = {x};   //not allowed，x is not constant
x=31325;
char cs = x;   //allowed by this form of initialization
在上述代码中，初始化c4时，您知道x的值为66，但在编译器看来，x是一个变量，其值可能很大。
编译器不会跟踪下述阶段可能发生的情况：从x被初始化到它被用来初始化c4。
表达式中的转换
当同一个表达式中包含两种不同的算术类型时，将出现什么情况呢？
在这种情况下，C++将执行两种自动转换：
首先，一些类型在出现时便会自动转换；其次，有些类型在与其他类型同时出现在表达式中时将被转换。
先来看看自动转换。在计算表达式时，C++将bool，char，unsigned char，signed char和short值转换为int。
具体地说，true被转换为1，false被转换为0。这些转换被称为整型提升（integral promotion）。请看下面的语句：
short chickens = 20;
short ducks = 35;
short fowl = chickens + ducks;
为执行第3条语句，C++程序取得chickens和ducks的值，并将它们转换为int，
然后，程序将结果转换为short类型，因为结果将被赋给一个short变量。
这种说法可能有点拗口，但是情况确实如此。
通常将int类型选择为计算机最自然的类型，这意味着计算机使用这种类型时，运算速度可能最快。
还有其他一些整型提升：如果short比int短，则unsigned short类型将被转换为int；
如果两种类型的长度相同，则unsigned short类型将被转换为unsigned int。
这种规则确保了在对unsigned short进行提升时不会损失数据。
同样，wchar_t被提升成为下列类型中第一个宽度足够存储wchar_t取值范围的类型：
int，unsigned int，long或unsigned long。
将不同类型进行算术运算时，也会进行一些转换，例如将int和float相加时。
当运算涉及两种类型时，较小的类型将被转换为较大的类型。
例如，程序清单3.11中的程序用9.0除以5。由于9.0的类型为double，因此程序在用5除之前，将5转换为double类型。
总之，编译器通过校验表来确定在算术表达式中执行的转换。
C++11对这个校验表稍做了修改，下面是C++11版本的校验表，编译器将依次查阅该列表
（1）如果有一个操作数的类型是long double，则将另一个操作数转换为long double。
（2）否则，如果有一个操作数的类型是double，则将另一个操作数转换为double。
（3）否则，如果有一个操作数的类型是float，则将另一个操作数转换为float。
（4）否则，说明操作数都是整型，因此执行整型提升。
（5）在这种情况下，如果两个操作数都是有符号或无符号的，且其中一个操作数的级别比另一个低，
则转换为级别高的类型。
（6）如果一个操作数为有符号的，另一个操作数为无符号的，且无符号操作数的级别比有符号操作数高，
则将有符号操作数转换为无符号操作数所属的类型。
（7）否则，如果有符号类型可表示无符号类型的所有可能取值，则将无符号操作数转换为有符号操作数所属的类型。
（8）否则，将两个操作数都转换为有符号类型的无符号版本。
ANSI C遵循的规则与ISO 2003 C+相同，这与前述规则稍有不同；而传统K&R C的规则又与ANSI C稍有不同。
例如，传统C语言总是将float提升为double，即使两个操作数都是float。
前面的列表谈到了整型级别的概念，简单地说，
有符号整型按级别从高到低依次为long long，long，int，short和signed char；
无符号整型的排列顺序与有符号整型相同。
类型char，signed char和unsigned char的级别相同。
类型bool的级别最低。
wchar_t、char16_t和char32_t的级别与其底层类型相同。
传递参数时的转换
正如第7章将介绍的，传递参数时的类型转换通常由C++函数原型控制。
然而，也可以取消原型对参数传递的控制，尽管这样做并不明智。
在这种情况下，C++将对char和short类型（signed和unsigned）应用整型提升。
另外，为保持与传统C语言中大量代码的兼容性，在将参数传递给取消原型对参数传递控制的函数时，
C++将float参数提升为double。
强制类型转换
C++还允许通过强制类型转换机制显式地进行类型转换。（C++认识到，必须有类型规则，而有时又需要推翻这些规则。）
强制类型转换的格式有两种。例如，为将存储在变量thorn中的int值转换为long类型，可以使用下述表达式中的一种：
(long) thorn
long (thorn)
强制类型转换不会修改thorn变量本身，而是创建一个新的、指定类型的值，可以在表达式中使用这个值。
强制转换的通用格式如下：
(typeName) value
typeName (value)
第一种格式来自C语言，第二种格式是纯粹的C++。新格式的想法是，要让强制类型转换就像是函数调用。
这样对内置类型的强制类型转换就像是为用户定义的类设计的类型转换。
C++还引入了4个强制类型转换运算符，对它们的使用要求更为严格，这将在第15章介绍。
在这四个运算符中，static_cast<>可用于将值从一种数值类型转换为另一种数值类型。
例如，可以像下面这样将thorn转换为long类型：static cast<long> (thorn)
推而广之，可以这样做：static_cast<typeName> (value)
Stroustrup认为，C语言式的强制类型转换由于有过多的可能性而极其危险，这将在第15章更深入地讨论。
运算符static_cast比传统强制类型转换更严格。
程序清单3.14演示了这两种基本的强制类型转换和static_cast<>。
程序清单3.14 typecast.cpp
#include <iostream>

using namespace std;

int main()
{
    int auks, bats, coots;

    auks = 19.99 + 11.99;

    bats = (int) 19.99 + (int) 11.99;
    coots = int(19.99) + int(11.99);
    cout << "auks = " << auks << ", bats = " << bats << ", coots = " << coots << endl;

    char ch = 'Z';
    cout << "The code for " << ch << " is ";
    cout << int(ch) << endl;
    cout << "Yes, the code is " << static_cast<int> (ch) << endl;

    return 0;
}
显示结果如下
auks = 31, bats = 30, coots = 30
The code for Z is 90
Yes, the code is 90

3.4.5 C++11中的auto声明
C++11新增了一个工具，让编译器能够根据初始值的类型推断变量的类型。为此，它重新定义了auto的含义。
auto是一个C语言关键字，但很少使用，有关其以前的含义，请参阅第9章。
在初始化声明中，如果使用关键字auto，而不指定变量的类型，编译器将把变量的类型设置成与初始值相同：
auto n= 100;   // n is int
auto x = 1.5;   // x is double
auto y =1.3e12L;   // y is long double
然而，自动推断类型并非为这种简单情况而设计的；事实上，如果将其用于这种简单情形，甚至可能让您误入歧途。
例如，假设您要将x、y和z都指定为double类型，并编写了如下代码：
auto x =0.0; // ok，x is double because 0.0 is double
double y = 0;   // ok，0 automatically converted to 0.0
auto z = 0;   // oops，z is int because 0 is int
显式地声明类型时，将变量初始化0（而不是0.0）不会导致任何问题，但采用自动类型推断时，这却会导致问题。
处理复杂类型，如标准模块库（STL）中的类型时，自动类型推断的作用才能显现出来。
例如，对于下述C++98代码：
std::vector<double> scores;
std::vector<double>::iterator p_itr = scores.begin();
C++11允许您将其重写为下面这样：
std::vector<double> scores;
auto p_itr = scores.begin();
本书后面讨论相关的主题时，将再次提到auto的这种新含义。
3.5总结
C++的基本类型分为两组：一组由存储为整数的值组成，另一组由存储为浮点格式的值组成。
整型之间通过存储值时使用的内存量及有无符号来区分。
整型从最小到最大依次是：bool，char，signed char，unsigned char，short，unsigned short，
int，unsigned int，long、unsigned long以及C++11新增的long long和unsigned long long。
还有一种wchar_t类型，它在这个序列中的位置取决于实现。
C++11新增了类型char16_t和char32_t，它们的宽度足以分别存储16和32位的字符编码。
C++确保了char足够大，能够存储系统基本字符集中的任何成员，而wchar_t则可以存储系统扩展字符集中的任意成员，
short至少为16位，而int至少与short一样长，long至少为32位，且至少和int一样长。确切的长度取决于实现。
字符通过其数值编码来表示。
浮点类型可以表示小数值以及比整型能够表示的值大得多的值。
3种浮点类型分别是float，double和long double。
C++确保float不比double长，而double不比long double长。
通常，float使用32位内存，doublo使用64位，long double使用80到128位。
通过提供各种长度不同、有符号或无符号的类型，c++使程序员能够根据特定的数据要求选择合适的类型。
C++使用运算符来提供对数字类型的算术运算：加、减、乘、除和求模。
当两个运算符对同一个操作数进行操作时，C++的优先级和结合性规则可以确定先执行哪种操作。
对变量赋值、在运算中使用不同类型、使用强制类型转换时，C+将把值从一种类型转换为另一种类型。
很多类型转换都是“安全的”，即可以在不损失和改变数据的情况下完成转换。
例如，可以把int值转换为long值，而不会出现任何问题。
对于其他一些转换，如将浮点类型转换为整型，则需要更加小心。
3.6 复习题
1.为什么C++有多种整型？
方便根据特定需求选择最适合的类型。

2.声明与下述描述相符的变量
a.short整数，值为80
b.unsigned int整数，值为42110
c.值为3000000000的整数

short a = 80;
unsigned int b = 42110;
unsigned long c = 3000000000; 或者 long long d = 3000000000;

3.C++提供了什么措施来防止超出整型的范围？
C++没有提供自动防止超出整型限制的功能，可以使用头文件climits来确定限制情况。

4.33L与33之间有什么区别？
常量33L的类型为long，常量33的类型为int

5，下面两条C++语句是否等价？
char grade = 65;
char grade ='A';
不等价
65是一个int常量，而'A'是一个char常量

6，如何使用C++来找出编码88表示的字符？指出至少两种方法。
char ch = 88;
cout << ch << endl;
cout.put ( char (88) );
cout << char (88) << endl;
cout  << (char) 88 << endl;

7，将long值赋给float变量会导致舍入误差，将long值赋给double变量呢？将long long值赋给double变量呢？
这个问题的答案取决于这两个类型的长度。如果long为4个字节，则没有损失。因为此时long的最大值只有10位数字。
由于double提供了至少15位有效数字，因而不需要进行任何舍入。
long long类型可提供19位有效数字，超过了double保证的15位有效数字。

8，下列C++表达式的结果分别是多少？
a.8*9+2
b.6*3/4
c.3/4*6
d.6.0*3/4
e.15%4

74
4
0
4.5
3

9.假设x1和x2是两个double变量，您要将它们作为整数相加，再将结果赋给一个整型变量。
请编写一条完成这项任务的C++语句。如果要将它们作为double值相加并转换为int呢？

int y = (int) x1 +  (int) x2;
int y = int (x1) + int (x2);

int z = (int) (x1 + x2);
int z = int (x1 + x2);


10，下面每条语句声明的变量都是什么类型？
a.auto cars = 15;
b.auto iou = 150.37f;
c.auto level= 'B';
d.auto crat =U'\U00002155'
e.auto fract =8.25f/2.5

int
float
char
char32_t
double

3.7编程练习
1.编写一个小程序，要求用户使用一个整数指出自己的身高（单位为英寸），然后将身高转换为英尺和英寸。
该程序使用下划线字符来指示输入位置。另外，使用个const符号常量来表示转换因子。
#include <iostream>

int main()
{
    std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);
    const int Foot_inch = 12;
    const double Inch_sm = 2.54;

    double Growth = 0;
    std::cout << "Enter your height in centimeters: ___\b\b\b";
    std::cin >> Growth;

    double Growth_inch = Growth / Inch_sm;
    std::cout << "Height in inches: " << Growth_inch << std::endl;

    int f = int (Growth_inch) / Foot_inch;
    int d = int (Growth_inch) % Foot_inch;
    std::cout << "Your height: " << f << " foot " << d << " inch" << std::endl;

    return 0;
}
显示结果如下
Enter your height in centimeters: 168
Height in inches: 66.141732
Your height: 5 foot 6 inch

2.编写一个小程序，要求以几英尺几英寸的方式输入其身高，并以磅为单位输入其体重。（使用3个变量来存储这些信息。）
该程序报告其BMI（Body Mass Index，体重指数）。
为了计算BMI，该程序以英寸的方式指出用户的身高（1英尺为12英寸），
并将以英寸为单位的身高转换为以米为单位的身高（1英寸=0.0254米），
然后，将以磅为单位的体重转换为以千克为单位的体重（1千克=2.2磅），
最后，计算相应的BMI = 体重（千克）除以身高（米）的平方，用符号常量表示各种转换因子。
#include <iostream>
#include <cmath>

int main()
{
    std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);

    const int Foot_inch = 12;
    const double Inch_metr = 0.0254;
    const double kg_pound = 2.2;

    int height_foot = 0;
    std::cout << "How many foot are in you: ___\b\b\b";
    std::cin >> height_foot;

    int height_inch = 0;
    std::cout << "How many inches are in you: __\b\b";
    std::cin >> height_inch;

    int weight_and_pounds = 0;
    std::cout << "Enter your weight in pounds: ___\b\b\b";
    std::cin >> weight_and_pounds;

    height_inch += height_foot * Foot_inch;

    double height_meters = height_inch * Inch_metr;

    double weight_in_kilograms = weight_and_pounds / kg_pound;

    double bmi = weight_in_kilograms / pow(height_meters, 2);

    std::cout << "BMI = " << bmi << std::endl;

    return 0;
}
显示结果如下
How many foot are in you: 5__
How many inches are in you: 6_
Enter your weight in pounds: 138
BMI = 22.320355

3.编写一个程序，要求用户以度、分、秒的方式输入一个纬度，然后以度为单位显示该纬度。
1度为60分，1分等于60秒，请以符号常量的方式表示这些值。对于每个输入值，应使用一个独立的变量存储它。
#include <iostream>
#include <cmath>

int main()
{
    std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);

    const double degree_minute = 60;
    const double degree_second = degree_minute * 60;

    std::cout << "Enter a latitude in degrees, minutes, and seconds: " << std::endl;

    std::cout << "First, enter the degrees:__\b\b ";
    int degrees = 0;
    std::cin >> degrees;

    std::cout << "Next, enter the minutes of arc:__\b\b ";
    int minutes = 0;
    std::cin >> minutes;

    std::cout << "Finally, enter the seconds of arc:__\b\b ";
    int seconds = 0;
    std::cin >> seconds;

    double Result = degrees + (minutes / degree_minute) + (seconds / degree_second);
    std::cout << degrees << " degrees, " << minutes << " minutes, " << seconds << " seconds = " << Result << " degrees\n";

    return 0;
}
显示结果如下
Enter a latitude in degrees, minutes, and seconds:
First, enter the degrees: 37
Next, enter the minutes of arc: 51
Finally, enter the seconds of arc: 19
37 degrees, 51 minutes, 19 seconds = 37.855278 degrees

4，编写一个程序，要求用户以整数方式输入秒数（使用long或long long变量存储），
然后以天、小时、分钟和秒的方式显示这段时间。
使用符号常量来表示每天存多少小时、每小时有多少分钟以及每分钟有多少秒。
#include <iostream>
#include <cmath>

int main()
{
    std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);

    const int Day = 24;
    const int Hour = 60;
    const int Minute = 60;

    long long int enter_seconds = 0;
    std::cout << "Enter the number of seconds: ________\b\b\b\b\b\b\b\b";
    std::cin >> enter_seconds;

    int seconds = (enter_seconds % Minute);
    int minutes = (enter_seconds / Minute) % Hour;
    int hours = ( enter_seconds / (Minute * Hour) ) % Day;
    int days = enter_seconds / (Minute * Hour * Day);

    std::cout << enter_seconds << " seconds = " << days << " days, " << hours << " hours, " << minutes << " minutes, ";
    std::cout << seconds << " seconds" << std::endl;

    return 0;
}
显示结果如下
Enter the number of seconds: 99999___
99999 seconds = 1 days, 3 hours, 46 minutes, 39 seconds

5.编写一个程序，要求用户输入全球当前的人口和美国当前的人口（或其他国家的人口），
将这些信息存储在long long变量中，并让程序显示美国（或其他国家）的人口占全球人口的百分比。
#include <iostream>
#include <cmath>

int main()
{
    std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);

    unsigned long long int world_population = 0;
    std::cout << "Enter the world's population: ___________\b\b\b\b\b\b\b\b\b\b\b";
    std::cin >> world_population;

    unsigned long long int population_country = 0;
    std::cout << "Enter the population of the country: ___________\b\b\b\b\b\b\b\b\b\b\b";
    std::cin >> population_country;

    double Result = double(population_country) / world_population * 100;
    std::cout << "The population of the country is " << Result << "% of the world population." << std::endl;

    return 0;
}
显示结果如下
Enter the world's population: 6898758899_
Enter the population of the country: 310783781__
The population of the country is 4.504923% of the world population.

6.编写一个程序，要求用户以公里为单位输入距离，并以升为单位输入汽油量，然后指出每100公里的耗油量（升）。
#include <iostream>
#include <cmath>

int main()
{
    std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);
    const int km_100 = 100;

    double kilometers = 0;
    std::cout << "Enter the distance in kilometers: ";
    std::cin >> kilometers;

    double litres = 0;
    std::cout << "Enter the amount of spent gasoline in litres: ";
    std::cin >> litres;

    double Result = ( (litres / kilometers) * km_100 );
    std::cout << "Fuel consumption: " << Result << " litres / 100km" << std::endl;

    return 0;
}
显示结果如下
Enter the distance in kilometers: 168
Enter the amount of spent gasoline in litres: 13.8
Fuel consumption: 8.214286 litres / 100km

7.编写一个程序，要求用户按欧洲风格输入汽车的耗油量（每100公里消耗的汽油量（升）），
然后将其转换为美国风格的耗油量，每加仑多少英里。
1英里等于1.609公里，1加仑等于3.785升。

(y 升/100公里) = 100  / ( (x 英里/加仑 ) * (1.609 / 3.785) )

(x 英里/加仑 ) = 100 / ( (y 升/100公里) * (1.609 / 3.785) )

#include <iostream>
#include <cmath>

int main()
{
    std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);
    const double mile_km = 1.609;
    const double gl_litr = 3.785;

    std::cout << "Enter the number of liters per 100 kilometers: ";
    double litr_100km = 0.0;
    std::cin >> litr_100km;

    double mile_gl = 100 / ( litr_100km * (mile_km / gl_litr) );

    std::cout << "Answer " << mile_gl << " Miles per gallon" << std::endl;

    return 0;
}
显示结果如下
Enter the number of liters per 100 kilometers: 14.7
Answer 16.002672 Miles per gallon

Enter the number of liters per 100 kilometers: 12.4
Answer 18.970910 Miles per gallon

Enter the number of liters per 100 kilometers: 8.7
Answer 27.038998 Miles per gallon

第4章复合类型
4.1 数组
4.1.1 程序说明
4.1.2 数组的初始化规则
4.1.3 C++11数组初始化方法
4.2 字符串
4.2.1 拼接字符串常量
4.2.2 在数组中使用字符串
4.2.3 字符串输入
4.2.4 每次读取一行字符串输入
4.2.5 混合输入字符串和数字
4.3 string类简介
4.3.1 C++11字符串初始化
4.3.2 赋值、拼接和附加
4.3.3 string类的其他操作
4.3.4 string类I/O
43.5 其他形式的字符串字面值
4.4 结构简介
4.4.1 在程序中使用结构
4.4.2 C++11结构初始化
4.4.3 结构可以将string类作为成员吗
4.4.4 其他结构属性
4.4.5 结构数组
4.4.6 结构中的位字段
4.5 共用体
4.6 枚举
4.6.1 设置枚举量的值
4.6.2 枚举的取值范围
4.7 指针和自由存储空间
4.7.1 声明和初始化指针
4.7.2 指针的危险
4.7.3 指针和数字
4.7.4 使用new来分配内存
4.7.5.使用delete释放内存
4.7.6 使用new来创建动态数组
4.8 指针、数组和指针算术
4.8.1 程序说明
4.8.2 指针小结
4.8.3 指针和字符串
4.8.4 使用new创建动态结构
4.8.5 自动存储、静态存储和动态存储
4.9 类型组合
4.10 数组的替代品
4.10.1 模板类vector
4.10.2 模板类array（C++11）
4.10.3 比较数组、vector对象和array对象
4.11 总结
4.12 复习题
4.13 编程练习
本章内容包括：
创建和使用数组。
创建和使用C风格字符串。
创建和使用string类字符串。
使用方法getline和get读取字符串。
混合输入字符串和数字。
创建和使用结构。
创建和使用共用体。
创建和使用枚举。
创建和使用指针。
使用new和delete管理动态内存。
创建动态数组。
创建动态结构。
自动存储、静态存储和动态存储。
vector和array类简介。
复合类型是基于基本整型和浮点类型创建的，包括类，数组，字符串，结构，联合。
4.1数组
数组（array）是一种数据格式，能够存储多个同类型的值。每个值都存储在一个独立的数组元素中，计算机在内存中依次存储数组的各个元素。
要创建数组，可使用声明语句。数组声明应指出以下三点：数组元素的类型，数组名，数组元素的个数。
在C++中，可以通过修改简单变量的声明，添加中括号（其中包含元素数目）来完成数组声明。
事实上，可以将数组中的每个元素看作是一个简单变量。
声明数组的通用格式如下：
typeName arrayName [arraysrze];
表达式 arraySize 指定元素数目，它必须是整型常数或const值，也可以是常量表达式。
具体地说，arraySize不能是变量，变量的值是在程序运行时设置的。
数组的很多用途都是基于这样一个事实：可以单独访问数组元素。方法是使用下标或索引来对元素进行编号。
C++数组从0开始编号，C++使用带索引的方括号来指定数组元素，最后一个元素的索引比数组长度小1（参见图4.1）。
编译器不会检查使用的下标是否有效。例如，如果将一个值赋给不存在的元素，编译器并不会指出错误。
但是程序运行后，这种赋值可能引发问题，它可能破坏数据或代码，也可能导致程序异常终止。
所以必须确保程序只使用有效的下标值。
程序清单4.1 arrayone.cpp
#include <iostream>

using namespace std;

int main()
{
    int yams[3];
    yams[0] = 7;
    yams[1] = 8;
    yams[2] = 6;

    int yamcosts[3] = { 20, 30, 5 };

    cout << "Total yams = " << yams[0] + yams[1] + yams[2] << endl;
    cout << "The package with " << yams[1] << " yams costs " << yams[1] * yamcosts[1] << " cents.\n";
    int total = yams[0] * yamcosts[0] + yams[1] * yamcosts[1] + yams[2] * yamcosts[2];
    cout << "The total yam expense is " << total << " cents. \n";

    cout << "\nSize of yams array = " << sizeof yams << " bytes.\n";
    cout << "Size of one element = " << sizeof yams[0] << " bytes.\n";

    return 0;
}
显示结果如下
Total yams = 21
The package with 8 yams costs 240 cents.
The total yam expense is 410 cents.

Size of yams array = 12 bytes.
Size of one element = 4 bytes.

如果将sizeof运算符用于数组名，得到的将是整个数组的长度（单位为字节）。
如果将sizeof用于某个数组元素，得到的将是这个元素的长度（单位为字节）。
4.1.2数组的初始化规则
C++有几条关于初始化数组的规则，决定了数组的元素数目与初始化器中值的数目不相同时将发生的情况。我们来看看这些规则。
只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组：
int cards[4] = {3, 6, 8, 10};   // okay
int han[4];   // okay
han[4] = {5, 6, 7, 9};   // not allowed
hand = cards;   // not allowed
然而，可以使用下标分别给数组中的元素赋值。
初始化数组时，提供的值可以少于数组的元素数目。例如，下面的语句只初始化hotelTips的前两个元素：
double hotelTips[5] = {5.0, 2.5};
如果只对数组的一部分进行初始化，则编译器将把其他元素设置为0。
因此，将数组中所有的元素都初始化为0非常简单，只要显式地将第一个元素初始化为0，
然后让编译器将其他元素都初始化为0即可：
long totals[500] = {0};
如果初始化为{1}而不是{0}，则第一个元素被设置为1，其他元素都被设置为0。
如果初始化数组时方括号内[]为空，C++编译器将计算元素个数。例如，对于下面的声明：
short things[] = {1, 5, 3, 8};
编译器将使things数组包含4个元素。
int num_elements = sizeof (things) / sizeof (short);
4.1.3 C++11数组初始化方法
第3章说过，C++11将使用大括号的初始化（列表初始化）作为一种通用初始化方式，可用于所有类型。
数组以前就可使用列表初始化，但C++11中的列表初始化新增了一些功能。
首先，初始化数组时，可省略等号（=）：
double earnings[4] {1.2e4, 1.6e4, 1.1e4, 1.7e4};   //okay with C++11
其次，可不在大括号内包含任何东西，这将把所有元素都设置为零：
unsigned int counts[10] = {};   // all elements set to 0
double balances[100] {};   // all elements set to 0
第三，列表初始化禁止缩窄转换，这在第3章介绍过：
long plifs[] = {25, 92, 3.0};   // not allowed
char slifs[4] {'h', 'i', 1122011,'\0'};   // not allowed
char tlifs[4] {'h', 'i', 112, '\0'};   // allowed
在上述代码中，第一条语句不能通过编译，因为将浮点数转换为整型是缩窄操作，即使浮点数的小数点后面为零。
第二条语句也不能通过编译，因为1122011超出了char变量的取值范围（这里假设char变量的长度为8位）。
第三条语句可通过编译，因为虽然112是一个int值，但它在char变量的取值范围内。
C++标准模板库（STL）提供了一种数组替代品――模板类vector，而C++11新增了模板类array。
这些替代品比内置复合类型数组更复杂、更灵活，本章将简要地讨论它们，而第16章将更详细地讨论它们。
4.2字符串
字符串是存储在内存的连续字节中的一系列字符。
C++处理字符串的方式有两种。第一种来自C语言，常被称为C风格字符串。
本章将首先介绍它，然后介绍另一种基于string类库的方法。
存储在连续字节中的一系列字符意味着可以将字符串存储在char数组中，其中每个字符都位于一个数组元素中。
字符串提供了一种存储文本信息的便捷方式，如提供给用户的消息或来自用户的响应。
C风格字符串具有一种特殊的性质：以空字符（null character）结尾，
空字符被写作'\0'，其ASCII码为0，用来标记字符串的结尾。空字符对C风格字符串而言至关重要。
例如，C++有很多处理字符串的函数，其中包括cout使用的那些函数。
它们都逐个地处理字符串中的字符，直到到达空字符为止。
有一种更好的、将字符数组初始化为字符串的方法――只需使用一个用引号括起的字符串即可，
这种字符串被称为字符串常量（string constant）或字符串字面值（string literal）。
用引号括起的字符串隐式地包括结尾的空字符，因此不用显式地包括它（参见图4.2）。
另外，各种C++输入工其通过键盘输入，将字符串读入到char数组中时，将自动加上结尾的空字符。
当然，应确保数组足够大，能够存储字符串中所有字符―包括空字符。
让数组比字符串长没有什么害处，只是会浪费一些空间而已。
这是因为处理字符串的函数根据空字符的位置，而不是数组长度来进行处理。C++对字符串长度没有限制。
在确定存储字符串所需的最短数组时，别忘了将结尾的空字符计算在内。
注意，字符串常量（使用双引号）不能与字符常量（使用单引号）互换。
4.2.1拼接字符串常量
有时候，字符串很长，无法放到一行中。C++允许拼接字符串字面值，即将两个用引号括起的字符串合并为一个。
事实上，任何两个由空白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个。
4.2.2在数组中使用字符串
要将字符串存储到数组中，最常用的方法有两种――将数组初始化为字符串常量、把键盘或文件输入读到字符数组中。
程序清单4.2演示了这两种方法，它将一个数组初始化为用引号括起的字符串，
并使用cin将一个输入字符串放到另一个数组中。该程序还使用了标准C语言库函数strlen来确定字符串的长度。
标准头文件cstring（老式实现为string.h）提供了该函数以及很多与字符串相关的其他函数的声明。
程序清单4.2 string.cpp
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    const int Size = 32;
    char name1[Size];
    char name2[Size] = "C++owboy";

    cout << "Howdy! I'm " << name2 << "! What's your name?\n";
    cin >> name1;
    cout << "Well, " << name1 << ", your name has "<< strlen(name1) << " letters and is stored\n";
    cout << "in an array of " << sizeof(name1) << " bytes. \n";
    cout << "Your initial is " << name1[0] << " . \n";
    name2[3] = '\0';
    cout << "Here are the first 3 characters of my name: " << name2 << endl;

    return 0;
}
显示结果如下
Howdy! I'm C++owboy! What's your name?
Peter
Well, Peter, your name has 5 letters and is stored
in an array of 32 bytes.
Your initial is P .
Here are the first 3 characters of my name: C++

4.2.3字符串输入
程序string.cpp有一个缺陷，这种缺陷通过精心选择输入被掩盖掉了。
程序清单4.3揭开了它的面纱，揭示了字符串输入的技巧。
程序清单4.3instr1.cpp
#include <iostream>

using namespace std;

int main()
{
    const int ArSize = 32;
    char name[ArSize];
    char dessert[ArSize];
    cout << "Enter your name:\n";
    cin >> name;
    cout << "Enter your favorite dessert:\n";
    cin >> dessert;
    cout << "I have some delicious " << dessert << " for you, " << name << " .\n";

    return 0;
}
显示结果如下
Enter your name:
Peter Smith
Enter your favorite dessert:
I have some delicious Smith for you, Peter .

4.2.4每次读取一行字符 串输入
每次读取一个单词通常不是最好的选择。例如，假设程序要求用户输入城市名，用户输入New York或Sao Paulo。
您希望程序读取并存储完整的城市名，而不仅仅是New或Sao。
要将整条短语而不是一个单词作为字符串输入，需要采用另一种字符串读取方法。
具体地说，需要采用面向行而不是面向单词的方法。
幸运的是，istream 中的类（如cin）提供了一些面向行的类成员函数：getline和get。
getline函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。
要调用这种方法，可以使用cin.getline。该函数有两个参数。
第一个参数是用来存储输入行的数组的名称，第二个参数是要读取的字符数。
如果这个参数为20，则函数最多读取19个字符，余下的空间用于存储自动在结尾处添加的空字符。
getline成员函数在读取指定数目的字符或遇到换行符时停止读取。
例如，假设要使用getine将姓名读入到一个包含20个元素的name数组中。可以使用这样的函数调用：
cin.getline (name, 20);
getine成员函数还可以接受第三个可选参数，这将在第17章讨论。
程序清单4.4将程序清单4.3修改为使用cin.getine，而不是简单的cin。除此之外，该程序没有做其他修改。
程序清单4.4 instr2.cpp
#include <iostream>

using namespace std;

int main()
{
    const int ArSize = 32;
    char name[ArSize];
    char dessert[ArSize];
    cout << "Enter your name:\n";
    cin.getline(name, ArSize);
    cout << "Enter your favorite dessert:\n";
    cin.getline(dessert, ArSize);
    cout << "I have some delicious " << dessert << " for you, " << name << " .\n";

    return 0;
}
显示结果如下
Enter your name:
Peter Smith
Enter your favorite dessert:
Apple
I have some delicious Apple for you, Peter Smith .

istream类有另一个名为get的成员函数，该函数有几种变体。
其中一种变体的工作方式与getline类似，它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。
但get并不丢弃读取的换行符，而是将其留在输入队列中。假设我们连续两次调用get：
    cout << "Enter your name:\n";
    cin.get(name, ArSize);
    cout << "Enter your favorite dessert:\n";
    cin.get(dessert, ArSize);
由于第一次调用后，换行符将留在输入队列中，因此第二次调用时看到的第一个字符便是换行符。
因此get认为已到达行尾，而没有发现任何可读取的内容。
幸运的是，get有另一种变体。使用不带任何参数的cin.get调用可读取下一个字符（即使是换行符），
因此可以用它来处理换行符，为读取下一行输入做好准备。也就是说，可以采用下面的调用序列：
    cout << "Enter your name:\n";
    cin.get(name, ArSize);
    cin.get();
    cout << "Enter your favorite dessert:\n";
    cin.get(dessert, ArSize);
    cin.get();
另一种使用get的方式是将两个类成员函数拼接起来（合并），如下所示：
cin.get(name, Arsize).get();
之所以可以这样做，是由于cin.get(name, ArSize)返回一个cin对象，该对象随后将被用来调用get函数。
同样，下面的语句将把输入中连续的两行分别读入到数组name1和name2中，其效果与两次调用cin.getline相同：
cin.getline (name1, Arsize).getline (name2, ArSize);
程序清单4.5采用了拼接方式。第11章将介绍如何在类定义中使用这项特性。
程序清单4.5 instr3.cpp
#include <iostream>

using namespace std;

int main()
{
    const int ArSize = 32;
    char name[ArSize];
    char dessert[ArSize];

    cout << "Enter your name:\n";
    cin.get(name, ArSize).get();
    cout << "Enter your favorite dessert:\n";
    cin.get(dessert, ArSize).get();
    cout << "I have some delicious " << dessert << " for you, " << name << " .\n";

    return 0;
}
显示结果如下
Enter your name:
Peter Smith
Enter your favorite dessert:
Orange
I have some delicious Orange for you, Peter Smith .

需要指出的一点是，C++允许函数有多个版本，条件是这些版本的参数列表不同。
如果使用的是cin.get (name, ArSize)，则编译器知道是要将一个字符串放入数组中，因而将使用适当的成员函数。
如果使用的是cin.get()，则编译器知道是要读取一个字符。第8章将探索这种特性――函数重载。
为什么要使用get，而不是getline呢？首先，老式实现没有getline。其次，get使输入更仔细。
例如，假设用get将一行读入数组中。如何知道停止读取的原因是由于已经读取了整行，而不是由于数组已填满呢？
查看下一个输入字符，如果是换行符，说明已读取了整行；否则，说明该行中还有其他输入。
第17章将介绍这种技术。总之，getline使用起来简单一些，但get使得检查错误更简单些。
可以用其中的任何一个来读取一行输入；只是应该知道，它们的行为稍有不同。
空行和其他问题
当getline或get读取空行时，将发生什么情况？最初的做法是，下一条输入语句将在前一条getline或get结束读取的位置开始读取；
但当前的做法是，当get（不是getline）读取空行后将设置失效位（failbit），这意味着接下来的输入将被阻断，但可以用下面的命令来恢复输入：cin.clear();
另一个潜在的问题是，输入字符串可能比分配的空间长。
如果输入行包含的字符数比指定的多，则getline和get将把余下的字符留在输入队列中，而getline还会设置失效位，并关闭后面的输入。
第5、6章和第17章将介绍这些属性，并探讨程序如何避免这些问题。
4.2.5 混合输入字符串和数字
混合输入数字和面向行的字符串会导致问题。请看程序清单4.6中的简单程序。
程序清单4.6 numstr.cpp
#include <iostream>

using namespace std;

int main()
{
    cout << "What year was your house built?\n";
    int year;
    cin >> year;
    cin.get();
    cout << "What is its street address?\n";
    char address[80];
    cin.getline(address, 80);
    cout << "Year built: " << year << endl;
    cout << "Address: " << address << endl;
    cout << "Done!\n";

    return 0;
}
显示结果如下
What year was your house built?
1999
What is its street address?
JiangXi
Year built: 1999
Address: JiangXi
Done!

C++程序常使用指针（而不是数组）来处理字符串。我们将在介绍指针后，再介绍字符串这个方面的特性。
4.3 string类简介
ISO/ANSI C++98标准通过添加string类扩展了C库，因此现在可以string类型的变量（使用C++的话说是对象）而不是字符数组来存储字符串。
要使用string类，必须在程序中包含头文件string。string类位于名称空间std中，因此您必须提供一条using编译指令，或者使用std:string来引用它。
string类定义隐藏了字符串的数组性质，让您能够像处理普通变量那样处理字符串。程序清单4.7说明了string对象与字符数组之间的一些相同点和不同点。
程序清单4.7 strtype1.cpp
#include <iostream>
#include <string>

using namespace std;

int main()
{
    char charr1[32];
    char charr2[32] = "jaguar";
    string str1;
    string str2 = "panther";

    cout << "Enter a kind of feline: ";
    cin >> charr1;
    cin.get();
    cout << "Enter another kind of feline: ";
    cin >> str1;
    cin.get();
    cout << "Here are some felines:\n";
    cout << charr1 << " " << charr2 << " " << str1 << " " << str2 << endl;
    cout << "The third letter in " << charr2 << " is " << charr2[2] << endl;
    cout << "The third letter in " << str2 << " is " << str2[2] << endl;

    return 0;
}
显示结果如下
Enter a kind of feline: ocelot
Enter another kind of feline: tiger
Here are some felines:
ocelot jaguar tiger panther
The third letter in jaguar is g
The third letter in panther is n

从这个示例可知，，在很多方面，使用string对象的方式与使用字符数组相同。
可以使用C风格字符串来初始化string对象。
可以使用cin来将键盘输入存储到string对象中
可以使用cout来显示string对象
可以使用数组表示法来访问存储在string对象中的字符
string对象和字符数组之间的主要区别是，可以将string对象声明为简单变量，而不是数组。
从理论上说，可以将char数组视为一组用于存储一个字符串的char存储单元，而string类变量是一个表示字符串的实体。
4.3.1 C++11字符串初始化
正如您预期的，C++11也允许将列表初始化用于C风格字符串和string对象：
char first_date[] = {"Le Chapon Dodu"};
char second_date {"The Elegant Plate"};

string third_date = {"The Bread Bowl"};
string fourth_date {"Hank's Fine Eats"}
4.3.2 赋值、拼接和附加
使用string类时，某些操作比使用数组时更简单。
例如，不能将一个数组赋给另一个数组，但可以将string对象赋给另一个string对象。
string类简化了字符串合并操作。可以使用运算符+将两个string对象合并起来，
还可以使用运算符 +=将字符串附加到string对象的末尾。
程序清单4.8演示了这些用法。可以将C风格字符串或string对象与string对象相加，或将它们附加到string对象的末尾。
程序清单4.8 strtype2.cpp
#include <iostream>
#include <string>

using namespace std;

int main()
{
    string s1 = "penguin";
    string s2, s3;

    cout << "You can assign one string object to another: s2 = s1\n";
    s2 = s1;
    cout << "s1: " << s1 << ", s2: " << s2 << endl;

    cout << "You can assign a C-style string to a string object.\n";
    cout << "s2 = \"buzzard\"\n";
    s2 = "buzzard";
    cout << "s2: " << s2 << endl;

    cout << "You can concatenate strings: s3 = s1 + s2\n";
    s3 = s1 + s2;
    cout << "s3: " << s3 << endl;

    cout << "You can append strings. \n";
    s1 += s2;
    cout << "s1 += s2 yields s1 = " << s1 << endl;
    s2 += " for a day";
    cout << "s2 += \" for a day\" yields s2 = " << s2 << endl;

    return 0;
}
显示结果如下
You can assign one string object to another: s2 = s1
s1: penguin, s2: penguin
You can assign a C-style string to a string object.
s2 = "buzzard"
s2: buzzard
You can concatenate strings: s3 = s1 + s2
s3: penguinbuzzard
You can append strings.
s1 += s2 yields s1 = penguinbuzzard
s2 += " for a day" yields s2 = buzzard for a day

4.3.3 string类的其他操作
在C++新增string类之前，程序员也需要完成诸如给字符串赋值等工作。
对于C风格字符串，程序员使用C语言库中的函数来完成这些任务，头文件cstring（以前为string.h），提供了这些函数。
例如，可以使用函数strcpy将字符串复制到字符数组中，使用函数strcat将字符串附加到字符数组末尾。
strcpy(charr1, charr2);
strcat(charr1, charr2);
程序清单4.9对用于string对象的技术和用于字符数组的技术进行了比较
程序清单4.9 strtype3.cpp
#include <iostream>
#include <string>
#include <cstring>

using namespace std;

int main()
{
    char charr1[32];
    char charr2[32] = "jaguar";
    string str1;
    string str2 = "panther";

    str1 = str2;
    strcpy(charr1, charr2);

    str1 += " paste";
    strcat(charr1, " juice");

    int len1 = str1.size();
    int len2 = strlen(charr1);

    cout << "The string " << str1 << " contains " << len1 << " characters. \n";
    cout << "The string " << charr1 << " contains " << len2 << " characters. \n";

    return 0;
}
显示结果如下
The string panther paste contains 13 characters.
The string jaguar juice contains 12 characters.

4.3.4 string类I/O
正如您知道的，可以使用cin和运算符>>来将输入存储到string对象中，使用cout和运算符<<来显示string对象，
其句法与处理C风格字符串相同。但每次读取一行而不是一个单词时，使用的句法不同，程序清单4.10说明了这一点。
程序清单4.10 strtype4.cpp
#include <iostream>
#include <string>
#include <cstring>

using namespace std;

int main()
{
    char charr[32] = {0};
    string str;

    cout << "Length of string in charr before input: " << strlen(charr) << endl;

    cout << "Length of string in str before input: " << str.size() << endl;

    cout << "Enter a line of text:\n";
    cin.getline(charr, 32);
    cout << "You entered: " << charr << endl;

    cout << "Enter another line of text:\n";
    getline(cin, str);
    cout << "You entered: " << str << endl;

    cout << "Length of string in charr after input: " << strlen(charr) << endl;
    cout << "Length of string in str after input: " << str.size() << endl;

    return 0;
}
显示结果如下
Length of string in charr before input: 0
Length of string in str before input: 0
Enter a line of text:
Peter Smith
You entered: Peter Smith
Enter another line of text:
Hello World
You entered: Hello World
Length of string in charr after input: 11
Length of string in str after input: 11

4.3.5 其他形式的字符串字面值
本书前面说过，除char类型外，C++还有类型wchar_t，而C++11新增了类型 char16_t和char32_t。
可创建这些类型的数组和这些类型的字符串字面值。对于这些类型的字符串字面值，C++分别使用前缀L、u和U表示，下面是一个如何使用这些前缀的例子：
wchar_t title[] = L"Chief Astrogator";
char16_t name[] = u"Felonia Ripova";
char32_t car[] = U"Humber Super Snipe";
C++11还支持Unicode字符编码方案UTF-8，C++使用前缀u8来表示这种类型的字符串字面值。
C++11新增的另一种类型是原始（raw）字符串。
在原始字符串中，字符表示的就是自己，例如，序列\n不表示换行符，而表示两个常规字符一一斜杠和n，
因此在屏幕上显示时，将显示这两个字符。另一个例子是，可在字符串中使用"，而无需像程序清单4.8中那样使用繁琐的\"。
当然，既然可在字符串字面量包含"，就不能再使用它来表示字符串的开头和末尾。
因此，原始字符串将 ( 和 ) 用作定界符，并使用前缀R来标识原始字符串：
cout << R"(Jim "King" Tutt uses "\n" instead of end.)" <<'\n';
上述代码将显示如下内容：
Jim "King" Tutt uses\n instead of endl.
如果使用标准字符串字面值，将需编写如下代码：
cout << "Jim \"King\" Tutt uses \"\\n\" instead of endl." << '\n';
在上述代码中，使用了\\来显示\，因为单个\表示转义序列的第一个字符。
输入原始字符串时，按回车键不仅会移到下一行，还将在原始字符串中添加回车字符。
如果要在原始字符串中包含 ) ，该如何办呢？编译器见到第一个 ) 时，会不会认为字符串到此结束？会的。
但原始字符串语法允许您在表示字符串开头的"和(之间添加其他字符，
这意味着表示字符串结尾的"和)之间也必须包含这些字符。
因此，使用R"+*(标识原始字符串的开头时，必须使用)+*"标识原始字符串的结尾。因此，下面的语句：
cout << R"+*("(Who wouldn't?)", she whispered.)+*" << endl;
将显示如下内容：
"(Who wouldn't?)", she whispered.
总之，这相当于使用 +*( 和 )+* 替代了默认定界符 ( 和 ) 。
自定义定界符时，可在默认定界符之间添加任意数量的基本字符，
但空格、左括号、右括号、斜杠和控制字符（如制表符和换行符）除外。
可将前缀R与其他字符串前缀结合使用，以标识wchar_t等类型的原始字符串。
可将R放在前面，也可将其放在后面，如Ru、UR等。
4.4结构简介
假设要存储有关篮球运动员的信息，则可能需要存储他（她）的姓名、工资、身高、体重、平均得分、命中率、助攻次数等。
希望有一种数据格式可以将所有这些信息存储在一个单元中。
数组不能完成这项任务，因为虽然数组可以存储多个元素，但所有元素的类型必须相同。
C++中的结构的可以满足要求（存储篮球运动员的信息）。
结构是一种比数组更灵活的数据格式，因为同一个结构可以存储多种类型的数据，
这使得能够将有关篮球运动员的信息放在一个结构中，从而将数据的表示合并到一起。
如果要跟踪整个球队，则可以使用结构数组。
结构是用户定义的类型，而结构声明定义了这种类型的数据属性。定义了类型后，便可以创建这种类型的变量。
因此创建结构包括两步。首先，定义结构描述――它描述并标记了能够存储在结构中的各种数据类型。
然后按描述创建结构变量（结构数据对象）。
例如，假设Bloataire公司要创建一种类型来描述其生产线上充气产品的成员。
具体地说，这种类型应存储产品名称、容量（单位为立方英尺）和售价。下面的结构描述能够满足这些要求：
struct inflatable
{
    char name[32];
    double volume;
    double price;
};

关键字struct表明，这些代码定义的是一个结构的布局。标识符inflatable是这种数据格式的名称，
因此新类型的名称为inflatable。这样，便可以像创建char或int类型的变量那样创建inflatable类型的变量了。
接下来的大括号中包含的是结构存储的数据类型的列表，其中每个列表项都是一条声明语句。
这个例子使用了一个适合用于存储字符串的char数组、一个double和一个double。
列表中的每一项都被称为结构成员，因此infatable结构有3个成员（参见图4.6）。
总之，结构定义指出了新类型（这里是inflatable）的特征。定义结构后，便可以创建这种类型的变量了：
inflatable hat;
inflatable woopie_cushion;
inflatable mainframe;
如果您熟悉C语言中的结构，则可能已经注意到了，C++允许在声明结构变量时省略关键字struct：
struct inflatable goose;
inflatable vincent;
在C++中，结构标记的用法与基本类型名相同。这种变化强调的是，结构声明定义了一种新类型。
可以使用成员运算符（.）和成员名访问结构的成员，每个成员都是一个对应类型的变量。
顺便说一句，访问类成员函数的方式是从访问结构成员变量的方式衍生而来的。
4.4.1在程序中使用结构
介绍结构的主要特征后，下面在一个使用结构的程序中使用这些概念。
程序清单4.11说明了有关结构的这些问题，还演示了如何初始化结构。
程序清单4.11 structur.cpp
#include <iostream>

using namespace std;

struct inflatable
{
    char name[32];
    double volume;
    double price;
};

int main()
{
    inflatable guest =
    {
        "Glorious Gloria",
        1.88,
        29.99
    };

    inflatable pal =
    {
        "Audacious Arthur",
        3.12,
        32.99
    };

    cout << "Expand your guest list with " << guest.name << " and " << pal.name << "!\n";
    cout << "You can have both for $" << guest.price + pal.price << "!\n";

    return 0;
}
显示结果如下
Expand your guest list with Glorious Gloria and Audacious Arthur!
You can have both for $62.98!

结构声明的位置很重要。位于函数外面的声明被称为外部声明，可以被其后面的任何函数使用；
位于函数内部的声明被称为内部声明，只能被该声明所属的函数使用。
通常应使用外部声明，这样所有函数都可以使用这种类型的结构（参见图4.7）。
变量也可以在函数内部和外部定义，外部变量由所有的函数共享（这将在第9章做更详细的介绍）。
C++不提倡使用外部变量，但提倡使用外部结构声明。另外，在外部声明符号常量通常更合理。
4.4.2-C++11结构初始化
与数组一样，C++11也支持将列表初始化用于结构，且等号（=）是可选的：
inflatable duck {"Daphne", 0.12, 9.98};
其次，如果大括号内未包含任何东西，各个成员都将被设置为零。
例如，下面的声明导致mayor.volume和mayor.price被设置为零，且mayor.name的每个字节都被设置为零：
inflatable mayor {};
最后，不允许缩窄转换。
4.4.3 结构可以将string类作为成员吗
只要您使用的编译器支持对以string对象作为成员的结构进行初始化。
可以将编译指令using移到结构定义之前，也可以将name的类型声明为std:string。
4.4.4其他结构属性
C++使用户定义的类型与内置类型尽可能相似。例如，可以将结构作为参数传递给函数，也可以让函数返回一个结构。
另外，还可以使用赋值运算符（=）将结构赋给另一个同类型的结构，
这样结构中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组。
这种赋值被称为成员赋值，将在第7章讨论函数时再介绍如何传递和返回结构。
下面简要地介绍一下结构赋值，程序清单4.12是一个这样的示例。
程序清单4.12 assgn_st.cpp：
#include <iostream>

using namespace std;

struct inflatable
{
    char name[32];
    double volume;
    double price;
};

int main()
{
    inflatable bouquet =
    {
        "sunflowers",
        0.20,
        12.49
    };

    inflatable choice;
    cout << "bouquet: " << bouquet.name << " for $" << bouquet.price << endl;
    choice = bouquet;
    cout << "choice: " << choice.name << " for $" << choice.price << endl;

    return 0;
}
显示结果如下
bouquet: sunflowers for $12.49
choice: sunflowers for $12.49

从中可以看出，成员赋值是有效的，因为choice结构的成员值与bouquet结构中存储的值相同。
可以同时完成定义结构和创建结构变量的工作。为此，只需将变量名放在结束括号的后面即可，
甚至可以初始化以这种方式创建的变量。然而，将结构定义和变量声明分开，可以使程序更易于阅读和理解。
还可以声明没有名称的结构类型，方法是省略名称。可以使用成员运算符来访问它的成员（如position.x），
但这种类型没有名称，因此以后无法创建这种类型的变量。本书将不使用这种形式的结构。
4.4.5 结构数组
inflatable结构包含一个数组（name），也可以创建元素为结构的数组，方法和创建基本类型数组完全相同。
例如，要创建一个包含100个inflatable结构的数组，可以这样做：
inflatable gifts[100];
这样，gifts将是一个inflatable数组，其中的每个元素都是inflatable对象，可以与成员运算符一起使用。
记住，gifts本身是一个数组，而不是结构，因此像gifts.price这样的表述是无效的。
要初始化结构数组，可以结合使用初始化数组的规则（用逗号分隔每个元素的值，并将这些值用花括号括起）和
初始化结构的规则（用逗号分隔每个成员的值，并将这些值用花括号括起）。
因此，最终结果为一个被括在花括号中、用逗号分隔的值列表，
其中每个值本身又是一个被括在花括号中、用逗号分隔的值列表：
inflatable guests[2] = 
{
    {"Bambi", 0.5, 21.99}, 
    {"Godzilla", 2000, 565.99}
};
程序清单4.13是一个使用结构数组的简短示例。
由于guests是一个inflatable数组，因此guests[0]的类型为inflatable，
可以使用它和句点运算符来访问相应inflatable结构的成员
程序清单4.13 arrstruc.cpp
#include <iostream>

using namespace std;

struct inflatable
{
    char name[32];
    double volume;
    double price;
};

int main()
{
    inflatable guests[2] =
    {
        { "Bambi", 0.5, 21.99 },
        { "Godzilla", 2000, 565.99 }
    };
    cout << "The guests " << guests[0].name << " and " << guests[1].name << "\n";
    cout << "have a combined volume of " << guests[0].volume + guests[1].volume << " cubic feet.\n";

    return 0;
}
显示结果如下
The guests Bambi and Godzilla
have a combined volume of 2000.5 cubic feet.

4.4.6 结构中的位字段
与C语言一样，C++也允许指定占用特定位数的结构成员，这使得创建与某个硬件设备上的寄存器对应的数据结构非常方便。
字段的类型应为整型或枚举（稍后将介绍），接下来是冒号，冒号后面是一个数字，它指定了使用的位数。
可以使用没有名称的字段来提供间距。每个成员都被称为位字段（bit field），下面是一个例子：
struct torgle_register
{
    unsigned int SN : 4;
    unsigned int : 4;
    bool goodIn : 1;
    bool goodTorgle : 1;
};
可以像通常那样初始化这些字段，还可以使用标准的结构表示法来访问位字段
torgle_register tr = {14, true, false};

if (tr.goodIn)
{
    // ...
}
位字段通常用在低级编程中，一般来说，可以使用整型和附录E介绍的按位运算符来代替这种方式。
4.5 联合
联合（union）是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。
也就是说，结构可以同时存储int、long和double，但联合每次只能存储其中的一种类型。
联合的语法与结构相似，但含义不同。例如，请看下面的声明：
union one4all
{
    int int_val;
    long long_val;
    double double_val;
};
可以使用one4all变量来存储int，long或double，条件是在不同的时间进行：
one4all pail;

pail.int_val=15;
cout << pail.int val << '\n';
pail.double_val = 1.38;
cout << pail.double_val << '\n';
由于联合每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，所以，联合的长度为其最大成员的长度。
联合的用途之一是，当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。
例如，假设管理一个小商品目录，其中有一些商品的ID为整数，而另一些的ID为字符，在这种情况下，可以这样做；
struct widget
{
    char brand[32];
    int type;
    union id
    {
        long id_num;
        char id_char[20];
    } id_val;
};

widget prize;
if (prize.type == 1)
{
    cin >> prize.id_val.id_num;
}
else
{
    cin >> prize.id_val.id_char;
}
匿名联合（anonymous union）没有名称，其成员将成为位于相同地址处的变量，
显然，每次只有一个成员是当前的成员。
struct widget
{
    char brand[32];
    int type;
    union 
    {
        long id_num;
        char id_char[20];
    };
};
id_num和id_char被视为prize的两个成员，它们的地址相同，所以不需要中间标识符id_val。
4.6 枚举
C++的enum提供了另一种创建符号常量的方式，这种方式可以代替const，它还允许定义新类型但必须按严格的限制进行。
使用enum的句法与使用结构相似。例如，请着下面的语句
enum spectrum { red, orange, yellow, green, blue, violet, indigo, ultraviolet};
这条语句完成两项工作
让spectrum成为新类型的名称；spectrum被称为枚举（enumeration），就像struct变量被称为结构一样。
将red，orange，yellow等作为符号常量，它们对应整数值0~7，这些常量叫作枚举量（enumerator）。
在默认情况下，将整数值赋给枚举量，第一个枚举量的值为0，第二个枚举量的值为1，依次类推。
可以通过显式地指定整数值来覆盖默认值，本章后面将介绍如何做。
可以用枚举名来声明这种类型的变量：
spectrum band;
枚举变量具有一些特殊的属性，下面来看一看。
在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举的变量，如下所示：
band = blue;   // valid, blue is an enumerator
band = 2000;   // invalid, 2000 not an enumerator
因此，spectrum变量受到限制，只有8个可能的值。
如果试图将一个非法值赋给它，则有些编译器将出现编译器错误，而另一些则发出警告。
对于枚举，只定义了赋值运算符。具体地说，没有为枚举定义算术运算：
band =orange;   // valid
++band;   //not valid
band = orange + red;   //not valid
枚举量是整型，可被提升为int类型，但int类型不能自动转换为枚举类型：
int color = blue;   //valid，spectrum type promoted to int
band =3;   //invalid, int not converted to spectrum
color = 3+ red;   //valid，red converted to int
用于算术表达式中时，枚举将被转换为整数，因此表达式orange + red将被转换为1+0，
这是一个合法的表达式，但其类型为int，不能将其赋给类型为spectrum的变量band。
如果int值是有效的，则可以通过强制类型转换，将它赋给枚举变量：
band = spectrum (3);
如果试图对一个不适当的值进行强制类型转换，将出现什么情况呢？
结果是不确定的，这意味着这样做不会出错，但不能依赖得到的结果：
band = spectrum (40003);   //undefined
请参阅本章后面的“枚举的取值范围”一节，以了解一下哪些值合适，哪些值不合适。
正如您看到的那样，枚举的规则相当严格。实际上，枚举更常被用来定义相关的符号常量，而不是新类型。
例如，可以用枚举来定义switch语句中使用的符号常量（有关示例见第6章）。
如果打算只使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称，如下面的例子所示：
enum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};
4.6.1 设置枚举量的值
可以使用赋值运算符来显式地设置枚举量的值
enum bits {one =1, two = 2, four = 4, eight = 8};
指定的值必须是整数。也可以只显式地定义其中一些枚举量的值：
enum bigstep {first, second = 100, third};
这里，first在默认情况下为0，后面没有被初始化的枚举量的值将比其前面的枚举量大1。因此，third的值为101。
最后，可以创建多个值相同的枚举量：
enum {zero, null = 0, one, numero_uno =1};
其中，zero和null都为0，one和numero_uno都为1。
在C++早期的版本中，只能将int值（或提升为int的值）赋给枚举量，但这种限制取消了，
因此可以使用long甚至long long类型的值
4.6.2枚举的取值范围
最初，对于枚举来说，只有声明中指出的那些值是有效的。
然而，C++现在通过强制类型转换，增加了可赋给枚举变量的合法值。
每个枚举都有取值范围（range），通过强制类型转换，可以将取值范围中的任何整数值赋给枚举变量，
即使这个值不是枚举值。例如，假设bits和myflag的定义如下：
enum bits {one = 1, two = 2, four = 4, eight =8};
bits myflag;
则下面的代码将是合法的
myflag = bits (6);   //valid, because 6 is in bits range
其中6不是枚举值，但它位于枚举定义的取值范围内。
取值范围的定义如下。首先，要找出上限，需要知道枚举量的最大值。
找到大于这个最大值的、最小的2的幂，将它减去1，得到的便是取值范围的上限。
例如，前面定义的bigstep的最大值枚举值是101。在2的幂中，比这个数大的最小值为128，因此取值范围的上限为127。
要计算下限，需要知道枚举量的最小值。如果它不小于0，则取值范围的下限为0；
否则，采用与寻找上限方式相同的方式，但加上负号。
例如，如果最小的枚举量为-6，而比它小的、最大的2的幂是-8（加上负号），因此下限为-7。
选择用多少空间来存储枚举由编译器决定。
对于取值范围较小的枚举，使用一个字节或更少的空间而对于包含long类型值的枚举，则使用4个字节。
C++11扩展了枚举，增加了作用域内枚举（scoped enumeration），第10章的“类作用域”一节将简要地介绍这种枚举。
4.7 指针和自由存储空间
在第3章的开头，提到了计算机程序在存储数据时必须跟踪的3种基本属性。为了方便，这里再次列一出了这些属性：
信息存储在何处
存储的值为多少
存储的信息是什么类型。
您使用过一种策略来达到上述目的：定义一个简单变量。
声明语句指出了值的类型和符号名，还让程序为值分配内存，并在内部跟踪该内存单元。
下面来看一看另一种策略，它在开发C++类时非常重要。
这种策略以指针为基础，指针是一个变量，其存储的是变量的地址，而不是变量的值。
在讨论指针之前，我们先看一看如何找到常规变量的地址。只需对变量应用地址运算符（&），就可以获得它的地址；
例如，如果home是一个变量，则&home是它的地址。
程序清单4.14演示了这个运算符的用法。
程序清单4.14 address.cpp
#include <iostream>

using namespace std;

int main()
{
    int donuts = 6;
    double cups = 4.5;
    cout << "donuts value = " << donuts << " and donuts address = " << &donuts << endl;
    cout << "cups value = " << cups << " and cups address = " << &cups << endl;

    return 0;
}
显示结果如下
donuts value = 6 and donuts address = 0x7ffe7b53c5fc
cups value = 4.5 and cups address = 0x7ffe7b53c600

指针与C++基本原理
面向对象编程与传统的过程性编程的区别在于，OOP强调的是在运行阶段（而不是编译阶段）进行决策。
运行阶段指的是程序正在运行时，编译阶段指的是编译器将程序组合起来时。
运行阶段决策提供了灵活性，可以根据当时的情况进行调整。
例如，考虑为数组分配内存的情况。传统的方法是声明一个数组。要在C++中声明数组，必须指定数组的长度。
因此，数组长度在程序编译时就设定好了；这就是编译阶段决策。
OOP通过将这样的决策推迟到运行阶段进行，使程序更灵活。
总之，使用OOP时，您可以在运行阶段确定数组的长度。为使用这种方法，语言必须允许在程序运行时创建数组。
稍后您看会到，C++采用的方法是，使用关键字new请求正确数量的内存以及使用指针来跟踪新分配的内存的位置。
指针用于存储变量的地址，将*运算符应用于指针，可以得到该地址处对应变量的值。
程序清单4.15说明了这几点，它还演示了如何声明指针。
程序清单4.15 pointer.cpp
#include <iostream>

using namespace std;

int main()
{
    int updates = 6;
    int *p_updates;
    p_updates = &updates;

    cout << "Values: updates = " << updates << ", *p_updates = " << *p_updates << endl;

    cout << "Addresses: &updates = " << &updates << ", p_updates = " << p_updates << endl;

    *p_updates = *p_updates + 1;
    cout << "Now updates = " << updates << endl;

    return 0;
}
显示结果如下
Values: updates = 6, *p_updates = 6
Addresses: &updates = 0x7ffe46351dbc, p_updates = 0x7ffe46351dbc
Now updates = 7

4.7.1 声明和初始化指针
*运算符两边的空格是可选的，下面的声明创建一个指针（p1）和一个int变量（p2）：
int * p1, p2;
对每个指针变量名，都需要使用一个*。
指针变量不仅仅是指针，而且是指向特定类型的指针。和数组一样，指针都是基于其他类型的。
可以在声明语句中初始化指针。在这种情况下，被初始化的是指针，而不是它指向的值。
程序清单4.16演示了如何将指针初始化为一个地址。
程序清单4.16 init_ptr.cpp
#include <iostream>

using namespace std;

int main()
{
    int higgens = 5;
    int *pt = &higgens;
    cout << "Value of higgens = " << higgens << ", Address of higgens = " << &higgens << endl;
    cout << "Value of *pt = " << *pt << ", Value of pt = " << pt << endl;


    return 0;
}
显示结果如下
Value of higgens = 5, Address of higgens = 0x7ffd4042832c
Value of *pt = 5, Value of pt = 0x7ffd4042832c

4.7.2 指针的危险
在C++中创建指针时，计算机将分配内存给用来存储地址的指针变量，不会分配内存来存储指针所指向的数据。
一定要在对指针应用解除引用运算符（*）之前，将指针初始化为一个确定的、适当的地址。
4.73 指针和数字
指针与整数是截然不同的类型。整数是可以执行加、减、除等运算的数字，而指针描述的是位置，将两个地址相乘没有任何意义。
从可以对整数和指针执行的操作上看，它们也是彼此不同的。
因此，不能简单地将整数赋给指针，要将数字值作为地址来使用，应通过强制类型转换将数字转换为适当的地址类型。
int *pt;
pt = (int *) 0xB8000000;
4.7.4 使用new来分配内存
对指针的工作方式有一定了解后，来看看它如何实现在程序运行时分配内存。
前面我们都将指针初始化为变量的地址；变量是在编译时分配的有名称的内存，
而指针只是为可以通过名称直接访问的内存提供了一个别名。
指针真正的用武之地在于，在运行阶段分配未命名的内存以存储值。
在这种情况下，只能通过指针来访问内存。在C语言中，可以用库函数malloc来分配内存；
在C++中仍然可以这样做，但C++还有更好的方法――使用new运算符。
程序员要告诉new，需要为哪种数据类型分配内存；new将找到一个长度正确的内存块，并返回该内存块的地址。
为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配内存的通用格式如下
typeName * pointer_name = new typeName;
需要在两个地方指定数据类型：用来指定需要什么样的内存和用来声明合适的指针。
当然，如果已经声明了相应类型的指针，则可以使用该指针，而不用再声明一个新的指针。
程序清单4.17演示了如何将new用于两种不同的类型。
程序清单4.17 use_new.cpp
#include <iostream>

using namespace std;

int main()
{
    int nights = 1001;
    int *pt = new int;
    *pt = 1001;
    cout << "nights value = " << nights << ", location = " << &nights << endl;
    cout << "*pt value = " << *pt << ", location = " << pt << endl;

    double *pd = new double;
    *pd = 10000001.0;
    cout << "*pd value = " << *pd << ", location = " << pd << endl;
    cout << "location of pointer pd: " << &pd << endl;

    cout << "size of pt = " << sizeof(pt) << ", size of *pt = " << sizeof(*pt) << endl;
    cout << "size of pd = " << sizeof pd << ", size of *pd = " << sizeof(*pd) << endl;

    delete pt;
    delete pd;

    return 0;
}
显示结果如下
nights value = 1001, location = 0x7ffdf2dc2b34
*pt value = 1001, location = 0x55c254d74eb0
*pd value = 1e+07, location = 0x55c254d752e0
location of pointer pd: 0x7ffdf2dc2b38
size of pt = 8, size of *pt = 4
size of pd = 8, size of *pd = 8

new分配的内存块通常与常规变量声明分配的内存块不同。变量nights和pd的值都存储在被称为栈（stack）的内存区域中，
而new从被称为堆（heap）或自由存储区（free store）的内存区域分配内存。第9章将更详细地讨论这一点。
计算机可能会由于没有足够的内存而无法满足new的请求。在这种情况下，new通常会引发异常。
4.7.5 使用delete释放内存
当需要内存时，可以使用new来请求，在使用完内存后，可以使用delete来释放内存。
一定要配对地使用new和delete；否则将发生内存泄漏（memory leak），也就是说被分配的内存再也无法使用了。
不要尝试释放已经释放的内存块，C++标准指出，这样做的结果将是不确定的，这意味着什么情况都可能发生。
另外，不能使用delete来释放声明变量所获得的内存，只能用delete来释放使用new分配的内存。然而，对空指针使用delete是安全的。
4.7.6使用new来创建动态数组
在C++中，创建动态数组很容易；只要将数组的元素类型和元素数目告诉new即可。必须在类型名后上方括号，其中包含元素数目。
例如，要创建一个包含10个int元素的数组，可以这样做：
int *psome = new int[10];
new运算符返回第一个元素的地址。在这个例子中，该地址被赋给指针psome。
当程序使用完new分配的内存块时，应使用delete释放它们。
然而，对于使用new创建的数组，应使用另一种格式的delete来释放：
delete [] psome;
方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。请注意delete和指针之间的方括号。
如果使用new时，不带方括号，则使用delete时，也不应带方括号。
如果使用new时带方括号，则使用delete时也应带方括号。
总之，使用new和delete时，应遵守以下规则。
不要使用delete来释放不是new分配的内存
不要使用delete释放同一个内存块两次
如果使用new[]为数组分配内存，则应使用delete[]来释放。
如果使用new为一个数据对象分配内存，则应使用delete（没有方括号）来释放。
对空指针应用delete是安全的。
现在我们回过头来讨论动态数组。
psome是指向一个int（数组第一个元素）的指针。
由于编译器不能对psome是指向10个整数中的第1个这种情况进行跟踪，
因此编写程序时，必须让程序跟踪元素的数目。
实际上，程序确实跟踪了分配的内存量，以便以后使用delete[]运算符时能够正确地释放这些内存。
但这种信息不是公用的，例如，不能使用sizeof运算符来确定动态分配的数组包含的字节数。
为数组分配内存的通用格式如下：
type_name  pointer_name = new type_name[num_elements];
创建动态数组后，如何访问其中的元素呢？只要把指针当作数组名使用即可。
也就是说，对于第1个元素，可以使用psome[0]，对于第2个元素，可以使用psome[1]，依此类推。
这样，使用指针来访问动态数组就非常简单了，可以这样做的原因是，C和C++内部都使用指针来处理数组。
首先，程序清单4.18演示了如何使用new来创建动态数组以及使用数组表示法来访问元素；
它还指出了指针和真正的数组名之间的根本差别。
程序清单4.18 arraynew.cpp
#include <iostream>

using namespace std;

int main()
{
    double *p3 = new double[3];
    p3[0] = 0.2;
    p3[1] = 0.5;
    p3[2] = 0.8;

    cout << "p3[1] is " << p3[1] << ".\n";
    p3 = p3 + 1;
    cout << "Now p3[0] is " << p3[0] << " and p3[1] is " << p3[1] << ".\n" ;
    p3 = p3 - 1;
    delete[] p3;

    return 0;
}
显示结果如下
p3[1] is 0.5.
Now p3[0] is 0.5 and p3[1] is 0.8.

4.8指针、数组和指针算术
将整数变量加1后，其值将增加1；但将指针变量加1后，增加的量等于它指向的类型的字节数。
将指向double的指针加1后，如果系统对double使用8个字节存储，则数值将增加8；
将指向short的指针加1后，如果系统对short使用2个字节存储，则指针值将增加2。
程序清单4.19演示了这种令人吃惊的现象，它还说明了另一点：C++将数组名解释为地址。
程序清单4.19 addpntrs.cpp
#include <iostream>

using namespace std;

int main()
{
    double wages[3] = { 10000.0, 20000.0, 30000.0 };
    short stacks[3] = { 3, 2, 1 };

    double *pw = wages;

    short *ps = &stacks[0];
    cout << "pw = " << pw << ", *pw = " << *pw << endl;
    pw = pw + 1;
    cout << "add 1 to the pw pointer: \n";
    cout << "pw = " << pw << ", *pw = " << *pw << "\n\n";
    cout << "ps = " << ps << ", *ps = " << *ps << endl;
    ps = ps + 1;
    cout << "add 1 to the ps pointer: \n";
    cout << "ps = " << ps << ", *ps = " << *ps << "\n\n";

    cout << "access two elements with array notation\n";
    cout << "stacks[0] = " << stacks[0] << ", stacks[1] = " << stacks[1] << endl;

    cout << "access two elements with pointer notation\n";
    cout << "*stacks = " << *stacks << ", * (stacks + 1) = " << * (stacks + 1) << endl;

    cout << "size of wages array = " << sizeof(wages) << endl;
    cout << "size of pw pointer = " << sizeof(pw) << endl;

    return 0;
}
显示结果如下
pw = 0x7ffdf4cc2190, *pw = 10000
add 1 to the pw pointer:
pw = 0x7ffdf4cc2198, *pw = 20000

ps = 0x7ffdf4cc218a, *ps = 3
add 1 to the ps pointer:
ps = 0x7ffdf4cc218c, *ps = 2

access two elements with array notation
stacks[0] = 3, stacks[1] = 2
access two elements with pointer notation
*stacks = 3, * (stacks + 1) = 2
size of wages array = 24
size of pw pointer = 8

将指针变量加1后，其增加的值等于指向的类型占用的字节数
通常，使用数组表示法时，C++都执行下面的转换：
arrayname [i] -> * (arrayname + i)
如果使用的是指针，而不是数组名，则C++也将执行同样的转换：
pointername[i] -> * (pointername + i)
因此，在很多情况下，可以相同的方式使用指针名和数组名。
在多数表达式中，它们都表示地址。区别之一是，可以修改指针的值，而数组名是常量。
另一个区别是，对数组应用sizeof运算符得到的是数组的长度，
而对指针应用sizeof得到的是指针的长度，即使指针指向的是一个数组。
数组名被解释为其第一个元素的地址，而对数组名应用地址运算符 & 时，得到的是整个数组的地址。
short tell[10];
cout << tell << endl;
cout << &tell << endl;
从数字上说，这两个地址相同；但从概念上说，这两个类型不同。
tell是一个short指针（*short），而&tell是一个指向包含10个元素的short数组的指针（short（*）[10]）。
因此，表达式tell+1将地址值加2，而表达式(&tell)+1将地址加20。
刚才已经介绍了大量指针的知识，下面对指针和数组做一总结。
1.声明指针
要声明指向特定类型的指针，请使用下面的格式
typeName * pointerName;
2.给指针赋值
应将内存地址赋给指针。可以对变量名应用&运算符，来获得被命名的内存的地址，new运算符返回未命名的内存的地址。
3.对指针解除引用
对指针解除引用意味着获得指针指向的值。对指针应用解除引用或间接值运算符（*）来解除引用。
另一种对指针解除引用的方法是使用数组表示法。决不要对未被初始化为适当地址的指针解除引用。
4.区分指针和指针所指向的值
int *pt;
*pt = 5;
如果pt是指向int的指针，则*pt等同于一个int类型的变量。
5.数组名
在多数情况下，C+将数组名视为数组的第一个元素的地址。
将sizeof运算符用于数组名用时，此时将返回整个数组的长度（单位为字节）
6.指针算术
C++允许将指针和整数相加。加1的结果等于原来的地址值加上指向的对象占用的字节数。
还可以将一个指针减去另一个指针，获得两个指针的差。
后一种运算将得到一个整数，仅当两个指针指向同一个数组（也可以指向超出结尾的一个位置）时，这种运算才有意义；
这将得到两个元素的间隔。
7・创建数组
使用数组声明来创建数组时，数组的长度在编译时设置；
使用new[]运算符创建数组时，数组的长度在运行时设置。
使用完这种数组后，应使用delete[]释放其占用的内存。
8，数组表示法和指针表示法
使用方括号数组表示法等同于对指针解除引用，数组名和指针变量都是如此，
因此对于指针和数组名，既可以使用指针表示法，也可以使用数组表示法。
4.8.3 指针和字符串
数组和指针的特殊关系可以扩展到C风格字符串。请看下面的代码：
char flower [10] = "rose";
cout << flower << "s are red\n";
数组名是第一个元素的地址，因此cout语句中的flower是包含字符r的char元素的地址。
如果给cout提供一个字符的地址，则它将从该字符开始打印，直到遇到空字符为止。
如果flower是字符串第一个字符的地址，则表达式"s are red\n"是什么呢？
为了与cout对字符串输出的处理保持一致；这个用引号括起的字符串也应当是一个地址。
在C++中，用引号括起的字符串像数组名一样，也是第一个元素的地址。
上述代码不会将整个字符串发送给cout，而只是发送该字符串的地址。
这意味着对于数组中的字符串、用引号括起的字符串常量以及指针所描述的字符串，处理的方式是一样的，
都将传递它们的地址。与逐个传递字符串中的所有字符相比，这样做的工作量确实要少。
在cout和多数C++表达式中，char数组名、char指针以及用引号括起的字符串常量都被解释为字符串第一个字符的地址。
程序清单4.20演示了如何使用不同形式的字符串。它使用了两个字符串库中的函数。
函数strlen返回字符串的长度。函数strcpy将字符串从一个位置复制到另一个位置。
这两个函数的原型都位于头文件cstring（在老的C++实现中为string.h）中。
程序清单4.20 ptrstr.cpp
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    char animal[32] = "bear";
    const char *bird = "wren";
    char *ps;
    cout << animal << " and " << bird << "\n";

    cout << "Enter a kind of animal: ";
    cin.getline(animal, 32);
    ps = animal;
    cout << ps << "\n";
    cout << "Before using strcpy():\n";
    cout << animal << " at " << (int *) animal << endl;
    cout << ps << " at " << (int *) ps << endl;
    ps = new char[strlen(animal) + 1];
    strncpy(ps, animal, strlen(animal) + 1);
    cout << "After using strcpy():\n";
    cout << animal << " at " << (int *) animal << endl;
    cout << ps << " at " << (int *) ps << endl;
    delete[] ps;

    return 0;
}
显示结果如下
bear and wren
Enter a kind of animal: fox
fox
Before using strcpy():
fox at 0x7ffc2c85fdd0
fox at 0x7ffc2c85fdd0
After using strcpy():
fox at 0x7ffc2c85fdd0
fox at 0x5579461046d0

4.8.4使用new创建动态结构
通过使用new，可以创建动态结构。由于类与结构非常相似，因此本节介绍的有关结构的技术也适用于类。
例如，要创建一个未命名的inflatable类型，并将其地址赋给一个指针，可以这样做：
inflatable * ps = new inflatable;
就像点运算符可用于结构名一样，箭头->运算符可用于指向结构的指针。
例如，如果ps指向一个inflatable结构，则ps->price是被指向的结构的price成员（参见图4.11）。
如果ps是指向结构的指针，则*ps就是被指向的结构本身。
由于*ps是一个结构，因此 (*ps).price是该结构的price成员。
程序清单4.21使用new创建一个未命名的结构，并演示了两种访问结构成员的指针表示法。
程序清单4.21 newstrct.cpp
#include <iostream>

using namespace std;

struct inflatable
{
    char name[32];
    double volume;
    double price;
};

int main()
{
    inflatable *ps = new inflatable;
    cout << "Enter name of inflatable item: ";
    cin.getline(ps->name, 32);
    cout << "Enter volume in cubic feet: ";
    cin >> (*ps).volume;
    cout << "Enter price: $";
    cin >> ps->price;
    cout << "Name: " << (*ps).name << endl;
    cout << "Volume: " << ps->volume << " cubic feet\n";
    cout << "Price: $" << ps->price << endl;
    delete ps;

    return 0;
}
显示结果如下
Enter name of inflatable item: Apple
Enter volume in cubic feet: 9.3
Enter price: $12.3
Name: Apple
Volume: 9.3 cubic feet
Price: $12.3

程序清单4.22定义了一个函数getname，该函数返回一个指向输入字符串的指针。
该函数将输入读入到一个大型的临时数组中，然后使用new[]创建一个刚好能够存储该输入字符串的内存块，并返回一个指向该内存块的指针。
程序清单4.22 delete.cpp
#include <iostream>
#include <cstring>

using namespace std;

char *getname(void);

int main()
{
    char *name;

    name = getname();
    cout << name << " at " << (int *)name << "\n";
    delete[] name;

    name = getname();
    cout << name << " at " << (int *)name << "\n";
    delete[] name;

    return 0;
}

char *getname()
{
    char temp[256];
    cout << "Enter name: ";
    cin.getline(temp, 256);
    char *pn = new char[strlen(temp) + 1];
    strcpy(pn, temp);
    return pn;
}
显示结果如下
Enter name: Peter Smith
Peter Smith at 0x55bc435816d0
Enter name: Hello World
Hello World at 0x55bc435816d0

4.8.5 自动存储、静态存储和动态存储
根据用于分配内存的方法，C++有3种管理数据内存的方式：自动存储、静态存储和动态存储（有时也叫作自由存储空间或堆）。
在存在时间的长短方面，以这3种方式分配的数据对象各不相同。下面简要地介绍每种类型（C++11新增了第四种类型――线程存储，这将在第9章简要地讨论）
1.自动存储
在函数内部定义的常规变量使用自动存储空间，被称为自动变量（automatic variable），
这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。
实际上，自动变量是一个局部变量，其作用域为包含它的代码块。代码块是被包含在花括号中的一段代码。
到目前为止，我们使用的所有代码块都是整个函数。然而，在下一章将会看到，函数内也可以有代码块。
如果在其中的某个代码块定义了一个变量，则该变量仅在程序执行该代码块中的代码时存在。
自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将依次加入到栈中，
而在离开代码块时，将按相反的顺座释放这些变量，这被称为后进先出，因此，在程序执行过程中，栈将不断地增大和缩小。
2.静态存储
静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字static。
3.动态存储
new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。
它们管理了一个内存池，这在C++中被称为自由存储空间（free store）或堆（heap），该内存池同用于静态变量和自动变量的内存是分开的。
与使用常规变量相比，使用new和delete让程序员对程序如何使用内存有更大的控制权。然而，内存管理也更复杂了。
在栈中，自动添加和删除机制使得占用的内存总是连续的，但new和delete的相互影响可能导致占用的自由存储区不连续，这使得跟踪新分配内存的位置更困难。
如果使用new运算符在自由存储空间（或堆）上创建变量后没有及时调用delete，则即使包含指针的内存由于作用域规则和对象生命周期的原因而被释放，
在自由存储空间上动态分配的变量或结构也将继续存在，这将导致内存泄漏。
被泄漏的内存将在程序的整个生命周期内都不可使用；这些内存被分配出去，但无法收回。
极端情况下，应用程序可用的内存被耗尽，出现内存耗尽错误，导致程序崩溃。
要避免内存泄漏，最好是养成这样一种习惯，使用new运算符在自由存储空间上分配内存后，及时使用delete运算符释放它。
C++智能指针有助于自动完成这种任务，这将在第16章介绍。
4.9类型组合
本章介绍了数组、结构和指针，可以各种方式组合它们。
程序清单4.23 mixtypes.cpp
#include <iostream>

using namespace std;

struct antarctica_years_end
{
    int year;
};

int main()
{
    antarctica_years_end s01, s02, s03;
    s01.year = 1998;
    antarctica_years_end *pa = &s02;
    pa->year = 1999;
    antarctica_years_end trio[3];
    trio[0].year = 2003;
    cout << trio->year << endl;
    const antarctica_years_end *arp[3] = { &s01, &s02, &s03 };
    cout << arp[1]->year << endl;
    const antarctica_years_end **ppa = arp;
    auto ppb = arp;

    cout << (*ppa)->year << endl;
    cout << (*(ppb + 1))->year << endl;

    return 0;
}
显示结果如下
2003
1999
1998
1999

4.10 模板类vector和array
4.10.1 模板类vector
模板类vector是一种动态数组。您可以在运行阶段设置vector对象的长度，可在末尾附加新数据，还可在中间插入新数据。
基本上，它是使用new创建动态数组的替代品。实际上，vector类确实使用new和delete来管理内存，但这种工作是自动完成的。
要使用vector对象，必须包含头文件vector。其次，vector包含在名称空间std中，因此您可使用using编译指令或std:vector。
第三，模板使用不同的语法来指出它存储的数据类型。第四，vector类使用不同的语法来指定元素数。
#include <vector>
using namespace std;
vector<int> vi;   // create a zero-size array of int
int n;
cin >> n;
vectore<double> vd (n);   //create an array of n doubles
其中，vi是一个vectorsint>对象，vd是一个vectorkdouble>对象。
由于vector对象在您插入或添加值时自动调整长度，因此可以将vi的初始长度设置为零。
下面的声明创建一个名为vt的vector对象，它可存储n_elem个类型为typeName的元素：
vector<typeName> vt (n_elem);
其中参数n_elem可以是整型常量，也可以是整型变量。
4.10.2 模板类array（C++11）
vector类的功能比数组强大，但付出的代价是效率稍低。
C++11新增了模板类array，它也位于名称空间std中。
与数组一样，array对象的长度也是固定的，也使用栈（静态内存分配），而不是自由存储区，
因此其效率与数组相同，但更方便，更安全。
要创建array对象，需要包含头文件array，array对象的创建语法与vector稍有不同：
#include <array>
using namespace std;

array<int, 5> ai;   // create array object of 5 ints
array<double, 4> ad = {1.2, 2.1, 3.43, 4.3};
下面的声明创建一个名为arr的array对象，它包含n_elem个类型为typename的元素：
array<typeName, n_elem> arr;
与创建vector对象不同的是，n_elem不能是变量。
在C++11中，可将列表初始化用于vector和array对象，但在C++98中，不能对vector对象这样做。
4.10.3 比较数组、vector对象和array对象
程序清单4.24 choices.cpp
#include <iostream>
#include <vector>
#include <array>

using namespace std;

int main()
{

    double a1[4] = { 1.2, 2.4, 3.6, 4.8 };
    vector<double> a2(4);

    a2[0] = 1.0 / 3.0;
    a2[1] = 1.0 / 5.0;
    a2[2] = 1.0 / 7.0;
    a2[3] = 1.0 / 9.0;

    array<double, 4> a3 = { 3.14, 2.72, 1.62, 1.41 };
    array<double, 4> a4;
    a4 = a3;

    cout << "a1[0]: " << a1[0] << " at " << &a1[0] << endl;
    cout << "a2[0]: " << a2[0] << " at " << &a2[0] << endl;
    cout << "a3[0]: " << a3[0] << " at " << &a3[0] << endl;
    cout << "a4[0]: " << a4[0] << " at " << &a4[0] << endl;

    cout << "a1[1]: " << a1[1] << " at " << &a1[1] << endl;
    cout << "a2[1]: " << a2[1] << " at " << &a2[1] << endl;
    cout << "a3[1]: " << a3[1] << " at " << &a3[1] << endl;
    cout << "a4[1]: " << a4[1] << " at " << &a4[1] << endl;

    cout << "a1[2]: " << a1[2] << " at " << &a1[2] << endl;
    cout << "a2[2]: " << a2[2] << " at " << &a2[2] << endl;
    cout << "a3[2]: " << a3[2] << " at " << &a3[2] << endl;
    cout << "a4[2]: " << a4[2] << " at " << &a4[2] << endl;

    cout << "a1[3]: " << a1[3] << " at " << &a1[3] << endl;
    cout << "a2[3]: " << a2[3] << " at " << &a2[3] << endl;
    cout << "a3[3]: " << a3[3] << " at " << &a3[3] << endl;
    cout << "a4[3]: " << a4[3] << " at " << &a4[3] << endl;

    return 0;
}
显示结果如下
a1[0]: 1.2 at 0x7fff2e2f0e30
a2[0]: 0.333333 at 0x55bde0bbfeb0
a3[0]: 3.14 at 0x7fff2e2f0e50
a4[0]: 3.14 at 0x7fff2e2f0e70
a1[1]: 2.4 at 0x7fff2e2f0e38
a2[1]: 0.2 at 0x55bde0bbfeb8
a3[1]: 2.72 at 0x7fff2e2f0e58
a4[1]: 2.72 at 0x7fff2e2f0e78
a1[2]: 3.6 at 0x7fff2e2f0e40
a2[2]: 0.142857 at 0x55bde0bbfec0
a3[2]: 1.62 at 0x7fff2e2f0e60
a4[2]: 1.62 at 0x7fff2e2f0e80
a1[3]: 4.8 at 0x7fff2e2f0e48
a2[3]: 0.111111 at 0x55bde0bbfec8
a3[3]: 1.41 at 0x7fff2e2f0e68
a4[3]: 1.41 at 0x7fff2e2f0e88

4.11总结
数组、结构和指针是C++的3种复合类型。数组可以在一个数据对象中存储多个同种类型的值。通过使用索引或下标，可以访问数组中各个元素。
结构可以将多个不同类型的值存储在同一个数据对象中，可以使用成员关系运算符（.）来访问其中的成员。
使用结构的第一步是创建结构模板，它定义结构存储了哪些成员。模板的名称将成为新类型的标识符，然后就可以声明这种类型的结构变量。
联合可以存储一个值，但是这个值可以是不同的类型，成员名指出了使用的模式。
指针是被设计用来存储地址的变量。我们说，指针指向它存储的地址。指针声明指出了指针指向的对象的类型。
对指针应用解除引用运算符，将得到指针指向的位置中的值。
字符串是以空字符为结尾的一系列字符。字符串可用引号括起的字符串常量表示，其中隐式包含了结尾的空字符。
可以将字符串存储在char数组中，可以用被初始化为指向字符串的char指针表示字符串。
函数stren返回字符串的长度，其中不包括空字符。函数strcpy将字符串从一个位置复制到另一个位置。
在使用这些函数时，应当包含头文件cstring或string.h.
头文件string支持的C++ string类提供了另一种对用户更友好的字符串处理方法。
具体地说，string对象将根据要存储的字符串自动调整其大小，用户可以使用赋值运算符来复制字符串。
new运算符允许在程序运行时为数据对象请求内存。该运算符返回获得内存的地址，
可以将这个地址赋给一个指针，程序将只能使用该指针来访问这块内存。
如果数据对象是简单变量，则可以使用解除引用运算符（*）来获得其值；
如果数据对象是数组，则可以像使用数组名那样使用指针来访问元素；
如果数据对象是结构，则可以用指针解除引用运算符（->）来访问其成员。
指针和数组紧密相关。如果ar是数组名，则表达式ar[i]被解释为* (ar + i)，其中数组名被解释为数组第一个元素的地址。
这样，数组名的作用和指针相同。反过来，可以使用数组表示法，通过指针名来访问new分配的数组中的元素。
运算符new和delete允许显式控制何时给数据对象分配内存，何时将内存归还给内存池。
自动变量是在函数中声明的变量，而静态变量是在函数外部或者使用关键字static声明的变量，这两种变量都不太灵活。
自动变量在程序执行到其所属的代码块（通常是函数定义）时产生，在离开该代码块时终止。静态变量在整个程序周期内都存在。
C++98新增的标准模板库（STL）提供了模板类vector，它是动态数组的替代品。C++11提供了模板类array，它是定长数组的替代品。
4.12 复习题
1.如何声明下述数据？
.actor是由30个char组成的数组
b.betsie是由100个short组成的数组
c.chuck是由13个float组成的数组
d.dipsea是由64个long double组成的数组。

char actors [30];
short betsie [100];
float chuck [13];
long double dipsea [64];

2.使用模板类array而不是数组来完成问题1。

array<char, 30>actors;
array<short, 100> betsie;
array<float, 13> chuck;
array<long double, 64> dipsea;

3.声明一个包含5个元素的int数组，并将它初始化为前5个正奇数
int oddly[5] = {1, 3, 5, 7, 9};

4.编写一条语句，将问题3中数组第一个元素和最后一个元素的和赋给变量even。
int even = oddly[0] + oddly[4];

5・编写一条语句，显示float数组ideas中的第2个元素的值。
cout << ideas[1]<<"n";

6.声明一个char的数组，并将其初始化为字符串"cheeseburger'
char lunch[32] = "cheeseburger";
char lunch[] = "cheeseburger";

7.声明一个string对象，并将其初始化为字符串"Waldorf Salad".
string lunch = "Waldorf salad";
如果没有using编译指令，则为：
std::string lunch = "Waldorf Salad";

8.设计一个描述鱼的结构声明。结构中应当包括品种、重量（整数，单位为盎司）和长度（英寸，包括小数）。
struct fish
{
    char kind[32];
    int weight;
    double length;
};

9.声明一个问题8中定义的结构的变量，并对它进行初始化。
fish petes = 
{
    "trout",
    12,
    26.25
};

10.用enum定义一个名为Response的类型，它包含Yes，No和Maybe等枚举量，
其中Yes的值为1，No为0，Maybe为2。
enum Response {No, Yes, Maybe};

11.假设ted是一个double变量，请声明一个指向ted的指针，并使用该指针来显示ted的值

double * pd = &ted;
cout << *pd << '\n';

12.假设treacle是一个包含10个元素的float数组，请声明一个指向treacle的第一个元素的指针，
并使用该指针来显示数组的第一个元素和最后一个元素。
float treacle[10];

float * pf = treacle;   // or & ( treacle[0] )
cout << pf[0] << " , " << pf[9] << '\n';   //or use *pf and * (pf + 9)


13.编写一段代码，要求用户输入一个正整数，然后创建一个动态的int数组，
其中包含的元素数目等于用户输入的值。首先使用new来完成这项任务，再使用vector对象来完成这项任务。
#include <iostream>
#include <vector>

using namespace std;

int main()
{
    int size;
    cout << "Enter a positive integer: ";
    cin >> size;
    if (size <= 0)
    {
        return 0;
    }

    int * dyn = new int[size];
    vector<int> dv (size);

    delete [] dyn;

    return 0;
}

14.下面的代码是否有效？如果有效，它将打印出什么结果？
cout << (int *) "Home of the jolly bytes";
有效，"Home of the jolly bytes"是一个字符串常量，用于表达式时，表示字符串常量第一个字符的地址。
强制类型转换 (int *) 将地址转换为int指针，然后作为地址被打印。

15.编写一段代码，给问题8中描述的结构动态分配内存，再读取该结构的成员的值。
struct fish
{
    char kind[32];
    int weight;
    double length;
};

fish * pole =new fish;
cout << "Enter kind of fish: ";
cin.getline(pole->kind, 32);

16.程序清单4.6指出了混合输入数字和一行字符串时存储的问题。
#include <iostream>

using namespace std;

int main()
{
    cout << "What year was your house built?\n";
    int year;
    cin >> year;
    cin.get();
    cout << "What is its street address?\n";
    char address[80];
    cin.getline(address, 80);
    cout << "Year built: " << year << endl;
    cout << "Address: " << address << endl;
    cout << "Done!\n";

    return 0;
}

如果将下面的代码：cin.getline(address, 80);替换为：cin >> address;将对程序的运行带来什么影响？
使用cin >>address将使得程序跳过空白，直到找到非空白字符为止。然后它将读取字符，直到再次遇到空白为止。
使用cin >>address只读取一个单词，而不是整行。

17.声明一个vector对象和一个array对象，它们都包含10个string对象。指出所需的头文件，但不要使用using。
使用const来指定要包含的string对象数。

#include <iostream>
#include <string>
#include <vector>
#include <array>

const int num_of_str = 10;

std::vector<std::string> vstr (num_of_str);
std::array<std::string, num_of_str> astr;


4.13 编程练习
1.编写一个C++程序，如下述输出示例所示的那样请求并显示信息。
#include <iostream>

int main()
{
    std::cout << "What is your first name? ";
    char first_name[128];
    std::cin.getline(first_name, 128);

    std::cout << "What is your last name? ";
    char last_name[128];
    std::cin.getline(last_name, 128);

    std::cout << "What letter grade do you deserve? ";
    char ctg;
    std::cin >> ctg;
    ctg = ctg + 1;

    std::cout << "What is your age? ";
    int age = 0;
    std::cin >> age;

    std::cout << "Name: " << last_name << ", " << first_name << std::endl;
    std::cout << "Grade: " << ctg << std::endl;
    std::cout << "Age: " << age << std::endl;

    return 0;
}
显示结果如下
What is your first name? Betty Sue
What is your last name? Yewe
What letter grade do you deserve? B
What is your age? 22
Name: Yewe, Betty Sue
Grade: C
Age: 22

2.修改程序清单4.4，使用C++ string类而不是char数组。
#include <iostream>
#include <string>

int main()
{
    std::string name;
    std::cout << "Enter your name: ";
    std::getline(std::cin, name, '\n');

    std::string dessert;
    std::cout << "Enter your favorite dessert: ";
    std::getline(std::cin, dessert, '\n');

    std::cout << "I have some delicious " << dessert << " for you, " << name << " .\n";

    return 0;
}
显示结果如下
Enter your name: Peter Smith
Enter your favorite dessert: Apple
I have some delicious Apple for you, Peter Smith .

3.编写一个程序，它要求用户首先输入其名，然后输入其姓；
然后程序使用个逗号和空格将姓和名组合起来，并存储和显示组合结果。
请使用char数组和头文件cstring中的函数。
#include <iostream>
#include <cstring>

int main()
{
    std::cout << "What is your first name? ";
    char first_name[128];
    std::cin.getline(first_name, 128);

    std::cout << "What is your last name? ";
    char last_name[128];
    std::cin.getline(last_name, 128);

    char result[256];
    strcpy(result, last_name);
    strcat(result, ", ");
    strcat(result, first_name);
    std::cout << "Here's the information in a single string: " << result << std::endl;

    return 0;
}
显示结果如下
What is your first name? Smith
What is your last name? Peter
Here's the information in a single string: Peter, Smith

4.编写一个程序，它要求用户首先输入其名，再输入其姓；
然后程序使用一个逗号和空格将姓和名组合起来，并存储和显示组合结果。
请使用string对象和头文件string中的函数。
#include <iostream>
#include <string>

int main()
{
    std::cout << "What is your first name? ";
    std::string first_name;
    std::getline(std::cin, first_name, '\n');

    std::cout << "What is your last name? ";
    std::string last_name;
    std::getline(std::cin, last_name, '\n');

    std::string result;
    result = last_name + ", " + first_name;
    std::cout << "Here's the information in a single string: " << result << std::endl;

    return 0;
}
显示结果如下
What is your first name? World
What is your last name? Hello
Here's the information in a single string: Hello, World

5.结构CandyBar包含3个成员。第一个成员存储了糖块的品牌；第二个成员存储糖块的重量（可以有小数）；
第三个成员存储了糖块的卡路里含量（整数）。请编写一个程序，声明这个结构，
创建一个名为snack的CandyBar变量，并将其成员分别初始化为"Mocha Munch"、2.3和350，
初始化应在声明snack时进行。最后，程序显示snack变量的内容。
#include <iostream>
#include <string>

struct CandyBar
{
    std::string candy_name;
    double weight;
    int calories;
};

int main()
{
    CandyBar snack;
    snack.candy_name = "Mocha Munch";
    snack.weight = 2.3;
    snack.calories= 350;

    std::cout << "Name: " << snack.candy_name << std::endl;
    std::cout << "Weight: " << snack.weight << std::endl;
    std::cout << "Calories: " << snack.calories << std::endl;

    return 0;
}
显示结果如下
Name: Mocha Munch
Weight: 2.3
Calories: 350

6，结构CandyBar包含3个成员，如编程练习5所示。
请编写一个程序，创建一个包含3个元素的CandyBar数组，并将它们初始化为所选择的值，然后显示每个结构的内容。
#include <iostream>
#include <string>

struct CandyBar
{
    std::string candy_name;
    double weight;
    int calories;
};

int main()
{
    CandyBar snack[3];

    snack[0].candy_name = "Mocha Munch";
    snack[0].weight = 1.1;
    snack[0].calories = 350;

    snack[1].candy_name = "Mocha Munch1";
    snack[1].weight = 2.2;
    snack[1].calories = 350;

    snack[2].candy_name = "Mocha Munch2";
    snack[2].weight = 3.3;
    snack[2].calories = 350;

    std::cout << "Name: " << snack[0].candy_name << std::endl;
    std::cout << "Weight: " << snack[0].weight << std::endl;
    std::cout << "Calories: " << snack[0].calories << std::endl;

    std::cout << std::endl;

    std::cout << "Name: " << snack[1].candy_name << std::endl;
    std::cout << "Weight: " << snack[1].weight << std::endl;
    std::cout << "Calories: " << snack[1].calories << std::endl;

    std::cout << std::endl;

    std::cout << "Name: " << snack[2].candy_name << std::endl;
    std::cout << "Weight: " << snack[2].weight << std::endl;
    std::cout << "Calories: " << snack[2].calories << std::endl;

    return 0;
}
显示结果如下
Name: Mocha Munch
Weight: 1.1
Calories: 350

Name: Mocha Munch1
Weight: 2.2
Calories: 350

Name: Mocha Munch2
Weight: 3.3
Calories: 350

7.William Wingate从事比萨饼分析服务。对于每个披萨饼，他都需要记录下列信息
披萨饼公司的名称，可以有多个单词组成。
披萨饼的直径。
拔萨饼的重量。
请设计一个能够存储这些信息的结构，并编写一个使用这种结构变量的程序。
程序将请求用户输入上述信息，然后显示这些信息。
#include <iostream>
#include <string>

struct WilliamWingate
{
    std::string company_name;
    double diametr = 0.0;
    double weight = 0.0;
};

int main()
{
    WilliamWingate Pizza;

    std::cout << "Enter company name: ";
    std::getline(std::cin, Pizza.company_name, '\n');

    std::cout << "Enter diametr: ";
    std::cin >> Pizza.diametr;

    std::cout << "Enter weight: ";
    std::cin >> Pizza.weight;

    std::cout << std::endl;

    std::cout << "Company name = " << Pizza.company_name << std::endl;
    std::cout << "Diametr = " << Pizza.diametr << std::endl;
    std::cout << "Weight = " << Pizza.weight << std::endl;

    return 0;
}
显示结果如下
Enter company name: Hello World
Enter diametr: 3.3
Enter weight: 12.5

Company name = Hello World
Diametr = 3.3
Weight = 12.5

8.完成编程练习7，但使用new来为结构分配内存，而不是声明一个结构变量。
另外，让程序在请求输入比萨饼公司名称之前输入比萨饼的直径。
#include <iostream>
#include <string>

struct WilliamWingate
{
    std::string company_name;
    double diametr = 0.0;
    double weight = 0.0;
};

int main()
{
    WilliamWingate *Pizza = new WilliamWingate;

    std::cout << "Enter diametr: ";
    (std::cin >> Pizza->diametr).get();

    std::cout << "Enter company name: ";
    std::getline(std::cin, Pizza->company_name, '\n');

    std::cout << "Enter weight: ";
    std::cin >> Pizza->weight;

    std::cout << std::endl;

    std::cout << "Company name = " << Pizza->company_name << std::endl;
    std::cout << "Diametr = " << Pizza->diametr << std::endl;
    std::cout << "Weight = " << Pizza->weight << std::endl;

    delete Pizza;

    return 0;
}
显示结果如下
Enter diametr: 5.5
Enter company name: Peter Smith
Enter weight: 123.6

Company name = Peter Smith
Diametr = 5.5
Weight = 123.6

9.完成编程练习6，但使用new来动态分配数组，而不是声明一个包含3个元素的CandyBar数组
#include <iostream>
#include <string>

struct CandyBar
{
    std::string candy_name;
    double weight;
    int calories;
};

int main()
{
    CandyBar *snack = new CandyBar[3];

    snack[0].candy_name = "Mocha Munch";
    snack[0].weight = 1.1;
    snack[0].calories = 350;

    snack[1].candy_name = "Mocha Munch1";
    snack[1].weight = 2.2;
    snack[1].calories = 350;

    snack[2].candy_name = "Mocha Munch2";
    snack[2].weight = 3.3;
    snack[2].calories = 350;

    std::cout << "Name: " << snack[0].candy_name << std::endl;
    std::cout << "Weight: " << snack[0].weight << std::endl;
    std::cout << "Calories: " << snack[0].calories << std::endl;

    std::cout << std::endl;

    std::cout << "Name: " << snack[1].candy_name << std::endl;
    std::cout << "Weight: " << snack[1].weight << std::endl;
    std::cout << "Calories: " << snack[1].calories << std::endl;

    std::cout << std::endl;

    std::cout << "Name: " << snack[2].candy_name << std::endl;
    std::cout << "Weight: " << snack[2].weight << std::endl;
    std::cout << "Calories: " << snack[2].calories << std::endl;

    delete[] snack;

    return 0;
}
显示结果如下
Name: Mocha Munch
Weight: 1.1
Calories: 350

Name: Mocha Munch1
Weight: 2.2
Calories: 350

Name: Mocha Munch2
Weight: 3.3
Calories: 350

10.编写 个程序，让用户输入三次赛跑的成绩，并显示次数和平均成绩。
请使用一个array对象来存储数据（如果编译器不支持array类，请使用数组）。
#include <iostream>
#include <array>

int main() 
{
	std::array<double, 3> result;

	std::cout << "Enter 3 race results: " << std::endl;
	std::cin >> result[0] >> result[1] >> result[2];

	std::cout << "You typed: ";
	std::cout << result[0] << ", " << result[1] << ", " << result[2] << std::endl;

	std::cout << "Average value: ";
	double Average = (result[0] + result[1] + result[2]) / 3.0;
	std::cout << Average << std::endl;

	return 0;
}
显示结果如下
Enter 3 race results:
8.8
7.5
6.2
You typed: 8.8, 7.5, 6.2
Average value: 7.5

第5章 循环和关系表达式
5.1 for循环
5.1.1 for循环的组成部分
5.1.2 回到for循环
5.1.3 修改步长
5.1.4 使用for循环访问字符串
5.1.5 递增运算符和递减运算符
5.1.6 副作用和顺序点
5.1.7 前缀格式和后缀格式
5.1.8 递增、递减运算符和指针
5.1.9 组合赋值运算符
5.1.10 复合语句（语句块）
5.1.11 其他语法技巧 逗号运算符
5.1.12 关系表达式
5.1.13 赋值、比较和可能犯的错误
5.1.14 C风格字符串的比较
5.1.15 比较string类字符串
5.2 while 循环.
5.2.1 for与while
5.2.2 等待一段时间：编写延时循环
5.3 do while循环
5.4 基于范围的for循环（C++1月）.
5.5 循环和文本输入.
5.5.1 使用原始的cin进行输入
5.5.2 使用cin.get(char)进行补救
5.5.3 使用哪一个cin.get()
5.5.4 文件尾条件
5.5.5 另一个cin.get()版本
5.6 嵌套循环和二维数维
5.6.1 初始化二维数组
5.6.2 使用二维数组
5.7 总结
5.8 复习题
5.9 编程练习
本章内容包括：
for循环。
表达式和语句。
递增运算符和递减运算符：++和--。
组合赋值运算符。
复合语句（语句块）。
逗号运算符。
关系运算符：>、>=、==、<、<=和!=
while循环。
typedef工具。
do while循环。
字符输入方法get。
文件尾条件。
嵌套循环和二维数组。
本章将讨论循环和关系表达式，第6将介绍分支语句和逻辑表达式。
5.1 for循环
很多情况下都需要程序执行重复的任务，C++中的for循环可以轻松地完成这种任务。
我们来看看程序清单5.1中，以了解for循环所做的工作，然后讨论它是如何工作的。
程序清单5.1 forloop.cpp
#include <iostream>

using namespace std;

int main()
{
    int i;

    for (i = 0; i < 5; i++)
    {
        cout << i << " loop.\n";
    }
    cout << "loop end.\n";

    return 0;
}
显示结果如下
0 loop.
1 loop.
2 loop.
3 loop.
4 loop.
loop end.

5.1.1 for循环的组成部分
for循环为执行重复的操作提供了循序渐进的步骤。我们来具体看一看它是如何工作的。for循环的组成部分完成下面这些步骤。
设置初始值。
执行测试，看看循环是否应当继续进行。
执行循环操作。
更新用于测试的值。
初始化、测试和更新操作构成了控制部分，这些操作由括号括起。其中每部分都是一个表达式，彼此由分号隔开。
控制部分后面的语句叫作循环体，只要测试表达式为true，它便被执行：
for (initialization; test-expression; update-expression)
    body
循环只执行一次初始化。通常，程序使用该表达式将变量设置为起始值。
test-expression（测试表达式）决定循环体是否被执行。通常，这个表达式是关系表达式。
实际上，C++并没有将test-expression的值限制为只能为真或假。可以使用任意表达式，C++将把结果强制转换为bool类型。
因此，值为0的表达式将被转换为bool值false，导致循环结束。如果表达式的值为非零，则被强制转换为bool值true，循环将继续进行。
程序清单5.2通过将表达式i用作测试条件来演示了这一特点。
程序清单5.2 num_test.cpp
#include <iostream>

using namespace std;

int main()
{
    cout << "Enter the starting countdown value: ";
    int limit = 0;
    cin >> limit;
    if (limit <= 0 )
    {
        return 0;
    }
    int i;
    for (i = limit; i; i--)
    {
        cout << "i = " << i << "\n";
    }
    cout << "Done, now i = " << i << "\n";

    return 0;
}
显示结果如下
Enter the starting countdown value: 8
i = 8
i = 7
i = 6
i = 5
i = 4
i = 3
i = 2
i = 1
Done, now i = 0

程序清单5.3 express.cpp
#include <iostream>

using namespace std;

int main()
{
    int x = 0;
    cout << "The expression x = 100 has the value ";
    cout << (x = 100) << endl;
    cout << "Now x = " << x << endl;
    cout << "The expression x < 3 has the value ";
    cout << (x < 3) << endl;
    cout << "The expression x > 3 has the value ";
    cout << (x > 3) << endl;
    cout.setf(ios_base::boolalpha);
    cout << "The expression x < 3 has the value ";
    cout << (x < 3) << endl;
    cout << "The expression x > 3 has the value ";
    cout << (x > 3) << endl;

    return 0;
}
显示结果如下
The expression x = 100 has the value 100
Now x = 100
The expression x < 3 has the value 0
The expression x > 3 has the value 1
The expression x < 3 has the value false
The expression x > 3 has the value true

程序清单5.4 formore.cpp
#include <iostream>

using namespace std;

const int ArSize = 16;

int main()
{
    long long factorials[ArSize];
    factorials[1] = factorials[0] = 1LL;
    for (int i = 2; i < ArSize; i++)
    {
        factorials[i] = i * factorials[i - 1];
    }
    for (int i = 0; i < ArSize; i++)
    {
        cout << i << " ! = " << factorials[i] << endl;
    }

    return 0;
}
显示结果如下
0 ! = 1
1 ! = 1
2 ! = 2
3 ! = 6
4 ! = 24
5 ! = 120
6 ! = 720
7 ! = 5040
8 ! = 40320
9 ! = 362880
10 ! = 3628800
11 ! = 39916800
12 ! = 479001600
13 ! = 6227020800
14 ! = 87178291200
15 ! = 1307674368000

程序清单5.5 bigstep.cpp
#include <iostream>

using namespace std;

int main()
{

    cout << "Enter an integer: ";
    int step;
    cin >> step;
    if (step <= 0)
    {
        return 0;
    }
    cout << "Counting by " << step << "\n";
    for (int i = 0; i < 100; i = i + step)
    {
        cout << i << endl;
    }

    return 0;
}
显示结果如下
Enter an integer: 5
Counting by 5
0
5
10
15
20
25
30
35
40
45
50
55
60
65
70
75
80
85
90
95

程序清单5.6 forstr1.cpp
#include <iostream>
#include <string>

using namespace std;

int main()
{
    cout << "Enter a word: ";
    string word;
    getline(cin, word, '\n');

    for (int i = word.size() - 1; i >= 0; i--)
    {
        cout << word[i];
    }
    cout << "\nDone.\n";

    return 0;
}
显示结果如下
Enter a word: Hello, World!
!dlroW ,olleH
Done.

程序清单5.7 plus_one.cpp
#include <iostream>
#include <string>

using namespace std;

int main()
{
    int a = 20;
    int b = 20;

    cout << "a = "<< a << ": b = " << b << "\n";
    cout << "a++ = " << a++ << " : ++b = " << ++b << "\n";
    cout << "a = " << a << ": b = " << b << "\n";

    return 0;
}
显示结果如下
a = 20: b = 20
a++ = 20 : ++b = 21
a = 21: b = 21

副作用（side effect）指的是在计算表达式时对某些东西（如存储在变量中的值）进行了修改；
顺序点（sequence point）是程序执行过程中的一个点，在这里，进入下一步之前将确保对所有的副作用都进行了评估。
在C++中，语句中的分号就是一个顺序点，这意味着程序处理下一条语句之前，赋值运算符、递增运算符和递减运算符执行的所有修改都必须完成。
本章后面将讨论的有些操作也有顺序点。另外，任何完整的表达式末尾都是一个顺序点。何为完整表达式呢？
它是这样一个表达式：不是另一个更大表达式的子表达式。
顺序点有助于阐明后缀递增何时进行。例如，请看下面的代码：
int guests = 0;

while (guests++ < 10)
{
    cout << guests << endl;
}
while循环将在本章后面讨论，它类似于只有测试表达式的for循环。
表达式guests++ < 10是一个完整表达式，因此该表达式的末尾是一一个顺序点。
所以，C++确保副作用（将guests加1）在程序进入cout之前完成。
然而，通过使用后缀格式，可确保将guests同10进行比较后再将其值加1。
现在来看下面的语句：
y = (4 + x++) + (6 + x++);
表达式4+x++不是一个完整表达式，因此，C+ +不保证x的值在计算子表达式4+x++后立刻增加1。
在这个例子中，整条赋值语句是一个完整表达式，而分号标示了顺序点，因此C++只保证程序执行到下一条语句之前，x的值将被递增两次。
C++没有规定是在计算每个子表达式之后将x的值递增，还是在整个表达式计算完毕后才将x的值递增，有鉴于此，您应避免使用这样的表达式。
5.1.7前缀格式和后缀格式
显然，如果变量被用于某些目的（如用作函数参数或给变量赋值），使用前缀格式和后缀格式的结果将不同。
然而。如果递增表达式的值没有被使用，情况又如何呢？例如，下面两条语句的作用是否不同？
x++;
++x;
下面两条语句的作用是否不同？
for (n =16; n > 0; --n)
和
for (n = 16; n > 0; n--)
从逻辑上说，在上述两种情形下，使用前缀格式和后缀格式没有任何区别。表达式的值未被使用，因此只存在副作用。
在上面的例子中，使用这些运算符的表达式为完整表达式，因此将x加1和n减1的副作用将在程序进入下一步之前完成，前缀格式和后缀格式的最终效果相同。
然而，虽然选择使用前缀格式还是后缀格式对程序的行为没有影响，但执行速度可能有细微的差别。
对于内置类型和当代的编译器而言，这看似不是什么问题。然而，C++ 允许您针对类定义这些运算符，
在这种情况下，用户这样定义前缀函数：将值加1，然后返回结果；但后缀版本首先复制一个副本，将其加1，然后将复制的副本返回。
因此，对于类而言，前缀版本的效率比后缀版本高。
总之，对于内置类型，采用哪种格式不会有差别：但对于用户定义的类型，如果有用户定义的递增和递减运算符，则前缀格式的效率更高。
5.1.8 递增/递减运算符和指针
将递增运算符用于指针时，将把指针的值增加其指向的数据类型占用的字节数；
将递减运算符用于指针时，将把指针的值减掉其指向的数据类型占用的字节数。
double arr[5] = {21.1, 32.8, 23.4, 45.2, 37.4};
double *pt = arr;   //pt points to arr[0]
++pt;   // pt points to arr[1]
也可以结合使用这些运算符和*运算符来修改指针指向的值。
*++pt的含义如下：现将++应用于pt，然后将*应用于被递增后的pt。
++*pt的含义如下：先取得pt指向的值，然后将这个值加1。
(*pt)++的含义如下：先取得pt指向的值，然后将这个值加1。
*pt++的含义如下：先将*应用于递增之前的pt，再将++应用于pt。
5.1.9组合赋值运算符
+=运算符将两个操作数相加，并将结果赋给左边的操作数。
这意味着左边的操作数必须能够被赋值，如变量、数组元素、结构成员或通过对指针解除引用来标识的数据。
组合赋值运算符包括+=、-=、*=、/=、%=。
5.1.10复合语句（语句块）
复合语句（代码块）由一对花括号和它们包含的语句组成，复合语句（代码块）被视为一条语句。
例如，程序清单5.8中的程序使用花括号将3条语句合并为一个代码块。
程序清单5.8 block.cpp
#include <iostream>
#include <string>

using namespace std;

int main()
{
    cout << "Please enter five numbers:\n";
    double number = 0.0;
    double sum = 0.0;
    for (int i = 1; i <= 5; i++)
    {
        cout << "Value " << i << " : ";
        cin >> number;
        sum += number;
    }

    cout << "the sum of five numbers = " << sum << endl;
    cout << "the average of five numbers = " << sum / 5 << "\n";

    return 0;
}
显示结果如下
Please enter five numbers:
Value 1 : 5.1
Value 2 : 3.2
Value 3 : 6.3
Value 4 : 2.6
Value 5 : 7.2
the sum of five numbers = 24.4
the average of five numbers = 4.88

如果在复合语句（代码块）中定义一个新的变量，则仅当程序执行该代码块中的语句时，该变量才存在。执行完该代码块后，变量将被释放。
如果在一个代码块中声明一个变量，而外部语句块中也有一个这种名称的变量，在声明位置到内部语句块结束的范围之内，新变量将隐藏旧变量。
5.1.11 逗号运算符
假设有一个循环，每轮都将一个变量加1，而将另一个变量减1。
在for循环控制部分的更新部分中完成这两项工作将非常方便，但循环句法只允许这里包含一个表达式。
在这种情况下，可以使用逗号运算符将两个表达式合并为一个。
程序清单5.9在一个程序中使用了两次逗号运算符，该程序将一个string类对象的内容反转。
程序清单5.9 forstr2.cpp
#include <iostream>
#include <string>

using namespace std;

int main()
{
    cout << "Enter a word: ";
    string word;
    getline(cin, word, '\n');

    char temp;
    int i, j;
    for (i = 0, j = word.size() - 1; i < j; ++i, --j)
    {
        temp = word[j];
        word[j] = word[i];
        word[i] = temp;
    }
    cout << word << "\nDone\n";

    return 0;
}
显示结果如下
Enter a word: Hello, World!
!dlroW ,olleH
Done

逗号运算符确保先计算第一个表达式，然后计算第二个表达式（换句话说，逗号运算符是一个顺序点）。
逗号表达式的值是最后一个表达式的值。
5.1.12 关系表达式
C++提供了6种关系运算符来对数字进行比较。由于字符用其ASCII码表示，因此也可以将这些运算符用于字符。
不能将它们用于C风格字符串，但可用于string类对象。
对于所有的关系表达式，如果比较结果为真，则其值将为true，否则为false，因此可将其用作循环测试表达式。
关系运算符
<
<=
==
>
>=
!=
5.1.13 赋值、比较和可能犯的错误
不要混淆等于运算符（==）与赋值运算符（=）。
程序清单5.10：equal.cpp
#include <iostream>
#include <string>

using namespace std;

int main()
{
    int quizscores[10] = { 20, 20, 20, 20, 20, 19, 20, 18, 20, 20 };
    cout << "Doing it right:\n";
    int i;
    for (i = 0; quizscores[i] == 20; i++)
    {
        cout << "quiz " << i << " is a 20\n";
    }

    // for (i = 0; quizscores[i] = 20; i++)

    return 0;
}
显示结果如下
Doing it right:
quiz 0 is a 20
quiz 1 is a 20
quiz 2 is a 20
quiz 3 is a 20
quiz 4 is a 20

程序清单5.11 compstr1.cpp
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    char word[5] = "?ate";
    for (char ch = 'a'; strcmp(word, "mate"); ch++)
    {
        cout << word << endl;
        word[0] = ch;
    }
    cout << "After loop ends, word is " << word << endl;

    return 0;
}
显示结果如下
?ate
aate
bate
cate
date
eate
fate
gate
hate
iate
jate
kate
late
After loop ends, word is mate

程序清单5.12 compstr2.cpp
#include <iostream>
#include <string>

using namespace std;

int main()
{
    string word = "?ate";
    for (char ch = 'a'; word != "mate"; ch++)
    {
        cout << word << endl;
        word[0] = ch;
    }
    cout << "After loop ends, word is " << word << endl;

    return 0;
}
显示结果如下
?ate
aate
bate
cate
date
eate
fate
gate
hate
iate
jate
kate
late
After loop ends, word is mate

5.2 while循环
while循环是没有初始化和更新部分的for循环，它只有测试条件和循环体：
while（test-condition）
    body
如果测试条件表达式为true，则执行循环体中的语句。
与for循环一样，循环体也由一条语句或两个花括号定义的复合语句组成。
执行完循环体后，程序返回测试条件，对它进行重新评估。如果该条件为非零，则再次执行循环体。
测试和执行将一直进行下去，直到测试条件为false为止（参见图5.3）。
显然，如果希望循环最终能够结束，循环体中的代码必须完成某种影响测试条件表达式的操作。
和for循环一样while循环也是一种入口条件循环。因此，如果测试条件一开始便为false，则程序将不会执行循环体。
程序清单5.13使用了一个while循环。该循环遍历字符串，并显示其中的字符及其ASCII码。循环在遇到空值字符时停止。
程序清单5.13 while.cpp
#include <iostream>
#include <string>

using namespace std;

const int ArSize = 128;

int main()
{
    char name[ArSize];

    cout << "Please enter your name: ";
    cin.getline(name, ArSize);

    cout << "Here is your name: \n";
    int i = 0;
    while (name[i] != '\0')
    {
        cout << name[i] << ": " << int (name[i]) << endl;
        i++;
    }

    return 0;
}
显示结果如下
Please enter your name: Peter Smith
Here is your name:
P: 80
e: 101
t: 116
e: 101
r: 114
 : 32
S: 83
m: 109
i: 105
t: 116
h: 104

for循环的3个表达式可以是空表达式，只有两个分号是必需的。如果省略for循环中的测试表达式，测试结果将一直为true。
5.2.2 编写延时循环
程序清单5.14演示了如何使用clock和头ctime来创建延迟循环。
程序清单5.14 waiting.cpp
#include <iostream>
#include <ctime>

using namespace std;

int main()
{
    cout << "Enter the delay time, in seconds: ";
    double sees;
    cin >> sees;
    clock_t delay = sees * CLOCKS_PER_SEC;
    cout << "starting\n";
    clock_t start = clock();
    while (clock() - start < delay)
        ;
    cout << "done\n";

    return 0;
}
显示结果如下
Enter the delay time, in seconds: 8
starting
done

C++为类型建立别名的方式有两种。
一种是使用预处理器：
#define BYTE char
这样，预处理器将在编译程序时用char替换所有的BYTE，从而使BYTE成为char的别名。
第二种方法是使用关键字typedef来创建别名。例如，要将byte作为char的别名，可以这样做：
typedef char byte
下面是通用格式：
typedef typeName aliasName
5.3 do while循环
do while循环是出口条件（exit condition）循环。do while循环首先执行循环体，然后再判定测试表达式，决定是否应继续执行循环。
如果条件为false，则循环终止；否则，进入新一轮的执行和测试。
这样的循环通常至少执行一次，因为其程序流必须经过循环体后才能到达测试条件。
do
    body
while (test-expression);
程序清单5.15：dowhile.cpp
#include <iostream>

using namespace std;

int main()
{
    int n = 0;
    cout << "Enter numbers in the range 1-10 to find my favorite number\n";
    do
    {
        cin >> n;
    }
    while (n != 7);
    cout << "Yes, 7 is my favorite. \n";

    return 0;
}
显示结果如下
Enter numbers in the range 1-10 to find my favorite number
1
3
5
7
Yes, 7 is my favorite.

5.4 基于范围的for循环（C++11）
C++11新增了一种循环：基于范围（range-based）的for循环。
这简化了对数组（vector和array）的每个元素执行相同的操作，如下例所示：
double prices[5] = {4.99, 10.99, 6.87, 7.99, 8.49};

for (double x : prices)
{
    cout << x << '\n';
}
for循环显示数组中的每个值。
要修改数组的元素，需要使用不同的循环变量语法：
for (double &x : prices)
{
    x = х * 0.80;
}
符号&表明x是一个引用变量，这个主题将在第8章讨论。
就这里而言，这种声明让接下来的代码能够修改数组的内容，而第一种语法不能。
还可结合使用基于范围的for循环和初始化列表：
for ( int  x : {3, 5, 2, 8, 6} )
{
    cout << x << ' ';
}
cout << '\n';

#include <iostream>

using namespace std;

int main()
{
    int i;

    double prices[5] = {4.99, 10.99, 6.87, 7.99, 8.49};

    for (double x : prices)
    {
        cout << x << '\n';
    }

    cout << '\n';

    for (double &x : prices)
    {
        x = x * 0.80;
    }

    for (double x : prices)
    {
        cout << x << '\n';
    }

    cout << '\n';

    for ( int  x :
            {
                3, 5, 2, 8, 6
            } )
    {
        cout << x << ' ';
    }
    cout << '\n';

    return 0;
}
显示结果如下
4.99
10.99
6.87
7.99
8.49

3.992
8.792
5.496
6.392
6.792

3 5 2 8 6

5.5 循环和文本输入
5.5.1 使用原始的cin进行输入
如果程序要使用循环来读取来自键盘的文本输入，则必须有办法知道何时停止读取。
如何知道这一点呢？一种方法是选择某个特殊字符，将其作为停止标记。
例如，程序清单5.16在遇到#字符时停止读取输入。该程序计算读取的字符数，并回显这些字符，即在屏幕上显示读取的字符。
按下键盘上的键不能自动将字符显示到屏幕上，程序必须通过回显输入字符来完成这项正作。
通常，这种任务由操作系统处理。运行完毕后，该程序将报告处理的总字符数。程序清单5.16列出了该程序的代码。
程序清单5.16 textin1.cpp
#include <iostream>

using namespace std;

int main()
{
    char ch;
    int count = 0;
    cout << "Enter characters; enter # to quit:\n";
    cin >> ch;
    while (ch != '#')
    {
        cout << ch;
        ++count;
        cin >> ch;
    }
    cout << '\n' << count << " characters read.\n";

    return 0;
}
显示结果如下
Enter characters; enter # to quit:
Hello, World!#
Hello,World!
12 characters read.

5.5.2 使用cin.get（char）进行补救
通常，逐个字符读取输入的程序需要检查每个字符，包括空格、制表符和换行符。
cin所属的istream类（在iostream中定义）中包含一个能够满足这种要求的成员函数。
具体地说，成员函数cin.get（ch）读取输入中的下一个字符（即使它是空格），并将其赋给变量ch。
使用这个函数调用替换cin >> ch，可以修补程序清单5.16的问题。程序清单5.17列出了修改后的代码。
程序清单5.17 textin2.cpp
#include <iostream>

using namespace std;

int main()
{
    char ch;
    int count = 0;
    cout << "Enter characters; enter # to quit:\n";
    cin.get(ch);
    while (ch != '#')
    {
        cout << ch;
        ++count;
        cin.get(ch);
    }
    cout << '\n' << count << " characters read.\n";

    return 0;
}
显示结果如下
Enter characters; enter # to quit:
Hello, World!#
Hello, World!
13 characters read.

cin.get可以接受两个参数：char *类型的地址和int类型的整数，也可以接收一个参数：char类型的引用，还可以不接受任何参数。
5.5.4 文件尾条件
程序清单5.17表明，使用诸如#等符号来表示输入结束很难令人满意，因为这样的符号可能就是合法输入的组成部分，其他符号（如@和%）也如此。
如果输入来自于文件，则可以使用一种功能更强大的技术――检测文件尾（EOF）。
很多操作系统都允许通过键盘来模拟文件尾条件。在Unix中，可以在行首按下Ctrl+D来实现。
检测到EOF后，cin将eofbit设置为1，可以通过成员函数eof来查看eofbit是否被设置。
如果检测到EOF，则cin.eof将返回bool值true，否则返回false。
注意，eof在读取到文件结尾后报告，而不是预先报告。因此应将cin.eof测试放在读取后。
程序清单5.18 textin3.cpp
#include <iostream>

using namespace std;

int main()
{
    char ch;
    int count = 0;
    cin.get(ch);
    while (cin.eof() == false)
    {
        cout << ch;
        ++count;
        cin.get(ch);
    }
    cout << '\n' << count << " characters read.\n";

    return 0;
}
显示结果如下
Hello, World!
Hello, World!

14 characters read.
注意程序读取了一个换行符

不接受任何参数的cin.get返回输入中的下一个字符。也就是说，可以这样使用它：
ch = cin.get();
该函数的工作方式与C语言中的getchar相似，将字符编码作为int返回，而cin.get(ch)返回一个对象，而不是读取的字符。
同样，可以使用cout.put函数来显示字符：
cout.put (ch);
该函数的工作方式类似C语言中的putchar，只不过其参数类型为char，而不是int。
当cin.get函数读取到文件结尾时，将返回一个用符号常量EOF表示的特殊值。该常量是在头文件iostream中定义的。
EOF值必须不同于任何有效的字符值，以便程序不会将EOF与常规字符混淆。
通常，EOF被定义为值-1，因为没有ASCII码为-1的字符，但并不需要知道实际的值，而只需在程序中使用EOF即可。
程序清单5.19将程序清单5.18进行了修改，使用了cin.get方法。
程序清单5.19 textin4.cpp
#include <iostream>

using namespace std;

int main()
{
    int ch;
    int count = 0;
    while ( ( ch = cin.get() ) != EOF )
    {
        cout.put( char (ch) );
        ++count;
    }
    cout << '\n' << count << " characters read.\n";

    return 0;
}
显示结果如下
Hello, World!
Hello, World!

14 characters read.

5.6嵌套循环和二维数组
到目前为止，本章使用的数组都是一维数组，因为每个数组都可以看作是一行数据。二维数组更像是一个表格――既有数据行又有数据列。
C++没有提供二维数组类型，但用户可以创建每个元素本身都是数组的数组。例如，假设要存储5个城市在4年间的最高温度。
在这种情况下，可以这样声明数组：
int maxtemps[4][5];
该声明意味着maxtemps是一个包含4个元素的数组，其中每个元素都是一个由5个整数组成的数组（参见图5.5）。
表达式maxtemps[0]是maxtemps数组的第一个元素，因此maxtemps[0]本身就是一个由5个int组成的数组。
maxtemps[0]数组的第一个元素是maxtemps[0][0]，该元素是一个int，因此，需要使用两个下标来访问int元素。
可以认为第一个下标表示行，第二个下标表示列（参见图5.6）。
假设要打印数组所有的内容，可以用一个for循环来改变行，用另一个被嵌套的for循环来改变列
for (int row = 0; row < 4; row++)
{
    for (int col =0; col < 5; ++col)
    {
        cout << maxtemps[row][col] << "\t";
    }
    cout << endl;
}
对于每个row值，内部的for循环将遍历所有的col值。
这个示例在每个值之后打印一个制表符，打印完每行后，打印一个换行符
5.6.1 初始化二维数组
int maxtemps[4][5] =
{
    {96, 100, 87, 101, 105},
    {96, 98, 91, 107, 104},
    {97, 101, 93, 108, 107},
    {98, 103, 95, 109, 108}
};
5.6.2 使用二维数组
程序清单5.20初始化了一个二维数组，并使用了一个嵌套循环。
程序清单5.20 nested.cpp
#include <iostream>

using namespace std;

const int Cities = 5;
const int Years = 4;

int main()
{
    const char *cities[Cities] =
    {
        "Gribble City",
        "Gribbletown",
        "New Gribble",
        "San Gribble",
        "Gribble Vista"
    };

    int maxtemps[Years][Cities] =
    {
        { 96, 100, 87, 101, 105 },
        { 96, 98, 91, 107, 104 },
        { 97, 101, 93, 108, 107 },
        { 98, 103, 95, 109, 108 }
    };

    cout << "Maximum temperatures for 2008 - 2011\n\n";
    for (int city = 0; city < Cities; ++city)
    {
        cout << cities[city] << ":\t";
        for (int year = 0; year < Years; ++year)
        {
            cout << maxtemps[year][city] << "\t";
        }
        cout << endl;
    }

    return 0;
}
显示结果如下
Maximum temperatures for 2008 - 2011

Gribble City:   96      96      97      98
Gribbletown:    100     98      101     103
New Gribble:    87      91      93      95
San Gribble:    101     107     108     109
Gribble Vista:  105     104     107     108

#include <iostream>
#include <array>
#include <string>

using namespace std;

const int Cities = 5;
const int Years = 4;

int main()
{
    const string cities[Cities] =
    {
        "Gribble City",
        "Gribbletown",
        "New Gribble",
        "San Gribble",
        "Gribble Vista"
    };

    array<array<int, Cities>, Years> maxtemps =
    {
        96, 100, 87, 101, 105,
        96, 98, 91, 107, 104,
        97, 101, 93, 108, 107,
        98, 103, 95, 109, 108
    };


    cout << "Maximum temperatures for 2008 - 2011\n\n";
    for (int city = 0; city < Cities; ++city)
    {
        cout << cities[city] << ":\t";
        for (int year = 0; year < Years; ++year)
        {
            cout << maxtemps[year][city] << "\t";
        }
        cout << endl;
    }

    return 0;
}
显示结果如下
Maximum temperatures for 2008 - 2011

Gribble City:   96      96      97      98
Gribbletown:    100     98      101     103
New Gribble:    87      91      93      95
San Gribble:    101     107     108     109
Gribble Vista:  105     104     107     108

5.7总结
C++提供了3种循环：for循环、while循环和do while循环。
如果循环测试条件为true或非零，则循环将重复执行一组指令；如果测试条件为false或0，则结束循环。
for循环和while循环都是入口条件循环，这意味着程序将在执行循环体中的语句之前检查测试条件。
do while循环是出口条件循环，这意味着其将在执行循环体中的语句之后检查条件。
每种循环都要求循环体由一条语句组成。然而，这条语句可以是复合语句（由花括号括起的多条语句）。
关系表达式对两个值进行比较，常被用作循环测试条件。
关系表达式是通过使用6种关系运算符之一构成的：<、<=、==、>、>=或!=。
关系表达式的结果为bool类型，值为true或false。
许多程序都逐字节地读取文本输入或文本文件，istream类提供了多种可完成这种工作的方法。
如果ch是一个char变量，则下面的语句将输入中的下一个字符读入到ch中：
cin >> ch;
然而，它将忽略空格、换行符和制表符。
下面的成员函数调用读取输入中的下一个字符（而不管该字符是什么）并将其存储到ch中：
cin.get (ch);
成员函数调用cin.get();返回下一个输入字符（包括空格、换行符和制表符），因此，可以这样使用它：
ch = cin.get();
cin.get(char)通过返回转换为false的bool值来指出已到达EOF（fstream类重载了bool操作符），
而cin.get通过返回EOF值来指出已到达EOF，EOF是在文件iostream中定义的。
嵌套循环适合用于处理多维数组。
5.8 复习题
1.入口条件循环和出口条件循环之间的区别是什么？各种C++循环分别属于其中的哪一种？
入口条件循环在进入输入循环体之前评估测试表达式。如果条件最初为false，则循环不会执行其循环体。
出口条件循环在处理循环体之后评估测试表达式。因此，即使测试表达式最初为false，循环也将执行一次。
for和while循环都是入口条件循环，而do while循环是出口条件循环。

2.如果下面的代码片段是有效程序的组成部分，它将打印什么内容？
int i;
for(i = 0; i < 5; i++)
    cout << i;
    cout << endl;

01234

注意，cout<< endl;不是循环体的组成部分

3.如果下面的代码片段是有效程序的组成部分，它将打印什么内容？
int j;
for (j = 0; j < 11; j += 3)
    cout << j;
cout << endl << j << endl;

0369
12

4.如果下面的代码片段是有效程序的组成部分，它将打印什么内容？
int j = 5;
while (++j < 9)
    cout << j++ << endl;

6
8

5・如果下面的代码片段是有效程序的组成部分，它将打印什么内容？
int k = 8;
do
    cout << "k = " << k << endl;
while (k++ < 5);

k = 8

6.编写一个打印1、2、4、8、16、32、64的for循环，每轮循环都将计数变量的值乘以2。

for (int i = 1; i <= 64; i *= 2)
{
    cout << i << ' ';
}
cout << '\n';

7.如何在循环体中包括多条语句？

将多条语句放在一对大括号中将形成一个复合语句或代码块。

8.下面的语句是否有效？如果无效，原因是什么？如果有效，它将完成什么工作？
int x = (1, 024);
下面的语句又如何呢？
int y;
y = 1, 024;

int x = (1, 024);是有效的。表达式1, 024由两个表达式组成1和024，用逗号运算符连接。
表达式1, 024的值为右侧表达式024的值。024是八进制，换算成十进制就是20，因此该声明将值20赋给x。
y = 1, 024;是有效的。逗号运算符的优先级低于所有其他运算符，
因此y = 1, 024;相当于(y =1), 024;
也就是说，左侧表达式将y设置成1，整个表达式的值（没有使用）为024（八进制）。

9.在查看输入方面，cin>>ch同cn.get (ch)和ch = cin.get()有什么不同？

cin>> ch将跳过空格、换行符和制表符，其他两种格式将读取这些字符

5.9 编程练习
1.编写一个要求用户输入两个整数的程序。该程序将计算并输出这两个整数之间（包括这两个整数）所有整数的和。
这里假设先输入较小的整数。
#include <iostream>

int main()
{
    std::cout << "Enter a and b: ";
    int a = 0;
    int b = 0;
    std::cin >> a >> b;
    if (a > b)
    {
        return 0;
    }
    int result = 0;
    for (int i = a; i <= b; i++)
    {
        result += i;
    }
    std::cout << "Result: " << result << std::endl;

    return 0;
}
显示结果如下
Enter a and b: 2 9
Result: 44

2.使用array对象（而不是数组）和long double（而不是long long）重新编写程序清单5.4，并计算100!的值。
#include <iostream>
#include <array>

const int arr_size = 101;

int main()
{
    std::array<long double, arr_size> factorials;

    factorials[1] = factorials[0] = 1.0L;

    for (int i = 2; i < arr_size; i++)
    {
        factorials[i] = i * factorials[i - 1];
    }

    for (int i = 0; i < arr_size; i++)
    {
        std::cout << i << " ! = " << factorials[i] << std::endl;
    }

    return 0;
}
显示结果如下
0 ! = 1
1 ! = 1
2 ! = 2
3 ! = 6
4 ! = 24
5 ! = 120
6 ! = 720
7 ! = 5040
8 ! = 40320
9 ! = 362880
10 ! = 3.6288e+06
11 ! = 3.99168e+07
12 ! = 4.79002e+08
13 ! = 6.22702e+09
14 ! = 8.71783e+10
15 ! = 1.30767e+12
16 ! = 2.09228e+13
17 ! = 3.55687e+14
18 ! = 6.40237e+15
19 ! = 1.21645e+17
20 ! = 2.4329e+18
21 ! = 5.10909e+19
22 ! = 1.124e+21
23 ! = 2.5852e+22
24 ! = 6.20448e+23
25 ! = 1.55112e+25
26 ! = 4.03291e+26
27 ! = 1.08889e+28
28 ! = 3.04888e+29
29 ! = 8.84176e+30
30 ! = 2.65253e+32
31 ! = 8.22284e+33
32 ! = 2.63131e+35
33 ! = 8.68332e+36
34 ! = 2.95233e+38
35 ! = 1.03331e+40
36 ! = 3.71993e+41
37 ! = 1.37638e+43
38 ! = 5.23023e+44
39 ! = 2.03979e+46
40 ! = 8.15915e+47
41 ! = 3.34525e+49
42 ! = 1.40501e+51
43 ! = 6.04153e+52
44 ! = 2.65827e+54
45 ! = 1.19622e+56
46 ! = 5.50262e+57
47 ! = 2.58623e+59
48 ! = 1.24139e+61
49 ! = 6.08282e+62
50 ! = 3.04141e+64
51 ! = 1.55112e+66
52 ! = 8.06582e+67
53 ! = 4.27488e+69
54 ! = 2.30844e+71
55 ! = 1.26964e+73
56 ! = 7.10999e+74
57 ! = 4.05269e+76
58 ! = 2.35056e+78
59 ! = 1.38683e+80
60 ! = 8.32099e+81
61 ! = 5.0758e+83
62 ! = 3.147e+85
63 ! = 1.98261e+87
64 ! = 1.26887e+89
65 ! = 8.24765e+90
66 ! = 5.44345e+92
67 ! = 3.64711e+94
68 ! = 2.48004e+96
69 ! = 1.71122e+98
70 ! = 1.19786e+100
71 ! = 8.50479e+101
72 ! = 6.12345e+103
73 ! = 4.47012e+105
74 ! = 3.30789e+107
75 ! = 2.48091e+109
76 ! = 1.88549e+111
77 ! = 1.45183e+113
78 ! = 1.13243e+115
79 ! = 8.94618e+116
80 ! = 7.15695e+118
81 ! = 5.79713e+120
82 ! = 4.75364e+122
83 ! = 3.94552e+124
84 ! = 3.31424e+126
85 ! = 2.8171e+128
86 ! = 2.42271e+130
87 ! = 2.10776e+132
88 ! = 1.85483e+134
89 ! = 1.6508e+136
90 ! = 1.48572e+138
91 ! = 1.352e+140
92 ! = 1.24384e+142
93 ! = 1.15677e+144
94 ! = 1.08737e+146
95 ! = 1.033e+148
96 ! = 9.91678e+149
97 ! = 9.61928e+151
98 ! = 9.42689e+153
99 ! = 9.33262e+155
100 ! = 9.33262e+157

3.编写一个要求用户输入数字的程序。每次输入后，程序都将报告到目前为止，所有输入的累计和。
当用户输入0时，程序结束。
#include <iostream>

int main()
{
    long long result = 0;
    long long a;

    do
    {
        std::cout << "Enter number: ";
        a = 0;
        std::cin >> a;
        result += a;
        std::cout << "sum = " << result << std::endl;
    }
    while (a != 0);

    return 0;
}
显示结果如下
Enter number: 1
sum = 1
Enter number: 11
sum = 12
Enter number: 111
sum = 123
Enter number: 1111
sum = 1234
Enter number: 11111
sum = 12345
Enter number: 111111
sum = 123456
Enter number: 0
sum = 123456

4.Daphne以10%的单利投资了100美元。也就是说，每一年的利润都是投资额的10%，即每年10美元。
而Cleo以5%的复利投资了100美元。也就是说，利息是当前存款（包括获得的利息）的5%。
请编写一个程序，计算多少年后，Cleo的投资价值才能超过Daphne的投资价值，并显示此时两个人的投资价值。
#include <iostream>

int main()
{
    double daphne = 100;
    double cleo = 100;
    int age = 0;

    std::cout << "Balance Daphne: " << daphne << std::endl;
    std::cout << "Balance Cleo: " << cleo << std::endl;
    std::cout << std::endl;

    do
    {
        daphne += 0.10 * 100;
        cleo += 0.05 * cleo;
        age++;

        std::cout << "Balance Daphne: " << daphne << std::endl;
        std::cout << "Balance Cleo: " << cleo << std::endl;
        std::cout << "Years passed: " << age << std::endl;

        std::cout << std::endl;
    }
    while (cleo <= daphne);

    return 0;
}
显示结果如下

Balance Daphne: 100
Balance Cleo: 100

Balance Daphne: 110
Balance Cleo: 105
Years passed: 1

Balance Daphne: 120
Balance Cleo: 110.25
Years passed: 2

Balance Daphne: 130
Balance Cleo: 115.763
Years passed: 3

Balance Daphne: 140
Balance Cleo: 121.551
Years passed: 4

Balance Daphne: 150
Balance Cleo: 127.628
Years passed: 5

Balance Daphne: 160
Balance Cleo: 134.01
Years passed: 6

Balance Daphne: 170
Balance Cleo: 140.71
Years passed: 7

Balance Daphne: 180
Balance Cleo: 147.746
Years passed: 8

Balance Daphne: 190
Balance Cleo: 155.133
Years passed: 9

Balance Daphne: 200
Balance Cleo: 162.889
Years passed: 10

Balance Daphne: 210
Balance Cleo: 171.034
Years passed: 11

Balance Daphne: 220
Balance Cleo: 179.586
Years passed: 12

Balance Daphne: 230
Balance Cleo: 188.565
Years passed: 13

Balance Daphne: 240
Balance Cleo: 197.993
Years passed: 14

Balance Daphne: 250
Balance Cleo: 207.893
Years passed: 15

Balance Daphne: 260
Balance Cleo: 218.287
Years passed: 16

Balance Daphne: 270
Balance Cleo: 229.202
Years passed: 17

Balance Daphne: 280
Balance Cleo: 240.662
Years passed: 18

Balance Daphne: 290
Balance Cleo: 252.695
Years passed: 19

Balance Daphne: 300
Balance Cleo: 265.33
Years passed: 20

Balance Daphne: 310
Balance Cleo: 278.596
Years passed: 21

Balance Daphne: 320
Balance Cleo: 292.526
Years passed: 22

Balance Daphne: 330
Balance Cleo: 307.152
Years passed: 23

Balance Daphne: 340
Balance Cleo: 322.51
Years passed: 24

Balance Daphne: 350
Balance Cleo: 338.635
Years passed: 25

Balance Daphne: 360
Balance Cleo: 355.567
Years passed: 26

Balance Daphne: 370
Balance Cleo: 373.346
Years passed: 27

5.假设要销售一本书。请编写一个程序，输入这本书全年中每个月的销售数量，
程序通过循环，使用初始化为月份字符串的char*数组（或string对象数组）逐月进行提示，
并将输入的数据储存在一个int数组中。然后，程序计算数组中各元素的总数，并报告这一年的销售情况。
#include <iostream>
#include <string>

int main()
{
    std::string month[12] =
    {
        "January", "February", "March",
        "April", "May", "June",
        "July", "August", "September",
        "October", "November", "December"
    };

    int total_book = 0;
    int array_book_sold[12];

    for (int i = 0; i < 12; i++)
    {
        std::cout << "Enter the number of books sold for: " << month[i] << std::endl;
        std::cin >> array_book_sold[i];

        total_book += array_book_sold[i];
    }
    std::cout << "Total books sold: " << total_book << std::endl;

    return 0;
}
显示结果如下
Enter the number of books sold for: January
12
Enter the number of books sold for: February
23
Enter the number of books sold for: March
34
Enter the number of books sold for: April
45
Enter the number of books sold for: May
56
Enter the number of books sold for: June
67
Enter the number of books sold for: July
78
Enter the number of books sold for: August
89
Enter the number of books sold for: September
90
Enter the number of books sold for: October
101
Enter the number of books sold for: November
112
Enter the number of books sold for: December
123
Total books sold: 830


6.完成编程练习5，但这一次使用一个二维数组来存储输入3年中每个月的销售量。
程序将报告每年销售量以及三年的总销售量。
#include <iostream>
#include <string>

int main()
{
    std::string months[12] =
    {
        "January", "February", "March",
        "April", "May", "June",
        "July", "August", "September",
        "October", "November", "December"
    };

    int value[3][12] = { 0 };
    int total_book = 0;

    for (int i = 0; i < 3; i++)
    {

        int total_book_year = 0;
        std::cout << i + 1 << " year" << std::endl;

        for (int j = 0; j < 12; j++)
        {
            std::cout << "Enter the number of books sold for: " << months[j] + " : ";
            std::cin >> value[i][j];
            total_book_year += value[i][j];
        }
        std::cout << "Total books sold year: " << total_book_year << std::endl;
        total_book += total_book_year;
    }
    std::cout << "Total books sold: " << total_book << std::endl;

    return 0;
}
显示结果如下
1 year
Enter the number of books sold for: January : 11
Enter the number of books sold for: February : 11
Enter the number of books sold for: March : 11
Enter the number of books sold for: April : 22
Enter the number of books sold for: May : 2
Enter the number of books sold for: June : ^C
[weiyayun@weiyayun-PC code]$ ch05_p06
1 year
Enter the number of books sold for: January : 11
Enter the number of books sold for: February : 11
Enter the number of books sold for: March : 11
Enter the number of books sold for: April : 22
Enter the number of books sold for: May : 22
Enter the number of books sold for: June : 22
Enter the number of books sold for: July : 33
Enter the number of books sold for: August : 33
Enter the number of books sold for: September : 33
Enter the number of books sold for: October : 123
Enter the number of books sold for: November : 123
Enter the number of books sold for: December : 123
Total books sold year: 567
2 year
Enter the number of books sold for: January : 111
Enter the number of books sold for: February : 111
Enter the number of books sold for: March : 111
Enter the number of books sold for: April : 222
Enter the number of books sold for: May : 222
Enter the number of books sold for: June : 222
Enter the number of books sold for: July : 333
Enter the number of books sold for: August : 333
Enter the number of books sold for: September : 333
Enter the number of books sold for: October : 666
Enter the number of books sold for: November : 666
Enter the number of books sold for: December : 666
Total books sold year: 3996
3 year
Enter the number of books sold for: January : 1111
Enter the number of books sold for: February : 1111
Enter the number of books sold for: March : 1111
Enter the number of books sold for: April : 2222
Enter the number of books sold for: May : 2222
Enter the number of books sold for: June : 2222
Enter the number of books sold for: July : 3333
Enter the number of books sold for: August : 3333
Enter the number of books sold for: September : 3333
Enter the number of books sold for: October : 5678
Enter the number of books sold for: November : 5678
Enter the number of books sold for: December : 5678
Total books sold year: 37032
Total books sold: 41595

7.设计一个名为car的结构，用它存储下述有关汽车的信息：
生产商（存储在字符数组或string对象中的字符串）、生产年份（整数）。
编写一个程序，向用户询问有多少辆汽车。随后，程序使用new来创建个由相应数量的car结构组成的动态数组。
接下来，程序提示用户输入每辆车的生产商（可能由多个单词组成）和年份信息。
请注意，这需要特别小心，因为它将交替读取数值和字往串（参见第4章），最后，程序将显示每个结构的内容。
#include <iostream>
#include <string>

struct car
{
    std::string name;
    int age;
};

int main()
{
    std::cout << "Enter the number of machines that you want to catalog: ";
    int array_count;
    (std::cin >> array_count).get();

    car *ptr = new car[array_count];
    for (int i = 0; i < array_count; i++)
    {
        std::cout << "Car " << i + 1 << std::endl;
        std::cout << "Enter the manufacturer: ";
        std::getline(std::cin, ptr[i].name, '\n');
        std::cout << "Please enter the year of manufacture: ";
        (std::cin >> ptr[i].age).get();
    }

    std::cout << "Here is your collection:" << std::endl;

    for (int j = 0; j < array_count; j++)
    {
        std::cout << ptr[j].age << " : " << ptr[j].name << std::endl;
    }
    delete[] ptr;

    return 0;
}
显示结果如下
Enter the number of machines that you want to catalog: 3
Car 1
Enter the manufacturer: Peter Smith
Please enter the year of manufacture: 2003
Car 2
Enter the manufacturer: Hello World
Please enter the year of manufacture: 2006
Car 3
Enter the manufacturer: Mike Pence
Please enter the year of manufacture: 2009
Here is your collection:
2003 : Peter Smith
2006 : Hello World
2009 : Mike Pence

8.编写一个程序，它使用一个char数组和循环来每次读取一个单词，直到用户输入done为止。
随后该程序指出用户输入了多少个单词（不包括done在内）。
#include <iostream>
#include <cstring>
#include <string>

int main()
{
    char exit_word[8] = "done";
    char word[128];
    int count = 0;

    std::cout << "Type in the words (to complete, enter the word done): " << std::endl;

    do
    {
        if (std::cin >> word)
        {
            std::cout << word << std::endl;
            count++;
        }
        else
        {
            std::cout << "You entered " << count << " words." << std::endl;
            return 0;
        }
    }
    while (strcmp(word, exit_word));

    std::cout << "You entered " << count - 1 << " words." << std::endl;

    return 0;
}
显示结果如下
Type in the words (to complete, enter the word done):
Hello World Peter Smith Mike Pence
Hello
World
Peter
Smith
Mike
Pence
You entered 6 words.

Type in the words (to complete, enter the word done):
Hello World Peter Smith Mike Pence done
Hello
World
Peter
Smith
Mike
Pence
done
You entered 6 words.

9.编写一个满足前一个练习中描述的程序，但使用string对象而不是字符数组。
#include <iostream>
#include <string>

int main()
{
    std::string exit_word = "done";
    std::string word;
    int count = 0;

    std::cout << "Type in the words (to complete, enter the word done): " << std::endl;

    do
    {
        if (std::cin >> word)
        {
            std::cout << word << std::endl;
            count++;
        }
        else
        {
            std::cout << "You entered " << count << " words." << std::endl;
            return 0;
        }
    }
    while (word != exit_word);

    std::cout << "You entered " << count - 1 << " words." << std::endl;

    return 0;
}
显示结果如下
Type in the words (to complete, enter the word done):
Hello World Peter Smith Mike Pence
Hello
World
Peter
Smith
Mike
Pence
You entered 6 words.

Type in the words (to complete, enter the word done):
Hello World Peter Smith Mike Pence done
Hello
World
Peter
Smith
Mike
Pence
done
You entered 6 words.

10.编写一个使用嵌套循环的程序，要求用户输入一个值，指出要显示多少行。
然后，程序将显示相应行数的星号，其中第一行包括一个星号，第二行包括两个星号，依此类推。
每一行包含的字符数等于用户指定的行数，在星号不够的情况下，在星号前面加上句点。
#include <iostream>
#include <string>

int main()
{
    std::string dot = ".";
    std::string star = "*";

    std::cout << "Enter the number of rows: ";
    int count = 0;
    std::cin >> count;

    if (count <= 0)
    {
        return 0;
    }

    for (int i = 1; i <= count; i++)
    {
        for (int j = 0; j < count - i; j++)
        {
            std::cout << dot;
        }
        for (int j = 0; j < i; j++)
        {
            std::cout << star;
        }
        std::cout << std::endl;
    }

    return 0;
}
显示结果如下
Enter the number of rows: 5
....*
...**
..***
.****
*****

第6章 分支语句和逻辑运算符
6.1 if语句
6.1.1 if else语句
6.1.2 格式化if else语句
6.1.3 if else if else结构
6.2 逻辑表达式.
6.2.1 逻辑OR运算符：||
6.2.2 逻辑AND运算符：&&
6.2.3 用&&来设置取值范围
6.2.4 逻辑NOT运算符：!
6.2.5 逻辑运算符细节
6.2.6 其他表示方式
6.3 字符函数库cctype
6.4 ? : 运算符
6.5 switch语句
6.5.1 将枚举量用作标签
6.5.2 switch和if else
6.6 break和continue语句
6.7 读取数字的循环
6.8 简单文件输入/输出
6.8.1 文本I/O和文本文件
6.8.2 写入到文本文件中
6.8.3 读取文本文件
6.9 总结
6.10 复习题
6.11 编程练习
本章内容包括：
if语句。
if else语句。
逻辑运算符：&&、||和!。
cctype字符函数库
条件运算符 ? :
switch语句。
continue和break语句。
读取数字的循环。
基本文件输入/输出。
6.1 if语句
if（test-condition）
    statement
如果test-condition（测试条件）为true，则程序将执行statement（语句），后者既可以是一条语句，也可以是符合语句。
如果测试条件为false，则程序将跳过语句（参见图6.1）。
和循环测试条件一样，if测试条件也将被强制转换为bool值，因此0将被转换为false，非零为true，整个if语句被视为一条语句。
程序清单6.1 if.cpp
#include <iostream>

using namespace std;

int main()
{
    char ch;
    int spaces = 0;
    int total = 0;
    cin.get(ch);
    while (ch != '.')
    {
        if (ch == ' ')
        {
            ++spaces;
        }
        ++total;
        cin.get(ch);
    }
    cout << spaces << " spaces, " << total << " characters total in sentence\n";

    return 0;
}
显示结果如下
Hello, World! Peter Smith.
3 spaces, 25 characters total in sentence

程序清单6.2 ifelse.cpp
#include <iostream>

int main()
{
    char ch;
    std::cout << "Type, and I shall repeat.\n";
    std::cin.get(ch);
    while (ch != '.')
    {
        if (ch == '\n')
        {
            std::cout << ch;
        }
        else
        {
            std::cout << ++ch;
        }
        std::cin.get(ch);
    }
    std::cout << "\nDone.\n";

    return 0;
}
显示结果如下
Type, and I shall repeat.
Hello, World!.
Ifmmp-!Xpsme"
Done.

程序清单6.3 ifelseif.cpp
#include <iostream>

using namespace std;

const int Fave = 27;

int main()
{
    int n;
    cout << "Enter a number in the range 1-100 to find my favorite number: ";
    do
    {
        n = 0;
        cin >> n;
        if (n < Fave)
        {
            cout << "Too low -- guess again: ";
        }
        else if (n > Fave)
        {
            cout << "Too high -- guess again: ";
        }
        else
        {
            cout << Fave << " is right! \n";
        }
    }
    while (n != Fave);

    return 0;
}
显示结果如下
Enter a number in the range 1-100 to find my favorite number: 11
Too low -- guess again: 33
Too high -- guess again: 22
Too low -- guess again: 30
Too high -- guess again: 26
Too low -- guess again: 28
Too high -- guess again: 27
27 is right!

6.2逻辑表达式
6.2.1 逻辑OR运算符：||
||运算符的优先级比关系运算符低。||运算符是个顺序点（sequence point），||运算符左边的子表达式先于右边的子表达式。
如果左侧的表达式为true，则C++将不会去判定右侧的表达式，因为只要一个表达式为true，则整个逻辑表达式为true。
程序清单6.4在一条if语句中使用||运算符来检查某个字符的大写或小写。
程序清单6.4 or.cpp
#include <iostream>

using namespace std;

int main()
{
    cout << "This program may reformat your hard disk and destroy all your data.\n";
    cout << "Do you wish to continue? <y/n> ";
    char ch;
    cin >> ch;
    if (ch == 'y' || ch == 'Y')
    {
        cout << "You were warned!\n";
    }
    else if (ch == 'n' || ch == 'N')
    {
        cout << "A wise choice, bye.\n";
    }
    else
    {
        cout << "please enter a y or n\n";
    }

    return 0;
}
显示结果如下
This program may reformat your hard disk and destroy all your data.
Do you wish to continue? <y/n> y
You were warned!

This program may reformat your hard disk and destroy all your data.
Do you wish to continue? <y/n> n
A wise choice, bye.

This program may reformat your hard disk and destroy all your data.
Do you wish to continue? <y/n> a
please enter a y or n

6.2.2 逻辑AND运算符：&&
&&运算符的优先级比关系运算符低。&&运算符也是顺序点，&&运算符左边的子表达式先于右边的子表达式。
首先判定左侧，并且在右侧被判定之前产生所有的副作用。
如果左侧为false，则整个逻辑表达式必定为false，在这种情况下，C++将不会再对右侧进行判定。
程序清单6.5 and.cpp
#include <iostream>

using namespace std;

const int ArSize = 6;

int main()
{
    double naaq[ArSize];
    cout << "Enter the NAAQs (New Age Awareness Quotients) of your neighbors.\n";
    cout << "Program terminates when you make " << ArSize << " entries "
         << "or enter a negative value.\n";

    int i = 0;
    double temp;
    cout << "First value: ";
    cin >> temp;
    while (i < ArSize && temp >= 0)
    {
        naaq[i] = temp;
        ++i;
        if (i < ArSize)
        {
            cout << "Next value: ";
            cin >> temp;
        }
    }
    if (i == 0)
    {
        cout << "No data, bye.\n";
    }
    else
    {
        cout << "Enter your NAAQ: ";
        double you;
        cin >> you;
        int count = 0;
        for (int j = 0; j < i; j++)
        {
            if (naaq[j] > you)
            {
                ++count;
            }
        }
        cout << count << " of your neighbors have greater awareness of the New Age than you do.\n";
    }

    return 0;
}
显示结果如下
Enter the NAAQs (New Age Awareness Quotients) of your neighbors.
Program terminates when you make 6 entries or enter a negative value.
First value: 1.1
Next value: 2.2
Next value: 3.3
Next value: 4.4
Next value: 5.5
Next value: -1.1
Enter your NAAQ: 2.6
3 of your neighbors have greater awareness of the New Age than you do.

程序清单6.6 moreand.cpp
#include <iostream>

using namespace std;

const char *qualify[4] =
{
    "10,000-meter race.\n",
    "mud tug-of-war.\n",
    "masters canoe jousting.\n",
    "pie-throwing festival.\n"
};

int main()
{
    int age;
    cout << "Enter your age in years: ";
    cin >> age;
    int index;

    if (age > 17 && age < 35)
    {
        index = 0;
    }
    else if (age >= 35 && age < 50)
    {
        index = 1;
    }
    else if (age >= 50 && age < 65)
    {
        index = 2;
    }
    else
    {
        index = 3;
    }

    cout << "You qualify for the " << qualify[index];

    return 0;
}
显示结果如下

Enter your age in years: 29
You qualify for the 10,000-meter race.

Enter your age in years: 39
You qualify for the mud tug-of-war.

Enter your age in years: 53
You qualify for the masters canoe jousting.

Enter your age in years: 69
You qualify for the pie-throwing festival.

6.2.4逻辑 NOT运算符：!
!运算符将它后面的表达式的真值取反。也是说如果expression为true或非零，则! expression是false；
如果expression为false或零，则! expression 是true。
程序清单 6.7not.cpp
#include <iostream>
#include <climits>

using namespace std;

bool is_int(double x);

int main()
{
    double num;

    cout << "Please enter an integer value: ";
    num = 0;
    cin >> num;
    while (!is_int(num))
    {
        cout << "Out of range, please try again: ";
        num = 0;
        cin >> num;
    }
    int val = int(num);
    cout << "You've entered the integer " << val << "\nDone.\n";

    return 0;
}

bool is_int(double x)
{
    if (x <= INT_MAX && x >= INT_MIN)
    {
        return true;
    }
    else
    {
        return false;
    }
}
显示结果如下
Please enter an integer value: 123
You've entered the integer 123
Done.

Please enter an integer value: 12345678901
Out of range, please try again: 23
You've entered the integer 23
Done.

6.3字符面数库cctype
程序清单6.8 cctypes.cpp
#include <iostream>
#include <cctype>

using namespace std;

int main()
{
    cout << "Enter text for analysis, and type @ to terminate input.\n";
    char ch;
    int whitespace = 0;
    int digits = 0;
    int chars = 0;
    int punct = 0;
    int others = 0;

    cin.get(ch);
    while (ch != '@')
    {
        if (isalpha(ch))
        {
            chars++;
        }
        else if (isspace(ch))
        {
            whitespace++;
        }
        else if (isdigit(ch))
        {
            digits++;
        }
        else if (ispunct(ch))
        {
            punct++;
        }
        else
        {
            others++;
        }
        cin.get(ch);
    }
    cout << chars << " letters, "
         << whitespace << " whitespace, "
         << digits << " digits, "
         << punct << " punctuations, "
         << others << " others.\n";

    return 0;
}
显示结果如下
Enter text for analysis, and type @ to terminate input.
Hello, World!   123@
10 letters, 4 whitespace, 3 digits, 2 punctuations, 0 others.

6.4 ? : 运算符
程序清单6.9 condit.cpp
#include <iostream>

using namespace std;

int main() 
{
	int a, b;
	cout << "Enter two integers: ";
	cin >> a >> b;
	cout << "The larger of " << a << " and " << b;
	int c = a > b ? a : b;
	cout << " is " << c << endl;

	return 0;
}
显示结果如下
Enter two integers: 3 5
The larger of 3 and 5 is 5

Enter two integers: 5 3
The larger of 5 and 3 is 5

6.5 switch语句
switch语句的通用格式：
switch (integer-expression)
{
    case label1 : statement(s); break;
    case label2 : statement(s); break;
...
    default : statement(s); break;
}
程序清单6.10 switch.cpp
#include <iostream>

using namespace std;

void showmenu();
void report();
void comfort();

int main()
{
	showmenu();
	int choice;
               choice = 0;
	cin >> choice;
	while (choice != 5)
	{
		switch (choice)
		{
		case 1:   cout << "choose alarm\n";
			break;
		case 2:   report();
			break;
		case 3:   cout << "The boss was in all day.\n";
			break;
		case 4:   comfort();
			break;
		default:   cout << "That's not a choice.\n"; break;
		}
		showmenu();
                              choice = 0;
		cin >> choice;
	}
	cout << "Done.\n";

	return 0;
}

void showmenu()
{
	cout << "Please enter 1, 2, 3, 4, or 5:\n"
		"1) alarm           2) report\n"
		"3) alibi           4) comfort\n"
		"5) quit\n";
}

void report()
{
	cout << "It's been an excellent week for business.\n"
		"Sales are up 120%. Expenses are down 35%.\n";
}
void comfort()
{
	cout << "Your employees think you are the finest CEO\n"
		"in the industry. The board of directors think\n"
		"you are the finest CEO in the industry.\n";
}
显示结果如下
Please enter 1, 2, 3, 4, or 5:
1) alarm           2) report
3) alibi           4) comfort
5) quit
1
choose alarm
Please enter 1, 2, 3, 4, or 5:
1) alarm           2) report
3) alibi           4) comfort
5) quit
2
It's been an excellent week for business.
Sales are up 120%. Expenses are down 35%.
Please enter 1, 2, 3, 4, or 5:
1) alarm           2) report
3) alibi           4) comfort
5) quit
3
The boss was in all day.
Please enter 1, 2, 3, 4, or 5:
1) alarm           2) report
3) alibi           4) comfort
5) quit
4
Your employees think you are the finest CEO
in the industry. The board of directors think
you are the finest CEO in the industry.
Please enter 1, 2, 3, 4, or 5:
1) alarm           2) report
3) alibi           4) comfort
5) quit
5
Done.

程序清单6.11 enum.cpp
#include <iostream>

using namespace std;

enum { red, orange, yellow, green, blue, violet, indigo };

int main()
{

    cout << "Enter color code (0-6): ";
    int code = 0;
    cin >> code;
    while (code >= red && code <= indigo)
    {
        switch (code)
        {
        case red:
            cout << "Her lips were red.\n";
            break;
        case orange:
            cout << "Her hair was orange.\n";
            break;
        case yellow:
            cout << "Her shoes were yellow.\n";
            break;
        case green:
            cout << "Her nails were green.\n";
            break;
        case blue:
            cout << "Her sweatsuit was blue.\n";
            break;
        case violet:
            cout << "Her eyes were violet.\n";
            break;
        case indigo:
            cout << "Her mood was indigo.\n";
            break;
        default :
            cout << "code invalid\n";
            break;
        }
        cout << "Enter color code (0-6): ";
        code = 0;
        cin >> code;
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Enter color code (0-6): 0
Her lips were red.
Enter color code (0-6): 1
Her hair was orange.
Enter color code (0-6): 2
Her shoes were yellow.
Enter color code (0-6): 3
Her nails were green.
Enter color code (0-6): 4
Her sweatsuit was blue.
Enter color code (0-6): 5
Her eyes were violet.
Enter color code (0-6): 6
Her mood was indigo.
Enter color code (0-6): 7
Done.

6.6 break和continue语句
可以在switch语句或任何循环中使用break语句，使程序跳到switch或循环后面的语句处执行。
continue语句用于循环中，让程序跳过循环体余下的代码，并开始新一轮循环（参见图6.4）。
程序清单6.12 jump.cpp
#include <iostream>

using namespace std;

const int ArSize = 128;

int main()
{
    char line[ArSize] = {0};
    int spaces = 0;

    cout << "Enter a line of text:\n";
    cin.get(line, ArSize);
    cin.get();
    cout << "Complete line:\n" << line << endl;
    cout << "Line through first period:\n";
    for (int i = 0; line[i] != '\0'; i++)
    {
        cout << line[i];
        if (line[i] == '.')
        {
            break;
        }
        if (line[i] != ' ')
        {
            continue;
        }
        spaces++;
    }
    cout << "\n" << spaces << " spaces\n";
    cout << "Done.\n";

    return 0;
}
显示结果如下
Enter a line of text:
a b c d e f g 123. h i j k l m n.
Complete line:
a b c d e f g 123. h i j k l m n.
Line through first period:
a b c d e f g 123.
7 spaces
Done.

程序清单6.13 cinfish.cpp
#include <iostream>

using namespace std;

const int Max = 5;

int main()
{
    double fish[Max];
    cout << "Please enter the weights of your fish.\n";
    cout << "You may enter up to " << Max << " fish or enter q to terminate.\n";
    cout << "fish #1: ";
    int i = 0;
    while (i < Max && cin >> fish[i])
    {
        if (++i < Max)
        {
            cout << "fish #" << i + 1 << ": ";
        }
    }
    cin.clear();
    double total = 0.0;
    for (int j = 0; j < i; j++)
    {
        total += fish[j];
    }

    if (i == 0)
    {
        cout << "No fish, bye.\n";
    }
    else
    {
        cout << "average weight of " << i << " fish = "  << total / i << endl;
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Please enter the weights of your fish.
You may enter up to 5 fish or enter q to terminate.
fish #1: 1.2
fish #2: 1.5
fish #3: 1.6
fish #4: q
average weight of 3 fish = 1.43333
Done.

程序清单6.14 cingolf.cpp
#include <iostream>

using namespace std;

const int Max = 5;

int main()
{
    double golf[Max];
    cout << "Please enter your golf scores.\n";
    cout << "You must enter " << Max << " rounds.\n";
    int i;
    for (i = 0; i < Max; i++)
    {
        cout << "round #" << i + 1 << ": ";
        while (!(cin >> golf[i]))
        {
            cin.clear();
            while (cin.get() != '\n')
            {
                continue;
            }
            cout << "Please enter a number: ";
        }
        while (cin.get() != '\n')
        {
            continue;
        }
    }

    double total = 0.0;
    for (i = 0; i < Max; i++)
    {
        total += golf[i];
    }

    cout << "average score of " << Max << " rounds = " << total / Max << endl;

    return 0;
}
显示结果如下
Please enter your golf scores.
You must enter 5 rounds.
round #1: 1.1
round #2: 2.2
round #3: 3.3
round #4: 4.4
round #5: 5.5
average score of 5 rounds = 3.3

6.8简单文件输入/输出
程序清单6.15 outfile.cpp
#include <iostream>
#include <fstream>

using namespace std;

int main()
{
	char automobile[128];
	int year;
	double a_price;
	double d_price;

	ofstream outFile;
	outFile.open("carinfo.txt");

	cout << "Enter the make and model of automobile: ";
	cin.getline(automobile, 128);
	cout << "Enter the model year: ";
	cin >> year;
	cout << "Enter the original asking price: ";
	cin >> a_price;
	d_price = 0.913 * a_price;

	cout << fixed;
	cout.precision(2);
	cout.setf(ios_base::showpoint);
	cout << "Make and model: " << automobile << endl;
	cout << "Year: " << year << endl;
	cout << "Was asking $" << a_price << endl;
	cout << "Now asking $" << d_price << endl;

	outFile << fixed;
	outFile.precision(2);
	outFile.setf(ios_base::showpoint);
	outFile << "Make and model: " << automobile << endl;
	outFile << "Year: " << year << endl;
	outFile << "Was asking $" << a_price << endl;
	outFile << "Now asking $" << d_price << endl;

	outFile.close();

	return 0;
}
显示结果如下
Enter the make and model of automobile: Hello, World!
Enter the model year: 2020
Enter the original asking price: 123.567
Make and model: Hello, World!
Year: 2020
Was asking $123.57
Now asking $112.82

cat carinfo.txt
Make and model: Hello, World!
Year: 2020
Was asking $123.57
Now asking $112.82

程序清单6.16 sumafile.cpp
#include <iostream>
#include <fstream>
#include <cstdlib>

using namespace std;

const int SIZE = 128;

int main()
{
    char filename[SIZE];
    ifstream inFile;

    cout << "Enter name of data file: ";
    cin.getline(filename, SIZE);
    inFile.open(filename);
    if (!inFile.is_open())
    {
        cout << "Could not open the file " << filename << endl;
        cout << "Program terminating.\n";
        exit(EXIT_FAILURE);
    }
    double value;
    double sum = 0.0;
    int count = 0;

    value = 0.0;
    inFile >> value;
    while (inFile.good())
    {
        ++count;
        sum += value;
        value = 0.0;
        inFile >> value;
    }
    if (inFile.eof())
    {
        cout << "End of file reached.\n";
    }
    else if (inFile.fail())
    {
        cout << "Input terminated by data mismatch.\n";
    }
    else
    {
        cout << "Input terminated for unknown reason.\n";
    }

    if (count == 0)
    {
        cout << "No data processed.\n";
    }
    else
    {
        cout << "Items read: " << count << endl;
        cout << "Sum: " << sum << endl;
        cout << "Average: " << sum / count << endl;
    }
    inFile.close();

    return 0;
}
显示结果如下
Enter name of data file: sumafile.txt
End of file reached.
Items read: 5
Sum: 16.5
Average: 3.3

cat sumafile.txt
1.1 2.2 3.3 4.4 5.5

6.9总结
if语句使程序有条件地执行语句或语句块，也就是说，如果满足特定的条件，程序将执行特定的语句或语句块。
if else语句程序选择执行两个语句或语句块之一。可以在这条语句后再加上if else，以提供一系列的选项。
switch语句引导程序执行一系列选项之一。
if和ifelse语句通常使用关系表达式作为测试条件。通过使用逻辑运算符（&&、||和!），可以组合或修改关系表达式，创建更细致的测试。
条件运算符（? :）提供了一种选择两个值之一的简洁方式。
cctype字符函数库提供了一组方便的、功能强大的工具，可用于分析字符输入。
声明ifstream和ofstream对象，并将它们同文件关联起来后，便可以像使用cin和cout那样使用这些对象编写程序。
6.10复习题
1.请看下面两个计算空格和换行符数目的代码片段：
//Version 1
while (cin.get(ch))
{
    if (ch == ' ')
    {
        spaces++;
    }
    If (ch == '\n')
    {
        newlines++;
    }
}

//Version 2
while (cin.get(ch))
{
    if (ch == ' ')
    {
        spaces++;
    }
    else If (ch == '\n')
    {
        newlines++;
    }
}
第二种格式比第一种格式好在哪里呢？
if else版本的效率更高。
例如，考虑当ch为空格时的情况。版本1对空格加1，然后看它是否为换行符。
这将浪费时间，因为程序已经知道ch为空格，因此它不是换行符。
在这种情况下，版本2将不会查看字符是否为换行符。

2.在程序清单6.2中，用ch+1替换++ch将发生什么情况呢？
#include <iostream>

int main()
{
    char ch;
    std::cout << "Type, and I shall repeat.\n";
    std::cin.get(ch);
    while (ch != '.')
    {
        if (ch == '\n')
        {
            std::cout << ch;
        }
        else
        {
            std::cout << ++ch;
        }
        std::cin.get(ch);
    }
    std::cout << "\nDone.\n";

    return 0;
}
++ch和ch+1得到的数值相同。但++ch的类型为char，将作为字符打印，而ch+1是int类型（因为将char和int相加），将作为数字打印。

3.请认真考虑下面的程序：
#include <iostream>

using namespace std;

int main()
{
    char ch;
    int ct1, ct2;
    ct1 = ct2 = 0;

    while ( ( ch = cin.get() ) != '$' )
    {
        cout << ch;
        ct1++;
        if (ch = '$')
        {
            ct2++;
        }
        cout << ch;
    }
    cout << "ct1 = " << ct1 << ", ct2 = " << ct2 << "\n";

    return 0;
}
假设输入如下（请在每行末尾按回车键）：
Hi!
Send $10 or $20 now
则输出将是什么（还记得吗，输入被缓冲）？
Hi!
H$i$!$
$Send $10 or $20 now
S$e$n$d$ $ct1 = 9, ct2 = 9

注意读取Hi!后读到的是一个换行符

4.创建表示下述条件的逻辑表达式：
a.weight大于或等于115，但小于125.
b.ch为q或Q.
c.x为偶数，但不是26
d.x为偶数，但不是26的倍数。
e.donation为1000-2000或guest为1.
f.ch是小写字母或大写字母（假设小写字母是依次编码的，大写字母也是依次编码的，但在大小写字母间编码不是连续的）

a.weight >=115 && weight < 125
b.ch =='q' || ch == 'Q'
c.x % 2 == 0 && x != 26
d.x % 2 == 0 && !(x % 26 == 0)
e.(donation >= 1000 && donation <= 2000) || guest = 1
f.(ch >= 'a' && ch <='z') || (ch >= 'A' && ch <= 'Z')

5.在英语中，"I will not not speak（我不会不说）”的意思与"I will speak（我要说）”相同。
在C++中，!!x是否与x相同呢？
不一定相同。如果x不为0和1，则!x为0，!!x为1。如果x为bool变量，则!!x为x。

6.创建一个条件表达式，其值为变量的绝对值。
也是说，如果变量x为正，则表达式的值为x；但如果x为负，则表达式的值为-x。
(x>=0) ? x : -x或(x < 0) ? -x : x

7.用switch改写下面的代码片段
if (ch == 'A')
    a_grade++;
else if (ch == 'B')
    b_grade++;
else if (ch == 'C')
    c_grade++;
else if (ch == 'D')
    d_grade++;
else
    f_grade++;

switch (ch)
{
case 'A':
    a_grade++;
    break;
case 'B':
    b_grade++;
    break;
case 'C':
    c_grade++;
    break;
case 'D':
    d_grade++;
    break;
default :
    f_grade++;
    break;
}

8.对于程序清单6.10，与使用数字相比，使用字符（如a和c）表示菜单选项和case标签有何优点呢？
提示：想想用户输入q和输入5的情况。
#include <iostream>

using namespace std;

void showmenu();
void report();
void comfort();

int main()
{
    showmenu();
    int choice;
    choice = 0;
    cin >> choice;
    while (choice != 5)
    {
        switch (choice)
        {
        case 1:
            cout << "choose alarm\n";
            break;
        case 2:
            report();
            break;
        case 3:
            cout << "The boss was in all day.\n";
            break;
        case 4:
            comfort();
            break;
        default:
            cout << "That's not a choice.\n";
            break;
        }
        showmenu();
        choice = 0;
        cin >> choice;
    }
    cout << "Done.\n";

    return 0;
}

void showmenu()
{
    cout << "Please enter 1, 2, 3, 4, or 5:\n"
         "1) alarm           2) report\n"
         "3) alibi           4) comfort\n"
         "5) quit\n";
}

void report()
{
    cout << "It's been an excellent week for business.\n"
         "Sales are up 120%. Expenses are down 35%.\n";
}
void comfort()
{
    cout << "Your employees think you are the finest CEO\n"
         "in the industry. The board of directors think\n"
         "you are the finest CEO in the industry.\n";
}

如果使用整数标签，且用户输入了非整数（如q），则cin >> choice会失败
如果使用字符标签，且用户输入了整数（如5），则cin >> choice会将5作为字符处理，然后进入switch语句的default部分。

9.请看下面的代码片段：
int line = 0;
char ch;
while ( cin.get(ch) )
{
    if ( ch == 'Q' )
    {
        break;
    }
    if (ch != '\n')
    {
        continue;
    }
    line++;
}
请重写该代码片段，不要使用break和continue语句

int line = 0;
char ch;
while ( cin.get(ch) && ch != 'Q' )
{
    if (ch == '\n')
    {
        line++;
    }
}

6.11编程练习
1.编写一个程序，读取键盘输入，直到遇到@符号为止，并回显输入，
同时将大写字符转换为小写，将小写字符转换为大写（别忘了cctype函数系列）。
#include <iostream>
#include <cctype>

int main()
{
    std::cout << "Type the text (@ means the end)" << std::endl;
    char ch;
    std::cin.get(ch);

    while (ch != '@')
    {
        if (isalpha(ch))
        {
            if (islower(ch))
            {
                std::cout << char(toupper(ch));
            }
            else
            {
                std::cout << char(tolower(ch));
            }
        }
        else
        {
            std::cout << ch;
        }
        std::cin.get(ch);
    }
    std::cout << std::endl;

    return 0;
}
显示结果如下
Type the text (@ means the end)
Hello, World! 123@
hELLO, wORLD! 123


2.编写一个程序，最多将10个donation值读入到一个double数组中（如果您愿意，也可使用模板类array）。
程序遇到非数字输入时将结束输入，并报告这些数字的平均值以及数组中有多少个数字大于平均值。
#include <iostream>

const int array_size = 10;

int main()
{
    double fond[array_size];
    double summ = 0.0;
    int count = 0;

    std::cout << "Enter 10 numbers of donations: " << std::endl;

    int i;
    for (i = 0; i < array_size; i++)
    {
        if ( ! (std::cin >> fond[i]) || fond[i] <= 0 )
        {
            break;
        }
        summ += fond[i];
    }

    double avg = summ / i;
    std::cout << "The average value of " << i << " donations: " << avg << std::endl;

    for (int j = 0; j < i; j++)
    {
        if (fond[j] > avg)
        {
            count++;
        }
    }
    std::cout << "Donations exceeding the average: " << count << std::endl;

    return 0;
}
显示结果如下
Enter 10 numbers of donations:
1.1 2.2 3.3 4.4 5.5 q
The average value of 5 donations: 3.3
Donations exceeding the average: 2

3.编写一个菜单驱动程序的雏形。该程序显示一个提供4个选项的菜单，每个选项用一个字母标记。
如果用户使用有效选项之外的字母进行响应，程序将提示用户输入一个有效的字母，直到用户这样做为止。
然后，该程序使用一条switch语句，根据用户的选择执行一个简单操作。
#include <iostream>

int main()
{
    std::cout << "Please enter one of the following choices: " << std::endl;
    std::cout << "c) carnivore p) pianist" << std::endl << "t) tree g) game" << std::endl;
    char enter;

    while ( std::cin.get(enter) )
    {
        while (std::cin.get() != '\n')
        {
            continue;
        }
        switch (enter)
        {
        case 'c':
        case 'C':
            std::cout << "Your choice is carnivore" << std::endl;
            break;
        case 'p':
        case 'P':
            std::cout << "Your choice is pianist" << std::endl;
            break;
        case 't':
        case 'T':
            std::cout << "Your choice is tree" << std::endl;
            break;
        case 'g':
        case 'G':
            std::cout << "Your choice is game" << std::endl;
            break;
        default:
            std::cout << "Please enter c, p, t, or g: ";
            break;
        }
    }

    return 0;
}
显示结果如下
Please enter one of the following choices:
c) carnivore p) pianist
t) tree g) game
c
Your choice is carnivore
p
Your choice is pianist
t
Your choice is tree
g
Your choice is game
c
Your choice is carnivore

4.加入Benevolent Order of Programmer后，在BOP大会上，
人们便可以通过加入者的真实姓名、头衔或秘密BOP姓名来了解他（她）。
请编写一个程序，可以使用真实姓名、头衔、秘密姓名或成员偏好来列出成员。
编写该程序时，请使用下面的结构；
struct bop
{
    char fullname[strsize];
    char title[strsize];
    char bopname[strsize];
    int preference;
};
该程序创建一个由上述结构组成的小型数组，并将其初始化为适当的值。
另外，该程序使用一个循环，让用户在下面的选项中进行选择
a.display by name         b.display by title
c.display by bopname   d.display by preference
q.quit
注意，"display by preference"并不意味着显示成员的偏好，而是意味着根据成员的偏好来列出成员。
例如，如果偏好号为1，则选择d将显示程序员的头衔。
#include <iostream>

const int strsize = 128;

struct bop
{
    char fullname[strsize];
    char title[strsize];
    char bopname[strsize];
    int preference;
};

int main()
{
    std::cout << "Benevolent Order of Programmers Report" << std::endl;
    std::cout << "a. display by name" << std::endl;
    std::cout << "b. display by title" << std::endl;
    std::cout << "c. display by bopname" << std::endl;
    std::cout << "d. display by preference" << std::endl;
    std::cout << "q. quit" << std::endl;
    std::cout << "Enter a,b,c,d or q: ";

    bop organization[4] =
    {
        { "Wimp Macho", "Wimp Macho - WM", "WM", 0 },
        { "Raki Rhodes", "Raki Rhodes - RR", "RR", 1 },
        { "Celia Laiter", "Celia Laiter - CL", "CL", 2 },
        { "Hoppy Hipman", "Hoppy Hipman - HH", "HH", 0 }
    };

    char enter;
    while ( std::cin.get(enter) )
    {
        while (std::cin.get() != '\n')
        {
            continue;
        }
        switch (enter)
        {
        case 'a':
        case 'A':
            for (int i = 0; i < 4; i++)
            {
                std::cout << organization[i].fullname << std::endl;
            }
            std::cout << "Enter a,b,c,d or q: ";
            break;
        case 'b':
        case 'B':
            for (int i = 0; i < 4; i++)
            {
                std::cout << organization[i].title << std::endl;
            }
            std::cout << "Enter a,b,c,d or q: ";
            break;
        case 'c':
        case 'C':
            for (int i = 0; i < 4; i++)
            {
                std::cout << organization[i].bopname << std::endl;
            }
            std::cout << "Enter a,b,c,d or q: ";
            break;
        case 'd':
        case 'D':
            for (int i = 0; i < 4; i++)
            {
                switch (organization[i].preference)
                {
                case 0:
                    std::cout << organization[i].fullname << std::endl;
                    break;
                case 1:
                    std::cout << organization[i].title << std::endl;
                    break;
                case 2:
                    std::cout << organization[i].bopname << std::endl;
                    break;
                default:
                    std::cout << organization[i].fullname << std::endl;
                    break;
                }
            }
            std::cout << "Enter a,b,c,d or q: ";
            break;
        case 'q':
        case 'Q':
            std::cout << "Done." << std::endl;

            return 0;
            break;
        default:
            std::cout << "Enter a,b,c,d or q: ";
            break;
        }
    }
    return 0;
}
显示结果如下
Benevolent Order of Programmers Report
a. display by name
b. display by title
c. display by bopname
d. display by preference
q. quit
Enter a,b,c,d or q: a
Wimp Macho
Raki Rhodes
Celia Laiter
Hoppy Hipman
Enter a,b,c,d or q: b
Wimp Macho - WM
Raki Rhodes - RR
Celia Laiter - CL
Hoppy Hipman - HH
Enter a,b,c,d or q: c
WM
RR
CL
HH
Enter a,b,c,d or q: d
Wimp Macho
Raki Rhodes - RR
CL
Hoppy Hipman
Enter a,b,c,d or q: q
Done.

5.在Ncutronia王国，货币单位是tvarp，收入所得税的计算方式如下：
5000 tvarps：不收税
5001 ~15000 tvarps：10%
15001~35000 tvarps：15%
35000 tvarps以上：20%
例如，收入为38000 tvarps时，所得税为5000 x 0.00 + 10000 × 0.10 + 20000 x 0.15 + 3000 x 0.20，即4600 tvarps。
请编写一个程序，使用循环来要求用户输入收入，并报告所得税。当用户输入负数或非数字时，循环将结束。
#include <iostream>

int main()
{
    std::cout << "Enter the number of earned tvarpov: ";
    double twarp = 0;

    while (std::cin >> twarp && twarp >= 0)
    {
        double summ = 0;

        if (twarp <= 5000)
        {
            std::cout << "Your tax = 0" << std::endl;
        }
        else if ((twarp > 5000) && (twarp <= 15000))
        {
            summ = (5000 * 0) + ((twarp - 5000) * 0.10);
            std::cout << "Your tax = " << summ << std::endl;
        }
        else if ((twarp > 15000) && (twarp <= 35000))
        {
            summ = (5000 * 0) + (10000 * 0.10) + ((twarp - 15000) * 0.15);
            std::cout << "Your tax = " << summ << std::endl;
        }
        else if (twarp > 35000)
        {
            summ = (5000 * 0) + (10000 * 0.10) + (20000 * 0.15) + ((twarp - 35000) * 0.20);
            std::cout << "Your tax = " << summ << std::endl;
        }
        std::cout << "Enter the number of earned tvarpov: ";
    }

    return 0;
}
显示结果如下
Enter the number of earned tvarpov: 38000
Your tax = 4600
Enter the number of earned tvarpov: 20000
Your tax = 1750
Enter the number of earned tvarpov: 10000
Your tax = 500
Enter the number of earned tvarpov: q

6.编写一个程序，记录捐助给“维护合法权利团体”的资金。
该程序要求用户输入捐献者数目，然后要求用户输入每一个捐献者的姓名和款项。
这些信息被储存在一个动态分配的结构数组中。
每个结构有两个成员：用来储存姓名的字符数组（或string对象）和用来存储款项的double成员。
读取所有的数据后，程序将显示所有捐款>=10000的捐款者的姓名及其捐款数额。
该列表前应包含一个标题，指出下面的捐款者是重要捐款人（Grand Patrons）。
然后，程序将列出其他的捐款者，该列表要以Patrons开头。
如果某种类别没有捐款者，则程序将打印单词"none"，该程序只显示这两种类别，而不进行排序。
#include <iostream>
#include <string>

using namespace std;

struct ZVL
{
    string name;
    double donate;
};

int main()
{
    std::cout << "Enter the number of patrons: ";
    int mecenat_count = 0;
    (std::cin >> mecenat_count).get();

    ZVL *zvl = new ZVL[mecenat_count];

    for (int i = 0; i < mecenat_count; i++)
    {
        std::cout << "Enter the name of the patron: ";
        getline(std::cin, zvl[i].name, '\n');
        std::cout << "Enter amount of donation: ";
        (std::cin >> zvl[i].donate).get();
    }

    int grand_patrons_count = 0;
    std::cout << "Grand Patrons: " << std::endl;

    for (int i = 0; i < mecenat_count; i++)
    {
        if (zvl[i].donate >= 10000)
        {
            std::cout << zvl[i].name << " = $" << zvl[i].donate  << std::endl;
            grand_patrons_count++;
        }
    }
    if (grand_patrons_count == 0)
    {
        std::cout << "NONE!" << std::endl;
    }

    int patrons_count = 0;
    std::cout << "Patrons: " << std::endl;

    for (int i = 0; i < mecenat_count; i++)
    {
        if (zvl[i].donate < 10000)
        {
            std::cout << zvl[i].name << " = $" << zvl[i].donate << std::endl;
            patrons_count++;
        }
    }

    if (patrons_count == 0)
    {
        std::cout << "NONE!" << std::endl;
    }

    delete [] zvl;

    return 0;
}
显示结果如下
Enter the number of patrons: 3
Enter the name of the patron: Peter Smith
Enter amount of donation: 8000
Enter the name of the patron: Mike Pence
Enter amount of donation: 12000
Enter the name of the patron: Hello World
Enter amount of donation: 20000
Grand Patrons:
Mike Pence = $12000
Hello World = $20000
Patrons:
Peter Smith = $8000

7.编写一个程序，它每次读取一个单词，直到用户只输入q。
然后，该程序指出有多少个单词以元音打头，有多少个单词以辅音打头，还有多少个单词不属于这两类。
为此，方法之一是，使用isalpha来区分以字母和其他字符打头的单词，
然后对于通过了isalpha测试的单词，使用if或switch语句来确定哪些以元音打头。
#include <iostream>
#include <cctype>
#include <string>

int main()
{
    std::cout << "Enter words (q to quit): " << std::endl;
    std::string words;

    int vowels = 0;
    int consonants = 0;
    int others = 0;

    while (std::cin >> words && words != "q")
    {
        if (isalpha(words[0]))
        {
            switch (words[0])
            {
            case 'a':
            case 'A':
            case 'e':
            case 'E':
            case 'i':
            case 'I':
            case 'o':
            case 'O':
            case 'u':
            case 'U':
            case 'y':
            case 'Y':
                vowels++;
                break;
            default:
                consonants++;
                break;
            }
        }
        else
        {
            others++;
        }
    }

    std::cout << vowels << " words beginning with vowels.\n";
    std::cout << consonants << " words beginning with consonants.\n";
    std::cout << others << " words beginning with any other character.\n";

    return 0;
}
显示结果如下
Enter words (q to quit):
Apple Orange Egg Peter Smith Mike Pence University Internet q
5 words beginning with vowels.
4 words beginning with consonants.
0 words beginning with any other character.

8.编写一个程序，它打开一个文件文件，逐个字符地读取该文件，直到到达文件末尾，然后指出该文件中包含多少个字符。
#include <iostream>
#include <fstream>

int main()
{
    std::ifstream finput;
    finput.open("ch06_p08.txt");

    if ( ! finput.is_open() )
    {
        std::cout << "Could not open file!" << '\n';
        return 0;
    }
    char word;
    int word_count = 0;

    while (finput.get(word))
    {
        word_count++;
    }

    if (finput.eof())
    {
        std::cout << "End of file reached.\n";
    }
    else if (finput.fail())
    {
        std::cout << "Input Fail.\n";
    }

    if (word_count == 0)
    {
        std::cout << "No data in the file.\n";
    }
    else
    {
        std::cout << "Number of characters in the file: " << word_count << std::endl;
    }

    finput.close();

    return 0;
}
显示结果如下
End of file reached.
Number of characters in the file: 26

cat ch06_p08.txt
123456789
abcdefg
hijklmn

注意每行都有一个换行符

9.完成编程练习6，但从文件中读取所需的信息。该文件的第一项应为捐款人数，余下的内容应为成对的行。
在每一对中，第一行为捐款人姓名，第二行为捐款数额。
#include <iostream>
#include <fstream>
#include <string>

struct ZVL
{
    std::string name;
    double donate;
};

int main()
{
    std::ifstream fileinp;
    fileinp.open("ch06_p09.txt");

    if (!fileinp.is_open())
    {
        std::cout << "Cound not open file." << std::endl;
        std::cout << "The program will be closed." << std::endl;
        exit(EXIT_FAILURE);
    }
    std::cout << "Number of Patrons: ";

    int mecenat_count;
    (fileinp >> mecenat_count).get();

    std::cout << mecenat_count << std::endl;
    ZVL *zvl = new ZVL[mecenat_count];

    for (int i = 0; i < mecenat_count; i++)
    {
        if ( ! std::getline(fileinp, zvl[i].name, '\n') )
        {
            break;
        }
        std::cout << "The name of the patron has been entered: ";
        std::cout << zvl[i].name << std::endl;
        (fileinp >> zvl[i].donate).get();
        std::cout << "Donation amount entered: ";
        std::cout << zvl[i].donate << std::endl;
        std::cout << std::endl;
    }

    int grand_patrons_count = 0;
    std::cout << "Grand Patrons: " << std::endl;

    for (int i = 0; i < mecenat_count; i++)
    {
        if (zvl[i].donate >= 10000)
        {
            std::cout << zvl[i].name << " = $" << zvl[i].donate << std::endl;
            grand_patrons_count++;
        }
    }

    if (grand_patrons_count == 0)
    {
        std::cout << "NONE!" << std::endl;
    }

    int patrons_count = 0;
    std::cout << "Patrons: " << std::endl;

    for (int i = 0; i < mecenat_count; i++)
    {
        if (zvl[i].donate < 10000)
        {
            std::cout << zvl[i].name << " = $" << zvl[i].donate << std::endl;
            patrons_count++;
        }
    }

    if (patrons_count == 0)
    {
        std::cout << "NONE!" << std::endl;
    }

    delete [] zvl;
    fileinp.close();

    return 0;
}
显示结果如下
Number of Patrons: 3
The name of the patron has been entered: Pete Smith
Donation amount entered: 8000

The name of the patron has been entered: Mike Pence
Donation amount entered: 12000

The name of the patron has been entered: Hello World
Donation amount entered: 20000

Grand Patrons:
Mike Pence = $12000
Hello World = $20000
Patrons:
Pete Smith = $8000

cat ch06_p09.txt
3
Pete Smith
8000
Mike Pence
12000
Hello World
20000

第7章 函数 C++的编程模块
7.1 复习函数的基本知识
7.1.1 定义函数
7.1.2 函数原型和函数调用
7.2 函数参数和按值传递
7.2.1 多个参数
7.2.2 另外一个接受两个参数的函数
7.3 函数和数组
7.3.1 函数如何使用指针来处理数组
7.3.2 将数组作为参数意味着什么
7.3.3 更多数组函数示例
7.3.4 使用数组区间的函数
7.3.5 指针和const
7.4 函数和二维数组
7.5 函数和C风格字符串
7.5.1 将C风格字符串作为参数的函数
7.5.2 返回C风格字符串的函数
7.6 函数和结构
7.6.1 传递和返回结构
7.6.2 另一个处理结构的函数示例
7.6.3 传递结构的地址.
7.7 函数和string对象
7.8 函数与array对象
7.9 递归
7.9.1 包含一个递归调甩的递归
7.9.2 包含多个递归调用的递归
7.10 函数指针
7.10.1 函数指针的基础知识
7.10.2 函数指针示例
7.10.3 深入探讨函数指针
7.10.4 使用typedef进行简化
7.11 总结
7.12 复习题
7.13 编程练习
本章内容包括：
函数基本知识。
函数原型。
按值传递函数参数。
设计处理数组的函数。
使用const指针参数。
设计处理文本字符串的函数。
设计处理结构的函数。
设计处理string对象的函数。
调用自身的函数（递归）。
指向函数的指针。

程序清单7.1.calling.cpp
#include <iostream>

using namespace std;

void simple();

int main()
{
    cout << "main () will call the simple () function: \n";
    simple();
    cout << "main() is finished with the simple () function.\n";

    return 0;
}

void simple()
{
    cout << "I'm but a simple function. \n";
}
显示结果如下
main () will call the simple () function:
I'm but a simple function.
main() is finished with the simple () function.

程序清单7.2 protos.cpp
#include <iostream>

using namespace std;

void cheers(int);
double cube(double x);

int main()
{
    cheers(5);
    cout << "Give me a number: ";
    double side;
    cin >> side;
    double volume = cube(side);
    cout << "A " << side << "-foot cube has a volume of " << volume << " cubic feet.\n";
    cheers(cube(2));

    return 0;
}


void cheers(int n)
{
    for (int i = 0; i < n; i++)
    {
        cout << "Cheers! ";
    }
    cout << endl;
}

double cube(double x)
{
    return x * x * x;
}
显示结果如下
Cheers! Cheers! Cheers! Cheers! Cheers!
Give me a number: 5
A 5-foot cube has a volume of 125 cubic feet.
Cheers! Cheers! Cheers! Cheers! Cheers! Cheers! Cheers! Cheers!

程序清单7.3演示了一个接受两个参数的函数，它还表明，在函数中修改形参的值不会影响调用程序中的数据。
程序清单7.3 twoarg.cpp
#include <iostream>

using namespace std;

void n_chars(char, int);

int main()
{
    int times;
    char ch;
    cout << "Enter a character: ";
    cin.get(ch);
    while (cin.get() != '\n')
    {
        continue;
    }
    while (ch != 'q')
    {
        cout << "Enter an integer: ";
        times = 0;
        if ( ! (cin >> times) )
        {
            break;
        }
        while (cin.get() != '\n')
        {
            continue;
        }
        n_chars(ch, times);
        cout << "\ntimes = " << times << ".\n";
        cout << "Enter a character (q to quit) : ";
        cin.get(ch);
        while (cin.get() != '\n')
        {
            continue;
        }
    }
    cout << "Done.\n";

    return 0;
}

void n_chars(char c, int n)
{
    while (n-- > 0)
    {
        cout << c;
    }
}
显示结果如下
Enter a character: a
Enter an integer: 3
aaa
times = 3.
Enter a character (q to quit) : b
Enter an integer: 5
bbbbb
times = 5.
Enter a character (q to quit) : c
Enter an integer: 7
ccccccc
times = 7.
Enter a character (q to quit) : q
Done.

程序清单7.4 lotto.cpp
#include <iostream>

using namespace std;

long double probability(int numbers, int picks);

int main()
{
    double total, choices;
    cout << "Enter the total number of choices on the game card and\n";
    cout << "the number of picks allowed:\n";
    while ( (cin >> total) && (cin >> choices) && choices <= total )
    {
        cout << "You have one chance in " << probability(total, choices) << " of winning. \n";
        cout << "Next two numbers (q to quit) : ";
    }
    cout << "Done.\n";

    return 0;
}
long double probability(int numbers, int picks)
{
    long double result = 1.0;
    long double n;
    int p;
    for (n = numbers, p = picks; p > 0; n--, p--)
    {
        result = result * n / p;
    }
    return result;
}
显示结果如下
Enter the total number of choices on the game card and
the number of picks allowed:
51 6
You have one chance in 1.80095e+07 of winning.
Next two numbers (q to quit) : q
Done.

程序清单7.5 arrfun1.cpp
#include <iostream>

using namespace std;

const int ArSize = 8;

int sum_arr(int arr[], int n);

int main()
{
    int cookies[ArSize] = { 1, 2, 4, 8, 16, 32, 64, 128 };

    int sum = sum_arr(cookies, ArSize);
    cout << "Total cookies eaten: " << sum << "\n";

    return 0;
}

int sum_arr(int arr[], int n)
{
    int total = 0;
    for (int i = 0; i < n; i++)
    {
        total = total + arr[i];
    }
    return total;
}
显示结果如下
Total cookies eaten: 255

程序清单7.6 arrfun2.cpp
#include <iostream>

const int ArSize = 8;

int sum_arr(int arr[], int n);

int main()
{
    int cookies[ArSize] = { 1, 2, 4, 8, 16, 32, 64, 128 };

    std::cout << "array address = " << cookies << '\n';
    std::cout << "sizeof cookies = " << sizeof cookies << '\n';
    int sum = sum_arr(cookies, ArSize);
    std::cout << "Total cookies eaten: " << sum << std::endl;

    sum = sum_arr(cookies, 3);
    std::cout << "First three eaters ate " << sum << " cookies.\n";

    sum = sum_arr(cookies + 4, 4);
    std::cout << "Last four eaters ate " << sum << " cookies.\n";

    return 0;
}

int sum_arr(int arr[], int n)
{
    int total = 0;
    std::cout << "arr address = " << arr << '\n';

    std::cout << "sizeof arr = " << sizeof arr << '\n';
    for (int i = 0; i < n; i++)
    {
        total = total + arr[i];
    }
    return total;
}
编译命令如下
g++ -o arrfun2 arrfun2.cpp
arrfun2.cpp: In function ‘int sum_arr(int*, int)’:
arrfun2.cpp:30:44: warning: ‘sizeof’ on array function parameter ‘arr’ will return size of ‘int*’ [-Wsizeof-array-argument]
   30 |     std::cout << "sizeof arr = " << sizeof arr << '\n';
      |                                            ^~~
arrfun2.cpp:25:17: note: declared here
   25 | int sum_arr(int arr[], int n)
      |             ~~~~^~~~~

显示结果如下
array address = 0x7ffd1df68500
sizeof cookies = 32
arr address = 0x7ffd1df68500
sizeof arr = 8
Total cookies eaten: 255
arr address = 0x7ffd1df68500
sizeof arr = 8
First three eaters ate 7 cookies.
arr address = 0x7ffd1df68510
sizeof arr = 8
Last four eaters ate 240 cookies.

程序清单7.7 arrfun3.cpp
#include <iostream>

using namespace std;

const int Max = 5;

int fill_array(double ar[], int limit);
void show_array(const double ar[], int n);
void revalue(double r, double ar[], int n);

int main()
{
    double properties[Max];
    int size = fill_array(properties, Max);
    show_array(properties, size);
    if (size > 0)
    {
        cout << "Enter revaluation factor: ";
        double factor = 0;
        while (!(cin >> factor))
        {
            cin.clear();
            while (cin.get() != '\n')
            {
                continue;
            }
            cout << "Bad input; Please enter a number: ";
        }
        revalue(factor, properties, size);
        show_array(properties, size);
    }
    cout << "Done.\n";

    return 0;
}

int fill_array(double ar[], int limit)
{
    double temp;
    int i;
    for (i = 0; i < limit; i++)
    {
        cout << "Enter value #" << (i + 1) << ": ";
        temp = 0;
        if ( ! (cin >> temp) )
        {
            cin.clear();
            while (cin.get() != '\n')
            {
                continue;
            }
            cout << "Bad input; input process terminated.\n";
            break;
        }
        else if (temp < 0)
        {
            while (cin.get() != '\n')
            {
                continue;
            }
            cout << "input process terminated.\n";
            break;
        }
        ar[i] = temp;
    }
    return i;
}

void show_array(const double ar[], int n)
{
    for (int i = 0; i < n; i++)
    {
        cout << "Property #" << (i + 1) << ": $";
        cout << ar[i] << endl;
    }
}

void revalue(double r, double ar[], int n)
{
    for (int i = 0; i < n; i++)
    {
        ar[i] *= r;
    }
}
显示结果如下
Enter value #1: 10000
Enter value #2: 20000
Enter value #3: 30000
Enter value #4: q
Bad input; input process terminated.
Property #1: $10000
Property #2: $20000
Property #3: $30000
Enter revaluation factor: 0.6
Property #1: $6000
Property #2: $12000
Property #3: $18000
Done.

程序清单7.8 arrfun4.cpp
#include <iostream>

using namespace std;

const int ArSize = 8;

int sum_arr(const int *begin, const int *end);

int main()
{
    int cookies[ArSize] = { 1, 2, 4, 8, 16, 32, 64, 128 };

    int sum = sum_arr(cookies, cookies + ArSize);
    cout << "Total cookies eaten: " << sum << endl;
    sum = sum_arr(cookies, cookies + 3);
    cout << "First three eaters ate " << sum << " cookies. \n";
    sum = sum_arr(cookies + 4, cookies + 8);
    cout << "Last four eaters ate " << sum << " cookies. \n";

    return 0;
}

int sum_arr(const int *begin, const int *end)
{
    const int *pt;
    int total = 0;
    for (pt = begin; pt != end; pt++)
    {
        total = total + *pt;
    }
    return total;
}
显示结果如下
Total cookies eaten: 255
First three eaters ate 7 cookies.
Last four eaters ate 240 cookies.

程序清单7.9 strgfun.cpp
#include <iostream>

using namespace std;

int c_in_str(const char *str, char ch);

int main()
{
    char mmm[15] = "minimum";
    const char *wail = "ululate";
    int ms = c_in_str(mmm, 'm');
    int us = c_in_str(wail, 'u');
    cout << ms << " m characters in " << mmm << endl;
    cout << us << " u characters in " << wail << endl;

    return 0;
}

int c_in_str(const char *str, char ch)
{
    int count = 0;
    while (*str)
    {
        if (*str == ch)
        {
            count++;
        }
        str++;
    }
    return count;
}
显示结果如下
3 m characters in minimum
2 u characters in ululate

程序清单7.10 strgback.cpp
#include <iostream>

using namespace std;

char *buildstr(char c, int n);

int main()
{
    char ch;
    cout << "Enter a character: ";
    cin.get(ch);
    while (cin.get() != '\n')
    {
        continue;
    }
    cout << "Enter an integer: ";
    int times = 0;
    if ( ! (cin >> times) || times <= 0)
    {
        return 0;
    }
    char *ps = buildstr(ch, times);
    cout << ps << endl;
    delete [] ps;
    ps = buildstr('+', 20);
    cout << ps << endl;
    delete [] ps;

    return 0;
}

char *buildstr(char c, int n)
{
    char *pstr = new char[n + 1];
    pstr[n] = '\0';
    while (n-- > 0)
    {
        pstr[n] = c;
    }
    return pstr;
}
显示结果如下
Enter a character: c
Enter an integer: 5
ccccc
++++++++++++++++++++

程序清单7.11 travel.cpp
#include <iostream>

using namespace std;

const int Mins_per_hr = 60;

struct travel_time
{
    int hours;
    int mins;
};

travel_time sum(travel_time t1, travel_time t2);
void show_time(travel_time t);

int main()
{

    travel_time day1 = { 5, 45 };
    travel_time day2 = { 4, 55 };
    travel_time trip = sum(day1, day2);
    cout << "Two-day total: ";
    show_time(trip);
    travel_time day3 = { 4, 32 };
    cout << "Three-day total: ";
    show_time(sum(trip, day3));

    return 0;
}

travel_time sum(travel_time t1, travel_time t2)
{
    travel_time total;
    total.mins = (t1.mins + t2.mins) % Mins_per_hr;
    total.hours = t1.hours + t2.hours + (t1.mins + t2.mins) / Mins_per_hr;
    return total;
}

void show_time(travel_time t)
{
    cout << t.hours << " hours, " << t.mins << " minutes\n";
}
显示结果如下
Two-day total: 10 hours, 40 minutes
Three-day total: 15 hours, 12 minutes

程序清单7.12 strctfun.cpp
#include <iostream>
#include <cmath>

using namespace std;

struct polar
{
    double distance;
    double angle;
};

struct rect
{
    double x;
    double y;
};

polar rect_to_polar(rect xypos);
void show_polar(polar dapos);

int main()
{
    rect rplace;
    polar pplace;
    cout << "Enter the x and y values: ";
    while ( (cin >> rplace.x) && (cin >> rplace.y) )
    {
        pplace = rect_to_polar(rplace);
        show_polar(pplace);
        cout << "Enter the x and y values (q to quit) : ";
    }
    cout << "Done.\n";

    return 0;
}

polar rect_to_polar(rect xypos)
{
    polar answer;
    answer.distance = sqrt(xypos.x * xypos.x + xypos.y * xypos.y);
    answer.angle = atan2(xypos.y, xypos.x);
    return answer;
}

void show_polar(polar dapos)
{
    const double Rad_to_deg = 57.29577951;
    cout << "distance = " << dapos.distance << ", angle = " << dapos.angle *Rad_to_deg << " degrees\n";
}
显示结果如下
Enter the x and y values: 3 3
distance = 4.24264, angle = 45 degrees
Enter the x and y values (q to quit) : q
Done.

程序清单7.13 strctptr.cpp
#include <iostream>
#include <cmath>

using namespace std;

struct polar
{
    double distance;
    double angle;
};

struct rect
{
    double x;
    double y;
};

void rect_to_polar(const rect *pxy, polar *pda);
void show_polar(const polar *pda);

int main()
{
    rect rplace;
    polar pplace;
    cout << "Enter the x and y values: ";
    while ( (cin >> rplace.x) && (cin >> rplace.y) )
    {
        rect_to_polar(&rplace, &pplace);
        show_polar(&pplace);
        cout << "Enter the x and y values (q to quit) : ";
    }
    cout << "Done.\n";

    return 0;
}

void show_polar(const polar *pda)
{
    const double Rad_to_deg = 57.29577951;
    cout << "distance = " << pda->distance << ", angle = " << pda->angle *Rad_to_deg << " degrees\n";
}

void rect_to_polar(const rect *pxy, polar *pda)
{
    pda->distance = sqrt( (pxy->x) * (pxy->x) + (pxy->y) * (pxy->y) );
    pda->angle = atan2(pxy->y, pxy->x);
}
显示结果如下
Enter the x and y values: 3 3
distance = 4.24264, angle = 45 degrees
Enter the x and y values (q to quit) : 6 6
distance = 8.48528, angle = 45 degrees
Enter the x and y values (q to quit) : q
Done.

程序清单7.14 topfive.cpp
#include <iostream>
#include <string>

using namespace std;

const int SIZE = 5;

void display(const string sa[], int n);

int main()
{
    string list[SIZE];
    cout << "Enter your " << SIZE << " favorite astronomical sights:\n";

    for (int i = 0; i < SIZE; i++)
    {
        cout << i + 1 << " : ";
        getline(cin, list[i], '\n');
    }
    cout << "Your list:\n";
    display(list, SIZE);

    return 0;
}

void display(const string sa[], int n)
{
    for (int i = 0; i < n; i++)
    {
        cout << i + 1 << " : " << sa[i] << endl;
    }
}
显示结果如下
Enter your 5 favorite astronomical sights:
1 : Peter Smith
2 : Mike Pence
3 : Hello World
4 : Apple
5 : Orange
Your list:
1 : Peter Smith
2 : Mike Pence
3 : Hello World
4 : Apple
5 : Orange

程序清单7.15 arrobj.cpp
#include <iostream>
#include <array> 
#include <string> 

using namespace std;

const int Seasons = 4;

const array<string, Seasons> Snames =
{ 
	"Spring", "Summer", "Fall", "Winter" 
};

void fill(array<double, Seasons> * pa);
void show(array<double, Seasons> & da);

int main()
{
	array<double, Seasons> expenses;
	fill(&expenses);
	show(expenses);

	return 0;
}

void fill(array<double, Seasons> * pa)
{
	for (int i = 0; i < Seasons; i++)
	{
		 cout << "Enter " << Snames[i] << " expenses: ";
		 cin >> (*pa)[i];
	}
}

void show(array<double, Seasons> & da)
{
	double total = 0.0;
	cout << "\nEXPENSES\n";
	for (int i = 0; i < Seasons; i++)
	{
		 cout << Snames[i] << ": $" << da[i] << endl;
		 total += da[i];
	}
	cout << "Total Expenses: $" << total << endl;
}
显示结果如下
Enter Spring expenses: 10000
Enter Summer expenses: 20000
Enter Fall expenses: 30000
Enter Winter expenses: 40000

EXPENSES
Spring: $10000
Summer: $20000
Fall: $30000
Winter: $40000
Total Expenses: $100000

程序清单7.16 recur.cpp
#include <iostream>

using namespace std;

void countdown(int n);

int main()
{
    countdown(4);

    return 0;
}

void countdown(int n)
{
    cout << "Counting down ... " << n << endl;
    if (n > 0)
    {
        countdown(n - 1);
    }
    cout << n << " end!\n";
}
显示结果如下
Counting down ... 4
Counting down ... 3
Counting down ... 2
Counting down ... 1
Counting down ... 0
0 end!
1 end!
2 end!
3 end!
4 end!

程序清单7.17 ruler.cpp
#include <iostream>

using namespace std;

const int Len = 66;
const int Divs = 6;

void subdivide(char ar[], int low, int high, int level);

int main()
{

    char ruler[Len];
    int i;
    for (i = 1; i < Len - 2; i++)
    {
        ruler[i] = ' ';
    }
    ruler[Len - 1] = '\0';
    int max = Len - 2;
    int min = 0;
    ruler[min] = ruler[max] = '|';
    cout << ruler << endl;
    for (i = 1; i <= Divs; i++)
    {
        subdivide(ruler, min, max, i);
        cout << ruler << endl;
        for (int j = 1; j < Len - 2; j++)
        {
            ruler[j] = ' ';
        }
    }

    return 0;
}

void subdivide(char ar[], int low, int high, int level)
{
    if (level == 0)
    {
        return;
    }
    int mid = (high + low) / 2;
    ar[mid] = '|';
    subdivide(ar, low, mid, level - 1);
    subdivide(ar, mid, high, level - 1);
}
显示结果如下
|                                                               |
|                               |                               |
|               |               |               |               |
|       |       |       |       |       |       |       |       |
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

程序清单7.18 fun_ptr.cpp
#include <iostream>

using namespace std;

double betsy(int);
double pam(int);
void estimate(int lines, double (*pf) (int));

int main()
{
    int code;
    cout << "How many lines of code do you need? ";
    cin >> code;
    cout << "Here's Betsy's estimate:\n";
    estimate(code, betsy);
    cout << "Here's Pam's estimate:\n";
    estimate(code, pam);

    return 0;
}

double betsy(int Ins)
{
    return 0.05 * Ins;
}

double pam(int Ins)
{
    return 0.03 * Ins + 0.0004 * Ins * Ins;
}

void estimate(int lines, double (*pf)(int))
{
    cout << lines << " lines will take " << (*pf)(lines) << " hour(s)\n";
}
显示结果如下
How many lines of code do you need? 8
Here's Betsy's estimate:
8 lines will take 0.4 hour(s)
Here's Pam's estimate:
8 lines will take 0.2656 hour(s)

程序清单7.19 arfupt.cpp
#include <iostream>

using namespace std;

const double *f1(const double ar[], int n);
const double *f2(const double[], int);
const double *f3(const double *, int);

int main()
{
    double av[3] = { 1112.3, 1542.6, 2227.9 };
    const double *(*p1) (const double *, int) = f1;
    auto p2 = f2;

    cout << "Using pointers to functions:\n";
    cout << " Address Value\n";
    cout << (*p1) (av, 3) << " : " << *(*p1) (av, 3) << endl;
    cout << p2(av, 3) << " : " << *p2(av, 3) << endl;

    const double *(*pa[3])(const double *, int) = { f1, f2, f3 };
    auto pb = pa;

    cout << "\nUsing an array of pointers to functions:\n";
    cout << " Address          Value\n";
    for (int i = 0; i < 3; i++)
    {
        cout << pa[i](av, 3) << " : " << *pa[i](av, 3) << endl;
    }

    cout << "\nUsing a pointer to a pointer to a function: \n";
    cout << " Address         Value\n";
    for (int i = 0; i < 3; i++)
    {
        cout << pb[i](av, 3) << " : " << *pb[i](av, 3) << endl;
    }

    cout << "\nUsing pointers to an array of pointers:\n";
    cout << " Address         Value\n";
    auto pc = &pa;
    cout << (*pc)[0](av, 3) << " : " << *(*pc)[0](av, 3) << endl;

    const double *(*(*pd)[3]) (const double *, int) = &pa;
    const double *pdb = (*pd)[1](av, 3);
    cout << pdb << " : " << *pdb << endl;
    cout << (*(*pd)[2]) (av, 3) << " : " << * (*(*pd)[2]) (av, 3) << endl;

    return 0;
}

const double *f1(const double *ar, int n)
{
    return ar;
}

const double *f2(const double ar[], int n)
{
    return ar + 1;
}

const double *f3(const double ar[], int n)
{
    return ar + 2;
}
显示结果如下
Using pointers to functions:
 Address Value
0x7ffdfe6686e0 : 1112.3
0x7ffdfe6686e8 : 1542.6

Using an array of pointers to functions:
 Address          Value
0x7ffdfe6686e0 : 1112.3
0x7ffdfe6686e8 : 1542.6
0x7ffdfe6686f0 : 2227.9

Using a pointer to a pointer to a function:
 Address         Value
0x7ffdfe6686e0 : 1112.3
0x7ffdfe6686e8 : 1542.6
0x7ffdfe6686f0 : 2227.9

Using pointers to an array of pointers:
 Address         Value
0x7ffdfe6686e0 : 1112.3
0x7ffdfe6686e8 : 1542.6
0x7ffdfe6686f0 : 2227.9

7.11 总结
函数是C++的编程模块。要使用函数，必须提供函数定义和函数原型。
函数定义是实现函数功能的代码；函数原型描述了函数的接口：传递给函数的值的数目和种类以及函数的返回类型。
函数调用使得程序将参数传递给函数，并执行函数的代码。
在默认情况下，C++函数按值传递参数。这意味着函数定义中的形参是新的变量，它们被初始化为函数调用所提供的值。
因此，C++函数通过使用拷贝，保护了原始数据的完整性。
C++将数组名参数视为数组第一个元素的地址。从技术上讲，这仍然是按值传递的，
因为指针是原始地址的拷贝，但函数将使用指针来访问原始数组的内容。
当且仅当声明函数的形参时，下面两个声明才是等价的：
typeName arr []
typeName * arr
这两个声明都表明arr是指向typeName的指针；但在编写函数代码时，可以像使用数组名那样使用arr来访问元素：arr[i]。
即使在传递指针时，也可以将形参声明为const指针，来保护原始数据的完整性。
由于传递数据的地址时，并不会传输有关数组长度的信息，因此通常将数组长度作为独立的参数来传递。
另外，也可传递两个指针（其中一个指向数组开头，另一个指向数组末尾的下一个元素），以指定一个范围，就像STL使用的算法一样。
C++提供了3种表示C风格字符串的方法：字符数组、字符串常量和字符串指针。它们的类型都是char *，因此被作为char*类型参数传递给函数。
C++使用空值字符（0）来结束字符串，因此字符串函数检测空值字符来确定字符串的结尾。
C++还提供了string类，用于表示字符串。函数可以接受string对象作为参数以及将string对象作为返回值。
string类的方法size可用于判断其存储的字符串的长度。
C++处理结构的方式与基本类型完全相同，这意味着可以按值传递结构；并将其用作函数返回类型。
然而，如果结构非常大，，则传递结构指针的效率将更高，同时函数能够使用原始数据。这些考虑因素也适用于类对象。
C++函数可以是递归的，也就是说，函数代码中可以包括对函数本身的调用。
C++函数名与函数地址的作用相同。通过将函数指针作为参数，可以传递要调用的函数的名称。
7.12 复习题
1.使用函数的3个步骤是什么？
定义函数、提供原型、调用函数

2.请创建与下面的描述匹配的函数原型。
a.igor没有参数，且没有返回值。
b.tofu接受一个int参数，并返回一个float。
c.mpg接受两个double参数，并返回一个double。
d.summation将long数组名和数组长度作为参数，并返回一个long值。
e.doctor接受一个字符串参数（不能修改该字符串），并返回一个double值。
f.ofcourse将boss结构作为参数，不返回值。
g.plot将map结构的指针作为参数，并返回一个字符串。

a.void igor (void);
b.float tofu (int n);
c.double mpg (double miles, double gallons);
d.long summation (long array[], int size);
e.double doctor (const char * str);
f.void ofcourse (boss dude);
g.char * plot (map * pmap);

3.编写一个接受3个参数的函数：int数组名、数组长度和一个int值，并将数组的所有元素都设置为该int值。
void set_array (int arr[], int size, int value)
{
    for (int i = 0; i < size; i++)
    {
        arr[i] = value;
    }
}

4.编写一个接受3个参数的函数：指向数组区间中第一个元素的指针、
指向数组区间最后一个元素后面的指针以及一个int值，并将数组中的每个元素都设置为该int值。
void set_array(int *begin, int *end, int value)
{
    for(int *pt = begin; pt != end; pt++)
    {
        *pt = value;
    }
}

5.编写将double数组名和数组长度作为参数，并返回该数组中最大值的函数。该函数不应修改数组的内容。
double find_max (const double arr[], int size)
{
    double max;
    if (size < 1)
    {
        cout << "Invalid array size : " << size << endl;
        cout << "Returning 0\n";
        return 0;
    }
    max = arr[0];
    for (int i = 1;i < size; i++)
    {
        if (arr[i] > max)
        {
            max = arr[i];
        }
    }
    return max;
}

6.为什么不对类型为基本类型的函数参数使用const限定符？
基本类型的函数参数是按值传递，原始数据不会被修改。

7.C++程序可使用哪3种C风格字符串格式？
字符数组，带双引号的字符串字面量，指向字符串第一个字符的字符指针


8.编写一个函数，其原型如下：
int replace (char * str, char c1, char c2);
该函数将字符串中所有的c1都替换为c2，并返回替换次数。
int replace (char * str, char c1, char c2)
{
    int count = 0;
    while (*str)
    {
        if (*str == c1)
        {
            *str = c2;
            count++;
        }
        str++;
    }
    return count;
}

9.表达式*"pizza"的含义是什么？"taco"[2]呢？
由于C++将"pizza"解释为其第一个元素的地址，因此使用*运算符将得到第一个元素的值，即字符p。
亩于C+将"taco"解释为第一个元素的地址；因此它将"taco"[2]解释为第三个元素的值，即字符c。

10.C++允许按值传递结构，也允许传递结构的地址。如果glitz是一个结构变量，如何按值传递它？
如何传递它的地址？这两种方法有何利弊？
要按值传递它，只要传递结构名glitz即可。要传递它的地址，需要使用地址运算符&glitz。
按值传递将自动保护原始数据，但这是以时间和内存为代价的。
按地址传递可节省时间和内存，但不能保护原始数据，除非对函数参数使用了const限定符。
另外，按值传递意味着可以使用常规的结构成员表示法，但传递指针则必须使用间接成员运算符。

11.函数judge的返回类型为int，它将这样一个函数的地址作为参数：
将const char指针作为参数，并返回一个int值。请编写judge函数的原型。
int judge ( int (*pf) (const char * ) );

12，假设有如下结构声明：
struct applicant
{
    char name[30];
    int credit_ratings[3];
};
a.编写一个函数，它将applicant结构作为参数，并显示该结构的内容。
b.编写一个函数，它将applicant结构的地址作为参数，并显示该参数指向的结构的内容。

a.
void display (applicant ap)
{
    cout << ap.name << endl;
    for (int i = 0 ;i < 3; i++)
    {
        cout << ap.credit_ratings[i] << endl;
    }
}
b.
void show(const applicant * pa)
{
    cout << pa->name << endl;
    for (int i = 0; i < 3; i++)
    {
        cout << pa->credit_ratings[i] << endl;
    }
}

13.假设函数f1()和f2()的原型如下：
void f1 (applicant * a);
const char * f2 (const applicant *a1, const applicant * a2);
请将p1和p2分别声明为指向f1和f2的指针；将ap声明为一个数组，它包含5个类型与p1相同的指针；
将pa声明为一个指针，它指向的数组包含10个类型与p2相同的指针。使用typedef来帮助完成这项工作。
typedef void (*p_f1) (applicant *);
typedef const char * (*p_f2) (const applicant *, const applicant *);
p_f1 p1 = f1;
p_f2 p2 = f2;
p_f1 ap[5];
p_f2 (*pa)[10];

7.13 编程练习
1.编写一个程序，不断要求用户输入两个数，直到其中的一个为0。
对于每两个数，程序将使用一个函数来计算它们的调和平均数，并将结果返回给main，而后者将报告结果。
调和平均数指的是倒数平均值的倒数。
1/ ( ( (1/x) + (1/y) ) / 2 ) = 2 / ( (1/x) + (1/y) ) = (2 * x * y) / (x + y) 

#include <iostream>

double average_harmonic(double x, double y);

int main()
{
    double x = 0;
    double y = 0;
    std::cout << "Enter x and y: " << std::endl;

    while ( (std::cin >> x) && x != 0 && (std::cin >> y) && y != 0)
    {
        std::cout << "The average harmonic " << x << " and " << y << " = " << average_harmonic(x, y) << std::endl;
        std::cout << "Enter x and y: " << std::endl;
    }

    return 0;
}
double average_harmonic(double x, double y)
{
    return  (2.0 * x * y) / (x + y);
}
显示结果如下
Enter x and y:
2 5
The average harmonic 2 and 5 = 2.85714
Enter x and y:
0 0

2.编写一个程序，要求用户输入最多10个高尔夫成绩，并将其存储在一个数组中。
程序允许用户提早结束输入，并在一行上显示所有成绩，然后报告平均成绩。
请使用3个数组处理函数来分别进行输入、计算和显示平均成绩。
#include <iostream>

int enter_result(int golf_result[], int array_size);
double avg_result(int golf_result[], int array_size);
void output_result(double avg, int golf_result[], int array_size);

int main()
{
    const int SIZE = 10;

    int golf_result[SIZE] = { 0 };

    int num = enter_result(golf_result, SIZE);
    double avg = avg_result(golf_result, num);
    output_result(avg, golf_result, num);

    return 0;
}
int enter_result(int golf_result[], int array_size)
{
    std::cout << "Enter the results (1-10) or q to exit : " << std::endl;
    int i;
    for (i = 0; i < array_size; i++)
    {
        std::cout << "Result " << i + 1 << " : ";
        int enter = 0;

        if ( ! (std::cin >> enter) )
        {
            std::cin.clear();

            while (std::cin.get() != '\n')
            {
                continue;
            }
            std::cout << "Invalid Input.\n" << std::endl;
            break;
        }
        else if (enter < 1 || enter > 10)
        {
            while (std::cin.get() != '\n')
            {
                continue;
            }
            std::cout << "Input not in 1-10.\n" << std::endl;
            break;
        }
        golf_result[i] = enter;
    }
    return i;
}

double avg_result(int golf_result[], int array_size)
{
    double avg = 0;
    double summ = 0;

    for (int i = 0; i < array_size; i++)
    {
        summ += golf_result[i];
    }
    avg = summ / array_size;

    return avg;
}

void output_result(double avg, int golf_result[], int array_size)
{
    std::cout << "Result = ";

    for (int i = 0; i < array_size; i++)
    {
        std::cout << golf_result[i] << " ";
    }
    std::cout << "AVG = " << avg << std::endl;
}
显示结果如下
Enter the results (1-10) or q to exit :
Result 1 : 3
Result 2 : 4
Result 3 : 5
Result 4 : 6
Result 5 : 7
Result 6 : 8
Result 7 : 9
Result 8 : 1
Result 9 : 2
Result 10 : q
Invalid Input.

Result = 3 4 5 6 7 8 9 1 2 AVG = 5


3.下面是一个结构声明：
struct box
{
    char maker[128];
    double height;
    double width;
    double length;
    double volume;
};
a.编写一个函数，按值传递box结构，并显示每个成员的值
b.编写一个函数，传递box结构的地址，并将volume成员设置为其他三维长度的乘积。
c.编写一个使用这两个函数的简单程序。
#include <iostream>

using namespace std;

struct box
{
    char maker[128];
    double height;
    double width;
    double length;
    double volume;
};

void print_box(const box details);
void set_volume(box *address);

int main()
{
    box details;
    cout << "Enter maker : ";
    cin.get(details.maker, 128);

    while (cin.get() != '\n')
    {
        continue;
    }

    cout << "Enter height : ";
    cin >> details.height;
    cout << "Enter width : ";
    cin >> details.width;
    cout << "Enter length : ";
    cin >> details.length;

    set_volume(&details);
    cout << '\n';
    print_box(details);

    return 0;
}

void print_box(const box details)
{
    cout << "maker = " << details.maker << endl;
    cout << "height = " << details.height << endl;
    cout << "width = " << details.width << endl;
    cout << "length = " << details.length << endl;
    cout << "volume = " << details.volume << endl;
}

void set_volume(box *address)
{
    address->volume = (address->height) * (address->length) * (address->width);
}
显示结果如下
Enter maker : Hello World
Enter height : 3
Enter width : 5
Enter length : 7

maker = Hello World
height = 3
width = 5
length = 7
volume = 105

4.许多州的彩票发行机构都使用如程序清单7.4所示的简单彩票玩法的变体。
在这些玩法中，玩家从一组被称为域号码（field number）的号码中选择几个。
例如，可以从域号码1~47中选择5个号码；还可以从第二个区间（如1~27）选择一个号码（称为特选号码），
要赢得头奖，必须正确猜中所有的号码。中头奖的儿率是选中所有域号码的几率与选中特选号码几率的乘积。
例如，在这个例子中，中头奖的几率是从47个号码中正确选取5个号码的几率与
从27个号码中正确选择1个号码的几率的乘积。
请修改程序清单7.4，以计算中得这种彩票头奖的几率。
#include <iostream>

long double probability(int numbers, int picks);

int main()
{
    double total1 = 0;
    double total2 = 0;
    double choices = 0;

    std::cout << "Enter the total number of choices on the game card and\n";
    std::cout << "the number of picks allowed and\n";
    std::cout << "the total number of choices on the second game field\n";

    while ( (std::cin >> total1) && (std::cin >> choices) && choices <= total1 && (std::cin >> total2) )
    {
        std::cout << "You have one chance in " << probability(total1, choices) * probability(total2, 1) << " of winning.\n";
        std::cout << "Next two numbers (q to quit) : ";
    }
    std::cout << "Done.\n";

    return 0;
}
long double probability(int numbers, int picks)
{
    long double result = 1.0;
    long double n;
    int p;
    for (n = numbers, p = picks; p > 0; n--, p--)
    {
        result = result * n / p;
    }
    return result;
}
显示结果如下
Enter the total number of choices on the game card and
the number of picks allowed and
the total number of choices on the second game field
47 5 27
You have one chance in 4.14164e+07 of winning.
Next two numbers (q to quit) : q
Done.

5.定义一个递归函数，接受一个整数参数，并返回该参数的阶乘。
在程序中对该函数进行测试，程序使用循环让用户输入不同的值，程序将报告这些值的阶乘。
#include <iostream>

long double factorial(int number);

int main()
{
    std::cout << "Enter any integer (0 - N): ";
    int number = 0;
    std::cin >> number;

    long double Result = factorial(number);
    std::cout << number << "! = " << Result << std::endl;

    return 0;
}

long double factorial(int number)
{
    return number > 0 ? number * factorial(number - 1) : 1;
}
显示结果如下
Enter any integer (0 - N): 5
5! = 120

Enter any integer (0 - N): 6
6! = 720

Enter any integer (0 - N): 7
7! = 5040

Enter any integer (0 - N): 8
8! = 40320

Enter any integer (0 - N): 9
9! = 362880

6.编写一个程序，它使用下列函数fill_array将一个double数组的名称和长度作为参数。
它提示用户输入double值，并将这些值存储到数组中。
当数组被填满或用户输入了非数字时，输入将停止，并返回实际输入了多少个数字。
show_array将一个double数组的名称和长度作为参数，并显示该数组的内容
reverse_array将一个double数组的名称和长度作为参数，并将存储在数组中的值的顺序反转。
程序将使用这些函数来填充数组，然后显示数组；反转数组，然后显示数组；
反转数组中除第一个和最后一个元素之外的所有元素，然后显示数组。
#include <iostream>

const int SIZE = 10;

int fill_array(double massiv[], int size);
void Show_array(double massiv[], int size);
void Reverse_array(double massiv[], int size);

int main()
{
    double massiv[SIZE] = { 0 };

    int num = fill_array(massiv, SIZE);
    Show_array(massiv, num);
    std::cout << '\n';
    Reverse_array(massiv, num);
    Show_array(massiv, num);
    std::cout << '\n';
    Reverse_array(massiv + 1, num - 2);
    Show_array(massiv, num);

    return 0;
}

int fill_array(double massiv[], int size)
{
    double number;
    int i;
    for (i = 0; i < size; i++)
    {
        std::cout << "Value " << i + 1 << " = ";
        number = 0;
        if ( ! (std::cin >> number) )
        {
            break;
        }
        massiv[i] = number;
    }
    return i;
}

void Reverse_array(double massiv[], int size)
{
    for (int i = 0, j = size - 1; i < j; i++, j--)
    {
        double temp = 0;

        temp = massiv[i];
        massiv[i] = massiv[j];
        massiv[j] = temp;
    }
}

void Show_array(double massiv[], int size)
{
    for (int i = 0; i < size; i++)
    {
        std::cout << massiv[i] << std::endl;
    }
}
显示结果如下
Value 1 = 1.1
Value 2 = 2.2
Value 3 = 3.3
Value 4 = 4.4
Value 5 = 5.5
Value 6 = 6.6
Value 7 = 7.7
Value 8 = q
1.1
2.2
3.3
4.4
5.5
6.6
7.7

7.7
6.6
5.5
4.4
3.3
2.2
1.1

7.7
2.2
3.3
4.4
5.5
6.6
1.1

7.修改程序清单7.7中的3个数组处理函数，使之使用两个指针参数来表示区间。
fill_array函数不返回实际读取了多少个数字，而是返回一个指针，该指针指向最后被填充的位置；
其他的函数可以将该指针作为第二个参数，以标识数据结尾。
#include <iostream>

const int Max = 5;

double *fill_array(double *arrBegin, double *arrEnd);
void show_array(double *arrBegin, double *arrEnd);
void revalue(double r, double *arrBegin, double *arrEnd);

int main()
{
    double properties[Max];
    double *size = fill_array(properties, properties + Max);
    show_array(properties, size);

    if ( (size - properties) > 0)
    {
        std::cout << "Enter revaluation factor: ";
        double factor = 0.0;
        while (!(std::cin >> factor))
        {
            std::cin.clear();
            while (std::cin.get() != '\n')
            {
                continue;
            }
            std::cout << "Bad input; Please enter a number: ";
        }
        revalue(factor, properties, size);
        show_array(properties, size);
    }
    std::cout << "Done.\n";

    return 0;
}

double *fill_array(double *arrBegin, double *arrEnd)
{
    double temp;
    int i = 0;
    double *pt = nullptr;

    for (pt = arrBegin; pt != arrEnd; pt++)
    {
        std::cout << "Enter value #" << (++i) << ": ";
        temp = 0;
        if ( ! (std::cin >> temp) )
        {
            std::cin.clear();
            while (std::cin.get() != '\n')
            {
                continue;
            }
            std::cout << "Bad input; input process terminated.\n";
            break;
        }
        else if (temp < 0)
        {
            while (std::cin.get() != '\n')
            {
                continue;
            }
            std::cout << "input process terminated.\n";
            break;
        }
        *pt = temp;
    }
    return pt;
}

void show_array(double *arrBegin, double *arrEnd)
{
    int i = 0;
    for (double *pt = arrBegin; pt != arrEnd; pt++)
    {
        std::cout << "Property #" << (++i) << ": $";
        std::cout << *pt << std::endl;
    }
}

void revalue(double factor, double *arrBegin, double *arrEnd)
{
    for (double *pt = arrBegin; pt != arrEnd; pt++)
    {
        *pt *= factor;
    }
}
显示结果如下
Enter value #1: 10000
Enter value #2: 20000
Enter value #3: 30000
Enter value #4: q
Bad input; input process terminated.
Property #1: $10000
Property #2: $20000
Property #3: $30000
Enter revaluation factor: 0.6
Property #1: $6000
Property #2: $12000
Property #3: $18000
Done.

8.在不使用array类的情况下完成程序清单7.15所做的工作。
编写两个这样的版本：
a.使用const char*数组存储表示季度名称的字符串，并使用double数组存储开支
#include <iostream>
#include <array>
#include <string>

const int Seasons = 4;

const char *Snames[Seasons] =
{
    "Spring", "Summer", "Fall", "Winter"
};

void fill(double expenses[], const int Seasons);
void show(double expenses[], const int Seasons);

int main()
{
    double expenses[Seasons];
    fill(expenses, Seasons);
    show(expenses, Seasons);

    return 0;
}

void fill(double expenses[], const int Seasons)
{
    for (int i = 0; i < Seasons; i++)
    {
        std::cout << "Enter " << Snames[i] << " expenses: ";
        std::cin >> expenses[i];
    }
}

void show(double expenses[], const int Seasons)
{
    double total = 0.0;
    std::cout << "\nEXPENSES\n";
    for (int i = 0; i < Seasons; i++)
    {
        std::cout << Snames[i] << ": $" << expenses[i] << std::endl;
        total += expenses[i];
    }
    std::cout << "Total Expenses: $" << total << std::endl;
}
显示结果如下
Enter Spring expenses: 10000
Enter Summer expenses: 20000
Enter Fall expenses: 15000
Enter Winter expenses: 23000

EXPENSES
Spring: $10000
Summer: $20000
Fall: $15000
Winter: $23000
Total Expenses: $68000

b.使用const char*数组存储表示季度名称的字符串，并使用一个结构，该结构只有一个成员：用于存储开支的double数组。
#include <iostream>
#include <array>
#include <string>

const int Seasons = 4;

const char Snames[][8] =
{
    "Spring", "Summer", "Fall", "Winter"
};

struct Expenses
{
    double expenses[Seasons];
};

void fill(const char Snames[][8], Expenses *exp);
void show(const char Snames[][8], Expenses *exp);

int main()
{
    Expenses exp;
    fill(Snames, &exp);
    show(Snames, &exp);

    return 0;
}

void fill(const char Snames[][8], Expenses *exp)
{
    for (int i = 0; i < Seasons; i++)
    {
        std::cout << "Enter " << Snames[i] << " expenses: ";
        std::cin >> exp->expenses[i];
    }
}

void show(const char Snames[][8], Expenses *exp)
{
    double total = 0.0;
    std::cout << "\nEXPENSES\n";
    for (int i = 0; i < Seasons; i++)
    {
        std::cout << Snames[i] << ": $" << exp->expenses[i] <<  std::endl;
        total += exp->expenses[i];
    }
    std::cout << "Total Expenses: $" << total <<  std::endl;
}
显示结果如下
Enter Spring expenses: 10000
Enter Summer expenses: 20000
Enter Fall expenses: 50000
Enter Winter expenses: 10000

EXPENSES
Spring: $10000
Summer: $20000
Fall: $50000
Winter: $10000
Total Expenses: $90000

9.这个练习让您编写处理数组和结构的函数。下面是程序的框架，请提供其中描述的函数，以完成该程序。
#include <iostream>
#include <cstring>

const int SLEN = 128;

struct student
{
    char fullname[SLEN] = {0};
    char hobby[SLEN];
    int ooplevel;
};

int getinfo(student pa[], int n);
void display1(student st);
void display2(const student *ps);
void display3(const student pa[], int n);

int main()
{
    std::cout << "Enter class size: ";
    int class_size = 0;
    std::cin >> class_size;

    while (std::cin.get() != '\n')
    {
        continue;
    }

    student *ptr_stu = new student[class_size];
    int entered = getinfo(ptr_stu, class_size);

    for (int i = 0; i < entered; i++)
    {
        display1(ptr_stu[i]);
        display2(&ptr_stu[i]);
    }
    display3(ptr_stu, entered);

    delete[] ptr_stu;
    std::cout << "Done.\n";

    return 0;
}

int getinfo(student pa[], int class_size)
{
    int enteredCount = 0;

    for (int i = 0; i < class_size; i++)
    {
        std::cout << "Student " << i + 1 << std::endl;
        std::cout << "Enter name: ";

        std::cin.getline(pa[i].fullname, SLEN);

        if (strlen(pa[i].fullname) != 0)
        {
            std::cout << "Enter hobby: ";
            std::cin.getline(pa[i].hobby, SLEN);

            std::cout << "Enter ooplevel: ";
            (std::cin >> pa[i].ooplevel).get();
        }
        else
        {
            break;
        }
        ++enteredCount;
        std::cout << std::endl;
    }
    return enteredCount;
}

void display1(student st)
{
    std::cout << "Name: ";
    std::cout << st.fullname << std::endl;
    std::cout << "Hobby: ";
    std::cout << st.hobby << std::endl;
    std::cout << "Ooplevel: ";
    std::cout << st.ooplevel << std::endl;
    std::cout << std::endl;
}

void display2(const student *ps)
{
    std::cout << "Name: ";
    std::cout << ps->fullname << std::endl;
    std::cout << "Hobby: ";
    std::cout << ps->hobby << std::endl;
    std::cout << "Ooplevel: ";
    std::cout << ps->ooplevel << std::endl;
    std::cout << std::endl;
}

void display3(const student pa[], int n)
{
    for (int i = 0; i < n; ++i)
    {
        std::cout << "Name: ";
        std::cout << pa[i].fullname << std::endl;
        std::cout << "Hobby: ";
        std::cout << pa[i].hobby << std::endl;
        std::cout << "Ooplevel: ";
        std::cout << pa[i].ooplevel << std::endl;
        std::cout << std::endl;
    }
}
显示结果如下
Enter class size: 6
Student 1
Enter name: Peter Smith
Enter hobby: abc
Enter ooplevel: 1

Student 2
Enter name: Mike Pence
Enter hobby: 123
Enter ooplevel: 2

Student 3
Enter name: Hello World
Enter hobby: efg
Enter ooplevel: 3

Student 4
Enter name:
Name: Peter Smith
Hobby: abc
Ooplevel: 1

Name: Peter Smith
Hobby: abc
Ooplevel: 1

Name: Mike Pence
Hobby: 123
Ooplevel: 2

Name: Mike Pence
Hobby: 123
Ooplevel: 2

Name: Hello World
Hobby: efg
Ooplevel: 3

Name: Hello World
Hobby: efg
Ooplevel: 3

Name: Peter Smith
Hobby: abc
Ooplevel: 1

Name: Mike Pence
Hobby: 123
Ooplevel: 2

Name: Hello World
Hobby: efg
Ooplevel: 3

Done.

10.设计一个名为calculate的函数，它接受两个double值和一个指向函数的指针，
而被指向的函数接受两个double参数，并返回一个double值。
calculate函数返回被指向的函数使用calculate的两个double参数计算得到的值。
请编写一个程序，该程序使用循环来让用户成对地输入数字。
对于每对数字，程序都使用calculate来调用add和至少一个其他的函数。
#include <iostream>

double Multiplication(double x, double y);
double Division(double x, double y);
double Subtraction(double x, double y);
double Addition(double x, double y);
double Calculate(double x, double y, double (*pf)(double x, double y));
void print_menu();

int main()
{
    print_menu();
    int menu = 0;
    while (std::cin >> menu)
    {
        double x = 0, y = 0;
        switch (menu)
        {
        case 1:
            std::cout << "Enter x and y : ";
            std::cin >> x >> y;
            std::cout << x << " * " << y << " = " << Calculate(x, y, Multiplication) << std::endl;
            break;
        case 2:
            std::cout << "Enter x and y : ";
            std::cin >> x >> y;
            std::cout << x << " / " << y << " = " << Calculate(x, y, Division) << std::endl;
            break;
        case 3:
            std::cout << "Enter x and y : ";
            std::cin >> x >> y;
            std::cout << x << " - " << y << " = " << Calculate(x, y, Subtraction) << std::endl;
            break;
        case 4:
            std::cout << "Enter x and y : ";
            std::cin >> x >> y;
            std::cout << x << " + " << y << " = " << Calculate(x, y, Addition) << std::endl;
            break;
        default:
            std::cout << "Invalid input" << std::endl;
            break;
        }
        print_menu();
        menu = 0;
    }

    return 0;
}

double Multiplication(double x, double y)
{
    return x * y;
}

double Division(double x, double y)
{
    return x / y;
}

double Subtraction(double x, double y)
{
    return x - y;
}

double Addition(double x, double y)
{
    return x + y;
}

double Calculate(double x, double y, double(*pf)(double x, double y))
{
    return (*pf)(x, y);
}

void print_menu()
{
    std::cout << "Choose the action of the calculator: " << std::endl;
    std::cout << "[1] - Multiplication: " << std::endl;
    std::cout << "[2] - Division: " << std::endl;
    std::cout << "[3] - Subtraction: " << std::endl;
    std::cout << "[4] - Addition: " << std::endl;
    std::cout << "[q] - Quit: " << std::endl;
}
显示结果如下
Choose the action of the calculator:
[1] - Multiplication:
[2] - Division:
[3] - Subtraction:
[4] - Addition:
[q] - Quit:
1
Enter x and y : 2 3
2 * 3 = 6
Choose the action of the calculator:
[1] - Multiplication:
[2] - Division:
[3] - Subtraction:
[4] - Addition:
[q] - Quit:
2
Enter x and y : 18 3
18 / 3 = 6
Choose the action of the calculator:
[1] - Multiplication:
[2] - Division:
[3] - Subtraction:
[4] - Addition:
[q] - Quit:
3
Enter x and y : 6 3
6 - 3 = 3
Choose the action of the calculator:
[1] - Multiplication:
[2] - Division:
[3] - Subtraction:
[4] - Addition:
[q] - Quit:
4
Enter x and y : 6 3
6 + 3 = 9
Choose the action of the calculator:
[1] - Multiplication:
[2] - Division:
[3] - Subtraction:
[4] - Addition:
[q] - Quit:
q

第8章 函数探幽
8.1 C++内联函数
8.2 引用变量
8.2.1 创建引用变量
8.2.2 将引用用作函数参数
8.2.3 引用的属性和特别之处
8.2.4 将引用用于结构
8.2.5 将引用用于类对象
8.2.6 对象、继承和引用
8.2.7 何时使用引用参数
8.3 默认参数
8.4 函数重载
8.4.1 重载示例
8.4.2 何时使用函数重载
8.5 函数模板
8.5.1 重载的模板
8.5.2 模板的局限性
8.5.3 显式具体化
8.5.4 实例化和具体化
8.5.5 编译器选择使用哪个函数版本
8.5.6 模板函数的发展
8.6 总结
8.7 复习题
8.8 编程练习
本章内容包括：
内联函数。
引用变量。
如何按引用传递函数参数。
默认参数。
函数重载。
函数模板。
函数模板具体化。
8.1 C++内联函数
内联函数是C++为提高程序运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。
常规函数调用使程序跳到另一个地址（函数的地址），并在函数结束时返回，需要额外的开销。
对于内联函数，程序无需跳到另一个位置处执行代码，再跳回来，编译器将使用内联函数的代码替换函数调用。
因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。
如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数代码的10个副本（参见图8.1）。
应有选择地使用内联函数。如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将只占整个过程的很小一部分。
如果代码执行时间很短且经常被调用，则内联调用就可以节省处理非内联调用的大部分时间。
在函数声明前加上关键字inline，在函数定义前加上关键字inline。
程序员请求将函数作为内联函数时，编译器并不一定会满足这种要求。
它可能认为该函数过大或注意到函数调用了自己（内联函数不能递归），因此不将其作为内联函数。
程序清单8.1 inline.cpp-
#include <iostream>

using namespace std;

inline double square(double x)
{
    return x * x;
}

int main()
{
    double a, b;
    double c = 13.0;
    a = square(5.0);
    b = square(4.5 + 7.5);
    cout << "a = " << a << ", b = " << b << "\n";
    cout << "c = " << c;
    cout << ", c squared = " << square(c++) << "\n";
    cout << "Now c = " << c << "\n";

    return 0;
}
显示结果如下
a = 25, b = 144
c = 13, c squared = 169
Now c = 14

8.2 引用变量
引用变量是已定义的变量的别名（另一个名称）。引用变量的主要用途是用作函数的形参。
通过将引用变量用作参数，函数将使用原始数据，而不是其副本。引用也为函数处理大型结构提供了一种非常方便的途径。
程序清单8.2 firstref.cpp
#include <iostream>

using namespace std;

int main()
{
    int rats = 101;
    int &rodents = rats;

    cout << "rats = " << rats;
    cout << ", rodents = " << rodents << endl;
    rodents++;
    cout << "rats = " << rats;
    cout << ", rodents = " << rodents << endl;

    cout << "rats address = " << &rats;
    cout << ", rodents address = " << &rodents << endl;

    return 0;
}
显示结果如下
rats = 101, rodents = 101
rats = 102, rodents = 102
rats address = 0x7ffcc6d73fec, rodents address = 0x7ffcc6d73fec

程序清单8.3 secref.cpp
#include <iostream>

using namespace std;

int main()
{
    int rats = 101;
    int &rodents = rats;
    cout << "rats = " << rats;
    cout << ", rodents = " << rodents << endl;
    cout << "rats address = " << &rats;
    cout << ", rodents address = " << &rodents << endl;

    int bunnies = 50;
    rodents = bunnies;
    cout << "bunnies = " << bunnies;
    cout << ", rats = " << rats;
    cout << ", rodents = " << rodents << endl;
    cout << "bunnies address = " << &bunnies;
    cout << ", rodents address = " << &rodents << endl;

    return 0;
}
显示结果如下
rats = 101, rodents = 101
rats address = 0x7fff8a427d58, rodents address = 0x7fff8a427d58
bunnies = 50, rats = 50, rodents = 50
bunnies address = 0x7fff8a427d5c, rodents address = 0x7fff8a427d58

程序清单8.4 swaps.cpp
#include <iostream>

using namespace std;

void swapr(int &a, int &b);
void swapp(int *p, int *q);
void swapv(int a, int b);

int main()
{
    int wallet1 = 300;
    int wallet2 = 350;
    cout << "walletl = $" << wallet1;
    cout << " wallet2 = $" << wallet2 << endl;

    cout << "Using references to swap contents:\n";
    swapr(wallet1, wallet2);
    cout << "walletl = $" << wallet1;
    cout << " wallet2 = $" << wallet2 << endl;

    cout << "Using pointers to swap contents again:\n";
    swapp(&wallet1, &wallet2);
    cout << "walletl = $" << wallet1;
    cout << " wallet2 = $" << wallet2 << endl;

    cout << "Trying to use passing by value:\n";
    swapv(wallet1, wallet2);
    cout << "walletl = $" << wallet1;
    cout << " wallet2 = $" << wallet2 << endl;

    return 0;
}

void swapr(int &a, int &b)
{
    int temp;
    temp = a;
    a = b;
    b = temp;
}

void swapp(int *p, int *q)
{
    int temp;
    temp = *p;
    *p = *q;
    *q = temp;
}

void swapv(int a, int b)
{
    int temp;
    temp = a;
    a = b;
    b = temp;
}
显示结果如下
walletl = $300 wallet2 = $350
Using references to swap contents:
walletl = $350 wallet2 = $300
Using pointers to swap contents again:
walletl = $300 wallet2 = $350
Trying to use passing by value:
walletl = $300 wallet2 = $350

程序清单8.5 cubes.cpp
#include <iostream>

using namespace std;

double cube(double a);
double refcube(double &ra);

int main()
{
    double x = 3.0;
    cout << cube(x) << " = cube of " << x << endl;
    cout << refcube(x) << " = cube of " << x << endl;

    return 0;
}
double cube(double a)
{
    a *= a * a;
    return a;
}

double refcube(double &ra)
{
    ra *= ra * ra;
    return ra;
}
显示结果如下
27 = cube of 3
27 = cube of 27

程序清单8.6 strc_ref.cpp
#include <iostream>
#include <string>

using namespace std;

struct free_throws
{
    string name;
    int made;
    int attempts;
    double percent;
};

void display(const free_throws &ft);
void set_pc(free_throws &ft);
free_throws &accumulate(free_throws &target, const free_throws &source);

int main()
{
    free_throws one = { "Ifelsa Branch", 13, 14 };
    free_throws two = { "Andor Knott", 10, 16 };
    free_throws three = { "Minnie Max", 7, 9 };
    free_throws four = { "Whily Looper", 5, 9 };
    free_throws five = { "Long Long", 6, 14 };
    free_throws team = { "Throwgoods", 0, 0 };

    free_throws dup;
    set_pc(one);
    display(one);
    accumulate(team, one);
    display(team);

    display(accumulate(team, two));
    accumulate(accumulate(team, three), four);
    display(team);

    dup = accumulate(team, five);
    cout << "Displaying team:\n";
    display(team);

    cout << "Displaying dup after assignment:\n";
    display(dup);
    set_pc(four);
    accumulate(dup, five) = four;

    cout << "Displaying dup after ill-advised assignment:\n";
    display(dup);

    return 0;
}

void display(const free_throws &ft)
{
    cout << "Name: " << ft.name << '\n';
    cout << "Made: " << ft.made << '\t';
    cout << "Attempts: " << ft.attempts << '\t';
    cout << "Percent: " << ft.percent << '\n';
}

void set_pc(free_throws &ft)
{
    if (ft.attempts != 0)
    {
        ft.percent = 100.0 * double(ft.made) / double(ft.attempts);
    }
    else
    {
        ft.percent = 0;
    }
}

free_throws &accumulate(free_throws &target, const free_throws &source)
{
    target.attempts += source.attempts;
    target.made += source.made;
    set_pc(target);
    return target;
}
显示结果如下
Name: Ifelsa Branch
Made: 13        Attempts: 14    Percent: 92.8571
Name: Throwgoods
Made: 13        Attempts: 14    Percent: 92.8571
Name: Throwgoods
Made: 23        Attempts: 30    Percent: 76.6667
Name: Throwgoods
Made: 35        Attempts: 48    Percent: 72.9167
Displaying team:
Name: Throwgoods
Made: 41        Attempts: 62    Percent: 66.129
Displaying dup after assignment:
Name: Throwgoods
Made: 41        Attempts: 62    Percent: 66.129
Displaying dup after ill-advised assignment:
Name: Whily Looper
Made: 5 Attempts: 9     Percent: 55.5556

程序清单8.7 strquote.cpp
#include <iostream>
#include <string>

using namespace std;

string version1(const string &si, const string &s2);
const string &version2(string &si, const string &s2);
const string version3(string &si, const string &s2);

int main()
{
    string input;
    string copy;
    string result;
    cout << "Enter a string: ";
    getline(cin, input, '\n');
    copy = input;
    cout << "Your string as entered: " << input << endl;
    result = version1(input, "***");
    cout << "Your string enhanced: " << result << endl;
    cout << "Your original string: " << input << endl;
    result = version2(input, "###");
    cout << "Your string enhanced: " << result << endl;
    cout << "Your original string: " << input << endl;
    cout << "Resetting original string.\n";
    input = copy;
    result = version3(input, "@@@");
    cout << "Your string enhanced: " << result << endl;
    cout << "Your original string: " << input << endl;

    return 0;
}

string version1(const string &si, const string &s2)
{
    string temp;
    temp = s2 + si + s2;
    return temp;
}

const string &version2(string &si, const string &s2)
{
    si = s2 + si + s2;
    return si;
}

const string version3(string &si, const string &s2)
{
    string temp;
    temp = s2 + si + s2;
    return temp;
}
显示结果如下
Enter a string: Hello World
Your string as entered: Hello World
Your string enhanced: ***Hello World***
Your original string: Hello World
Your string enhanced: ###Hello World###
Your original string: ###Hello World###
Resetting original string.
Your string enhanced: @@@Hello World@@@
Your original string: Hello World

程序清单8.8 filefunc.cpp
#include <iostream>
#include <fstream>
#include <cstdlib>

using namespace std;

const int LIMIT = 5;

void file_it(ostream &os, double fo, const double fe[], int n);

int main()
{
    ofstream fout;
    const char *fn = "filefun_data.txt";
    fout.open(fn);
    if (!fout.is_open())
    {
        cout << "Can't open " << fn << "\n";
        exit(EXIT_FAILURE);
    }
    double objective;
    cout << "Enter the focal length of your telescope objective in mm: ";
    cin >> objective;
    double eps[LIMIT];
    cout << "Enter the focal lengths, in mm, of " << LIMIT << " eyepieces:\n";
    for (int i = 0; i < LIMIT; i++)
    {
        cout << "Eyepiece #" << i + 1 << ": ";
        cin >> eps[i];
    }
    file_it(fout, objective, eps, LIMIT);
    file_it(cout, objective, eps, LIMIT);
    cout << "Done.\n";

    return 0;
}

void file_it(ostream &os, double fo, const double fe[], int n)
{
    ios_base::fmtflags initial;
    initial = os.setf(ios_base::fixed);
    os.precision(0);
    os << "Focal length of objective: " << fo << " mm\n";
    os.setf(ios::showpoint);
    os.precision(1);
    os.width(12);
    os << "f.l. eyepiece";
    os.width(15);
    os << "magnification" << endl;
    for (int i = 0; i < n; i++)
    {
        os.width(12);
        os << fe[i];
        os.width(15);
        os << int(fo / fe[i] + 0.5) << endl;
    }
    os.setf(initial);
}
显示结果如下
Enter the focal length of your telescope objective in mm: 1800
Enter the focal lengths, in mm, of 5 eyepieces:
Eyepiece #1: 30
Eyepiece #2: 19
Eyepiece #3: 14
Eyepiece #4: 8.8
Eyepiece #5: 7.5
Focal length of objective: 1800 mm
f.l. eyepiece  magnification
        30.0             60
        19.0             95
        14.0            129
         8.8            205
         7.5            240
Done.

cat filefun_data.txt
Focal length of objective: 1800 mm
f.l. eyepiece  magnification
        30.0             60
        19.0             95
        14.0            129
         8.8            205
         7.5            240

8.3默认参数
默认参数指的是当函数调用中省略了实参时自动使用的一个值。
程序清单8.9 left.cpp
#include <iostream>

using namespace std;

const int ArSize = 128;

char *left(const char *str, int n = 1);

int main()
{
    char sample[ArSize];
    cout << "Enter a string:\n";
    cin.getline(sample, ArSize);
    char *ps = left(sample, 4);
    cout << ps << endl;
    delete[] ps;
    ps = left(sample);
    cout << ps << endl;
    delete[] ps;

    return 0;
}
char *left(const char *str, int n)
{
    if (n < 1)
    {
        n = 1;
    }
    char *p = new char[n + 1];
    int i;
    for (i = 0; i < n && str[i]; i++)
    {
        p[i] = str[i];
    }
    while (i <= n)
    {
        p[i++] = '\0';
    }
    return p;
}
显示结果如下
Enter a string:
Hello, World!
Hell
H

8.4 函数重载
默认参数让您能够使用不同数目的参数调用同一个函数，而函数多态（函数重载）让您能够使用多个同名的函数。
可以通过函数重载来设计一系列函数，它们完成相同的工作，但使用不同的参数列表。
C++根据函数的参数列表（参数数目和参数类型）确定要使用的重载函数版本。
程序清单8.10 leftover.cpp
#include <iostream>

using namespace std;

long long left(long long num, int ct);
char *left(const char *str, int n = 1);

int main()
{
    const char *trip = "abcdefghijkl";
    long long n = 123456789876;
    int i;
    char *temp;
    for (i = 1; i < 10; i++)
    {
        cout << left(n, i) << endl;
        temp = left(trip, i);
        cout << temp << endl;
        delete[] temp;
    }

    return 0;
}

long long left(long long num, int ct)
{
    if (ct <= 0 || num <= 0)
    {
        return 0;
    }
    int digits = 1;
    long long n = num;
    while (n /= 10)
    {
        digits++;
    }
    if (digits > ct)
    {
        ct = digits - ct;
        while (ct--)
        {
            num /= 10;
        }
        return num;
    }
    else
    {
        return num;
    }
}
char *left(const char *str, int n)
{
    if (n < 1)
    {
        n = 1;
    }
    char *p = new char[n + 1];
    int i;
    for (i = 0; i < n && str[i]; i++)
    {
        p[i] = str[i];
    }
    while (i <= n)
    {
        p[i++] = '\0';
    }
    return p;
}
显示结果如下
1
a
12
ab
123
abc
1234
abcd
12345
abcde
123456
abcdef
1234567
abcdefg
12345678
abcdefgh
123456789
abcdefghi

8.5函数模板
函数模板使用泛型来定义函数，其中的泛型可用具体的类型替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。
由于模板允许以泛型（而不是具体类型）的方式编写程序，因此有时也被称为泛型编程。
程序清单8.11 funtemp.cpp
#include <iostream>

using namespace std;

template <typename T>
void Swap(T &a, T &b);

int main()
{
    int i = 10;
    int j = 20;
    cout << "i, j = " << i << ", " << j << "\n";
    cout << "Using compiler-generated int swapper:\n";
    Swap(i, j);
    cout << "Now i, j = " << i << ", " << j << "\n";
    double x = 24.5;
    double y = 81.7;
    cout << "x, y = " << x << ", " << y << "\n";
    cout << "Using compiler-generated double swapper:\n";
    Swap(x, y);
    cout << "Now x, y = " << x << ", " << y << "\n";

    return 0;
}
template <typename T>
void Swap(T &a, T &b)
{
    T temp;
    temp = a;
    a = b;
    b = temp;
}
显示结果如下
i, j = 10, 20
Using compiler-generated int swapper:
Now i, j = 20, 10
x, y = 24.5, 81.7
Using compiler-generated double swapper:
Now x, y = 81.7, 24.5

程序清单8.12 twotemps.cpp
#include <iostream>

using namespace std;

const int Lim = 8;

template <typename T>
void Swap(T &a, T &b);
template <typename T>
void Swap(T a[], T b[], int n);
void Show(int a[], int n);

int main()
{
    int i = 10, j = 20;
    cout << "i, j = " << i << ", " << j << "\n";
    cout << "Using compiler-generated int swapper:\n";
    Swap(i, j);
    cout << "Now i, j = " << i << ", " << j << "\n";
    int d1[Lim] = { 0, 7, 0, 4, 1, 7, 7, 6 };
    int d2[Lim] = { 0, 7, 2, 0, 1, 9, 6, 9 };
    cout << "Original arrays:\n";
    Show(d1, Lim);
    Show(d2, Lim);
    Swap(d1, d2, Lim);
    cout << "Swapped arrays:\n";
    Show(d1, Lim);
    Show(d2, Lim);

    return 0;
}
template <typename T>
void Swap(T &a, T &b)
{
    T temp;
    temp = a;
    a = b;
    b = temp;
}
template <typename T>
void Swap(T a[], T b[], int n)
{
    T temp;
    for (int i = 0; i < n; i++)
    {
        temp = a[i];
        a[i] = b[i];
        b[i] = temp;
    }
}
void Show(int a[], int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        if (i != 0)
        {
            cout << ", ";
        }
        cout << a[i];
    }

    cout << endl;
}
显示结果如下
i, j = 10, 20
Using compiler-generated int swapper:
Now i, j = 20, 10
Original arrays:
0, 7, 0, 4, 1, 7, 7, 6
0, 7, 2, 0, 1, 9, 6, 9
Swapped arrays:
0, 7, 2, 0, 1, 9, 6, 9
0, 7, 0, 4, 1, 7, 7, 6

对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本。
显式具体化的原型和定义应以template <>开头，并通过名称来指出类型。
具体化优先于常规模板，而非模板函数优先于具体化和常规模板。
// non-template function prototype
void Swap(job &, job &);
// template prototype
template <typename T>
void Swap(T &, T &);
// explicit specialization for the job type
template <> void Swap<job> (job &, job &);
Swap<job>中的<job>是可选的，因为函数的参数类型表明，这是job的一个具体化。
因此，该原型也可以这样编写：
template <> void Swap (job &, job &);

程序清单8.13 twoswap.cpp
#include <iostream>

using namespace std;

struct job
{
    char name[128];
    double salary;
    int floor;
};

template <typename T>
void Swap(T &a, T &b);

template <> void Swap<job> (job &j1, job &j2);
void Show(job &j);

int main()
{
    cout.precision(2);
    cout.setf(ios::fixed, ios::floatfield);
    int i = 10, j = 20;
    cout << "i, j = " << i << ", " << j << "\n";
    cout << "Using compiler-generated int swapper \n";
    Swap(i, j);
    cout << "Now i, j = " << i << ", " << j << " \n";
    job sue = { "Susan Yaffee", 73000.60, 7 };
    job sidney = { "Sidney Taffee", 78060.72, 9 };
    cout << "Before job swapping \n";
    Show(sue);
    Show(sidney);
    Swap(sue, sidney);
    cout << "After job swapping \n";
    Show(sue);
    Show(sidney);

    return 0;
}
template <typename T>
void Swap(T &a, T &b)
{
    T temp;
    temp = a;
    a = b;
    b = temp;
}
template <> void Swap<job> (job &j1, job &j2)
{
    double t1;
    int t2;
    t1 = j1.salary;
    j1.salary = j2.salary;
    j2.salary = t1;
    t2 = j1.floor;
    j1.floor = j2.floor;
    j2.floor = t2;
}
void Show(job &j)
{
    cout << j.name << " : $" << j.salary << " on floor " << j.floor << endl;
}
显示结果如下
i, j = 10, 20
Using compiler-generated int swapper
Now i, j = 20, 10
Before job swapping
Susan Yaffee : $73000.60 on floor 7
Sidney Taffee : $78060.72 on floor 9
After job swapping
Susan Yaffee : $78060.72 on floor 9
Sidney Taffee : $73000.60 on floor 7

8.5.4 实例化和具体化
在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。
编译器使用模板为特定类型生成函数定义时，得到的是模板实例（instantiation）。
这种实例化方式被称为隐式实例化（implicit instantiation）。
C++还允许显式实例化（explici instantiation），用<>符号指示类型，并在声明前加上关键字template。
template void Swap<int> (int &, int &);   //explicit instantiation
编译器看到上述声明后，将使用Swap模板生成一个使用int类型的实例。
也就是说，该声明的意思是"使用Swap模板生成int类型的函数定义"。
与显式实例化不同的是，显式具体化使用下面两个等价的声明之一
template <> void Swap<int> (int &, int &);   // explicit specialization
tempiate <> void Swap (int &, int &);   // explicit specialization
这些声明的意思是"不要使用Swap模板来生成函数定义，而应使用专门为int类型显式地定义的函数定义"。
这些原型必须有自己的函数定义。显式具体化声明在关键字template后包含<>，而显式实例化没有。
警告：试图在同一个文件（或转换单元）中使用同一种类型的显式实例和显式具体化将出错
还可通过在程序中使用函数来创建显式实例化。例如，请看下面的代码
template <typename T>
T Add (T a, T b)
{
    return a + b;
}
...
int m = 6;
double x = 10.2;
cout << Add<double> (x, m) << endl;   // explicit instantiation
这里的模板与函数调用Add (x, m)不匹配，因为该模板要求两个函数参数的类型相同。
但通过使用Add<double> (x, m) 可强制为double类型实例化，并将参数m强制转换为double类型，
以便与函数Add<double> (double, double)的第二个参数匹配。
如果对Swap做类似的处理，结果将如何呢？
int m =5;
double x=14.3;
Swap<double> (m, x);
这将为类型double生成一个显式实例化。
不幸的是，这些代码不管用，因为第一个形参的类型为double&，不能指向int变量m。
隐式实例化、显式实例化和显式具体化统称为具体化（specialization），
它们的相同之处在于，它们表示的都是使用具体类型的函数定义，而不是通用描述。
引入显式实例化后，必须在声明中使用前缀template和template <>，以区分显式实例化和显式具体化。
通常，功能越多，语法规则也越多。下面的代码片段总结了这些概念：
template <class T>
void Swap (T &, T &):   //template prototype
template <> void Swap<job> (job &, job &);   // explicit specialization for job
int main (void)
{
    template void Swap<char> (char &, char &);   //explicit instantiation for char
    short a, b;
    ...
    Swap (a, b);   //implicit template instantiation for short
    job n, m;
    ...
    Swap (n, m);   //use explicit specialization for job
    char g, h;
    ...
    Swap (g, h);   //use explicit template instantiation for char
    ...
}
编译器看到char的显式实例化后，将使用模板定义来生成Swap的char版本。
对于其他Swap调用，编译器根据函数调用中实际使用的参数，生成相应的版本。
例如，当编译器看到函数调用Swap (a, b)后，将生成Swap的short版本，因为两个参数的类型都是short。
当编译器看到Swap (n, m)后，将使用为job类型提供的独立定义（显式具体化）。
当编译器看到Swap (g, h)后，将使用处理显式实例化时生成的模板具体化。
8.5.5 编译器选择使用哪个函数版本
对于函数重载、函数模板和函数模板重载，C++需要（且有）一个定义良好的策略，
来决定为函数调用使用哪一个函数定义，尤其是有多个参数时。
这个过程称为重载解析（overloading resolution），我们先大致了解一下这个过程是如何进行的。
第1步：创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数
第2步：使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，
为此有一个隐式转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。
第3步：确定是否有最佳的可行函数。如果有，则使用它，否则该函数调用出错。
编译器必须确定哪个可行函数是最佳的。它查看为使函数调用参数与可行的候选函数的参数匹配所需要进行的转换。
通常，从最佳到最差的顺序如下所述。
1.完全匹配，但常规函数优先于模板。
2.提升转换（例如，char和short自动转换为int，float自动转换为double）。
3.标准转换（例如，int转换为char，long转换为double）。
4.用户定义的转换，如类声明中定义的转换。
通常，有两个或两个以上函数完全匹配是一种错误，但这一规则有两个例外。显然，我们需要对这一点做更深入的探讨。
完全匹配和最佳匹配
进行完全匹配时，C++允许某些"无关紧要的转换"。表8.1列出了这些转换，Type表示任意类型。
从实参                                              到形参
Type                                                Type &
Type &                                            Type
Type []                                             Type *
Type (argument-list)                      Type (*) (argument-list)
Type                                                 const Type
Type                                                 volatile Type
Type *                                               const Type *
Type *                                               volatile Type *
Type (argument-list)意味着用作实参的函数名与用作形参的函数指针只要返回类型和参数列表相同，就是匹配的。
如果有多个匹配的原型，则编译器将无法完成重载解析过程；
如果没有最佳的可行函数，则编译器将生成一条错误消息。
然而，有时候，即使两个函数都完全匹配，仍可完成重载解析。
首先，指向非const数据的指针和引用优先与非const指针和引用参数匹配。
一个完全匹配优于另一个的另一种情况是，其中一个是非模板函数，而另一个不是。
在这种情况下，非模板函数将优先于模板函数（包括显式具体化）。
如果两个完全匹配的函数都是模板函数，则较具体的模板函数优先。
例如，这意味着显式具体化将优于使用模板隐式生成的具体化。
术语“最具体（most specialized）”并不一定意味着显式具体化，而是指编译器推断使用哪种类型时执行的转换最少。
用于找出最具体的模板的规则被称为函数模板的部分排序规则（partial ordering rules）。
程序清单8.14 tempover.cpp
#include <iostream>

using namespace std;

struct debts
{
    char name[128];
    double amount;
};
template <typename T>
void ShowArray(T arr[], int n);
template <typename T>
void ShowArray(T *arr[], int n);

int main()
{
    int things[6] = { 13, 31, 103, 301, 310, 130 };
    debts mr_E[3] =
    {
        { "Ima Wolfe", 2400.0 },
        { "Ura Foxe", 1300.0 },
        { "Iby Stout", 1800.0 }
    };

    double *pd[3];
    for (int i = 0; i < 3; i++)
    {
        pd[i] = & (mr_E[i].amount);
    }
    cout << "Listing Mr. E's counts of things :\n";
    ShowArray(things, 6);
    cout << "Listing Mr. E's debts:\n";
    ShowArray(pd, 3);

    return 0;
}

template <typename T>
void ShowArray(T arr[], int n)
{
    cout << "template A\n";
    for (int i = 0; i < n; i++)
    {
        cout << arr[i] << ' ';
    }
    cout << endl;
}

template <typename T>
void ShowArray(T *arr[], int n)
{
    cout << "template B\n";
    for (int i = 0; i < n; i++)
    {
        cout << *arr[i] << ' ';
    }
    cout << endl;
}
显示结果如下
Listing Mr. E's counts of things :
template A
13 31 103 301 310 130
Listing Mr. E's debts:
template B
2400 1300 1800

程序清单8.15 tempchoices.cpp
#include <iostream>

using namespace std;

template<typename T>
T lesser(T a, T b)
{
    cout << "template lesser\n";
    return a < b ? a : b;
}

int lesser(int a, int b)
{
    a = a < 0 ? -a : a;
    b = b < 0 ? -b : b;
    return a < b ? a : b;
}

int main()
{
    int m = 20;
    int n = -30;
    double x = 15.5;
    double y = 25.9;
    cout << lesser(m, n) << endl;
    cout << lesser(x, y) << endl;
    cout << lesser<>(m, n) << endl;
    cout << lesser<int>(x, y) << endl;

    return 0;
}
显示结果如下
20
template lesser
15.5
template lesser
-30
template lesser
15

lesser<> (m, n)中的<>指出，编译器应选择模板函数，而不是非模板函数；编译器注意到实参的类型为int，因此使用int替代T对模板进行实例化。
lesser<int>(x, y) 这条语句要求进行显式实例化（使用int替代T），将使用显式实例化得到的函数。
x和y的值将被强制转换为int，该函数返回一个int值，这就是程序显示15而不是15.5的原因所在。
8.5.6模板函数的发展
C++11新增的关键字decltype
int x;
decltype(x) y;   //make y the same type as x
给decltype提供的参数可以是表达式
decltype(x+y) xpy;   //make xpy the same type as x +y
хpy = x +y;

decltype(x+ y) xpy = x +y;
decltype比这些示例演示的要复杂些。为确定类型，编译器必须遍历一个核对表。
假设有如下声明decltype (expression) var;
则核对表的简化版如下：
第一步：如果expression是一个没有用括号括起的标识符，则var的类型与该标识符的类型相同，包括const等限定符。
第二步：如果expression是一个函数调用，则var的类型与函数的返回类型相同。
编译器通过查看函数的原型来获悉返回类型，而无需实际调用函数。
第三步：如果expression是一个左值，则var为指向其类型的引用。
要进入第三步，expression不能是未用括号括起的标识符，可以是用括号括起的标识符。
第四步：如果前面的条件都不满足，则var的类型与expression的类型相同。
如果需要多次声明，可结合使用typedef和decltype。
3.另一种函数声明语法（C+11后置返回类型）
double h (int x, float y);
使用新增的语法可编写成这样：
auto h (int x, float y) -> double;
这将返回类型移到了参数声明后面。
-> double被称为后置返回类型（trailing return type），其中auto是个占位符，
表示后置返回类型提供的类型，这是C++给auto新增的一种角色。
这种语法也可用于函数定义：
auto h (int x, float y) -> double
{
    ...
}
template <typename T1, typename T2>
auto Add (T1 x, T2 y) -> decltype(x + y)
{
    return x + y;
}
现在，decltype在参数声明后面，因此x和y位于作用域内，可以使用它们。
8.6总结
通过将inline关键字用于函数定义，并在首次调用该函数前提供其函数定义，可以使得C++编译器将该函数视为内联函数。
也就是说，编译器不是让程序跳到独立的代码段，以执行函数，而是用相应的代码替换函数调用。
只有在函数很短时才能采用内联方式。
引用变量是一种伪装指针，它允许为变量创建别名（另一个名称），
引用变量主要被用作处理结构和类对象的函数的参数，通常，被声明为特定类型引用的标识符只能指向这种类型的数据；
然而，如果一个类（如ofstream）是从另一个类（如ostream）派生出来的，则基类引用可以指向派生类对象。
C++原型让您能够定义参数的默认值。如果函数调用省略了相应的参数，则程序将使用默认值；
如果函数调用提供了参数值，则程序将使用这个值（而不是默认值），只能在参数列表中从右到左提供默认参数。
因此，如果为某个参数提供了默认值，则必须为该参数右边所有的参数提供默认值。
函数的特征标是其参数列表。程序员可以定义两个同名函数，只要其特征标不同。
这被称为函数多态或函数重载。通常，通过重载函数来为不同的数据类型提供相同的服务。
函数模板自动完成重载函数的过程。只需使用泛型和具体算法来定义函数，
编译器将为程序中使用的特定参数类型生成正确的函数定义。
3.7 复习题
1.哪种函数适合定义为内联函数？
函数体很小，非递归，而且经常使用的函数

2.假设song函数的原型如下：
void song (const char * name, int times);
a.如何修改原型，使times的默认值为1？
void song (const char * name, int times = 1);
b.函数定义需要做哪些修改？
函数定义不需要做修改
c.能否为name提供默认值"O.My Papa"？
如果为name提供默认值，则也必须为times提供默认值
void song (const char * name = "O.My Papa", int times = 1);

3.编写iquote的重载版本，显示其用双引号括起的参数。
编写3个版本：一个用于int参数，一个用于double参数，另一个用于char *参数。
#include <iostream>

using namespace std;

void iquote( int n)
{
    cout << "\"" << n << "\"";
}
void iquote(double x)
{
    cout << '"' << x << '"';
}
void iquote(const char * str)
{
    cout << "\"" << str << "\"";
}
4.下面是一个结构模板：
struct box
{
    char maker [128];
    double height;
    double width;
    double length;
    double volume;
};
a.请编写一个函数，它将box结构的引用作为形参，并显示每个成员的值。
void show_box(const box & container)
{
    cout << "Made by " << container.maker << end;
    cout << "Height = " << container.height << end;
    cout << "Width = " << container.width << end;
    cout << "Length = " << container.length << end;
    cout << "Volume = " << container.volume << end;

}
b.请编写一个函数，它将box结构的引用作为形参，并将volume成责设置为其他3边的乘积为。
void set_volume (box & container)
{
    container.volume = (container.height) * (contianer.width) * (container.length);
}
5.为让函数fill和show使用引用参数，需要对程序清单7.15做哪些修改？
#include <iostream>
#include <array>
#include <string>

using namespace std;

const int Seasons = 4;

const array<string, Seasons> Snames =
{
    "Spring", "Summer", "Fall", "Winter"
};

void fill(array<double, Seasons> &pa);
void show(const array<double, Seasons> &da);

int main()
{
    array<double, Seasons> expenses;
    fill(expenses);
    show(expenses);

    return 0;
}

void fill(array<double, Seasons> & pa)
{
    for (int i = 0; i < Seasons; i++)
    {
        cout << "Enter " << Snames[i] << " expenses: ";
        cin >> pa[i];
    }
}

void show(const array<double, Seasons> &da)
{
    double total = 0.0;
    cout << "\nEXPENSES\n";
    for (int i = 0; i < Seasons; i++)
    {
        cout << Snames[i] << ": $" << da[i] << endl;
        total += da[i];
    }
    cout << "Total Expenses: $" << total << endl;
}

6.指出下面每个目标是否可以使用默认参数或函数重载完成，或者这两种方法都无法完成，并提供合适的原型。
a.mass (density, volume)返回密度为density、体积为volume的物体的质量，
而mass（denstity）返回密度为density、体积为1.0立方米的物体的质量。这些值的类型都为double。
double mass (double d, double v = 1.0);
函数重载
double mass (double d, double v);
double mass (double d);

b.repeat (10, "I'm OK")将指定的字符串显示10次，而repeat ("But you're kind of stupid")将指定的字符串显示5次。
不可以使用默认参数，因为默认参数要求从右到左提供默认值
函数重载
void repeat (int times, const char * str);
void repeat (const char * str);

c.average (3, 6)返回两个int参数的平均值（int类型），而average (3.0, 6.0)返回两个double值的平均值（double 类型）。
函数重载
int average (int a, int b);
double average (double x, double y);

d.mangle ("Im glad to meet you")根据是将值赋给char变量还是char *变量，
分别返回字符I和指向字符串"I'm mad to gleet you"的指针。
都不可以，因为函数重载是根据函数名和函数的参数列表来确定

7.编写返回两个参数中较大值的函数模板。
template <typename T>
T& max(T & a, T & b)
{
    return a > b ? a : b;
}

8.给定复习题7的模板和复习题4的box结构，提供一个模板具体化，它接受两个box参数，并返回体积较大的一个。
template <> box & max<box> (box & b1, box & b2)
{
    return b1.volume > b2.volume ? b1 : b2;
}

9.在下述代码（假定这些代码是一个完整程序的一部分）中；v1、v2、v3、v4和v5分别是哪种类型？
int g(int x);

float m = 5.5f;
float & rm = m;
decltype(m) v1 = m;   float类型
decltype(rm) v2 = m;   float &类型
decltype((m)) v3 = m;   float &类型
decltype(g(100)) v4;   int类型
decltype(2.0 * m) v5;   double类型

8.8编程练习
1.编写通常接受一个参数（字符串的地址），并打印该字符串的函数。
然而，如果提供了第三个参数（int类型），且该参数不为0，则该函数打印字符串的次数将为该函数被调用的次数
（注意，字符串的打印次数不等于第三个参数的值，而等于函数被调用的次数）。
#include <iostream>
#include <string>

using namespace std;

void print_text(const string *pt, int flag = 0);

int main()
{
    string word = "Long Live Rock-n-roll!";
    print_text(&word);
    word = "Let There Be Rock!";
    print_text(&word);
    print_text(&word);
    word = "Be Quick Or Be Dead!";
    print_text(&word, 1);

    return 0;
}
void print_text(const string *pt, int flag)
{
    static int count = 0;

    if (flag != 0)
    {
        for (int i = 0; i < count; i++)
        {
            std::cout << *pt << std::endl;
        }
    }
    else
    {
        std::cout << *pt << std::endl;
    }
    ++count;
}
显示结果如下
Long Live Rock-n-roll!
Let There Be Rock!
Let There Be Rock!
Be Quick Or Be Dead!
Be Quick Or Be Dead!
Be Quick Or Be Dead!

2.CandyBar结构包含3个成员。第一个成员存储candy bar的品牌名称；第一个成员存储candy bar的重量（可能有小数）；
第三个成员存储 candy bar的热量（整数）。请编写一个程序，它使用一个这样的函数，
即将CandyBar的引用、char指针，double和int作为参数，并用最后3个值设置相应的结构成员。
最后3个参数的默认值分别为"Millennium Munch"，2.85和350。
另外，该程序还包含一个以CandyBar的引用为参数，并显示结构内容的函数，请尽可能使用const。
#include <iostream>
#include <string>

struct CandyBar
{
    std::string CandeName;
    double weight;
    double calories;
};

void fill_struct(CandyBar &Munch, const char *name = "Millennium Munch",
                 double weight = 2.85, int calories = 350);
void Display_struct(const CandyBar &Munch);

int main()
{
    CandyBar box_1;
    CandyBar box_2;
    CandyBar box_3;

    fill_struct(box_1);
    Display_struct(box_1);

    fill_struct(box_2, "KitKat", 11.5, 400);
    Display_struct(box_2);

    fill_struct(box_3, "Pocky", 7.3, 210);
    Display_struct(box_3);

    return 0;
}

void fill_struct(CandyBar &Munch, const char *name, double weight, int calories)
{
    Munch.CandeName = name;
    Munch.weight = weight;
    Munch.calories = calories;
}

void Display_struct(const CandyBar &Munch)
{
    std::cout << "Name: ";
    std::cout << Munch.CandeName << std::endl;
    std::cout << "Weight: ";
    std::cout << Munch.weight << std::endl;
    std::cout << "Calories: ";
    std::cout << Munch.calories << std::endl;
    std::cout << std::endl;
}
显示结果如下
Name: Millennium Munch
Weight: 2.85
Calories: 350

Name: KitKat
Weight: 11.5
Calories: 400

Name: Pocky
Weight: 7.3
Calories: 210

3.编写一个函数，它接受一个指向string对象的引用作为参数，并将该string对象的内容转换为大写。
然后编写一个程序，它通过使用一个循环让您能够用不同的输入来测试这个函数。
#include <iostream>
#include <algorithm>
#include <string>
#include <cctype>

void uppercase(std::string &text);

int main()
{
    std::cout << "Enter a string (q to quit) : ";
    std::string text;

    while (std::getline(std::cin, text, '\n') && text != "q")
    {
        uppercase(text);
        std::cout << text << std::endl;
        std::cout << "Next string (q to quit) : ";
    }
    std::cout << "Done." << std::endl;

    return 0;
}

void uppercase(std::string &text)
{
    std::transform(text.begin(), text.end(), text.begin(), ::toupper);
}
::toupper表示强制使用C版本的toupper函数
::tolower表示强制使用C版本的tolower函数

显示结果如下
Enter a string (q to quit) : Hello, World!
HELLO, WORLD!
Next string (q to quit) : q
Done.

#include <iostream>
#include <string>
#include <cctype>
#include <algorithm>

using namespace std;

int main()
{
    string s = "Hello World";
    cout << s << endl;
    transform(s.begin(),s.end(),s.begin(),::toupper);
    cout << s << endl;
    transform(s.begin(),s.end(),s.begin(),::tolower);
    cout << s << endl;

    return 0;
}
Hello World
HELLO WORLD
hello world

::toupper表示强制使用C版本的toupper函数
::tolower表示强制使用C版本的tolower函数
4.下面是一个程序框架
请提供其中描述的函数和原型，从而完成该程序。注意，应有两个show函数，每个都使用默认参数。
请尽可能使用cosnt参数。set使用new分配足够的空间来存储指定的字符串。
#include <iostream>
#include <cstring>

struct stringy
{
    char *str;
    int ct;
};

void set(stringy &beany, const char *testing);
void show(const char *string, int size = 1);
void show(const stringy &beany, int size = 1);
void clear_memory(stringy &beany);

int main()
{
    stringy beany;
    char testing[] = "Reality isn't what it used to be.";
    set(beany, testing);
    show(beany);
    show(beany, 2);
    clear_memory(beany);

    testing[0] = 'D';
    testing[1] = 'u';

    show(testing);
    show(testing, 3);
    show("Done!");

    return 0;
}

void set(stringy &beany, const char *testing)
{
    beany.ct = strlen(testing);
    beany.str = new char[beany.ct + 1];
    strcpy(beany.str, testing);
}

void show(const char *string, int size)
{
    for (int i = 0; i < size; i++)
    {
        std::cout << string << std::endl;
    }
}

void show(const stringy &beany, int size)
{
    for (int i = 0; i < size; i++)
    {
        std::cout << beany.str << std::endl;
    }
}

void clear_memory(stringy &beany)
{
    delete [] beany.str;
}
显示结果如下
Reality isn't what it used to be.
Reality isn't what it used to be.
Reality isn't what it used to be.
Duality isn't what it used to be.
Duality isn't what it used to be.
Duality isn't what it used to be.
Duality isn't what it used to be.
Done!

5.编写模板函数max5，它将一个包含5个T类型元素的数组作为参数，并返回数组中最大的元素。
在一个程序中使用该函数，将T替换为一个包含5个int值的数组和一个包含5个dowble值的数组，以测试该函数。
#include <iostream>

template <typename T>
T max5(T *massiv);

int main()
{
    double double_massiv[5] = { 0.1, 1.2, 3.45, 2.2, 1.3 };
    std::cout << "Maximum value of the array double = ";
    std::cout << max5(double_massiv) << std::endl;

    int int_massiv[5] = { 2, 5, 8, 66, 231 };
    std::cout << "Maximum value of array int = ";
    std::cout << max5(int_massiv) << std::endl;

    return 0;
}

template <typename T>
T max5(T *massiv)
{
    T max = massiv[0];
    for (int i = 0; i < 5; i++)
    {
        if (massiv[i] > max)
        {
            max = massiv[i];
        }
    }
    return max;
}
显示结果如下
Maximum value of the array double = 3.45
Maximum value of array int = 231

6.编写模板函数maxn，它将由一个T类型元素组成的数组和一个表示数组元素数目的整数作为参数，
并返回数组中最大的元素。编写程序对它进行测试，该程序使用一个包含6个int元素的数组和
一个包含4个double元素的数组来调用该函数。
程序还包含一个具体化，它将char指针数组和数组中的指针数量作为参数，并返回最长的字符串的地址。
如果有多个这样的字符串，则返回其中第一个字符串的地址。使用由5个字符串指针组成的数组来测试该具体化。
#include <iostream>
#include <cstring>

const int SIZE_INT = 6;
const int SIZE_DOUBLE = 4;
const int SIZE_CHAR = 5;

template <typename T>
T maxn(T *massiv, int size);

const char *maxn(const char *massiv[], int size);

int main()
{
    int massiv_int[SIZE_INT] = { 1, 2, 2, 4, 52 };
    double massiv_double[SIZE_DOUBLE] = { 0.1, 2.4, 0.4, 33.1 };
    const char *words[SIZE_CHAR] = { "Ham", "Bread", "Sandwich", "Asparagus", "Chocolate" };

    std::cout << "The maximum value of the array INT = ";
    std::cout << maxn(massiv_int, SIZE_INT) << std::endl;
    std::cout << "The maximum value of the array DOUBLE = ";
    std::cout << maxn(massiv_double, SIZE_DOUBLE) << std::endl;
    std::cout << "The maximum value of the array CHAR = ";
    std::cout << maxn(words, SIZE_CHAR) << std::endl;

    return 0;
}

template <typename T>
T maxn(T *massiv, int size)
{
    T max = massiv[0];
    for (int i = 0; i < size; i++)
    {
        if (massiv[i] > max)
        {
            max = massiv[i];
        }
    }
    return max;
}

const char *maxn(const char *massiv[], int size)
{
    const char *max_length_string = &(massiv[0][0]);
    int max_characters = strlen(massiv[0]);
    int next = 0;

    for (int i = 0; i < size; i++)
    {
        next = strlen(massiv[i]);
        if (next > max_characters)
        {
            max_characters = next;
            max_length_string = &(massiv[i][0]);
        }
    }
    return max_length_string;
}
显示结果如下
The maximum value of the array INT = 52
The maximum value of the array DOUBLE = 33.1
The maximum value of the array CHAR = Asparagus

7.修改程序清单8.14，使其使用两个名为SumArray的模板函数来返回数组元素的总和，而不是显示数组的内容。
程序应显示thing的总和以及所有debt的总和。
#include <iostream>

struct debts
{
    char name[128];
    double amount;
};

template <typename T>
T SumArray(T arr[], int n);
template <typename T>
T SumArray(T *arr[], int n);
template <typename T>
void ShowArray(T arr[], int n);
template <typename T>
void ShowArray(T *arr[], int n);

int main()
{
    int things[6] = { 13, 31, 103, 301, 310, 130 };
    debts mr_E[3] =
    {
        { "Ima Wolfe", 2400.0 },
        { "Ura Foxe", 1300.0 },
        { "Iby Stout", 1800.0 }
    };

    double *pd[3];

    for (int i = 0; i < 3; i++)
    {
        pd[i] = &(mr_E[i].amount);
    }

    std::cout << "Listing Mr. E's counts of things :\n";
    ShowArray(things, 6);
    std::cout << "Total = " << SumArray(things, 6) << std::endl;

    std::cout << "Listing Mr. E's debts:\n";
    ShowArray(pd, 3);
    std::cout << "Total = " << SumArray(pd, 3) << std::endl;

    return 0;
}

template <typename T>
T SumArray(T arr[], int n)
{
    T summ = 0;
    for (int i = 0; i < n; i++)
    {
        summ += arr[i];
    }
    return summ;
}

template <typename T>
T SumArray(T *arr[], int n)
{
    T summ = 0;
    for (int i = 0; i < n; i++)
    {
        summ += *arr[i];
    }
    return summ;
}

template <typename T>
void ShowArray(T arr[], int n)
{
    std::cout << "template ShowArray A\n";
    for (int i = 0; i < n; i++)
    {
        std::cout << arr[i] << ' ';
    }
    std::cout << std::endl;
}

template <typename T>
void ShowArray(T *arr[], int n)
{
    std::cout << "template ShowArray B\n";
    for (int i = 0; i < n; i++)
    {
        std::cout << *arr[i] << ' ';
    }
    std::cout << std::endl;
}
显示结果如下
Listing Mr. E's counts of things :
template ShowArray A
13 31 103 301 310 130
Total = 888
Listing Mr. E's debts:
template ShowArray B
2400 1300 1800
Total = 5500

第9章 内存模型和名称空间
9.1 单独编译
9.2 存储持续性、作用域和链接性
9.2.1 作用域和链接
9.2.2 自动存储持续性
9.2.3 静态持续变量
9.2.4 静态持续性、外部链接性
9.2.5 静态持续性、内部链接性
9.2.6 静态存储持续性、无链接性
9.2.7 说明符和限定符
9.2.8 函数和链接性
9.2.9 语言链接性
9.2.10 存储方案和动态分配
9.3 名称空间
9.3.1 传统的C++名称空间
9.3.2 新的名称空间特性
9.3.3 名称空间示例
9.3.4 名称空间及其前途
9.4 总结
9.5 复习题
9.6 编程练习
本章内容包括：
单独编译。
存储持续性、作用城和链接性。
定位（placement）new运算符。
名称空间。
9.1单独编译
下面列出了头文件中常包含的内容。
函数原型。
使用#define定义的符号常量。
自定义类型。
结构声明。
类声明。
模板声明。
程序清单9.1、程序清单9.2和程序清单9.3是将程序清单7.12分成几个独立部分后得到的结果。
程序清单9.1 coordin.h
#pragma once
#ifndef COORDIN_H_
#define COORDIN_H_

struct polar
{
    double distance;
    double angle;
};

struct rect
{
    double x;
    double y;
};

polar rect_to_polar(rect xypos);
void show_polar(polar dapos);

#endif

程序清单9.2 file1.cpp
#include <iostream>
#include "coordin.h"

int main()
{
    rect rplace;
    polar pplace;
    std::cout << "Enter the x and y values: ";
    while ( (std::cin >> rplace.x) && (std::cin >> rplace.y) )
    {
        pplace = rect_to_polar(rplace);
        show_polar(pplace);
        std::cout << "Enter the x and y values (q to quit) : ";
    }
    std::cout << "Done.\n";

    return 0;
}

程序清单9.3 file2.cpp
#include <iostream>
#include <cmath>
#include "coordin.h"

polar rect_to_polar(rect xypos)
{
    polar answer;
    answer.distance = sqrt(xypos.x * xypos.x + xypos.y * xypos.y);
    answer.angle = atan2(xypos.y, xypos.x);
    return answer;
}
void show_polar(polar dapos)
{
    const double Rad_to_deg = 57.29577951;
    std::cout << "distance = " << dapos.distance << ", angle = " << dapos.angle *Rad_to_deg << " degrees\n";
}
编译命令如下
g++ -o file1 file1.cpp file2.cpp
显示结果如下
Enter the x and y values: 3.0 3.0
distance = 4.24264, angle = 45 degrees
Enter the x and y values (q to quit) : q
Done.

9.2 存储持续性、作用域和链接性
C++使用三种（在C++11中是四种）不同的方案来存储数据，这些方案的区别就在于数据保留在内存中的时间。
自动存储持续性：在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。
它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放。
静态存储持续性：在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为静态，
它们在程序整个运行过程中都存在。
线程存储持续性（C++11）：当前，多核处理器很常见，这些CPU可同时处理多个执行任务。
这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字thread_local声明的，则其生命周期与所属的线程一样长。本书不探讨并行编程。
动态存储持续性：用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止。
这种内存的存储持续性为动态，有时被称为自由存储（free store）或堆（heap）。
9.2.1作用域和链接
作用域（scope）描述了名称在文件（翻译单元）的多大范围内可见。
例如，函数中定义的变量可在该函数中使用，但不能在其他函数中使用；
而在文件中的函数定义之前定义的变量则可在所有函数中使用。
链接性（linkage）描述了名称如何在不同单元间共享。
链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享。
自动变量的名称没有链接性，因为它们不能共享。
C++变量的作用域有多种。作用域为局部的变量只在定义它的代码块中可用。
代码块是由花括号括起的一系列语句。例如函数体就是代码块，但可以在函数体中嵌入其他代码块。
作用域为全局（也叫文件作用域）的变量在定义位置到文件结尾之间都可用。
自动变量的作用域为局部，静态变量的作用域是全局还是局部取决于它是如何被定义的。
在函数原型作用域（function prototype scope）中使用的名称只在包含参数列表的括号内可用
（这就是为什么这些名称是什么以及是否出现都不重要的原因）。
在类中声明的成员的作用域为整个类（参见第10章），在名称空间中声明的变量的作用域为整个名称空间
（由于名称空间已经引入到C++语言中，因此全局作用域是名称空间作用域的特例）。
C++函数的作用域可以是整个类或整个名称空间（包括全局的），但不能是局部的
（因为不能在代码块内定义函数，如果函数的作用域为局部，则只对它自己是可见的，因此不能被其他函数调用。
这样的函数将无法运行）。
不同的C++存储方式是通过存储持续性、作用域和链接性来描述的。
下面来看看各种C++存储方式的这些特征。首先介绍引入名称空间之前的情况，然后看一看名称空间带来的影响。
9.2.2 自动存储持续性
在默认情况下，在函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性。
程序清单9.4 auto.cpp
#include <iostream>

using namespace std;

void oil(int x);

int main()
{
    int texas = 31;
    int year = 2011;
    cout << "In main(), texas = " << texas << ", &texas = " << &texas << endl;
    cout << "In main(), year = " << year << ", &year = " << &year << endl;
    oil(texas);
    cout << "In main(), texas = " << texas << ", &texas = " << &texas << endl;
    cout << "In main(), year = " << year << ", &year = " << &year << endl;

    return 0;
}
void oil(int x)
{
    int texas = 5;
    cout << "In oil(), texas = " << texas << ", &texas = " << &texas << endl;
    cout << "In oil(), x = " << x << ", &x = " << &x << endl;
    {
        int texas = 113;
        cout << "In block, texas = " << texas << ", &texas = " << &texas << endl;
        cout << "In block, x = " << x << ", &x = " << &x << endl;
    }
    cout << "Post-block texas = " << texas << ", &texas = " << &texas << endl;
}
显示结果如下
In main(), texas = 31, &texas = 0x7ffdbe70b930
In main(), year = 2011, &year = 0x7ffdbe70b934
In oil(), texas = 5, &texas = 0x7ffdbe70b910
In oil(), x = 31, &x = 0x7ffdbe70b90c
In block, texas = 113, &texas = 0x7ffdbe70b914
In block, x = 31, &x = 0x7ffdbe70b90c
Post-block texas = 5, &texas = 0x7ffdbe70b910
In main(), texas = 31, &texas = 0x7ffdbe70b930
In main(), year = 2011, &year = 0x7ffdbe70b934

在C++11中，关键字auto用于自动类型推断。但在C语言和以前的C++版本中，auto的含义截然不同，它用于显式地指出变量为自动存储。
由于只能将关键字auto用于默认为自动的变量，因此程序员几乎不使用它。
在C++11中，这种用法不再合法。制定标准的人不愿引入新关键字，因为这样做可能导致将该关键字用于其他目的的代码非法。
考虑到auto的老用法很少使用，因此赋予其新含义比引入新关键字是更好的选择。
1.自动变量的初始化
可以使用任何在声明时其值为已知的表达式来初始化自动变量
2.自动变量和栈
由于自动变量的数目随函数的开始和结束而增减，因此程序必须在运行时对自动变量进行管理。
常用的方法是留出一段内存，并将其视为栈，以管理变量的增减。
栈的默认长度取决于实现，但编译器通常提供改变栈长度的选项。
程序使用两个指针来跟踪栈，一个指针指向栈底（栈的开始位置），另一个指针指向栈顶（下一个可用内存单元）。
当函数被调用时，其自动变量将被加入到栈中，栈顶指针指向变量后面的下一个可用的内存单元；
函数结束时，栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。
栈是LIFO（后进先出）的，即最后加入到栈中的变量首先被弹出。
这种设计简化了参数传递。函数调用将其参数的值放在栈顶，然后重新设置栈顶指针。
被调用的函数根据其形参描述来确定每个参数的地址。
3・寄存器变量
关键字register最初是由C语言引入的，它建议编译器使用CPU寄存器来存储自动变量，提高访问变量的速度。
在C++11之前，这个关键字在C++中的用法始终未变，在C++11中，这种提示作用也失去了，
关键字register只是显式地指出变量是自动的。
9.2.3 静态持续变量
和C语言一样，C++也为静态存储持续性变量提供了3种链接性：
外部链接性（可在其他文件中访问）、内部链接性（只能在当前文件中访问）和无链接性（只能在当前函数或代码块中访问）。
编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在。
另外，如果没有显式地初始化静态变量，编译器将把它设置为0。
在默认情况下，静态数组和结构将每个元素或成员的所有位都设置为0。
要想创建链接性为外部的静态持续变量，必须在代码块的外面声明它；
要创建链接性为内部的静态持续变量，必须在代码块的外面声明它，并使用static限定符；
要创建没有链接性的静态持续变量，必须在代码块内声明它，并使用static限定符。
静态变量的初始化
除默认的零初始化外，还可对静态变量进行常量表达式初始化和动态初始化。
零初始化和常量表达式初始化被统称为静态初始化，这意味着在编译器处理文件（翻译单元）时初始化变量。
动态初始化意味着变量将在编译后初始化。
那么初始化形式由什么因素决定呢？首先，所有静态变量都被零初始化，而不管程序员是否显式地初始化了它。
接下来，如果使用常量表达式初始化了变量，且编译器仅根据文件内容（包括被包含的头文件）就可计算表达式，
编译器将执行常量表达式初始化。必要时，编译器将执行简单计算。如果没有足够的信息，变量将被动态初始化。
常量表达式并非只能是使用字面常量的算术表达式，它还可使用sizeof运算符。
C++11新增了关键字constexpr，这增加了创建常量表达式的方式。
9.2.4 静态持续性、外部链接性
链接性为外部的变量通常简称为外部变量，它们的存储持续性为静态，作用域为整个文件。
外部变量是在函数外部定义的，外部变量也称全局变量（相对于局部的自动变量）。
引用声明使用关键字extern，且不进行初始化；否则，声明为定义，导致分配存储空间。
如果要在多个文件中使用外部变量，只需在一个文件中包含该变量的定义，
在使用该变量的其他所有文件中，都使用关键字extern声明它。
程序清单9.5 external.cpp
#include <iostream>

using namespace std;

double warming = 0.3;

void update(double dt);
void local();

int main()
{
    cout << "Global warming is " << warming << " degrees.\n";
    update(0.1);
    cout << "Global warming is " << warming << " degrees.\n";
    local();
    cout << "Global warming is " << warming << " degrees.\n";

    return 0;
}

程序清单9.6 support.cpp
#include <iostream>

using std::cout;
extern double warming;

void update(double dt);
void local();

void update(double dt)
{
    extern double warming;
    warming += dt;
    cout << "Updating global warming to " << warming << " degrees.\n";
}

void local()
{
    double warming = 0.8;
    cout << "Local warming = " << warming << " degrees.\n";
    cout << "But global warming = " << ::warming << " degrees.\n";
}
显示结果如下
Global warming is 0.3 degrees.
Updating global warming to 0.4 degrees.
Global warming is 0.4 degrees.
Local warming = 0.8 degrees.
But global warming = 0.4 degrees.
Global warming is 0.4 degrees.

9.2.5 静态持续性、内部链接性
将static限定符用于作用域为整个文件的变量时，该变量的链接性将为内部的。
在多文件程序中，内部链接性和外部链接性之间的差别很有意义。
链接性为内部的变量只能在其所属的文件中使用；但常规外部变量都具有外部链接性，可以在其他文件中使用。
程序清单9.7 twofile1.cpp
#include <iostream>

int tom = 3;
int dick = 30;
static int harry = 300;

void remote_access();

int main()
{
    using namespace std;
    cout << "main () reports the following addresses:\n";
    cout << &tom << " = &tom, " << &dick << " = &dick, " << &harry << " = &harry\n";
    remote_access();

    return 0;
}

程序清单9.8 twofile2.cpp
#include <iostream>

extern int tom;
static int dick = 10;
int harry = 200;

void remote_access()
{
    using namespace std;
    cout << "remote_access () reports the following addresses:\n";
    cout << &tom << " = &tom, " << &dick << " = &dick, " << &harry << " = &harry\n";
}
显示结果如下
main () reports the following addresses:
0x55d3531cb048 = &tom, 0x55d3531cb04c = &dick, 0x55d3531cb050 = &harry
remote_access () reports the following addresses:
0x55d3531cb048 = &tom, 0x55d3531cb054 = &dick, 0x55d3531cb058 = &harry

9.2.6静态存储持续性、无链接性
在代码块中的变量使用static时，将导致局部变量的存储持续性为静态的。
这意味着虽然该变量只在该代码块中可用，但它在该代码块不处于活动状态时仍然存在。
因此在两次函数调用之间，静态局部变量的值将保持不变。
另外，如果初始化了静态局部变量，则程序只在启动时进行一次初始化，
以后再调用函数时，将不会像自动变量那样再次被初始化。
程序清单9.9 static.cpp
#include <iostream>

using namespace std;

const int ArSize = 128;

void strcount(const char *str);

int main()
{
    char input[ArSize];
    char next;

    cout << "Enter a line:\n";
    while ( cin.get(input, ArSize) )
    {
        while (std::cin.get() != '\n')
        {
            continue;
        }
        strcount(input);
        cout << "Enter a line:\n";
    }
    cout << "Done.\n";

    return 0;
}
void strcount(const char *str)
{
    static int total = 0;
    int count = 0;
    cout << "\"" << str << "\" contains ";
    while (*str++)
    {
        count++;
    }
    total += count;
    cout << count << " characters\n";
    cout << total << " characters total\n";
}
显示结果如下
Enter a line:
Hello World
"Hello World" contains 11 characters
11 characters total
Enter a line:
Peter Smith
"Peter Smith" contains 11 characters
22 characters total
Enter a line:
Mike Pence
"Mike Pence" contains 10 characters
32 characters total
Enter a line:
Done.

9.2.7说明符和限定符
下面是说明符：
auto（在C++11中不再是说明符）；
register；
static；
extern；
thread_local（C++11新增的）；
mutable
在同一个声明中不能使用多个说明符，但thread_local除外，它可与static或extern结合使用，
在C++11之前；可以在声明中使用关键字auto，指出变量为自动变量；但在C++11中，auto用于自动类型推断。
关键字register用于在声明中指示寄存器存储，而在C++11中，它只是显式地指出变量是自动的。
关键字static被用在作用域为整个文件的声明中时，表示内部链接性；
被用于局部声明中，表示局部变量的存储持续性为静态的。
关键字exterm表明是引用声明，即声明引用在其他地方定义的变量。
关键字thread_local指出变量的持续性与其所属线程的持续性相同。
thread_local变量之于线程，犹如常规静态变量之于整个程序。
关键字mutable的含义将根据const来解释。
下面是限定符：
const；
volatile；
const表明内存被初始化后，程序便不能再对它进行修改。
volatile表明，即使程序代码没有对内存单元进行修改，其值也可能发生变化。
该关键字的作用是为了改善编译器的优化能力。
例如，假设编译器发现，程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，
而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次使用之间不会变化。
如果不将变量声明为volatile，则编译器将进行这种优化；将变量声明为volatile，相当于告诉编译器，不要进行这种优化。
可以用mutable来指出，即使结构（或类）变量为const，其某个成员也可以被修改。
在C++中const限定符对默认存储类型稍有影响。
在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的。
也就是说，在C++看来，全局const定义就像使用了static说明符一样。
如果出于某种原因，程序员希望某个常量的链接性为外部的，则可以使用extern关键字来覆盖默认的内部链接性。
在这种情况下，必须在所有使用该常量的文件中使用exten关键字来声明它，且只有一个文件对其进行初始化。
这与常规外部变量不同，定义常规外部变量时，不必使用extern关键字，但在使用该变量的其他文件中必须使用extern。
在函数或代码块中声明const时，其作用域为代码块，仅当程序执行该代码块中的代码时，该常量才是可用的。
这意味着在函数或代码块中创建常量时，不必担心其名称与其他地方定义的常量发生冲突。
9.2.8 函数和链接性
和C语言一样，C++不允许在一个函数中定义另外一个函数，因此所有函数的存储持续性都自动为静态的，
即在整个程序执行期间都一直存在。在默认情况下，函数的链接性为外部的，即可以在文件间共享。
实际上，可以在函数原型中使用关键字extern来指出函数是在另一个文件中定义的，不过这是可选的。
还可以使用关键字static将函数的链接性设置为内部的，使之只能在一个文件中使用。
必须同时在原型和函数定义中使用该关键字，这意味着该函数只在这个文件中可见，
还意味着可以在其他文件中定义同名的的函数。
和变量一样，在定义静态函数的文件中，静态函数将覆盖外部定义，
因此即使在外部定义了同名的函数，该文件仍将使用静态函数。
对于链接性为外部的函数来说，只能有一个文件包含该函数的定义，但使用该函数的每个文件都应包含其函数原型。
内联函数不受这项规则的约束，这允许程序员能够将内联函数的定义放在头文件中。
如果该文件中的函数原型指出该函数是静态的，则编译器将只在该文件中查找函数定义；
否则，编译器（包括链接程序）将在所有的程序文件中查找。
如果找到两个定义，编译器将发出错误消息，因为每个外部函数只能有一个定义。
如果在程序文件中没有找到，编译器将在库中搜索。
这意味着如果定义了一个与库函数同名的函数，编译器将使用程序员定义的版本，而不是库函数。
然而，C++保留了标准库函数的名称，程序员不应使用它们。
9.2.9 语言链接性
链接程序要求每个不同的函数都有不同的符号名。在C语言中，一个名称只对应一个函数。
但在C++中，同一个名称可能对应多个函数，必须将这些函数翻译为不同的符号名称。
因此，C++编译器执行名称矫正或名称修饰，为重载函数生成不同的符号名称。
链接程序寻找与C++函数调用匹配的函数时，使用的方法与C语言不同。
为解决这种问题，可以用函数原型来指出要使用的约定：
extern "C" void spiff (int);   // use C protocol for name look-up
extern void spoff (int);   //use C++ protocol for name look-up
extern "C++" void spaff (int);   // use C++ protocol for name look-up
第一个原型使用C语言链接性；而后面的两个使用C++语言链接性。
第二个原型是通过默认方式指出这一点的，而第三个显式地指出了这一点。
C和C++链接性是C++标准指定的说明符，但实现可提供其他语言链接性说明符。
9.2.10存储方案和动态分配
动态内存由运算符new和delete控制，而不是由作用域和链接性规则控制。
因此，可以在一个函数中分配动态内存，而在另一个函数中将其释放。
其分配和释放顺序取决于new和delete在何时以何种方式被使用。
虽然存储方案概念不适用于动态内存，但适用于用来跟踪动态内存的自动和静态指针变量。
1.使用new运算符初始化
如果要为内置的标量类型（如int或double）分配存储空间并初始化，可在类型名后面加上初始值，并将其用括号括起：
int * pi = new int (6);
double * pd = new double (99.99);
这种括号语法也可用于有合适构造函数的类，这将在本书后面介绍。
然而，要初始化常规结构或数组，需要使用大括号的列表初始化，这要求编译器支持C++11。C+11允许您这样做：
struct where
{
    double x;
    double y;
    double z;
};
where * one = new where {2.5, 5.3, 7.2);   // C++11
int * ar = new int[4] {2, 4, 6, 7};   // C+11
在C++11中，还可将列表初始化用于单值变量：
int * pin = new int {6};
double * pdo = new double {99.99};
2.new失败时
new可能找不到请求的内存量，在这种情况下将引发异常std:bad_alloc。
3.new运算符、函数和替换函数
运算符new和new[]分别调用如下函数：
void * operator new (std::size_t):
void  operator new [] (std::size t)
这些函数被称为分配函数，它们位于全局名称空间中。
同样，也有由delete和delete[]调用的释放函数：
void operator delete (void *);
void operator delete [] (void *);
4.定位new运算符
通常，new负责在堆（heap）中找到一个足以能够满足要求的内存块。
new运算符还有另一种变体，被称为定位（placement）new运算符，它让您能够指定要使用的位置。
程序员可能使用这种特性处理需要通过特定地址进行访问的硬件或在特定位置创建对象。
要使用定位new特性，首先需要包含头文件new，它提供了这种版本的new运算符的原型；
然后将new运算符用于提供了所需地址的参数。除需要指定参数外，其他用法与常规new运算符相同。
new (参数) 类型
new (参数) 类型 [数量]
程序清单9.10 newplace.cpp
#include <iostream>
#include <new>

using namespace std;

const int BUF = 512;
const int N = 5;
char buffer[BUF];

int main()
{
    double *pd1, *pd2;
    int i;
    cout << "Calling new and placement new:\n";
    pd1 = new double[N];
    pd2 = new (buffer) double[N];
    for (i = 0; i < N; i++)
    {
        pd2[i] = pd1[i] = 1000 + 20.0 * i;
    }
    cout << "Memory addresses: \n" << "heap: " << pd1 << ", static: " << (void *) buffer << ", " << pd2 << endl;
    cout << "Memory contents:\n";
    for (i = 0; i < N; i++)
    {
        cout << pd1[i] << " at " << &(pd1[i]) << "; ";
        cout << pd2[i] << " at " << &(pd2[i]) << endl;
    }

    cout << "\nCalling new and placement new a second time:\n";
    double *pd3, *pd4;
    pd3 = new double[N];
    pd4 = new (buffer) double[N];
    for (i = 0; i < N; i++)
    {
        pd4[i] = pd3[i] = 1000 + 40.0 * i;
    }
    cout << "Memory addresses: \n" << "heap: " << pd3 << ", static: " << pd4 << endl;
    cout << "Memory contents:\n";
    for (i = 0; i < N; i++)
    {
        cout << pd3[i] << " at " << &(pd3[i]) << "; ";
        cout << pd4[i] << " at " << &(pd4[i]) << endl;
    }

    cout << "\nCalling new and placement new a third time:\n";
    delete [] pd1;
    pd1 = new double[N];
    pd2 = new (buffer + N * sizeof(double)) double[N];
    for (i = 0; i < N; i++)
    {
        pd2[i] = pd1[i] = 1000 + 60.0 * i;
    }
    cout << "Memory addresses: \n" << "heap: " << pd1 << ", static: " << pd2 << endl;
    cout << "Memory contents:\n";
    for (i = 0; i < N; i++)
    {
        cout << pd1[i] << " at " << &(pd1[i]) << "; ";
        cout << pd2[i] << " at " << &(pd2[i]) << endl;
    }
    delete[] pd1;
    delete[] pd3;

    return 0;
}
显示结果如下
Calling new and placement new:
Memory addresses:
heap: 0x55d6573622c0, static: 0x55d655b361a0, 0x55d655b361a0
Memory contents:
1000 at 0x55d6573622c0; 1000 at 0x55d655b361a0
1020 at 0x55d6573622c8; 1020 at 0x55d655b361a8
1040 at 0x55d6573622d0; 1040 at 0x55d655b361b0
1060 at 0x55d6573622d8; 1060 at 0x55d655b361b8
1080 at 0x55d6573622e0; 1080 at 0x55d655b361c0

Calling new and placement new a second time:
Memory addresses:
heap: 0x55d6573622f0, static: 0x55d655b361a0
Memory contents:
1000 at 0x55d6573622f0; 1000 at 0x55d655b361a0
1040 at 0x55d6573622f8; 1040 at 0x55d655b361a8
1080 at 0x55d657362300; 1080 at 0x55d655b361b0
1120 at 0x55d657362308; 1120 at 0x55d655b361b8
1160 at 0x55d657362310; 1160 at 0x55d655b361c0

Calling new and placement new a third time:
Memory addresses:
heap: 0x55d6573622c0, static: 0x55d655b361c8
Memory contents:
1000 at 0x55d6573622c0; 1000 at 0x55d655b361c8
1060 at 0x55d6573622c8; 1060 at 0x55d655b361d0
1120 at 0x55d6573622d0; 1120 at 0x55d655b361d8
1180 at 0x55d6573622d8; 1180 at 0x55d655b361e0
1240 at 0x55d6573622e0; 1240 at 0x55d655b361e8

9.3 名称空间
声明区域是可以在其中进行声明的区域。
对于在函数外面声明的全局变量，其声明区域为其声明所在的文件；
对于在函数中声明的局部变量，其声明区域为其声明所在的代码块。
变量的潜在作用域从声明点开始，到其声明区域的结尾。
因此潜在作用域比声明区域小，这是由于变量必须定义后才能使用。
然而，变量并非在其潜在作用域内的任何位置都是可见的。
例如，在函数中声明的局部变量将隐藏在同一个文件中声明的全局变量。
变量对程序而言可见的范围被称为作用域（scope）。
每个声明区域都可以声明名称，这些名称独立于在其他声明区域中声明的名称。
在一个函数中声明的局部变量不会与在另一个函数中声明的局部变量发生冲突。
C++新增了这样一种功能，即通过定义一种新的声明区域来创建命名的名称空间。
一个名称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西。
名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。
因此，在默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量）。
除了用户定义的名称空间外，还存在另一个名称空间――全局名称空间（global namespace）。
它对应于文件级声明区域，因此前面所说的全局变量现在被描述为位于全局名称空间中。
任何名称空间中的名称都不会与其他名称空间中的名称发生冲突。
名称空间中的声明和定义规则同全局声明和定义规则相同。
名称空间是开放的（open），可以把新的名称加入到已有的名称空间中。
可以通过作用域解析运算符 :: 来访问给定名称空间中的名称。
1.using声明和using编译指令
C++提供了两种机制（using声明和using编译指令）来简化对名称空间中名称的使用。
using声明使特定的标识符可用，using编译指令使整个名称空间可用。
using声明由被限定的名称和它前面的关键字using组成；
using Jill::fetch;   // a using declaration
using声明将特定的名称添加到它所属的声明区域中。
下面的代码段说明了这几点：
namespace Jill
{
    double bucket (double n) { ... }
    double fetch;
    struct Hill { ... };
}
char fetch;
int main ()
{
    using Jill::fetch;
    cin >> fetch;   // read a value into Jill::fetch
    cin >> ::fetch;   // read a value into global fetch
}
在函数的外面使用using声明时，将把名称添加到全局名称空间中。
using声明使一个名称可用，而using编译指令使所有的名称都可用。
using编译指令由名称空间名和它前面的关键字using namespace组成，
它使名称空间中的所有名称都可用，而不需要使用作用域解析运算符。
在全局声明区域中使用using编译指令，将使该名称空间的名称全局可用。
在函数中使用using编译指令，将使其中的名称在该函数中可用。
有关using编译指令和using声明，需要记住的一点是，它们增加了名称冲突的可能性。
如果在代码中使用作用域解析运算符 :: 不存在二义性的标识符，使用using声明或using编译指令后，情况将发生变化。
Jack::pal = 3;
Jill::pal = 10;

using Jack::pal;
using Jill::pal;
pal = 4;   // which one? now have a conflict
2.using编译指令和using声明之比较
假设名称空间和声明区域定义了相同的名称。如果试图使用using声明将名称空间的名称导入该声明区域，
则这两个名称会发生冲突，从而出错。
如果使用using编译指令将该名称空间的名称导入该声明区域，则局部版本将隐藏名称空间版本。
不过仍可以使用作用域解析运算符来访问名称空间名称。
一般说来，使用using声明比使用using编译指令更安全，这是由于它只导入指定的名称。
如果该名称与局部名称发生冲突，编译器将发出指示。using编译指令导入所有名称，包括可能并不需要的名称。
如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告，
另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。
namespace Jill
{
    double bucket (double n) { ... }
    double fetch;
    struct Hill { ... };
}
char fetch;
int main ()
{
    using namespace Jill;
    Hill Thrill;   // create a type Jill:Hill structure
    double water = bucket (2);   // use Jill::bucket()
    double fetch;   // hide Jill::fetch
    cin >> fetch;   // read a value into the local fetch
    cin >> ::fetch;   // read a value into the global fetch
    cin >> Jill::fetch;   // read a value into Jill::fetch
}
int foom()
{
    Jill::Hill crest;
}
3.名称空间的其他特性
可以将名称空间声明进行嵌套：
4.未命名的名称空间
可以通过省略名称空间的名称来创建未命名的名称空间。
在该名称空间中声明的名称的潜在作用域为：从声明点到该声明区域末尾。从这个方面看，它们与全局变量相似。
然而，由于这种名称空间没有名称，因此不能显式地使用using编译指令或using声明来使它在其他位置都可用。
具体地说，不能在未命名名称空间所属文件之外的其他文件中，使用该名称空间中的名称。
这提供了链接性为内部的静态变量的替代品。
程序清单9.11 namesp.h
#include <string>

namespace pers
{
    struct Person
    {
        std::string fname;
        std::string lname;
    };
    void getPerson(Person &);
    void showPerson(const Person &);
}

namespace debts
{
    using namespace pers;
    struct Debt
    {
        Person name;
        double amount;
    };
    void getDebt(Debt &);
    void showDebt(const Debt &);
    double sumDebts(const Debt ar[], int n);
}

程序清单9.12 namesp.cpp
#include <iostream>
#include "namesp.h"

namespace pers
{
    using std::cout;
    using std::cin;
    void getPerson(Person &rp)
    {
        cout << "Enter first name: ";
        std::getline(cin, rp.fname, '\n');
        cout << "Enter last name: ";
        std::getline(cin, rp.lname, '\n');
    }
    void showPerson(const Person &rp)
    {
        std::cout << rp.lname << ", " << rp.fname;
    }
}

namespace debts
{
    void getDebt(Debt &rd)
    {
        getPerson(rd.name);
        std::cout << "Enter debt: ";
        std::cin >> rd.amount;
        while (std::cin.get() != '\n')
        {
            continue;
        }
    }
    void showDebt(const Debt &rd)
    {
        showPerson(rd.name);
        std::cout << ": $" << rd.amount << std::endl;
    }
    double sumDebts(const Debt ar[], int n)
    {
        double total = 0;
        for (int i = 0; i < n; i++)
        {
            total += ar[i].amount;
        }
        return total;
    }
}

程序清单9.13 usenmsp.cpp
#include <iostream>
#include "namesp.h"

void other(void);
void another(void);

int main()
{
    using debts::Debt;
    using debts::showDebt;
    Debt golf = { { "Benny", "Goatsnif f" }, 120.0 };
    showDebt(golf);
    other();
    another();

    return 0;
}

void other(void)
{
    using std::cout;
    using std::endl;
    using namespace debts;
    Person dg = { "Doodles", "Glister" };
    showPerson(dg);
    cout << endl;
    Debt zippy[3];
    int i;
    for (i = 0; i < 3; i++)
    {
        getDebt(zippy[i]);
    }
    for (i = 0; i < 3; i++)
    {
        showDebt(zippy[i]);
    }
    cout << "Total debt: $" << sumDebts(zippy, 3) << endl;
    return;
}

void another(void)
{
    using pers::Person;
    Person collector = { "Milo", "Rightshift" };
    pers::showPerson(collector);
    std::cout << std::endl;
}
显示结果如下
Goatsnif f, Benny: $120
Glister, Doodles
Enter first name: Peter
Enter last name: Smith
Enter debt: 133
Enter first name: Pence
Enter last name: Mike
Enter debt: 210
Enter first name: World
Enter last name: Hello
Enter debt: 330
Smith, Peter: $133
Mike, Pence: $210
Hello, World: $330
Total debt: $673
Rightshift, Milo

下面是一些指导原则。
使用在己命名的名称空间中声明的变量，而不是使用外部全局变量。
使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。
如果开发了一个函数库或类库，将其放在一个名称空间中。
仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计。
不要在头文件中使用using编译指令。首先，这样做掩盖了要让哪些名称可用；
另外，包含头文件的顺序可能影响程序的行为。如果非要使用编译指令using，应将其放在所有预处理器编译指令#include之后。
导入名称时，首选使用作用域解析运算符或using声明的方法。
对于using声明，首选将其作用域设置为局部而不是全局。
9.4 总结
C++鼓励程序员在开发程序时使用头文件来定义用户类型，为操纵用户类型的函数提供函数原型；
并将函数定义放在一个独立的源代码文件中。头文件和源代码文件一起定义和实现了用户定义的类型及其使用方式。
最后，将main和其他使用这些函数的函数放在第三个文件中。
C++的存储方案决定了变量保留在内存中的时间以及程序的哪一部分可以访问它，
自动变量是在代码块（如函数体或函数体中的代码块）中定义的变量，
仅当程序执行到包含定义的代码块时，它们才存在，并且可见。
自动变量可以通过使用存储类型说明符register或根本不使用说明符来声明，没有使用说明符时，变量将默认为自动的。
register说明符提示编译器，该变量的使用频率很高，但C++11摒弃了这种用法。
静态变量在整个程序执行期间都存在。对于在函数外面定义的变量，
其所属文件中位于该变量的定义后面的所有函数都可以使用它（文件作用域），并可在程序的其他文件中使用（外部链接性）。
另一个文件使用这种变量，必须使用extern关键字来声明它。
对于多个文件间共享的变量，应在一个文件中包含其定义（无需使用extern，但如果同时进行初始化，也可使用它），
并在其他文件中包含引用声明（使用extern且不初始化）。
在函数的外面使用关键字static定义的变量的作用域为整个文件，但是不能用于其他文件（内部链接性）。
在代码块中使用关键字static定义的变量被限制在该代码块内（局部作用域、无链接性），
但在整个程序执行期间，它都一直存在。
在默认情况下，C++函数的链接性为外部，因此可在文件间共享；
但使用关键字static限定的函数的链接性为内部的，被限制在定义它的文件中。
动态内存分配和释放是使用new和delete进行的，它使用自由存储区或堆来存储数据。
调用new占用内存，而调用delete释放内存。程序使用指针来跟踪这些内存单元。
名称空间允许定义一个可在其中声明标识符的命名区域。
这样做的目的是减少名称冲突，尤其当程序非常大，并使用多个厂商的代码时。
可以通过使用作用域解析运算符、using声明或using编译指令，来使名称空间中的标识符可用。
9.5复习题
1.对于下面的情况，应使用哪种存储方案？
a.homer是函数的形参。
b.secret变量由两个文件共享。
c.topsecret变量由一个文件中的所有函数共享，但对于其他文件来说是隐藏的。
d.beencalled记录包含它的函数被调用的次数。

a.自动变量
b.在一个文件中将secret定义为外部变量，在另一个文件中使用extern来声明它
c.在topsecret定义前加上static，也可以在一个未命名的名称空间中定义topsecret
d.在函数中变量beencalled的定义前加上static

2.using声明和using编译指令之间有何区别？
using声明使得名称空间中对应的名称可用，using编译指令使得名称空间中所有的名称可用。
假设名称空间和声明区域定义了相同的名称。如果试图使用using声明将名称空间的名称导入该声明区域，
则这两个名称会发生冲突，从而出错。
如果使用using编译指令将该名称空间的名称导入该声明区域，则局部版本将隐藏名称空间版本。
不过仍可以使用作用域解析运算符来访问名称空间名称。

3.重新编写下面的代码，使其不使用using声明和using编译指令。
#include <iostream>

using namespace std;

int main()
{
    double x;

    cout << "Enter value : ";
    while ( ! (cin >> x) )
    {
        cin.clear();
        while (cin.get() != '\n')
        {
            continue;
        }
        cout << "Bad input. Please enter a number : ";
    }
    cout << "Value = " << x << endl;
    return 0;
}
修改后
#include <iostream>

int main()
{
    double x;

    std::cout << "Enter value : ";
    while ( ! (std::cin >> x) )
    {
        std::cin.clear();
        while (std::cin.get() != '\n')
        {
            continue;
        }
        std::cout << "Bad input. Please enter a number : ";
    }
    std::cout << "Value = " << x << std::endl;
    return 0;
}
4.重新编写下面的代码，使之使用using声明，而不是using编译指令。
#include <iostream>

using namespace std;

int main()
{
    double x;

    cout << "Enter value : ";
    while ( ! (cin >> x) )
    {
        cin.clear();
        while (cin.get() != '\n')
        {
            continue;
        }
        cout << "Bad input. Please enter a number : ";
    }
    cout << "Value = " << x << endl;
    return 0;
}
修改后
#include <iostream>

int main()
{
    using std::cin;
    using std::cout;
    using std::endl;

    double x;

    cout << "Enter value : ";
    while ( ! (cin >> x) )
    {
        cin.clear();
        while (cin.get() != '\n')
        {
            continue;
        }
        cout << "Bad input. Please enter a number : ";
    }
    cout << "Value = " << x << endl;
    return 0;
}
5.在一个文件中调用average(3, 6)函数时，它返回两个int参数的int平均值，
在同一个程序的另一个文件中调用时，它返回两个int参数的double平均值。应如何实现？
每个文件中包含对应版本的静态average函数原型和定义，
或者在每个文件中的未命名的名称空间中定义一个对应版本的average函数

6.下面的程序由两个文件组成，该程序显示什么内容？
file1.cpp
#include <iostream>

using namespace std;

void other();
void another();

int x = 10;
int y;

int main ()
{
    cout << x << endl;
    {
        int x = 4;
        cout << x << endl;
        cout << y << endl;
    }
    other();
    another();
  
    return 0;
}
void other()
{
    int y = 1;
    cout << "Other : " << x << ", " << y << endl;
}

file2.cpp
#include <iostream>

using namespace std;

extern int x;

namespace
{
    int y = -4;
}

void another()
{
    cout << "another : " << x << ", " << y << endl;
}

10
4
0
Other : 10, 1
another : 10, -4

7.下面的代码将显示什么内容？
#include <iostream>

using namespace std;

void other();

namespace n1
{
    int x = 1;
}
namespace n2
{
    int x = 2;
}

int main ()
{
    using namespace n1;

    cout << x << endl;
    {
        int x = 4;
        cout << x << ", " << n1::x << ", " << n2::x << endl;
    }
    using n2::x;
    cout << x << endl;
    other();

    return 0;
}

void other()
{
    using namespace n2;
    cout << x << endl;
    {
        int x = 4;
        cout << x << ", " << n1::x << ", " << n2::x << endl;
    }
    using n2::x;
    cout << x << endl;
}
1
4, 1, 2
2
2
4, 1, 2
2

9.6编程练习
1.下面是一个头文件：
根据这个头文件，创建一个多文件程序。其中的一个文件名为golf.cpp，它提供了与头文件中的原型匹配的函数定义；
另一个文件应包含main，并演示原型化函数的所有特性。
例如，包含一个让用户输入的循环，并使用输入的数据来填充一个由golf结构组成的数组，
数组被填满或用户将高尔夫选手的姓名设置为空字符串时，循环将结束。
main函数只使用头文件中原型化的函数来访问golf结构。
golf.h
#pragma once
#ifndef GOLF_H_
#define GOLF_H_

const int Len = 128;

struct golf
{
    char fullname[Len] = {0};
    int handicap;
};

void setgolf(golf &g, const char *name, int hc);
int setgolf(golf &g);
void handicap(golf &g, int hc);
void showgolf(const golf &g);

#endif

golf.cpp
#include <iostream>
#include <cstring>
#include "golf.h"

void setgolf(golf &g, const char *name, int hc)
{
    strcpy(g.fullname, name);
    g.handicap = hc;
}
int setgolf(golf &g)
{
    int name_valid = 0;

    std::cout << "Enter the name of the player: " << std::endl;
    std::cin.getline(g.fullname, Len);

    if (strlen(g.fullname) > 0)
    {
        name_valid = 1;

        std::cout << "Enter the player's handicap: " << std::endl;
        (std::cin >> g.handicap).get();
    }
    return name_valid;
}

void handicap(golf &g, int hc)
{
    g.handicap = hc;
}

void showgolf(const golf &g)
{
    std::cout << "Player name: " << g.fullname << std::endl;
    std::cout << "Handicap player: " << g.handicap << std::endl;
}

ch09_p01.cpp
#include <iostream>
#include "golf.h"

int main()
{
    golf ann;
    setgolf(ann, "Ann Birdfree", 24);
    showgolf(ann);

    int col_players = 0;
    std::cout << "Enter the number of players: ";
    (std::cin >> col_players).get();

    golf *players = new golf[col_players];
    int i;
    for (i = 0; i < col_players; i++)
    {
        if (setgolf(players[i]) == 0)
        {
            break;
        }
    }

    for (int j = 0; j < i; j++)
    {
        showgolf(players[j]);
    }

    delete [] players;

    return 0;
}
显示结果如下
Player name: Ann Birdfree
Handicap player: 24
Enter the number of players: 6
Enter the name of the player:
Peter Smith
Enter the player's handicap:
21
Enter the name of the player:
Mike Pence
Enter the player's handicap:
33
Enter the name of the player:
Hello World
Enter the player's handicap:
66
Enter the name of the player:

Player name: Peter Smith
Handicap player: 21
Player name: Mike Pence
Handicap player: 33
Player name: Hello World
Handicap player: 66

2.修改程序清单9.9：用string对象代替字符数组。这样，该程序将不再需要检查输入的字符串是否过长，
同时可以将输入字符串同字符串""进行比较，以判断是否为空行。
#include <iostream>
#include <string>

const int ArSize = 128;

void strcount(const std::string str);

int main()
{
    std::string input;
    std::string next;

    std::cout << "Enter a line: ";
    while ( std::getline(std::cin, input, '\n') && input != "")
    {
        strcount(input);
        std::cout << "Enter a line : ";
    }

    std::cout << "Done." << std::endl;

    return 0;
}

void strcount(const std::string str)
{
    static int total = 0;
    int count = 0;

    std::cout << "\"" << str << "\" contains ";

    for (int i = 0; i < str.size(); i++)
    {
        count++;
    }

    total += count;
    std::cout << count << " characters\n";
    std::cout << total << " characters total\n";
}
显示结果如下
Enter a line: Hello, World!
"Hello, World!" contains 13 characters
13 characters total
Enter a line : Mike Pence
"Mike Pence" contains 10 characters
23 characters total
Enter a line : Peter, Smith
"Peter, Smith" contains 12 characters
35 characters total
Enter a line :
Done.

3.下面是一个结构声明：
编写一个程序，使用定位new运算符将一个包含两个这种结构的数组放在一个缓冲区中。
然后，给结构的成员赋值，并使用一个循环来显示内容。
一种方法是像程序清单9.10那样将一个静态数组用作缓冲区；另一种方法是使用常规new运算符来分配缓冲区。
#include <iostream>
#include <new>
#include <cstring>

const int STRUCTSIZE = 2;
const int BUFFSIZE = 512;
char buffer[BUFFSIZE];

struct chaff
{
    char dross[32];
    int slag;
};

void show_chaff(const chaff &chf);
void set_chaff(chaff &chf, const char *name, int qlty);

int main()
{
    chaff *pchaff = new (buffer) chaff[STRUCTSIZE];
    char name[32];
    int quantity = 0;

    for (int i = 0; i < STRUCTSIZE; i++)
    {
        std::cout << "Enter name: ";
        std::cin.getline(name, 32);
        std::cout << "Enter the quantity: ";
        (std::cin >> quantity).get();
        set_chaff(pchaff[i], name, quantity);
    }
    std::cout << pchaff << ", " << (void *)buffer << std::endl;
    for (int i = 0; i < STRUCTSIZE; i++)
    {
        std::cout << "Chaff " << i + 1 << std::endl;
        show_chaff(pchaff[i]);
    }

    return 0;
}

void show_chaff(const chaff &chf)
{
    std::cout << "Dross : " << chf.dross << std::endl;
    std::cout << "Slag : " << chf.slag << std::endl;
}

void set_chaff(chaff &chf, const char *name, int qlty)
{
    strcpy(chf.dross, name);
    chf.slag = qlty;
}
显示结果如下
Enter name: Peter Smith
Enter the quantity: 3
Enter name: Mike Pence
Enter the quantity: 2
0x55edb41e22c0, 0x55edb41e22c0
Chaff 1
Dross : Peter Smith
Slag : 3
Chaff 2
Dross : Mike Pence
Slag : 2

4.请基于下面这个名称空间编写一个由3个文件组成的程序：
第一个文件是一个头文件，其中包含名称空间；
第二个文件是一个源代码文件，它对这个名称空间进行扩展，以提供这三个函数的定义；
第三个文件声明两个Sales对象，并使用setSales的交互式版本为一个结构提供值，
然后使用setSales的非交互式版本为另一个结构提供值。另外它还使用showSales来显示这两个结构的内容。
sales.h
#pragma once
#ifndef SALES_H_
#define SALES_H_

namespace SALES
{
    const int QUARTERS = 4;

    struct Sales
    {
        double sales[QUARTERS] = { 0, 0, 0, 0 };
        double average;
        double max;
        double min;
    };

    void setSales(Sales &s, const double arr[], int n);
    void setSales(Sales &s);
    void showSales(const Sales &s);
}

double find_avg(const double arr[], int size);
double find_max(const double arr[], int size);
double find_min(const double arr[], int size);

#endif

sales.cpp
#include <iostream>
#include "sales.h"

void SALES::setSales(Sales &s, const double arr[], int n)
{
    if (n > QUARTERS)
    {
        n = QUARTERS;
    }

    for (int i = 0; i < n; i++)
    {
        s.sales[i] = arr[i];
    }
    s.average = find_avg(s.sales, QUARTERS);
    s.max = find_max(s.sales, QUARTERS);
    s.min = find_min(s.sales, QUARTERS);
}

void SALES::setSales(Sales &s)
{
    for (int i = 0; i < QUARTERS; ++i)
    {
        std::cout << "Enter sales for quarter " << i + 1 << '\n';
        std::cin >> s.sales[i];
    }

    s.average = find_avg(s.sales, QUARTERS);
    s.max = find_max(s.sales, QUARTERS);
    s.min = find_min(s.sales, QUARTERS);
}

void SALES::showSales(const Sales &s)
{
    for (int i = 0; i < QUARTERS; i++)
    {
        if (i != 0)
        {
            std::cout << ", ";
        }
        std::cout << s.sales[i];
    }
    std::cout << std::endl;
    std::cout << "average: " << s.average << std::endl;
    std::cout << "max: " << s.max << std::endl;
    std::cout << "min: " << s.min << std::endl;
}

double find_avg(const double arr[], int size)
{
    double summ = 0;
    for (int i = 0; i < size; i++)
    {
        summ += arr[i];
    }
    return summ / size;
}

double find_max(const double arr[], int size)
{
    double max = arr[0];
    for (int i = 0; i < size; i++)
    {
        if (arr[i] > max)
        {
            max = arr[i];
        }
    }
    return max;
}

double find_min(const double arr[], int size)
{
    double min = arr[0];
    for (int i = 0; i < size; i++)
    {
        if (arr[i] < min)
        {
            min = arr[i];
        }
    }
    return min;
}

ch09_p04.cpp
#include <iostream>
#include "sales.h"

int main()
{
    SALES::Sales struct1;
    SALES::setSales(struct1);
    std::cout << std::endl;
    SALES::showSales(struct1);

    std::cout << std::endl;

    double arr[] = { 123.12, 522.22, 455.42, 777.32 };
    SALES::Sales struct2;
    SALES::setSales(struct2, arr, SALES::QUARTERS);
    SALES::showSales(struct2);

    return 0;
}
显示结果如下
Enter sales for quarter 1
125
Enter sales for quarter 2
323
Enter sales for quarter 3
256
Enter sales for quarter 4
521

125, 323, 256, 521
average: 306.25
max: 521
min: 125

123.12, 522.22, 455.42, 777.32
average: 469.52
max: 777.32
min: 123.12

第10章 对象和类
10.1 过程性编程和面向对象编程
10.2 抽象和类
10.2.1 类型是什么
10.2.2 C++中的类
10.2.3 实现类成员函数
10.2.4 使用类
10.2.5 修改实现
10.2.6 小结
10.3 类的构造函数和析构函数
10.3.1 声明和定义构造函数.
10.3.2 使用构造函数
10.3.3 默认构造函数
10.3.4 析构函数
10.3.5 改进Stock类
10.3.6 构造函数和析构函数小_.
10.4 this指针
10.5 对象数组
10.6 类作用域
10.6.1 作用域为类的常量
10.6.2 作用域内枚举（C++11）
10.7 抽象数据类型
10.8 总结
10.9 复习题
10.10 编程练习
本章内容包括：
过程性编程和面向对象编程。
类概念。
如何定义和实现类公有类访问和私有类访问。
类的数据成员。
类方法（类函数成员）。
创建和使用类对象。
类的构造函数和析构函数
const成员函数。
this指针。
创建对象数组。
类作用城
抽象数据类型。
本章首先介绍类；将解释抽象、封装、数据隐藏，并演示类是如何实现这些特性的。
本章还将讨论如何定义类、如何为类提供公有部分和私有部分以及如何创建使用类数据的成员函数。
另外，还将介绍构造函数和析构函数，它们是特殊的成员函数，用于创建和删除属于当前类的对象，最后介绍this指针。
程序清单10.1 stock00.h
#pragma once
#ifndef STOCK00_H_
#define STOCK00_H_
#include <string>

class Stock
{
private:
    std::string company;
    long shares;
    double share_val;
    double total_val;
    void set_tot()
    {
        total_val = shares * share_val;
    }
public:
    void acquire(const std::string & co, long n, double pr);
    void buy(long num, double price);
    void sell(long num, double price);
    void update(double price);
    void show();
};

#endif

关键字private和public描述了对类成员的访问控制。
使用类对象的程序都可以直接访问公有部分，但只能通过公有成员函数（或友元函数，参见第11章）来访问对象的私有成员。
因此，公有成员函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口。
防止程序直接访问数据被称为数据隐藏（参见图 10.1）。
C++还提供了第三个访问控制关键字protected，第13章介绍类继承时将讨论该关键字。
无论类成员是数据成员还是成员函数，都可以在类的公有部分或私有部分中声明它。
数据项通常放在私有部分，组成类接口的成员函数放在公有部分；否则，就无法在程序中调用这些接口函数。
也可以把成员函数放在私有部分中，不能直接在程序中调用这种函数，但公有方法却可以使用它们。
通常，程序员使用私有成员函数来处理不属于公有接口的实现细节。
关键字private是类对象的默认访问控制。
类描述看上去很像是包含成员函数以及public和private可见性标签的结构声明。
实际上，C++对结构进行了扩展，使之具有与类相同的特性。
它们之间唯一的区别是，结构的默认访问类型是public，而类为private。
C++程序员通常使用类来实现类描述，而把结构限制为只表示纯粹的数据对象。
10.2.3 实现类成员函数
成员函数定义与常规函数定义非常相似，但是它们还有两个特殊的特征：
定义成员函数时，使用作用域解析运算符 :: 来标识函数所属的类；类的成员函数可以访问类的private成员。
成员函数的函数头使用作用域运算符解析 :: 来指出函数所属的类。
void Stock::update (double price)
update函数是Stock类的成员。
我们可以将另一个类的成员函数也命名为update。
void Buffoon::update()
作用域解析运算符 :: 确定了方法定义对应的类。我们说，标识符update具有类作用域。
Stock类的其他成员函数不必使用作用域解析运算符，就可以使用update方法，
这是因为它们属于同一个类，因此update是可见的。
类方法的完整名称中包括类名，Stock:update是函数的限定名（qualified name），
简单的update是非限定名，它只能在类作用域中使用。
程序清单10.2 stock00.cpp
#include <iostream>
#include "stock00.h"

void Stock::acquire(const std::string & co, long n, double pr)
{
    company = co;
    if (n < 0)
    {
        std::cout << "Number of shares can't be negative; " << company << " shares set to 0.\n";
        shares = 0;
    }
    else
    {
        shares = n;
    }
    share_val = pr;
    set_tot();
}

void Stock::buy(long num, double price)
{
    if (num < 0)
    {
        std::cout << "Number of shares purchased can't be negative. " << "Transaction is aborted.\n";
    }
    else
    {
        shares += num;
        share_val = price;
        set_tot();
    }
}

void Stock::sell(long num, double price)
{
    using std::cout;
    if (num < 0)
    {
        cout << "Number of shares sold can't be negative. " << "Transaction is aborted.\n";
    }
    else if (num > shares)
    {
        cout << "You can't sell more than you have! " << "Transaction is aborted.\n";
    }
    else
    {
        shares -= num;
        share_val = price;
        set_tot();
    }
}

void Stock::update(double price)
{
    share_val = price;
    set_tot();
}

void Stock::show()
{
    std::cout << "Company: " << company << ", Shares: " << shares << '\n'
              << " Share Price: $" << share_val << ", Total Worth: $" << total_val << '\n';
}
定义位于类声明中的函数将自动成为内联函数，因此Stock:set_tot是一个内联函数。
如果愿意，也可以在类声明之外定义成员函数，并使其成为内联函数。
为此，只需在定义类的成员函数时使用inline限定符即可。

同一个类的每个新对象都有自己的存储空间，用于存储其成员变量，
但同一个类的所有对象共享同一组类方法，即每种方法只有一个副本。
例如，假设kate和joe都是Stock对象，则kae.shares将占据一个内存块，而joc.shares占用另一个内存块，
但kate.show和joe.show都调用同一个方法，也就是说，它们将执行同一个代码块，只是将这些代码用于不同的数据。
程序清单 10.3 usestock00.cpp
#include <iostream>
#include "stock00.h"

int main()
{
    Stock fluffy_the_cat;
    fluffy_the_cat.acquire("NanoSmart", 20, 12.50);
    fluffy_the_cat.show();
    fluffy_the_cat.buy(15, 18.125);
    fluffy_the_cat.show();
    fluffy_the_cat.sell(400, 20.00);
    fluffy_the_cat.show();
    fluffy_the_cat.buy(300000, 40.125);
    fluffy_the_cat.show();
    fluffy_the_cat.sell(300000, 0.125);
    fluffy_the_cat.show();

    return 0;
}
显示结果如下
Company: NanoSmart, Shares: 20
 Share Price: $12.5, Total Worth: $250
Company: NanoSmart, Shares: 35
 Share Price: $18.125, Total Worth: $634.375
You can't sell more than you have! Transaction is aborted.
Company: NanoSmart, Shares: 35
 Share Price: $18.125, Total Worth: $634.375
Company: NanoSmart, Shares: 300035
 Share Price: $40.125, Total Worth: $1.20389e+07
Company: NanoSmart, Shares: 35
 Share Price: $0.125, Total Worth: $4.375

10.2.5 修改实现
ostream类包含一些可用于控制格式的成员函数。使用方法setf，便可避免科学计数法：
std::cout.setf (std::ios_base::fixed, std::ios base::floatfield);
这设置了cout对象的一个标记，命令cout使用定点表示法。
同样，下面的语句导致cout在使用定点表示法时，显示三位小数：
std::cout.precision(3);
上述格式修改将一直有效，直到您再次修改，因此它们可能影响客户程序中的后续输出。
因此，应在输出结束后重置格式信息，使其恢复到之前的状态。
10.2.6小结
类声明类似结构声明，可以包括数据成员和函数成员。
声明有私有部分，在其中声明的成员只能通过成员函数进行访问；
声明还具有公有部分，在其中声明的成员可被使用类对象的程序直接访问。
通常，数据成员被放在私有部分中，成员函数被放在公有部分中，因此典型的类声明的格式如下：
cfass ClassNamé
{
private：data member declarations
public：member function prototypes
};
可以在类声明中提供完整的函数定义，而不是函数原型，但是通常的做法是单独提供函数定义（除非函数很小）。
在这种情况下，需要使用作用域解析运算符来指出成员函数属于哪个类。
要创建对象（类的实例），只需将类名视为类型名即可，因为类是用户定义的类型。
类成员函数（方法）可通过类对象来调用，需要使用成员运算符句点( . )。
10.3 类的构造面数和析构面数
常规的初始化语法不适用于类Stock，因为类Stock的数据成员是私有的，这意味着程序不能直接访问数据成员。
您已经看到，程序只能通过成员函数来访问数据成员，因此需要设计合适的成员函数，才能成功地将对象初始化。
一般来说，最好是在创建对象时自动对它进行初始化。
为此，C++提供了一个特殊的成员函数――类构造函数，专门用于构造新对象、将值赋给它们的数据成员。
更准确地说，C++为这些成员函数提供了名称和使用语法，而程序员需要提供方法定义。
名称与类名相同。例如，Stock类一个可能的构造函数是名为Stock()的成员函数。
构造函数的原型和函数头有一个有趣的特征――虽然没有返回值，但没有被声明为void类型。实际上，构造函数没有声明类型。
10.3.1 声明和定义构造函数
现在需要创建Stock的构造函数。由于需要为Stock对象提供3个值，因此应为构造函数提供3个参数。
程序员可能只想设置company成员，而将其他值设置为0；这可以使用默认参数来完成（参见第8章）。
注意，构造函数没有返回类型，且位于类声明的公有部分。
构造函数的参数名称不能与类的数据成员名称相同，一种常见的做法是在数据成员名称中使用前缀或后缀。
10.3.2 使用构造函数
C++提供了两种使用构造函数来初始化对象的方式。
第一种方式是显式地调用构造函数：
Stock food = Stock ("World cabbage", 250, 1.25);
这将food对象的company成员设置为字符串"World Cabbage"，将shares成员设置为250，依此类推。
另一种方式是隐式地调用构造函数：
Stock garment ("Furry Mason", 50, 2.5);
这种格式更紧凑，它与下面的显式调用等价：
Stock garment = Stock ("Furry Mason", 50, 2.5);
每次创建类对象（甚至使用new动态分配内存）时，C++都使用类构造函数。下面是将构造函数与new起使用的方法：
Stock * pstock = new Stock ("Electroshock Games", 18, 19.0);
这条语句创建一个Stock对象，将其初始化为参数提供的值，并将该对象的地址赋给pstock指针。
在这种情况下，对象没有名称，但可以使用指针来管理该对象。我们将在第11章进一步讨论对象指针。
构造函数的使用方式不同于其他类方法。一般来说，使用对象来调用方法，
但无法使用对象来调用构造函数，因为在构造函数构造出对象之前，对象是不存在的。
因此构造函数被用来创建对象，而不能通过对象来调用。
10.3.3 默认构造函数
默认构造函数是在未提供显式初始值时，用来创建对象的构造函数。也就是说，它是用于下面这种声明的构造函数：
Stock fluffy_the_cat;
如果没有提供任何构造函数，则C+将自动提供默认构造函数。它是默认构造函数的隐式版本，不做任何工作。
对于Stock类来说，默认构造函数可能如下：
Stock::Stock() {}
默认构造函数没有参数，因为声明中不包含值。
当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数。
为类定义了构造函数后，程序员就必须为它提供默认构造函数。
如果提供了非默认构造函数，但没有提供默认构造函数，则下面的声明将出错：
Stock stock1;
如果要创建对象，而不显式地初始化，则必须定义一个不接受任何参数的默认构造函数。
定义默认构造函数的方式有两种。一种是给已有构造函数的所有参数提供默认值：
Stock (const string & co = "Error", int n = 0, double pr = 0.0)
另一种方式是通过函数重载来定义一个没有参数的构造函数：
Stock() {}
由于只能有一个默认构造函数，因此不要同时采用这两种方式。
实际上，通常应初始化所有的对象，以确保所有成员一开始就有已知的合理值。
因此，用户定义的默认构造函数通常给所有成员提供隐式初始值。
例如，下面是为Stock类定义的一个默认构造函数：
Stock::Stock()
{
    company = "no name";
    shares = 0;
    share_val = 0.0;
    total_val = 0.0;
}
通常应提供对所有类数据成员做隐式初始化的默认构造函数。
使用上述任何一种方式（没有参数或所有参数都有默认值）创建了默认构造函数后，
便可以声明对象变量，而不对它们进行显式初始化。
Stock first ("Concrete Conglomerate");
Stock second ();
Stock third;
第一个声明调用非默认构造函数，即接受参数的构造函数；
第二个声明指出second是一个返回Stock对象的函数。
隐式地调用默认构造函数时，不要使用圆括号。
10.3.4析构函数
用构造函数创建对象后，程序负责跟踪该对象，直到其过期为止。
对象过期时，程序将自动调用一个特殊的成员函数――析构函数。
析构函数完成清理工作，例如，如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存。
Stock的构造函数没有使用new，因此析构函数实际上没有需要完成的任务。
在这种情况下，只需让编译器生成一个什么要不做的隐式析构函数即可，Stock类第一版正是这样做的。
然而，了解如何声明和定义析构函数是绝对必要的，下面为Stock类提供一个析构函数。
和构造函数一样，析构函数的名称也很特殊：在类名前加上~。因此，Stock类的析构函数为~Stock()。
另外，和构造函数一样，析构函数也可以没有返回值和声明类型。
与构造函数不同的是，析构函数没有参数，因此Stock析构函数的原型必须是这样的
~Stock();
由于Stock的析构函数不承担任何重要的工作，因此可以将它编写为不执行任何操作的函数：
Stock::~Stock() {}
然而，为让您能看出析构函数何时被调用，这样编写其代码：
Stock::~Stock()
{
    cout << "Bye, " << company << "!\n";
}
什么时候应调用析构函数呢？这由编译器决定，通常不应在代码中显式地调用标构函数。
如果创建的是静态存储类对象，则其析构函数将在程序结束时自动被调用。
如果创建的是自动存储类对象（就像前面的示例中那样），则其析构函数将在程序执行完对应的代码块时自动被调用。
如果对象是通过new创建的，则它将驻留在栈内存或自由存储区中，当使用delete来释放内存时，其析构函数将自动被调用。
最后，程序可以创建临时对象来完成特定的操作，在这种情况下，程序将在结束对该对象的使用时自动调用其析构函数。
由于在类对象过期时析构函数将自动被调用，因此必须有一个析构函数。
如果程序员没有提供析构函数，编译器将隐式地声明一个默认析构函数。
在发现导致对象被删除的代码后，提供默认析构函数的定义。
10.3.5 改进Stock.类
程序清单10.4 stock10.h
#pragma once
#ifndef STOCK10_H_
#define STOCK10_H_
#include <string>

class Stock
{
private:
    std::string company;
    long shares;
    double share_val;
    double total_val;
    void set_tot()
    {
        total_val = shares * share_val;
    }
public:
    Stock();
    Stock(const std::string &co, long n = 0, double pr = 0.0);
    ~Stock();
    void buy(long num, double price);
    void sell(long num, double price);
    void update(double price);
    void show();
};

#endif

程序清单10.5 stock10.cpp
#include <iostream>
#include "stock10.h"

Stock::Stock()
{
    std::cout << "Default constructor called\n";
    company = "no name";
    shares = 0;
    share_val = 0.0;
    total_val = 0.0;
}

Stock::Stock(const std::string & co, long n, double pr)
{
    std::cout << "Constructor using " << co << " called\n";
    company = co;
    if (n < 0)
    {
        std::cout << "Number of shares can't be negative; " << company << " shares set to 0.\n";
        shares = 0;
    }
    else
    {
        shares = n;
    }
    share_val = pr;
    set_tot();
}
Stock::~Stock()
{
    std::cout << "Bye, " << company << "!\n";
}

void Stock::buy(long num, double price)
{
    if (num < 0)
    {
        std::cout << "Number of shares purchased can't be negative. " << "Transaction is aborted.\n";
    }
    else
    {
        shares += num;
        share_val = price;
        set_tot();
    }
}

void Stock::sell(long num, double price)
{
    using std::cout;
    if (num < 0)
    {
        cout << "Number of shares sold can't be negative. " << "Transaction is aborted.\n";
    }
    else if (num > shares)
    {
        cout << "You can't sell more than you have! " << "Transaction is aborted.\n";
    }
    else
    {
        shares -= num;
        share_val = price;
        set_tot();
    }
}

void Stock::update(double price)
{
    share_val = price;
    set_tot();
}
void Stock::show()
{
    using std::cout;
    using std::ios_base;
    ios_base::fmtflags orig = cout.setf(ios_base::fixed, ios_base::floatfield);
    std::streamsize prec = cout.precision(3);
    cout << "Company: " << company << ", Shares: " << shares << '\n';
    cout << "Share Price: $ " << share_val;
    cout.precision(2);
    cout << ", Total Worth: $" << total_val << '\n';
    cout.setf(orig, ios_base::floatfield);
    cout.precision(prec);
}

程序清单10.6 usestock10.cpp
#include <iostream>
#include "stock10.h"

int main()
{

    using std::cout;
    cout << "Using constructors to create new objects\n";
    Stock stock1("NanoSmart", 12, 20.0);
    stock1.show();
    Stock stock2 = Stock("Boffo Objects", 2, 2.0);
    stock2.show();
    cout << "Assigning stock1 to stock2:\n";
    stock2 = stock1;
    cout << "Listing stock1 and stock2:\n";
    stock1.show();
    stock2.show();
    cout << "Using a constructor to reset an object\n";
    stock1 = Stock("Nifty Foods", 10, 50.0);
    cout << "Revised stock1:\n";
    stock1.show();
    cout << "Done.\n";

    return 0;
}
显示结果如下
Using constructors to create new objects
Constructor using NanoSmart called
Company: NanoSmart, Shares: 12
Share Price: $ 20.000, Total Worth: $240.00
Constructor using Boffo Objects called
Company: Boffo Objects, Shares: 2
Share Price: $ 2.000, Total Worth: $4.00
Assigning stock1 to stock2:
Listing stock1 and stock2:
Company: NanoSmart, Shares: 12
Share Price: $ 20.000, Total Worth: $240.00
Company: NanoSmart, Shares: 12
Share Price: $ 20.000, Total Worth: $240.00
Using a constructor to reset an object
Constructor using Nifty Foods called
Bye, Nifty Foods!
Revised stock1:
Company: Nifty Foods, Shares: 10
Share Price: $ 50.000, Total Worth: $500.00
Done.
Bye, NanoSmart!
Bye, Nifty Foods!

在C++11中，只要提供与某个构造函数的参数列表匹配的内容，并用大括号将它们括起：
Stock hot tip = {"Derivatives Plus Plus", 100, 45.0};
Stock jock {"Sport Age Storage，Inc"};
stock temp {}
在前两个声明中，用大括号括起的列表与下面的构造函数匹配：t
Stock::Stock(const std::string & co, long n = 0, double pr = 0.0);
因此，将使用该构造函数来创建这两个对象。创建对象jock时，第二和第三个参数将为默认值0和0.0.
第三个声明与默认构造函数匹配，因此将使用该构造函数创建对象temp。
const Stock land = Stock ("Kludgehorn Properties");
land.show();
对于当前的C++来说，编译器将拒绝第二行。这是什么原因呢？因为show的代码无法确保调用对象不被修改。
C++的解决方法是将const关键字放在函数的括号后面。也就是说，show声明应像这样：
    void show() const;
同样，函数定义的开头应像这样：
void Stock::show() const
{
    using std::cout;
    using std::ios_base;
    ios_base::fmtflags orig = cout.setf(ios_base::fixed, ios_base::floatfield);
    std::streamsize prec = cout.precision(3);
    cout << "Company: " << company << ", Shares: " << shares << '\n';
    cout << "Share Price: $ " << share_val;
    cout.precision(2);
    cout << ", Total Worth: $" << total_val << '\n';
    cout.setf(orig, ios_base::floatfield);
    cout.precision(prec);
}
以这种方式声明和定义的类函数被称为const成员函数。
只要类方法不修改调用对象，就应将其声明为const。从现在开始，我们将遵守这一规则。
10.3.6 构造函数和析构函数小结
构造函数是一种特殊的类成员函数，在创建类对象时被调用。
构造函数的名称和类名相同，但通过函数重载，可以创建多个同名的构造函数，
条件是每个函数的特征标（参数列表）都不同。另外，构造函数没有声明类型。
通常，构造函数用于初始化类对象的成员，初始化应与构造函数的参数列表匹配。
如果编译器支持C++11，则可使用列表初始化。
如果构造函数只有一个参数，则将对象初始化为一个与参数的类型相同的值时，该构造函数将被调用。
Bozo dribble = bozo (44);   //primary form
Bozo roon (66);   //secondary form
Bozo tubby = 32;   //special form for one-argument constructors
实际上，第三个示例是新内容，不属于复习内容，但现在正是介绍它的好时机。
第11章将介绍一种关闭这项特性的方式，因为它可能带来令人不愉快的意外。
接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值：
Classname object = value;
这种特性可能导致问题，但正如第11章将介绍的，可关闭这项特性。
默认构造函数没有参数，因此如果创建对象时没有进行显式地初始化，则将调用默认构造函数。
如果程序中没有提供任何构造函数，则编译器会为程序定义一个默认构造函数；
否则，必须自己提供默认构造函数。默认构造函数可以没有任何参数；如果有，则必须给所有参数都提供默认值。
对于未被初始化的对象，程序将使用默认构造函数来创建。
就像对象被创建时程序将调用构造函数一样，当对象被删除时，程序将调用析构函数。
每个类都只能有一个析构函数。析构函数没有返回类型（连void都没有），也没有参数，其名称为类名称前加上~。
如果构造函数使用了new，则必须提供使用delete的析构函数。
10.4 this指针
对于Stock类，还有很多工作要做。到目前为止，每个类成员函数都只涉及一个对象，即调用它的对象。
但有时候方法可能涉及到两个对象，在这种情况下需要使用C++的this指针。
虽然Stock类声明可以显示数据，但它缺乏分析能力。例如，从show的输出我们可以知道持有的哪一支股票价格最高，
但由于程序无法直接访问total_val，因此无法作出判断。要让程序知道存储的数据最直接的方式是让方法返回一个值。
为此，通常使用内联代码，如下例所示：
class Stock
{
private:
double total_val;
public:
   double total() const {return total_val;}
}
通过将该函数添加到类声明中，可以让程序查看一系列股票，找到价格最高的那一支。
然而，可以采用另一种方法，定义一个成员函数，它查看两个Stock对象，并返回股价较高的那个对象的引用。
实现这种方法时，将出现一些有趣的问题，下面就来讨论这些问题。
首先，如何将两个要比较的对象提供给成员函数呢？
例如，假设将该方法命名为topval，将第二个对象作为参数传递给它，可以按引用来传递参数。
其次，让方法返回一个引用，该引用指向股价总值较高的对象。因此，用于比较的方法的原型如下：
const Stock & topval (const Stock & s) const;
该函数隐式地访问一个对象，而显式地访问另一个对象，并返回其中一个对象的引用。
括号中的const表明，该函数不会修改被显式地访问的对象；而括号后的const表明，该函数不会修改被隐式地访问的对象。
由于该函数返回了两个const对象之一的引用，因此返回类型也应为const引用。
假设要对Stock对象stock1和stock2进行比较，并将其中股价总值较高的那一个赋给top对象，则可以使用下面两条语句之一
top = stock1.topval(stock2);
top = stock2.topval(stock1);
this指针指向用来调用成员函数的对象（this被作为隐藏参数传递给方法）。
这样，函数调用stock1.topval(stock2)将this设置为stock1对象的地址，使得这个指针可用于topval方法。
同样，函数调用stock2.topval(stock1)将this设置为stock2对象的地址。
一般来说，所有的类方法都将this指针设置为调用它的对象的地址。
每个成员函数（包括构造函数和析构函数）都有一个this指针。this指针指向调用对象。
如果方法需要引用整个调用对象，则可以使用表达式*this.。
在函数的括号后面使用const限定符将this限定为const，这样将不能使用this来修改对象的值。
程序清单10.7 stock20.h
#pragma once
#ifndef STOCK20_H_
#define STOCK20_H_ 
#include <string> 

class Stock
{
private:
	std::string company;
	int shares;
	double share_val;
	double total_val;
	void set_tot() { total_val = shares * share_val; }
public:
	Stock();
	Stock(const std::string & co, long n = 0, double pr = 0.0);
	~Stock();
	void buy(long num, double price);
	void sell(long num, double price);
	void update(double price);
	void show() const;
	const Stock & topval(const Stock & s) const;
};

#endif

程序清单10.8 stock20.cpp
#include <iostream>
#include "stock20.h"

Stock::Stock()
{
    std::cout << "Default constructor called\n";
    company = "no name";
    shares = 0;
    share_val = 0.0;
    total_val = 0.0;
}
Stock::Stock(const std::string & co, long n, double pr)
{
    std::cout << "Constructor using " << co << " called\n";
    company = co;
    if (n < 0)
    {
        std::cout << "Number of shares can't be negative; " << company << " shares set to 0.\n";
        shares = 0;
    }
    else
    {
        shares = n;
    }

    share_val = pr;
    set_tot();
}

Stock::~Stock()
{
    std::cout << "Bye, " << company << "!\n";
}

void Stock::buy(long num, double price)
{
    if (num < 0)
    {
        std::cout << "Number of shares purchased can't be negative. " << "Transaction is aborted.\n";
    }
    else
    {
        shares += num;
        share_val = price;
        set_tot();
    }
}

void Stock::sell(long num, double price)
{
    using std::cout;
    if (num < 0)
    {
        cout << "Number of shares sold can't be negative. " << "Transaction is aborted.\n";
    }
    else if (num > shares)
    {
        cout << "You can't sell more than you have! " << "Transaction is aborted.\n";
    }
    else
    {
        shares -= num;
        share_val = price;
        set_tot();
    }
}
void Stock::update(double price)
{
    share_val = price;
    set_tot();
}
void Stock::show() const
{
    using std::cout;
    using std::ios_base;
    ios_base::fmtflags orig = cout.setf(ios_base::fixed, ios_base::floatfield);
    std::streamsize prec = cout.precision(3);
    cout << "Company: " << company << ", Shares: " << shares << '\n';
    cout << "Share Price: $" << share_val;
    cout.precision(2);
    cout << ", Total Worth: $" << total_val << '\n';
    cout.setf(orig, ios_base::floatfield);
    cout.precision(prec);
}

const Stock &Stock::topval(const Stock &s) const
{
    if (s.total_val > total_val)
    {
        return s;
    }
    else
    {
        return *this;
    }
}
10.5对象数组
声明对象数组的方法与声明标准类型数组相同：
Stock mystuff[4];
当程序创建未被显式初始化的类对象时，总是调用默认构造函数。
上述声明要求，这个类要么没有显式地定义任何构造函数（在这种情况下，将使用不执行任何操作的隐式默认构造函数），
要么定义了一个显式默认构造函数（就像这个例子那样）。
每个元素（mystuff[0]，mystuff[1]）都是Stock对象，可以使用Stock方法。
可以用构造函数来初始化数组元素。在这种情况下，必须为每个元素调用构造函数：
const int STKS = 4;
stock stocks[STKS] = {
Stock ("NanoSmart", 12.5, 20),
Stock ("Boffo Objects", 200, 2.0),
Stock ("Monolithic Obelisks", 130, 3.25),
Stock ("Fleep Enterprises", 60, 6.5)
};
如果类包含多个构造函数，则可以对不同的元素使用不同的构造函数：
const int STKS = 10;
stock stocks[STKS] = {
Stock ("NanoSmart", 12.5, 20),
Stock (),
Stock ("Monolithic Obelisks", 130, 3.25)
};
上述代码使用Stock(const std::string & co, long n = 0, double pr = 0.0)初始化stock[0]和stock[2]，
使用构造函数Stock()初始化stock[1]。由于该声明只初始化了数组的部分元素，
因此余下的7个元素将使用默认构造函数进行初始化。
初始化对象数组的方案是，首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，
然后将临时对象的内容复制到相应的元素中。因此，要创建类对象数组，则这个类必须有默认构造函数。
程序清单10.9 usestock20.cpp
#include <iostream>
#include "stock20.h"

const int STKS = 4;

int main()
{
    Stock stocks[STKS] =
    {
        Stock("NanoSmart", 12, 20.0),
        Stock("Boffo Objects", 200, 2.0),
        Stock("Monolithic Obelisks", 130, 3.25),
        Stock("Fleep Enterprises", 60, 6.5)
    };

    std::cout << "Stock holdings:\n";
    int st;
    for (st = 0; st < STKS; st++)
    {
        stocks[st].show();
    }
    const Stock *top = &stocks[0];
    for (st = 1; st < STKS; st++)
    {
        top = & ( top->topval(stocks[st]) );
    }
    std::cout << "\nMost valuable holding:\n";
    top->show();

    return 0;
}
显示结果如下
Constructor using NanoSmart called
Constructor using Boffo Objects called
Constructor using Monolithic Obelisks called
Constructor using Fleep Enterprises called
Stock holdings:
Company: NanoSmart, Shares: 12
Share Price: $20.000, Total Worth: $240.00
Company: Boffo Objects, Shares: 200
Share Price: $2.000, Total Worth: $400.00
Company: Monolithic Obelisks, Shares: 130
Share Price: $3.250, Total Worth: $422.50
Company: Fleep Enterprises, Shares: 60
Share Price: $6.500, Total Worth: $390.00

Most valuable holding:
Company: Monolithic Obelisks, Shares: 130
Share Price: $3.250, Total Worth: $422.50
Bye, Fleep Enterprises!
Bye, Monolithic Obelisks!
Bye, Boffo Objects!
Bye, NanoSmart!

10.6 类作用域
C++类引入了一种新的作用域：类作用域，在类中定义的名称（如类数据成员名和类成员函数名）的作用域都为整个类，
作用域为整个类的名称只在该类中是已知的，在类外是不可知的。
因此，可以在不同类中使用相同的类成员名而不会引起冲突。
另外，类作用域意味着不能从外部直接访问类的成员，公有成员函数也是如此。
也就是说，要调用公有成员函数，必须通过对象。同样，在定义成员函数时，必须使用作用域解析运算符。
总之，在类声明或成员函数定义中，可以使用未修饰的成员名称。
构造函数名称在被调用时，才能被识别，因为它的名称与类名相同。
在其他情况下，使用类成员名时，必须根据上下文使用直接成员运算符（.）、间接成员运算符（->）或作用域解析运算符（：）。
10.6.1 作用域为类的常量
有时候，使符号常量的作用域为类很有用。有两种方式可以实现这个目标，并且效果相同。
第一种方式是在类中声明一个枚举。在类声明中声明的枚举的作用域为整个类，
因此可以用枚举为整型常量提供作用域为整个类的符号名称。
注意，用这种方式声明枚举并不会创建类数据成员。也就是说，所有对象中都不包含枚举。
由于这里使用枚举只是为了创建符号常量，并不打算创建枚举类型的变量，因此不需要提供枚举名。
class Bakery
{
private:
enum {Months = 12}
double costs[Months];
...
}
顺便说一句，在很多实现中，ios_base类在其公有部分中完成了类似的工作，诸如ios base:fixed等标识符就来自这里。
其中，fixed是ios_base类中定义的典型的枚举量。
C++提供了另一种在类中定义常量的方式――使用关键字static：
class Bakery
{
private:
    static const int Months = 12;
    double costs[Months];
    ...
}
这将创建一个名为Months的常量，该常量将与其他静态变量存储在一起，而不是存储在对象中。
因此，只有一个Months常量，被所有Bakery对象共享。第12章将深入介绍静态类成员。
10.6.2 作用域内枚举（C++11）
C++11提供了一种新枚举，其枚举量的作用域为类。这种枚举的声明类似于下面这样：
enum class egg {Small, Medium, Large, Jumbo};
enum class t_shirt {Small, Medium, Large, Xlarge};
也可使用关键字struct代替class。无论使用哪种方式，都需要使用枚举名来限定枚举量
egg choice = egg::Large;
t_shirt Floyd = t_shirt::Large;
枚举量的作用域为类后，不同枚举定义中的枚举量就不会发生名称冲突了。
C++11还提高了作用域内枚举的类型安全。在有些情况下，常规枚举将自动转换为整型，
如将其赋给int变量或用于比较表达式时，但作用域内校举不能隐式地转换为整型。
但在必要时，可进行显式类型转换
int Frodo = int (t_shirt::Small);
默认情况下，C++11作用域内枚举的底层类型为int。另外，还提供了一种语法，可用于做出不同的选择：
enum class :short pizza {Small, Medium, Large, XLarge};
:short将底层类型指定为short。底层类型必须为整型。
在C++11中，也使用这种语法来指定常规校举的底层类型，但如果没有指定，编译器选择的底层类型将随实现而异。
10.7 抽象数据类型
下面简要地介绍一下栈的特征。首先，栈存储了多个数据项；其次，栈由可对它执行的操作来描述。
可创建空栈。
可将数据项添加到堆顶（压入）。
可从栈顶删除数据项（弹出）
可查看栈否填满
可查看栈是否为空。
可以将上述描述转换为一个类声明，其中公有成员函数提供了表示栈操作的接口，而私有数据成员负责存储栈数据。
私有部分表明数据存储的方式。例如，可以使用常规数组、动态分配数组或更高级的数据结构（如链表），
然而，公有接口应隐藏数据表示，而以通用的术语来表达，如创建栈、压入等。
程序清单10.10 stack.h
#pragma once
#ifndef STACK_H_
#define STACK_H_

typedef unsigned long Item;

class Stack
{
private:
    enum { MAX = 10 };
    Item items[MAX];
    int top;
public:
    Stack();
    bool isempty() const;
    bool isfull() const;
    bool push(const Item &item);
    bool pop(Item &item);
};

#endif

程序清单10.11 stack.cpp
#include <iostream>
#include "stack.h"

Stack::Stack()
{
    top = 0;
}

bool Stack::isempty() const
{
    return top == 0;
}

bool Stack::isfull() const
{
    return top == MAX;
}

bool Stack::push(const Item &item)
{
    if (top < MAX)
    {
        items[top++] = item;
        return true;
    }
    else
    {
        return false;
    }
}

bool Stack::pop(Item &item)
{
    if (top > 0)
    {
        item = items[--top];
        return true;
    }
    else
    {
        return false;
    }
}

程序清单10.12 stacker.cpp
#include <iostream>
#include <cctype>
#include "stack.h"

int main()
{
    using namespace std;
    Stack st;
    char ch;
    unsigned long po;
    cout << "Please enter A to add a purchase order,\n"
         << "P to process a purchase order, or Q to quit.\n";
    while (cin >> ch && toupper(ch) != 'Q')
    {
        while (cin.get() != '\n')
        {
            continue;
        }
        if (!isalpha(ch))
        {
            cout << "Please enter A, P, Q\n";
            continue;
        }
        switch (ch)
        {
        case 'A':
        case 'a':
            cout << "Enter a purchase order number to add: ";
            cin >> po;
            if (st.isfull())
            {
                cout << "stack already full\n";
            }
            else
            {
                st.push(po);
            }
            break;
        case 'P':
        case 'p':
            if (st.isempty())
            {
                cout << "stack already empty\n";
            }
            else
            {
                st.pop(po);
                cout << "purchase order #" << po << " popped\n";
            }
            break;
        default :
            cout << "Please enter A, P, Q\n";
            continue;
            break;
        }
        cout << "Please enter A to add a purchase order,\n"
             << "P to process a purchase order, or Q to quit.\n";
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
A
Enter a purchase order number to add: 123
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
A
Enter a purchase order number to add: 456
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
A
Enter a purchase order number to add: 789
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
P
purchase order #789 popped
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
P
purchase order #456 popped
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
A
Enter a purchase order number to add: 666
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
P
purchase order #666 popped
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
P
purchase order #123 popped
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
P
stack already empty
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
Q
Done.

10.8 总结
面向对象编程强调的是程序如何表示数据。使用OOP方法解决编程问题的第一步是根据它与程序之间的接口来描述数据，从而指定如何使用数据。
然后，设计一个类来实现该接口。一般来说，私有数据成员存储信息，公有成员函数（又称为方法）提供访问数据的唯一途径。
类将数据和方法组合成一个单元，其私有性实现数据隐藏。
通常，将类声明分成两部分组成，这两部分通常保存在不同的文件中。
类声明（包括由函数原型表示的方法）应放到头文件中。定义成员函数的源代码放在方法文件中。这样便将接口描述与实现细节分开了。
从理论上说，只需知道公有接口就可以使用类。当然，可以查看实现方法（除非只提供了编译形式），但程序不应依赖于其实现细节。
只要程序和类只通过定义接口的方法进行通信，程产员就可以随意地对任何部分做独立的改进，而不必担心这样做会导致意外的不良影响。
类是用户定义的类型，对象是类的实例。这意味着对象是这种类型的变量，例如由new按类描述分配的内存。
C++试图让用户定义的类型尽可能与标准类型类似，因此可以声明对象、指向对象的指针和对象数组。
可以按值传递对象、将对象作为函数返回值、将一个对象赋给同类型的另一个对象。
如果提供了构造函数，则在创建对象时，可以初始化对象。如果提供了析构函数方法，则在对象消亡后，程序将执行该函数。
每个对象都存储自己的数据，而共享类方法。如果mr_object是对象名，try_me是成员函数，
则可以使用成员运算符句点调用成员函数：mr_object.try me()。
在try_me方法中引用类数据成员时，将使用mr_object对象相应的数据成员。
同样，函数调用i_object.try_me()将访问i_object对象的数据成员。
如果希望成员函数对多个对象进行操作，可以将额外的对象作为参数传递给它。
如果方法需要显式地引用调用它的对象，则可以使用this指针。
由于this指针被设置为调用对象的地址，因此*this是该对象的别名。
类很适合用于描述ADT，公有成员函数接口提供了ADT描述的服务，
类的私有部分和类方法的代码提供了实现，这些实现对类的客户隐藏。
10.9 复习题
1.什么是类？
类是用户定义的类型，类声明指定了数据将如何存储，同时指定了用来访问和操纵这些数据的方法（类成员函数）。

2.类如何实现抽象、封装和数据隐藏？
类提供了完成对应任务的公有接口（类成员函数），这是抽象。
类的数据成员是私有的，只能通过公有接口（类成员函数）来访问这些数据，这是数据隐藏。
类实现的具体细节（如数据表示和方法的代码）都是隐藏的，这是封装。

3.对象和类之间的关系是什么？
类是用户定义的类型，对象是根据类定义被创建出来的变量。
类和对象之间的关系同标准类型与其变量之间的关系相同。

4.除了是函数之外，类函数成员与类数据成员之间的区别是什么？
如果创建给定类的多个对象，则每个对象都有其自己的数据内存空间；但所有的对象都使用同一组成员函数。

5.定义一个类来表示银行帐户。数据成员包括储户姓名、账号（使用字符串）和存款。
成员函数执行如下操作：创建一个对象并将其初始化；显示储户姓名、账号和存款；
存入参数指定的存款；取出参数指定的款项。
请提供类声明，而不用给出方法实现。
#include <string>

class BankAccount
{
private:
    std::string name;
    std::string acctnum;
    double balance;
public:
    BankAccount();
    BankAccount(const std::string &client, const std::string &num, double bal = 0.0);
    void show() const;
    void deposit (double cash);
    void withdraw (double cash);
};

6.类构造函数在何时被调用？类析构函数呢？
在创建类对象或显式调用构造函数时，类的构造函数都将被调用。
当对象过期时，类的析构函数将被调用。

7.给出复习题5中的银行账户类的构造函数的代码。
BankAccount::BankAccount()
{
    name = "no name";
    acctnum = "no acctnum";
    balance = 0;
}
BankAccount::BankAccount(const std::string &client, const std::string &num, double bal)
{
    name = client;
    acctnum = num;
    balance = bal;
}

8.什么是默认构造函数，拥有默认构造函数有何好处？
默认构造函数是没有参数或所有参数都有默认值的构造函数。
拥有默认构造函数后，可以声明对象，而不初始化它。它还使得能够声明对象数组。

9.修改Stock类的定义（stock20.h中的版本），使之包含返回各个数据成员值的成员函数。
stock30.h
#pragma once
#ifndef STOCK30_H_
#define STOCK30_H_ 
#include <string> 

class Stock
{
private:
	std::string company;
	int shares;
	double share_val;
	double total_val;
	void set_tot() { total_val = shares * share_val; }
public:
	Stock();
	Stock(const std::string & co, long n = 0, double pr = 0.0);
	~Stock();
	void buy(long num, double price);
	void sell(long num, double price);
	void update(double price);
	void show() const;
	const Stock & topval(const Stock & s) const;
              int sharenum() const {return shares;}
              double shareval() const {return share_val;}
              double totalval() const {return total_val;}
              const string & coname() const {return company;}
};

#endif

10.this和*this是什么？
this指针被设置为调用类成员函数的对象的地址，*this是该对象的别名。

10.10编程练习
1.为复习题5描述的类提供方法定义，并编写一个小程序来演示所有的特性。
bank_account.h
#pragma once
#ifndef BANK_ACCOUNT_H_
#define BANK_ACCOUNT_H_
#include <string>


class Bank_account
{
private:
    std::string name_depositor;
    std::string account_number;
    unsigned int balance;
public:
    Bank_account();
    Bank_account(const std::string &name_dep, const std::string &acc_num, double bal = 0);
    ~Bank_account();
    void show_account();
    void add_balance(double bal);
    void cash_withdrawal(double bal);
};

#endif

bank_account.cpp
#include <iostream>
#include "bank_account.h"

Bank_account::Bank_account()
{
    name_depositor = "NON";
    account_number = "000 000 000 000";
    balance = 0.0;
}

Bank_account::Bank_account(const std::string &name_dep, const std::string &acc_num, double bal)
{
    name_depositor = name_dep;
    account_number = acc_num;

    if (bal < 0)
    {
        std::cout << "The balance can not be negative. Your balance will be set to 0." << std::endl;
        balance = 0;
    }
    else
    {
        balance = bal;
    }
}

Bank_account::~Bank_account()
{
    std::cout << "All transactions with " << account_number << " completed." << std::endl;
    std::cout << std::endl;
}

void Bank_account::show_account()
{
    std::cout << "Name of depositor: " << name_depositor << std::endl;
    std::cout << "Deposit number: " << account_number << std::endl;
    std::cout << "Balance: $" << balance  << std::endl;
    std::cout << std::endl;
}

void Bank_account::add_balance(double bal)
{
    if (bal < 0)
    {
        std::cout << "The value can not be negative." << std::endl;
        std::cout << std::endl;
    }
    else
    {
        balance += bal;
        std::cout << "The balance is added with $" << bal  << std::endl;
        std::cout << std::endl;
    }
}

void Bank_account::cash_withdrawal(double bal)
{
    if (bal > balance)
    {
        std::cout << "Unable to withdraw $" << bal;
        std::cout << " On your balance sheet $" << balance << std::endl;
        std::cout << std::endl;
    }
    else
    {
        balance -= bal;
        std::cout << "Discontinued $" << bal;
        std::cout << " On your balance sheet $" << balance << std::endl;
        std::cout << std::endl;
    }
}

bank.cpp
#include <iostream>
#include "bank_account.h"

void print_menu();
void transactions_menu();

int main()
{
    Bank_account Acc;
    Acc.show_account();
    std::string name_depositor;
    std::string account_number;
    double balance = 0;
    int menu = 0;

    print_menu();
    while (std::cin >> menu && menu != 3)
    {
        while (std::cin.get() != '\n')
        {
            continue;
        }
        switch (menu)
        {
        case 1:
            std::cout << "Enter the name of the account holder: " << std::endl;
            std::getline(std::cin, name_depositor, '\n');

            std::cout << "Enter the account number: " << std::endl;
            std::getline(std::cin, account_number, '\n');

            std::cout << "Enter the current balance: " << std::endl;
            std::cin >> balance;
            while (std::cin.get() != '\n')
            {
                continue;
            }

            Acc = Bank_account(name_depositor, account_number, balance);
            menu = 0;
            print_menu();
            break;
        case 2:
            menu = 0;
            transactions_menu();
            while (std::cin >> menu && menu != 4)
            {
                while (std::cin.get() != '\n')
                {
                    continue;
                }

                switch (menu)
                {
                case 1:
                    std::cout << "Enter the amount to be added to the balance: ";
                    std::cin >> balance;
                    while (std::cin.get() != '\n')
                    {
                        continue;
                    }
                    Acc.add_balance(balance);
                    menu = 0;
                    transactions_menu();
                    break;
                case 2:
                    std::cout << "Enter the amount to be withdrawn from the balance: ";
                    std::cin >> balance;
                    while (std::cin.get() != '\n')
                    {
                        continue;
                    }
                    Acc.cash_withdrawal(balance);
                    menu = 0;
                    transactions_menu();
                    break;
                case 3:
                    Acc.show_account();
                    menu = 0;
                    transactions_menu();
                    break;
                default:
                    std::cout << "Please Enter 1 or 2 or 3 or 4\n";
                    menu = 0;
                    transactions_menu();
                    break;
                }
            }
            menu = 0;
            print_menu();
            break;
        default:
            std::cout << "Please Enter 1 or 2 or 3\n";
            menu = 0;
            print_menu();
            break;
        }
    }

    std::cout << "Done.\n";

    return 0;
}

void print_menu()
{
    std::cout << "[1] - Create an account" << std::endl;
    std::cout << "[2] - Account Operations" << std::endl;
    std::cout << "[3] - Quit" << std::endl;
}

void transactions_menu()
{
    std::cout << "[1] - Add cash" << std::endl;
    std::cout << "[2] - Withdraw cash" << std::endl;
    std::cout << "[3] - Display Information" << std::endl;
    std::cout << "[4] - Quit" << std::endl;
}
显示结果如下

Name of depositor: NON
Deposit number: 000 000 000 000
Balance: $0

[1] - Create an account
[2] - Account Operations
[3] - Quit
1
Enter the name of the account holder:
Mike Pence
Enter the account number:
222 222 222 222
Enter the current balance:
200
All transactions with 222 222 222 222 completed.

[1] - Create an account
[2] - Account Operations
[3] - Quit
2
[1] - Add cash
[2] - Withdraw cash
[3] - Display Information
[4] - Quit
3
Name of depositor: Mike Pence
Deposit number: 222 222 222 222
Balance: $200

[1] - Add cash
[2] - Withdraw cash
[3] - Display Information
[4] - Quit
1
Enter the amount to be added to the balance: 300
The balance is added with $300

[1] - Add cash
[2] - Withdraw cash
[3] - Display Information
[4] - Quit
3
Name of depositor: Mike Pence
Deposit number: 222 222 222 222
Balance: $500

[1] - Add cash
[2] - Withdraw cash
[3] - Display Information
[4] - Quit
2
Enter the amount to be withdrawn from the balance: 150
Discontinued $150 On your balance sheet $350

[1] - Add cash
[2] - Withdraw cash
[3] - Display Information
[4] - Quit
3
Name of depositor: Mike Pence
Deposit number: 222 222 222 222
Balance: $350

[1] - Add cash
[2] - Withdraw cash
[3] - Display Information
[4] - Quit
4
[1] - Create an account
[2] - Account Operations
[3] - Quit
3
Done.
All transactions with 222 222 222 222 completed.

2.下面是一个非常简单的类定义：
它使用了一个string对象和一个字符数组，让您能够比较它们的用法。
请提供未定义的方法的代码，以完成这个类的实现。
再编写一个使用这个类的程序，它使用了三种可能的构造函数调用（没有参数、一个参数和两个参数）以及两种显示方法。
person_class.h
#pragma once
#ifndef PERSON_CLASS_H_
#define PERSON_CLASS_H_
#include <string>

class Person
{
private:
    static const int LIMIT = 32;
    std::string lname;
    char fname[LIMIT];
public:
    Person()
    {
        lname = "";
        fname[0] = '\0';
    }
    Person(const std::string &In, const char *fn = "Heyyou");
    ~Person();

    void Show() const;
    void FormalShow() const;
};

#endif

person_class.cpp
#include <iostream>
#include <cstring>
#include "person_class.h"

Person::Person(const std::string &In, const char *fn)
{
    lname = In;
    strcpy(fname, fn);
}
Person::~Person()
{
    std::cout << "Bye, " << lname << ", " << fname << "!\n";
}
void Person::Show() const
{
    std::cout << fname << " " << lname << std::endl;
}
void Person::FormalShow() const
{
    std::cout << lname << ", " << fname << std::endl;
}

person.cpp
#include <iostream>
#include "person_class.h"

int main()
{
    Person one;
    Person two("Smythecraft");
    Person three = Person("Dimwiddy", "Sam");

    one.Show();
    std::cout << std::endl;
    one.FormalShow();

    std::cout << "=================" << std::endl;

    two.Show();
    std::cout << std::endl;
    two.FormalShow();

    std::cout << "=================" << std::endl;

    three.Show();
    std::cout << std::endl;
    three.FormalShow();

    return 0;
}
显示结果如下


,
=================
Heyyou Smythecraft

Smythecraft, Heyyou
=================
Sam Dimwiddy

Dimwiddy, Sam
Bye, Dimwiddy, Sam!
Bye, Smythecraft, Heyyou!
Bye, , !

3.完成第9章的编程练习1，但要用正确的golf类声明替换那里的代码。
用带合适参数的构造函数替换setgolf (golf &, const char *, int)，以提供初始值。
保留setgolt的交互版本，但要用构造函数来实现它
golf_class.h
#pragma once
#ifndef GOLF_CLASS_H_
#define GOLF_CLASS_H_

class Golf
{
private:
    static const int Len = 128;
    char fullname[Len];
    int handicap;
public:
    Golf();
    Golf(const char *name, int hc);
    ~Golf();
    int set_golf();
    void show_golf();
};

#endif

golf_class.cpp
#include <iostream>
#include <cstring>
#include "golf_class.h"

Golf::Golf()
{
    strcpy(fullname, "");
    handicap = 0;
}

Golf::Golf(const char *name, int hc)
{
    strcpy(fullname, name);
    handicap = hc;
}

Golf::~Golf()
{
    std::cout << "Bye, " << fullname << ", " << handicap << "!\n";
}

int Golf::set_golf()
{
    int name_valid = 0;

    std::cout << "Enter the player's name: ";
    std::cin.getline(fullname, Len);

    if (strlen(fullname) > 0)
    {
        name_valid = 1;
        std::cout << "Enter the player's handicap: " << std::endl;
        (std::cin >> handicap).get();
        Golf temp(fullname, handicap);
        *this = temp;
    }
    return name_valid;
}

void Golf::show_golf()
{
    std::cout << "Player name: " << fullname << std::endl;
    std::cout << "Player Handicap: " << handicap << std::endl;
}


ch10_p03.cpp
#include <iostream>
#include "golf_class.h"

int main()
{
    Golf ann;
    ann = Golf("Ann Birdfree", 24);
    ann.show_golf();

    std::cout << "Enter the number of players: ";
    int col_players = 0;
    (std::cin >> col_players).get();
    std::cout << std::endl;

    Golf *players = new Golf[col_players];
    int i;
    for (i = 0; i < col_players; i++)
    {
        if (players[i].set_golf() == 0)
        {
            break;
        }
    }

    for (int j = 0; j < i; j++)
    {
        players[j].show_golf();
    }

    delete [] players;

    return 0;
}
显示结果如下
Bye, Ann Birdfree, 24!
Player name: Ann Birdfree
Player Handicap: 24
Enter the number of players: 3

Enter the player's name: Mike Pence
Enter the player's handicap:
33
Bye, Mike Pence, 33!
Enter the player's name: Peter Smith
Enter the player's handicap:
22
Bye, Peter Smith, 22!
Enter the player's name:
Player name: Mike Pence
Player Handicap: 33
Player name: Peter Smith
Player Handicap: 22
Bye, , 0!
Bye, Peter Smith, 22!
Bye, Mike Pence, 33!
Bye, Ann Birdfree, 24!

4.完成第9章的编程练习4，但将Sales结构及相关的函数转换为一个类及其方法。
用构造函数替换setSales (sales &, double [], int)函数。用构造函数实现setSales (Sales &)方法的交互版本。
将类保留在名称空间SALES中。
sales_class.h
#pragma once
#ifndef SALES_CLASS_H_
#define SALES_CLASS_H_

namespace SALES
{
    static const int QUARTERS = 4;

    class Sales
    {
    private:
        double sales[QUARTERS];
        double average;
        double max;
        double min;
        double find_avg(const double arr[], int size);
        double find_max(const double arr[], int size);
        double find_min(const double arr[], int size);
    public:
        Sales();
        Sales(const double arr[], int n);
        ~Sales();
        void showSales();
        void setSales();
    };
}

#endif

sales_class.cpp
#include <iostream>
#include "sales_class.h"

SALES::Sales::Sales()
{
    for (int i = 0; i < QUARTERS; i++)
    {
        sales[i] = 0;
    }
    average = 0;
    max = 0;
    min = 0;
}
SALES::Sales::Sales(const double arr[], int n)
{
    for (int i = 0; i < QUARTERS; i++)
    {
        sales[i] = 0;
    }

    if (n > QUARTERS)
    {
        n = QUARTERS;
    }
    for (int i = 0; i < n; i++)
    {
        sales[i] = arr[i];
    }
    average = find_avg(sales, QUARTERS);
    max = find_max(sales, QUARTERS);
    min = find_min(sales, QUARTERS);
}
SALES::Sales::~Sales()
{

}

void SALES::Sales::setSales()
{
    for (int i = 0; i < QUARTERS; ++i)
    {
        std::cout << "Enter total sales for " << i + 1 << " quarter: ";
        std::cin >> sales[i];
    }

    average = find_avg(sales, QUARTERS);
    max = find_max(sales, QUARTERS);
    min = find_min(sales, QUARTERS);
}

void SALES::Sales::showSales()
{
    for (int i = 0; i < QUARTERS; i++)
    {
        if (i != 0)
        {
            std::cout << ", ";
        }
        std::cout << sales[i];
    }
    std::cout << std::endl;
    std::cout << "Average value: " << average << std::endl;
    std::cout << "Maximum value: " << max << std::endl;
    std::cout << "Minimum value: " << min << std::endl;
}
double SALES::Sales::find_avg(const double arr[], int size)
{
    double summ = 0;
    for (int i = 0; i < size; i++)
    {
        summ += arr[i];
    }
    return summ / size;
}

double SALES::Sales::find_max(const double arr[], int size)
{
    double max = arr[0];
    for (int i = 0; i < size; i++)
    {
        if (arr[i] > max)
        {
            max = arr[i];
        }
    }
    return max;
}
double SALES::Sales::find_min(const double arr[], int size)
{
    double min = arr[0];
    for (int i = 0; i < size; i++)
    {
        if (arr[i] < min)
        {
            min = arr[i];
        }
    }
    return min;
}

ch10_p04.cpp
#include <iostream>
#include "sales_class.h"

int main()
{
    double arr[] = { 123.12, 522.22, 455.42, 777.32 };

    SALES::Sales Struct1;
    Struct1.setSales();
    std::cout << std::endl;
    Struct1.showSales();
    std::cout << std::endl;

    SALES::Sales Struct2 (arr, SALES::QUARTERS);
    Struct2.showSales();

    return 0;
}
显示结果如下
Enter total sales for 1 quarter: 123
Enter total sales for 2 quarter: 567
Enter total sales for 3 quarter: 666
Enter total sales for 4 quarter: 222

123, 567, 666, 222
Average value: 394.5
Maximum value: 666
Minimum value: 123

123.12, 522.22, 455.42, 777.32
Average value: 469.52
Maximum value: 777.32
Minimum value: 123.12

5.考虑下面的结构声明：
struct customer
{
    char fullname[35];
    double payment;
}
编写一个程序，它从栈中添加和删除customer结构（栈用Stack类声明表示），
每次customer结构被删除时，其payment的值都被加入到总数中，并报告总数。
stack_class.h
#pragma once
#ifndef STACK_CLASS_H_
#define STACK_CLASS_H_


struct customer
{
    char fullname[36];
    double payment;
};

typedef customer Item;

class Stack
{
private:
    enum { MAX = 10 };
    Item items[MAX];
    int top;
public:
    Stack();
    bool isempty() const;
    bool isfull() const;
    bool push(const Item &item);
    bool pop(Item &item);
};

#endif

stack_class.cpp
#include <iostream>
#include "stack_class.h"

Stack::Stack()
{
    top = 0;
}
bool Stack::isempty() const
{
    return top == 0;
}
bool Stack::isfull() const
{
    return top == MAX;
}
bool Stack::push(const Item &item)
{
    if (top < MAX)
    {
        items[top++] = item;
        return true;
    }
    else
    {
        return false;
    }
}
bool Stack::pop(Item &item)
{
    if (top > 0)
    {
        item = items[--top];
        return true;
    }
    else
    {
        return false;
    }
}

ch10_p05.cpp
#include <iostream>
#include <string>
#include "stack_class.h"

int main()
{
    Stack st;
    char ch;
    customer po;
    double subtotal = 0.0;

    std::cout << "Type A to add the client,\n";
    std::cout << "P to delete the client, and Q to exit.\n";

    while (std::cin >> ch && toupper(ch) != 'Q')
    {
        while (std::cin.get() != '\n')
        {
            continue;
        }

        if (!isalpha(ch))
        {
            std::cout << "Please enter A, P, Q\n";
            continue;
        }

        switch (ch)
        {
        case 'A':
        case 'a':
            std::cout << "Enter customer name: ";
            std::cin.getline(po.fullname, 36);
            std::cout << "Enter customer payment: ";
            (std::cin >> po.payment).get();

            if (st.isfull())
            {
                std::cout << "Stack already full\n";
            }
            else
            {
                st.push(po);
            }
            break;
        case 'P':
        case 'p':
            if (st.isempty())
            {
                std::cout << "Stack already empty\n";
            }
            else
            {
                st.pop(po);
                subtotal += po.payment;
                std::cout << "Client " << po.fullname << " was deleted\n";
                std::cout << "Total customer payment : " << subtotal << '\n';
            }
            break;
        default :
            std::cout << "Please enter A, P, Q\n";
            continue;
            break;
        }
        std::cout << "Type A to add the client,\n";
        std::cout << "P to delete the client, and Q to exit.\n";
    }
    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Type A to add the client,
P to delete the client, and Q to exit.
A
Enter customer name: Mike Pence
Enter customer payment: 200
Type A to add the client,
P to delete the client, and Q to exit.
A
Enter customer name: Peter Smith
Enter customer payment: 300
Type A to add the client,
P to delete the client, and Q to exit.
A
Enter customer name: Hello World
Enter customer payment: 500
Type A to add the client,
P to delete the client, and Q to exit.
P
Client Hello World was deleted
Total customer payment : 500
Type A to add the client,
P to delete the client, and Q to exit.
P
Client Peter Smith was deleted
Total customer payment : 800
Type A to add the client,
P to delete the client, and Q to exit.
A
Enter customer name: aaaaa
Enter customer payment: 123
Type A to add the client,
P to delete the client, and Q to exit.
P
Client aaaaa was deleted
Total customer payment : 923
Type A to add the client,
P to delete the client, and Q to exit.
P
Client Mike Pence was deleted
Total customer payment : 1123
Type A to add the client,
P to delete the client, and Q to exit.
Q
Done.

6・下面是一个类声明：
请提供成员函数的定义和测试这个类的程序。
move_class.h
#pragma once
#ifndef MOVE_CLASS_H_
#define MOVE_CLASS_H_


class Move
{
private:
    mutable double x;
    mutable double y;
public:
    Move() {};
    ~Move() {};
    Move(double a = 0, double b = 0);
    void show_move() const;

    Move add(const Move &m) const;
    void reset(double a = 0, double b = 0);
};

#endif

move_class.cpp
#include <iostream>
#include "move_class.h"

Move::Move(double a, double b)
{
    x = a;
    y = b;
}
void Move::show_move() const
{
    std::cout << "X = " << x << std::endl;
    std::cout << "Y = " << y << std::endl;
}

Move Move::add(const Move &m) const
{
    x += m.x;
    y += m.y;
    return *this;
}

void Move::reset(double a, double b)
{
    x = a;
    y = b;
}

ch10_p06.cpp
#include <iostream>
#include "move_class.h"

int main()
{
    Move test_1(5, 10);
    test_1.show_move();

    test_1.add(test_1);
    test_1.show_move();

    test_1.reset();
    test_1.show_move();

    test_1.reset(10.0, 20.0);
    test_1.show_move();

    Move test_2(25.0, 25.0);
    test_2.show_move();

    test_2.add(test_1);
    test_2.show_move();

    return 0;
}
显示结果如下

X = 5
Y = 10
X = 10
Y = 20
X = 0
Y = 0
X = 10
Y = 20
X = 25
Y = 25
X = 35
Y = 45

7.Betelgeusean plorg有这些特征
数据：plorg的名称不超过19个字符；
plorg有满意指数（CI），这是一个整数。
操作：
新的plorg：将有名称，其CI值为50
plorg的CI可以修改；
plorg可以报告其名称和CI；
plorg的默认名称为"Plorga"。
请编写一个Plorg类声明（包括数据成员和成员函数原型）来表示plorg，并编写成员函数的函数定义。
然后编写一个小程序，以演示Plorg类的所有特性。
plorg_class.h
#pragma once
#ifndef PLORG_CLASS_H_
#define PLORG_CLASS_H_


class Plorg
{
private:
    static const int SIZE = 32;
    char name_plorg[SIZE];
    int ci;
public:
    Plorg(const char *name = "Plorga", int index = 50);
    void change_ci(char action, int index);
    void show_data() const;
};

#endif

plorg_class.cpp
#include <iostream>
#include <cstring>
#include "plorg_class.h"


Plorg::Plorg(const char *name, int index)
{
    strcpy(name_plorg, name);
    ci = index;
}

void Plorg::change_ci(char action, int index)
{
    switch (action)
    {
    case '+':
        ci += index;
        break;
    case '-':
        ci -= index;
        break;
    default:
        std::cout << "You can only use \"+\" or \"-\"" << std::endl;
        break;
    }
}

void Plorg::show_data() const
{
    std::cout << "Plorg name: " << name_plorg << std::endl;
    std::cout << "CI (contentment index): " << ci << std::endl;
}

ch10_p07.cpp
#include <iostream>
#include "plorg_class.h"


int main()
{
    Plorg Girl;
    Girl.show_data();

    Plorg Man ("Hann", 300);
    Man.show_data();

    Man.change_ci('-', 125);
    Man.show_data();

    Man.change_ci('+', 200);
    Man.show_data();

    Man.change_ci('|', 200);
    Man.show_data();

    return 0;
}
显示结果如下
Plorg name: Plorga
CI (contentment index): 50
Plorg name: Hann
CI (contentment index): 300
Plorg name: Hann
CI (contentment index): 175
Plorg name: Hann
CI (contentment index): 375
You can only use "+" or "-"
Plorg name: Hann
CI (contentment index): 375

8.可以将简单列表描述成下面这样：
可存储0或多个某种类型的列表；
可创建空列表
可在列表中添加数据项；
可确定列表是否为空；
可确定列表是否为满；
可访问列表中的每一个数据项，并对它执行某种操作。
可以看到，这个列表确实很简单，例如，它不允许插入或删除数据项。
请设计一个List类来表示这种抽象类型。您应提供头文件list.h和实现文件list.cpp，
前者包含类定义后者包含类方法的实现。您还应创建一个简短的程序来使用这个类。
该列表的规范很简单，这主要旨在简化这个编程练习。可以选择使用数组或链表来实现该列表，
但公有接口不应依赖于所做的选择。也就是说，公有接口不应有数组索引、节点指针等。
应使用通用概念来表达创建列表、在列表中添加数据项等操作。
对于访问数据项以及执行操作，通常应使用将函数指针作为参数的函数来处理：
void visit (void (*pf) (Item&) );
其中，pf指向一个将Item引用作为参数的函数（不是成员函数），Item是列表中数据项的类型。
visit函数将该函数用于列表中的每个数据项。
list.h
#pragma once
#ifndef LIST_H_
#define LIST_H_
#include <string>


static const int MAX = 5;

class List
{
private:
    std::string items[MAX];
    int top;
public:
    List();
    ~List();
    bool isempty() const;
    bool isfull() const;
    bool add_element(const std::string &item);
    void visit_element(void (*pf)(std::string &));
    void show_list();
    void reset_list();
};

#endif

list.cpp
#include <iostream>
#include "list.h"

List::List()
{
    for (int i = 0; i < MAX; i++)
    {
        items[i] = "";
    }
    top = 0;
}

List::~List()
{
    std::cout << "Working with the list is complete" << std::endl;
}

bool List::isempty() const
{
    if (top == 0)
    {
        std::cout << "The list is empty" << std::endl;
    }
    return top == 0;
}

bool List::isfull() const
{
    if (top == MAX)
    {
        std::cout << "The list is full" << std::endl;
    }
    return top == MAX;
}

bool List::add_element(const std::string &item)
{
    if (top < MAX)
    {
        items[top++] = item;
        return true;
    }
    else
    {
        return false;
    }
}

void List::visit_element(void(*pf)(std::string &))
{
    for (int i = 0; i < top; ++i)
    {
        (*pf)(items[i]);
    }
}
void List::show_list()
{
    for (int i = 0; i < top; i++)
    {
        std::cout << "Value " << i + 1 << " : " << items[i] << std::endl;
    }
}

void List::reset_list()
{
    top = 0;
}

ch10_p08.cpp
#include <iostream>
#include <cstring>
#include "list.h"


void some_func1(std::string &str);
void some_func2(std::string &str);

int main()
{
    List Game;

    std::string games[MAX] =
    {
        "Dota 2",
        "CS:GO",
        "PRAY",
        "ArcheAge",
        "Loong online"
    };


    for (int i = 0; i < MAX; i++)
    {
        Game.add_element(games[i]);
    }


    Game.show_list();
    std::cout << '\n';
    Game.visit_element(some_func1);
    Game.show_list();
    std::cout << '\n';

    Game.visit_element(some_func2);
    Game.show_list();

    return 0;
}

void some_func1(std::string &str)
{
    int size = str.size();
    for (int i = 0; i < size; ++i)
    {
        str[i] = toupper(str[i]);
    }
}

void some_func2(std::string &str)
{
    int size = str.size();
    for (int i = 0; i < size; ++i)
    {
        str[i] = tolower(str[i]);
    }
}
显示结果如下
Value 1 : Dota 2
Value 2 : CS:GO
Value 3 : PRAY
Value 4 : ArcheAge
Value 5 : Loong online

Value 1 : DOTA 2
Value 2 : CS:GO
Value 3 : PRAY
Value 4 : ARCHEAGE
Value 5 : LOONG ONLINE

Value 1 : dota 2
Value 2 : cs:go
Value 3 : pray
Value 4 : archeage
Value 5 : loong online
Working with the list is complete

第11章 使用类
11.1 运算符重载
11.2 计算时间：一个运算符重载示例.
11.2.1 添加加法运算符
11.2.2 重载限制
11.2.3 其他重载运算符
11.3 友元
11.3.1 创建友元
11.3.2 常用的友元：重载<<运算符
11.4 重载运算符：作为成员函数还是非成员函数
11.5 再谈重载：一个矢量类
11.5.1 使用状态成员
11.5.2 为Vector类重载算术运算符
11.5.3 对实现的说明
11.5.4 使用Vector类来模拟随机漫步
11.6类的自动转换和强制类型转换
11.6.1 转换函数
11.6.2 转换函数和友元函数
11.7 总结
11.8 复习题
11.9 编程练习
本章内容包括：
运算符重载。
友元函数
重载<<运算符，以便用于输出。
状态成员。
使用rand生成随机值。
类的自动转换和强制类型转换。
类转换函数。
11.1 运算符重载
C++根据操作数的数目和类型来决定采用哪种操作。
要重载运算符，需使用被称为运算符函数的特殊函数形式。运算符函数的格式如下：
operator op (argument-list)
例如，operator + ()重载+运算符，operator * ()重载*运算符。
op必须是有效的C++运算符，不能虚构一个新的符号。
operator[] () 函数将重载[]运算符，因为[]是数组索引运算符。
例如，假设有一个Salesperson类，并为它定义了一个operator + ()成员函数，以重载+运算符，
以便能够将两个Saleperson对象的销售额相加，则如果district2、sid和sara都是Salesperson类对象，便可以编写这样的等式：
district2 = sid + sara;
编译器发现，操作数是Salesperson类对象，因此使用相应的运算符函数替换上述运算符：
district2 = sid.operator+(sara);
程序清单11.1 mytime0.h
#pragma once
#ifndef MYTIME0_H_
#define MYTIME0_H_

class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    Time Sum(const Time &t) const;
    void Show() const;
};

#endif

程序清单11.2 mytime0.cpp
#include <iostream>
#include "mytime0.h"


Time::Time()
{
    hours = minutes = 0;
}

Time::Time(int h, int m)
{
    hours = h;
    minutes = m;
}

void Time::AddMin(int m)
{
    minutes += m;
    hours += minutes / 60;
    minutes %= 60;
}
void Time::AddHr(int h)
{
    hours += h;
}

void Time::Reset(int h, int m)
{
    hours = h;
    minutes = m;
}
Time Time::Sum(const Time &t) const
{
    Time sum;
    sum.minutes = minutes + t.minutes;
    sum.hours = hours + t.hours + sum.minutes / 60;
    sum.minutes %= 60;
    return sum;
}

void Time::Show() const
{
    std::cout << hours << " hours, " << minutes << " minutes";
}

程序清单11.3 usetime0.cpp
#include <iostream>
#include "mytime0.h"

int main()
{
	using std::cout;
	using std::endl;
	
	Time planning;
	Time coding(2, 40);
	Time fixing(5, 55);
	Time total;
	cout << "planning time = ";
	planning.Show();
	cout << endl;
	cout << "coding time = ";
	coding.Show();
	cout << endl;
	cout << "fixing time = ";
	fixing.Show();
	cout << endl;
	total = coding.Sum(fixing);
	cout << "coding.Sum (fixing) = ";
	total.Show();
	cout << endl;

	return 0;
}
显示结果如下
planning time = 0 hours, 0 minutes
coding time = 2 hours, 40 minutes
fixing time = 5 hours, 55 minutes
coding.Sum (fixing) = 8 hours, 35 minutes

程序清单11.4 mytime1.h
#pragma once
#ifndef MYTIME1_H_
#define MYTIME1_H_

class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    Time operator+(const Time &t) const;
    void Show() const;
};

#endif

程序清单11.5 mytime1.cpp
#include <iostream>
#include "mytime1.h"

Time::Time()
{
    hours = minutes = 0;
}

Time::Time(int h, int m)
{
    hours = h;
    minutes = m;
}

void Time::AddMin(int m)
{
    minutes += m;
    hours += minutes / 60;
    minutes %= 60;
}

void Time::AddHr(int h)
{
    hours += h;
}

void Time::Reset(int h, int m)
{
    hours = h;
    minutes = m;
}

Time Time::operator+(const Time &t) const
{
    Time sum;
    sum.minutes = minutes + t.minutes;
    sum.hours = hours + t.hours + sum.minutes / 60;
    sum.minutes %= 60;
    return sum;
}

void Time::Show() const
{
    std::cout << hours << " hours, " << minutes << " minutes";
}

程序清单11.6 usetime1.cpp
#include <iostream>
#include "mytime1.h"

int main()
{
    using std::cout;
    using std::endl;

    Time planning;
    Time coding(2, 40);
    Time fixing(5, 55);
    Time total;
    cout << "planning time = ";
    planning.Show();
    cout << endl;
    cout << "coding time = ";
    coding.Show();
    cout << endl;
    cout << "fixing time = ";
    fixing.Show();
    cout << endl;
    total = coding + fixing;
    cout << "coding + fixing = ";
    total.Show();
    cout << endl;
    Time morefixing(3, 28);
    cout << "more fixing time = ";
    morefixing.Show();
    cout << endl;
    total = morefixing.operator + (total);
    cout << "morefixing.operator+(total) = ";
    total.Show();
    cout << endl;

    return 0;
}
显示结果如下
planning time = 0 hours, 0 minutes
coding time = 2 hours, 40 minutes
fixing time = 5 hours, 55 minutes
coding + fixing = 8 hours, 35 minutes
more fixing time = 3 hours, 28 minutes
morefixing.operator+(total) = 12 hours, 3 minutes

下面详细介绍C++对用户定义的运算符重载的限制。
重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符。
因此，不能将减法运算符重载为计算两个double值的和，而不是它们的差。
虽然这种限制将对创造性有所影响，但可以确保程序正常运行。
使用运算符时不能违反运算符原来的句法规则。同样，不能修改运算符的优先级。
因此，如果将加号运算符重载成将两个类相加，则新的运算符与原来的加号具有相同的优先级。
不能创建新运算符。
不能重载下面的运算符
sizeof 运算符。
.* 成员指针运算符
->* 成员指针运算符
:: 作用域解析运算符，
? : 条件运算符。
typeid ―个RTTI运算符。
const_cast 强制类型转换运算符。
dynamic_cast 强制类型转换运算符。
reinterpret_cast 强制类型转换运算符。
static_cast 强制类型转换运算符。

成员指针是什么？是指向一个类中某个成员的指针。注意是直接指向，不是通过某个对象指向的。
如果要定义一个成员指针，用这样的语法：
class cl
{
public:
    int mint;
    double get_mint(float adder)
    {
        return mint + adder;
    }
};
int cl::*fmint = &cl::mint;
double (cl::*fget)(float) = &cl::get_mint;
怎样访问成员指针所指向的内容呢？不能用*（解引用运算符）得到，而应该通过一个对象访问。格式如下：
cl c;
c.*fmint;
cl *p;
(p->*fget)(1.0f);
注意 .* 和 ->* ，它们就是成员指针运算符。再注意访问函数时加的括号，它们是必须的，因为 .* 和 ->* 的优先级低于 () 。

表11.1中的大多数运算符都可以通过成员或非成员函数进行重载，但下面的运算符只能通过成员函数进行重载。
= 赋值运算符。
() 函数调用运算符。
[] 下标运算符。
-> 通过指针访问类成员的运算符。

表11.1
+ - * / % ^ & | ~ ! && || < > == <= >= !=
<< >> ++ -- , new delete new [] delete []
^= &= |= ~= += -= *= /= %= >>= <<=

程序清单11.7 mytime2.h
#pragma once
#ifndef MYTIME2_H_
#define MYTIME2_H_

class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    Time operator+(const Time &t) const;
    Time operator-(const Time &t) const;
    Time operator*(double n) const;
    void Show() const;
};

#endif

程序清单11.8 mytime2.cpp
#include <iostream>
#include "mytime2.h"

Time::Time()
{
    hours = minutes = 0;
}

Time::Time(int h, int m)
{
    hours = h;
    minutes = m;
}

void Time::AddMin(int m)
{
    minutes += m;
    hours += minutes / 60;
    minutes %= 60;
}

void Time::AddHr(int h)
{
    hours += h;
}

void Time::Reset(int h, int m)
{
    hours = h;
    minutes = m;
}

Time Time::operator+(const Time &t) const
{
    Time sum;
    sum.minutes = minutes + t.minutes;
    sum.hours = hours + t.hours + sum.minutes / 60;
    sum.minutes %= 60;
    return sum;
}

Time Time::operator-(const Time &t) const
{
    Time diff;
    int tot1, tot2;
    tot1 = t.minutes + 60 * t.hours;
    tot2 = minutes + 60 * hours;
    diff.minutes = (tot2 - tot1) % 60;
    diff.hours = (tot2 - tot1) / 60;
    return diff;
}

Time Time::operator*(double mult) const
{
    Time result;
    long totalminutes = hours * mult * 60 + minutes * mult;
    result.hours = totalminutes / 60;
    result.minutes = totalminutes % 60;
    return result;
}

void Time::Show() const
{
    std::cout << hours << " hours, " << minutes << " minutes";
}

程序清单 11.9 usetime2.cpp
#include <iostream>
#include "mytime2.h"

int main()
{
    using std::cout;
    using std::endl;

    Time weeding(4, 35);
    Time waxing(2, 47);
    Time total;
    Time diff;
    Time adjusted;
    cout << "weeding time = ";
    weeding.Show();
    cout << endl;
    cout << "waxing time = ";
    waxing.Show();
    cout << endl;
    cout << "total work time = ";
    total = weeding + waxing;
    total.Show();
    cout << endl;
    diff = weeding - waxing;
    cout << "weeding time - waxing time = ";
    diff.Show();
    cout << endl;
    adjusted = total * 1.5;
    cout << "adjusted work time = ";
    adjusted.Show();
    cout << endl;

    return 0;
}
显示结果如下
weeding time = 4 hours, 35 minutes
waxing time = 2 hours, 47 minutes
total work time = 7 hours, 22 minutes
weeding time - waxing time = 1 hours, 48 minutes
adjusted work time = 11 hours, 3 minutes

11.3友元
C++控制对类对象私有部分的访问。通常，公有类方法提供唯一的访问途径。
C++提供了另外一种形式的访问权限：友元。友元有3种：友元函数；友元类；友元成员函数。
通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。
下面介绍友元函数，其他两种友元将在第15章介绍。
在为类重载二元运算符时（带两个参数的运算符）常常需要友元。
在前面的Time类示例中，重载的乘法运算符与其他两种重载运算符的差别在于，它使用了两种不同的类型。
也就是说，加法和减法运算符都结合两个Time值，而乘法运算符将一个Time值与一个double值结合在一起。
A=B*2.75;
将被转换为下面的成员函数调用：
A = B.operator*(2.75);
但下面的语句又如何呢？
A=2.75*B;
左侧的操作数应是调用对象，但2.75不是对象。因此，编译器不能使用成员函数调用来替换该表达式。
解决这个难题的一种方式是非成员函数（记住，大多数运算符都可以通过成员或非成员函数来重载）。
非成员函数不是由对象调用的，它使用的所有值（包括对象）都是显式参数。这样，编译器能够将下面的表达式：
A= 2.75*B;
与下面的非成员函数调用匹配：
A = operator*(2.75, B);
该函数的原型如下：
Time operator*(double m, const Time &t);
对于非成员重载运算符函数来说，运算符表达式左边的操作数对应于运算符函数的第一个参数，
运算符表达式右边的操作数对应于运算符函数的第二个参数。
非成员函数不能直接访问类的私有数据，至少常规非成员函数不能访问。
然而，有一类特殊的非成员函数可以访问类的私有成员，它们被称为友元函数。
11.3.1 创建友元
创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend：
friend Time operator*(double m, const Time &t);
该原型意味着下面两点：
虽然operator*()函数是在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用；
虽然operator*()函数不是成员函数，但它与成员函数的访问权限相同。
第二步是编写函数定义。因为它不是成员函数，所以不要使用Time::限定符。
另外，不要在定义中使用关键字friend，定义应该如下
Time operator*(double mult, const Time &t)
{
    Time result;
    long totalminutes = t.hours * mult * 60 + t.minutes * mult;
    result.hours = totalminutes/60;
    result.minutes = totalminutes%60;
    return result;
}
有了上述声明和定义后，下面的语句
A = 2.75 * B;
将转换为如下语句，从而调用刚才定义的非成员友元函数
A = operator*(2.75, B);
总之，类的友元函数是非成员函数，其访问权限与成员函数相同。
实际上，按下面的方式对定义进行修改（交换乘法操作数的顺序），可以将这个友元函数编写为非友元函数：
Time operator*(double m, const Time & t)
{
    return t * m;
}
这个版本将Time对象t作为一个整体使用，让成员函数来处理私有值，因此不必是友元。
11.3.2 常用的友元：重载<<运算符
一个很有用的类特性是，可以对<<运算符进行重载，使之能与cout一起来显示对象的内容。
与前面介绍的示例相比，这种重载要复杂些，因此我们分两步（而不是一步）来完成。
假设trip是一个Time对象。为显示Time的值，前面使用的是Show()。然而，如果可以像下面这样操作将更好：
cout << trip;
之所以可以这样做，是因为<<是可被重载的C++运算符之一。
最初<<运算符是C和C++的位运算符，将值中的位左移（参见附录E）。
ostream类对该运算符进行了重载，将其转换为一个输出工具。
cout是一个ostream对象，它能够识别所有的C++基本类型。
这是因为对于每种基本类型，ostream类声明中都包含了相应的重载的operator<<()定义。
也就是说，一个定义使用int参数，一个定义使用double参数，等等。
因此，要使cout能够识别Time对象，一种方法是将一个新的函数定义添加到ostream类声明中。
但修改iostream文件是个危险的主意，这样做会在标准接口上浪费时间。
相反，可以通过Time类声明来让Time类知道如何使用cout。
1.<<的第一种重载版本
要使Time类知道使用cout，必须使用友元函数。这是什么原因呢？
因为下面这样的语句使用两个对象，其中第一个是ostream类对象（cout）：
cout << trip;
如果使用一个Time成员函数来重载<<，Time对象将是第一个操作数，就像使用成员函数重载*运算符那样。
这意味着必须这样使用<<：
trip << cout;
这样会令人迷惑。但通过使用友元函数，可以像下面这样重载运算符：
void operatore<<(ostream & os, const Time &t)
{
    os << t.hours << " hours, " << t.minutes << " minutes";
}
这样可以使用下面的语句：
cout << trip;
友元还是非友元？
新的Time类声明使operator<<()函数成为Time类的一个友元函数。
因为operator<<()直接访问Time对象的私有成员，所以它必须是Time类的友元。
但由于它并不直接访问ostream对象的私有成员，所以并不一定必须是ostream类的友元。
注意，新的operator<<()定义使用ostream引用os作为它的第一个参数。
通常情况下，os引用cout对象，如表达式cout <<trip所示。但也可以将这个运算符用于其他ostream对象，
在这种情况下，os将引用相应的对象。
2.<<的第二种重载版本
前面介绍的实现存在一个问题。像下面这样的语句可以正常工作
cout << trip;
但下面的语句不可行
cout << "Trip time: " << trip << " (Tuesday)\n";
关于cout操作的一点知识，请看下面的语句：
int x = 5;
int y=8;
cout << x << y;
C++从左至右读取输出语句，意味着它等同于：
(cout << x) << y;
ostream类将operators<<()函数实现为返回一个指向ostream对象的引用。
具体地说，它返回一个指向调用对象（这里是cout）的引用。
因此，表达式(cout << x)本身就是ostream对象cout，从而可以位于<<运算符的左侧。
可以对友元函数采用相同的方法。只要修改operator<<()函数，让它返回ostream对象的引用即可；
ostream & operator<<(ostream & os, const Time & t)
{
    os << t.hours << " hours, " << t.minutes << " minutes";
    return os;
}
只有在类声明的函数原型中才能使用friend关键字。除非函数定义也是原型，否则不能在函数定义中使用该关键字。
程序清单11.10 mytime3.h
#pragma once
#ifndef MYTIME3_H_
#define MYTIME3_H_

#include <iostream>

class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    Time operator+(const Time &t) const;
    Time operator-(const Time &t) const;
    Time operator*(double n) const;
    friend Time operator*(double m, const Time &t)
    {
        return t * m;
    }
    friend std::ostream &operator<<(std::ostream &os, const Time &t);
};

#endif

程序清单11.11 mytime3.cpp
#include <iostream>
#include "mytime3.h"

Time::Time()
{
    hours = minutes = 0;
}

Time::Time(int h, int m)
{
    hours = h;
    minutes = m;
}

void Time::AddMin(int m)
{
    minutes += m;
    hours += minutes / 60;
    minutes %= 60;
}

void Time::AddHr(int h)
{
    hours += h;
}

void Time::Reset(int h, int m)
{
    hours = h;
    minutes = m;
}

Time Time::operator+(const Time &t) const
{
    Time sum;
    sum.minutes = minutes + t.minutes;
    sum.hours = hours + t.hours + sum.minutes / 60;
    sum.minutes %= 60;
    return sum;
}

Time Time::operator-(const Time &t) const
{
    Time diff;
    int tot1, tot2;
    tot1 = t.minutes + 60 * t.hours;
    tot2 = minutes + 60 * hours;
    diff.minutes = (tot2 - tot1) % 60;
    diff.hours = (tot2 - tot1) / 60;
    return diff;
}

Time Time::operator*(double mult) const
{
    Time result;
    long totalminutes = hours * mult * 60 + minutes * mult;
    result.hours = totalminutes / 60;
    result.minutes = totalminutes % 60;
    return result;
}

std::ostream &operator<<(std::ostream &os, const Time &t)
{
    os << t.hours << " hours, " << t.minutes << " minutes";
    return os;
}

程序清单11.12 usetime3.cpp
#include <iostream>
#include "mytime3.h"

int main()
{
    using std::cout;
    using std::endl;

    Time aida(3, 35);
    Time tosca(2, 48);
    Time temp;
    cout << "Aida and Tosca:\n";
    cout << aida << "; " << tosca << endl;
    temp = aida + tosca;
    cout << "Aida + Tosca: " << temp << endl;
    temp = aida * 1.17;
    cout << "Aida * 1.17: " << temp << endl;
    cout << "10.0 * Tosca: " << 10.0 * tosca << endl;

    return 0;
}
显示结果如下
Aida and Tosca:
3 hours, 35 minutes; 2 hours, 48 minutes
Aida + Tosca: 6 hours, 23 minutes
Aida * 1.17: 4 hours, 11 minutes
10.0 * Tosca: 28 hours, 0 minutes

11.4 重载运算特：作为成员函数还是非成员函数
对于很多运算符来说，可以选择使用成员函数或非成员函数来实现运算符重载。
一般来说，非成员函数应是友元函数，这样它才能直接访问类的私有数据。
例如，Time类的加法运算符在Time类声明中的原型如下：
Time operator+(const Time &t) const;
也可以使用下面的原型：
friend Time operator+(const Time & t1, const Time & t2);
加法运算符需要两个操作数。对于成员函数版本来说，一个操作数通过this指针隐式地传递，
另一个操作数作为函数参数显式地传递；对于友元版本来说，两个操作数都作为参数来传递。
这两个原型都与表达式T2 + T3匹配，其中T2和T3都是Time类型对象。也就是说，编译器将下面的语句：
T1 = T2+T3;
转换为下面两个的任何一个：
T1 = T2.operator+(T3);
T1 = operator+(T2, T3);
记住，在定义运算符时，必须选择其中的一种格式，而不能同时选择这两种格式。
那么哪种格式最好呢？对于某些运算符来说（如前所述），成员函数是唯一合法的选择。
在其他情况下，这两种格式没有太大的区别。有时，使用非成员函数版本可能更好（尤其是为类定义类型转换时）。
11.5再谈重载：一个矢量类
程序清单11.13 vect.h
#pragma once
#ifndef VECT_H_
#define VECT_H_
#include <cmath>
#include <iostream>

namespace VECTOR
{
    class Vector
    {
    public:
        enum Mode { RECT, POL };
    private:
        double x;
        double y;
        double mag;
        double ang;
        Mode mode;
        void set_mag();
        void set_ang();
        void set_x();
        void set_y();
    public:
        Vector();
        Vector(double n1, double n2, Mode form = RECT);
        void reset(double n1, double n2, Mode form = RECT);
        ~Vector();
        double xval() const
        {
            return x;
        }
        double yval() const
        {
            return y;
        }
        double magval() const
        {
            return mag;
        }
        double angval() const
        {
            return ang;
        }
        void polar_mode();
        void rect_mode();
        Vector operator+(const Vector &b) const;
        Vector operator-(const Vector &b) const;
        Vector operator-() const;
        Vector operator*(double n) const;
        friend Vector operator*(double n, const Vector &a);
        friend std::ostream &operator<<(std::ostream &os, const Vector &v);
    };
}

#endif

程序清单11.14 vect.cpp
#include <iostream>
#include "vect.h"

using std::sqrt;
using std::sin;
using std::cos;
using std::atan;
using std::atan2;
using std::cout;

namespace VECTOR
{
    const double Rad_to_deg = 45.0 / atan(1.0);

    void Vector::set_mag()
    {
        mag = sqrt(x * x + y * y);
    }

    void Vector::set_ang()
    {
        if (x == 0.0 && y == 0.0)
        {
            ang = 0.0;
        }
        else
        {
            ang = atan2(y, x);
        }
    }
    void Vector::set_x()
    {
        x = mag * cos(ang);
    }
    void Vector::set_y()
    {
        y = mag * sin(ang);
    }
    Vector::Vector()
    {
        x = y = mag = ang = 0.0;
        mode = RECT;
    }
    Vector::Vector(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
        {
            x = n1;
            y = n2;
            set_mag();
            set_ang();
        }
        else if (form == POL)
        {
            mag = n1;
            ang = n2 / Rad_to_deg;
            set_x();
            set_y();
        }
        else
        {
            cout << "Incorrect argument to Vector (), ";
            cout << "vector set to 0\n";
            x = y = mag = ang = 0.0;
            mode = RECT;
        }

    }
    void Vector::reset(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
        {
            x = n1;
            y = n2;
            set_mag();
            set_ang();
        }
        else if (form == POL)
        {
            mag = n1;
            ang = n2 / Rad_to_deg;
            set_x();
            set_y();
        }
        else
        {
            cout << "Incorrect argument to Vector (), ";
            cout << "vector set to 0\n";
            x = y = mag = ang = 0.0;
            mode = RECT;
        }
    }
    Vector::~Vector()
    {

    }
    void Vector::polar_mode()
    {
        mode = POL;
    }
    void Vector::rect_mode()
    {
        mode = RECT;
    }
    Vector Vector::operator+(const Vector &b) const
    {
        return Vector(x + b.x, y + b.y);
    }
    Vector Vector::operator-(const Vector &b) const
    {
        return Vector(x - b.x, y - b.y);
    }
    Vector Vector::operator-() const
    {
        return Vector(-x, -y);
    }
    Vector Vector::operator*(double n) const
    {
        return Vector(n * x, n * y);
    }
    Vector operator*(double n, const Vector &a)
    {
        return a * n;
    }
    std::ostream &operator<<(std::ostream &os, const Vector &v)
    {
        if (v.mode == Vector::RECT)
        {
            os << " (x,y) = (" << v.x << ", " << v.y << ")";
        }
        else if (v.mode == Vector::POL)
        {
            os << " (m,a) = (" << v.mag << ", " << v.ang *Rad_to_deg << " ) ";
        }
        else
        {
            os << "Vector object mode is invalid";
        }
        return os;
    }
}

程序清单11.15 randwalk.cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
#include "vect.h"

int main()
{
    using namespace std;
    using VECTOR::Vector;
    srand(time(nullptr));
    double direction;
    Vector step;
    Vector result(0.0, 0.0);
    unsigned long steps = 0;
    double target;
    double dstep;
    cout << "Enter target distance (q to quit) : ";
    while (cin >> target)
    {
        cout << "Enter step length: ";
        if (!(cin >> dstep))
        {
            break;
        }
        while (result.magval() < target)
        {
            direction = rand() % 360;
            step.reset(dstep, direction, Vector::POL);
            result = result + step;
            steps++;
        }
        cout << "After " << steps << " steps, the subject has the following location:\n";
        cout << result << endl;
        result.polar_mode();
        cout << " or\n" << result << endl;
        cout << "Average outward distance per step = " << result.magval() / steps << endl;
        steps = 0;
        result.reset(0.0, 0.0);
        cout << "Enter target distance (q to quit): ";
    }
    cout << "Done.\n";
    cin.clear();
    while (cin.get() != '\n')
    {
        continue;
    }

    return 0;
}
显示结果如下
Enter target distance (q to quit) : 50
Enter step length: 2
After 923 steps, the subject has the following location:
 (x,y) = (51.3223, -2.86578)
 or
 (m,a) = (51.4022, -3.19602 )
Average outward distance per step = 0.0556904
Enter target distance (q to quit): 50
Enter step length: 2
After 615 steps, the subject has the following location:
 (x,y) = (49.9669, -5.38278)
 or
 (m,a) = (50.256, -6.14859 )
Average outward distance per step = 0.081717
Enter target distance (q to quit): 50
Enter step length: 1
After 609 steps, the subject has the following location:
 (x,y) = (46.6646, 19.3847)
 or
 (m,a) = (50.5307, 22.5583 )
Average outward distance per step = 0.0829732
Enter target distance (q to quit): q
Done.

11.6类的自动转换和强制类型转换
将一个标准类型变量的值赋给另一种标准类型的变量时，如果这两种类型兼容，则C++自动将这个值转换为接收变量的类型。
在无法自动转换时，可以使用强制类型转换。
程序清单11.16 stonewt.h
#pragma once
#ifndef STONEWT_H_
#define STONEWT_H_

class Stonewt
{
private:
    enum { Lbs_per_stn = 14 };
    int stone;
    double pds_left;
    double pounds;
public:
    Stonewt(double lbs);
    Stonewt(int stn, double lbs);
    Stonewt();
    ~Stonewt();
    void show_lbs() const;
    void show_stn() const;
};

#endif

程序清单11.17 stonewt.cpp
#include <iostream>
#include "stonewt.h"

using std::cout;

Stonewt::Stonewt(double lbs)
{
    stone = int(lbs) / Lbs_per_stn;
    pds_left = int(lbs) % Lbs_per_stn + lbs - int(lbs);
    pounds = lbs;
}

Stonewt::Stonewt(int stn, double lbs)
{
    stone = stn;
    pds_left = lbs;
    pounds = stn * Lbs_per_stn + lbs;
}

Stonewt::Stonewt()
{
    stone = pounds = pds_left = 0;
}

Stonewt::~Stonewt()
{

}
void Stonewt::show_stn() const
{
    cout << stone << " stone, " << pds_left << " pounds\n";
}
void Stonewt::show_lbs() const
{
    cout << pounds << " pounds\n";
}

程序清单11.18 stone.cpp
#include <iostream>
#include "stonewt.h"

using std::cout;


void display(const Stonewt &st, int n);

int main()
{
    Stonewt incognito = 275;
    Stonewt wolfe(285.7);
    Stonewt taft(21, 8);
    cout << "The celebrity weighed ";
    incognito.show_stn();
    cout << "The detective weighed ";
    wolfe.show_stn();
    cout << "The President weighed ";
    taft.show_lbs();
    incognito = 276.8;
    taft = 325;
    cout << "After dinner, the celebrity weighed ";
    incognito.show_stn();
    cout << "After dinner, the President weighed ";
    taft.show_lbs();
    display(taft, 2);
    cout << "The wrestler weighed even more.\n";
    display(422, 2);
    cout << "No stone left unearned\n";

    return 0;
}

void display(const Stonewt &st, int n)
{
    for (int i = 0; i < n; i++)
    {
        cout << "Wow! ";
        st.show_stn();
    }
}
显示结果如下
The celebrity weighed 19 stone, 9 pounds
The detective weighed 20 stone, 5.7 pounds
The President weighed 302 pounds
After dinner, the celebrity weighed 19 stone, 10.8 pounds
After dinner, the President weighed 325 pounds
Wow! 23 stone, 3 pounds
Wow! 23 stone, 3 pounds
The wrestler weighed even more.
Wow! 30 stone, 2 pounds
Wow! 30 stone, 2 pounds
No stone left unearned

程序清单11.18将数字转换为Stonewt对象。可以做相反的转换吗？也就是说，是否可以将Stonewt对象转换为double值，就像如下所示的那样？
Stonewt wolfe(285.7);
double host = wolfe;
可以这样做，但不是使用构造函数。构造函数只用于从某种类型到类类型的转换。
要进行相反的转换，必须使用特殊的C++运算符函数――转换函数。
转换函数是用户定义的强制类型转换，可以像使用强制类型转换那样使用它们。
例如，如果定义了从Stonewt到double的转换函数，就可以使用下面的转换：
Stonewt wolfe (285.7);
double host = double (wolfe);
double thinker = (double) wolfe;
也可以让编译器来决定如何做：
Stonewt wells (20, 3);
double star = wells;
编译器发现，右侧是Stonewt类型，而左侧是double类型，因此它将查看程序员是否定义了与此匹配的转换函数。
（如果没有找到这样的定义，编译器将生成错误消息，指出无法将Stonewt赋给double。）
那么，如何创建转换函数呢？要转换为typeName类型，需要使用这种形式的转换函数：
operator typeName();
请注意以下几点：
转换函数必须是类方法；
转换函数不能指定返回类型；
转换函数不能有参数。
例如，转换为double类型的函数的原型如下
operator double()
typeName（这里为double）指出了要转换成的类型，因此不需要指定返回类型。
转换函数是类方法意味着：它需要通过类对象来调用，从而告知函数要转换的值。因此，函数不需要参数。
要添加将Stonewt对象转换为int类型和double类型的函数，需要将下面的原型添加到类声明中：
operator int ();
operator double ();
程序清单11.19 stonewt1.h
#pragma once
#ifndef STONEWT1_H_
#define STONEWT1_H_

class Stonewt
{
private:
    enum { Lbs_per_stn = 14 };
    int stone;
    double pds_left;
    double pounds;
public:
    Stonewt(double lbs);
    Stonewt(int stn, double lbs);
    Stonewt();
    ~Stonewt();
    void show_lbs() const;
    void show_stn() const;

    operator int() const;
    operator double() const;
};

#endif

程序清单11.20 stonewt1.cpp
#include <iostream>
#include "stonewt1.h"

using std::cout;

Stonewt::Stonewt(double lbs)
{
    stone = int(lbs) / Lbs_per_stn;
    pds_left = int(lbs) % Lbs_per_stn + lbs - int(lbs);
    pounds = lbs;
}
Stonewt::Stonewt(int stn, double lbs)
{
    stone = stn;
    pds_left = lbs;
    pounds = stn * Lbs_per_stn + lbs;
}
Stonewt::Stonewt()
{
    stone = pounds = pds_left = 0;
}
Stonewt::~Stonewt()
{

}
void Stonewt::show_stn() const
{
    cout << stone << " stone, " << pds_left << " pounds\n";
}
void Stonewt::show_lbs() const
{
    cout << pounds << " pounds\n";
}
Stonewt::operator int() const
{
    return int(pounds + 0.5);
}

Stonewt::operator double() const
{
    return pounds;
}

程序清单11.21 stone1.cpp
#include <iostream>
#include "stonewt1.h"

int main()
{
    using std::cout;
    Stonewt poppins(9, 2.8);
    double p_wt = poppins;
    cout << "Convert to double => ";
    cout << "Poppins: " << p_wt << " pounds. \n";
    cout << "Convert to int => ";
    cout << "Poppins: " << int(poppins) << " pounds. \n";

    return 0;
}
显示结果如下
Convert to double => Poppins: 128.8 pounds.
Convert to int => Poppins: 129 pounds.

11.7 总结
一般来说，访问类的私有成员的唯一方法是使用类的公有方法。C++使用友元函数来避开这种限制。
要让函数成为友元，需要在类声明中声明该函数，并在声明前加上关键字friend。
C++允许自定义特殊的运算符函数，这种函数描述了特定的运算符与类之间的关系。
运算符函数可以是类成员函数，也可以是友元函数（有一些运算符函数只能是类成员函数）。
要调用运算符函数可以直接调用该函数，也可以以通常的句法使用被重载的运算符。
对于运算符op，其运算符函数的格式如下：
operator op (argument-list)
argument-list表示该运算符的操作数。
如果运算符函数是类成员函数，则第一个操作数是调用该函数的对象，它不在argument-list中。
定义运算符函数时，如果要使其第一个操作数不是类对象，
则必须使用友元函数，这样就可以将操作数按所需的顺序传递给函数了。
最常见的运算符重载任务之一是定义<<运算符，使之可与cout一起使用，来显示对象的内容。
要让ostream对象成为第一个操作数，需要将运算符函数定义为友元；
要使重新定义的运算符能与其自身拼接，需要将返回类型声明为ostream&。
然而，如果类包含这样的方法，它返回需要显示的数据成员的值，则可以直接使用这些方法。
C++允许指定在类和基本类型之间进行转换的方式。
首先，任何接受唯一一个参数的构造函数都可被用作转换函数，将与该参数类型相同的值转换为类，
如果将与该参数类型相同的值赋给对象，则C++将自动调用该构造函数。
例如，假设有一个String类，它包含一个将char*值作为其唯二参数的构造函数，
那么如果bean是String对象，则可以使用下面的语句：
bean = "pinto";
然而，如果在该构造函数的声明前加上了关键字explicit，则该构造函数将只能用于显式转换：
bean = String ("pinto");
要将类对象转换为其他类型，必须定义转换函数，指出如何进行这种转换。
转换函数必须是成员函数。将类对象转换为typeName类型的转换函数的原型如下：
operator typeName ()
注意，转换函数没有返回类型、没有参数，但必须返回转换后的值（虽然没有声明返回类型）。
11.8复习题
1.使用成员函数为Stonéwt类重载乘法运算符，该运算符将数据成员与double类型的值相乘。
stonewt1.h
#pragma once
#ifndef STONEWT1_H_
#define STONEWT1_H_

class Stonewt
{
private:
    enum { Lbs_per_stn = 14 };
    int stone;
    double pds_left;
    double pounds;
public:
    Stonewt(double lbs);
    Stonewt(int stn, double lbs);
    Stonewt();
    ~Stonewt();
    void show_lbs() const;
    void show_stn() const;
    Stonewt operator *(double mult) const;
    operator int() const;
    operator double() const;
};

#endif

Stonewt Stonewt::operator*(double mult) const
{
    return Stonewt (pounds * mult);
}

2.友元函数与成员函数之间的区别是什么？
成员函数是类定义的一部分，通过类的对象来调用，成员函数可以隐式访问调用对象的私有成员。
友元函数不是类定义的一部分，调用时要把类的对象作为参数，函数内部要使用成员运算符访问参数的私有成员。

3.非成员函数必须是友元才能访问类成员吗？
如果要访问类的私有成员，则必须是友元函数。如果只访问类的公有成员，则不必是友元函数。

4.使用友元函数为Stonewt类重载乘法运算符，该运算符将double值与Stone值相乘。
stonewt1.h
#pragma once
#ifndef STONEWT1_H_
#define STONEWT1_H_

class Stonewt
{
private:
    enum { Lbs_per_stn = 14 };
    int stone;
    double pds_left;
    double pounds;
public:
    Stonewt(double lbs);
    Stonewt(int stn, double lbs);
    Stonewt();
    ~Stonewt();
    void show_lbs() const;
    void show_stn() const;
    Stonewt operator *(double mult) const;
    friend Stonewt operator *(double mult, const Stonewt & s);
    operator int() const;
    operator double() const;
};

#endif

Stonewt Stonewt::operator*(double mult) const
{
    return Stonewt (pounds * mult);
}

Stonewt operator*(double mult, const Stonewt & s)
{
    return Stonewt (s.pounds * mult);
}

5.哪些运算符不能重载？
sizeof 运算符。
.* 成员指针运算符
->* 成员指针运算符
:: 作用域解析运算符，
? : 条件运算符。
typeid ―个RTTI运算符。
const_cast 强制类型转换运算符。
dynamic_cast 强制类型转换运算符。
reinterpret_cast 强制类型转换运算符。
static_cast 强制类型转换运算符。

6.在重载运算符=、()、[]和->时，有什么限制？
必须作为类的成员函数来实现重载

7.为Vector类定义一个转换函数，将Vector类转换为一个double类型的值，后者表示矢量的长度。
#pragma once
#ifndef VECT_H_
#define VECT_H_
#include <cmath>
#include <iostream>

namespace VECTOR
{
    class Vector
    {
    public:
        enum Mode { RECT, POL };
    private:
        double x;
        double y;
        double mag;
        double ang;
        Mode mode;
        void set_mag();
        void set_ang();
        void set_x();
        void set_y();
    public:
        Vector();
        Vector(double n1, double n2, Mode form = RECT);
        void reset(double n1, double n2, Mode form = RECT);
        ~Vector();
        double xval() const
        {
            return x;
        }
        double yval() const
        {
            return y;
        }
        double magval() const
        {
            return mag;
        }
        double angval() const
        {
            return ang;
        }
        void polar_mode();
        void rect_mode();
        Vector operator+(const Vector &b) const;
        Vector operator-(const Vector &b) const;
        Vector operator-() const;
        Vector operator*(double n) const;
        operator double() const {return mag;};
        friend Vector operator*(double n, const Vector &a);
        friend std::ostream &operator<<(std::ostream &os, const Vector &v);
    };
}

#endif

11.9编程练习
1.修改程序清单11.15，使之将一系列连续的随机漫步者位置写入到文件中。
对于每个位置，用步号进行标示。另外，让该程序将初始条件（目标距离和步长）以及结果小结写入到该文件中。
vect.h
#pragma once
#ifndef VECT_H_
#define VECT_H_
#include <cmath>
#include <iostream>

namespace VECTOR
{
    class Vector
    {
    public:
        enum Mode { RECT, POL };
    private:
        double x;
        double y;
        double mag;
        double ang;
        Mode mode;
        void set_mag();
        void set_ang();
        void set_x();
        void set_y();
    public:
        Vector();
        Vector(double n1, double n2, Mode form = RECT);
        void reset(double n1, double n2, Mode form = RECT);
        ~Vector();
        double xval() const
        {
            return x;
        }
        double yval() const
        {
            return y;
        }
        double magval() const
        {
            return mag;
        }
        double angval() const
        {
            return ang;
        }
        void polar_mode();
        void rect_mode();
        Vector operator+(const Vector &b) const;
        Vector operator-(const Vector &b) const;
        Vector operator-() const;
        Vector operator*(double n) const;
        friend Vector operator*(double n, const Vector &a);
        friend std::ostream &operator<<(std::ostream &os, const Vector &v);
    };
}

#endif

vect.cpp
#include <iostream>
#include "vect.h"

using std::sqrt;
using std::sin;
using std::cos;
using std::atan;
using std::atan2;
using std::cout;

namespace VECTOR
{
    const double Rad_to_deg = 45.0 / atan(1.0);

    void Vector::set_mag()
    {
        mag = sqrt(x * x + y * y);
    }

    void Vector::set_ang()
    {
        if (x == 0.0 && y == 0.0)
        {
            ang = 0.0;
        }
        else
        {
            ang = atan2(y, x);
        }
    }
    void Vector::set_x()
    {
        x = mag * cos(ang);
    }
    void Vector::set_y()
    {
        y = mag * sin(ang);
    }
    Vector::Vector()
    {
        x = y = mag = ang = 0.0;
        mode = RECT;
    }
    Vector::Vector(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
        {
            x = n1;
            y = n2;
            set_mag();
            set_ang();
        }
        else if (form == POL)
        {
            mag = n1;
            ang = n2 / Rad_to_deg;
            set_x();
            set_y();
        }
        else
        {
            cout << "Incorrect argument to Vector (), ";
            cout << "vector set to 0\n";
            x = y = mag = ang = 0.0;
            mode = RECT;
        }

    }
    void Vector::reset(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
        {
            x = n1;
            y = n2;
            set_mag();
            set_ang();
        }
        else if (form == POL)
        {
            mag = n1;
            ang = n2 / Rad_to_deg;
            set_x();
            set_y();
        }
        else
        {
            cout << "Incorrect argument to Vector (), ";
            cout << "vector set to 0\n";
            x = y = mag = ang = 0.0;
            mode = RECT;
        }
    }
    Vector::~Vector()
    {

    }
    void Vector::polar_mode()
    {
        mode = POL;
    }
    void Vector::rect_mode()
    {
        mode = RECT;
    }
    Vector Vector::operator+(const Vector &b) const
    {
        return Vector(x + b.x, y + b.y);
    }
    Vector Vector::operator-(const Vector &b) const
    {
        return Vector(x - b.x, y - b.y);
    }
    Vector Vector::operator-() const
    {
        return Vector(-x, -y);
    }
    Vector Vector::operator*(double n) const
    {
        return Vector(n * x, n * y);
    }
    Vector operator*(double n, const Vector &a)
    {
        return a * n;
    }
    std::ostream &operator<<(std::ostream &os, const Vector &v)
    {
        if (v.mode == Vector::RECT)
        {
            os << " (x,y) = (" << v.x << ", " << v.y << ")";
        }
        else if (v.mode == Vector::POL)
        {
            os << " (m,a) = (" << v.mag << ", " << v.ang *Rad_to_deg << " ) ";
        }
        else
        {
            os << "Vector object mode is invalid";
        }
        return os;
    }
}

randwalk.cpp
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <ctime>
#include "vect.h"


int main()
{
    using VECTOR::Vector;

    std::srand(std::time(nullptr));

    std::ofstream fout;
    fout.open("Vector.txt");

    double direction;
    Vector step;
    Vector result(0.0, 0.0);
    unsigned long steps = 0;
    double target;
    double dstep;

    std::cout << "Enter target distance (q to quit) : ";
    target = 0.0;
    while (std::cin >> target)
    {
        while (std::cin.get() != '\n')
        {
            continue;
        }
        std::cout << "Enter step length: ";
        dstep = 0.0;
        if (!(std::cin >> dstep))
        {
            break;
        }
        while (std::cin.get() != '\n')
        {
            continue;
        }
        fout << "Target distance : ";
        fout << target << ",";
        fout << " Step length: ";
        fout << dstep << std::endl;

        while (result.magval() < target)
        {
            direction = std::rand() % 360;
            step.reset(dstep, direction, Vector::POL);
            result = result + step;
            steps++;

            fout << steps << ": " << result << std::endl;
            std::cout << steps << ": " << result << std::endl;
        }

        fout << "After " << steps << " steps, the subject has the following location:\n";
        std::cout << "After " << steps << " steps, the subject has the following location:\n";

        fout << result << std::endl;
        std::cout << result << std::endl;
        result.polar_mode();

        fout << " or\n" << result << std::endl;
        std::cout << " or\n" << result << std::endl;

        fout << "Average outward distance per step = ";
        std::cout << "Average outward distance per step = ";
        fout << result.magval() / steps << std::endl;
        std::cout << result.magval() / steps << std::endl;

        steps = 0;
        result.reset(0.0, 0.0);
        std::cout << "Enter target distance (q to quit) : ";
        target = 0.0;
    }
    fout.close();
    std::cout << "Done.\n";
    std::cin.clear();
    while (std::cin.get() != '\n')
    {
        continue;
    }

    return 0;
}
显示结果如下
Enter target distance (q to quit) : 8
Enter step length: 1
1:  (x,y) = (-0.34202, -0.939693)
2:  (x,y) = (-0.780391, -0.0408986)
3:  (x,y) = (-1.72591, -0.366467)
4:  (x,y) = (-2.60053, 0.118343)
5:  (x,y) = (-2.10053, -0.747683)
6:  (x,y) = (-1.18002, -1.13841)
7:  (x,y) = (-1.00638, -2.12322)
8:  (x,y) = (-0.0500718, -1.83085)
9:  (x,y) = (0.906233, -1.53848)
10:  (x,y) = (1.28084, -0.611294)
11:  (x,y) = (0.451802, -1.17049)
12:  (x,y) = (-0.475382, -0.79588)
13:  (x,y) = (0.219277, -0.0765406)
14:  (x,y) = (1.1648, -0.402109)
15:  (x,y) = (0.219277, -0.0765406)
16:  (x,y) = (-0.720416, -0.418561)
17:  (x,y) = (-0.297798, 0.487747)
18:  (x,y) = (0.108939, -0.425798)
19:  (x,y) = (-0.657106, 0.216989)
20:  (x,y) = (-0.203115, 1.108)
21:  (x,y) = (-1.1303, 0.733389)
22:  (x,y) = (-1.94945, 1.30697)
23:  (x,y) = (-2.70416, 0.650906)
24:  (x,y) = (-3.70279, 0.598571)
25:  (x,y) = (-2.89377, 1.18636)
26:  (x,y) = (-2.01083, 1.65583)
27:  (x,y) = (-1.20181, 1.06804)
28:  (x,y) = (-2.17618, 1.29299)
29:  (x,y) = (-1.25567, 1.68372)
30:  (x,y) = (-0.848937, 2.59727)
31:  (x,y) = (-1.4646, 1.80926)
32:  (x,y) = (-1.41226, 0.810629)
33:  (x,y) = (-0.824477, 1.61965)
34:  (x,y) = (-0.279838, 0.780976)
35:  (x,y) = (0.158533, 1.67977)
36:  (x,y) = (1.15473, 1.59261)
37:  (x,y) = (0.263721, 2.0466)
38:  (x,y) = (-0.545296, 1.45882)
39:  (x,y) = (0.432852, 1.66673)
40:  (x,y) = (-0.551956, 1.84038)
41:  (x,y) = (-1.47246, 2.23111)
42:  (x,y) = (-1.6289, 3.2188)
43:  (x,y) = (-0.780847, 2.68888)
44:  (x,y) = (-1.70135, 2.29815)
45:  (x,y) = (-1.5277, 3.28296)
46:  (x,y) = (-2.17049, 4.049)
47:  (x,y) = (-2.08334, 3.05281)
48:  (x,y) = (-1.12703, 3.34518)
49:  (x,y) = (-0.68866, 2.44638)
50:  (x,y) = (-0.396288, 1.49008)
51:  (x,y) = (-0.22264, 2.47489)
52:  (x,y) = (-0.965785, 3.14402)
53:  (x,y) = (-0.406592, 2.31498)
54:  (x,y) = (-1.40111, 2.41951)
55:  (x,y) = (-2.37141, 2.17759)
56:  (x,y) = (-1.43172, 1.83557)
57:  (x,y) = (-1.15608, 2.79683)
58:  (x,y) = (-2.08326, 3.17143)
59:  (x,y) = (-1.13775, 3.497)
60:  (x,y) = (-1.25961, 4.48955)
61:  (x,y) = (-1.36414, 5.48407)
62:  (x,y) = (-1.92334, 6.31311)
63:  (x,y) = (-0.938528, 6.48676)
64:  (x,y) = (-1.81315, 6.97157)
65:  (x,y) = (-1.42242, 7.89207)
After 65 steps, the subject has the following location:
 (x,y) = (-1.42242, 7.89207)
 or
 (m,a) = (8.01923, 100.217 )
Average outward distance per step = 0.123373
Enter target distance (q to quit) : q
Done.

cat Vector.txt
Target distance : 8, Step length: 1
1:  (x,y) = (-0.34202, -0.939693)
2:  (x,y) = (-0.780391, -0.0408986)
3:  (x,y) = (-1.72591, -0.366467)
4:  (x,y) = (-2.60053, 0.118343)
5:  (x,y) = (-2.10053, -0.747683)
6:  (x,y) = (-1.18002, -1.13841)
7:  (x,y) = (-1.00638, -2.12322)
8:  (x,y) = (-0.0500718, -1.83085)
9:  (x,y) = (0.906233, -1.53848)
10:  (x,y) = (1.28084, -0.611294)
11:  (x,y) = (0.451802, -1.17049)
12:  (x,y) = (-0.475382, -0.79588)
13:  (x,y) = (0.219277, -0.0765406)
14:  (x,y) = (1.1648, -0.402109)
15:  (x,y) = (0.219277, -0.0765406)
16:  (x,y) = (-0.720416, -0.418561)
17:  (x,y) = (-0.297798, 0.487747)
18:  (x,y) = (0.108939, -0.425798)
19:  (x,y) = (-0.657106, 0.216989)
20:  (x,y) = (-0.203115, 1.108)
21:  (x,y) = (-1.1303, 0.733389)
22:  (x,y) = (-1.94945, 1.30697)
23:  (x,y) = (-2.70416, 0.650906)
24:  (x,y) = (-3.70279, 0.598571)
25:  (x,y) = (-2.89377, 1.18636)
26:  (x,y) = (-2.01083, 1.65583)
27:  (x,y) = (-1.20181, 1.06804)
28:  (x,y) = (-2.17618, 1.29299)
29:  (x,y) = (-1.25567, 1.68372)
30:  (x,y) = (-0.848937, 2.59727)
31:  (x,y) = (-1.4646, 1.80926)
32:  (x,y) = (-1.41226, 0.810629)
33:  (x,y) = (-0.824477, 1.61965)
34:  (x,y) = (-0.279838, 0.780976)
35:  (x,y) = (0.158533, 1.67977)
36:  (x,y) = (1.15473, 1.59261)
37:  (x,y) = (0.263721, 2.0466)
38:  (x,y) = (-0.545296, 1.45882)
39:  (x,y) = (0.432852, 1.66673)
40:  (x,y) = (-0.551956, 1.84038)
41:  (x,y) = (-1.47246, 2.23111)
42:  (x,y) = (-1.6289, 3.2188)
43:  (x,y) = (-0.780847, 2.68888)
44:  (x,y) = (-1.70135, 2.29815)
45:  (x,y) = (-1.5277, 3.28296)
46:  (x,y) = (-2.17049, 4.049)
47:  (x,y) = (-2.08334, 3.05281)
48:  (x,y) = (-1.12703, 3.34518)
49:  (x,y) = (-0.68866, 2.44638)
50:  (x,y) = (-0.396288, 1.49008)
51:  (x,y) = (-0.22264, 2.47489)
52:  (x,y) = (-0.965785, 3.14402)
53:  (x,y) = (-0.406592, 2.31498)
54:  (x,y) = (-1.40111, 2.41951)
55:  (x,y) = (-2.37141, 2.17759)
56:  (x,y) = (-1.43172, 1.83557)
57:  (x,y) = (-1.15608, 2.79683)
58:  (x,y) = (-2.08326, 3.17143)
59:  (x,y) = (-1.13775, 3.497)
60:  (x,y) = (-1.25961, 4.48955)
61:  (x,y) = (-1.36414, 5.48407)
62:  (x,y) = (-1.92334, 6.31311)
63:  (x,y) = (-0.938528, 6.48676)
64:  (x,y) = (-1.81315, 6.97157)
65:  (x,y) = (-1.42242, 7.89207)
After 65 steps, the subject has the following location:
 (x,y) = (-1.42242, 7.89207)
 or
 (m,a) = (8.01923, 100.217 )
Average outward distance per step = 0.123373

2.对Vector类的头文件（程序清单11.13）和实现文件（程序清单11.14）进行修改，
使其不再存储矢量的长度和角度，而是在magval（）和angval）被调用时计算它们。
应保留公有接口不变（公有方法及其参数不变），但对私有部分（包括一些私有方法）和方法实现进行修改。
然后，使用程序清单11.15对修改后的版本进行测试，结果应该与以前相同，因为Vector类的公有接口与原来相同。
vect1.h
#pragma once
#ifndef VECT1_H_
#define VECT1_H_
#include <cmath>
#include <iostream>

namespace VECTOR
{
    class Vector
    {
    public:
        enum Mode { RECT, POL };
    private:
        double x;
        double y;
        Mode mode;
    public:
        Vector();
        Vector(double n1, double n2, Mode form = RECT);
        void reset(double n1, double n2, Mode form = RECT);
        ~Vector();
        double xval() const
        {
            return x;
        }
        double yval() const
        {
            return y;
        }
        double magval() const;
        double angval() const;
        void polar_mode();
        void rect_mode();
        Vector operator+(const Vector &b) const;
        Vector operator-(const Vector &b) const;
        Vector operator-() const;
        Vector operator*(double n) const;
        friend Vector operator*(double n, const Vector &a);
        friend std::ostream &operator<<(std::ostream &os, const Vector &v);
    };
}

#endif

vect1.cpp
#include <iostream>
#include "vect1.h"

using std::sqrt;
using std::sin;
using std::cos;
using std::atan;
using std::atan2;
using std::cout;

namespace VECTOR
{
    const double Rad_to_deg = 45.0 / atan(1.0);

    Vector::Vector()
    {
        x = y = 0.0;
        mode = RECT;
    }
    Vector::Vector(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
        {
            x = n1;
            y = n2;
        }
        else if (form == POL)
        {
            x = n1 * cos(n2 / Rad_to_deg);
            y = n1 * sin(n2 / Rad_to_deg);
        }
        else
        {
            cout << "Incorrect argument to Vector (), ";
            cout << "vector set to 0\n";
            x = y = 0.0;
            mode = RECT;
        }
    }
    void Vector::reset(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
        {
            x = n1;
            y = n2;
        }
        else if (form == POL)
        {
            x = n1 * cos(n2 / Rad_to_deg);
            y = n1 * sin(n2 / Rad_to_deg);
        }
        else
        {
            cout << "Incorrect argument to Vector (), ";
            cout << "vector set to 0\n";
            x = y = 0.0;
            mode = RECT;
        }
    }
    Vector::~Vector()
    {

    }
    double Vector::magval() const
    {
        return sqrt(x * x + y * y);
    }
    double Vector::angval() const
    {
        return (x == 0.0 && y == 0.0) ? 0.0 : atan2(y, x);
    }
    void Vector::polar_mode()
    {
        mode = POL;
    }
    void Vector::rect_mode()
    {
        mode = RECT;
    }
    Vector Vector::operator+(const Vector &b) const
    {
        return Vector(x + b.x, y + b.y);
    }
    Vector Vector::operator-(const Vector &b) const
    {
        return Vector(x - b.x, y - b.y);
    }
    Vector Vector::operator-() const
    {
        return Vector(-x, -y);
    }
    Vector Vector::operator*(double n) const
    {
        return Vector(n * x, n * y);
    }
    Vector operator*(double n, const Vector &a)
    {
        return a * n;
    }
    std::ostream &operator<<(std::ostream &os, const Vector &v)
    {
        if (v.mode == Vector::RECT)
        {
            os << " (x,y) = (" << v.x << ", " << v.y << ")";
        }
        else if (v.mode == Vector::POL)
        {
            os << " (m,a) = (" << v.magval() << ", " << v.angval() *Rad_to_deg << " ) ";
        }
        else
        {
            os << "Vector object mode is invalid";
        }
        return os;
    }
}

ch11_p02.cpp
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <ctime>
#include "vect1.h"


int main()
{
    using VECTOR::Vector;

    std::srand(std::time(nullptr));

    std::ofstream fout;
    fout.open("Vector1.txt");

    double direction;
    Vector step;
    Vector result(0.0, 0.0);
    unsigned long steps = 0;
    double target;
    double dstep;

    std::cout << "Enter target distance (q to quit) : ";
    target = 0.0;
    while (std::cin >> target)
    {
        while (std::cin.get() != '\n')
        {
            continue;
        }
        std::cout << "Enter step length: ";
        dstep = 0.0;
        if (!(std::cin >> dstep))
        {
            break;
        }
        while (std::cin.get() != '\n')
        {
            continue;
        }
        fout << "Target distance : ";
        fout << target << ",";
        fout << " Step length: ";
        fout << dstep << std::endl;

        while (result.magval() < target)
        {
            direction = std::rand() % 360;
            step.reset(dstep, direction, Vector::POL);
            result = result + step;
            steps++;

            fout << steps << ": " << result << std::endl;
            std::cout << steps << ": " << result << std::endl;
        }

        fout << "After " << steps << " steps, the subject has the following location:\n";
        std::cout << "After " << steps << " steps, the subject has the following location:\n";

        fout << result << std::endl;
        std::cout << result << std::endl;
        result.polar_mode();

        fout << " or\n" << result << std::endl;
        std::cout << " or\n" << result << std::endl;

        fout << "Average outward distance per step = ";
        std::cout << "Average outward distance per step = ";
        fout << result.magval() / steps << std::endl;
        std::cout << result.magval() / steps << std::endl;

        steps = 0;
        result.reset(0.0, 0.0);
        std::cout << "Enter target distance (q to quit) : ";
        target = 0.0;
    }
    fout.close();
    std::cout << "Done.\n";
    std::cin.clear();
    while (std::cin.get() != '\n')
    {
        continue;
    }

    return 0;
}
显示结果如下
Enter target distance (q to quit) : 6
Enter step length: 1
1:  (x,y) = (0.819152, 0.573576)
2:  (x,y) = (1.8117, 0.451707)
3:  (x,y) = (2.54305, 1.13371)
4:  (x,y) = (3.13084, 0.324688)
5:  (x,y) = (4.12111, 0.463862)
6:  (x,y) = (3.57647, -0.374809)
7:  (x,y) = (3.20186, -1.30199)
8:  (x,y) = (2.90949, -2.2583)
9:  (x,y) = (2.36485, -3.09697)
10:  (x,y) = (1.5988, -2.45418)
11:  (x,y) = (1.94082, -1.51449)
12:  (x,y) = (1.95828, -2.51434)
13:  (x,y) = (1.75037, -1.53619)
14:  (x,y) = (0.911695, -0.991549)
15:  (x,y) = (1.08534, -1.97636)
16:  (x,y) = (0.0853429, -1.97636)
17:  (x,y) = (-0.860176, -1.65079)
18:  (x,y) = (-1.05098, -2.63242)
19:  (x,y) = (-1.59562, -3.47109)
20:  (x,y) = (-2.50917, -3.87782)
21:  (x,y) = (-1.66112, -4.40774)
22:  (x,y) = (-0.676313, -4.58139)
23:  (x,y) = (0.319881, -4.66855)
24:  (x,y) = (-0.607302, -5.04315)
25:  (x,y) = (-0.0773832, -5.8912)
26:  (x,y) = (-1.06765, -6.03037)
After 26 steps, the subject has the following location:
 (x,y) = (-1.06765, -6.03037)
 or
 (m,a) = (6.12416, -100.04 )
Average outward distance per step = 0.235544
Enter target distance (q to quit) : q
Done.

cat Vector1.txt
Target distance : 6, Step length: 1
1:  (x,y) = (0.819152, 0.573576)
2:  (x,y) = (1.8117, 0.451707)
3:  (x,y) = (2.54305, 1.13371)
4:  (x,y) = (3.13084, 0.324688)
5:  (x,y) = (4.12111, 0.463862)
6:  (x,y) = (3.57647, -0.374809)
7:  (x,y) = (3.20186, -1.30199)
8:  (x,y) = (2.90949, -2.2583)
9:  (x,y) = (2.36485, -3.09697)
10:  (x,y) = (1.5988, -2.45418)
11:  (x,y) = (1.94082, -1.51449)
12:  (x,y) = (1.95828, -2.51434)
13:  (x,y) = (1.75037, -1.53619)
14:  (x,y) = (0.911695, -0.991549)
15:  (x,y) = (1.08534, -1.97636)
16:  (x,y) = (0.0853429, -1.97636)
17:  (x,y) = (-0.860176, -1.65079)
18:  (x,y) = (-1.05098, -2.63242)
19:  (x,y) = (-1.59562, -3.47109)
20:  (x,y) = (-2.50917, -3.87782)
21:  (x,y) = (-1.66112, -4.40774)
22:  (x,y) = (-0.676313, -4.58139)
23:  (x,y) = (0.319881, -4.66855)
24:  (x,y) = (-0.607302, -5.04315)
25:  (x,y) = (-0.0773832, -5.8912)
26:  (x,y) = (-1.06765, -6.03037)
After 26 steps, the subject has the following location:
 (x,y) = (-1.06765, -6.03037)
 or
 (m,a) = (6.12416, -100.04 )
Average outward distance per step = 0.235544

3.修改程序清单11.15，使之报告N次测试中的最高、最低和平均步数（其中N是用户输入的整数），而不是报告每次测试的结果。
vect.h
#pragma once
#ifndef VECT_H_
#define VECT_H_
#include <cmath>
#include <iostream>

namespace VECTOR
{
    class Vector
    {
    public:
        enum Mode { RECT, POL };
    private:
        double x;
        double y;
        double mag;
        double ang;
        Mode mode;
        void set_mag();
        void set_ang();
        void set_x();
        void set_y();
    public:
        Vector();
        Vector(double n1, double n2, Mode form = RECT);
        void reset(double n1, double n2, Mode form = RECT);
        ~Vector();
        double xval() const
        {
            return x;
        }
        double yval() const
        {
            return y;
        }
        double magval() const
        {
            return mag;
        }
        double angval() const
        {
            return ang;
        }
        void polar_mode();
        void rect_mode();
        Vector operator+(const Vector &b) const;
        Vector operator-(const Vector &b) const;
        Vector operator-() const;
        Vector operator*(double n) const;
        friend Vector operator*(double n, const Vector &a);
        friend std::ostream &operator<<(std::ostream &os, const Vector &v);
    };
}

#endif

vect.cpp
#include <iostream>
#include "vect.h"

using std::sqrt;
using std::sin;
using std::cos;
using std::atan;
using std::atan2;
using std::cout;

namespace VECTOR
{
    const double Rad_to_deg = 45.0 / atan(1.0);

    void Vector::set_mag()
    {
        mag = sqrt(x * x + y * y);
    }

    void Vector::set_ang()
    {
        if (x == 0.0 && y == 0.0)
        {
            ang = 0.0;
        }
        else
        {
            ang = atan2(y, x);
        }
    }
    void Vector::set_x()
    {
        x = mag * cos(ang);
    }
    void Vector::set_y()
    {
        y = mag * sin(ang);
    }
    Vector::Vector()
    {
        x = y = mag = ang = 0.0;
        mode = RECT;
    }
    Vector::Vector(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
        {
            x = n1;
            y = n2;
            set_mag();
            set_ang();
        }
        else if (form == POL)
        {
            mag = n1;
            ang = n2 / Rad_to_deg;
            set_x();
            set_y();
        }
        else
        {
            cout << "Incorrect argument to Vector (), ";
            cout << "vector set to 0\n";
            x = y = mag = ang = 0.0;
            mode = RECT;
        }

    }
    void Vector::reset(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
        {
            x = n1;
            y = n2;
            set_mag();
            set_ang();
        }
        else if (form == POL)
        {
            mag = n1;
            ang = n2 / Rad_to_deg;
            set_x();
            set_y();
        }
        else
        {
            cout << "Incorrect argument to Vector (), ";
            cout << "vector set to 0\n";
            x = y = mag = ang = 0.0;
            mode = RECT;
        }
    }
    Vector::~Vector()
    {

    }
    void Vector::polar_mode()
    {
        mode = POL;
    }
    void Vector::rect_mode()
    {
        mode = RECT;
    }
    Vector Vector::operator+(const Vector &b) const
    {
        return Vector(x + b.x, y + b.y);
    }
    Vector Vector::operator-(const Vector &b) const
    {
        return Vector(x - b.x, y - b.y);
    }
    Vector Vector::operator-() const
    {
        return Vector(-x, -y);
    }
    Vector Vector::operator*(double n) const
    {
        return Vector(n * x, n * y);
    }
    Vector operator*(double n, const Vector &a)
    {
        return a * n;
    }
    std::ostream &operator<<(std::ostream &os, const Vector &v)
    {
        if (v.mode == Vector::RECT)
        {
            os << " (x,y) = (" << v.x << ", " << v.y << ")";
        }
        else if (v.mode == Vector::POL)
        {
            os << " (m,a) = (" << v.mag << ", " << v.ang *Rad_to_deg << " ) ";
        }
        else
        {
            os << "Vector object mode is invalid";
        }
        return os;
    }
}

ch11_p03.cpp
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <algorithm>
#include <numeric>
#include "vect.h"


int main()
{
    using VECTOR::Vector;

    std::srand(std::time(nullptr));

    std::vector<unsigned long> stepsResult;
    std::cout << "Enter number of attempts: ";
    int attempt = 0;
    std::cin >> attempt;
    while (std::cin.get() != '\n')
    {
        continue;
    }

    std::ofstream fout;
    fout.open("ch11_p03.txt");

    double direction;
    Vector step;
    Vector result(0.0, 0.0);
    unsigned long steps = 0;
    double target;
    double dstep;

    std::cout << "Enter target distance (q to quit) : ";
    target = 0.0;
    while (attempt > 0 && std::cin >> target)
    {
        while (std::cin.get() != '\n')
        {
            continue;
        }
        std::cout << "Enter step length: ";
        dstep = 0.0;
        if (!(std::cin >> dstep))
        {
            break;
        }
        while (std::cin.get() != '\n')
        {
            continue;
        }
        fout << "Target distance : ";
        fout << target << ",";
        fout << " Step length: ";
        fout << dstep << std::endl;

        while (result.magval() < target)
        {
            direction = std::rand() % 360;
            step.reset(dstep, direction, Vector::POL);
            result = result + step;
            steps++;

        }
        stepsResult.push_back(steps);

        fout << "After " << steps << " steps, the subject has the following location:\n";
        std::cout << "After " << steps << " steps, the subject has the following location:\n";

        fout << result << std::endl;
        std::cout << result << std::endl;
        result.polar_mode();

        fout << " or\n" << result << std::endl;
        std::cout << " or\n" << result << std::endl;

        fout << "Average outward distance per step = ";
        std::cout << "Average outward distance per step = ";
        fout << result.magval() / steps << std::endl;
        std::cout << result.magval() / steps << std::endl;

        steps = 0;
        result.reset(0.0, 0.0);
        --attempt;
        if (attempt > 0)
        {
            std::cout << "Enter target distance (q to quit) : ";
            target = 0.0;
        }
    }
    std::cout << "The smallest number of steps is ";
    std::cout << *std::min_element(stepsResult.begin(), stepsResult.end());
    std::cout << '\n';

    std::cout << "The largest number of steps is ";
    std::cout << *std::max_element(stepsResult.begin(), stepsResult.end());
    std::cout << '\n';

    std::cout << "The average number of steps is ";
    std::cout << std::accumulate(stepsResult.begin(), stepsResult.end(), 0) / stepsResult.size();
    std::cout << '\n';

    fout.close();
    std::cout << "Done.\n";
    if (attempt > 0)
    {
        std::cin.clear();
        while (std::cin.get() != '\n')
        {
            continue;
        }
    }

    return 0;
}
显示结果如下
Enter number of attempts: 5
Enter target distance (q to quit) : 5
Enter step length: 1
After 30 steps, the subject has the following location:
 (x,y) = (3.42309, -3.89729)
 or
 (m,a) = (5.18714, -48.7064 )
Average outward distance per step = 0.172905
Enter target distance (q to quit) : 6
Enter step length: 1
After 25 steps, the subject has the following location:
 (x,y) = (-5.56922, 2.26059)
 or
 (m,a) = (6.01053, 157.907 )
Average outward distance per step = 0.240421
Enter target distance (q to quit) : 7
Enter step length: 1
After 79 steps, the subject has the following location:
 (x,y) = (-2.19311, -6.66206)
 or
 (m,a) = (7.01376, -108.221 )
Average outward distance per step = 0.0887817
Enter target distance (q to quit) : 8
Enter step length: 1
After 295 steps, the subject has the following location:
 (x,y) = (-4.53022, -6.86561)
 or
 (m,a) = (8.22554, -123.418 )
Average outward distance per step = 0.0278832
Enter target distance (q to quit) : 9
Enter step length: 1
After 30 steps, the subject has the following location:
 (x,y) = (-0.383674, 9.90786)
 or
 (m,a) = (9.91529, 92.2176 )
Average outward distance per step = 0.33051
The smallest number of steps is 25
The largest number of steps is 295
The average number of steps is 91
Done.

4.重新编写最后的Time类示例（程序清单11.10、程序清单11.11和程序清单11.12），使用友元函数来实现所有的重载运算符。
mytime4.h
#pragma once
#ifndef MYTIME4_H_
#define MYTIME4_H_

#include <iostream>

class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    friend Time operator+(const Time &t1, const Time &t2);
    friend Time operator-(const Time &t1, const Time &t2);
    friend Time operator*(double n, const Time &t);
    friend Time operator*(const Time &t, double n);
    friend std::ostream &operator<<(std::ostream &os, const Time &t);
};

#endif

mytime4.cpp
#include <iostream>
#include "mytime4.h"

Time::Time()
{
    hours = minutes = 0;
}

Time::Time(int h, int m)
{
    hours = h;
    minutes = m;
}

void Time::AddMin(int m)
{
    minutes += m;
    hours += minutes / 60;
    minutes %= 60;
}

void Time::AddHr(int h)
{
    hours += h;
}

void Time::Reset(int h, int m)
{
    hours = h;
    minutes = m;
}
Time operator+(const Time & t1, const Time & t2)
{
	Time sum;
	sum.minutes = t1.minutes + t2.minutes;
	sum.hours = t1.hours + t2.hours + sum.minutes / 60;
	sum.minutes %= 60;
	return sum;
}
Time operator-(const Time & t1, const Time & t2)
{
	Time diff;
	int tot1, tot2;
	tot1 = t1.minutes + 60 * t2.hours;
	tot2 = t1.minutes + 60 * t2.hours;
	diff.minutes = (tot2 - tot1) % 60;
	diff.hours = (tot2 - tot1) / 60;
	return diff;
}
Time operator*(double n, const Time & t)
{
	Time result;
	long totalminutes = t.hours * n * 60 + t.minutes * n;
	result.hours = totalminutes / 60;
	result.minutes = totalminutes % 60;
	return result;
}
Time operator*(const Time& t, double n)
{
	Time result;
	long totalminutes = t.hours * n * 60 + t.minutes * n;
	result.hours = totalminutes / 60;
	result.minutes = totalminutes % 60;
	return result;
}
std::ostream & operator<<(std::ostream & os, const Time & t)
{
	os << t.hours << " hours, " << t.minutes << " minutes";
	return os;
}

usetime4.cpp
#include <iostream>
#include "mytime4.h"

int main()
{
    using std::cout;
    using std::endl;

    Time aida(3, 35);
    Time tosca(2, 48);
    Time temp;
    cout << "Aida and Tosca:\n";
    cout << aida << "; " << tosca << endl;
    temp = aida + tosca;
    cout << "Aida + Tosca: " << temp << endl;
    temp = aida * 1.17;
    cout << "Aida * 1.17: " << temp << endl;
    cout << "10.0 * Tosca: " << 10.0 * tosca << endl;

    return 0;
}
显示结果如下
Aida and Tosca:
3 hours, 35 minutes; 2 hours, 48 minutes
Aida + Tosca: 6 hours, 23 minutes
Aida * 1.17: 4 hours, 11 minutes
10.0 * Tosca: 28 hours, 0 minutes

5.重新编写Stonewt类（程序清单11.16和程序清单11.17），使它有一个状态成员，
由该成员控制对应转换为英石格式、整数磅格式还是浮点磅格式。
重载<<运算符，使用它来替换show_stn和show_lbs方法。
重载加法、减法和乘法运算符，以便可以对Stonewt值进行加、减、乘运算。
编写一个使用所有类方法和友元的小程序，来测试这个类。
stonewt2.h
#pragma once
#ifndef STONEWT2_H_
#define STONEWT2_H_

class Stonewt
{
private:
    enum { Lbs_per_stn = 14 };
    enum Mode { STONE, iPOUND, dPOUND };
    int stone;
    double pds_left;
    double dpounds;
    int ipounds;
    Mode mode;
    void setmode();
public:
    Stonewt(double lbs);
    Stonewt(int stn, double lbs);
    Stonewt();
    ~Stonewt();
    void setmode(int m);
    friend Stonewt operator+(const Stonewt &stn1, const Stonewt &stn2);
    friend Stonewt operator-(const Stonewt &stn1, const Stonewt &stn2);
    friend Stonewt operator*(double n, const Stonewt &stn);
    friend Stonewt operator*(const Stonewt &stn, double n);
    friend std::ostream &operator<<(std::ostream &os, const Stonewt &stn);
};

#endif

stonewt2.cpp
#include <iostream>
#include "stonewt2.h"

Stonewt::Stonewt(double lbs)
{
    stone = int(lbs) / Lbs_per_stn;
    pds_left = int(lbs) % Lbs_per_stn + lbs - int(lbs);
    dpounds = lbs;
    ipounds = int(lbs);
    setmode();
}

Stonewt::Stonewt(int stn, double lbs)
{
    stone = stn;
    pds_left = lbs;
    dpounds = stn * Lbs_per_stn + lbs;
    ipounds = int(stn * Lbs_per_stn + lbs);
    setmode();
}

Stonewt::Stonewt()
{
    stone = dpounds = ipounds = pds_left = 0;
    setmode();
}

Stonewt::~Stonewt()
{

}
void Stonewt::setmode()
{
    if (pds_left == 0)
    {
        mode = STONE;
    }
    else if (pds_left > int(pds_left))
    {
        mode = dPOUND;
    }
    else
    {
        mode = iPOUND;
    }
}
void Stonewt::setmode(int m)
{
    if (m == 0)
    {
        mode = STONE;
    }
    else if (m == 1)
    {
        mode = iPOUND;
    }
    else if (m == 2)
    {
        mode = dPOUND;
    }
    else
    {
        std::cout << "\nInvalid argument to the setmode() function, ";
        std::cout << "The mode is set to STONE.\n";
        mode = STONE;
    }
}
Stonewt operator+(const Stonewt &stn1, const Stonewt &stn2)
{
    return Stonewt (stn1.dpounds + stn2.dpounds);
}
Stonewt operator-(const Stonewt &stn1, const Stonewt &stn2)
{
    return Stonewt (stn1.dpounds - stn2.dpounds);
}
Stonewt operator*(double n, const Stonewt &stn)
{
    return Stonewt (stn.dpounds * n);
}
Stonewt operator*(const Stonewt &stn, double n)
{
    return Stonewt (stn.dpounds * n);
}
std::ostream &operator<<(std::ostream &os, const Stonewt &stn)
{
    if (stn.mode == Stonewt::STONE)
    {
        os << stn.stone << " stone, " << stn.pds_left << " pounds.";
    }
    else if (stn.mode == Stonewt::iPOUND)
    {
        os << stn.ipounds << " pounds.";
    }
    else
    {
        os << stn.dpounds << " pounds.";
    }
    return os;
}


stone2.cpp
#include <iostream>
#include "stonewt2.h"

int main()
{
    Stonewt var_a;
    std::cout << "Object var_a constructed by default constructor: " << var_a << std::endl;

    Stonewt var_b(62.52);
    std::cout << "Object var_b constructed from double value: " << var_b << std::endl;

    Stonewt var_c(10, 60.21);
    std::cout << "Object var_c constructed from stone, double values: " << var_c << std::endl;

    var_c.setmode(0);
    std::cout << "Object var_c (Mode set to STONE): " << var_c << std::endl;

    var_c.setmode(1);
    std::cout << "Object var_c (Mode set to iPOUND): " << var_c << std::endl;

    var_c.setmode(2);
    std::cout << "Object var_c (Mode set to dPOUND): " << var_c << std::endl;

    std::cout << "Object var_c (Mode set to incorrect value):\n";
    var_c.setmode(6);
    std::cout << "Object var_c after that: " << var_c << std::endl;

    Stonewt var_d = var_b + var_c;
    std::cout << "\nObject var_d after adding: " << var_d << std::endl;

    var_d.setmode(0);
    std::cout << "Object var_d (Mode set to STONE): " << var_d << std::endl;

    var_d.setmode(1);
    std::cout << "Object var_d (Mode set to iPOUND): " << var_d << std::endl;

    var_d.setmode(2);
    std::cout << "Object var_d (Mode set to dPOUND): " << var_d << std::endl;

    var_d = var_c - var_b;
    std::cout << "\nObject var_d after division: " << var_d << std::endl;

    var_d.setmode(0);
    std::cout << "Object var_d (Mode set to STONE): " << var_d << std::endl;

    var_d.setmode(1);
    std::cout << "Object var_d (Mode set to iPOUND): " << var_d << std::endl;

    var_d.setmode(2);
    std::cout << "Object var_d (Mode set to dPOUND): " << var_d << std::endl;

    var_d = 5.0 * var_b;
    std::cout << "\nObject var_d after multiplying: " << var_d << std::endl;

    var_d.setmode(0);
    std::cout << "Object var_d (Mode set to STONE): " << var_d << std::endl;

    var_d.setmode(1);
    std::cout << "Object var_d (Mode set to iPOUND): " << var_d << std::endl;

    var_d.setmode(2);
    std::cout << "Object var_d (Mode set to dPOUND): " << var_d << std::endl;

    return 0;
}
显示结果如下
Object var_a constructed by default constructor: 0 stone, 0 pounds.
Object var_b constructed from double value: 62.52 pounds.
Object var_c constructed from stone, double values: 200.21 pounds.
Object var_c (Mode set to STONE): 10 stone, 60.21 pounds.
Object var_c (Mode set to iPOUND): 200 pounds.
Object var_c (Mode set to dPOUND): 200.21 pounds.
Object var_c (Mode set to incorrect value):

Invalid argument to the setmode() function, The mode is set to STONE.
Object var_c after that: 10 stone, 60.21 pounds.

Object var_d after adding: 262.73 pounds.
Object var_d (Mode set to STONE): 18 stone, 10.73 pounds.
Object var_d (Mode set to iPOUND): 262 pounds.
Object var_d (Mode set to dPOUND): 262.73 pounds.

Object var_d after division: 137.69 pounds.
Object var_d (Mode set to STONE): 9 stone, 11.69 pounds.
Object var_d (Mode set to iPOUND): 137 pounds.
Object var_d (Mode set to dPOUND): 137.69 pounds.

Object var_d after multiplying: 312.6 pounds.
Object var_d (Mode set to STONE): 22 stone, 4.6 pounds.
Object var_d (Mode set to iPOUND): 312 pounds.
Object var_d (Mode set to dPOUND): 312.6 pounds.

6.重新编写Stonewt类（程序清单11.16和程序清单11.17），重载全部6个关系运算符。
运算符对pounds成员进行比较，并返回一个bool值。
编写一个程序，它声明一个包含6个Stonewt对象的数组，并在数组声明中初始化前3个对象。
然后使用循环来读取用于设置剩余3个数组元素的值。
接着报告最小的元素、最大的元素以及大于或等于11英石的元素的数量
（最简单的方法是创建一个Stonewt对象，并将其初始化为11英石，然后将其同其他对象进行比较）。
stonewt3.h
#pragma once
#ifndef STONEWT3_H_
#define STONEWT3_H_

class Stonewt
{
private:
    enum { Lbs_per_stn = 14 };
    enum Mode { STONE, iPOUND, dPOUND };
    int stone;
    double pds_left;
    double dpounds;
    int ipounds;
    Mode mode;
    void setmode();
public:
    Stonewt(double lbs);
    Stonewt(int stn, double lbs);
    Stonewt();
    ~Stonewt();
    void setmode(int m);
    friend Stonewt operator+(const Stonewt &stn1, const Stonewt &stn2);
    friend Stonewt operator-(const Stonewt &stn1, const Stonewt &stn2);
    friend Stonewt operator*(double n, const Stonewt &stn);
    friend Stonewt operator*(const Stonewt &stn, double n);
    friend bool operator > (const Stonewt &stn1, const Stonewt &stn2);
    friend bool operator < (const Stonewt &stn1, const Stonewt &stn2);
    friend bool operator >= (const Stonewt &stn1, const Stonewt &stn2);
    friend bool operator <= (const Stonewt &stn1, const Stonewt &stn2);
    friend bool operator == (const Stonewt &stn1, const Stonewt &stn2);
    friend bool operator != (const Stonewt &stn1, const Stonewt &stn2);
    friend std::ostream &operator<<(std::ostream &os, const Stonewt &stn);
};

#endif

stonewt3.cpp
#include <iostream>
#include "stonewt3.h"

Stonewt::Stonewt(double lbs)
{
    stone = int(lbs) / Lbs_per_stn;
    pds_left = int(lbs) % Lbs_per_stn + lbs - int(lbs);
    dpounds = lbs;
    ipounds = int(lbs);
    setmode();
}

Stonewt::Stonewt(int stn, double lbs)
{
    stone = stn;
    pds_left = lbs;
    dpounds = stn * Lbs_per_stn + lbs;
    ipounds = int(stn * Lbs_per_stn + lbs);
    setmode();
}

Stonewt::Stonewt()
{
    stone = dpounds = ipounds = pds_left = 0;
    setmode();
}

Stonewt::~Stonewt()
{

}
void Stonewt::setmode()
{
    if (pds_left == 0)
    {
        mode = STONE;
    }
    else if (pds_left > int(pds_left))
    {
        mode = dPOUND;
    }
    else
    {
        mode = iPOUND;
    }
}
void Stonewt::setmode(int m)
{
    if (m == 0)
    {
        mode = STONE;
    }
    else if (m == 1)
    {
        mode = iPOUND;
    }
    else if (m == 2)
    {
        mode = dPOUND;
    }
    else
    {
        std::cout << "Invalid argument to the setmode() function, The mode is set to STONE.\n";
        mode = STONE;
    }
}
Stonewt operator+(const Stonewt &stn1, const Stonewt &stn2)
{
    return Stonewt (stn1.dpounds + stn2.dpounds);
}
Stonewt operator-(const Stonewt &stn1, const Stonewt &stn2)
{
    return Stonewt (stn1.dpounds - stn2.dpounds);
}
Stonewt operator*(double n, const Stonewt &stn)
{
    return Stonewt (stn.dpounds * n);
}
Stonewt operator*(const Stonewt &stn, double n)
{
    return Stonewt (stn.dpounds * n);
}
bool operator > (const Stonewt &stn1, const Stonewt &stn2)
{
    return stn1.dpounds > stn2.dpounds;
}
bool operator < (const Stonewt &stn1, const Stonewt &stn2)
{
    return stn1.dpounds < stn2.dpounds;
}
bool operator >= (const Stonewt &stn1, const Stonewt &stn2)
{
    return stn1.dpounds >= stn2.dpounds;
}
bool operator <= (const Stonewt &stn1, const Stonewt &stn2)
{
    return stn1.dpounds <= stn2.dpounds;
}
bool operator == (const Stonewt &stn1, const Stonewt &stn2)
{
    return stn1.dpounds == stn2.dpounds;
}
bool operator != (const Stonewt &stn1, const Stonewt &stn2)
{
    return stn1.dpounds != stn2.dpounds;
}
std::ostream &operator<<(std::ostream &os, const Stonewt &stn)
{
    if (stn.mode == Stonewt::STONE)
    {
        os << stn.stone << " stone, " << stn.pds_left << " pounds.";
    }
    else if (stn.mode == Stonewt::iPOUND)
    {
        os << stn.ipounds << " pounds.";
    }
    else
    {
        os << stn.dpounds << " pounds.";
    }
    return os;
}

stone3.cpp
#include <iostream>
#include "stonewt3.h"

int main()
{
    const int ARR_SIZE = 6;

    Stonewt eleven(11, 0);
    Stonewt arr[ARR_SIZE] = { 30.27, 102.34, 80.51 };
    Stonewt maxElement = arr[0];
    Stonewt minElement = arr[0];

    for (int i = 0, j = ARR_SIZE - 1; i < ARR_SIZE / 2; ++i, --j)
    {
        arr[j] = arr[i] * 2.0;
    }

    int quantity = 0;

    for (int i = 0; i < ARR_SIZE; ++i)
    {
        if (arr[i] > maxElement)
        {
            maxElement = arr[i];
        }
        if (arr[i] < minElement)
        {
            minElement = arr[i];
        }
        if (arr[i] >= eleven)
        {
            ++quantity;
        }
    }

    std::cout << "Maximal element is: " << maxElement << std::endl;
    std::cout << "Minimal element is: " << minElement << std::endl;
    std::cout << "Quantity of elements bigger than 11 stones is: " << quantity << std::endl;

    return 0;
}
显示结果如下
Maximal element is: 204.68 pounds.
Minimal element is: 30.27 pounds.
Quantity of elements bigger than 11 stones is: 2

7.复数有两个部分组成：实数部分和虚数部分。复数的一种书写方式是：（3.0，4.0），其中，3.0是实数部分，4.0是虚数部分。
假设a=（A，Bi），c=（C，Di），则下面是一些复数运算
加法：a+c=（A+C，（B+D）i）
减法：a-c=（A-C，（B-D）i）。
乘法：a*c=（A*C-B*D，（A*D + B*C）i）。
乘法：x*c=（x*C，x*Di），其中x为实数
共轭：~a-（A，-Bi）
请定义一个复数类，以便下面的程序可以使用它来获得正确的结果。
注意，必须重载运算符<<和>>。标准C++使用头文件complex提供了比这个示例更广泛的复数支持，
因此应将自定义的头文件命名为complex0.h，以免发生冲突。应尽可能使用const。
请注意，经过重载后，cin>>c将提示用户输入实数和虚数部分。
complex0.h
#pragma once
#ifndef COMPLEX0_H_
#define COMPLEX0_H_
#include <iostream>

class Complex
{
private:
    double m_real;
    double m_imag;
public:
    Complex();
    Complex(double n1, double n2);
    ~Complex();
    friend Complex operator + (const Complex &n1, const Complex &n2);
    friend Complex operator - (const Complex &n1, const Complex &n2);
    friend Complex operator * (const Complex &n1, const Complex &n2);
    friend Complex operator * (double num, const Complex &n);
    friend Complex operator * (const Complex &n, double num);
    friend Complex operator ~ (const Complex &c);
    friend std::istream &operator>>(std::istream &is, Complex &c);
    friend std::ostream &operator<<(std::ostream &os, const Complex &c);
};

#endif

complex0.cpp
#include "complex0.h"

Complex::Complex()
{
    m_real = 0;
    m_imag = 0;
}
Complex::Complex(double n1, double n2)
{
    m_real = n1;
    m_imag = n2;
}
Complex::~Complex()
{

}
Complex operator + (const Complex &n1, const Complex &n2)
{
    return Complex (n1.m_real + n2.m_real, n1.m_imag + n2.m_imag);
}
Complex operator - (const Complex &n1, const Complex &n2)
{
    return Complex (n1.m_real - n2.m_real, n1.m_imag - n2.m_imag);
}
Complex operator * (const Complex &n1, const Complex &n2)
{
    return Complex ( (n1.m_real * n2.m_real) - (n1.m_imag * n2.m_imag),  (n1.m_real * n2.m_imag) + (n1.m_imag * n2.m_real));
}
Complex operator * (double num, const Complex &n)
{
    return Complex (n.m_real * num, n.m_imag * num);
}
Complex operator * (const Complex &n, double num)
{
    return Complex (n.m_real * num, n.m_imag * num);
}
Complex operator ~ (const Complex &c)
{
    return Complex (c.m_real, -c.m_imag);
}
std::istream &operator >> (std::istream &is, Complex &c)
{
    std::cout << "real: ";
    if (is >> c.m_real)
    {
        std::cout << "imaginary: ";
        is >> c.m_imag;
    }
    return is;
}
std::ostream &operator<<(std::ostream &os, const Complex &c)
{
    os << "(" << c.m_real << ", " << c.m_imag << "i)";
    return os;
}

ch11_p07.cpp
#include <iostream>
#include "complex0.h"

int main()
{
    Complex a(3.0, 4.0);
    Complex c;

    std::cout << "Enter a complex number (q to quit) :\n";
    while (std::cin >> c)
    {
        std::cout << "c is " << c<< '\n';
        std::cout << "complex conjugate is " << ~c << '\n';

        std::cout << "a is " << a << '\n';
        std::cout << "a + c is " << a + c << '\n';
        std::cout << "a - c is " << a - c << '\n';
        std::cout << "a * c is " << a * c<< '\n';
        std::cout << "2 * c is " << 2 * c << '\n';
        std::cout << "Enter a complex number (q to quit) :\n";
    }
    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Enter a complex number (q to quit) :
real: 6
imaginary: 5
c is (6, 5i)
complex conjugate is (6, -5i)
a is (3, 4i)
a + c is (9, 9i)
a - c is (-3, -1i)
a * c is (-2, 39i)
2 * c is (12, 10i)
Enter a complex number (q to quit) :
real: q
Done.

第12章 类和动态内存分配
12.1 动态内存和类
12.1.1 复习示例和静态类成员
12.1.2 特殊成员函数
12.1.3 回到Stringbad：复制构造 函数的哪里出了问题.
12.1.4 Stringbad的其他问题：赋值运算符
12.2 改进后的新String类
12.2.1 修订后的默认构造函数
12.2.2 比较成员函数
12.2.3 使用中括号表示法访问字符
12.2.4 静态类成员函数
12.2.5 进一步重载赋值运算符
12.3 在构造函数中使用new时应注意的事项
12.3.1 应该和不应该
12.3.2 包含类成员的类的逐成员复制
12.4 有关返回对象的说明
12.4.1 返回指向const对象的引用
12.4.2 返回指向非const对象的引用
12.4.3 返回对象
12.4.4 返回const对象
12.5 使用指向对象的指针
12.5.1 再谈new和delete
12.5.2 指针和对象小结
12.5.3 再谈定位new运算符
12.6 复习各种技术
12.6.1 重载<<运算符
12.6.2 转换函数
12.6.3 其构造函数使用new的类
12.7 队列模拟
12.7.1 队列类
12.7.2 Customer类
12.7.3 ATM模拟
12.8 总结
12.9 复习题
12.10 编程练习
本章内容包括：
对类成员使用动态内存分配。
隐式和显式复制构造函数。
隐式和显式重载赋值运算符。
在构造函数中使用new所必须完成的工作。
使用静态类成员。
将定位new运算符用于对象。
使用指向对象的指针。
实现队列抽象数据类型（ADT）。
12.1动态内存和类
程序清单12.1 strngbad.h
#pragma once
#ifndef STRNGBAD_H_
#define STRNGBAD_H_
#include <iostream>

class StringBad
{
private:
    char *str;
    int len;
    static int num_strings;
public:
    StringBad(const char *s);
    StringBad();
    ~StringBad();
    friend std::ostream &operator<<(std::ostream &os, const StringBad &st);
};

#endif

程序清单12.2 strngbad.cpp
#include <cstring>
#include "strngbad.h"

using std::cout;

int StringBad::num_strings = 0;

StringBad::StringBad(const char *s)
{
    len = std::strlen(s);
    str = new char[len + 1];
    std::strcpy(str, s);
    num_strings++;
    cout << num_strings << " : \"" << str << "\" object created\n";
}
StringBad::StringBad()
{
    len = 4;
    str = new char[4];
    std::strcpy(str, "C++");
    num_strings++;
    cout << num_strings << " : \"" << str << "\" default object created\n";
}
StringBad::~StringBad()
{
    cout << num_strings << " : \"" << str << "\" object deleted, ";
    --num_strings;
    cout << num_strings << " left\n";
    delete [] str;
}
std::ostream &operator<<(std::ostream &os, const StringBad &st)
{
    os << st.str;
    return os;
}
注意，不能在类声明中初始化静态成员变量。对于静态类成员，可以在类声明之外使用单独的语句来进行初始化。
int StringBad::num_strings = 0;
初始化语句指出了类型，并使用了作用域运算符，但没有使用关键字static。
初始化是在类定义文件中，而不是在类声明文件中进行的，这是因为类声明位于头文件中，
程序可能将头文件包括在其他几个文件中。如果在头文件中进行初始化，将出现多个初始化语句副本，从而引发错误。
对于不能在类声明中初始化静态数据成员的一种例外情况（见第10章）是，静态数据成员为整型或枚举型const。
程序清单12.3 vegnews.cpp
#include "strngbad.h"

using std::cout;

void callme1(StringBad &);
void callme2(StringBad);

int main()
{
    using std::endl;
    {
        cout << "Starting an inner block.\n";
        StringBad headline1("Celery Stalks at Midnight");
        StringBad headline2("Lettuce Prey");
        StringBad sports("Spinach Leaves Bowl for Dollars");
        cout << "headline1: " << headline1 << endl;
        cout << "headline2: " << headline2 << endl;
        cout << "sports: " << sports << endl;
        callme1(headline1);
        cout << "headline1: " << headline1 << endl;
        callme2(headline2);
        cout << "headline2: " << headline2 << endl;
        cout << "Initialize one object to another:\n";
        StringBad sailor = sports;
        cout << "sailor: " << sailor << endl;
        cout << "Assign one object to another:\n";
        StringBad knot;
        knot = headline1;
        cout << "knot: " << knot << endl;
        cout << "Exiting the block.\n";
    }
    cout << "End of main()\n";

    return 0;
}

void callme1(StringBad &rsb)
{
    cout << "String passed by reference:\n";
    cout << " \"" << rsb << "\"\n";
}

void callme2(StringBad sb)
{
    cout << "String passed by value:\n";
    cout << " \"" << sb << "\"\n";
}
显示结果如下

Starting an inner block.
1 : "Celery Stalks at Midnight" object created
2 : "Lettuce Prey" object created
3 : "Spinach Leaves Bowl for Dollars" object created
headline1: Celery Stalks at Midnight
headline2: Lettuce Prey
sports: Spinach Leaves Bowl for Dollars
String passed by reference:
 "Celery Stalks at Midnight"
headline1: Celery Stalks at Midnight
String passed by value:
 "Lettuce Prey"
3 : "Lettuce Prey" object deleted, 2 left
headline2: ***
Initialize one object to another:
sailor: Spinach Leaves Bowl for Dollars
Assign one object to another:
3 : "C++" default object created
knot: Celery Stalks at Midnight
Exiting the block.
3 : "Celery Stalks at Midnight" object deleted, 2 left
2 : "Spinach Leaves Bowl for Dollars" object deleted, 1 left
1 : "***" object deleted, 0 left
free(): double free detected in tcache 2
Aborted (core dumped)

12.1.2特殊成员函数
StringBad类的问题是由特殊成员函数引起的。这些成员函数是自动定义的。
具体地说，C++自动提供了下面这些成员函数：
默认构造函数，如果没有定义构造函数；
默认析构函数，如果没有定义；
复制构造函数，如果没有定义；
赋值运算符，如果没有定义
地址运算符，如果没有定义。
如果程序使用对象的方式要求这样做，编译器将生成上述最后三个函数的定义。
例如，如果您将一个对象赋给另一个对象，编译器将提供赋值运算符的定义。
结果表明，StringBad类中的问题是由隐式复制构造函数和隐式赋值运算符引起的。
隐式地址运算符返回调用对象的地址（即this指针的值）。这与我们的初衷是一致的，在此不详细讨论该成员函数。
默认析构函数不执行任何操作，因此这里也不讨论，但需要指出的是，这个类已经提供默认构造函数。
至于其他成员函数还需要进一步讨论。
C++11提供了另外两个特殊成员函数：移动构造函数和移动赋值运算符，这将在第18章讨论。
1.默认构造函数
如果没有提供任何构造函数，C++将创建默认构造函数。
也就是说，编译器将提供一个不接受任何参数，也不执行任何操作的构造函数（默认的默认构造函数）。
如果定义了构造函数，C++将不会定义默认构造函数。
默认构造函数是没有任何参数或所有参数都有默认值的构造函数。
只能有一个默认构造函数。
2.复制构造函数
复制构造函数用于将一个对象复制到新创建的对象中。它用于初始化过程中（包括按值传递参数），而不是常规的赋值过程中。
类的复制构造函数原型通常如下
class_name (const class_name &);
它接受一个指向类对象的常量引用作为参数。
3.何时调用复制构造函数
新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。
每当程序生成了对象副本时，编译器都将使用复制构造函数。
具体地说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。
按值传递意味着创建原始变量的个副本，编译器生成临时对象时，也将使用复制构造函数。
4.默认的复制构造函数的功能
默认的复制构造函数逐个复制非静态成员，复制的是成员的值。
如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。
12.1.4 赋值运算符
C++允许类对象赋值，这是通过自动为类重载赋值运算符实现的，这种运算符的原型如下：
class_name & class_name::operator = (const class_name &);
它接受并返回一个指向类对象的引用。
1.赋值运算符的功能以及何时使用它
将已有的对象赋给另一个对象时，将使用重载的赋值运算。
初始化对象时，并不一定会使用赋值运算符，也有可能使用复制构造函数。
与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制。
如果成员本身就是类对象，则程序将使用为这个类定义的赋值运算符来复制该成员，但静态数据成员不受影响。
3.解决赋值的问题
对于由于默认赋值运算符不合适而导致的问题，解决办法是提供赋值运算符（进行深度复制）定义。
其实现与复制构造函数相似，但也有一些差别。
由于目标对象可能引用了以前分配的数据，所以函数应使用delete[]来释放这些数据。
函数应当避免将对象赋给自身；否则，给对象重新赋值前，释放内存操作可能删除对象的内容。
函数返回一个指向调用对象的引用。
12.2改进后的新String类
可以将成员函数声明为静态的，函数声明必须包含关键字static。
不能通过对象调用静态成员函数；实际上，静态成员函数甚至不能使用this指针。
如果静态成员函数是在公有部分声明的，则可以使用类名和作用域解析运算符来调用它。
由于静态成员函数不与特定的对象相关联，因此只能使用静态数据成员。
程序清单12.4 string1.h
#pragma once
#ifndef STRNG1_H_
#define STRNG1_H_
#include <iostream>

using std::ostream;
using std::istream;

class String
{
private:
    char *str;
    int len;
    static int num_strings;
    static const int CINLIM = 128;
public:
    String(const char *s);
    String();
    String(const String &);
    ~String();
    int length() const
    {
        return len;
    }
    String &operator=(const String &);
    String &operator=(const char *);
    char &operator [] (int i);
    const char &operator [] (int i) const;

    friend bool operator<(const String &st1, const String &st2);
    friend bool operator>(const String &st1, const String &st2);
    friend bool operator==(const String &st1, const String &st2);
    friend ostream &operator<<(ostream &os, const String &st);
    friend istream &operator>>(istream &is, String &st);

    static int HowMany();
};

#endif

程序清单12.5 string1.cpp
#include <cstring>
#include "string1.h"

using std::cin;
using std::cout;

int String::num_strings = 0;

int String::HowMany()
{
    return num_strings;
}

String::String(const char *s)
{
    len = std::strlen(s);
    str = new char[len + 1];
    std::strcpy(str, s);
    num_strings++;
}

String::String()
{
    len = 0;
    str = new char[1];
    str[0] = '\0';
    num_strings++;
}

String::String(const String &st)
{
    len = st.len;
    str = new char[len + 1];
    std::strcpy(str, st.str);
    num_strings++;
}
String::~String()
{
    --num_strings;
    delete[] str;
}
String &String::operator= (const String &st)
{
    if (this == &st)
    {
        return *this;
    }
    delete[] str;
    len = st.len;
    str = new char[len + 1];
    std::strcpy(str, st.str);
    return *this;
}
String &String::operator=(const char *s)
{
    delete[] str;
    len = std::strlen(s);
    str = new char[len + 1];
    std::strcpy(str, s);
    return *this;
}
char &String::operator [] (int i)
{
    return str[i];
}
const char &String::operator [] (int i) const
{
    return str[i];
}
bool operator<(const String &st1, const String &st2)
{
    return (std::strcmp(st1.str, st2.str) < 0);
}
bool operator>(const String &st1, const String &st2)
{
    return (std::strcmp(st1.str, st2.str) > 0);
}
bool operator==(const String &st1, const String &st2)
{
    return (std::strcmp(st1.str, st2.str) == 0);
}
ostream &operator<<(ostream &os, const String &st)
{
    os << st.str;
    return os;
}
istream &operator>>(istream &is, String &st)
{
    char temp[String::CINLIM];
    is.get(temp, String::CINLIM);
    if (is)
    {
        st = temp;
    }
    while (is && is.get() != '\n')
    {
        continue;
    }
    return is;
}

程序清单12.6 sayings1.cpp
#include "string1.h"

const int ArSize = 10;
const int MaxLen = 128;

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    String name;
    cout << "Hi, what's your name?\n>> ";
    cin >> name;
    cout << name << ", please enter up to " << ArSize << " short sayings <empty line to quit>:\n";
    String sayings[ArSize];
    char temp[MaxLen];
    int i;
    for (i = 0; i < ArSize; i++)
    {
        cout << i + 1 << ": ";
        cin.get(temp, MaxLen);
        while (cin && cin.get() != '\n')
        {
            continue;
        }
        if (!cin || temp[0] == '\0')
        {
            break;
        }
        else
        {
            sayings[i] = temp;
        }
    }
    int total = i;
    if (total > 0)
    {
        cout << "Here are your sayings:\n";
        for (i = 0; i < total; i++)
        {
            cout << sayings[i][0] << ": " << sayings[i] << endl;
        }
        int shortest = 0;
        int first = 0;
        for (i = 1; i < total; i++)
        {
            if (sayings[i].length() < sayings[shortest].length())
            {
                shortest = i;
            }
            if (sayings[i] < sayings[first])
            {
                first = i;
            }
        }
        cout << "Shortest saying:\n" << sayings[shortest] << endl;
        cout << "First alphabetically:\n" << sayings[first] << endl;
        cout << "This program used " << String::HowMany() << " String objects.\n";
    }
    else
    {
        cout << "No input!\n";
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Hi, what's your name?
>> WEIYAYUN
WEIYAYUN, please enter up to 10 short sayings <empty line to quit>:
1: Hello, World!
2: Peter Smith
3: Mike Pence
4: Java
5: C++
6: C
7: PYTHON
8: RUST
9: D
10: SWIFT
Here are your sayings:
H: Hello, World!
P: Peter Smith
M: Mike Pence
J: Java
C: C++
C: C
P: PYTHON
R: RUST
D: D
S: SWIFT
Shortest saying:
C
First alphabetically:
C
This program used 11 String objects.
Done.

12.3在构造面数中使用new时应注意的事项
如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete。
new对应于delete，new[]对应于delete[]。
如果有多个构造函数，则必须以相同的方式使用new，要么都带中括号，要么都不带。
因为只有一个析构函数，所有的构造函数都必须与它兼容。
然而，可以在一个构造函数中使用new初始化指针，而在另一个构造函数中将指针初始化为nullptr，
这是因为delete（无论是带中括号还是不带中括号）可以用于空指针。
应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。
另外，还应该更新所有受影响的静态类成员。
应当定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象。
12.4有关返回对象的说明
当成员函数或独立的函数返回对象时，有几种返回方式可供选择。
可以返回指向对象的引用、指向对象的const引用或const对象。
返回对象将调用复制构造函数，而返回引用不会。
如果被返回的对象是被调用函数中的局部变量，则不应按引用方式返回它，
因为在被调用函数执行完毕时，局部对象将调用其析构函数。
因此，当控制权回到调用函数时，引用指向的对象将不再存在。在这种情况下，应返回对象而不是引用。
如果方法或函数要返回一个没有公有复制构造函数的类（如ostream类）的对象，它必须返回一个指向这种对象的引用。
最后，有些方法和函数（如重载的赋值运算符）可以返回对象，也可以返回指向对象的引用，
在这种情况下，应首选引用，因为其效率更高。
12.5使用指向对象的指针
程序清单12.7 sayings2.cpp
#include <cstdlib>
#include <ctime>
#include "string1.h"

const int ArSize = 10;
const int MaxLen = 128;

int main()
{
    using namespace std;
    String name;
    cout << "Hi, what's your name?\n>> ";
    cin >> name;
    cout << name << ", please enter up to " << ArSize << " short sayings <empty line to quit>:\n";
    String sayings[ArSize];
    char temp[MaxLen];
    int i;
    for (i = 0; i < ArSize; i++)
    {
        cout << i + 1 << ": ";
        cin.get(temp, MaxLen);
        while (cin && cin.get() != '\n')
        {
            continue;
        }
        if (!cin || temp[0] == '\0')
        {
            break;
        }
        else
        {
            sayings[i] = temp;
        }
    }
    int total = i;
    if (total > 0)
    {
        cout << "Here are your sayings:\n";
        for (i = 0; i < total; i++)
        {
            cout << sayings[i] << "\n";
        }
        String *shortest = &sayings[0];
        String *first = &sayings[0];
        for (i = 1; i < total; i++)
        {
            if (sayings[i].length() < shortest->length())
            {
                shortest = &sayings[i];
            }
            if (sayings[i] < *first)
            {
                first = &sayings[i];
            }
        }
        cout << "Shortest saying: \n" << *shortest << endl;
        cout << "First alphabetically: \n" << * first << endl;
        srand(time(nullptr));
        int choice = rand() % total;
        String *favorite = new String(sayings[choice]);
        cout << "My favorite saying: \n" << *favorite << endl;
        delete favorite;
    }
    else
    {
        cout << "No input!\n";
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Hi, what's your name?
>> WEIYAYUN
WEIYAYUN, please enter up to 10 short sayings <empty line to quit>:
1: Apple
2: Orange
3: Egg
4: Water
5: Sun
6: C++
7: Java
8:
Here are your sayings:
Apple
Orange
Egg
Water
Sun
C++
Java
Shortest saying:
Egg
First alphabetically:
Apple
My favorite saying:
Water
Done.

在下述情况下析构函数将被调用（参见图12.4）。
如果对象是自动变量，则当执行完定义该对象的程序块时，将调用该对象的析构函数。
如果对象是静态变量，则在程序结束时将调用对象的析构函数。
如果对象是用new创建的，则仅当您显式使用delete删除对象时，其析构函数才会被调用。
12.5.2指针和对象小结
使用对象指针时，需要注意几点（参见图12.5）：
使用常规表示法来声明指向对象的指针；
可以将指针初始化为指向已有的对象；
可以使用new来初始化指针，这将创建一个新的对象；
对类使用new将调用相应的类构造函数来初始化新创建的对象；
可以使用->运算符通过指针访问类方法；
可以对对象指针应用解除引用运算符（*）来获得对象。
12.5.3再谈定位new运算符
程序清单12.8 placenew1.cpp
#include <iostream>
#include <string>
#include <new>

using namespace std;

const int BUF = 512;

class JustTesting
{
private:
    string words;
    int number;
public:
    JustTesting(const string &s = "Just Testing", int n = 0)
    {
        words = s;
        number = n;
        cout << words << " constructed\n";
    }
    ~JustTesting()
    {
        cout << words << " destroyed\n";
    }
    void Show() const
    {
        cout << words << ", " << number << endl;
    }
};

int main()
{
    char *buffer = new char[BUF];
    JustTesting *pc1, *pc2;
    pc1 = new (buffer) JustTesting;
    pc2 = new JustTesting("Heap1", 20);
    cout << "Memory block addresses:\n" << "buffer: " << (void *) buffer << " pc1: " << pc1;
    cout << " pc2: " << pc2 << endl;
    cout << "Memory contents:\n";
    cout << "pc1 : ";
    pc1->Show();
    cout << "pc2 : ";
    pc2->Show();
    JustTesting *pc3, *pc4;
    pc3 = new (buffer) JustTesting("Bad Idea", 6);
    pc4 = new JustTesting("Heap2", 10);
    cout << "Memory block addresses:\n" << " pc3: " << pc3 << " pc4: " << pc4 << endl;
    cout << "Memory contents : \n";
    cout << "pc3 : ";
    pc3->Show();
    cout << "pc4 : ";
    pc4->Show();
    delete pc2;
    delete pc4;
    delete[] buffer;
    cout << "Done.\n";

    return 0;
}
显示结果如下
Just Testing constructed
Heap1 constructed
Memory block addresses:
buffer: 0x5646411a0eb0 pc1: 0x5646411a0eb0 pc2: 0x5646411a14d0
Memory contents:
pc1 : Just Testing, 0
pc2 : Heap1, 20
Bad Idea constructed
Heap2 constructed
Memory block addresses:
 pc3: 0x5646411a0eb0 pc4: 0x5646411a1500
Memory contents :
pc3 : Bad Idea, 6
pc4 : Heap2, 10
Heap1 destroyed
Heap2 destroyed
Done.

程序清单12.9 placenew2.cpp
#include <iostream>
#include <string>
#include <new>

using namespace std;

const int BUF = 512;

class JustTesting
{
private:
    string words;
    int number;
public:
    JustTesting(const string &s = "Just Testing", int n = 0)
    {
        words = s;
        number = n;
        cout << words << " constructed\n";
    }
    ~JustTesting()
    {
        cout << words << " destroyed\n";
    }
    void Show() const
    {
        cout << words << ", " << number << endl;
    }
};

int main()
{
    char *buffer = new char[BUF];
    JustTesting *pc1, *pc2;
    pc1 = new (buffer) JustTesting;
    pc2 = new JustTesting("Heap1", 20);
    cout << "Memory block addresses:\n" << "buffer: " << (void *) buffer << " pc1: " << pc1;
    cout << " pc2: " << pc2 << endl;
    cout << "Memory contents:\n";
    cout << "pc1 : ";
    pc1->Show();
    cout << "pc2 : ";
    pc2->Show();
    JustTesting *pc3, *pc4;
    pc3 = new (buffer + sizeof(JustTesting)) JustTesting("Bad Idea", 6);
    pc4 = new JustTesting("Heap2", 10);
    cout << "Memory block addresses:\n" << "pc3: " << pc3 << " pc4: " << pc4 << endl;
    cout << "Memory contents : \n";
    cout << "pc3 : ";
    pc3->Show();
    cout << "pc4 : ";
    pc4->Show();
    delete pc2;
    delete pc4;
    pc3->~JustTesting();
    pc1->~JustTesting();
    delete[] buffer;
    cout << "Done.\n";

    return 0;
}
显示结果如下
Just Testing constructed
Heap1 constructed
Memory block addresses:
buffer: 0x56100f686eb0 pc1: 0x56100f686eb0 pc2: 0x56100f6874d0
Memory contents:
pc1 : Just Testing, 0
pc2 : Heap1, 20
Bad Idea constructed
Heap2 constructed
Memory block addresses:
pc3: 0x56100f686ed8 pc4: 0x56100f687500
Memory contents :
pc3 : Bad Idea, 6
pc4 : Heap2, 10
Heap1 destroyed
Heap2 destroyed
Bad Idea destroyed
Just Testing destroyed
Done.

在类声明中声明的结构、类或枚举被称为是被嵌套在类中，其作用域为整个类。
这种声明不会创建数据对象，而只是指定了可以在类中使用的类型。
如果声明是在类的私有部分进行的，则只能在这个类使用被声明的类型；
如果声明是在公有部分进行的，则可以从类的外部通过作用域解析运算符使用被声明的类型。
例如，如果Node是在Queue类的公有部分声明的，则可以在类的外面声明Queue:Node类型的变量。
使用const声明的常量，可以对它进行初始化，但不能给它赋值。
从概念上说，调用构造函数时，对象将在括号中的代码执行之前被创建。
然后，程序流程进入到括号中，使用常规的赋值方式将值存储到内存中。
因此，对于const数据成员，必须在执行到构造函数体之前，即创建对象时进行初始化。
C++提供了一种特殊的语法来完成上述工作，它叫做成员初始化列表（member initializer list）。
成员初始化列表由逗号分隔的初始化列表组成（前面带冒号）。它位于参数列表的右括号之后、函数体左括号之前。
如果数据成员的名称为mdata，并需要将它初始化为val，则初始化器为mdata (val)。
通常，初值可以是常量或构造函数的参数列表中的参数。
这种方法并不限于初始化const数据成员，也可以用来初始化正常的数据成员。
只有构造函数可以使用这种初始化列表语法。对于const类成员，必须使用这种语法。
另外，对于被声明为引用的类成员，也必须使用这种语法。
这是因为引用与const数据类似，只能在被创建时进行初始化。
对于简单数据成员，使用成员初始化列表和在函数体中使用赋值没有什么区别。
然而，对于本身就是类对象的成员来说，使用成员初始化列表的效率更高。
成员初始化列表的语法
如果Classy是一个类，而mem1、mem2和mem3都是这个类的数据成员，则类构造函数可以使用如下的语法来初始化数据成员：
Classy::Crassy(int n, int m) : mem1(n), mem2(0), mem3 (n*m + 2)
{
    // ...
}
上述代码将mem1初始化为n，将mem2初始化为0，将mem3初始化为n*m+2。
从概念上说，这些初始化工作是在对象创建时完成的，此时还未执行括号中的任何代码。请注意以下几点：
这种格式只能用于构造函数；
必须用这种格式来初始化非静态const数据成员（至少在C++11之前是这样的）；
必须用这种格式来初始化引用数据成员。
数据成员被初始化的顺序与它们出现在类声明中的顺序相同，与初始化器中的排列顺序无关。
不能将成员初始化列表语法用于构造函数之外的其他类方法。
成员初始化列表使用的括号方式也可用于常规初始化。也就是说，如果愿意，可以将下述代码：
int games=162;
double talk =2.71828;
替换为：
int games (162);
double talk (2.71828);
这使得初始化内置类型就像初始化类对象一样。
C++11允许您以更直观的方式进行初始化：
class Classy
{
    int mem1=10;   //in-class initialization
    const int mem2 = 20;   //in-class initialization
    // ...
}
这与在构造函数中使用成员初始化列表等价：
Classy::Classy() : mem1(10), mem2 (20)
{
    // ...
}
成员mem1和mem2将分别被初始化为10和20，除非调用了使用成员初始化列表的构造函数，
在这种情况下，实际列表将覆盖这些默认初始值：
classy::classy (int n) : mem1(n)
{
    // ...
}
在这里，构造函数将使用n来初始化mem1，但mem2仍被设置为20。
程序清单12.10 queue.h
#pragma once
#ifndef QUEUE_H_  
#define QUEUE_H_ 

class Customer
{
private:
	long arrive;
	int processtime;
public:
	Customer() { arrive = processtime = 0; }
	void set(long when);
	long when() const { return arrive; }
	int ptime() const { return processtime; }
};

typedef Customer Item;

class Queue
{
private:
	struct Node { Item item; struct Node* next; };
	enum { Q_SIZE = 10 };
	Node* front;
	Node* rear;
	int items;
	const int qsize;
					 
	Queue(const Queue & q) : qsize(0) { }
	Queue & operator=(const Queue & q) { return *this; }
public:
	Queue(int qs = Q_SIZE);
	~Queue();
	bool isempty() const;
	bool isfull() const;
	int queuecount() const;
	bool enqueue(const Item &item);
	bool dequeue(Item &item);
};

#endif

程序清单12.11 queue.cpp
#include <cstdlib>
#include "queue.h"

Queue::Queue(int qs) : qsize(qs)
{
    front = rear = NULL;
    items = 0;
}

Queue::~Queue()
{
    Node *next;
    while (front != NULL)
    {
        next = front->next;
        delete front;
        front = next;
    }
}

bool Queue::isempty() const
{
    return items == 0;
}

bool Queue::isfull() const
{
    return items == qsize;
}

int Queue::queuecount() const
{
    return items;
}
bool Queue::enqueue(const Item &item)
{
    if (isfull())
    {
        return false;
    }
    Node *add = new Node;

    add->item = item;
    add->next = NULL;
    if (items == 0)
    {
        front = add;
        rear = add;
    }
    else
    {
        rear->next = add;
        rear = add;
    }
    items++;
    return true;
}
bool Queue::dequeue(Item &item)
{
    if (isempty())
    {
        return false;
    }
    item = front->item;
    items--;
    Node *next = front->next;
    delete front;
    front = next;
    if (items == 0)
    {
        front = NULL;
        rear = NULL;
    }
    return true;
}
void Customer::set(long when)
{
    processtime = std::rand() % 3 + 1;
    arrive = when;
}

程序清单12.12 usequeue.cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
#include "queue.h"

const int MIN_PER_HR = 60;

bool newcustomer(double x);

int main()
{
    using std::cin;
    using std::cout;
    using std::endl;
    using std::ios_base;

    std::srand(std::time(nullptr));

    cout << "Case Study: Bank of Heather Automatic Teller\n";
    cout << "Enter maximum size of queue: ";
    int qs;
    cin >> qs;
    Queue line(qs);

    cout << "Enter the number of simulation hours: ";
    int hours;
    cin >> hours;
    long cyclelimit = MIN_PER_HR * hours;

    cout << "Enter the average number of customers per hour: ";
    double perhour;
    cin >> perhour;
    double min_per_cust;
    min_per_cust = MIN_PER_HR / perhour;

    Item temp;
    long turnaways = 0;
    long customers = 0;
    long served = 0;
    long sum_line = 0;
    int wait_time = 0;
    long line_wait = 0;

    for (long cycle = 0; cycle < cyclelimit; cycle++)
    {
        if (newcustomer(min_per_cust))
        {
            if (line.isfull())
            {
                turnaways++;
            }
            else
            {
                customers++;
                temp.set(cycle);
                line.enqueue(temp);
            }
        }
        if (wait_time <= 0 && !line.isempty())
        {
            line.dequeue(temp);
            wait_time = temp.ptime();
            line_wait += cycle - temp.when();
            served++;
        }
        if (wait_time > 0)
        {
            wait_time--;
        }
        sum_line += line.queuecount();
    }

    if (customers > 0)
    {
        cout << "customers accepted: " << customers << endl;
        cout << "customers served: " << served << endl;
        cout << "customers turnaways: " << turnaways << endl;
        cout.precision(2);
        cout.setf(ios_base::fixed, ios_base::floatfield);
        cout << "average queue size: " << (double)sum_line / cyclelimit << endl;
        cout << "average wait time: " << (double)line_wait / served << " minutes\n";
    }
    else
    {
        cout << "No customers!\n";
    }
    cout << "Done.\n";

    return 0;
}
bool newcustomer(double x)
{
    return ( (std::rand() * x) / RAND_MAX < 1);
}
显示结果如下
Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 10
Enter the number of simulation hours: 3
Enter the average number of customers per hour: 30
customers accepted: 85
customers served: 80
customers turnaways: 1
average queue size: 2.76
average wait time: 5.71 minutes
Done.

Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 10
Enter the number of simulation hours: 3
Enter the average number of customers per hour: 60
customers accepted: 98
customers served: 88
customers turnaways: 82
average queue size: 8.84
average wait time: 16.80 minutes
Done.

Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 10
Enter the number of simulation hours: 3
Enter the average number of customers per hour: 90
customers accepted: 103
customers served: 94
customers turnaways: 77
average queue size: 8.83
average wait time: 16.31 minutes
Done.

12.8总结
在类构造函数中，可以使用new为数据分配内存；然后将内存地址赋给类成员。
这样，类便可以处理长度不同的字符串，而不用在类设计时提前固定数组的长度。
如果对象包含指向new分配的内存的指针成员，则释放对象的内存并不会自动释放指针成员指向的内存。
因此如果在类构造函数中使用了new来分配内存，则在类析构函数中需要使用delete来释放new分配的内存。
这样，当对象过期时将自动释放其指针成员指向的内存。
如果对象包含指向new分配的内存的指针成员，则将一个对象初始化为另一个对象或将一个对象赋给另一个对象时也会出现问题。
在默认情况下，C++逐个对成员进行初始化和赋值，这意味着被初始化或被赋值的对象的成员将与原始对象完全相同。
如果原始对象的成员指向一个数据块，则副本成员将指向同一个数据块。
当程序最终删除这两个对象时，类的析构函数将试图删除同一个内存数据块两次，这将出错。解决方法是：
定义一个特殊的复制构造函数来重新定义初始化，并重载赋值运算符。
在上述任何一种情况下，新的定义都将创建指向数据的副本；并使新对象指向这些副本。
这样，旧对象和新对象都将引用独立的、相同的数据，而不会重叠。由于同样的原因，必须定义赋值运算符。
对于每一种情况，最终目的都是执行深度复制，也就是说，复制实际的数据，而不仅仅是复制指向数据的指针。
对象的存储持续性为自动或外部时，在它不再存在时将自动调用其析构函数。
如果使用new运算符为对象分配内存，并将其地址赋给一个指针，则当您将delete用于该指针时将自动为对象调用析构函数。
然而；如果使用定位new运算符（而不是常规new运算符）为类对象分配内存，
则必须负责显式地为该对象调用析构函数，方法是使用指向该对象的指针调用析构函数。
C++允许在类中包含结构、类和枚举定义。这些嵌套类型的作用域为整个类，
这意味着它们被局限于类中，不会与其他地方定义的同名结构、类和校举发生冲突。
c++为类构造函数提供了一种可用来初始化数据成员的特殊语法。
这种语法包括冒号和由逗号分隔的初始化列表，被放在构造函数参数的右括号后，函数体的左括号之前。
每一个初始化器都由被初始化的成员的名称和包含初始值的括号组成。
从概念上来说，这些初始化操作是在对象创建时进行的，此时函数体中的语句还没有执行。
如果数据成是非静态const成员或引用，则必须采用这种格式，但可将C++11新增的类内初始化用于非静态const成员。
C++11允许类内初始化，即在类定义中进行初始化。这与使用成员初始化列表等价。
然而，使用成员初始化列表的构造函数将覆盖相应的类内初始化。
12.9复习题
1.假设String类有如下私有成员：
class String
{
private:
    char *str;
    int len;
    // ...
}
a.下述默认构造函数有什么问题？
String::String() {}
语法是正确的，但该构造函数没有将str指针初始化。该构造函数应将指针设置成nullptr或使用new[]来初始化它。
b.下述构造函数有什么问题？
String::String(const char *s)
{
    str = s;
    len = strlen(s);
}
该构造函数没有创建新的字符串，而只是复制了原有字符串的地址。它应当使用new[]和strcpy()。
c.下述构造函数有什么问题？
String::String(const char *s)
{
    strcpy(str, s);
    len = strlen(s);
}
它复制了字符串，但没有给它分配存储空间，应先使用new char[len + 1]来分配适当数量的内存。

2.如果您定义了一个类，其指针成员是使用new初始化的，请指出可能出现的3个问题以及如何纠正这些问题。
首先，当这种类型的对象过期时，对象的指针成员指向的数据仍将保留在内存中，
这将占用空间，同时不可访问，因为指针已经丢失。
可以让类析构函数删除构造函数中new分配的内存，来解决这种问题。
其次，析构函数释放这种内存后，如果程序将这样的对象初始化为另一个对象，则析构函数将试图释放这些内存两次。
这是因为将一个对象初始化为另一个对象的默认初始化，将复制指针值，但不复制指向的数据，这将使两个指针指向相同的数据。
解决方法是，定义一个复制构造函数，使初始化复制指向的数据。
第三，将一个对象赋给另一个对象也将导致两个指针指向相同的数据。
解决方法是重载赋值运算符，使之复制数据，而不是指针。

3.如果没有显式提供类方法，编译器将自动生成哪些类方法？请描述这些隐式生成的函数的行为。
C++自动提供下面的成员函数：
如果没有定义构造函数，将提供默认构造函数。
如果没有定义复制构造函数，将提供复制构造函数。
如果没有定义赋值运算符，将提供赋值运算符。
如果没有定义析构函数，将提供默认析构函数.
如果没有定义地址运算符，将提供地址运算符。
默认构造函数不完成任何工作，但使得能够声明数组和未初始化的对象。
默认复制构造函数和默认赋值运算符使用成员赋值。
默认析构函数也不完成任何工作。隐式地址运算符返回调用对象的地址（即this指针的值）。

4.找出并改正下述类声明中的错误：
class nifty
{
                                    //应该声明private:
    char personality[];   //应该声明为字符数组或字符指针或string对象
    int talents;
                                    //应该声明public:
    nifty ();
    nifty (char * s);
    ostream & operator << (ostream & os, nifty & n);
};
nifty::nifty()
{
    personality = NULL;
    talents = 0;
}
nifty:nifty(char * s)
{
    personality = new char[strlen(s)];
    personality = s;
    talents = 0;
}
ostream & nifty::operator << (ostream & os, nifty & n)
{
    os << n;
}
修改后
#include <string>

class nifty
{
private:
    std::string personality;
    int talents;
public:
    nifty();
    nifty(const char * s);
    friend ostream & operator << (ostream & os, const nifty & n);
};

nifty::nifty()
{
    personality = "";
    talents = 0;
}
nifty::nifty(const char *s)
{
    personality = s;
    talents = 0;
}
ostream & operator << (ostream & os, const nifty & n)
{
    os << n.personality << '\n';
    os << n.talents << '\n';
    return os;
}
5.对于下面的类声明：
class Golfer
{
private:
    char * fullname;
    int games;
    int * scores;
public:
    Golfer();
    Golfer (const char * name, int g = 0);
    Golfer (const Golfer & g);
    ~Golfer();
};
a.下列各条语句将调用哪些类方法？
Golfer nancy;   默认构造函数Golfer();
Golfer lulu ("Little Lulu");   Golfer (const char * name, int g);
Golfer roy ("Roy Hobbs", 12);   Golfer (const char * name, int g);
Golfer * par =new Golfer;    默认构造函数Golfer();
Golfer next = lulu;   复制构造函数 Golfer (const Golfer & g);
Golfer hazzard = "Weed Thwacker";   Golfer (const char * name, int g);
*par = nancy;   默认赋值运算符
nancy = "Nancy Putter";   先构造临时对象，再赋值 Golfer (const char * name, int g); 默认赋值运算符
b.很明显，类需要有另外几个方法才能更有用，但是类需要哪些方法才能防止数据被损坏呢？
定义复制构造函数，重载赋值运算符，处理好指针成员的数据复制问题。

12.10编程练习
1.对于下面的类声明：
给这个类提供实现，并编写一个使用所有成员函数的小程序。
cow.h
#pragma once
#ifndef COW_H_
#define COW_H_

#include <iostream>

using std::ostream;

class Cow
{
    char name[20];
    char *hobby;
    double weight;
public:
    Cow();
    Cow(const char *nm, const char *ho, double wt);
    Cow(const Cow &c);
    ~Cow();
    Cow & operator = (const Cow & c);
    friend ostream & operator << (ostream & os, const Cow & c);
};

#endif

cow.cpp
#include <iostream>
#include <cstring>
#include "cow.h"

Cow::Cow()
{
    std::cout << "Default constructor called" << std::endl;

    name[0] = '\0';
    hobby = new char[1];
    hobby[0] = '\0';
    weight = 0;
}

Cow::Cow(const char *nm, const char *ho, double wt)
{
    std::cout << "Constructor with parameters was called" << std::endl;

    strncpy(name, nm, 20);
    hobby = new char[strlen(ho) + 1];
    strcpy(hobby, ho);
    weight = wt;
}

Cow::Cow(const Cow &c)
{
    std::cout << "Copy Constructor called" << std::endl;

    strncpy(name, c.name, 20);
    hobby = new char[strlen(c.hobby) + 1];
    strcpy(hobby, c.hobby);
    weight = c.weight;
}

Cow::~Cow()
{
    std::cout << name << " Called the destructor" << std::endl;

    delete[] hobby;
}

Cow &Cow::operator = (const Cow &c)
{
    std::cout << "Assignment operator called" << std::endl;

    if (this == &c)
    {
        return *this;
    }
    delete[] hobby;

    strncpy(name, c.name, 20);
    hobby = new char[strlen(c.hobby) + 1];
    strcpy(hobby, c.hobby);
    weight = c.weight;

    return *this;
}
ostream &operator<<(ostream &os, const Cow &c)
{
    os << "Name: " << c.name << '\n';
    os << "Hobby: " << c.hobby << '\n';
    os << "Weight: " << c.weight << "\n\n";
    return os;
}

ch12_p01.cpp
#include <iostream>
#include "cow.h"

int main()
{
    {
        std::cout << "Cow 1:\n";
        Cow Cow1;

        std::cout << "Cow 2:\n";
        Cow Cow2("Cow2", "HOBBY", 89);

        std::cout << "Cow 3:\n";
        Cow Cow3 = Cow2;

        std::cout << "Cow 4:\n";
        Cow Cow4;
        Cow4 = Cow2;


        std::cout << std::endl;

        std::cout << "Cow 1:\n" << Cow1;
        std::cout << "Cow 2:\n" << Cow2;
        std::cout << "Cow 3:\n" << Cow3;
        std::cout << "Cow 4:\n" << Cow4;

        std::cout << std::endl;
    }

    return 0;
}
显示结果如下
Cow 1:
Default constructor called
Cow 2:
Constructor with parameters was called
Cow 3:
Copy Constructor called
Cow 4:
Default constructor called
Assignment operator called

Cow 1:
Name:
Hobby:
Weight: 0

Cow 2:
Name: Cow2
Hobby: HOBBY
Weight: 89

Cow 3:
Name: Cow2
Hobby: HOBBY
Weight: 89

Cow 4:
Name: Cow2
Hobby: HOBBY
Weight: 89


Cow2 Called the destructor
Cow2 Called the destructor
Cow2 Called the destructor
 Called the destructor

2.通过完成下面的工作来改进String类声明。
a.对+运算符进行重载，使之可将两个字符串合并成1个。
b.提供一个成员函数，将字符串中所有的字母字符转换为小写。
c.提供一个成员函数，将字符串中所有字母字符转换成大写。
d.提供一个这样的成员函数，它接受一个char参数，返回该字符在字符串中出现的次数。
使用下面的程序来测试您的工作：
string2.h
#pragma once
#ifndef STRNG2_H_
#define STRNG2_H_
#include <iostream>

using std::ostream;
using std::istream;

class String
{
private:
    char *str;
    int len;
    static int num_strings;
    static const int CINLIM = 128;
public:
    String(const char *s);
    String();
    String(const String &);
    ~String();
    int length() const
    {
        return len;
    }
    void stringup();
    void stringlow();
    int has(char ch);
    String &operator=(const String &);
    String &operator=(const char *);
    char &operator [] (int i);
    const char &operator [] (int i) const;

    friend bool operator<(const String &st1, const String &st2);
    friend bool operator>(const String &st1, const String &st2);
    friend bool operator==(const String &st1, const String &st2);
    friend ostream &operator<<(ostream &os, const String &st);
    friend istream &operator>>(istream &is, String &st);
    friend String operator + (const String &st1, const String &st2);
    friend String operator + (const char *s, const String &st);
    friend String operator + (const String &st, const char *s);

    static int HowMany();
};

#endif

string2.cpp
#include <cstring>
#include <cctype>
#include "string2.h"

using std::cin;
using std::cout;

int String::num_strings = 0;

int String::HowMany()
{
    return num_strings;
}

String::String(const char *s)
{
    len = std::strlen(s);
    str = new char[len + 1];
    std::strcpy(str, s);
    num_strings++;
}

String::String()
{
    len = 0;
    str = new char[1];
    str[0] = '\0';
    num_strings++;
}

String::String(const String &st)
{
    len = st.len;
    str = new char[len + 1];
    std::strcpy(str, st.str);
    num_strings++;
}
String::~String()
{
    --num_strings;
    delete[] str;
}
void String::stringup()
{
    for (int i = 0; str[i] != '\0'; i++)
    {
        str[i] = toupper(str[i]);
    }
}
void String::stringlow()
{
    for (int i = 0; str[i] != '\0'; i++)
    {
        str[i] = tolower(str[i]);
    }
}
int String::has(char ch)
{
    int count = 0;
    for (int i = 0; i < len; i++)
    {
        if (str[i] == ch)
        {
            count++;
        }
    }
    return count;
}
String &String::operator= (const String &st)
{
    if (this == &st)
    {
        return *this;
    }
    delete[] str;
    len = st.len;
    str = new char[len + 1];
    std::strcpy(str, st.str);
    return *this;
}
String &String::operator=(const char *s)
{
    delete[] str;
    len = std::strlen(s);
    str = new char[len + 1];
    std::strcpy(str, s);
    return *this;
}
char &String::operator [] (int i)
{
    return str[i];
}
const char &String::operator [] (int i) const
{
    return str[i];
}
bool operator<(const String &st1, const String &st2)
{
    return (std::strcmp(st1.str, st2.str) < 0);
}
bool operator>(const String &st1, const String &st2)
{
    return (std::strcmp(st1.str, st2.str) > 0);
}
bool operator==(const String &st1, const String &st2)
{
    return (std::strcmp(st1.str, st2.str) == 0);
}

String operator + (const String &st1, const String &st2)
{
    String temp;
    delete [] temp.str;

    temp.len = strlen(st1.str) + strlen(st2.str);
    temp.str = new char[temp.len + 1];
    strcat(strcpy(temp.str, st1.str), st2.str);

    return temp;
}
String operator+(const char *s, const String &st)
{
    String temp;
    delete[] temp.str;

    temp.len = strlen(s) + st.len;
    temp.str = new char[temp.len + 1];
    strcat(strcpy(temp.str, s), st.str);

    return temp;
}
String operator+(const String &st, const char *s)
{
    String temp;
    delete[] temp.str;

    temp.len = strlen(s) + st.len;
    temp.str = new char[temp.len + 1];
    strcat(strcpy(temp.str, st.str), s);

    return temp;
}
ostream &operator<<(ostream &os, const String &st)
{
    os << st.str;
    return os;
}
istream &operator>>(istream &is, String &st)
{
    char temp[String::CINLIM];
    is.get(temp, String::CINLIM);
    if (is)
    {
        st = temp;
    }
    while (is && is.get() != '\n')
    {
        continue;
    }
    return is;
}

ch12_p02.cpp
#include "string2.h"

const int ArSize = 10;
const int MaxLen = 128;

int main()
{
    String s1(" and I am a C++ student.");
    String s2 = "Please enter your name: ";
    String s3;

    std::cout << s2;
    std::cin >> s3;
    s2 = "My name is " + s3;

    std::cout << s2 << "." << std::endl;
    s2 = s2 + s1;

    s2.stringup();

    std::cout << "The string\n" << s2 << "\ncontains " << s2.has('A');
    std::cout << " 'A' characters in it." << std::endl;
    std::cout << std::endl;

    s1 = "red";
    String rgb[3] = { String(s1), String("green"), String("blue") };

    std::cout << "Enter the name of a primary color for mixing light: ";

    String ans;
    bool success = false;

    while (std::cin >> ans)
    {
        ans.stringlow();
        for (int i = 0; i < 3; i++)
        {
            if (ans == rgb[i])
            {
                std::cout << "That's right!\n";
                success = true;
                break;
            }
        }
        if (success)
        {
            break;
        }
        else
        {
            std::cout << "Try again! \n";
        }
    }
    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Please enter your name: Apple
My name is Apple.
The string
MY NAME IS APPLE AND I AM A C++ STUDENT.
contains 5 'A' characters in it.

Enter the name of a primary color for mixing light: yellow
Try again!
red
That's right!
Done.

3.重新编写程序清单10.7和程序清单10.8描述的Stock类，使之使用动态分配的内存，而不是string类对象来存储股票名称。
另外，使用重载的operator<<定义代替show成员函数。再使用程序清单10.9测试新的定义程序。
stock30.h
#pragma once
#ifndef STOCK30_H_
#define STOCK30_H_
#include <string>
#include <iostream>

class Stock
{
private:
    char *company;
    int shares;
    double share_val;
    double total_val;
    void set_tot()
    {
        total_val = shares * share_val;
    }
public:
    Stock();
    Stock(const char *s, long n = 0, double pr = 0.0);
    ~Stock();
    void buy(long num, double price);
    void sell(long num, double price);
    void update(double price);
    const Stock &topval(const Stock &s) const;
    friend std::ostream &operator << (std::ostream &os, const Stock &st);

};

#endif

stock30.cpp
#include <cstring>
#include "stock30.h"

Stock::Stock()
{
    std::cout << "Default constructor called\n";
    company = new char[1];
    company[0] = '\0';
    shares = 0;
    share_val = 0.0;
    total_val = 0.0;
}
Stock::Stock(const char *s, long n, double pr)
{
    std::cout << "Constructor using " << s << " called\n";
    company = new char[strlen(s) + 1];
    strcpy(company, s);

    if (n < 0)
    {
        std::cout << "Number of shares can't be negative; " << company << " shares set to 0.\n";
        shares = 0;
    }
    else
    {
        shares = n;
    }

    share_val = pr;
    set_tot();
}

Stock::~Stock()
{
    std::cout << "Bye, " << company << "!\n";
    delete[] company;
}

void Stock::buy(long num, double price)
{
    if (num < 0)
    {
        std::cout << "Number of shares purchased can't be negative. " << "Transaction is aborted.\n";
    }
    else
    {
        shares += num;
        share_val = price;
        set_tot();
    }
}

void Stock::sell(long num, double price)
{
    using std::cout;
    if (num < 0)
    {
        cout << "Number of shares sold can't be negative. " << "Transaction is aborted.\n";
    }
    else if (num > shares)
    {
        cout << "You can't sell more than you have! " << "Transaction is aborted.\n";
    }
    else
    {
        shares -= num;
        share_val = price;
        set_tot();
    }
}
void Stock::update(double price)
{
    share_val = price;
    set_tot();
}
std::ostream &operator << (std::ostream &os, const Stock &st)
{
    using std::ios_base;
    ios_base::fmtflags orig = os.setf(ios_base::fixed, ios_base::floatfield);
    std::streamsize prec = os.precision(3);
    os << "Company: " << st.company << ", Shares: " << st.shares << '\n';
    os << "Share Price: $" << st.share_val;
    os.precision(2);
    os << ", Total Worth: $" << st.total_val << '\n';
    os.setf(orig, ios_base::floatfield);
    os.precision(prec);

    return os;
}

const Stock &Stock::topval(const Stock &s) const
{
    if (s.total_val > total_val)
    {
        return s;
    }
    else
    {
        return *this;
    }
}

ch12_p03.cpp
#include <iostream>
#include "stock30.h"

const int STKS = 4;

int main()
{
    Stock stocks[STKS] =
    {
        Stock("NanoSmart", 12, 20.0),
        Stock("Boffo Objects", 200, 2.0),
        Stock("Monolithic Obelisks", 130, 3.25),
        Stock("Fleep Enterprises", 60, 6.5)
    };

    std::cout << "Stock holdings:\n";
    int st;
    for (st = 0; st < STKS; st++)
    {
        std::cout << stocks[st];
    }
    const Stock *top = &stocks[0];
    for (st = 1; st < STKS; st++)
    {
        top = & ( top->topval(stocks[st]) );
    }
    std::cout << "\nMost valuable holding:\n";
    std::cout << *top;

    return 0;
}
显示结果如下
Constructor using NanoSmart called
Constructor using Boffo Objects called
Constructor using Monolithic Obelisks called
Constructor using Fleep Enterprises called
Stock holdings:
Company: NanoSmart, Shares: 12
Share Price: $20.000, Total Worth: $240.00
Company: Boffo Objects, Shares: 200
Share Price: $2.000, Total Worth: $400.00
Company: Monolithic Obelisks, Shares: 130
Share Price: $3.250, Total Worth: $422.50
Company: Fleep Enterprises, Shares: 60
Share Price: $6.500, Total Worth: $390.00

Most valuable holding:
Company: Monolithic Obelisks, Shares: 130
Share Price: $3.250, Total Worth: $422.50
Bye, Fleep Enterprises!
Bye, Monolithic Obelisks!
Bye, Boffo Objects!
Bye, NanoSmart!

4.请看下面程序清单10.10定义的Stack类的变量：
正如私有成员表明的，这个类使用动态分配的数组来保存栈项。
请重新编写方法，以适应这种新的表示法，并编写一个程序来演示所有的方法，包括复制构造函数和赋值运算符。
stack2.h
#pragma once
#ifndef STACK2_H_
#define STACK2_H_
#include <iostream>

typedef unsigned long Item;

class Stack
{
private:
    enum { MAX = 10 };
    Item *pitems;
    int size;
    int top;
public:
    Stack(int n = MAX);
    Stack(const Stack &st);
    ~Stack();
    bool isempty() const;
    bool isfull() const;

    bool push(const Item &item);
    bool pop(Item &item);

    Stack &operator = (const Stack &st);
    friend std::ostream &operator << (std::ostream &os, const Stack &s);
};

#endif

stack2.cpp
#include <iostream>
#include "stack2.h"

Stack::Stack(int n)
{
    if (n < 1)
    {
        std::cerr << "Error. Argument must be a positive integer. ";
        std::cerr << "Setting n to 10." << std::endl;
        n = 10;
    }
    pitems = new Item[n];
    size = n;
    top = 0;
}

Stack::Stack(const Stack &st)
{
    pitems = new Item[st.size];
    for (int i = 0; i < st.size; i++)
    {
        pitems[i] = (st.pitems)[i];
    }
    size = st.size;
    top = st.top;
}

Stack::~Stack()
{
    delete[] pitems;
}

bool Stack::isempty() const
{
    return top == 0;
}

bool Stack::isfull() const
{
    return top == size;
}

bool Stack::push(const Item &item)
{
    if (top < size)
    {
        pitems[top++] = item;
        return true;
    }
    else
    {
        return false;
    }
}

bool Stack::pop(Item &item)
{
    if (top > 0)
    {
        item = pitems[--top];
        return true;
    }
    else
    {
        return false;
    }
}

Stack &Stack::operator = (const Stack &st)
{
    if (this == &st)
    {
        return *this;
    }
    delete[] pitems;

    size = st.size;
    top = st.top;
    pitems = new Item[size];

    for (int i = 0; i < size; i++)
    {
        pitems[i] = (st.pitems)[i];
    }
    return *this;
}

std::ostream &operator<<(std::ostream &os, const Stack &s)
{
    for (int i = 0; i < s.top; i++)
    {
        os << "item " << i + 1 << ": " << (s.pitems)[i] << std::endl;
    }
    return os;
}

ch12_p04.cpp
#include <iostream>
#include "stack2.h"

int main()
{
    std::cout << "setting s1..." << std::endl;
    Stack s1;
    std::cout << "setting s2..." << std::endl;
    Stack s2(5);
    std::cout << "setting s3..." << std::endl;
    Stack s3(-1);
    std::cout << "setting s4..." << std::endl;
    Stack s4 = Stack(10);
    std::cout << "setting s5..." << std::endl;
    Stack s5(s4);
    std::cout << "setting s6..." << std::endl;
    Stack s6 = Stack(s3);
    std::cout << std::endl;

    std::cout << "s1.isempty() == " << s1.isempty() << std::endl;
    s1.push(10);
    s1.push(20);
    s1.push(30);

    s2 = s1;

    unsigned long x = 0;
    s2.pop(x);

    std::cout << "We pushed 10, 20, and 30 into s1" << std::endl;
    std::cout << "We assigned s2 to s1" << std::endl;
    std::cout << "s2.pop(x), x = " << x << std::endl;
    std::cout << std::endl;

    std::cout << "s1: " << std::endl;
    std::cout << s1;
    std::cout << std::endl;
    std::cout << "s2: " << std::endl;
    std::cout << s2;

    return 0;
}
显示结果如下
setting s1...
setting s2...
setting s3...
Error. Argument must be a positive integer. Setting n to 10.
setting s4...
setting s5...
setting s6...

s1.isempty() == 1
We pushed 10, 20, and 30 into s1
We assigned s2 to s1
s2.pop(x), x = 30

s1:
item 1: 10
item 2: 20
item 3: 30

s2:
item 1: 10
item 2: 20

5.Heather银行进行的研究表明，ATM客户不希望排队时间不超过1分钟。
使用程序清单12.10中的模拟，找出要使平均等候时间为1分钟，每小时到达的客户数应为多少（试验时间不短于100小时）？
queue2.h
#pragma once
#ifndef QUEUE2_H_
#define QUEUE2_H_

class Customer
{
private:
    long arrive;
    int processtime;
public:
    Customer()
    {
        arrive = processtime = 0;
    }
    void set(long when);
    long when() const
    {
        return arrive;
    }
    int ptime() const
    {
        return processtime;
    }
};

typedef Customer Item;

class Queue
{
private:
    struct Node
    {
        Item item;
        struct Node *next;
    };
    enum { Q_SIZE = 10 };
    Node *front;
    Node *rear;
    int items;
    const int qsize;

    Queue(const Queue &q) : qsize(0) { }
    Queue &operator=(const Queue &q)
    {
        return *this;
    }
public:
    Queue(int qs = Q_SIZE);
    ~Queue();
    bool isempty() const;
    bool isfull() const;
    int queuecount() const;
    bool enqueue(const Item &item);
    bool dequeue(Item &item);
};

#endif

queue2.cpp
#include <iostream>
#include <cstdlib>
#include "queue2.h"

Queue::Queue(int qs) : qsize(qs)
{
    front = rear = nullptr;
    items = 0;
}

Queue::~Queue()
{
    Node *next;
    while (front != nullptr)
    {
        next = front->next;
        delete front;
        front = next;
    }
}

bool Queue::isempty() const
{
    return items == 0;
}

bool Queue::isfull() const
{
    return items == qsize;
}

int Queue::queuecount() const
{
    return items;
}
bool Queue::enqueue(const Item &item)
{
    if (isfull())
    {
        return false;
    }
    Node *add = new Node;

    add->item = item;
    add->next = nullptr;
    if (items == 0)
    {
        front = add;
        rear = add;
    }
    else
    {
        rear->next = add;
        rear = add;
    }
    items++;
    return true;
}
bool Queue::dequeue(Item &item)
{
    if (isempty())
    {
        return false;
    }
    item = front->item;
    items--;
    Node *next = front->next;
    delete front;
    front = next;
    if (items == 0)
    {
        front = nullptr;
        rear = nullptr;
    }
    return true;
}
void Customer::set(long when)
{
    processtime = std::rand() % 3 + 1;
    arrive = when;
}

ch12_p05.cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
#include "queue2.h"

const int MIN_PER_HR = 60;

bool newcustomer(double x);

int main()
{
    using std::cin;
    using std::cout;
    using std::endl;
    using std::ios_base;

    std::srand(std::time(nullptr));

    cout << "Case Study: Bank of Heather Automatic Teller\n";
    cout << "Enter maximum size of queue: ";
    int qs;
    cin >> qs;

    cout << "Enter the number of simulation hours: ";
    int hours;
    cin >> hours;
    long cyclelimit = MIN_PER_HR * hours;

    double perhour;
    double min_per_cust;

    Item temp;
    long turnaways = 0;
    long customers = 0;
    long served = 0;
    long sum_line = 0;
    int wait_time = 0;
    long line_wait = 0;

    int i = hours;

    do
    {
        perhour = i--;
        min_per_cust = MIN_PER_HR / perhour;
        Queue line(qs);
        turnaways = 0;
        customers = 0;
        served = 0;
        sum_line = 0;
        wait_time = 0;
        line_wait = 0;

        for (long cycle = 0; cycle < cyclelimit; cycle++)
        {
            if (newcustomer(min_per_cust))
            {
                if (line.isfull())
                {
                    turnaways++;
                }
                else
                {
                    customers++;
                    temp.set(cycle);
                    line.enqueue(temp);
                }
            }
            if (wait_time <= 0 && !line.isempty())
            {
                line.dequeue(temp);
                wait_time = temp.ptime();
                line_wait += cycle - temp.when();
                served++;
            }
            if (wait_time > 0)
            {
                wait_time--;
            }
            sum_line += line.queuecount();
        }
    }
    while ((double)line_wait / served > 1.0);
    i++;

    if (customers > 0)
    {
        std::cout << "customers per hours: " << i << std::endl;
        cout << "customers accepted: " << customers << endl;
        cout << "customers served: " << served << endl;
        cout << "customers turnaways: " << turnaways << endl;
        cout.precision(2);
        cout.setf(ios_base::fixed, ios_base::floatfield);
        cout.setf(ios_base::showpoint);
        cout << "average queue size: " << (double)sum_line / cyclelimit << endl;
        cout << "average wait time: " << (double)line_wait / served << " minutes\n";
    }
    else
    {
        cout << "No customers!\n";
    }
    cout << "Done.\n";

    return 0;
}
bool newcustomer(double x)
{
    return ( (std::rand() * x) / RAND_MAX < 1);
}
显示结果如下
Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 10
Enter the number of simulation hours: 100
customers per hours: 17
customers accepted: 1709
customers served: 1709
customers turnaways: 0
average queue size: 0.24
average wait time: 0.85 minutes
Done.

Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 20
Enter the number of simulation hours: 100
customers per hours: 18
customers accepted: 1771
customers served: 1770
customers turnaways: 0
average queue size: 0.26
average wait time: 0.89 minutes
Done.

Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 30
Enter the number of simulation hours: 100
customers per hours: 18
customers accepted: 1737
customers served: 1737
customers turnaways: 0
average queue size: 0.23
average wait time: 0.78 minutes
Done.

Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 40
Enter the number of simulation hours: 100
customers per hours: 17
customers accepted: 1687
customers served: 1687
customers turnaways: 0
average queue size: 0.24
average wait time: 0.84 minutes
Done.

Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 50
Enter the number of simulation hours: 100
customers per hours: 17
customers accepted: 1649
customers served: 1649
customers turnaways: 0
average queue size: 0.21
average wait time: 0.75 minutes
Done.

6.Heather银行想知道，如果再开设一台ATM，情况将如何。请对模拟进行修改，以包含两个队列。
假设当第一台ATM前的排队人数少于第二台ATM时，客户将排在第一队，否则将排在第二队。
然后再找出要使平均等候时间为1分钟，每小时到达的客户数应该为多少
（注意，这是一个非线性问题，即将ATM数量加倍，并不能保证每小时处理的客户数量也翻倍，
并确保客户等候的时间少于1分钟）？
ch12_p06.cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
#include "queue2.h"

const int MIN_PER_HR = 60;

bool newcustomer(double x);

int main()
{
    using std::cin;
    using std::cout;
    using std::endl;
    using std::ios_base;

    std::srand(std::time(nullptr));

    cout << "Case Study: Bank of Heather Automatic Teller\n";
    cout << "Enter maximum size of queue: ";
    int qs;
    cin >> qs;

    cout << "Enter the number of simulation hours: ";
    int hours;
    cin >> hours;
    long cyclelimit = MIN_PER_HR * hours;

    double perhour;
    double min_per_cust;

    Item temp;

    long turnawaysL1 = 0;
    long customersL1 = 0;
    long servedL1 = 0;
    long sum_lineL1 = 0;
    int wait_timeL1 = 0;
    long line_waitL1 = 0;

    long turnawaysL2 = 0;
    long customersL2 = 0;
    long servedL2 = 0;
    long sum_lineL2 = 0;
    int wait_timeL2 = 0;
    long line_waitL2 = 0;

    double average_wait;


    int i = hours;

    do
    {
        perhour = i--;
        min_per_cust = MIN_PER_HR / perhour;
        Queue line1(qs);
        Queue line2(qs);
        turnawaysL1 = turnawaysL2 = 0;
        customersL1 = customersL2 = 0;
        servedL1 = servedL2 = 0;
        sum_lineL1 = sum_lineL2 = 0;
        wait_timeL1 = wait_timeL2 = 0;
        line_waitL1 = line_waitL2 = 0;

        for (long cycle = 0; cycle < cyclelimit; cycle++)
        {
            if (newcustomer(min_per_cust))
            {
                if (line1.queuecount() <= line2.queuecount())
                {
                    if (line1.isfull())
                    {
                        turnawaysL1++;
                    }
                    else
                    {
                        customersL1++;
                        temp.set(cycle);
                        line1.enqueue(temp);
                    }
                }
                else
                {
                    if (line2.isfull())
                    {
                        turnawaysL2++;
                    }
                    else
                    {
                        customersL2++;
                        temp.set(cycle);
                        line2.enqueue(temp);
                    }
                }
            }
            if (wait_timeL1 == 0 && !line1.isempty())
            {
                line1.dequeue(temp);
                wait_timeL1 = temp.ptime();
                line_waitL1 += cycle - temp.when();
                servedL1++;
            }

            if (wait_timeL2 == 0 && !line2.isempty())
            {
                line2.dequeue(temp);
                wait_timeL2 = temp.ptime();
                line_waitL2 += cycle - temp.when();
                servedL2++;
            }
            if (wait_timeL1 > 0)
            {
                wait_timeL1--;
            }

            if (wait_timeL2 > 0)
            {
                wait_timeL2--;
            }
            sum_lineL1 += line1.queuecount();
            sum_lineL2 += line2.queuecount();
        }
        average_wait = double(line_waitL1 + line_waitL2) / (servedL1 + servedL2);

    }
    while (average_wait > 1.0);
    i++;

    if (customersL1 + customersL2 > 0)
    {
        std::cout << "customers per hours: " << i << std::endl;
        cout << "customers accepted: " << customersL1 + customersL2 << endl;
        cout << "customers served: " << servedL1 + servedL2 << endl;
        cout << "customers turnaways: " << turnawaysL1 + turnawaysL2 << endl;
        cout.precision(2);
        cout.setf(ios_base::fixed, ios_base::floatfield);
        cout.setf(ios_base::showpoint);
        cout << "average queue1 size: " << (double)sum_lineL1 / cyclelimit << endl;
        cout << "average queue2 size: " << (double)sum_lineL2 / cyclelimit << endl;
        cout << "average queue size: " << ( (double)(sum_lineL1 * sum_lineL2) / (sum_lineL1 + sum_lineL2) ) / cyclelimit << endl;
        cout << "average wait time: " << average_wait << " minutes\n";
    }
    else
    {
        cout << "No customers!\n";
    }
    cout << "Done.\n";

    return 0;
}
bool newcustomer(double x)
{
    return ( (std::rand() * x) / RAND_MAX < 1);
}
显示结果如下
Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 20
Enter the number of simulation hours: 100
customers per hours: 50
customers accepted: 5010
customers served: 5009
customers turnaways: 0
average queue1 size: 0.58
average queue2 size: 0.23
average queue size: 0.17
average wait time: 0.97 minutes
Done.

第13章 类继承
13.1 一个简单的基类
13.1.1 派生一个类
13.1.2 构造函数：访问权限的考虑
13.1.3 使用派生类
13.1.4 派生类和基类之间的特殊关系
13.2 继承：is-a关系
13.3 多态公有继承
13.4 静态联编和动态联编
13.4.1 指针和引用类型的兼容性
13.4.2 虚成员函数和动态联编
13.4.3 有关虚函数注意事项
13.5 访问控制 protected
13.6 抽象基类
13.6.1 应用ABC概念
13.6.2 ABC理念
13.7 继承和动态内存分配
13.7.1 第一种情况：派生类不使用new
13.7.2 第二种情况：派生类使用new
13.7.3 使用动态内存分配和友元的继承示例
13.8 类设计回顾
13.8.1 编译器生成的成员涵数.
13.8.2 其他的类方法
13.8.3 公有继承的考虑因素
13.8.4 类函数小结
13.9 总结
13.10 复习题
13.11 编程练习
本章内容包括：
is-a关系的继承。
如何以公有方式从一个类派生出另一个类。
保护访问。
构造函数成员初始化列表。
向上和向下强制转换。
虚成员函数。
静态联编与动态联编。
抽象基类。
纯虚函数。
何时及如何使用公有继承。
从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。
程序清单13.1 tabletenn0.h
#pragma once
#ifndef TABLETENN0_H_  
#define TABLETENN0_H_  

#include <string> 

using std::string;

class TableTennisPlayer
{
private:
	string firstname;
	string lastname;
	bool hasTable;
public:
	TableTennisPlayer(const string & fn = "none", const string & In = "none", bool ht = false);
	void Name() const;
	bool HasTable() const { return hasTable; };
	void ResetTable(bool v) { hasTable = v; };
};

#endif

程序清单13.2 tabletenn0.cpp
#include <iostream>
#include "tabletenn0.h"

TableTennisPlayer::TableTennisPlayer(const string & fn, const string & In, bool ht) : firstname(fn), lastname(In), hasTable(ht) 
{

}
void TableTennisPlayer::Name() const
{
    std::cout << lastname << ", " << firstname;
}

程序清单13.3 usett0.cpp
#include <iostream>
#include "tabletenn0.h"

int main()
{
    using std::cout;
    TableTennisPlayer player1("Chuck", "Blizzard", true);
    TableTennisPlayer player2("Tara", "Boomdea", false);
    player1.Name();
    if (player1.HasTable())
    {
        cout << " : has a table.\n";
    }
    else
    {
        cout << " : hasn't a table.\n";
    }
    player2.Name();
    if (player2.HasTable())
    {
        cout << " : has a table";
    }
    else
    {
        cout << " : hasn't a table. \n";
    }

    return 0;
}
显示结果如下
Blizzard, Chuck : has a table.
Boomdea, Tara : hasn't a table.

程序清单13.4 tabletenn1.h
#pragma once
#ifndef TABLETENN1_H_
#define TABLETENN1_H_

#include <string>

using std::string;

class TableTennisPlayer
{
private:
    string firstname;
    string lastname;
    bool hasTable;
public:
    TableTennisPlayer(const string &fn = "none", const string &In = "none", bool ht = false);
    void Name() const;
    bool HasTable() const
    {
        return hasTable;
    };
    void ResetTable(bool v)
    {
        hasTable = v;
    };
};

class RatedPlayer : public TableTennisPlayer
{
private:
    unsigned int rating;
public:
    RatedPlayer(unsigned int r = 0, const string &fn = "none", const string &In = "none", bool ht = false);
    RatedPlayer(unsigned int r, const TableTennisPlayer &tp);
    unsigned int Rating() const
    {
        return rating;
    }
    void ResetRating(unsigned int r)
    {
        rating = r;
    }
};

#endif

冒号指出RatedPlayer类的基类是TableTennisplayer类，public表明公有派生。
使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问（稍后将介绍保护成员）。
Ratedplayer对象将具有以下特征：
派生类对象存储了基类的数据成员（派生类继承了基类的实现）；
派生类对象可以使用基类的方法（派生类继承了基类的接口）。
因此，RatedPlayer对象可以存储运动员的姓名及其是否有球桌。
另外，RatedPlayer对象还可以使用TableTennisPlayer 类的Name、hasTable和ResetTable方法（参见图13.1）。
派生类需要自己的构造函数。派生类可以根据需要添加额外的数据成员和成员函数。
在这个例子中，派生类需要另一个数据成员来存储比分，还应包含检索比分的方法和重置比分的方法。
构造函数必须给新成员（如果有的话）和继承的成员提供数据。
在第一个RatedPlayer构造函数中，每个成员对应一个形参；
而第二个Ratedplayer构造函数使用一个TableTennisPlayer参数，该参数包括firstname，lastname和hasTable.
派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。
例如，RatedPlayer构造函数不能直接设置继承的成员（firstname，lastname和hasTable），而必须使用基类的公有方法来访问私有的基类成员。
具体地说，派生类构造函数必须使用基类构造函数。
创建派生类对象时，程序首先创建基类对象。从概念上说，这意味着基类对象应当在程序进入派生类构造函数之前被创建。
C++使用成员初始化列表语法来完成这种工作。例如，下面是第一个RatedPlayer构造函数的代码：
RatedPlayer::RatedPlayer(unsigned int r, const string &fn, const string &In, bool ht) : TableTennisPlayer(fn, In, ht)
{
    rating = r;
}
其中 : TableTennisPlayer (fn, In, ht)是成员初始化列表。它是可执行的代码，调用TableTennisPlayer构造函数。
如果省略成员初始化列表，不显式调用基类构造函数，程序将使用默认的基类构造函数。
除非要使用默认构造函数，否则应显式调用正确的基类构造函数。
如果愿意，也可以对派生类成员使用成员初始化列表语法。在这种情况下，应在列表中使用成员名，而不是类名。
有关派生类构造函数的要点如下：
首先创建基类对象；
派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数
派生类构造函数应初始化派生类新增的数据成员。
释放对象的顺序与创建对象的顺序相反，即首先执行派生类的析构函数，然后自动调用基类的析构函数。
创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数。
基类构造函数负责初始化继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。
派生类的构造函数总是调用一个基类构造函数。可以使用初始化器列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。
派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。
派生类构造函数可以使用初始化器列表机制将值传递给基类构造函数。
derived::derived (type1 x, type2 y) : base (x, y)
其中derived是派生类，base是基类，x和y是基类构造函数使用的变量。
例如，如果派生类构造函数接收到参数10和12，则将把10和12传递给基类构造函数。
除虚基类外（参见第14章），类只能将值传递回相邻的基类，但后者可以使用相同的机制将信息传递给相邻的基类，依此类推。
如果没有在成员初始化列表中提供基类构造函数，程序将使用默认的基类构造函数。
成员初始化列表只能用于构造函数。

程序清单13.5 tabletenn1.cpp
#include <iostream>
#include "tabletenn1.h"

TableTennisPlayer::TableTennisPlayer(const string &fn, const string &In, bool ht) : firstname(fn), lastname(In), hasTable(ht)
{

}
void TableTennisPlayer::Name() const
{
    std::cout << lastname << ", " << firstname;
}
RatedPlayer::RatedPlayer(unsigned int r, const string &fn, const string &In, bool ht) : TableTennisPlayer(fn, In, ht)
{
    rating = r;
}
RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer &tp) : TableTennisPlayer(tp), rating(r)
{

}

程序清单13.6 usett1.cpp
#include <iostream>
#include "tabletenn1.h"

int main()
{
    using std::cout;
    using std::endl;
    TableTennisPlayer player1("Tara", "Boomdea", false);
    RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
    rplayer1.Name();
    if (rplayer1.HasTable())
    {
        cout << " : has a table. \n";
    }
    else
    {
        cout << " : hasn't a table. \n";
    }
    player1.Name();
    if (player1.HasTable())
    {
        cout << " : has a table";
    }
    else
    {
        cout << " : hasn't a table. \n";
    }
    cout << "Name: ";
    rplayer1.Name();
    cout << "; Rating: " << rplayer1.Rating() << endl;
    RatedPlayer rplayer2(1212, player1);
    cout << "Name: ";
    rplayer2.Name();
    cout << "; Rating: " << rplayer2.Rating() << endl;

    return 0;
}
显示结果如下
Duck, Mallory : has a table.
Boomdea, Tara : hasn't a table.
Name: Duck, Mallory; Rating: 1140
Name: Boomdea, Tara; Rating: 1212
派生类与基类之间有一些特殊关系。
派生类对象可以使用基类的方法，条件是方法不是私有的；
基类指针可以在不进行显式类型转换的情况下指向派生类对象；
基类引用可以在不进行显式类型转换的情况下引用派生类对象。
然而，基类指针或引用只能用于调用基类方法，不能用于调用派生类的方法。
通常，C++要求引用和指针类型与赋给的类型匹配，但这一规则对继承来说是例外。
然而，这种例外只是单向的，不可以将基类对象和地址赋给派生类引用和指针。
上述规则是有道理的。例如，如果允许基类引用隐式地引用派生类对象，则可以使用基类引用为派生类对象调用基类的方法。
因为派生类继承了基类的方法，所以这样做不会出现问题。
如果可以将基类对象赋给派生类引用，派生类引用能够为基对象调用派生类方法，这样做将出现问题。
C++有3种继承方式：公有维承、保护继承和私有继承。
公有继承是最常用的方式，它建立一种is-a关系，即派生类对象也是一个基类对象，
可以对基类对象执行的任何操作，也可以对派生类对象执行。
派生类将继承基类的所有数据成员，还可以添加了专门用于派生类的成员。
因为派生类可以添加特性；所以，将这种关系称为is-a-kind-of（是一种）关系可能更准确。
公有继承不建立has-a关系。例如，午餐可能包括水果，但通常午餐并不是水果。
在午餐中加入水果的正确方法是将其作为一种has-a关系：午餐有水果。
正如将在第14章介绍的，最容易的建模方式是将Fruit对象作为Lunch类的数据成员（参见图13.3）。
公有继承不能建立is-like-a关系，也就是说，它不采用明喻。人们通常说律师就像鲨鱼，但律师并不是鲨鱼。
例如，鲨鱼可以在水下生活。所以，不应从Shark类派生出Lawyer类。
继承可以在基类的基础上添加属性，但不能删除基类的属性。
在有些情况下，可以设计一个包含共有特征的类，然后以is-a或has-a关系，在这个类的基础上定义相关的类。
公有继承不建立is-implemented-as-a（作为 实现）关系。
例如，可以使用数组来实现栈，但从Array类派生出Stack类是不合适的，因为栈不是数组。
例如，数组索引不是栈的属性。另外，可以以其他方式实现栈，如链表。
正确的方法是，通过让栈包含一个私有Array对象成员来隐藏数组实现。
公有继承不建立uses-a关系。例如，计算机可以使用激光打印机，但从Computer类派生出Printer类（或反过来）是没有意义的。
然而，可以使用友元函数或类来处理Printer对象和Computer对象之间的通信。
有两种重要的机制可用于实现多态公有继承：
在派生类中重新定义基类的方法
如果方法是通过对象调用的，程序将使用对象类型来确定使用哪个版本的方法。
如果方法是通过引用或指针而不是对象调用的，程序将根据引用类型或指针类型来确定使用哪个版本的方法。
使用虚函数。
如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法。
方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法。
然而，在派生类声明中使用关键字virtual来指出哪些函数是虚函数也不失为一个好办法。
基类声明了一个虚析构函数。这样做是为了确保释放派生对象时，按正确的顺序调用析构函数。
如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的。
这样，程序将根据对象类型而不是引用或指针的类型来选择方法版本。为基类声明一个虚析构函数也是一种惯例。
注意，关键字virtual只用于类声明的方法原型中，而没有用于方法定义中。
程序清单13.7 brass.h
#pragma once
#ifndef BRASS_H_
#define BRASS_H_
#include <string>

class Brass
{
private:
    std::string fullName;
    long acctNum;
    double balance;
public:
    Brass(const std::string &s = "Nullbody", long an = -1, double bal = 0.0);
    void Deposit(double amt);
    virtual void Withdraw(double amt);
    double Balance() const;
    virtual void ViewAcct() const;
    virtual ~Brass() {}
};

class BrassPlus : public Brass
{
private:
    double maxLoan;
    double rate;
    double owesBank;
public:
    BrassPlus(const std::string &s = "Nullbody", long an = -1, double bal = 0.0, double ml = 500, double r = 0.11125);
    BrassPlus(const Brass &ba, double ml = 500, double r = 0.11125);
    virtual void ViewAcct()const;
    virtual void Withdraw(double amt);
    void ResetMax(double m)
    {
        maxLoan = m;
    }
    void ResetRate(double r)
    {
        rate = r;
    };
    void ResetOwes()
    {
        owesBank = 0;
    }
};

#endif
派生类并不能直接访问基类的私有数据，而必须使用基类的公有方法才能访问这些数据。
访问的方式取决于方法。构造函数使用一种技术，而其他成员函数使用另一种技术。
派生类构造函数在初始化基类私有数据时，采用的是成员初始化列表语法。
非构造函数不能使用成员初始化列表语法，但可以使用作用域解析运算符来调用基类方法。
程序清单13.8 brass.cpp
#include <iostream>
#include "brass.h"

using std::cout;
using std::endl;
using std::string;

typedef std::ios_base::fmtflags format;
typedef std::streamsize precis;
format setFormat();
void restore(format f, precis p);

Brass::Brass(const string &s, long an, double bal)
{
    fullName = s;
    acctNum = an;
    balance = bal;
}

void Brass::Deposit(double amt)
{
    if (amt < 0)
    {
        cout << "Negative deposit not allowed; deposit is cancelled.\n";
    }
    else
    {
        balance += amt;
    }
}

void Brass::Withdraw(double amt)
{
    format initialState = setFormat();
    precis prec = cout.precision(2);
    if (amt < 0)
    {
        cout << "Withdrawal amount must be positive; withdrawal canceled.\n";
    }
    else if (amt <= balance)
    {
        balance -= amt;
    }
    else
    {
        cout << "Withdrawal amount of $" << amt << " exceeds your balance. Withdrawal canceled.\n";

    }
    restore(initialState, prec);
}

double Brass::Balance() const
{
    return balance;
}

void Brass::ViewAcct() const
{
    format initialState = setFormat();
    precis prec = cout.precision(2);
    cout << "Client: " << fullName << endl;
    cout << "Account Number: " << acctNum << endl;
    cout << "Balance: $" << balance << endl;
    restore(initialState, prec);
}
BrassPlus::BrassPlus(const string &s, long an, double bal, double ml, double r) : Brass(s, an, bal)
{
    maxLoan = ml;
    rate = r;
    owesBank = 0.0;
}

BrassPlus::BrassPlus(const Brass &ba, double ml, double r) : Brass(ba)
{
    maxLoan = ml;
    rate = r;
    owesBank = 0.0;
}
void BrassPlus::ViewAcct() const
{
    format initialState = setFormat();
    precis prec = cout.precision(2);
    Brass::ViewAcct();
    cout << "Maximum loan: $" << maxLoan << endl;
    cout << "Owed to bank: $" << owesBank << endl;
    cout.precision(3);
    cout << "Loan Rate: " << 100 * rate << "%\n";
    restore(initialState, prec);
}
void BrassPlus::Withdraw(double amt)
{
    format initialState = setFormat();
    precis prec = cout.precision(2);
    double bal = Balance();
    if (amt <= bal)
    {
        Brass::Withdraw(amt);
    }
    else if (amt <= bal + maxLoan)
    {
        double advance = amt - bal;
        owesBank += advance * (1.0 + rate);
        cout << "Bank advance: $" << advance << endl;
        cout << "Finance charge: $" << advance *rate << endl;
        Deposit(advance);
        Brass::Withdraw(amt);
    }
    else
    {
        cout << "Credit limit exceeded. Transaction cancelled.\n";
    }
    restore(initialState, prec);
}

format setFormat()
{
    return cout.setf(std::ios_base::fixed, std::ios_base::floatfield);
}

void restore(format f, precis p)
{
    cout.setf(f, std::ios_base::floatfield);
    cout.precision(p);
}


程序清单13.9 usebrass1.cpp
#include <iostream>
#include "brass.h"

int main()
{
    using std::cout;
    using std::endl;
    Brass Piggy("Porcelot Pigg", 381299, 4000.00);
    BrassPlus Hoggy("Horatio Hogg", 382288, 3000.00);
    Piggy.ViewAcct ();
    cout << endl;
    Hoggy.ViewAcct ();
    cout << endl;
    cout << "Depositing $1000 into the Hogg Account:\n";
    Hoggy.Deposit(1000.00);
    cout << "New balance: $" << Hoggy .Balance () << endl;
    cout << "Withdrawing $4200 from the Pigg Account: \n";
    Piggy.Withdraw(4200.00);
    cout << "Pigg account balance: $" << Piggy .Balance () << endl;
    cout << "Withdrawing $4200 from the Hogg Account: \n";
    Hoggy.Withdraw (4200.00);
    Hoggy.ViewAcct ();

    return 0;
}
显示结果如下
Client: Porcelot Pigg
Account Number: 381299
Balance: $4000.00

Client: Horatio Hogg
Account Number: 382288
Balance: $3000.00
Maximum loan: $500.00
Owed to bank: $0.00
Loan Rate: 11.125%

Depositing $1000 into the Hogg Account:
New balance: $4000
Withdrawing $4200 from the Pigg Account:
Withdrawal amount of $4200.00 exceeds your balance. Withdrawal canceled.
Pigg account balance: $4000
Withdrawing $4200 from the Hogg Account:
Bank advance: $200.00
Finance charge: $22.25
Client: Horatio Hogg
Account Number: 382288
Balance: $0.00
Maximum loan: $500.00
Owed to bank: $222.25
Loan Rate: 11.125%

程序清单13.10 usebrass2.cpp
#include <iostream>
#include "brass.h"

const int CLIENTS = 4;

int main()
{
    using std::cin;
    using std::cout;
    using std::endl;
    Brass *p_clients[CLIENTS];
    std::string temp;
    long tempnum;
    double tempbal;
    char kind;
    for (int i = 0; i < CLIENTS; i++)
    {
        cout << "Enter client's name: ";
        std::getline(cin, temp, '\n');
        cout << "Enter client's account number: ";
        cin >> tempnum;
        cout << "Enter opening balance: $";
        cin >> tempbal;
        while (cin.get() != '\n')
        {
            continue;
        }
        cout << "Enter 1 for Brass Account or 2 for BrassPlus Account: ";
        while (cin >> kind && (kind != '1' && kind != '2'))
        {
            while (cin.get() != '\n')
            {
                continue;
            }
            cout << "Enter either 1 or 2 : ";
        }
        while (cin.get() != '\n')
        {
            continue;
        }
        if (kind == '1')
        {
            p_clients[i] = new Brass(temp, tempnum, tempbal);
        }
        else
        {
            double tmax, trate;
            cout << "Enter the overdraft limit: $";
            cin >> tmax;
            cout << "Enter the interest rate as a decimal fraction: ";
            cin >> trate;
            while (cin.get() != '\n')
            {
                continue;
            }
            p_clients[i] = new BrassPlus(temp, tempnum, tempbal, tmax, trate);
        }
    }
    cout << endl;
    for (int i = 0; i < CLIENTS; i++)
    {
        p_clients[i]->ViewAcct();
        cout << endl;
    }
    for (int i = 0; i < CLIENTS; i++)
    {
        delete p_clients[i];
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Enter client's name: Peter Smith
Enter client's account number: 123456
Enter opening balance: $2000
Enter 1 for Brass Account or 2 for BrassPlus Account: 1
Enter client's name: Mike Pence
Enter client's account number: 222333
Enter opening balance: $3000
Enter 1 for Brass Account or 2 for BrassPlus Account: 2
Enter the overdraft limit: $500
Enter the interest rate as a decimal fraction: 0.11125
Enter client's name: Hello World
Enter client's account number: 555666
Enter opening balance: $6000
Enter 1 for Brass Account or 2 for BrassPlus Account: 1
Enter client's name: Apple
Enter client's account number: 777888
Enter opening balance: $8000
Enter 1 for Brass Account or 2 for BrassPlus Account: 2
Enter the overdraft limit: $800
Enter the interest rate as a decimal fraction: 0.125

Client: Peter Smith
Account Number: 123456
Balance: $2000.00

Client: Mike Pence
Account Number: 222333
Balance: $3000.00
Maximum loan: $500.00
Owed to bank: $0.00
Loan Rate: 11.125%

Client: Hello World
Account Number: 555666
Balance: $6000.00

Client: Apple
Account Number: 777888
Balance: $8000.00
Maximum loan: $800.00
Owed to bank: $0.00
Loan Rate: 12.500%

Done.
如果析构函数不是虚的，则将只调用对应于指针类型的析构函数。
对于程序清单13.10，这意味着只有Brass的析构函数被调用，即使指针指向的是一个BrassPlus对象。
如果析构函数是虚的，将调用相应对象类型的析构函数。
因此，如果指针指向的是BrassPlus对象，将调用BrassPlus的析构函数，然后自动调用基类的析构函数。
因此，使用虚析构函数可以确保正确的析构函数序列被调用。
指向基类的引用或指针可以引用派生类对象，而不必进行显式类型转换。
将派生类引用或指针转换为基类引用或指针被称为向上强制转换。
向上强制转换是可传递的，也就是说，如果从BrassPlus派生出BrassPlusPlus类，
则Brass指针或引用可以引用Brass对象、BrassPlus对象或BrassPlusPlus对象。
将基类指针或引用转换为派生类指针或引用称为向下强制转换。如果不使用显式类型转换，则向下强制转换是不允许的。
如果函数按值传递类型为Brass的参数，则导致只将BrassPlus对象的Brass部分传递给函数。
如果函数按引用和指针传递参数，隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象。
如果使用基类指针或引用调用虚函数，则导致分别为基类对象和派生类对象使用各自对应版本的函数。
通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。
这种数组称为虚函数表，虚函数表中存储了为类对象进行声明的虚函数的地址。
调用虚函数时，程序将查看存储在对象中的指向虚函数地址数组的指针，然后转向相应的虚函数地址表。
如果使用类声明中定义的第一个虚函数，则程序将使用数组中的第一个元素存储的函数地址，并执行对应的函数；
如果使用类声明中的第三个虚函数，程序将使用数组中的第三个元素存储的函数地址。
在基类方法的声明中使用关键字virtual可使该方法在基类以及所有的派生类（包括从派生类派生出来的类）中是虚的。
如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。
如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的。
构造函数不能是虚函数。
析构函数应当是虚函数，除非类不用做基类。
友元函数不能是虚函数，因为友元函数不是类成员函数，而只有类成员函数才能是虚函数。友元函数可以调用虚成员函数。
如果派生类没有重新定义函数，将使用该函数的基类版本。
如果派生类重新定义基类的函数，则会隐藏该函数的基类版本。
重新定义继承的方法并不是重载，如果在派生类中重新定义函数，不管参数特征标如何，都会隐藏同名的基类方法。
如果派生类重新定义继承的方法，应确保与基类方法的原型完全相同。但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。
注意，这种例外只适用于返回值，而不适用于参数。
如果基类声明中方法被重载了，则应在派生类中重新定义所有版本的对应方法。
如果只重新定义一个版本，则其他两个版本将被隐藏，派生类对象将无法使用它们。
注意，如果不需要修改，则新定义可只调用基类版本。
关键字protected与private相似，private和protected之间的区别只有在基类派生的类中才会表现出来。
派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。
因此，对于外部世界来说，保护成员的行为与私有成员相似；但对于派生类来说，保护成员的行为与公有成员相似。
C++通过使用纯虚函数（pure virtual function），提供没有实现的抽象函数。纯虚函数声明的结尾处为= 0。
当类声明中包含纯虚函数时，则不能创建该类的对象。这里的理念是，包含纯虚函数的类只用作基类。
纯虚函数一般不在基类的实现文件中定义，而应该在派生类的实现文件中定义。但是，C++允许在基类的实现文件中定义对应的纯虚函数。
程序清单13.11 acctabc.h
#pragma once
#ifndef ACCTABC_H_
#define ACCTABC_H_
#include <iostream>
#include <string>

class AcctABC
{
private:
    std::string fullName;
    long acctNum;
    double balance;
protected:
    struct Formatting
    {
        std::ios_base::fmtflags flag;
        std::streamsize pr;
    };
    const std::string &FullName() const
    {
        return fullName;
    }
    long AcctNum() const
    {
        return acctNum;
    }
    Formatting SetFormat() const;
    void Restore(Formatting &f) const;
public:
    AcctABC(const std::string &s = "Nullbody", long an = -1, double bal = 0.0);
    void Deposit(double amt);
    virtual void Withdraw(double amt) = 0;
    double Balance() const
    {
        return balance;
    };
    virtual void ViewAcct() const = 0;
    virtual ~AcctABC() {}
};

class Brass : public AcctABC
{
public:
    Brass(const std::string &s = "Nullbody", long an = -1, double bal = 0.0) : AcctABC(s, an, bal) { }
    virtual void Withdraw(double amt);
    virtual void ViewAcct() const;
    virtual ~Brass() {}
};
class BrassPlus : public AcctABC
{
private:
    double maxLoan;
    double rate;
    double owesBank;
public:
    BrassPlus(const std::string &s = "Nullbody", long an = -1, double bal = 0.0, double ml = 500, double r = 0.10);
    BrassPlus(const Brass &ba, double ml = 500, double r = 0.10);
    virtual void ViewAcct()const;
    virtual void Withdraw(double amt);
    void ResetMax(double m)
    {
        maxLoan = m;
    }
    void ResetRate(double r)
    {
        rate = r;
    };
    void ResetOwes()
    {
        owesBank = 0;
    }
};

#endif

程序清单13.12 acctabc.cpp
#include <iostream>
#include "acctabc.h"

using std::cout;
using std::ios_base;
using std::endl;
using std::string;

AcctABC::AcctABC(const string &s, long an, double bal)
{
    fullName = s;
    acctNum = an;
    balance = bal;
}
void AcctABC::Deposit(double amt)
{
    if (amt < 0)
    {
        cout << "Negative deposit not allowed; deposit is cancelled.\n";
    }
    else
    {
        balance += amt;
    }
}
void AcctABC::Withdraw(double amt)
{
    balance -= amt;
}
AcctABC::Formatting AcctABC::SetFormat() const
{
    Formatting f;
    f.flag = cout.setf(ios_base::fixed, ios_base::floatfield);
    f.pr = cout.precision(2);
    return f;
}
void AcctABC::Restore(Formatting &f) const
{
    cout.setf(f.flag, ios_base::floatfield);
    cout.precision(f.pr);
}
void Brass::Withdraw(double amt)
{
    if (amt < 0)
    {
        cout << "Withdrawal amount must be positive; withdrawal canceled.\n";
    }
    else if (amt <= Balance())
    {
        AcctABC::Withdraw(amt);
    }
    else
    {
        cout << "Withdrawal amount of $" << amt << " exceeds your balance. Withdrawal canceled.\n";
    }
}

void Brass::ViewAcct() const
{
    Formatting f = SetFormat();
    cout << "Brass Client: " << FullName() << endl;
    cout << "Account Number: " << AcctNum() << endl;
    cout << "Balance: $" << Balance() << endl;
    Restore(f);
}
BrassPlus::BrassPlus(const string &s, long an, double bal, double ml, double r) : AcctABC(s, an, bal)
{
    maxLoan = ml;
    rate = r;
    owesBank = 0.0;
}
BrassPlus::BrassPlus(const Brass &ba, double ml, double r) : AcctABC(ba)
{
    maxLoan = ml;
    rate = r;
    owesBank = 0.0;
}
void BrassPlus::ViewAcct() const
{
    Formatting f = SetFormat();
    cout << "BrassPlus Client: " << FullName() << endl;
    cout << "Account Number: " << AcctNum() << endl;
    cout << "Balance: $" << Balance() << endl;
    cout << "Maximum loan: $" << maxLoan << endl;
    cout << "Owed to bank: $" << owesBank << endl;
    cout.precision(3);
    cout << "Loan Rate: " << 100 * rate << "%\n";
    Restore(f);
}

void BrassPlus::Withdraw(double amt)
{
    Formatting f = SetFormat();
    double bal = Balance();
    if (amt < 0)
    {
        cout << "Withdrawal amount must be positive; withdrawal canceled.\n";
    }
    else if (amt <= bal)
    {
        AcctABC::Withdraw(amt);
    }
    else if (amt <= bal + maxLoan)
    {
        double advance = amt - bal;
        owesBank += advance * (1.0 + rate);
        cout << "Bank advance: $" << advance << endl;
        cout << "Finance charge: $" << advance *rate << endl;
        Deposit(advance);
        AcctABC::Withdraw(amt);
    }
    else
    {
        cout << "Credit limit exceeded. Transaction cancelled.\n";
    }
    Restore(f);
}

程序清单13.13 usebrass3.cpp
#include <iostream>
#include "acctabc.h"

const int CLIENTS = 4;

int main()
{
    using std::cin;
    using std::cout;
    using std::endl;
    AcctABC *p_clients[CLIENTS];
    std::string temp;
    long tempnum;
    double tempbal;
    char kind;

    for (int i = 0; i < CLIENTS; i++)
    {
        cout << "Enter client's name: ";
        std::getline(cin, temp, '\n');
        cout << "Enter client's account number: ";
        cin >> tempnum;
        cout << "Enter opening balance: $";
        cin >> tempbal;
        while (cin.get() != '\n')
        {
            continue;
        }
        cout << "Enter 1 for Brass Account or 2 for BrassPlus Account: ";
        while (cin >> kind && (kind != '1' && kind != '2'))
        {
            while (cin.get() != '\n')
            {
                continue;
            }
            cout << "Enter either 1 or 2 : ";
        }
        while (cin.get() != '\n')
        {
            continue;
        }
        if (kind == '1')
        {
            p_clients[i] = new Brass(temp, tempnum, tempbal);
        }
        else
        {
            double tmax, trate;
            cout << "Enter the overdraft limit: $";
            cin >> tmax;
            cout << "Enter the interest rate as a decimal fraction: ";
            cin >> trate;
            while (cin.get() != '\n')
            {
                continue;
            }
            p_clients[i] = new BrassPlus(temp, tempnum, tempbal, tmax, trate);
        }
    }
    cout << endl;
    for (int i = 0; i < CLIENTS; i++)
    {
        p_clients[i]->ViewAcct();
        cout << endl;
    }
    for (int i = 0; i < CLIENTS; i++)
    {
        delete p_clients[i];
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Enter client's name: Apple
Enter client's account number: 111222
Enter opening balance: $3000
Enter 1 for Brass Account or 2 for BrassPlus Account: 1
Enter client's name: Orange
Enter client's account number: 333444
Enter opening balance: $5000
Enter 1 for Brass Account or 2 for BrassPlus Account: 2
Enter the overdraft limit: $500
Enter the interest rate as a decimal fraction: 0.125
Enter client's name: Mike Pence
Enter client's account number: 555666
Enter opening balance: $8000
Enter 1 for Brass Account or 2 for BrassPlus Account: 2
Enter the overdraft limit: $800
Enter the interest rate as a decimal fraction: 0.11125
Enter client's name: Peter Smith
Enter client's account number: 777888
Enter opening balance: $9000
Enter 1 for Brass Account or 2 for BrassPlus Account: 1

Brass Client: Apple
Account Number: 111222
Balance: $3000.00

BrassPlus Client: Orange
Account Number: 333444
Balance: $5000.00
Maximum loan: $500.00
Owed to bank: $0.00
Loan Rate: 12.500%

BrassPlus Client: Mike Pence
Account Number: 555666
Balance: $8000.00
Maximum loan: $800.00
Owed to bank: $0.00
Loan Rate: 11.125%

Brass Client: Peter Smith
Account Number: 777888
Balance: $9000.00

Done.

如果基类使用动态内存分配，并重新定义赋值和复制构造函数。
class baseDMA
{
private:
    char * label;
    int rating;
public:
    baseDMA (const char * l = "null", int r = 0);
    baseDMA (const baseDMA & rs);
    virtual ~baseDMA();
    baseDMA & operator = (const baseDMA & rs);
};
现在从baseDMA派生出lackDMA类，而后者不使用new：
class lacksDMA : public baseDMA
{
private:
    char color[40];
public:
    // ...
};
不需要为lackDMA类定义显式析构函数、复制构造函数和赋值运算符。
如果没有显式定义析构函数，编译器将定义一个不执行任何操作的默认构造函数。
实际上，派生类的默认构造函数总是执行自身的代码后调用基类析构函数。
因为我们假设lackDMA成员不需执行任何特殊操作，所以默认析构函数是合适的。
如果没有显式定义复制构造函数，编译器将定义一个默认复制构造函数来执行成员复制。
成员复制将根据数据类型采用相应的复制方式；复制类成员或继承的类组件时，使用该类的复制构造函数完成的。
所以，lacksDMA类的默认复制构造函数使用显式定义的baseDMA复制构造函数来复制lacksDMA对象的baseDMA部分。
因此，默认复制构造函数对于新的lacksDMA成员来说是合适的，同时对于继承的baseDMA对象来说也是合适的。
类的默认赋值运算符将自动使用基类的赋值运算符来对基类组件进行赋值。因此，默认赋值运算符也是合适的。
现在从baseDMA派生出lackDMA类，而后者使用new：
class hasDMA : public baseDMA
{
private:
    char * style;
public:
    // ...
};
在这种情况下，必须为派生类定义显式析构函数、复制构造函数和赋值运算符。
派生类析构函数自动调用基类的析构函数，故其自身的职责是对派生类构造函数使用new分配的内存进行清理。
因此，hasDMA析构函数必须释放指针style管理的内存，并依赖于baseDMA的析构函数来释放指针label管理的内存。
baseDMA::~baseDMA()
{
    delete [] label;
}
hasDMA::~hasDMA()
{
    delete [] style;
}
baseDMA::baseDMA(const baseDMA & rs)
{
    label = new char[std::strlen(rs.label) + 1];
    std::strcpy(label, rs.label);
    rating = rs.rating;
}
hasDMA::hasDMA(const hasDMA & hs) : baseDMA(hs)
{
    style = new char[std::strlen(hs.style) + 1];
    std::strcpy(style, hs.style);
}
baseDMA & baseDMA::operator = (const baseDMA & rs)
{
    if(this == &rs)
    {
        return *this;
    }
    delete [] label;
    label = new char[std::strlen(rs.label) + 1];
    std::strcpy(label, rs.label);
    rating = rs.rating;
    return *this;
}
hasDMA & hasDMA::operator = (const hasDMA & hs)
{
    if (this == &hs)
    {
        return *this;
    }
    baseDMA::operator=(hs);
    delete [] style;
    style = new char[std::strlen(hs.style) + 1];
    std::strcpy(style, hs.style);
    return *this;
}
当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数、
赋值运算符都必须使用相应的基类方法来处理基类元素。
程序清单13.14 dma.h
#pragma once
#ifndef DMA_H_
#define DMA_H_
#include <iostream>

class baseDMA
{
private:
    char *label;
    int rating;
public:
    baseDMA(const char *l = "null", int r = 0);
    baseDMA(const baseDMA &rs);
    virtual ~baseDMA();
    baseDMA &operator=(const baseDMA &rs);
    friend std::ostream &operator<<(std::ostream &os, const baseDMA &rs);
};
class lacksDMA : public baseDMA
{
private:
    enum { COL_LEN = 40 };
    char color[COL_LEN];
public:
    lacksDMA(const char * c= "blank", const char *l = "null", int r = 0);
    lacksDMA(const char * c, const baseDMA &rs);
    friend std::ostream &operator<<(std::ostream &os, const lacksDMA &ls);
};
class hasDMA : public baseDMA
{
private:
    char *style;
public:
    hasDMA(const char * s = "none", const char *l = "null", int r = 0);
    hasDMA(const char * s, const baseDMA &rs);
    hasDMA(const hasDMA &hs);
    ~hasDMA();
    hasDMA &operator=(const hasDMA &rs);
    friend std::ostream &operator<<(std::ostream &os, const hasDMA &hs);
};

#endif

程序清单13.15 dma.cpp
#include <iostream>
#include <cstring>
#include "dma.h"

baseDMA::baseDMA(const char *l, int r)
{
    label = new char[std:: strlen(l) + 1];
    std::strcpy(label, l);
    rating = r;
}
baseDMA::baseDMA(const baseDMA &rs)
{
    label = new char[std:: strlen(rs.label) + 1];
    std::strcpy(label, rs.label);
    rating = rs.rating;
}
baseDMA::~baseDMA()
{
    delete[] label;
}
baseDMA &baseDMA::operator=(const baseDMA &rs)
{
    if (this == &rs)
    {
        return *this;
    }
    delete[] label;
    label = new char[std:: strlen(rs.label) + 1];
    std::strcpy(label, rs.label);
    rating = rs.rating;
    return *this;
}
std::ostream &operator<<(std::ostream &os, const baseDMA &rs)
{
    os << "Label: " << rs.label << std::endl;
    os << "Rating: " << rs.rating << std::endl;
    return os;
}
lacksDMA::lacksDMA(const char *c, const char *l, int r) : baseDMA(l, r)
{
    std::strncpy(color, c, COL_LEN - 1);
    color[COL_LEN - 1] = '\0';
}
lacksDMA::lacksDMA(const char *c, const baseDMA &rs) : baseDMA(rs)
{
    std::strncpy(color, c, COL_LEN - 1);
    color[COL_LEN - 1] = '\0';
}
std::ostream &operator<< (std::ostream &os, const lacksDMA &Is)
{
    os << (const baseDMA &) Is;
    os << "Color: " << Is.color << std::endl;
    return os;
}
hasDMA::hasDMA(const char *s, const char *l, int r) : baseDMA(l, r)
{
    style = new char[std:: strlen(s) + 1];
    std::strcpy(style, s);
}
hasDMA::hasDMA(const char *s, const baseDMA &rs) : baseDMA(rs)
{
    style = new char[std:: strlen(s) + 1];
    std::strcpy(style, s);
}
hasDMA::hasDMA(const hasDMA &hs) : baseDMA(hs)
{
    style = new char[std:: strlen(hs.style) + 1];
    std::strcpy(style, hs.style);
}
hasDMA::~hasDMA()
{
    delete[] style;
}
hasDMA &hasDMA::operator=(const hasDMA &hs)
{
    if (this == &hs)
    {
        return *this;
    }
    baseDMA::operator=(hs);
    delete[] style;
    style = new char[std:: strlen(hs.style) + 1];
    std::strcpy(style, hs.style);
    return *this;
}
std::ostream &operator<<(std::ostream &os, const hasDMA &hs)
{
    os << (const baseDMA &) hs;
    os << "Style: " << hs.style << std::endl;
    return os;
}

程序清单13.16 usedma.cpp
#include <iostream>
#include "dma.h"

int main()
{
    using std::cout;
    using std::endl;
    baseDMA shirt("Portabelly", 8);
    lacksDMA balloon("red", "Blimpo", 4);
    hasDMA map("Mercator", "Buffalo Keys", 5);
    cout << "Displaying baseDMA object:\n";
    cout << shirt << endl;
    cout << "Displaying lacksDMA object:\n";
    cout << balloon << endl;
    cout << "Displaying hasDMA object:\n";
    cout << map << endl;
    lacksDMA balloon2(balloon);
    cout << "Result of lacksDMA copy:\n";
    cout << balloon2 << endl;
    hasDMA map2;
    map2 = map;
    cout << "Result of hasDMA assignment:\n";
    cout << map2 << endl;

    return 0;
}
显示结果如下
Displaying baseDMA object:
Label: Portabelly
Rating: 8

Displaying lacksDMA object:
Label: Blimpo
Rating: 4
Color: red

Displaying hasDMA object:
Label: Buffalo Keys
Rating: 5
Style: Mercator

Result of lacksDMA copy:
Label: Blimpo
Rating: 4
Color: red

Result of hasDMA assignment:
Label: Buffalo Keys
Rating: 5
Style: Mercator

1.默认构造函数
默认构造函数要么没有参数，要么所有的参数都有默认值。
如果没有定义任何构造函数，编译器将定义默认构造函数，让您能够创建对象。
自动生成的默认构造函数的另一项功能是，调用基类的默认构造函数以及调用本身是对象的成员所属类的默认构造函数。
如果派生类构造函数的成员初始化列表中没有显式调用基类构造函数，
则编译器将使用基类的默认构造函数来构造派生类对象的基类部分。
在这种情况下，如果基类没有构造函数，将导致编译阶段错误。
如果定义了某种构造函数，编译器将不会定义默认构造函数。
在这种情况下，如果需要默认构造函数，则必须自己提供。提供构造函数的动机之一是确保对象总能被正确地初始化。
另外，如果类包含指针成员，则必须初始化这些成员。
因此，最好提供一个显式默认构造函数，将所有的类数据成员都初始化为合理的值。
2.复制构造函数
复制构造函数接受其所属类的对象作为参数。
在下述情况下，将使用复制构造函数：
将新对象初始化为一个同类对象；
按值将对象传递给函数；
函数按值返回对象；
编译器生成临时对象。
如果程序没有使用（显式或隐式）复制构造函数，编译器将提供原型，但不提供函数定义；
否则，编译器将定义一个执行成员初始化的复制构造函数。
也就是说，新对象的每个成员都被初始化为原始对象相应成员的值。
如果成员为类对象，则初始化该成员时，将使用相应类的复制构造函数。
在某些情况下，成员初始化是不合适的。例如，使用new初始化的成员指针通常要求执行深复制，
或者类可能包含需要修改的静态变量。在上述情况下，需要定义自己的复制构造函数。
3.赋值运算符
默认的赋值运算符用于处理同类对象之间的赋值。不要将赋值与初始化混淆了。
如果语句创建新的对象，则使用初始化；如果语句修改已有对象的值，则是赋值。
默认赋值为成员赋值。如果成员为类对象，则默认成员赋值将使用相应类的赋值运算符。
如果需要显式定义复制构造函数，则基于相同的原因，也需要显式定义赋值运算符。
编译器不会生成将一种类型赋给另一种类型的赋值运算符。
如果希望能够将不同类型的参数赋给对象，则方法之一是显式重载赋值运算符。
另一种方法是使用转换函数将参数转换成对应类型的临时对象，然后就可使用相同类型对应的赋值运算符。
定义类时，还需要注意其他几点。
1.构造函数
构造函数不同于其他类方法，因为它创建新的对象，而其他类方法只是被现有的对象调用。这是构造函数不被继承的原因之一。
继承意味着派生类对象可以使用基类的方法，然而，构造函数在完成其工作之前，对象并不在在。
2.析构函数
一定要定义显式析构函数来释放类构造函数使用new分配的所有内存，并完成类对象所需的任何特殊的清理工作。
对于基类，即使它不需要析构函数，也应提供一个虚析构函数。
3.转换
使用一个参数就可以调用的构造函数定义了从参数类型到类类型的转换。
在带一个参数的构造函数原型中使用explicit将禁止进行隐式转换，但仍允许显式转换。
要将类对象转换为其他类型，应定义转换函数。
C++11支持将关键字explicit用于转换函数。与构造函数一样，explicit允许使用强制类型转换进行显式转换，但不允许隐式转换。
4.按值传递对象与传递引用
通常，编写使用对象作为参数的函数时，应按引用而不是按值来传递对象。这样做的原因之一是为了提高效率。
按值传递对象涉及到生成临时拷贝，即调用复制构造函数，然后调用析构函数。
调用这些函数需要时间，复制大型对象比传递引用花费的时间要多得多。如果函数不修改对象，应将参数声明为const引用。
按引用传递对象的另外一个原因是，在继承使用虚函数时，被定义为接受基类引用参数的函数可以接受派生类。
5.返回对象和返回引用
有些类方法返回对象。您可能注意到了，有些成员函数直接返回对象，而另一些则返回引用。
有时方法必须返回对象，但如果可以不返回对象，则应返回引用。
在编码方面，直接返回对象与返回引用之间唯一的区别在于函数原型和函数头。
返回对象涉及生成返回对象的临时副本，这是调用函数的程序可以使用的副本。
因此，返回对象的时间成本包括调用复制构造函数来生成副本所需的时间和调用析构函数删除副本所需的时间。
函数不能返回在函数中创建的临时对象的引用，因为当函数结束时，临时对象将消失，因此这种引用将是非法的。
在这种情况下，应返回对象，以生成一个调用程序可以使用的副本。
如果函数返回在函数中创建的临时对象，则不要使用引用。
如果函数返回的是通过引用或指针传递给它的对象，则应按引用返回对象。
6.使用const
可以使用const来确保方法不修改参数；可以使用const来确保方法不修改调用它的对象；
可以使用const来确保返回的引用或指针不能用于修改对象中的数据。
注意，如果函数将参数声明为指向const对象的引用或指针，则不能将该参数传递给另一个函数，
除非后者也将参数声明为指向const对象的引用或指针。
1.is-a 关系
无需进行显式类型转换，基类指针就可以指向派生类对象，基类引用可以引用派生类对象。
不能在不进行显式类型转换的情况下，将派生类指针或引用指向基类对象。
2.什么不能被继承
构造函数是不能继承的，也就是说，创建派生类对象时，必须调用派生类的构造函数。
然而，派生类构造函数通常使用成员初始化列表语法来调用基类构造函数，以创建派生对象的基类部分。
如果派生类松造函数没有使用成员初始化列表语法显式调用基类构造函数，将使用基类的默认构造函数。
在继承链中，每个类都可以使用成员初始化列表将信息传递给相邻的基类。
C++11新增了一种让您能够继承构造函数的机制，但默认仍不继承构造函数。
析构函数也是不能继承的。然而，在释放对象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数。
通常，对于基类，其析构函数应设置为虚函数。
赋值运算符是不能继承的，原因很简单。派生类继承的方法的特征标与基类完全相同，但赋值运算符的特征标随类而异，
这是因为它包含一个类型为其所属类的形参。
3.赋值运算符
如果编译器发现程序将一个对象赋给同一个类的另一个对象，它将自动为这个类提供一个赋值运算符。
这个运算符的默认或隐式版本将采用成员赋值，即将原对象的相应成员赋给目标对象的每个成员。
然而，如果对象属于派生类，编译器将使用基类赋值运算符来处理派生对象中基类部分的赋值。
如果显式地为基类提供了赋值运算符，将使用该运算符。与此相似，如果成员是另一个类的对象，
则对于该成员，将使用其所属类的赋值运算符。
如果派生类构造函数使用new来初始化指针，则必须提供显式赋值运算符。
可以将派生对象赋给基类对象，但这只涉及基类的成员。
4.私有成员与保护成员
对派生类而言，保护成员类似于公有成员；但对于外部而言，保护成员与私有成员类似。
派生类可以直接访问基类的保护成员，但只能通过基类的成员函数来访问私有成员。
因此，将基类成员设置为私有的可以提高安全性，而将它们设置为保护成员则可简化代码的编写工作，并提高访问速度。
5.虚方法
设计基类时，必须确定是否将类方法声明为虚的。
如果希望派生类能够重新定义方法，则应在基类中将方法定义为虚的；
如果不希望重新定义方法，则不必将其声明为虚的。
6.析构函数
基类的析构函数应当是虚的。这样，当通过基类指针或引用来删除派生对象时，
程序将首先调用派生类的析构函数，然后调用基类的析构函数，而不仅仅是调用基类的析构函数。
7.友元函数
由于友元函数并非类成员，因此不能继承。然而，您可能希望派生类的友元函数能够使用基类的友元函数。
为此，可以通过运算符dynamic_cast<>将派生类引用或指针转换为基类引用或指针，
然后使用转换后的指针或引用来调用基类的友元函数。
8.有关使用基类方法的说明
以公有方式派生的类的对象可以通过多种方式来使用基类的方法。
派生类对象可以使用继承而来的基类方法，如果派生类没有重新定义该方法。
派生类的构造函数自动调用基类的构造函数。
派生类的构造函数自动调用基类的默认构造函数，如果没有在成员初始化列表中显式调用基类的构造函数。
派生类构造函数显式地调用成员初始化列表中指定的基类构造函数。
派生类方法可以使用作用域解析运算符来调用公有的和受保护的基类方法。
派生类的友元函数可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，
然后使用该引用或指针来调用基类的友元函数。
13.8.4 类函数小结
C++类函数有很多不同的变体，其中有些可以继承，有些不可以。
有些运算符函数既可以是成员函数，也可以是友元，而有些运算符函数只能是成员函数。
表13.1总结了这些特征，其中op=表示诸如+=、*等格式的赋值运算符。
注意，op=运算符的特征与“其他运算符”类别并没有区别。单独列出op=旨在指出这些运算符与=运算符的行为是不同的。
表13.1 成员函数属性
函数                  能否继承                  成员还是友元         默认能否生成         能否为虚函数         是否可以有返回类型
构造函数                  否                           成员                           能                           否                           否
析构函数                  否                           成员                           能                           能                           否
=                             否                           成员                           能                           能                           能
&                             能                           任意                           能                           能                           能
转换函数                  能                           成员                           否                           能                           否
()                             能                           成员                           否                           能                           能
[]                             能                           成员                           否                           能                           能
->                           能                           成员                           否                           能                           能
op=                        能                           任意                           否                           能                           能
new                        能                           静态成员                    否                           否                           void *
delete                     能                           静态成员                    否                           否                           void
其他运算符              能                           任意                           否                           能                           能
其他成员                  能                           成员                           否                           能                           能
友元                         否                           友元                           否                           否                           能
13.9总结
继承通过使用已有的类（基类）定义新的类（派生类），使得能够根据需要修改编程代码。
公有继承建立is-a关系，这意味着派生类对象也应该是某种基类对象。
作为is-a模型的一部分，派生类继承基类的数据成员和大部分方法，但不继承基类的构造函数、析构函数和赋值运算符。
派生类可以直接访问基类的公有成员和保护成员，并能够通过基类的公有方法和保护方法访问基类的私有成员。
可以在派生类中新增数据成员和方法，还可以将派生类用作基类，来做进一步的开发。
每个派生类都必须有自己的构造函数。程序创建派生类对象时，将首先调用基类的构造函数，然后调用派生类的构造函数；
程序删除对象时，将首先调用派生类的析构函数，然后调用基类的析构函数。
如果要将类用作基类，则可以将成员声明为保护的，而不是私有的，这样，派生类将可以直接访问这些成员。
然而，使用私有成员通常可以减少出现编程问题的可能性。
如果希望派生类可以重新定义基类的方法，则可以使用关键字virtual将它声明为虚的。
这样对于通过指针或引用访问的对象，能够根据对象类型来处理，而不是根据引用或指针的类型来处理。
具体地说，基类的析构函数通常应当是虚的。
可以考虑定义一个ABC：只定义接口，而不涉及实现。ABC必须至少包含一个纯虚方法，
可以在声明中的分号前面加上= 0来声明纯虚方法，不一定非得定义纯虚方法。
对于包含纯虚成员的类，不能使用它来创建对象。纯虚方法用于定义派生类的通用接口。
13.10复习题
1.派生类从基类那里继承了什么？
基类的公有成员成为派生类的公有成员。基类的保护成员成为派生类的保护成员。基类的私有成员被继承，但不能直接访问。

2.派生类不能从基类那里继承什么？
不能继承构造函数、析构函数、赋值运算符和友元。

3.假设baseDMA::operator=()函数的返回类型为void，而不是baseDMA &，这将有什么后果？
如果返回类型为baseDMA，而不是baseDMA &，又将有什么后果？
如果返回的类型为void，仍可以使用单个赋值，但不能使用连锁赋值；
如果返回对象而不是返回引用；则该方法的执行速度将所减慢，这是因为返回语句需要复制对象。

4.创建和删除派生类对象时，构造函数和析构函数调用的顺序是怎样的？
按派生的顺序调用构造函数，最早的构造函数最先调用。调用析构函数的顺序正好相反。

5.如果派生类没有添加任何数据成员，它是否需要构造函数？
是的，每个类都必须有自己的构造函数。如果派生类没有添加新成员，则构造函数可以为空，但必须存在。

6.如果基类和派生类定义了同名的方法，当派生类对象调用该方法时，被调用的将是哪个方法？
调用派生类方法。它取代基类定义。当派生类没有重新定义方法或使用作用域解析运算符时，才会调用基类方法。
通常，应将所有要重新定义的函数声明为虚函数。

7.在什么情况下，派生类应定义赋值运算符？
如果派生类构造函数使用new或new []运算符来初始化类的指针成员，则应定义赋值运算符。
更普遍地说，如果对于派生类成员来说，默认赋值运算符不能正确完成赋值；则应定义赋值运算符。

8.可以将派生类对象的地址赋给基类指针吗？可以将基类对象的地址赋给派生类指针吗？
可以将派生类对象的地址赋给基类指针；
只有通过显式类型转换，才可以将基类对象的地址赋给派生类指针，而使用这样的指针不一定安全。

9.可以将派生类对象赋给基类对象吗？可以将基类对象赋给派生类对象吗？
可以将派生类对象赋给基类对象。派生类中新增的数据成员不会传递给基类对象。程序将使用基类的赋值运算符。
仅当派生类定义了转换运算符（即包含将基类引用作为唯一参数的构造函数）或使用基类为参数的赋值运算符时，相反方向的赋值才是可能的。

10.假设定义了一个函数，它将基类对象的引用作为参数。为什么该函数也可以将派生类对象作为参数？
因为C++允许基类引用指向从该基类派生而来的任何类型。

11.假设定义了一个函数，它将基类对象作为参数（即函数按值传递基类对象）。为什么该函数也可以将派生类对象作为参数？
按值传递对象将调用复制构造函数。由于形参是基类对象，因此将调用基类的复制构造函数。
复制构造函数以基类引用为参数，该引用可以指向作为参数传递的派生对象。最终结果是，将生成一个新的基类对象，其成员对应于派生对象的基类部分。

12.为什么通常按引用传递对象比按值传递对象的效率更高？
按引用（而不是按值）传递对象，这样可以确保函数从虚函数受益。
按引用（而不是按值）传递对象可以节省内存和时间尤其对于大型对象。
按值传递对象的主要优点在于可以保护原始数据，但可以通过将引用作为const类型传递，来达到同样的目的。

13.假设Corporation是基类，PublicCorporation是派生类。再假设这两个类都定义了head函数，
ph是指向Corporation类型的指针，且被赋给了一个PublicCorporation对象的地址。如果基类将head定义为：
a.常规非虚方法；
b.虚方法；
则ph->head将被如何解释？
如果head是一个常规方法，则ph->head将调用Corporation:head；
如果head是一个虚函数，测ph->head将调用PublicCorporation::head。

14.下述代码有什么问题？
class Kitchen
{
private:
    double kit_sq_ft;
public:
    Kitchen() {kit_sq_ft = 0.0;}
    virtual double area() const {return kit_sq_ft * kit_sq_ft;}
};
class House : public Kitchen
{
private:
    double all_sq_ft;
public:
    House () {all_sq_ft += kit_sq_ft;}
    double area(const char * s) const {cout << s; return all_sq_ft;} 
};
首先，Kitchen和House不符合is-a模型，因此公有继承不适。
其次，House中的area定义隐藏了基类Kitchen中的area。
House不能直接访问基类Kitchen中的私有成员。

13.11编程练习
1.以下面的类声明为基础：
派生出一个Classic类，并添加一组char成员，用于存储指出CD中主要作品的字符串。
修改上述声明，使基类的所有函数都是虚的。如果上述定义声明的某个方法并不需要，则请删除它。
cd.h
#pragma once
#ifndef CD_H_
#define CD_H_
#include <iostream>
#include <cstring>

class Cd
{
private:
    char performers[50];
    char label[20];
    int selections;
    double playtime;
public:
    Cd();
    Cd(const char *perf, const char *leb, int sel, double playt);
    Cd(const Cd &d);
    virtual ~Cd();
    virtual void Report() const;
    Cd &operator = (const Cd &d);
};

class Classic : public Cd
{
private:
    static const int lenght = 40;
    char cdname[lenght];
public:
    Classic();
    Classic(const char *name, Cd &cd);
    Classic(const char *name, const char *perf, const char *leb, int sel, double playt);
    Classic(const Classic &c);
    ~Classic();
    virtual void Report() const;
    Classic &operator = (const Classic &c);
};

#endif

cd.cpp
#include <iostream>
#include "cd.h"

Cd::Cd()
{
    performers[0] = '\0';
    label[0] = '\0';
    selections = 0;
    playtime = 0;
}
Cd::Cd(const char *perf, const char *leb, int sel, double playt)
{
    strncpy(performers, perf, 50 - 1);
    performers[50 - 1] = '\0';
    strncpy(label, leb, 20 - 1);
    label[20 - 1] = '\0';

    if (sel < 0)
    {
        std::cout << "Selections must be a positive integer. ";
        std::cout << "Setting selections to 0." << std::endl;
        selections = 0;
    }
    else
    {
        selections = sel;
    }

    if (playt < 0)
    {
        std::cout << "Play time must be a positive real number. ";
        std::cout << "Setting play time to 0." << std::endl;
        playtime = 0;
    }
    else
    {
        playtime = playt;
    }
}

Cd::Cd(const Cd &d)
{
    strncpy(performers, d.performers, 50 - 1);
    performers[50 - 1] = '\0';
    strncpy(label, d.label, 20 - 1);
    label[20 - 1] = '\0';
    selections = d.selections;
    playtime = d.playtime;
}

Cd::~Cd()
{

}

Cd &Cd::operator = (const Cd &d)
{
    if (this == &d)
    {
        return *this;
    }
    strncpy(performers, d.performers, 50 - 1);
    performers[50 - 1] = '\0';
    strncpy(label, d.label, 20 - 1);
    label[20 - 1] = '\0';
    selections = d.selections;
    playtime = d.playtime;

    return *this;
}

void Cd::Report() const
{
    std::cout << "Performers: " << performers << std::endl;
    std::cout << "label: " << label << std::endl;
    std::cout << "Selections: " << selections << std::endl;
    std::cout << "Play time: " << playtime << std::endl;
}

Classic::Classic()
{
    cdname[0] = '\0';
}

Classic::Classic(const char *name, Cd &cd) : Cd(cd)
{
    strncpy(cdname, name, 40 - 1);
    cdname[40 - 1] = '\0';
}

Classic::Classic(const char *name, const char *perf, const char *leb, int sel, double playt) : Cd(perf, leb, sel, playt)
{
    strncpy(cdname, name, 40 - 1);
    cdname[40 - 1] = '\0';
}

Classic::Classic(const Classic &c) : Cd(c)
{
    strncpy(cdname, c.cdname, 40 - 1);
    cdname[40 - 1] = '\0';
}

Classic::~Classic()
{

}

void Classic::Report() const
{
    Cd::Report();
    std::cout << "Primary Work: " << cdname << std::endl;
}

Classic &Classic::operator = (const Classic &c)
{
    if (this == &c)
    {
        return *this;
    }
    Cd::operator=(c);
    strncpy(cdname, c.cdname, 40 - 1);
    cdname[40 - 1] = '\0';

    return *this;
}

ch13_p01.cpp
#include <iostream>
#include "cd.h"

void Bravo(const Cd &disk);

int main()
{
    Cd c1("Beatles", "Capitol", 14, 35.5);
    Classic c2 = Classic("Piano sonata in b flat, Fantasia in C", "Alfred Brendel", "Phillips", 2, 57.17);
    Cd *pcd = &c1;

    std::cout << "Using object directly: " << std::endl;
    std::cout << std::endl;
    c1.Report();
    std::cout << std::endl;
    c2.Report();
    std::cout << std::endl;

    std::cout << "Using type cd* pointer to objects: " << std::endl;;
    std::cout << std::endl;
    pcd->Report();
    std::cout << std::endl;
    pcd = &c2;
    pcd->Report();
    std::cout << std::endl;

    std::cout << "Calling a function with a Cd reference argument: " << std::endl;;
    std::cout << std::endl;
    Bravo(c1);
    std::cout << std::endl;
    Bravo(c2);
    std::cout << std::endl;

    std::cout << "Testing assignment: " << std::endl;
    Classic copy;
    copy = c2;
    copy.Report();

    return 0;
}

void Bravo(const Cd &disk)
{
    disk.Report();
}
显示结果如下
Using object directly:

Performers: Beatles
label: Capitol
Selections: 14
Play time: 35.5

Performers: Alfred Brendel
label: Phillips
Selections: 2
Play time: 57.17
Primary Work: Piano sonata in b flat, Fantasia in C

Using type cd* pointer to objects:

Performers: Beatles
label: Capitol
Selections: 14
Play time: 35.5

Performers: Alfred Brendel
label: Phillips
Selections: 2
Play time: 57.17
Primary Work: Piano sonata in b flat, Fantasia in C

Calling a function with a Cd reference argument:

Performers: Beatles
label: Capitol
Selections: 14
Play time: 35.5

Performers: Alfred Brendel
label: Phillips
Selections: 2
Play time: 57.17
Primary Work: Piano sonata in b flat, Fantasia in C

Testing assignment:
Performers: Alfred Brendel
label: Phillips
Selections: 2
Play time: 57.17
Primary Work: Piano sonata in b flat, Fantasia in C

2.完成练习1，但让两个类使用动态内存分配而不是长度固定的数组来记录字符串。
cd2.h
#pragma once
#ifndef CD2_H_
#define CD2_H_
#include <iostream>
#include <cstring>

class Cd
{
private:
    char *performers;
    char *label;
    int selections;
    double playtime;
public:
    Cd();
    Cd(const char *perf, const char *leb, int sel, double playt);
    Cd(const Cd &d);
    virtual ~Cd();
    virtual void Report() const;
    Cd &operator = (const Cd &d);
};

class Classic : public Cd
{
private:
    char *cdname;
public:
    Classic();
    Classic(const char *name, Cd &cd);
    Classic(const char *name, const char *perf, const char *leb, int sel, double playt);
    Classic(const Classic &c);
    ~Classic();
    virtual void Report() const;
    Classic &operator = (const Classic &c);
};

#endif

cd2.cpp
#include "cd2.h"

Cd::Cd()
{
    performers = nullptr;
    label = nullptr;
    selections = 0;
    playtime = 0;
}

Cd::Cd(const char *perf, const char *leb, int sel, double playt)
{
    if (perf == nullptr)
    {
        performers = nullptr;
    }
    else
    {
        performers = new char[strlen(perf) + 1];
        strcpy(performers, perf);
    }

    if (leb == nullptr)
    {
        label = nullptr;
    }
    else
    {
        label = new char[strlen(leb) + 1];
        strcpy(label, leb);
    }

    if (sel < 0)
    {
        std::cout << "Selections must be a positive integer. ";
        std::cout << "Setting selections to 0." << std::endl;
        selections = 0;
    }
    else
    {
        selections = sel;
    }

    if (playt < 0)
    {
        std::cout << "Play time must be a positive real number. ";
        std::cout << "Setting play time to 0." << std::endl;
        playtime = 0;
    }
    else
    {
        playtime = playt;
    }
}

Cd::Cd(const Cd &d)
{
    if (d.performers == nullptr)
    {
        performers = nullptr;
    }
    else
    {
        performers = new char[strlen(d.performers) + 1];
        strcpy(performers, d.performers);
    }

    if (d.label == nullptr)
    {
        label = nullptr;
    }
    else
    {
        label = new char[strlen(d.label) + 1];
        strcpy(label, d.label);
    }
    selections = d.selections;
    playtime = d.playtime;
}

Cd::~Cd()
{
    delete[] performers;
    delete[] label;
}

Cd &Cd::operator = (const Cd &d)
{
    if (this == &d)
    {
        return *this;
    }
    else
    {
        delete[] performers;
        delete[] label;

        if (d.performers == nullptr)
        {
            performers = nullptr;
        }
        else
        {
            performers = new char[strlen(d.performers) + 1];
            strcpy(performers, d.performers);
        }

        if (d.label == nullptr)
        {
            label = nullptr;
        }
        else
        {
            label = new char[strlen(d.label) + 1];
            strcpy(label, d.label);
        }
    }

    selections = d.selections;
    playtime = d.playtime;

    return *this;
}

void Cd::Report() const
{
    std::cout << "Performers: " << performers << std::endl;
    std::cout << "label: " << label << std::endl;
    std::cout << "Selections: " << selections << std::endl;
    std::cout << "Play time: " << playtime << std::endl;
}

Classic::Classic()
{
    cdname = nullptr;
}

Classic::Classic(const char *name, Cd &cd) : Cd(cd)
{
    if (name == nullptr)
    {
        cdname = nullptr;
    }
    else
    {
        cdname = new char[strlen(name) + 1];
        strcpy(cdname, name);
    }
}

Classic::Classic(const char *name, const char *perf, const char *leb, int sel, double playt)  : Cd(perf, leb, sel, playt)
{
    if (name == nullptr)
    {
        cdname = nullptr;
    }
    else
    {
        cdname = new char[strlen(name) + 1];
        strcpy(cdname, name);
    }
}

Classic::Classic(const Classic &c) : Cd(c)
{
    if (c.cdname == nullptr)
    {
        cdname = nullptr;
    }
    else
    {
        cdname = new char[strlen(c.cdname) + 1];
        strcpy(cdname, c.cdname);
    }
}
Classic::~Classic()
{
    delete[] cdname;
}

void Classic::Report() const
{
    Cd::Report();
    std::cout << "Primary Work: " << cdname << std::endl;
}

Classic &Classic::operator = (const Classic &c)
{
    if (this == &c)
    {
        return *this;
    }
    else
    {
        Cd::operator=(c);
        delete[] cdname;

        if (c.cdname == nullptr)
        {
            cdname = nullptr;
        }
        else
        {
            cdname = new char[strlen(c.cdname) + 1];
            strcpy(cdname, c.cdname);
        }
    }
    return *this;
}

ch13_p02.cpp
#include "cd2.h"


void Bravo(const Cd &disk);

int main()
{
    Cd c1("Beatles", "Capitol", 14, 35.5);
    Classic c2 = Classic("Piano sonata in b flat, Fantasia in C", "Alfred Brendel", "Phillips", 2, 57.17);
    Cd *pcd = &c1;

    std::cout << "Using object directly: " << std::endl;
    std::cout << std::endl;
    c1.Report();
    std::cout << std::endl;
    c2.Report();
    std::cout << std::endl;

    std::cout << "Using type cd* pointer to objects: " << std::endl;;
    std::cout << std::endl;
    pcd->Report();
    std::cout << std::endl;
    pcd = &c2;
    pcd->Report();
    std::cout << std::endl;

    std::cout << "Calling a function with a Cd reference argument: " << std::endl;;
    std::cout << std::endl;
    Bravo(c1);
    std::cout << std::endl;
    Bravo(c2);
    std::cout << std::endl;

    std::cout << "Testing assignment: " << std::endl;
    Classic copy;
    copy = c2;
    copy.Report();

    return 0;
}

void Bravo(const Cd &disk)
{
    disk.Report();
}
显示结果如下
Using object directly:

Performers: Beatles
label: Capitol
Selections: 14
Play time: 35.5

Performers: Alfred Brendel
label: Phillips
Selections: 2
Play time: 57.17
Primary Work: Piano sonata in b flat, Fantasia in C

Using type cd* pointer to objects:

Performers: Beatles
label: Capitol
Selections: 14
Play time: 35.5

Performers: Alfred Brendel
label: Phillips
Selections: 2
Play time: 57.17
Primary Work: Piano sonata in b flat, Fantasia in C

Calling a function with a Cd reference argument:

Performers: Beatles
label: Capitol
Selections: 14
Play time: 35.5

Performers: Alfred Brendel
label: Phillips
Selections: 2
Play time: 57.17
Primary Work: Piano sonata in b flat, Fantasia in C

Testing assignment:
Performers: Alfred Brendel
label: Phillips
Selections: 2
Play time: 57.17
Primary Work: Piano sonata in b flat, Fantasia in C

3.修改baseDMA-lacksDMA-hasDMA类层次，让三个类都从一个ABC派生而来，
然后使用与程序清单13.10相似的程序对结果进行测试。也就是说，它应使用ABC指针数组，并让用户决定要创建的对象类型。
在类定义中添加virtual View方法以处理数据显示。
dma2.h
#pragma once
#ifndef DMA2_H_
#define DMA2_H_
#include <iostream>
#include <cstring>

class abcDMA
{
private:
    char *label;
    int rating;
protected:
    const char *showLabel() const
    {
        return label;
    }
    int showRating() const
    {
        return rating;
    }
public:
    abcDMA(const char *l = "NULL", int r = 0);
    abcDMA(const abcDMA &rs);
    virtual void View() const = 0;
    virtual ~abcDMA();
    abcDMA &operator = (const abcDMA &rs);
    friend std::ostream &operator << (std::ostream &os, const abcDMA &rs);
};

class baseDMA : public abcDMA
{
private:
public:
    baseDMA(const char *l = "null", int r = 0);
    baseDMA(const baseDMA &rs);
    virtual ~baseDMA();
    baseDMA &operator = (const baseDMA &rs);
    friend std::ostream &operator << (std::ostream &os, const baseDMA &rs);
    virtual void View() const;
};

class lacksDMA : public abcDMA
{
private:
    enum { COL_LEN = 40 };
    char color[COL_LEN];
public:
    lacksDMA(const char *c = "blank", const char *l = "null", int r = 0);
    lacksDMA(const char *c, const abcDMA &rs);
    friend std::ostream &operator<<(std::ostream &os, const lacksDMA &ls);
    virtual void View() const;
};

class hasDMA : public abcDMA
{
private:
    char *style;
public:
    hasDMA(const char *s = "none", const char *l = "null", int r = 0);
    hasDMA(const char *s, const abcDMA &rs);
    hasDMA(const hasDMA &hs);
    ~hasDMA();
    hasDMA &operator = (const hasDMA &rs);
    friend std::ostream &operator << (std::ostream &os, const hasDMA &hs);
    virtual void View() const;
};

#endif

dma2.cpp
#include "dma2.h"

abcDMA::abcDMA(const char *l, int r)
{
    label = new char[std:: strlen(l) + 1];
    std::strcpy(label, l);
    rating = r;
}

abcDMA::abcDMA(const abcDMA &rs)
{
    label = new char[std:: strlen(rs.label) + 1];
    std::strcpy(label, rs.label);
    rating = rs.rating;
}

void abcDMA::View() const
{
    std::cout << "Label: " << label << std::endl;
    std::cout << "Rating: " << rating << std::endl;
}

abcDMA::~abcDMA()
{
    delete[] label;
}

abcDMA   &abcDMA::operator = (const abcDMA &rs)
{
    if (this == &rs)
    {
        return *this;
    }
    else
    {
        delete[] label;
        label = new char[std:: strlen(rs.label) + 1];
        std::strcpy(label, rs.label);
        rating = rs.rating;
        return *this;
    }
}

std::ostream &operator << (std::ostream &os, const abcDMA &rs)
{
    os << "Label: " << rs.label << std::endl;
    os << "Rating: " << rs.rating << std::endl;
    return os;
}

baseDMA::baseDMA(const char *l, int r) : abcDMA(l, r) { }

baseDMA::baseDMA(const baseDMA &rs) : abcDMA(rs) { }

baseDMA::~baseDMA() { }

baseDMA &baseDMA::operator = (const baseDMA &rs)
{
    if (this == &rs)
    {
        return *this;
    }
    abcDMA::operator=(rs);
    return *this;
}
void baseDMA::View() const
{
    std::cout << "baseDMA object" << std::endl;
    std::cout << "Label: " << showLabel() << std::endl;
    std::cout << "Rating: " << showRating() << std::endl;
}
std::ostream &operator << (std::ostream &os, const baseDMA &rs)
{
    os << (const abcDMA &)rs;
    return os;
}

lacksDMA::lacksDMA(const char *c, const char *l, int r) : abcDMA(l, r)
{
    std::strncpy(color, c, COL_LEN - 1);
    color[COL_LEN - 1] = '\0';
}
lacksDMA::lacksDMA(const char *c, const abcDMA &rs) : abcDMA(rs)
{
    std::strncpy(color, c, COL_LEN - 1);
    color[COL_LEN - 1] = '\0';
}

void lacksDMA::View() const
{
    std::cout << "lacksDMA object" << std::endl;
    abcDMA::View();
    std::cout << "Color: " << color << std::endl;
}

std::ostream &operator << (std::ostream &os, const lacksDMA &Is)
{
    os << (const abcDMA &) Is;
    os << "Color: " << Is.color << std::endl;
    return os;
}
hasDMA::hasDMA(const char *s, const char *l, int r) : abcDMA(l, r)
{
    style = new char[std::strlen(s) + 1];
    std::strcpy(style, s);
}
hasDMA::hasDMA(const char *s, const abcDMA &rs) : abcDMA(rs)
{
    style = new char[std::strlen(s) + 1];
    std::strcpy(style, s);
}
hasDMA::hasDMA(const hasDMA &hs) : abcDMA(hs)
{
    style = new char[std::strlen(hs.style) + 1];
    std::strcpy(style, hs.style);
}

hasDMA::~hasDMA()
{
    delete[] style;
}

hasDMA &hasDMA::operator = (const hasDMA &hs)
{
    if (this == &hs)
    {
        return *this;
    }
    else
    {
        abcDMA::operator=(hs);
        delete[] style;
        style = new char[std::strlen(hs.style) + 1];
        std::strcpy(style, hs.style);
        return *this;
    }
}

void hasDMA::View() const
{
    std::cout << "hasDMA object" << std::endl;
    abcDMA::View();
    std::cout << "Style: " << style << std::endl;
}

std::ostream &operator << (std::ostream &os, const hasDMA &hs)
{
    os << (const abcDMA &) hs;
    os << "Style: " << hs.style << std::endl;
    return os;
}

ch13_p03.cpp
#include "dma2.h"

const int ArrLength = 3;
const int LEN = 40;

int main()
{
    abcDMA *arr[ArrLength];
    char label[LEN];
    char style[LEN];
    char color[LEN];

    int rating = 0;
    int choice = 0;

    for (int i = 0; i < ArrLength; i++)
    {
        std::cout << "For element " << i + 1 << ", enter the label: ";
        std::cin.getline(label, LEN);

        std::cout << "Enter the rating: ";
        std::cin >> rating;

        std::cout << "Enter 1 if this is to be a baseDMA object" << std::endl;
        std::cout << "Enter 2 if this is to be a hasDMA object" << std::endl;
        std::cout << "Enter 3 if this is to be a lacksDMA object" << std::endl;
        std::cin >> choice;
        std::cin.get();

        switch (choice)
        {
        case 1:
            arr[i] = new baseDMA(label, rating);
            break;
        case 2:
            std::cout << "Enter the style: ";
            std::cin.getline(style, LEN);
            arr[i] = new hasDMA(style, label, rating);
            break;
        case 3:
            std::cout << "Enter color: ";
            std::cin.getline(color, LEN);
            arr[i] = new lacksDMA(color, label, rating);
            break;
        default:
            std::cout << "Unrecognized input, setting object ";
            std::cout << "to baseDMA";
            arr[i] = new baseDMA(label, rating);
            break;
        }

    }
    std::cout << "Here's what you entered:" << std::endl;

    for (int i = 0; i < ArrLength; i++)
    {
        std::cout << "Element " << i + 1 << ":" << std::endl;
        arr[i]->View();
    }

    for (int i = 0; i < ArrLength; i++)
    {
        delete arr[i];
    }

    return 0;
}
显示结果如下
For element 1, enter the label: Portabelly
Enter the rating: 8
Enter 1 if this is to be a baseDMA object
Enter 2 if this is to be a hasDMA object
Enter 3 if this is to be a lacksDMA object
1
For element 2, enter the label: Buffalo Keys
Enter the rating: 5
Enter 1 if this is to be a baseDMA object
Enter 2 if this is to be a hasDMA object
Enter 3 if this is to be a lacksDMA object
2
Enter the style: Mercator
For element 3, enter the label: Blimpo
Enter the rating: 4
Enter 1 if this is to be a baseDMA object
Enter 2 if this is to be a hasDMA object
Enter 3 if this is to be a lacksDMA object
3
Enter color: red
Here's what you entered:
Element 1:
baseDMA object
Label: Portabelly
Rating: 8
Element 2:
hasDMA object
Label: Buffalo Keys
Rating: 5
Style: Mercator
Element 3:
lacksDMA object
Label: Blimpo
Rating: 4
Color: red

4.Benevolent Order of Programmers用来维护瓶装葡萄酒箱。为描述它，BOP Portmaster设置了一个Port类，其声明如下：
show（）方法按下面的格式显示信息：
operator<<()函数按下面的格式显示信息（末尾没有换行符）：
PortMaster完成了Port类的方法定义后派生了VintagePort类，VintagePort类如下所示：
您被指定负责完成VintagePort。
a.第一个任务是重新创建Port方法定义，因为前任被开除时销毁了方法定义。
b.第二个任务是解释为什么有的方法重新定义了，而有些没有重新定义。
c.第三个任务是解释为何没有将operator=（）和operator<<（）声明为虚的。
d.第四个任务是提供VintagePort中各个方法的定义。
port.h
#pragma once
#ifndef PORT_H_
#define PORT_H_
#include <iostream>
#include <cstring>

class Port
{
private:
    char *brand;
    char style[20];
    int bottles;
public:
    Port(const char *br = "none", const char *st = "none", int b = 0);
    Port(const Port &p);
    virtual ~Port()
    {
        delete[] brand;
    }
    Port &operator = (const Port &p);
    Port &operator += (int b);
    Port &operator -= (int b);
    int BottleCount() const
    {
        return bottles;
    }
    virtual void Show() const;
    friend std::ostream &operator << (std::ostream &os, const Port &p);
};

#endif

port.cpp
#include "port.h"

Port::Port(const char *br, const char *st, int b)
{
    brand = new char[strlen(br) + 1];
    strcpy(brand, br);
    strncpy(style, st, 19);
    style[19] = '\0';

    if (b < 0)
    {
        std::cout << "Number of bottles must be a positive integer." << std::endl;
        std::cout << "Setting bottles to 0." << std::endl;
        bottles = 0;
    }
    else
    {
        bottles = b;
    }
}

Port::Port(const Port &p)
{
    brand = new char[strlen(p.brand) + 1];
    strcpy(brand, p.brand);
    strncpy(style, p.style, 19);
    style[19] = '\0';
    bottles = p.bottles;
}

Port &Port::operator = (const Port &p)
{
    if (this == &p)
    {
        return *this;
    }
    else
    {
        delete[] brand;
        brand = new char[strlen(p.brand) + 1];
        strcpy(brand, p.brand);
        strncpy(style, p.style, 19);
        style[19] = '\0';
        bottles = p.bottles;
        return *this;
    }
}

Port &Port::operator += (int b)
{
    bottles += b;
    return *this;
}
Port &Port::operator -= (int b)
{
    if (b > bottles)
    {
        std::cout << "You cannot subtract more bottles than you have!" << std::endl;
        std::cout << "Subtracting " << bottles << " bottles." << std::endl;
        bottles = 0;
    }
    else
    {
        bottles -= b;
    }
    return *this;
}

void Port::Show() const
{
    std::cout << "Brand: " << brand << std::endl;
    std::cout << "Kind: " << style << std::endl;
    std::cout << "Bottles: " << bottles << std::endl;
}

std::ostream &operator<<(std::ostream &os, const Port &p)
{
    os << p.brand << ", " << p.style << ", " << p.bottles;
    return os;
}

vintageport.h
#pragma once
#ifndef VINTAGEPORT_H_
#define VINTAGEPORT_H_
#include "port.h"

class VintagePort : public Port
{
private:
    char *nickname;
    int year;
public:
    VintagePort();
    VintagePort(const char *br, int b, const char *nn, int y);
    VintagePort(const VintagePort &vp);
    ~VintagePort()
    {
        delete[] nickname;
    }
    VintagePort &operator = (const VintagePort &vp);
    void Show() const;
    friend std::ostream &operator << (std::ostream &os, const VintagePort &vp);
};

#endif

vintageport.cpp
#include <iostream>
#include <cstring>
#include "vintageport.h"

VintagePort::VintagePort() : Port("The Noble", "Vintage")
{
    nickname = nullptr;
    year = 1900;
}

VintagePort::VintagePort(const char *br, int b, const char *nn, int y) : Port(br, "Vintage", b)
{
    nickname = new char[strlen(nn) + 1];
    strcpy(nickname, nn);
    year = y;
}

VintagePort::VintagePort(const VintagePort &vp) : Port(vp)
{
    nickname = new char[strlen(vp.nickname) + 1];
    strcpy(nickname, vp.nickname);
    year = vp.year;
}

VintagePort &VintagePort::operator = (const VintagePort &vp)
{
    if (this == &vp)
    {
        return *this;
    }
    else
    {
        Port::operator=(vp);
        delete[] nickname;
        nickname = new char[strlen(vp.nickname) + 1];
        strcpy(nickname, vp.nickname);
        year = vp.year;
        return *this;
    }
}

void VintagePort::Show() const
{
    Port::Show();
    std::cout << "Nickname: " << nickname << std::endl;
    std::cout << "Year: " << year << std::endl;
}

std::ostream &operator<<(std::ostream &os, const VintagePort &vp)
{
    os << (const Port &)vp;

    if (nullptr == vp.nickname)
    {
        os << ", " << vp.year;
    }
    else
    {
        os << ", " << vp.nickname << ", " << vp.year;
    }
    return os;
}

ch13_p04.cpp
#include <iostream>
#include "vintageport.h"

const int arrSize = 2;
const int LEN = 50;

int main()
{
    char brand[LEN];
    char style[LEN];
    int bottles = 0;
    char nickname[LEN];
    int year = 0;
    int choice = 0;
    Port *arr[arrSize];

    for (int i = 0; i < arrSize; i++)
    {
        std::cout << "Object " << i + 1 << std::endl;
        std::cout << "Enter the brand for the object: ";
        std::cin.getline(brand, LEN);
        std::cout << "Enter the number of bottles: ";
        std::cin >> bottles;
        std::cin.get();
        std::cout << "Enter 1 if you would like this to be a Port object" << std::endl;
        std::cout << "Enter 2 if you would like this to be a Vintage Port object";
        std::cout << std::endl;
        std::cin >> choice;
        std::cin.get();

        switch (choice)
        {
        case 1:
            std::cout << "Enter the style: ";
            std::cin.getline(style, LEN);
            arr[i] = new Port(brand, style, bottles);
            std::cout << std::endl;
            break;
        case 2:
            std::cout << "Enter the nickname: ";
            std::cin.getline(nickname, LEN);
            std::cout << "Enter the year: ";
            std::cin >> year;
            std::cin.get();
            arr[i] = new VintagePort(brand, bottles, nickname, year);
            std::cout << std::endl;
            break;
        default:
            std::cout << "Input not recognized. Making a default Port object";
            arr[i] = new Port();
            std::cout << std::endl;
            break;
        }
    }

    std::cout << "Here's our array:" << std::endl;
    for (int i = 0; i < arrSize; i++)
    {
        std::cout << "Object " << i + 1 << std::endl;
        arr[i]->Show();
    }
    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Object 1
Enter the brand for the object: Hello World
Enter the number of bottles: 20
Enter 1 if you would like this to be a Port object
Enter 2 if you would like this to be a Vintage Port object
1
Enter the style: aaabbb

Object 2
Enter the brand for the object: Mike Pence
Enter the number of bottles: 30
Enter 1 if you would like this to be a Port object
Enter 2 if you would like this to be a Vintage Port object
2
Enter the nickname: cccddd
Enter the year: 2020

Here's our array:
Object 1
Brand: Hello World
Kind: aaabbb
Bottles: 20
Object 2
Brand: Mike Pence
Kind: Vintage
Bottles: 30
Nickname: cccddd
Year: 2020
Done.

第14章 C++中的代码重用
14.1 包含对象成员的类
14.1.1 valarray类简介
14.1.2 Student类的设计
14.1.3 Student类示例
14.2 私有继承
14.2.1 Student 类示例（新版本）
14.2.2 使用包含还是私有继承
14.2.3 保护继承
14.2.4 使用using重新定义访问权限
14.3 多重继承
14.3.1 有多少Worker
14.3.2 哪个方法
14.3.3 MI小结
14.4 类模板
14.4.1 定义类模板
14.4.2 使用模板类
14.4.3 深入探讨模板类
14.4.4 数组模板示例和非类型参数
14.4.5 模板多功能性
14.4.6 模板的具体化
14.4.7 成员模板
14.4.8 将模板用作参数
14.4.9 模板类和友元
14.4.10 模板别名（C++11）
14.5 总结
14.6 复习题
14.7 编程练习
本章内容包括：
has-a关系。
包含对象成员的类。
模板类valarray。
私有和保护继承。
多重继承。
虚基类。
创建类模板。
使用类模板。
模板的具体化。
valarray模板类是由头文件valarray支持的。这个类用于处理数值（或具有类似特性的类），
它支持诸如将数组中所有元素的值相加以及在数组中找出最大和最小的值等操作。
使用valarray类来声明一个对象时需要在标识符valarray后面加上一对尖括号，并在其中包含所需的数据类型：
valarray<double> weights;
double gpa[5] = {3.1, 3.5, 3.8, 2.9, 3.3};
valarray<double> v1;   // an array of double, size 0
valarray<int> v2(8);   //an array of 8 int elements
valarray<int> v3(10, 8); //an array of 8 int elements, each set to 10
valarray<double> v4(gpa, 4)   // an array of 4 elements initialize to the first 4 elements of gpa
valarray<int> v5 = {20, 32, 17, 9};   //C++11初始化列表
可以创建长度为零的空数组，指定长度的空数组、所存元素度被初始化为指定值的数组、用常规数组中的值进行初始化的数组。
在C++11中，也可使用初始化列表。
下面是这个类的一些方法。
operator[]：让您能够访问各个元素。
size：返回包含的元素数。
sum：返回所有元素的总和。
max：返回最大的元素。
min（）：返回最小的元素。
程序清单14.1 studentc.h
#pragma once
#ifndef STUDENTC_H_
#define STUDENTC_H_
#include <iostream>
#include <string>
#include <valarray>

class Student
{
private:
    typedef std::valarray<double> ArrayDb;
    std::string name;
    ArrayDb scores;
    std::ostream &arr_out(std::ostream &os) const;
public:
    Student() : name("Null Student"), scores() {}
    explicit Student(const std::string &s) : name(s), scores() {}
    explicit Student(int n) : name("Nully"), scores(n) {}
    Student(const std::string &s, int n) : name(s), scores(n) {}
    Student(const std::string &s, const ArrayDb &a) : name(s), scores(a) {}
    Student(const char *str, const double *pd, int n) : name(str), scores(pd, n) {}
    ~Student() {}
    double Average() const;
    const std::string &Name() const;
    double &operator[] (int i);
    double operator[] (int i) const;
    friend std::istream &operator>>(std::istream &is, Student &stu);
    friend std::istream &getline(std::istream &is, Student &stu);
    friend std::ostream &operator<<(std::ostream &os, const Student &stu);
};

#endif
使用explicit防止单参数构造函数的隐式转换，使用const限制方法修改数据。
对于继承的对象，构造函数在成员初始化列表中使用类名来调用特定的基类构造函数；对于成员对象，构造函数则使用成员名。
C++要求在构建对象的其他部分之前，先构建继承的对象和所有成员对象。
如果省略初始化列表，C++将使用成员对象所属类的默认构造函数。
当初始化列表包含多个项目时，这些项目被初始化的顺序为它们被声明的顺序，而不是它们在初始化列表中的顺序。
通常，初始化顺序并不重要，但如果代码使用一个成员的值作为另一个成员的初始化表达式的一部分时，
初始化顺序就非常重要了。
程序清单14.2 studentc.cpp
#include <iostream>
#include "studentc.h"

double Student::Average() const
{
    if (scores.size() > 0)
    {
        return scores.sum() / scores.size();
    }
    else
    {
        return 0;
    }
}
const std::string &Student::Name() const
{
    return name;
}
double &Student::operator[](int i)
{
    return scores[i];
}
double Student::operator[](int i) const
{
    return scores[i];
}
std::ostream &Student::arr_out(std::ostream &os) const
{
    int i;
    int lim = scores.size();
    if (lim > 0)
    {
        for (i = 0; i < lim; i++)
        {
            os << scores[i] << " ";
            if (i % 5 == 4)
            {
                os << std::endl;
            }
        }
        if (i % 5 != 0)
        {
            os << std::endl;
        }
    }
    else
    {
        os << " empty array ";
    }
    return os;
}

std::istream &operator>>(std::istream &is, Student &stu)
{
    is >> stu.name;
    return is;
}
std::istream &getline(std::istream &is, Student &stu)
{
    std::getline(is, stu.name, '\n');
    return is;
}
std::ostream &operator<<(std::ostream &os, const Student &stu)
{
    os << "Scores for " << stu.name << " :\n";
    stu.arr_out(os);
    return os;
}

程序清单14.3 use_stuc.cpp
#include <iostream>
#include "studentc.h"

using std::cin;
using std::cout;
using std::endl;

const int pupils = 3;
const int quizzes = 5;

void set(Student &sa, int n);

int main()
{
    Student ada[pupils] = { Student(quizzes), Student(quizzes), Student(quizzes) };

    int i;
    for (i = 0; i < pupils; ++i)
    {
        set(ada[i], quizzes);
    }
    cout << endl;
    cout << "Student List:\n";
    for (i = 0; i < pupils; ++i)
    {
        cout << ada[i].Name() << endl;
    }
    cout << endl;
    cout << "Results:\n";
    for (i = 0; i < pupils; ++i)
    {
        cout << ada[i];
        cout << "average: " << ada[i].Average() << endl;
        cout << endl;
    }
    cout << "Done.\n";

    return 0;
}

void set(Student &sa, int n)
{
    cout << "Please enter the student's name: ";
    getline(cin, sa);
    cout << "Please enter " << n << " quiz scores :\n";
    for (int i = 0; i < n; i++)
    {
        cin >> sa[i];
    }
    while (cin.get() != '\n')
    {
        continue;
    }
}
显示结果如下
Please enter the student's name: Mike Pence
Please enter 5 quiz scores :
3.6 3.8 3.9 3.9 3.8
Please enter the student's name: Peter Smith
Please enter 5 quiz scores :
4.1 4.3 4.3 3.8 3.9
Please enter the student's name: Hello World
Please enter 5 quiz scores :
4.3 4.2 3.9 3.9 3.6

Student List:
Mike Pence
Peter Smith
Hello World

Results:
Scores for Mike Pence :
3.6 3.8 3.9 3.9 3.8
average: 3.8

Scores for Peter Smith :
4.1 4.3 4.3 3.8 3.9
average: 4.08

Scores for Hello World :
4.3 4.2 3.9 3.9 3.6
average: 3.98

Done.

使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。
这意味着基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。
使用公有继承，基类的公有方法将成为派生类的公有方法。
使用私有继承，基类的公有方法将成为派生类的私有方法。
例如，如果从String类派生出Student类，后者将有一个String类组件，可用于保存字符串。
另外，Student方法可以使用String方法来访问String组件。
包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中。
我们将使用术语子对象（subobject）来表示通过继承或包含添加的对象。
因此私有继承提供的特性与包含相同：获得实现，但不获得接口。
所以，私有继承也可以用来实现has-a关系。
要进行私有继承，请使用关键字private而不是public来定义类
（实际上，private是默认值，因此省略访问限定符也将导致私有继承）。
程序清单14.4 studenti.h
#pragma once
#ifndef STUDENTI_H_
#define STUDENTI_H_
#include <iostream>
#include <valarray>
#include <string>

class Student : private std::string, private std::valarray<double>
{
private:
    typedef std::valarray<double> ArrayDb;
    std::ostream &arr_out(std::ostream &os) const;
public:
    Student() : std::string("Null Student"), ArrayDb() {}
    explicit Student(const std::string &s) : std::string(s), ArrayDb() {}
    explicit Student(int n) : std::string("Nully"), ArrayDb(n) {}
    Student(const std::string &s, int n) : std::string(s), ArrayDb(n) {}
    Student(const std::string &s, const ArrayDb &a) : std::string(s), ArrayDb(a) {}
    Student(const char *str, const double *pd, int n) : std::string(str), ArrayDb(pd, n) {}
    ~Student() {}
    double Average() const;
    double &operator [] (int i);
    double operator [] (int i) const;
    const std::string &Name() const;

    friend std::istream &operator>>(std::istream &is, Student &stu);
    friend std::istream &getline(std::istream &is, Student &stu);
    friend std::ostream &operator<<(std::ostream &os, const Student &stu);
};

#endif

程序清单14.5 studenti.cpp
#include <iostream>
#include "studenti.h"

using std::ostream;
using std::endl;
using std::istream;
using std::string;

double Student::Average() const
{
    if (ArrayDb::size() > 0)
    {
        return ArrayDb::sum() / ArrayDb::size();
    }
    else
    {
        return 0;
    }
}

const string &Student::Name() const
{
    return (const string &) * this;
}

double &Student::operator[](int i)
{
    return ArrayDb::operator[](i);
}

double Student::operator[] (int i) const
{
    return ArrayDb::operator[](i);
}
ostream &Student::arr_out(ostream &os) const
{
    int i;
    int lim = ArrayDb::size();
    if (lim > 0)
    {
        for (i = 0; i < lim; i++)
        {
            os << ArrayDb::operator[](i) << " ";
            if (i % 5 == 4)
            {
                os << endl;
            }
        }
        if (i % 5 != 0)
        {
            os << endl;
        }
    }
    else
    {
        os << " empty array ";
    }
    return os;
}
istream &operator >> (istream &is, Student &stu)
{
    is >> (string &)stu;
    return is;
}
istream &getline(istream &is, Student &stu)
{
    std::getline(is, (string &)stu, '\n');
    return is;
}
ostream &operator << (ostream &os, const Student &stu)
{
    os << "Scores for " << (const string &) stu << " :\n";
    stu.arr_out(os);
    return os;
}
包含使用成员对象名来调用成员对象方法，而私有继承使用基类名和作用域解析运算符来调用基类方法。

程序清单14.6 use_stui.cpp
#include <iostream>
#include "studenti.h"

using std::cin;
using std::cout;
using std::endl;

const int pupils = 3;
const int quizzes = 5;

void set(Student &sa, int n);

int main()
{
    Student ada[pupils] = { Student(quizzes), Student(quizzes), Student(quizzes) };
    int i;
    for (i = 0; i < pupils; i++)
    {
        set(ada[i], quizzes);
    }
    cout << endl;
    cout << "Student List:\n";
    for (i = 0; i < pupils; ++i)
    {
        cout << ada[i].Name() << endl;
    }
    cout << endl;
    cout << "Results:\n";
    for (i = 0; i < pupils; i++)
    {
        cout << ada[i];
        cout << "average: " << ada[i].Average() << endl;
        cout << endl;
    }
    cout << "Done.\n";

    return 0;
}

void set(Student &sa, int n)
{
    cout << "Please enter the student's name: ";
    getline(cin, sa);
    cout << "Please enter " << n << " quiz scores :\n";
    for (int i = 0; i < n; i++)
    {
        cin >> sa[i];
    }
    while (cin.get() != '\n')
    {
        continue;
    }
}
显示结果如下
Please enter the student's name: Mike Pence
Please enter 5 quiz scores :
3.8 3.8 3.9 3.9 3.9
Please enter the student's name: Peter Smith
Please enter 5 quiz scores :
4.1 4.2 4.3 4.8 4.9
Please enter the student's name: Hello World
Please enter 5 quiz scores :
4.1 3.9 3.9 3.8 4.5

Student List:
Mike Pence
Peter Smith
Hello World

Results:
Scores for Mike Pence :
3.8 3.8 3.9 3.9 3.9
average: 3.86

Scores for Peter Smith :
4.1 4.2 4.3 4.8 4.9
average: 4.46

Scores for Hello World :
4.1 3.9 3.9 3.8 4.5
average: 4.04

Done.

大多数C++程序员倾向于使用包含来建立has-a关系，而不选择使用私有继承。
首先，它易于理解。类声明中包含表示被包含类的显式命名对象，代码可以通过名称引用这些对象，而使用继承将使关系更抽象。
其次，继承会引起很多问题，尤其从多个基类继承时，可能必须处理很多问题，
如包含同名方法的独立的基类或共享祖先的独立基类。总之，使用包含不太可能遇到这样的麻烦。
另外，包含能够包括多个同类的子对象。如果某个类需要3个string对象，可以使用包含声明3个独立的string成员。
而继承则只能使用一个这样的对象（当对象都没有名称时，将难以区分）。
然而，私有继承所提供的特性确实比包含多。例如，假设类包含保护成员（可以是数据成员，也可以是成员函数），
则这样的成员在派生类中是可用的，但在继承层次结构外是不可用的。
如果使用组合将这样的类包含在另一个类中，则后者将不是派生类，而是位于继承层次结构之外，因此不能访问保护成员。
但通过继承得到的将是派生类，因此它能够访问保护成员。
另一种需要使用私有继承的情况是需要重新定义虚函数。派生类可以重新定义虚函数，但包含类不能。
使用私有继承，重新定义的函数将只能在类中使用，而不是公有的。
通常，应使用包含来建立has-a关系；如果新类需要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承。
保护继承是私有继承的变体。保护继承在列出基类时使用关键字protected。
使用保护继承时，基类的公有成员和保护成员都将成为派生类的保护成员。
和私有私有继承一样，基类的接口在派生类中也是可用的，但在继承层次结构之外是不可用的。
当从派生类派生出另一个类时，私有继承和保护继承之间的主要区别便呈现出来了。
使用私有继承时，第三代类将不能使用基类的接口，这是因为基类的公有方法在派生类中将变成私有方法；
使用保护继承时，基类的公有方法在第三代中将变成受保护的，因此第三代派生类可以使用它们。
隐式向上转换（implicit upcasting）意味着无需进行显式类型转换，就可以将基类指针或引用指向派生类对象。
表14.1总结了公有、私有和保护继承。
表14.1 各种继承方式
特征                           公有继承                                    保护继承                           私有继承
公有成员变成         派生类的公有成员                  派生类的保护成员                  派生类的私有成员
保护成员变成         派生类的保护成员                  派生类的保护成员                  派生类的私有成员
私有成员变成         只能通过基类接口访问         只能通过基类接口访问         只能通过基类接口访问
能否隐式向上转换         是                                    是（但只能在派生类中）                  否
使用保护派生或私有派生时，基类的公有成员将成为保护成员或私有成员。
假设要让基类的方法在派生类外面可用，方法之一是定义一个使用该基类方法的派生类方法。
另一种方法是使用一个using 声明（就像名称空间那样）来指出派生类可以使用特定的基类成员，即使采用的是私有派生。
class Student : private std::string, private std::valarray<double>
{
    // ...
public:
    using std::valarray<double>::min;
    using std::valarray<double>::max;
    // ...
};
上述using声明使得valarray<double>::min和valarray<double>::max可用，就像它们是Student的公有方法一样。
注意，using 声明只使用成员名――没有圆括号、函数特征标和返回类型。
例如，为使Student类可以使用valarray的operator[]（）方法，只需在Student类声明的公有部分包含下面的using声明：
using std::valarray<double>::operator[];
using声明只适用于继承，而不适用于包含。
多重继承描述的是有多个直接基类的类。与单继承一样，公有多重继承表示的也是is-a关系。
请注意，必须使用关键字public来限定每一个基类。这是因为，除非特别指出，否则编译器将认为是私有派生。
私有多重继承和保护多重继承可以表示has-a 关系。
多重继承可能会给程序员带来很多新问题。其中两个主要的问题是：
从两个不同的基类继承同名方法；
从两个或更多相关基类那里继承同一个类的多个实例。为解决这些问题，需要使用一些新规则和不同的语法。
因此，与使用单继承相比，使用多重继承更困难，也更容易出现问题。
程序清单14.7 worker0.h
#pragma once
#ifndef WORKER0_H_
#define WORKER0_H_
#include <string>

class Worker
{
private:
    std::string fullname;
    long id;
public:
    Worker() : fullname("no one"), id(0L) {}
    Worker(const std::string &s, long n) : fullname(s), id(n) {}
    virtual ~Worker() = 0;
    virtual void Set();
    virtual void Show() const;
};

class Waiter : public Worker
{
private:
    int panache;
public:
    Waiter() : Worker(), panache(0) {}
    Waiter(const std::string &s, long n, int p = 0) : Worker(s, n), panache(p) {}
    Waiter(const Worker &wk, int p = 0) : Worker(wk), panache(p) {}
    void Set();
    void Show() const;
};

class Singer : public Worker
{
protected:
    enum { other, alto, contralto, soprano, bass, baritone, tenor };
    enum { Vtypes = 7 };
private:
    static const char *pv[Vtypes];
    int voice;
public:
    Singer() : Worker(), voice(other) {}
    Singer(const std::string &s, long n, int v = other) : Worker(s, n), voice(v) {}
    Singer(const Worker &wk, int v = other) : Worker(wk), voice(v) {}
    void Set();
    void Show() const;
};

#endif

程序清单14.8 worker0.cpp
#include <iostream>
#include "worker0.h"

using std::cout;
using std::cin;
using std::endl;

Worker::~Worker() {}

void Worker::Set()
{
    cout << "Enter worker's name: ";
    std::getline(cin, fullname, '\n');
    cout << "Enter worker's ID: ";
    cin >> id;
    while (cin.get() != '\n')
    {
        continue;
    }
}

void Worker::Show() const
{
    cout << "Name: " << fullname << "\n";
    cout << "Employee ID: " << id << "\n";
}

void Waiter::Set()
{
    Worker::Set();
    cout << "Enter waiter's panache rating: ";
    cin >> panache;
    while (cin.get() != '\n')
    {
        continue;
    }
}

void Waiter::Show() const
{
    cout << "Category: waiter\n";
    Worker::Show();
    cout << "Panache rating: " << panache << "\n";
}

const char *Singer::pv[] = { "other", "alto", "contralto", "soprano", "bass", "baritone", "tenor" };

void Singer::Set()
{
    Worker::Set();
    cout << "Enter number for singer's vocal range:\n";
    int i;
    for (i = 0; i < Vtypes; i++)
    {
        cout << i << ":" << pv[i] << " ";
        if (i % 4 == 3)
        {
            cout << endl;
        }
    }
    if (i % 4 != 0)
    {
        cout << endl;
    }
    while (cin >> voice && (voice < 0 || voice >= Vtypes))
    {
        cout << "Please enter a value >= 0 and < " << Vtypes << endl;
    }
    cin.clear();
    while (cin.get() != '\n')
    {
        continue;
    }
}

void Singer::Show() const
{
    cout << "Category: singer\n";
    Worker::Show();
    cout << "Vocal range: " << pv[voice] << endl;
}

程序清单14.9 worktest.cpp
#include <iostream>
#include "worker0.h"

const int LIM = 4;

int main()
{
    Waiter bob("Bob Apple", 314L, 5);
    Singer bev("Beverly Hills", 522L, 3);
    Waiter w_temp;
    Singer s_temp;
    Worker *pw[LIM] = { &bob, &bev, &w_temp, &s_temp };
    int i;
    for (i = 2; i < LIM; i++)
    {
        pw[i]->Set();
    }
    for (i = 0; i < LIM; i++)
    {
        pw[i]->Show();
        std::cout << std::endl;
    }

    return 0;
}
显示结果如下
Enter worker's name: Mike Pence
Enter worker's ID: 111222
Enter waiter's panache rating: 8
Enter worker's name: Peter Smith
Enter worker's ID: 555666
Enter number for singer's vocal range:
0:other 1:alto 2:contralto 3:soprano
4:bass 5:baritone 6:tenor
3
Category: waiter
Name: Bob Apple
Employee ID: 314
Panache rating: 5

Category: singer
Name: Beverly Hills
Employee ID: 522
Vocal range: soprano

Category: waiter
Name: Mike Pence
Employee ID: 111222
Panache rating: 8

Category: singer
Name: Peter Smith
Employee ID: 555666
Vocal range: soprano

虚基类使得从多个类（它们的基类相同）派生出的对象只继承一个基类对象。
例如，通过在类声明中使用关键字virtual，可以使Worker被用作Singer和Waiter的虚基类（virtual和public的次序无关紧要）：
class Singer : virtual public Worker
{
    // ...
};
class Waiter : public virtual Worker
{
    // ...
};
然后，可以将SingingWaiter类定义为：
class SingingWaiter : public singer, public Waiter
{
    // ...
};
现在，SingingWaiter对象将只包含Worker对象的一个副本。
从本质上说，继承的Singer和Waiter对象共享一个Worker对象，而不是各自引入自己的Worker对象副本（请参见图14.5）。
因为SingingWaiter现在只包含了一个Worker子对象，所以可以使用多态。
class A
{
private:
    int a;
public:
    A (int n = 0) : a(n) {}
    // ...
};

class B : public A
{
private:
    int b;
public:
    B (int m = 0, int n = 0) : A(n), b(m) {}
    // ...
};

class C : public B
{
private:
    int c;
public:
    C (int q = 0, int m = 0, int n = 0) : B (m, n), c(q) {}
    // ...
};
C类的构造函数只能调用B类的构造函数，而B类的构造函数只能调用A类的构造函数。
这里，C类的构造函数使用值q，并将值m和n传递给B类的构造函数；而B类的构造函数使用值m，并将值n传递给A类的构造函数。
如果Worker是虚基类，则这种信息自动传递将不起作用。例如，对于下面的构造函数：
SingingWaiter (const Worker & wk, int p = 0, int v = Singer::other) : Waiter (wk, p), Singer (wk, v) {}   //flawed
存在的问题是，自动传递信息时，将通过2条不同的途径（Waiter 和Singer）将wk传递给Worker对象。
为避免这种冲突，C++在基类是虚的时，禁止信息通过中间类自动传递给基类。
因此，上述构造函数将初始化成员panache和voice，但wk参数中的信息将不会传递给子对象Waiter。
然而，编译器必须在构造派生对象之前构造基类对象组件；在上述情况下，编译器将使用Worker的默认构造函数。
如果不希望默认构造函数来构造虚基类对象，则需要显式地调用所需的基类构造函数。因此，构造函数应该是这样：
SingingWaiter (const Worker & wk, int p = 0, int v = Singer::other) : Worker(wk), Waiter (wk, p), Singer (wk, v) {}
上述代码将显式地调用构造函数Worker (const Worker &)。
请注意，这种用法是合法的，对于虚基类，必须这样做；但对于非虚基类，则是非法的。
如果类有间接虚基类，则除非只需使用该虚基类的默认构造函数，否则必须显式地调用该虚基类的某个构造函数。
除了修改类构造函数规则外，多重继承通常还要求调整其他代码。假设要在SingingWaiter类中扩展Show方法。
因为SingingWaiter对象没有新的数据成员，所以可能会认为它只需使用继承的方法即可。这引出了第一个问题。
假设没有在SingingWaiter类中重新定义Show方法，并试图使用SingingWaiter对象调用继承的Show方法：
SingingWaiter newhire ("Elise Hawks", 2005, 6, Singer::soprano);
newhire.Show();   //ambiguous
对于单继承，如果没有重新定义Show，则将使用最近祖先中的定义。
而在多重继承中，每个直接祖先都有一个Show函数，这使得上述调用是二义性的。
可以使用作用域解析运算符来澄清编程者的意图：
SingingWaiter newhire ("Elise Hawks", 2005, 6, Singer::soprano);
newhire.Singer::Show(); 
然而，更好的方法是在SingingWaiter中重新定义Show，并指出要使用哪个Show。
例如，如果希望SingingWaiter对象使用Singer版本的Show，则可以这样做：
void SingingWaiter::Show()
{
    Singer::Show();
}
对于单继承来说，让派生方法调用基类的方法是可以的。
然而，这种方式忽略了Waiter组件，可以通过同时调用Waiter版本的Show来补救。
然而，这将显示姓名和ID两次，因为Singer::Show()和Waiter::Show()都调用了Worker::Show()。
如何解决呢？一种办法是使用模块化方式，而不是递增方式，
即提供一个只显示Worker组件的方法和一个只显示Waiter组件或Singer组件（而不是Waiter和Worker组件）的方法。
然后，在SingngWater::Show()方法中将组件组合起来。例如，可以这样做：
void Worker::Data() const
{
    cout << "Name: " << fullname << "\n";
    cout << "Employee ID: " << id << "\n";
}
void Waiter::Data() const
{
    cout << "Panache rating: " << panache << "\n";
}
void Singer::Data() const
{
    cout << "Vocal range: " << pv[voice] << "\n";
}
void SingingWaiter::Data() const
{
    Singer::Data();
    Waiter::Data();
}
void SingingWaiter::Show() const
{
    cout << "Category: singing waiter\n";
    Worker::Data();
    Data();
}
另一种办法是将所有的数据组件都设置为保护的，而不是私有的，
不过使用保护方法（而不是保护数据）将可以更严格地控制对数据的访问。
程序清单14.10 workermi.h
#pragma once
#ifndef WORKERMI_H_
#define WORKERMI_H_
#include <string>

class Worker
{
private:
    std::string fullname;
    long id;
protected:
    virtual void Data() const;
    virtual void Get();
public:
    Worker() : fullname("no one"), id(0L) {}
    Worker(const std::string &s, long n) : fullname(s), id(n) {}
    virtual ~Worker() = 0;
    virtual void Set() = 0;
    virtual void Show() const = 0;
};

class Waiter : virtual public Worker
{
private:
    int panache;
protected:
    void Data() const;
    void Get();
public:
    Waiter() : Worker(), panache(0) {}
    Waiter(const std::string &s, long n, int p = 0) : Worker(s, n), panache(p) {}
    Waiter(const Worker &wk, int p = 0) : Worker(wk), panache(p) {}
    void Set();
    void Show() const;
};

class Singer : virtual public Worker
{
protected:
    enum
    {
        other, alto, contralto, soprano,
        bass, baritone, tenor
    };
    enum { Vtypes = 7 };
    void Data() const;
    void Get();
private:
    static const char *pv[Vtypes];
    int voice;
public:
    Singer() : Worker(), voice(other) {}
    Singer(const std::string &s, long n, int v = other) : Worker(s, n), voice(v) {}
    Singer(const Worker &wk, int v = other) : Worker(wk), voice(v) {}
    void Set();
    void Show() const;
};
class SingingWaiter : public Singer, public Waiter
{
protected:
    void Data() const;
    void Get();
public:
    SingingWaiter() {}
    SingingWaiter(const std::string &s, long n, int p = 0, int v = Singer::other) : Worker(s, n), Waiter(s, n, p), Singer(s, n, v) {}
    SingingWaiter(const Worker &wk, int p = 0, int v = Singer::other) : Worker(wk), Waiter(wk, p), Singer(wk, v) {}
    SingingWaiter(const Waiter &wt, int v = Singer::other) : Worker(wt), Waiter(wt), Singer(wt, v) {}
    SingingWaiter(const Singer &wt, int p = 0) : Worker(wt), Waiter(wt, p), Singer(wt) {}
    void Set();
    void Show() const;
};

#endif

程序清单14.11 workermi.cpp
#include <iostream>
#include "workermi.h"

using std::cout;
using std::cin;
using std::endl;

Worker::~Worker() { }

void Worker::Data() const
{
    cout << "Name: " << fullname << endl;
    cout << "Employee ID: " << id << endl;
}

void Worker::Get()
{
    std::getline(cin, fullname, '\n');
    cout << "Enter worker's ID: ";
    cin >> id;
    while (cin.get() != '\n')
    {
        continue;
    }
}

void Waiter::Set()
{
    cout << "Enter waiter's name: ";
    Worker::Get();
    Get();
}
void Waiter::Show() const
{
    cout << "Category: waiter\n";
    Worker::Data();
    Data();
}
void Waiter::Data() const
{
    cout << "Panache rating: " << panache << endl;
}
void Waiter::Get()
{
    cout << "Enter waiter's panache rating: ";
    cin >> panache;
    while (cin.get() != '\n')
    {
        continue;
    }
}
const char *Singer::pv[Singer::Vtypes] = { "other", "alto", "contralto", "soprano", "bass", "baritone", "tenor" };

void Singer::Set()
{
    cout << "Enter singer's name: ";
    Worker::Get();
    Get();
}

void Singer::Show() const
{
    cout << "Category: singer\n";
    Worker::Data();
    Data();
}
void Singer::Data() const
{
    cout << "Vocal range: " << pv[voice] << endl;
}
void Singer::Get()
{
    cout << "Enter number for singer's vocal range:\n";
    int i;
    for (i = 0; i < Vtypes; i++)
    {
        cout << i << ": " << pv[i] << "   ";
        if (i % 4 == 3)
        {
            cout << endl;
        }
    }
    if (i % 4 != 0)
    {
        cout << '\n';
    }
    while (cin >> voice && (voice < 0 || voice >= Vtypes))
    {
        cout << "Please enter a value >= 0 and < " << Vtypes << endl;
    }
    cin.clear();
    while (cin.get() != '\n')
    {
        continue;
    }
}
void SingingWaiter::Data() const
{
    Singer::Data();
    Waiter::Data();
}
void SingingWaiter::Get()
{
    Waiter::Get();
    Singer::Get();
}
void SingingWaiter::Set()
{
    cout << "Enter singing waiter's name: ";
    Worker::Get();
    Get();
}
void SingingWaiter::Show() const
{
    cout << "Category: singing waiter\n";
    Worker::Data();
    Data();
}

程序清单14.12 workmitest.cpp
#include <iostream>
#include <cstring>
#include "workermi.h"

const int SIZE = 5;

int main()
{
    using std::cin;
    using std::cout;
    using std::endl;
    using std::strchr;

    Worker *lolas[SIZE];

    int ct;
    for (ct = 0; ct < SIZE; ct++)
    {
        char choice;
        cout << "Enter the employee category:\n"
             << "w: waiter  s: singer  "
             << "t: singing waiter  q: quit\n";
        cin >> choice;
        while (cin.get() != '\n')
        {
            continue;
        }
        while (strchr("wstq", choice) == nullptr)
        {
            cout << "Please enter a w, s, t, or q: ";
            cin >> choice;
            while (cin.get() != '\n')
            {
                continue;
            }
        }
        if (choice == 'q')
        {
            break;
        }
        switch (choice)
        {
        case 'w':
            lolas[ct] = new Waiter;
            break;
        case 's':
            lolas[ct] = new Singer;
            break;
        case 't':
            lolas[ct] = new SingingWaiter;
            break;
        default :
            lolas[ct] = new SingingWaiter;
            break;
        }
        lolas[ct]->Set();
    }

    cout << "\nHere is your staff:\n";
    int i;
    for (i = 0; i < ct; i++)
    {
        lolas[i]->Show();
        cout << endl;
    }
    for (i = 0; i < ct; i++)
    {
        delete lolas[i];
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
w
Enter waiter's name: Mike Pence
Enter worker's ID: 111222
Enter waiter's panache rating: 8
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
s
Enter singer's name: Peter Smith
Enter worker's ID: 555666
Enter number for singer's vocal range:
0: other   1: alto   2: contralto   3: soprano
4: bass   5: baritone   6: tenor
5
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
t
Enter singing waiter's name: Hello World
Enter worker's ID: 777888
Enter waiter's panache rating: 9
Enter number for singer's vocal range:
0: other   1: alto   2: contralto   3: soprano
4: bass   5: baritone   6: tenor
6
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
w
Enter waiter's name: Apple
Enter worker's ID: 123123
Enter waiter's panache rating: 5
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
t
Enter singing waiter's name: Orange
Enter worker's ID: 567567
Enter waiter's panache rating: 8
Enter number for singer's vocal range:
0: other   1: alto   2: contralto   3: soprano
4: bass   5: baritone   6: tenor
3

Here is your staff:
Category: waiter
Name: Mike Pence
Employee ID: 111222
Panache rating: 8

Category: singer
Name: Peter Smith
Employee ID: 555666
Vocal range: baritone

Category: singing waiter
Name: Hello World
Employee ID: 777888
Vocal range: tenor
Panache rating: 9

Category: waiter
Name: Apple
Employee ID: 123123
Panache rating: 5

Category: singing waiter
Name: Orange
Employee ID: 567567
Vocal range: soprano
Panache rating: 8

Done.

再来看一下通过多种途径继承一个基类的派生类的情况。如果基类是虚基类，派生类将包含基类的一个子对象；如果基类不是虚基类，派生类将包含多个子对象。
当虚基类和非虚基类混合时，情况将如何呢？
例如，假设类B被用作类C和D的虚基类，同时被用作类X和Y的非虚基类，而类M是从C、D、X和Y派生而来的。
在这种情况下，类M从虚派生祖先（即类C和D）那里共继承了一个B类子对象，并从每一个非虚派生祖先（即类X和Y）分别继承了一个B类子对象。
因此，它包含三个B类子对象。当类通过多条虚途径和非虚途径继承某个特定的基类时，
该类将包含一个表示所有的虚途径的基类子对象和分别表示各条非虚途径的多个基类子对象。
使用虚基类将改变C++解析二义性的方式。使用非虚基类时，规则很简单。
如果类从不同的类那里继承了两个或更多的同名成员（数据或方法），
则使用该成员名时，如果没有用类名进行限定，将导致二义性。
但如果使用的是虚基类，则这样做不一定会导致二义性。在这种情况下，如果某个名称优先于（dominates）其他所有名称，
则使用它时，即便不使用限定符，也不会导致二义性。
那么，一个成员名如何优先于另一个成员名呢？派生类中的名称优先于直接或间接祖先类中的相同名称。例如，在下面的定义中：
class B
{
public:
    short q();
    // ...
};

class C : virtual public B
{
public :
    long q();
    int omg();
    // ...
};
class D : public C
{
    // ...
}
class E: virtual public B
{
private:
    int omg();
    // ...
};
class F: public D, public E
{
    // ...
};
类C中的q定义优先于类B中的q定义，因为类C是从类B派生而来的。因此，F中的方法可以使用q来表示C::q。
另一方面，任何一个omg定义都不优先于其他omg定义，因为C和E都不是对方的基类。
所以，在F中使用非限定的omg将导致二义性。
虚二义性规则与访问规则无关，也就是说，即使E::omg是私有的，不能在F类中直接访问，但使用omg仍将导致二义性。
同样，即使C::q是私有的，它也将优先于B:q。
在这种情况下，可以在类F中调用B:q，但如果不限定q，则将意味着要调用不可访问的C::q。
首先复习一下不使用虚基类的多重继承，这种形式的多重继承不会引入新的规则。
然而，如果一个类从两个不同的类那里继承了两个同名的成员，则需要在派生类中使用类限定符来区分它们。
否则，编译器将指出二义性。
如果一个类通过多种途径继承了一个非虚基类，则该类从每种途径分别继承非虚基类的一个实例。
在某些情况下，这可能正是所希望的，但通常情况下，多个基类实例会有问题。
接下来看一看使用虚基类的多重继承。当派生类使用关键字virtual来指示派生时，基类就成为虚基类。
主要变化（同时也是使用虚基类的原因）是，从虚基类的一个或多个实例派生而来的类将只继承了一个基类对象。
为实现这种特性，必须满足其他要求：有间接虚基类的派生类包含直接调用间接基类构造函数的构造函数，
这对于间接非虚基类来说是非法的；
通过优先规则解决名称二义性。
正如您看到的，多重继承会增加编程的复杂程度。然而，这种复杂性主要是由于派生类通过多条途径继承同一个基类引起的。
避免这种情况后，唯一需要注意的是，在必要时对继承的名称进行限定。
继承（公有、私有或保护）和包含并不总是能够满足重用代码的需要。
例如，Stack类（参见第10章）和Queue类（参见第12章）都是容器类（container class），容器类设计用来存储其他对象或数据类型。
例如，第10章的Stack类设计用于存储unsigned long值。可以定义专门用于存储double值或string对象的Stack类，
除了保存的对象类型不同外，这两种Stack类的代码是相同的。然而，与其编写新的类声明，不如编写一个泛型（即独立于类型的）栈，
然后将具体的类型作为参数传递给这个类。这样就可以使用通用的代码生成存储不同类型值的栈。
第10章的Stack示例使用typedef处理这种需求。然而，这种方法有两个缺点：首先，每次修改类型时都需要编辑头文件；
其次，在每个程序中只能使用这种技术生成一种栈，即不能让typedef同时代表两种不同的类型，因此不能使用这种方法在同一个程序中同时定义int栈和string栈。
C++的类模板为生成通用的类声明提供了一种更好的方法。模板提供参数化（parameterized）类型，即能够将类型名作为参数传递给接收方来建立类或函数。
例如，将类型名int传递给Queue模板，可以让编译器构造一个对int进行排队的Queue类。
C++库提供了多个模板类，本章前面使用了模板类valarray，第4章介绍了模板类vector和array，
而第16章将讨论的C++标准模板库（STL）提供了几个功能强大而灵活的容器类模板实现。
采用模板时，将使用模板定义替换Stack声明，使用模板成员函数替换Stack的成员函数。
和模板函数一样，模板类以下面这样的代码开头：
template <typename T>
关键字template告诉编译器，将要定义一个模板。尖括号中的内容相当于函数的参数列表。
可以使用自己的泛型名代替T，其命名规则与其他标识符相同。当模板被调用时，T将被具体的类型值（如int或string）取代。
在模板定义中，可以使用泛型名来标识要存储在栈中的类型。
同样，可以使用模板成员函数替换原有类的类方法。每个函数头都将以相同的模板声明打头：
template <typename T>
如果在类模板声明中定义了方法（内联定义），则可以省略模板前缀和类限定符。
这些模板不是类和成员函数定义，它们是C++编译器指令，说明了如何生成类和成员函数定义。
模板的具体实现被称为实例化（intantiation）或具体化（specialization），不能将模板成员函数放在独立的实现文件中
由于模板不是函数，它们不能单独编译。模板必须与特定的模板实例化请求一起使用。
为此，最简单的方法是将所有模板信息放在一个头文件中，并在要使用这些模板的文件中包含该头文件。
程序清单14.13 stacktp.h
#ifndef STACKTP_H_
#define STACKTP_H_

template <typename Type>
class Stack
{
private:
    enum { MAX = 10 };
    Type items[MAX];
    int top;
public:
    Stack();
    bool isempty();
    bool isfull();
    bool push(const Type &item);
    bool pop(Type &item);
};

template <typename Type>
Stack<Type>::Stack()
{
    top = 0;
}

template <typename Type>
bool Stack<Type>::isempty()
{
    return top == 0;
}

template <typename Type>
bool Stack<Type>::isfull()
{
    return top == MAX;
}

template <typename Type>
bool Stack<Type>::push(const Type &item)
{
    if (top < MAX)
    {
        items[top++] = item;
        return true;
    }
    else
    {
        return false;
    }
}

template <class Type>
bool Stack<Type>::pop(Type &item)
{
    if (top > 0)
    {
        item = items[--top];
        return true;
    }
    else
    {
        return false;
    }
}

#endif
仅在程序包含模板并不能生成模板类，而必须请求实例化。为此，需要声明一个类型为模板类的对象，方法是使用所需的具体类型替换泛型名。
例如，下面的代码创建两个栈，一个用于存储int，另一个用于存储 string 对象
Stack<int> kernels；
Stack<string> colonels;
看到上述声明后，编译器将按Stack<Type>模板来生成两个独立的类声明和两组独立的类方法。
类声明Stack<int>将使用int替换模板中所有的Type，而类声明Stack<string>将用string替换Type。
当然，使用的算法必须与类型一致。例如，Stack类假设可以将一个项目赋给另一个项目。
这种假设对于基本类型、结构和类来说是成立的（除非将赋值运算符设置为私有的），但对于数组则不成立。
泛型标识符Type称为类型参数（type parameter），这意味着它们类似于变量，但赋给它们的不能是数字，而只能是类型。
因此，在kernel声明中，类型参数Type的值为int。注意，必须显式地提供所需的类型，这与常规的函数模板是不同的，
因为编译器可以根据函数的参数类型来确定要生成哪种函数。
程序清单14.14 stacktem.cpp
#include <iostream>
#include <string>
#include <cctype>
#include "stacktp.h"

using std::cin;
using std::cout;


int main()
{
    Stack<std::string> st;
    char ch;
    std::string po;
    cout << "Please enter A to add a purchase order,\n"
         << "P to process a PO, or Q to quit.\n";
    while (cin >> ch && std::toupper(ch) != 'Q')
    {
        while (cin.get() != '\n')
        {
            continue;
        }
        if (!std::isalpha(ch))
        {
            cout << "Please enter A, P, Q\n";
            continue;
        }
        switch (ch)
        {
        case 'A':
        case 'a':
            cout << "Enter a PO number to add: ";
            std::getline(cin, po, '\n');
            if (st.isfull())
            {
                cout << "stack already full\n";
            }
            else
            {
                st.push(po);
            }
            break;
        case 'P':
        case 'p':
            if (st.isempty())
            {
                cout << "stack already empty\n";
            }
            else
            {
                st.pop(po);
                cout << "PO #" << po << " popped\n";
            }
            break;
        default :
            std::cout << "Please enter A, P, Q\n";
            continue;
            break;
        }
        cout << "Please enter A to add a purchase order,\n"
             << "P to process a PO, or Q to quit.\n";
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
A
Enter a PO number to add: abcdefg
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
A
Enter a PO number to add: hijklmn
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
A
Enter a PO number to add: opqrst
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
A
Enter a PO number to add: uvwxyz
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
P
PO #uvwxyz popped
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
P
PO #opqrst popped
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
P
PO #hijklmn popped
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
A
Enter a PO number to add: 1234567
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
P
PO #1234567 popped
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
P
PO #abcdefg popped
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
P
stack already empty
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
q
Done.

程序清单14.15 stcktp1.h
#ifndef STCKTP1_H_
#define STCKTP1_H_

template <typename Type>
class Stack
{
private:
    enum { SIZE = 10 };
    int stacksize;
    Type *items;
    int top;
public:
    explicit Stack(int ss = SIZE);
    Stack(const Stack &st);
    ~Stack()
    {
        delete[] items;
    }
    bool isempty()
    {
        return top == 0;
    }
    bool isfull()
    {
        return top == stacksize;
    }
    bool push(const Type &item);
    bool pop(Type &item);
    Stack &operator=(const Stack &st);
};

template <typename Type>
Stack<Type>::Stack(int ss) : stacksize(ss), top(0)
{
    items = new Type[stacksize];
}

template <typename Type>
Stack<Type>::Stack(const Stack &st)
{
    stacksize = st.stacksize;
    top = st.top;
    items = new Type[stacksize];
    for (int i = 0; i < top; i++)
    {
        items[i] = st.items[i];
    }
}

template <typename Type>
bool Stack<Type>::push(const Type &item)
{
    if (top < stacksize)
    {
        items[top++] = item;
        return true;
    }
    else
    {
        return false;
    }
}

template <typename Type>
bool Stack<Type>::pop(Type &item)
{
    if (top > 0)
    {
        item = items[--top];
        return true;
    }
    else
    {
        return false;
    }
}

template <typename Type>
Stack<Type> &Stack<Type>::operator=(const Stack<Type> &st)
{
    if (this == &st)
    {
        return *this;
    }
    delete[] items;
    stacksize = st.stacksize;
    top = st.top;
    items = new Type[stacksize];
    for (int i = 0; i < top; i++)
    {
        items[i] = st.items[i];
    }
    return *this;
}

#endif

程序清单14.16 stckoptr1.cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
#include "stcktp1.h"

const int Num = 10;

int main()
{
    std::srand(std::time(nullptr));
    std::cout << "Please enter stack size: ";
    int stacksize = 0;
    std::cin >> stacksize;

    Stack<const char *> st(stacksize);

    const char *in[Num] =
    {
        " 1: Hank Gilgamesh", " 2: Kiki Ishtar",
        " 3: Betty Rocker", " 4: Ian Flagranti",
        " 5: Wolfgang Kibble", " 6: Portia Koop",
        " 7: Joy Almondo", " 8: Xaverie Paprika",
        " 9: Juan Moore", "10: Misha Mache"
    };

    const char *out[Num];

    int processed = 0;
    int nextin = 0;

    while (processed < Num)
    {
        if (st.isempty())
        {
            st.push(in[nextin++]);
        }
        else if (st.isfull())
        {
            st.pop(out[processed++]);
        }
        else if (std::rand() % 2 && nextin < Num)
        {
            st.push(in[nextin++]);
        }
        else
        {
            st.pop(out[processed++]);
        }
    }
    for (int i = 0; i < Num; i++)
    {
        std::cout << out[i] << std::endl;
    }

    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Please enter stack size: 5
 2: Kiki Ishtar
 5: Wolfgang Kibble
 4: Ian Flagranti
 3: Betty Rocker
 6: Portia Koop
 7: Joy Almondo
 1: Hank Gilgamesh
 8: Xaverie Paprika
 9: Juan Moore
10: Misha Mache
Done.

Please enter stack size: 6
 2: Kiki Ishtar
 1: Hank Gilgamesh
 8: Xaverie Paprika
 7: Joy Almondo
 6: Portia Koop
10: Misha Mache
 9: Juan Moore
 5: Wolfgang Kibble
 4: Ian Flagranti
 3: Betty Rocker
Done.

Please enter stack size: 7
 2: Kiki Ishtar
 3: Betty Rocker
 1: Hank Gilgamesh
 4: Ian Flagranti
 5: Wolfgang Kibble
 7: Joy Almondo
 9: Juan Moore
10: Misha Mache
 8: Xaverie Paprika
 6: Portia Koop
Done.

程序清单14.17 arraytp.h
#ifndef ARRAYTP_H_
#define ARRAYTP_H_

#include <cstdlib>

template <typename T, int n>
class ArrayTP
{
private:
    T ar[n];
public:
    ArrayTP() {};
    explicit ArrayTP(const T &v);
    virtual T &operator[](int i);
    virtual T operator[](int i) const;
};

template <typename T, int n>
ArrayTP<T, n>::ArrayTP(const T &v)
{
    for (int i = 0; i < n; i++)
    {
        ar[i] = v;
    }
}

template <typename T, int n>
T &ArrayTP<T, n>::operator[](int i)
{
    if (i < 0 || i >= n)
    {
        std::cerr << "Error in array limits: " << i << " is out of range\n";
        std::exit(EXIT_FAILURE);
    }
    return ar[i];
}

template <typename T, int n>
T ArrayTP<T, n>::operator[](int i) const
{
    if (i < 0 || i >= n)
    {
        std::cerr << "Error in array limits: " << i << " is out of range\n";
        std::exit(EXIT_FAILURE);
    }
    return ar[i];
}

#endif

typename指出T为类型参数，int指出n的类型为int。
这种参数（指定特殊的类型而不是用作泛型名）称为非类型（non-type）或表达式（expression）参数。
表达式参数有一些限制。表达式参数可以是整型、枚举、引用或指针。
另外，模板代码不能修改参数的值，也不能使用参数的地址。所以，在ArrayTP模板中不能使用诸如n++和&n等表达式。
另外，实例化模板时，用作表达式参数的值必须是常量表达式。
与Stack中使用的构造函数方法相比，这种改变数组大小的方法有一个优点。
构造函数方法使用的是通过new和delete管理的堆内存，而表达式参数方法使用的是为自动变量维护的内存栈。
这样，执行速度将更快，尤其是在使用了很多小型数组时。
表达式参数方法的主要缺点是，每种数组大小都将生成自己的模板。
另一个区别是，构造函数方法更通用，这是因为数组大小是作为类成员存储在定义中的。
可以将用于常规类的技术用于模板类。模板类可用作基类，也可用作组件类，还可用作其他模板的类型参数。可以递归使用模板。
例如，对于前面的数组模板定义，可以这样使用：
AггауTp<ArrayтP<int, 5>, 10> twodee;
这使得twodee是一个包含10个元素的数组，其中每个元素都是一个包含5个int元素的数组。与之等价的常规数组声明如下：
int twodee [10][5];
程序清单14.18 twod.cpp
#include <iostream>
#include "arraytp.h"

int main()
{
    using std::cout;
    using std::endl;
    ArrayTP<int, 10> sums;
    ArrayTP<double, 10> aves;
    ArrayTP< ArrayTP<int, 5>, 10> twodee;

    int i, j;

    for (i = 0; i < 10; i++)
    {
        sums[i] = 0;
        for (j = 0; j < 5; j++)
        {
            twodee[i][j] = (i + 1) * (j + 1);
            sums[i] += twodee[i][j];
        }
        aves[i] = (double)sums[i] / 5;
    }
    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 5; j++)
        {
            cout.width(2);
            cout << twodee[i][j] << ' ';
        }
        cout << ": sum = ";
        cout.width(3);
        cout << sums[i] << ", average = " << aves[i] << endl;
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
 1  2  3  4  5 : sum =  15, average = 3
 2  4  6  8 10 : sum =  30, average = 6
 3  6  9 12 15 : sum =  45, average = 9
 4  8 12 16 20 : sum =  60, average = 12
 5 10 15 20 25 : sum =  75, average = 15
 6 12 18 24 30 : sum =  90, average = 18
 7 14 21 28 35 : sum = 105, average = 21
 8 16 24 32 40 : sum = 120, average = 24
 9 18 27 36 45 : sum = 135, average = 27
10 20 30 40 50 : sum = 150, average = 30
Done.

程序清单14.19 pairs.cpp
#include <iostream>
#include <string>

template <typename T1, typename T2>
class Pair
{
private:
    T1 a;
    T2 b;
public:
    T1 &first();
    T2 &second();
    T1 first() const
    {
        return a;
    }
    T2 second() const
    {
        return b;
    }
    Pair(const T1 &aval, const T2 &bval) : a(aval), b(bval) { }
    Pair() {}
};

template<typename T1, typename T2>
T1 &Pair<T1, T2>::first()
{
    return a;
}

template<typename T1, typename T2>
T2 &Pair<T1, T2>::second()
{
    return b;
}

int main()
{
    using std::cout;
    using std::endl;
    using std::string;
    Pair<string, int> ratings[4] =
    {
        Pair<string, int>("The Purpled Duck", 5),
        Pair<string, int>("Jaquie's Frisco Al Fresco", 4),
        Pair<string, int>("Cafe Souffle", 5),
        Pair<string, int>("Bertie's Eats", 3)
    };

    int joints = sizeof(ratings) / sizeof(Pair<string, int>);
    cout << "Rating:\t Eatery\n";
    for (int i = 0; i < joints; i++)
    {
        cout << ratings[i].second() << ":\t "
             << ratings[i].first() << endl;
    }
    cout << "Oops! Revised rating:\n";
    ratings[3].first() = "Bertie's Fab Eats";
    ratings[3].second() = 6;
    cout << ratings[3].second() << ":\t "
         << ratings[3].first() << endl;

    return 0;
}
显示结果如下
Rating:  Eatery
5:       The Purpled Duck
4:       Jaquie's Frisco Al Fresco
5:       Cafe Souffle
3:       Bertie's Eats
Oops! Revised rating:
6:       Bertie's Fab Eats

类模板的另一项新特性是，可以为类型参数提供默认值：
template <typename T1, typename T2 = int>
class Topo
{
    // ...
};
这样，如果省略T2的值，编译器将使用int。
虽然可以为类模板类型参数提供默认值，但不能为函数模板参数提供默认值。
然而，可以为非类型参数提供默认值，这对于类模板和函数模板都是适用的。
类模板与函数模板很相似，因为可以有隐式实例化、显式实例化和显式具体化。
模板以泛型的方式描述类，使用时以具体的类型生成类声明。
1.隐式实例化
声明一个或多个对象，指出所需的类型，而编译器使用通用模板提供的内容生成具体的类定义。
ArrayTP<int, 100> stuff;   //implicit instantiation
编译器在需要对象之前，不会生成类的隐式实例化：
ArrayTP<double, 30> * pt;   //a pointer, no object needed yet
pt = new ArrayTP<double, 30>;   //now an object is needed
第二条语句导致编译器生成类定义，并根据该定义创建一个对象。
2.显式实例化
当使用关键字template并指出所需类型来声明类时，编译器将生成类声明的显式实例化（explici instantiation），
声明必须位于模板定义所在的名称空间中。例如，下面的声明将ArrayTP<string, 100>声明为一个类：
template class ArrayTP<string, 100>;   //generate ArrayTP<string, 100> class
在这种情况下，虽然没有创建或提及类对象，编译器也将生成类声明（包括方法定义）。
和隐式实例化样，也将根据通用模板来生成具体化。
3.显式具体化
显式具体化（explicit specialization）是特定类型（用于替换模板中的泛型）的定义。
有时候，可能需要在为特殊类型实例化时，对模板进行修改，使其行为不同。在这种情况下，可以创建显式具体化。
例如假设已经为用于表示排好序数组的类（元素在加入时被排序）定义了一个模板：
template <typename T>
class SortedArray
{
   // ...
};
假设模板使用>运算符来对值进行比较。对于数字，这管用；如果T表示一种类，则只要定义了T::operator>()方法，这也管用；
但如果T是由const char*表示的字符串，这将不管用。实际上，模板倒是可以正常工作，但字符串将按地址排序。
这要求类定义使用strmp，而不是>来对值进行比较。
在这种情况下，可以提供一个显式模板具体化，这将采用为具体类型定义的模板，而不是为泛型定义的模板。
当具体化模板和通用模板都与实例化请求匹配时，编译器将使用具体化版本。
具体化类模板定义的格式如下：
template <> class Classname <specialized-type-name>
{
    // ...
};
要使用新的表示法提供一个专供const char*类型使用的SortedArray模板，可以使用类似于下面的代码
template <> class SortedArray<const char *>
{
    // ...
};
其中的实现代码将使用strcmp（而不是>）来比较字符串。现在，当请求const char *类型的SortedArray模板时，
编译器将使用上述专用的定义，而不是通用的模板定义：
SortedArray<int> scores;   //use general definition
SortedArray<const char *> dates;   //use specialized definition
4.部分具体化
C++还允许部分具体化（partial specialization），即部分限制模板的通用性。
例如，部分具体化可以给类型参数之一指定具体的类型：
//general template
template <typename T1, typename T2> class Pair
{
    // ...
};
//specialization with T2 set to int
template <typename T1> class Pair<T1, int>
{
    // ...
};
关键字template后面的声明的是没有被具体化的类型参数。因此，上述第二个声明将T2具体化为int，但T1保持不变。
注意，如果指定所有的类型，则<>内将为空，这将导致显式具体化：
//specialization with T1 and T2 set to int
template <> class Pair<int, int>
{
    // ...
};
如果有多个模板可供选择，编译器将使用具体化程度最高的模板。给定上述三个模板，情况如下：
Pair<double，double> p1;   //use general Pair template
Pair<double, int> p2;   //use Pair<T1, int> partial specialization
Pair<int, int> p3;   //use Pair<int, int> explicit specialization
也可以通过为指针提供特殊版本来部分具体化现有的模板
template <typename T>   //general version
class Feeb
{
    // ...
};
template <typename T*>   //pointer partial specialization
class Feeb
{
    // ...
};
如果提供的类型不是指针，则编译器将使用通用版本；如果提供的是指针，则编译器将使用指针具体化版本：
Feeb<char> fb1;   //use general Feeb template, T is char
Feeb<char *> fb2;   //use Feeb T* specialization, T is char
如果没有进行部分具体化，则第二个声明将使用通用模板，将T转换为char*类型。
如果进行了部分具体化，则第二个声明将使用具体化模板，将T转换为char。
部分具体化特性使得能够设置各种限制。例如，可以这样做：
//general template
template <typename T1, typename T2, typename T3> class Trio
{
    // ...
};
//specialization with T3 set to T2
template <typename T1, typename T2> class Trio<T1, T2, T2>
{
    // ...
};
//specialization with T3 and T2 set to T1*
template <class T1> class Trio<T1, T1*, T1*>
{
    // ...
};
给定上述声明，编译器将作出如下选择：
Trio<int, short, char > t1;   //use general template
Trio<int, short> t2;   //use Trio<T1, T2, T2>
Trio<char, char *, char *> t3;   //use Trio<T1, T1 *, T1 *>
14.4.7成员模板
模板可用作结构、类或模板类的成员。要完全实现STL的设计，必须使用这项特性。
程序清单14.20 tempmemb.cpp
#include <iostream>
#include <string>

using std::cout;
using std::endl;


template <typename T>
class beta
{
private:
    template <typename V>
    class hold
    {
    private:
        V val;
    public:
        hold(V v = 0) : val(v) {}
        void show() const
        {
            cout << val << endl;
        }
        V Value() const
        {
            return val;
        }
    };
    hold<T> q;
    hold<int> n;
public:
    beta(T t, int i) : q(t), n(i) {}
    template<typename U>
    U blab(U u, T t)
    {
        return (n.Value() + q.Value()) * u / t;
    }
    void Show() const
    {
        q.show();
        n.show();
    }
};

int main()
{
    beta<double> guy(3.5, 3);
    cout << "T was set to double\n";
    guy.Show();
    cout << "V was set to T, which is double, then V was set to int\n";
    cout << guy.blab(10, 2.3) << endl;
    cout << "U was set to int\n";
    cout << guy.blab(10.0, 2.3) << endl;
    cout << "U was set to double\n";
    cout << "Done.\n";

    return 0;
}
显示结果如下
T was set to double
3.5
3
V was set to T, which is double, then V was set to int
28
U was set to int
28.2609
U was set to double
Done.

模板可以包含类型参数（如typename T）和非类型参数（如int n）。
模板还可以包含本身就是模板的参数，这种参数是模板新增的特性，用于实现STL。
程序清单14.21 tempparm.cpp
#include <iostream>
#include "stacktp.h"

template <template <typename T> class Thing>
class Crab
{
private:
    Thing<int> s1;
    Thing<double> s2;
public:
    Crab() {};
    bool push(int a, double x)
    {
        return s1.push(a) && s2.push(x);
    }
    bool pop(int &a, double &x)
    {
        return s1.pop(a) && s2.pop(x);
    }
};

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    Crab<Stack> nebula;
    int ni;
    double nb;
    cout << "Enter int double pairs, such as 4 3.5 (0 0 to end):\n";
    while (cin >> ni && cin >> nb && ni > 0 && nb > 0)
    {
        if (!nebula.push(ni, nb))
        {
            break;
        }
    }

    while (nebula.pop(ni, nb))
    {
        cout << ni << ", " << nb << endl;
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Enter int double pairs, such as 4 3.5 (0 0 to end):
3 3.5
5 5.1
6 6.6
0 0
6, 6.6
5, 5.1
3, 3.5
Done.

可以混合使用模板参数和常规参数，例如，Crab类的声明可以像下面这样打头：
template <template <typename T> class Thing, typename U, typename V>
class crab
{
private:
Thing<U> s1;
Thing<V> s2;
};
现在，成员s1和s2可存储的数据类型为泛型。这要求将程序中nebula的声明修改成下面这样：
Crab<Stack, int, double> nebula;   //T=stack, U=int, V=double
模板参数T表示一种模板类型；而类型参数U和V表示非模板类型。
模板类声明也可以有友元。模板的友元分3类：
非模板友元
约束（bound）模板友元，即友元的类型取决于类被实例化时的类型；
非约束（unbound）模板友元，即友元的所有具体化都是类的每一个具体化的友元。
template <typename T>
class HasFriend
{
public:
    friend void counts();
};
上述声明使counts函数成为模板所有实例化的友元。例如，它将是类hasFriend<int>和HasFriend<string>的友元。
counts函数不是通过对象调用的（它是友元，不是成员函数）；也没有对象参数，那公它如何访问HasFriend 对象呢？
它可以访问全局对象；可以使用全局指针访问非全局对象；可以创建自己的对象；可以访问独立于对象的模板类的静态数据成员。
假设要为友元函数提供模板类参数，可以如下所示来进行友元声明吗？
friend void report(HasFriend &);
答案是不可以。原因是不存在“HasFriend这样的对象，而只有特定的具体化如HasFriend<short>。
要提供模板类参数，必须指明具体化。例如，可以这样做：
template <typename T>
class HasFriend
{
public:
    friend void report(HasFriend<T> &);
};
声明一个特定类型的对象
HasFriend<int>h1;
编译器使用int替换参数T，因此友元函数声明的格式如下：
class HasFriend<int>
{
public:
    friend void report(HasFriend<int> &);
};
也就是说，带HasFriend<int>参数的report将成为HasFriend<int>类的友元。
同样，带HasFriend<double>参数的report将是report的一个重载版本――它是Hasfriend<double>类的友元。
注意，report本身并不是模板函数，而只是使用一个模板作参数。这意味着必须为要使用的友元定义显式具体化：
void report (HasFriend<short>&)   //explicit specialization for short 
{
    // ...
};
void report（HasFriend<int>&)   //explicit specialization for int
{
    // ...
};
HasFriend模板有一个静态成员ct。这意味着这个类的每一个特定的具体化都将有自己的静态成员。
count方法是所有HasFriend具体化的友元，它报告两个特定的具体化（HasFriend<int>和HasFriend<double>）的ct的值。
该程序还提供两个report函数，它们分别是某个特定HasFriend具体化的友元。
程序清单14.22 frnd2tmp.cpp
#include <iostream>

using std::cout;
using std::endl;

template <typename T>
class HasFriend
{
private:
    T item;
    static int ct;
public:
    HasFriend(const T &i) : item(i)
    {
        ct++;
    }
    ~HasFriend()
    {
        ct--;
    }
    friend void counts();
    friend void reports(HasFriend<T> &);
};

template <typename T>
int HasFriend<T>::ct = 0;

void counts()
{
    cout << "int count: " << HasFriend<int>::ct << "; ";
    cout << "double count: " << HasFriend<double>::ct << endl;
}
void reports(HasFriend<int> &hf)
{
    cout << "HasFriend<int>: " << hf.item << endl;
}
void reports(HasFriend<double> &hf)
{
    cout << "HasFriend<double>: " << hf.item << endl;
}
int main()
{
    cout << "No objects declared: ";
    counts();
    HasFriend<int> hfi1(10);
    cout << "After hfi1 declared: ";
    counts();
    HasFriend<int> hfi2(20);
    cout << "After hfi2 declared: ";
    counts();
    HasFriend<double> hfdb(10.5);
    cout << "After hfdb declared: ";
    counts();
    reports(hfi1);
    reports(hfi2);
    reports(hfdb);

    return 0;
}
编译命令如下
g++ -o frnd2tmp frnd2tmp.cpp
frnd2tmp.cpp:22:39: warning: friend declaration ‘void reports(HasFriend<T>&)’ declares a non-template function [-Wnon-template-friend]
   22 |     friend void reports(HasFriend<T> &);
      |                                       ^
frnd2tmp.cpp:22:39: note: (if this is not what you intended, make sure the function template has already been declared and add ‘<>’ after the function name here)

显示结果如下
No objects declared: int count: 0; double count: 0
After hfi1 declared: int count: 1; double count: 0
After hfi2 declared: int count: 2; double count: 0
After hfdb declared: int count: 2; double count: 1
HasFriend<int>: 10
HasFriend<int>: 20
HasFriend<double>: 10.5

可以修改前一个示例，使友元函数本身成为模板。
首先，在模板类定义的前面声明每个模板函数。
template <typename T> void counts();
template <typename T> void report(T &);
然后，在在模板类定义中再次将模板函数声明为友元。这些语句根据类模板参数的类型声明具体化：
template<typename TT>
class HasFriendT
{
    // ...
    friend void counts<TT>();
    friend void report<>(HasFriendT<TT> &);
};
对于report函数，<>可以为空，因为可以从函数参数推断出如下模板类型参数：
HasFriendT<TT>
然而，也可以使用：
report< HasFriendT<TT> > (HasFriendT<TT> &);
但counts函数没有参数，因此必须使用模板参数语法（<TT>）来指明其具体化。
还需要注意的是，TT是HasFriendT类的参数类型。
同样，理解这些声明的最佳方式也是设想声明一个特定具体化的对象时，它们将变成什么样。例如，假设声明了这样一个对象：
HasFriendT<int> squack;
编译器将用int替换TT，并生成下面的类定义：
class HasFriendT<int>
{
    // ...
    friend void counts<int>();
    friend void report<>(HasFriendT<int> &);
};
基于T的具体化将变为int，基于HasFriendT<TT>的具体化将变为HasFriendT<int>。
因此，模板具体化counts<int>()和report<HasFriendT<int>>()被声明为HasFriendT<int>类的友元。
程序必须满足的第三个要求是，为友元提供模板定义。
程序清单14.23 tmp2tmp.cpp
#include <iostream>

using std::cout;
using std::endl;

template <typename T> void counts();
template <typename T> void report(T &);

template <typename TT>
class HasFriendT
{
private:
    TT item;
    static int ct;
public:
    HasFriendT(const TT &i) : item(i)
    {
        ct++;
    }
    ~HasFriendT()
    {
        ct--;
    }
    friend void counts<TT>();
    friend void report<>(HasFriendT<TT> &);
};

template <typename T>
int HasFriendT<T>::ct = 0;

template <typename T>
void counts()
{
    cout << "template size: " << sizeof(HasFriendT<T>) << "; ";
    cout << "template counts(): " << HasFriendT<T>::ct << endl;
}

template <typename T>
void report(T &hf)
{
    cout << hf.item << endl;
}

int main()
{
    counts<int>();
    counts<double>();
    HasFriendT<int> hfi1(10);
    HasFriendT<int> hfi2(20);
    HasFriendT<double> hfdb(10.5);
    report(hfi1);
    report(hfi2);
    report(hfdb);
    cout << "counts<int>() output:\n";
    counts<int>();
    cout << "counts<double>() output:\n";
    counts<double>();

    return 0;
}
显示结果如下
template size: 4; template counts(): 0
template size: 8; template counts(): 0
10
20
10.5
counts<int>() output:
template size: 4; template counts(): 2
counts<double>() output:
template size: 8; template counts(): 1

通过在类内部声明模板，可以创建非约束友元函数，即每个函数具体化都是每个类具体化的友元。
对于非约束友元，友元模板类型参数与模板类类型参数是不同的。
template<typename T>
class ManyFriend
{
public:
    template <typename C, typename D> friend void show2(C &, D &);
};
程序清单14.24 manyfrnd.cpp
#include <iostream>

using std::cout;
using std::endl;

template <typename T>
class ManyFriend
{
private:
    T item;
public:
    ManyFriend(const T &i) : item(i) {}
    template <typename C, typename D> friend void show2(C &, D &);
};
template <typename C, typename D> void show2(C &c, D &d)
{
    cout << c.item << ", " << d.item << endl;
}

int main()
{
    ManyFriend<int> hfi1(10);
    ManyFriend<int> hfi2(20);
    ManyFriend<double> hfdb(10.5);
    cout << "hfi1, hfi2: ";
    show2(hfi1, hfi2);
    cout << "hfdb, hfi2: ";
    show2(hfdb, hfi2);

    return 0;
}
显示结果如下
hfi1, hfi2: 10, 20
hfdb, hfi2: 10.5, 20

如果能为类型指定别名，将很方便，在模板设计中尤其如此。可使用typedef为模板具体化指定别名：
//define three typedef aliases
typedef std::array<double, 12> arrd;
typedef std::array<int, 12>arri;
typedef std::array<std::string, 12> arrst;
arrd gallons;   //gallons is type std::array<double, 12>
arri days;   //days is type std::array<int, 12>
arrst months;   //months is type std::array<std::string, 12>
但如果您经常编写类似于上述typedef的代码，您可能怀疑要么自己忘记了可简化这项任务的C++功能，
要么C++没有提供这样的功能。C++11新增了一项功能――使用模板提供一系列别名，如下所示：
template <typename T>
using arrtype = std::array<T, 12>;   //template to create multiple aliases
这将arrtype定义为一个模板别名，可使用它来指定类型，如下所示：
arrtype<double> gallons;   //gallons is type std::array<double, 12>
arrtype<int> days;   //days is type std::array<int, 12>
arrtype<std::string>months;   //months is type std::array<std::string, 12>
总之，arrtype<T>表示类型 std::array<T, 12>。
C++11允许将语法using=用于非模板。用于非模板时，这种语法与常规typedef等价：
typedef const char* pc1;   //typedef syntax
using pc2 = const char *;   //using = syntax
typedef const int * (*pa1)[10];   //typedef syntax
using pa2 = const int * (*)[10];   //using = syntax
习惯这种语法后，您可能发现其可读性更强，因为它让类型名和类型信息更清晰。
C++11新增的另一项模板功能是可变参数模板（variadic template），让您能够定义这样的模板类和模板函数，
即可接受可变数量的参数。这个主题将在第18章介绍。
14.5总结
C++提供了几种重用代码的手段。第13章介绍的公有继承能够建立is-a关系，这样派生类可以重用基类的代码。
私有继承和保护继承也使得能够重用基类的代码，但建立的是has-a关系。
使用私有继承时，基类的公有成员和保护成员将成为派生类的私有成员；
使用保护继承时，基类的公有成员和保护成员将成为派生类的保护成员。
无论使用哪种继承，基类的公有接口都将成为派生类的内部接口。
这有时候被称为继承实现，但并不继承接口，因为派生类对象不能显式地使用基类的接口。
因此，不能将派生对象看作是一种基类对象。由于这个原因，在不进行显式类型转换的情况下，
基类指针或引用将不能指向派生类对象。
还可以通过开发包含对象成员的类来重用类代码。这种方法被称为包含、层次化或组合，它建立的也是has-a关系。
与私有继承和保护继承相比，包含更容易实现和使用，所以通常优先采用这种方式。
然而，私有继承和保护继承比包含有一些不同的功能。例如，继承允许派生类访问基类的保护成员；
还允许派生类重新定义从基类那里继承的虚函数。因为包含不是继承，所以通过包含来重用类代码时，不能使用这些功能。
另一方面，如果需要使用某个类的几个对象，则用包含更适合。
多重继承（Ml）使得能够在类设计中重用多个类的代码。私有MI或保护Ml建立has-a关系，而公有Ml建立is-a关系。
Ml会带来一些问题，即多次定义同一个名称，继承多个基类对象。
可以使用类限定符来解决名称二义性的问题，使用虚基类来避免继承多个基类对象的问题。
但使用虚基类后，就需要为编写构造函数初始化列表以及解决二义性问题引入新的规则。
类模板使得能够创建通用的类设计，其中类型（通常是成员类型）由类型参数表示。
类定义（实例化）在声明类对象并指定特定类型时生成。
使用关键字template 声明类的特定具体化时，将发生显式实例化。
可以提供显式具体化――覆盖模板定义的具体类声明。方法是以template <>打头，
然后是模板类名称再加上尖括号（其中包含要具体化的类型）。
类模板可以指定多个泛型，也可以有非类型参数。
类模板还可以包含本身就是模板的参数。
类模板可以被部分具体化。
模板类可用作其他类、结构和模板的成员
所有这些机制的目的都是为了让程序员能够重用经过测试的代码，而不用手工复制它们。
这样可以简化编程工作，提供程序的可靠性。
14.6复习题
1.以A栏的类为基类时，B栏的类采用公有派生还是私有派生更合适。
class Bear                                          class PolarBear 公有派生 PolarBear is a Bear
class Kitchen                                     class Home       私有 Home has a Kitchen
class Person                                      class Programmer   公有派生 Programmer is a Person
class Person                                      class HorseAndJockey 私有 马和驯马师的组合 has a Person
class Person, class Automobile         class Driver                   Person 公有，Automobile 私有
                                                                                                Driver is a Person has a Automobile
2.假设有下面的定义：
class Frabjous
{
private:
    std::string fab;
public:
    Frabjous (const char * s = "C++") : fab(s) {}
   virtual void tell() {cout << fab;}
};
class Gloam
{
private:
    int glip;
    Frabjous fb;
public:
    Gloam (int g = 0, const char * s = "C++");
    Gloam (int g, const Frabjous &fr);
    void tell();
};
假设Gloam版本的tell应显示glip和f的值，请为这3个Gloam方法提供定义。
Gloam::Gloam(int g, const char * s) : glip(g), fb(s) {}
Gloam::Gloam(int g, const Frabjous & fr) : glip(g), fb(fr) {}
Gloam::tell()
{
    fb.tell();
    cout << '\n';
    cout << glip << '\n';
}

3.假设有下面的定义：
class Frabjous
{
private:
    std::string fab;
public:
    Frabjous (const char * s = "C++") : fab(s) {}
   virtual void tell() {cout << fab;}
};
class Gloam : private Frabjous
{
private:
    int glip;
public:
    Gloam (int g = 0, const char * s = "C++");
    Gloam (int g, const Frabjous &fr);
    void tell();
};
假设Gloam版本的tell()应显示glip和fab的值，请为这3个Gloam方法提供定义。
Gloam::Gloam(int g, const char * s) : glip(g), Frabjous(s) {}
Gloam::Gloam(int g, const Frabjous & fr) : glip(g), Frabjous(fr) {}
Gloam::tell()
{
    Frabjous::tell();
    cout << '\n';
    cout << glip << '\n';
}
4.假设有下面的定义，它是基于程序清单14.13中的Stack模板和程序清单14.10中的Woker类的：
Stack<Worker*> sw;
请写出将生成的类声明。只实现类声明，不实现非内联类方法。
class Stack<Worker *>
{
private:
    enum { MAX = 10 };
    Worker * items[MAX];
    int top;
public:
    Stack();
    bool isempty();
    bool isfull();
    bool push(const Worker * &item);
    bool pop(Worker * &item);
};

5.使用本章中的模板定义对下面的内容进行定义：
string对象数组；
double数组栈；
指向Worker对象的指针的栈数组。
程序清单14.18生成了多少个模板类定义？
template <typename T, int n>
class ArrayTP
{
private:
    T ar[n];
public:
    ArrayTP() {};
    explicit ArrayTP(const T &v);
    virtual T &operator[](int i);
    virtual T operator[](int i) const;
};

template <typename Type>
class Stack
{
private:
    enum { MAX = 10 };
    Type items[MAX];
    int top;
public:
    Stack();
    bool isempty();
    bool isfull();
    bool push(const Type &item);
    bool pop(Type &item);
};

ArrayTP<std::string, 10> sa;
Stack< ArrayTP<double, 10> > stck_arr_db;
ArrayTP< Stack<Worker *> , 10>

程序清单14.18生成了4个模板类定义
ArrayTP<int, 10>
ArrayTP<double, 10>
ArrayTP<int, 5>
ArrayTP< ArrayTP<int, 5>, 10>

6.指出虚基类与非虚基类之间的区别。
如果一个类通过多种途径继承了一个非虚基类，则该类从每种途径分别继承非虚基类的一个实例。
当派生类使用关键字virtual来指示派生时，基类就成为虚基类。
从虚基类的一个或多个实例派生而来的类将只继承一个基类对象。

14.7编程练习
1.Wine类有一个string类对象成员（参见第4章）和一个Pair对象（参见本章）；
其中前者用于存储葡萄酒的名称，而后者有2个valarray<int>对象（参见本章），
这两个valarray<int>对象分别保存了葡萄酒的酿造年份和该年生产的瓶数。
例如，Pair的第1个valarray<int>对象可能为1988、1992和1996年，第2个valarray<int>对象可能为24、48和144瓶。
Wine最好有1个int成员用于存储年数。另外，一些typedef可能有助于简化编程工作：
typedef std::valarray<int> ArrayInt;
typedef Pair<ArrayInt, ArrayInt> PairArray;
这样，PairArray表示的是类型Pair<std::valarray<int>, std::valarray<int>>。
使用包含来实现Wine类，并用一个简单的程序对其进行测试。
wine.h
#ifndef WINE_H_
#define WINE_H_
#include <string>
#include <valarray>
#include <iostream>

using ArrayInt = std::valarray<int>;
using PairArray = std::pair<ArrayInt, ArrayInt>;

class Wine
{
private:
    std::string label;
    PairArray data;
    int years;
public:
    Wine(const char *l, int у, const int yr[], const int bot[]);
    Wine(const char *l, int у);
    ~Wine();

    void Show() const;
    void GetBottles();
    const std::string &Label() const;
    int sum() const;
};

#endif

wine.cpp
#include <iostream>
#include "wine.h"

Wine::Wine(const char *l, int y, const int yr[], const int bot[])
{
    label = l;
    years = y;
    data.first.resize(years);
    data.second.resize(years);

    for (int i = 0; i < years; i++)
    {
        data.first[i] = yr[i];
        data.second[i] = bot[i];
    }
}

Wine::Wine(const char *l, int y)
{
    label = l;
    years = y;
    data.first.resize(years);
    data.second.resize(years);
}

Wine::~Wine()
{

}

void Wine::Show() const
{
    std::cout << "Wine: " << label << std::endl;
    std::cout << "\tYear\tBottles" << std::endl;

    for (int i = 0; i < years; i++)
    {
        std::cout << "\t" << data.first[i] << "\t";
        std::cout << data.second[i] << std::endl;
    }
}

const std::string &Wine::Label() const
{
    return label;
}

void Wine::GetBottles()
{
    std::cout << "Enter " << label << " data for " << years << " year(s):\n";

    int input = 0;
    for (int i = 0; i < years; i++)
    {
        std::cout << "Enter year: ";
        std::cin >> input;
        data.first[i] = input;
        std::cout << "Enter bottles for that year: ";
        std::cin >> input;
        data.second[i] = input;

        std::cout << std::endl;
    }
}

int Wine::sum() const
{
    int sum = 0;
    for (int i = 0; i < years; i++)
    {
        sum += data.second[i];
    }
    return sum;
}

ch14_p01.cpp
#include <iostream>
#include "wine.h"

int main()
{
    std::cout << "Enter name of wine: ";
    char lab[50];
    std::cin.getline(lab, 50);
    std::cout << std::endl;

    std::cout << "Enter number of years: ";
    int yrs = 0;
    std::cin >> yrs;
    while (std::cin.get() != '\n')
    {
        continue;
    }

    Wine holding(lab, yrs);
    holding.GetBottles();
    holding.Show();
    std::cout << std::endl;

    const int YRS = 3;
    int y[YRS] = { 1993, 1995, 1998 };
    int b[YRS] = { 48, 60, 72 };

    Wine more("Gushing Grape Red", YRS, y, b);
    more.Show();
    std::cout << std::endl;

    std::cout << "Total bottles for " << more.Label();
    std::cout << ": " << more.sum() << std::endl;
    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Enter name of wine: Apple Orange

Enter number of years: 5
Enter Apple Orange data for 5 year(s):
Enter year: 1992
Enter bottles for that year: 32

Enter year: 1995
Enter bottles for that year: 66

Enter year: 1998
Enter bottles for that year: 33

Enter year: 1999
Enter bottles for that year: 36

Enter year: 2003
Enter bottles for that year: 55

Wine: Apple Orange
        Year    Bottles
        1992    32
        1995    66
        1998    33
        1999    36
        2003    55

Wine: Gushing Grape Red
        Year    Bottles
        1993    48
        1995    60
        1998    72

Total bottles for Gushing Grape Red: 180
Done.

2.采用私有继承而不是包含来完成编程练习1。
wine2.h
#ifndef WINE2_H_
#define WINE2_H_
#include <string>
#include <valarray>
#include <iostream>


using ArrayInt = std::valarray<int>;
using PairArray = std::pair<ArrayInt, ArrayInt>;

class Wine : private std::string, private PairArray
{
private:
    int years;
public:
    Wine(const char *l, int y, const int yr[], const int bot[]);
    Wine(const char *l, int y);
    ~Wine();

    void Show() const;
    void GetBottles();
    const std::string &Label() const;
    int sum() const;
};

#endif

wine2.cpp
#include <iostream>
#include "wine2.h"

Wine::Wine(const char *l, int y) : PairArray(ArrayInt(y), ArrayInt(y)), std::string(l)
{
    years = y;
}

Wine::Wine(const char *l, int y, const int yr[], const int bot[]) : PairArray(ArrayInt(y), ArrayInt(y)), std::string(l)
{
    years = y;
    for (int i = 0; i < years; i++)
    {
        PairArray::first[i] = yr[i];
        PairArray::second[i] = bot[i];
    }
}

Wine::~Wine()
{

}

const std::string &Wine::Label() const
{
    return (const std::string &)(*this);
}

void Wine::Show() const
{
    std::cout << "Wine: " << Label() << std::endl;
    std::cout << "\tYear\tBottles" << std::endl;

    for (int i = 0; i < years; i++)
    {
        std::cout << "\t" << PairArray::first[i] << "\t";
        std::cout << PairArray::second[i] << std::endl;
    }
}

void Wine::GetBottles()
{
    std::cout << "Enter " << Label() << " data for " << years << " year(s):\n";

    int input;
    for (int i = 0; i < years; i++)
    {
        std::cout << "Enter year: ";
        std::cin >> input;
        PairArray::first[i] = input;
        std::cout << "Enter bottles for that year: ";
        std::cin >> input;
        PairArray::second[i] = input;

        std::cout << std::endl;
    }
}

int Wine::sum() const
{
    int sum = 0;
    for (int i = 0; i < years; i++)
    {
        sum += PairArray::second[i];
    }
    return sum;
}

ch14_p02.cpp
#include <iostream>
#include "wine2.h"

int main()
{
    std::cout << "Enter name of wine: ";
    char lab[50];
    std::cin.getline(lab, 50);
    std::cout << std::endl;

    std::cout << "Enter number of years: ";
    int yrs = 0;
    std::cin >> yrs;
    while (std::cin.get() != '\n')
    {
        continue;
    }
    Wine holding(lab, yrs);
    holding.GetBottles();
    holding.Show();
    std::cout << std::endl;

    const int YRS = 3;
    int y[YRS] = { 1993, 1995, 1998 };
    int b[YRS] = { 48, 60, 72 };

    Wine more("Gushing Grape Red", YRS, y, b);
    more.Show();
    std::cout << std::endl;

    std::cout << "Total bottles for " << more.Label();
    std::cout << ": " << more.sum() << std::endl;
    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Enter name of wine: Peter Smith

Enter number of years: 3
Enter Peter Smith data for 3 year(s):
Enter year: 1993
Enter bottles for that year: 32

Enter year: 2003
Enter bottles for that year: 55

Enter year: 2013
Enter bottles for that year: 66

Wine: Peter Smith
        Year    Bottles
        1993    32
        2003    55
        2013    66

Wine: Gushing Grape Red
        Year    Bottles
        1993    48
        1995    60
        1998    72

Total bottles for Gushing Grape Red: 180
Done.

3：定义QueueTP模板然后在一个类似于程序清单14.12的程序中创建一个指向Worker的指针队列，使用编写程序测试该队列。
queuetp.h
#ifndef QUEUETP_H_
#define QUEUETP_H_

template <typename T>
class QueueTp
{
private:
    struct Node
    {
        T value;
        Node *next = nullptr;
        Node *prev = nullptr;
    };
    using link = Node*;
    link head = nullptr;
    link tail = nullptr;
    void emptyList();
public:
    QueueTp();
    QueueTp(const QueueTp<T> &q);
    ~QueueTp();

    bool enqueue(const T &val);
    bool dequeue(T &val);
    bool isEmpty() const;

    QueueTp<T> &operator = (const QueueTp<T> &q);
};

template <typename T>
QueueTp<T>::QueueTp() : head(nullptr), tail(nullptr)
{

}

template <typename T>
QueueTp<T>::QueueTp(const QueueTp<T> &q)
{
    link tail = q.tail;
    while (tail != nullptr)
    {
        enqueue(tail->value);
        tail = tail->prev;
    }
}
template <typename T>
QueueTp<T>::~QueueTp()
{
    emptyList();
}
template <typename T>
void QueueTp<T>::emptyList()
{
    link t = head;
    link next;
    while (t != nullptr)
    {
        next = t->next;
        delete t;
        t = next;
    }
    head = nullptr;
    tail = nullptr;
}
template <typename T>
bool QueueTp<T>::enqueue(const T &val)
{
    link l = new (std::nothrow) Node;
    if (l == nullptr)
    {
        return false;
    }
    else
    {
        if (isEmpty())
        {
            l->value = val;
            l->next = nullptr;
            l->prev = nullptr;
            head = l;
            tail = l;
        }
        else
        {
            l->value = val;
            l->next = head;
            l->prev = nullptr;
            head->prev = l;
            head = l;
        }
        return true;
    }
}
template <typename T>
bool QueueTp<T>::dequeue(T &val)
{
    if (isEmpty())
    {
        return false;
    }
    else
    {
        if (head == tail)
        {
            val = tail->value;
            delete tail;
            head = tail = nullptr;
        }
        else
        {
            val = tail->value;
            link prev = tail->prev;
            delete tail;
            tail = prev;
            tail->next = nullptr;
        }
        return true;
    }
}
template <typename T>
bool QueueTp<T>::isEmpty() const
{
    if (nullptr == head && nullptr == tail)
    {
        return true;
    }
    else
    {
        return false;
    }
}
template <typename T>
QueueTp<T> &QueueTp<T>::operator = (const QueueTp<T> &q)
{
    if (&q == this)
    {
        return *this;
    }

    emptyList();
    link t = q.tail;
    while (t != nullptr)
    {
        enqueue(t->value);
        t = t->prev;
    }
    return *this;
}

#endif

workermi.h
#pragma once
#ifndef WORKERMI_H_
#define WORKERMI_H_
#include <string>

class Worker
{
private:
    std::string fullname;
    long id;
protected:
    virtual void Data() const;
    virtual void Get();
public:
    Worker() : fullname("no one"), id(0L) {}
    Worker(const std::string &s, long n) : fullname(s), id(n) {}
    virtual ~Worker() = 0;
    virtual void Set() = 0;
    virtual void Show() const = 0;
};

class Waiter : virtual public Worker
{
private:
    int panache;
protected:
    void Data() const;
    void Get();
public:
    Waiter() : Worker(), panache(0) {}
    Waiter(const std::string &s, long n, int p = 0) : Worker(s, n), panache(p) {}
    Waiter(const Worker &wk, int p = 0) : Worker(wk), panache(p) {}
    void Set();
    void Show() const;
};

class Singer : virtual public Worker
{
protected:
    enum
    {
        other, alto, contralto, soprano,
        bass, baritone, tenor
    };
    enum { Vtypes = 7 };
    void Data() const;
    void Get();
private:
    static const char *pv[Vtypes];
    int voice;
public:
    Singer() : Worker(), voice(other) {}
    Singer(const std::string &s, long n, int v = other) : Worker(s, n), voice(v) {}
    Singer(const Worker &wk, int v = other) : Worker(wk), voice(v) {}
    void Set();
    void Show() const;
};
class SingingWaiter : public Singer, public Waiter
{
protected:
    void Data() const;
    void Get();
public:
    SingingWaiter() {}
    SingingWaiter(const std::string &s, long n, int p = 0, int v = Singer::other) : Worker(s, n), Waiter(s, n, p), Singer(s, n, v) {}
    SingingWaiter(const Worker &wk, int p = 0, int v = Singer::other) : Worker(wk), Waiter(wk, p), Singer(wk, v) {}
    SingingWaiter(const Waiter &wt, int v = Singer::other) : Worker(wt), Waiter(wt), Singer(wt, v) {}
    SingingWaiter(const Singer &wt, int p = 0) : Worker(wt), Waiter(wt, p), Singer(wt) {}
    void Set();
    void Show() const;
};

#endif

workermi.cpp
#include <iostream>
#include "workermi.h"

using std::cout;
using std::cin;
using std::endl;

Worker::~Worker() { }

void Worker::Data() const
{
    cout << "Name: " << fullname << endl;
    cout << "Employee ID: " << id << endl;
}

void Worker::Get()
{
    std::getline(cin, fullname, '\n');
    cout << "Enter worker's ID: ";
    cin >> id;
    while (cin.get() != '\n')
    {
        continue;
    }
}

void Waiter::Set()
{
    cout << "Enter waiter's name: ";
    Worker::Get();
    Get();
}
void Waiter::Show() const
{
    cout << "Category: waiter\n";
    Worker::Data();
    Data();
}
void Waiter::Data() const
{
    cout << "Panache rating: " << panache << endl;
}
void Waiter::Get()
{
    cout << "Enter waiter's panache rating: ";
    cin >> panache;
    while (cin.get() != '\n')
    {
        continue;
    }
}
const char *Singer::pv[Singer::Vtypes] = { "other", "alto", "contralto", "soprano", "bass", "baritone", "tenor" };

void Singer::Set()
{
    cout << "Enter singer's name: ";
    Worker::Get();
    Get();
}

void Singer::Show() const
{
    cout << "Category: singer\n";
    Worker::Data();
    Data();
}
void Singer::Data() const
{
    cout << "Vocal range: " << pv[voice] << endl;
}
void Singer::Get()
{
    cout << "Enter number for singer's vocal range:\n";
    int i;
    for (i = 0; i < Vtypes; i++)
    {
        cout << i << ": " << pv[i] << "   ";
        if (i % 4 == 3)
        {
            cout << endl;
        }
    }
    if (i % 4 != 0)
    {
        cout << '\n';
    }
    while (cin >> voice && (voice < 0 || voice >= Vtypes))
    {
        cout << "Please enter a value >= 0 and < " << Vtypes << endl;
    }
    cin.clear();
    while (cin.get() != '\n')
    {
        continue;
    }
}
void SingingWaiter::Data() const
{
    Singer::Data();
    Waiter::Data();
}
void SingingWaiter::Get()
{
    Waiter::Get();
    Singer::Get();
}
void SingingWaiter::Set()
{
    cout << "Enter singing waiter's name: ";
    Worker::Get();
    Get();
}
void SingingWaiter::Show() const
{
    cout << "Category: singing waiter\n";
    Worker::Data();
    Data();
}

ch14_p03.cpp
#include <iostream>
#include <cstring>
#include "workermi.h"
#include "queuetp.h"

const int SIZE = 5;

int main()
{
    QueueTp<Worker *> q;
    Worker *pw;
    int ct;
    for (ct = 0; ct < SIZE; ct++)
    {
        std::cout << "Enter the employee category:\n";
        std::cout << "w: waiter  s: singer  ";
        std::cout << "t: singing waiter  q: quit\n";

        char choice = 0;
        std::cin >> choice;
        while (std::cin.get() != '\n')
        {
            continue;
        }
        while (std::strchr("wstq", choice) == nullptr)
        {
            std::cout << "Please enter a w, s, t, or q: ";
            std::cin >> choice;
            while (std::cin.get() != '\n')
            {
                continue;
            }
        }

        if (choice == 'q')
        {
            break;
        }

        switch (choice)
        {
        case 'w':
            pw = new Waiter;
            break;
        case 's':
            pw = new Singer;
            break;
        case 't':
            pw = new SingingWaiter;
            break;
        default:
            pw = new SingingWaiter;
            break;
        }

        pw->Set();
        q.enqueue(pw);
    }

    std::cout << "\nHere is your staff:\n";

    for (int i = 0; i < ct; i++)
    {
        q.dequeue(pw);
        pw->Show();
        delete pw;
        std::cout << std::endl;
    }
    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
w
Enter waiter's name: Apple
Enter worker's ID: 222333
Enter waiter's panache rating: 8
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
s
Enter singer's name: Orange
Enter worker's ID: 555666
Enter number for singer's vocal range:
0: other   1: alto   2: contralto   3: soprano
4: bass   5: baritone   6: tenor
1
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
t
Enter singing waiter's name: Water
Enter worker's ID: 888999
Enter waiter's panache rating: 9
Enter number for singer's vocal range:
0: other   1: alto   2: contralto   3: soprano
4: bass   5: baritone   6: tenor
6
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
q

Here is your staff:
Category: waiter
Name: Apple
Employee ID: 222333
Panache rating: 8

Category: singer
Name: Orange
Employee ID: 555666
Vocal range: alto

Category: singing waiter
Name: Water
Employee ID: 888999
Vocal range: tenor
Panache rating: 9

Done.

4.Person类保存人的名和姓。除构造函教外，它还有show()方法，用于显示名和姓。
Gunslinger类以Person类为虚基类派生而来，它包含一个Draw方法，返回一个double值，表示枪手的拔枪时间。
这个类还包含一个int成员，表示枪手枪上的刻痕数。最后，这个类还包含一个Show方法，用于显示所有这些信息。
PokerPlayer类以Person 类为虚基类派生而来。它包含一个Draw方法，返回一个1-52的随机数，用于表示克牌的值
（也可以定义一Card类，其中包含花色和面值成员，然后让Draw返回一个Card对象。
PokerPlayer类使用Person 类的show函数。
BadDude类从Gunslinger和PokerPlayer类公有派生而来。
它包含Gdraw方法（返回坏蛋拔枪的时间）和 Cdraw方法（返回下一张扑克牌）；
另外还有一个合适的Show函数。请定义这些类和方法以及其他必要的方法（如用于设置对象值的方法），
并使用一个类似于程序清单14.12的简单程序对它们进行测试。
person2.h
#ifndef PERSON2_H_
#define PERSON2_H_
#include <string>

class Person
{
private:
    std::string firstname;
    std::string lastname;
protected:
    virtual void Data() const;
public:
    Person(const std::string &first = "", const std::string &last = "");
    virtual ~Person() {};
    void setFirstName(const std::string &s)
    {
        firstname = s;
    }
    void setLastName(const std::string &s)
    {
        lastname = s;
    }
    virtual void Show() const;
    virtual void Set();
};
class Gunslinger : virtual public Person
{
private:
    double drawtime;
    int notches;
protected:
    void Data() const;
    virtual void setData();
public:
    Gunslinger(const std::string &first = "", const std::string &last = "", double d = 0, int n = 0);
    ~Gunslinger() {};
    void setDrawTime(double d);
    void setNotches(int n);
    double Draw() const
    {
        return drawtime;
    }
    int Notches() const
    {
        return notches;
    }
    virtual void Show() const;
    virtual void Set()
    {
        Person::Set();
        Gunslinger::setData();
    }
};

class PokerPlayer : virtual public Person
{
public:
    PokerPlayer(std::string first = "", std::string last = "");
    ~PokerPlayer() {}
    int Draw() const
    {
        return (rand() % 52) + 1;
    }
    virtual void Show() const;
    virtual void Set()
    {
        Person::Set();
    }
};

class BadDude : public Gunslinger, public PokerPlayer
{
private:
public:
    BadDude(std::string first = "", std::string last = "", double d = 0, int n = 0);
    ~BadDude() {}
    double Gdraw() const
    {
        return Gunslinger::Draw();
    }
    int Cdraw() const
    {
        return PokerPlayer::Draw();
    }
    virtual void Show() const;
    void Set();
};

#endif

person2.cpp
#include <iostream>
#include "person2.h"

void Person::Data() const
{
    std::cout << "First name: " << firstname << std::endl;
    std::cout << "Last name: " << lastname << std::endl;
}
Person::Person(const std::string &first, const std::string &last)
{
    firstname = first;
    lastname = last;
}
void Person::Show() const
{
    std::cout << "Type Person" << std::endl;
    Data();
}
void Person::Set()
{
    std::cout << "Enter the first name: ";
    std::getline(std::cin, firstname, '\n');
    std::cout << "Enter the last name: ";
    std::getline(std::cin, lastname, '\n');
}
void Gunslinger::Data() const
{
    std::cout << "Draw time: " << drawtime << std::endl;
    std::cout << "Notches: " << notches << std::endl;
}
void Gunslinger::setData()
{
    std::cout << "Enter the draw time: ";
    std::cin >> drawtime;
    while (!std::cin || drawtime < 0)
    {
        std::cin.clear();
        while (std::cin.get() != '\n')
        {
            continue;
        }
        std::cout << "Draw time must be a positive number.\nTry again: ";
        std::cin >> drawtime;
    }

    std::cout << "Enter the number of notches: ";
    std::cin >> notches;
    while (!std::cin || notches < 0)
    {
        std::cin.clear();
        while (std::cin.get() != '\n')
        {
            continue;
        }
        std::cout << "Notches must be a positive integer.\nTry again: ";
        std::cin >> notches;
    }
    while (std::cin.get() != '\n')
    {
        continue;
    }
}

Gunslinger::Gunslinger(const std::string &first, const std::string &last, double d, int n) : Person(first, last)
{
    drawtime = d;
    notches = n;
}

void Gunslinger::setDrawTime(double d)
{
    if (d < 0)
    {
        std::cerr << "Error, draw time cannot be negative. ";
        std::cerr << "Setting draw time to 0." << std::endl;
        drawtime = 0;
    }
    else
    {
        drawtime = d;
    }
}
void Gunslinger::setNotches(int n)
{
    if (n < 0)
    {
        std::cerr << "Error, notches cannot be negative. ";
        std::cerr << "Setting notches to 0." << std::endl;
        notches = 0;
    }
    else
    {
        notches = n;
    }
}

void Gunslinger::Show() const
{
    std::cout << "Type Gunslinger" << std::endl;
    Person::Data();
    Data();
}
PokerPlayer::PokerPlayer(std::string first, std::string last) : Person(first, last)
{

}
void PokerPlayer::Show() const
{
    std::cout << "Type Poker Player" << std::endl;
    Person::Data();
}
BadDude::BadDude(std::string first, std::string last, double d, int n) : Person(first, last), Gunslinger(first, last, d, n), PokerPlayer(first, last)
{

}
void BadDude::Show() const
{
    std::cout << "Type BadDude" << std::endl;
    Person::Data();
    Gunslinger::Data();
}
void BadDude::Set()
{
    Person::Set();
    Gunslinger::setData();
}

ch14_p04.cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include "person2.h"

const int SIZE = 4;

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    using std::strchr;

    std::srand(std::time(nullptr));
    Person *pp[SIZE];
    int ct;
    for (ct = 0; ct < SIZE; ct++)
    {
        std::cout << "Enter the person category:\n";
        std::cout << "p: person        g: gunslinger" << std::endl;
        std::cout << "k: poker player  b: bad dude" << std::endl;
        std::cout << "q: quit" << std::endl;

        char choice = 0;
        std::cin >> choice;
        while (std::cin.get() != '\n')
        {
            continue;
        }

        while (std::strchr("pgkbq", choice) == nullptr)
        {
            std::cout << "Please enter a p, g, k, b, or q: ";
            std::cin >> choice;
            while (std::cin.get() != '\n')
            {
                continue;
            }
        }

        if (choice == 'q')
        {
            break;
        }

        switch (choice)
        {
        case 'p':
            pp[ct] = new Person;
            break;
        case 'g':
            pp[ct] = new Gunslinger;
            break;
        case 'k':
            pp[ct] = new PokerPlayer;
            break;
        case 'b':
            pp[ct] = new BadDude;
            break;
        default:
            pp[ct] = new BadDude;
            break;
        }
        pp[ct]->Set();
        pp[ct]->Show();
        std::cout << "ct = " << ct << std::endl;
        std::cout << std::endl;
    }

    std::cout << "Your selection:" << std::endl;
    for (int i = 0; i < ct; i++)
    {
        pp[i]->Show();
        std::cout << std::endl;
        delete *(pp + i);
    }

    return 0;
}
显示结果如下
Enter the person category:
p: person        g: gunslinger
k: poker player  b: bad dude
q: quit
p
Enter the first name: Mike
Enter the last name: Pence
Type Person
First name: Mike
Last name: Pence
ct = 0

Enter the person category:
p: person        g: gunslinger
k: poker player  b: bad dude
q: quit
g
Enter the first name: Peter
Enter the last name: Smith
Enter the draw time: 3
Enter the number of notches: 6
Type Gunslinger
First name: Peter
Last name: Smith
Draw time: 3
Notches: 6
ct = 1

Enter the person category:
p: person        g: gunslinger
k: poker player  b: bad dude
q: quit
k
Enter the first name: Hello
Enter the last name: World
Type Poker Player
First name: Hello
Last name: World
ct = 2

Enter the person category:
p: person        g: gunslinger
k: poker player  b: bad dude
q: quit
b
Enter the first name: Apple
Enter the last name: Orange
Enter the draw time: 2
Enter the number of notches: 3
Type BadDude
First name: Apple
Last name: Orange
Draw time: 2
Notches: 3
ct = 3

Your selection:
Type Person
First name: Mike
Last name: Pence

Type Gunslinger
First name: Peter
Last name: Smith
Draw time: 3
Notches: 6

Type Poker Player
First name: Hello
Last name: World

Type BadDude
First name: Apple
Last name: Orange
Draw time: 2
Notches: 3

5.下面是一些类声明：
emp.h
#ifndef EMP_H_
#define EMP_H_
#include <iostream>
#include <string>

class abstr_emp
{
private:
    std::string fname;
    std::string lname;
    std::string job;
public:
    abstr_emp();
    abstr_emp(const std::string &fn, const std::string &ln, const std::string &j);
    virtual void ShowAll() const;
    virtual void SetAll();
    friend std::ostream &operator<<(std::ostream &os, const abstr_emp &e);
    virtual ~abstr_emp() = 0;
};

class employee : public abstr_emp
{
public:
    employee();
    employee(const std::string &fn, const std::string   &ln, const std::string   &j);
    virtual void ShowAll() const;
    virtual void SetAll();
};

class manager : virtual public abstr_emp
{
private:
    int inchargeof;
protected:
    int InChargeOf() const
    {
        return inchargeof;
    }
    int &InChargeOf()
    {
        return inchargeof;
    }
public:
    manager();
    manager(const std::string &fn, const std::string &ln, const std::string &j, int ico = 0);
    manager(const abstr_emp &e, int ico);
    manager(const manager &m);
    virtual void ShowAll() const;
    virtual void SetAll();
};
class fink : virtual public abstr_emp
{
private:
    std::string reportsto;
protected:
    const std::string &ReportsTo() const
    {
        return reportsto;
    }
    std::string &ReportsTo()
    {
        return reportsto;
    }
public:
    fink();
    fink(const std::string &fn, const std::string &ln, const std::string &j, const std::string &rpo);
    fink(const abstr_emp &e, const std::string &rpo);
    fink(const fink &e);
    virtual void ShowAll() const;
    virtual void SetAll();
};

class highfink : public manager, public fink
{
public:
    highfink();
    highfink(const std::string &fn, const std::string &ln, const std::string &j, const std::string &rpo, int ico);
    highfink(const abstr_emp &e, const std::string &rpo, int ico);
    highfink(const fink &f, int ico);
    highfink(const manager &m, const std::string &rpo);
    highfink(const highfink &h);
    virtual void ShowAll() const;
    virtual void SetAll();
};

#endif

注意，该类层次结构使用子带虚基类的MI，所以要牢记这种情况下用于构造函数初始化列表的特殊规则。
还需要注意的是，有些方法被声明为保护的。这可以简化一些highfink方法的代码。
请提供类方法的实现，并在一个程序中对这些类进行测试。
emp.cpp
#include <iostream>
#include "emp.h"

abstr_emp::abstr_emp()
{
    fname = "";
    lname = "";
    job = "";
}
abstr_emp::abstr_emp(const std::string &fn, const std::string   &ln, const std::string   &j)
{
    fname = fn;
    lname = ln;
    job = j;
}
void abstr_emp::ShowAll() const
{
    std::cout << "First name: " << fname << std::endl;
    std::cout << "Last name: " << lname << std::endl;
    std::cout << "Job: " << job << std::endl;
}

void abstr_emp::SetAll()
{
    std::cout << "Enter first name: ";
    std::cin >> fname;

    while (std::cin.get() != '\n')
    {
        continue;
    }

    std::cout << "Enter last name: ";
    std::cin >> lname;

    while (std::cin.get() != '\n')
    {
        continue;
    }

    std::cout << "Enter the job: ";
    std::getline(std::cin, job, '\n');
}
std::ostream &operator << (std::ostream &os, const abstr_emp &e)
{
    os << e.lname << ", " << e.fname << " : " << e.job;
    return os;
}
abstr_emp::~abstr_emp()
{

}
employee::employee() : abstr_emp()
{

}
employee::employee(const std::string &fn, const std::string   &ln, const std::string   &j) : abstr_emp(fn, ln, j)
{

}
void employee::ShowAll() const
{
    std::cout << "Status: Employee" << std::endl;
    abstr_emp::ShowAll();
}

void employee::SetAll()
{
    abstr_emp::SetAll();
}
manager::manager() : abstr_emp()
{
    inchargeof = 0;
}
manager::manager(const std::string &fn, const std::string &ln, const std::string &j, int ico) : abstr_emp(fn, ln, j)
{
    inchargeof = ico;
    if (inchargeof < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        inchargeof = 0;
    }
}
manager::manager(const abstr_emp &e, int ico) : abstr_emp(e)
{
    inchargeof = ico;
    if (inchargeof < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        inchargeof = 0;
    }
}
manager::manager(const manager &m) : abstr_emp(m)
{
    inchargeof = m.inchargeof;
}
void manager::ShowAll() const
{
    std::cout << "Status: Manager" << std::endl;
    abstr_emp::ShowAll();
    std::cout << "In charge of " << inchargeof << " people" << std::endl;
}
void manager::SetAll()
{
    abstr_emp::SetAll();
    std::cout << "Enter the number of people the manager is in charge of: ";
    std::cin >> inchargeof;

    if (inchargeof < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        inchargeof = 0;
    }
}
fink::fink() : abstr_emp()
{
    reportsto = "";
}
fink::fink(const std::string &fn, const std::string &ln, const std::string &j, const std::string &rpo) : abstr_emp(fn, ln, j)
{
    reportsto = rpo;
}
fink::fink(const abstr_emp &e, const std::string &rpo) : abstr_emp(e)
{
    reportsto = rpo;
}
fink::fink(const fink &e) : abstr_emp(e)
{
    reportsto = e.reportsto;
}
void fink::ShowAll() const
{
    std::cout << "Status: fink" << std::endl;
    abstr_emp::ShowAll();
    std::cout << "Reports to " << reportsto << std::endl;
}
void fink::SetAll()
{
    abstr_emp::SetAll();
    std::cout << "Enter whomever is reported to: ";
    std::getline(std::cin, reportsto, '\n');
}

highfink::highfink() : abstr_emp(), manager(), fink()
{
}
highfink::highfink(const std::string &fn, const std::string &ln, const std::string &j, const std::string &rpo, int ico) :
    abstr_emp(fn, ln, j), manager(fn, ln, j, ico), fink(fn, ln, j, rpo)
{

}
highfink::highfink(const abstr_emp &e, const std::string &rpo, int ico) : abstr_emp(e), manager(e, ico), fink(e, rpo)
{

}
highfink::highfink(const fink &f, int ico) : abstr_emp(f), manager(f, ico), fink(f)
{

}
highfink::highfink(const manager &m, const std::string &rpo) : abstr_emp(m), manager(m), fink(m, rpo)
{

}
highfink::highfink(const highfink &h) : abstr_emp(h), manager(h), fink(h)
{

}
void highfink::ShowAll() const
{
    std::cout << "Status: Highfink" << std::endl;
    abstr_emp::ShowAll();
    std::cout << "In charge of " << InChargeOf() << " people" << std::endl;
    std::cout << "Reports to " << ReportsTo() << std::endl;
}
void highfink::SetAll()
{
    abstr_emp::SetAll();
    std::cout << "Enter the number of people managed: ";
    std::cin >> InChargeOf();

    if (InChargeOf() < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        InChargeOf() = 0;
    }
    while (std::cin.get() != '\n')
    {
        continue;
    }

    std::cout << "Enter whomever is reported to: ";
    std::getline(std::cin, ReportsTo(), '\n');
}

ch14_p05.cpp
#include <iostream>
#include "emp.h"

int main()
{
    employee em("Trip", "Harris", "Thumper");
    std::cout << em << std::endl;
    em.ShowAll();

    std::cout << std::endl;

    manager ma("Amorphia", "Spindragon", "Nuancer", 5);
    std::cout << ma << std::endl;
    ma.ShowAll();

    std::cout << std::endl;

    fink fi("Matt", "Oggs", "Oiler", "Juno Barr");
    std::cout << fi << std::endl;
    fi.ShowAll();

    std::cout << std::endl;

    highfink hf(ma, "Curly Kew");
    hf.ShowAll();

    std::cout << std::endl;

    highfink hf2;
    hf2.SetAll();
    hf2.ShowAll();

    std::cout << std::endl;

    std::cout << "Using an abstr_emp * pointer:\n";

    abstr_emp *tri[4] = { &em, &fi, &hf, &hf2 };
    for (int i = 0; i < 4; i++)
    {
        tri[i]->ShowAll();
        std::cout << std::endl;
    }

    return 0;
}
显示结果如下
Harris, Trip : Thumper
Status: Employee
First name: Trip
Last name: Harris
Job: Thumper

Spindragon, Amorphia : Nuancer
Status: Manager
First name: Amorphia
Last name: Spindragon
Job: Nuancer
In charge of 5 people

Oggs, Matt : Oiler
Status: fink
First name: Matt
Last name: Oggs
Job: Oiler
Reports to Juno Barr

Status: Highfink
First name: Amorphia
Last name: Spindragon
Job: Nuancer
In charge of 5 people
Reports to Curly Kew

Enter first name: Mike
Enter last name: Pence
Enter the job: Apple
Enter the number of people managed: 8
Enter whomever is reported to: Peter Smith
Status: Highfink
First name: Mike
Last name: Pence
Job: Apple
In charge of 8 people
Reports to Peter Smith

Using an abstr_emp * pointer:
Status: Employee
First name: Trip
Last name: Harris
Job: Thumper

Status: fink
First name: Matt
Last name: Oggs
Job: Oiler
Reports to Juno Barr

Status: Highfink
First name: Amorphia
Last name: Spindragon
Job: Nuancer
In charge of 5 people
Reports to Curly Kew

Status: Highfink
First name: Mike
Last name: Pence
Job: Apple
In charge of 8 people
Reports to Peter Smith

第15章 友元、异常和其他
15.1 友元
15.1.1 友元类
15.1.2 友元成员函数
15.1.3 其他友元关系
15.1.4 共同的友元
15.2 嵌套类
15.2.1 嵌套类和访间权限
15.2.2 模板中的嵌套
15.3 异常
15.3.1 调用abort
15.3.2 返回错误码
1533 异常机制
15.3.4 将对象用作异常类型
15.3.5 异常规范和C++11
15.3.6 栈解退
15.3.7 其他异常特性
15.3.8 exception类
15.3.9 异常、类和继承
15.3.10 异常何时会迷失方向
15.3.11 有关异常的注意事项
15.4 RTTI
15.4.1 RTTI的用途
15.4.2 RTTI的工作原理
15.5 类型转换运算符
15.6 总结
15.7 复习题
15.8 编程练习
本章内容包括：
友元类。
友元类方法。
嵌套类。
引发异常、try块和catch块。
异常类。
运行阶段类型识别（RTTI）。
dynamic_cast和typeid。
static_cast、const_cast和reinterpret_cast。
可以将类作为友元，在这种情况下，友元类的所有方法都可以访问原始类的私有成员和保护成员。
另外，也可以只将特定的成员函数指定为另一个类的友元。
假设需要编写一个模拟电视机和遥控器的简单程序。Tv类和Remote类分别表示电视机和遥控器。
遥控器并非电视机，反之亦然，所以公有继承的is-a关系并不适用。
遥控器也非电视机的一部分，反之亦然，因此包含或私有继承和保护继承的has-a关系也不适用。
事实上，遥控器可以改变电视机的状态，这表明应将Romote类作为Tv类的一个友元。
下面的语句使Remote成为友元类：
friend class Remote;
友元声明可以位于公有、私有或保护部分，其所在的位置无关紧要。
由于Remote类提到了Tv类，所以编译器必须了解Tv类后，才能处理Remote类，为此，最简单的方法是首先定义Tv类。
也可以使用前向声明（forward delaration），这将稍后介绍。
程序清单15.1 tv.h
#ifndef TV_H_
#define TV_H_

class Tv
{
public:
    friend class Remote;
    enum { Off, On };
    enum { MinVal, MaxVal = 20 };
    enum { Antenna, Cable };
    enum { TV, DVD };

    Tv(int s = Off, int mc = 125) : state(s), volume(5), maxchannel(mc), channel(2), mode(Cable), input(TV) {}
    void onoff()
    {
        state = (state == On) ? Off : On;
    }
    bool ison() const
    {
        return state == On;
    }
    bool volup();
    bool voldown();
    void chanup();
    void chandown();
    void set_mode()
    {
        mode = (mode == Antenna) ? Cable : Antenna;
    }
    void set_input()
    {
        input = (input == TV) ? DVD : TV;
    }
    void settings() const;
private:
    int state;
    int volume;
    int maxchannel;
    int channel;
    int mode;
    int input;
};

class Remote
{
private:
    int mode;
public:
    Remote(int m = Tv::TV) : mode(m) {}
    bool volup(Tv &t)
    {
        return t.volup();
    }
    bool voldown(Tv &t)
    {
        return t.voldown();
    }
    void onoff(Tv &t)
    {
        t.onoff();
    }
    void chanup(Tv &t)
    {
        t.chanup();
    }
    void chandown(Tv &t)
    {
        t.chandown();
    }
    void set_chan(Tv &t, int c)
    {
        t.channel = c;
    }
    void set_mode(Tv &t)
    {
        t.set_mode();
    }
    void set_input(Tv &t)
    {
        t.set_input();
    }
};

#endif

程序清单15.2 tv.cpp
#include <iostream>
#include "tv.h"

bool Tv::volup()
{
    if (volume < MaxVal)
    {
        volume++;
        return true;
    }
    else
    {
        return false;
    }
}

bool Tv::voldown()
{
    if (volume > MinVal)
    {
        volume--;
        return true;
    }
    else
    {
        return false;
    }
}

void Tv::chanup()
{
    if (channel < maxchannel)
    {
        channel++;
    }
    else
    {
        channel = 1;
    }
}

void Tv::chandown()
{
    if (channel > 1)
    {
        channel--;
    }
    else
    {
        channel = maxchannel;
    }
}

void Tv::settings() const
{
    using std::cout;
    using std::endl;
    cout << "TV is " << (state == Off ? "Off" : "On") << endl;
    if (state == On)
    {
        cout << "Volume setting = " << volume << endl;
        cout << "Channel setting = " << channel << endl;
        cout << "Mode = " << (mode == Antenna ? "antenna" : "cable") << endl;
        cout << "Input = " << (input == TV ? "TV" : "DVD") << endl;
    }
}

程序清单15.3 use_tv.cpp
#include <iostream>
#include "tv.h"

int main()
{
    using std::cout;

    Tv s42;

    cout << "Initial settings for s42\" TV:\n";
    s42.settings();
    s42.onoff();
    s42.chanup();

    cout << "\nAdjusted settings for s42\" TV:\n";
    s42.settings();

    Remote grey;

    grey.set_chan(s42, 10);
    grey.volup(s42);
    grey.volup(s42);
    cout << "\ns42\" settings after using remote:\n";
    s42.settings();

    Tv s58(Tv::On);
    s58.set_mode();
    grey.set_chan(s58, 28);
    cout << "\ns58\" settings:\n";
    s58.settings();

    return 0;
}
显示结果如下
Initial settings for s42" TV:
TV is Off

Adjusted settings for s42" TV:
TV is On
Volume setting = 5
Channel setting = 3
Mode = cable
Input = TV

s42" settings after using remote:
TV is On
Volume setting = 7
Channel setting = 10
Mode = cable
Input = TV

s58" settings:
TV is On
Volume setting = 5
Channel setting = 28
Mode = antenna
Input = TV

可以选择仅让特定的类成员成为另一个类的友元，而不必让整个类成为友元。
让Remote:set_chan成为Tv类的友元的方法是，在Tv类声明中将其声明为友元：
class TV
{
public:
    friend void Remote::set_chan(Tv & t, int c);
    // ...
}
然而，要使编译器能够处理这条语句，它必须知道Remote的定义。
否则，它无法知道Remote是一个类，而set_chan是这个类的方法。
这意味着应将Remote的定义放到Tv的定义前面。Remote的方法提到了Tv对象，而这意味着Tv定义应当位于Remote定义之前。
避开这种循环依赖的方法是，使用前向声明（forward declaration）。为此，需要在Remote定义的前面插入下面的语句：
class Tv;   //forward declaration
这样，排列次序应如下：
class Tv;   //forward declaration
class Remote
{
    // ...
};
class Tv
{
    // ...
};
能否像下面这样排列呢？
class Remote;   //forward declaration
class Tv
{
    // ...
};
class Remote
{
    // ...
};
答案是不能。原因在于，在编译器在Tv类的声明中看到Remote的一个方法被声明为Tv类的友元之前，
应该先看到Remote类的声明和set_chan方法的声明。
还有一个麻烦。程序清单15.1的Remote声明包含了内联代码，例如：
    void onoff(Tv &t)
    {
        t.onoff();
    }
由于这将调用Tv的一个方法，所以编译器此时必须已经看到了Tv类的声明，这样才能知道Tv有哪些方法，
但正如看到的，该声明位于Remote声明的后面。这种问题的解决方法是，使Remote声明中只包含方法声明，
并将实际的定义放在Tv类之后。这样，排列顺序将如下：
class Tv;   // forward declaration
class Remote    // Tv-using methods as prototypes only
{
    // ...
};
class Tv
{
    // ...
};
// put Remote method definitions here
程序清单15.4 tvfm.h
#ifndef TVFM_H_
#define TVFM_H_

class Tv;

class Remote
{
public:
	enum State { Off, On };
	enum { MinVal, MaxVal = 20 };
	enum { Antenna, Cable };
	enum { TV, DVD };
private:
	int mode;
public:
	Remote(int m = TV) : mode(m) {}
	bool volup(Tv & t);
	bool voldown(Tv & t);
	void onoff(Tv & t);
	void chanup(Tv & t);
	void chandown(Tv & t);
	void set_mode(Tv & t);
	void set_input(Tv & t);
	void set_chan(Tv & t, int c);
};

class Tv
{
public:
	friend void Remote::set_chan(Tv & t, int c);
	enum State { Off, On };
	enum { MinVal, MaxVal = 20 };
	enum { Antenna, Cable };
	enum { TV, DVD };

	Tv(int s = Off, int mc = 125) : state(s), volume(5), maxchannel(mc), channel(2), mode(Cable), input(TV) {}
	void onoff() { state = (state == On) ? Off : On; }
	bool ison() const { return state == On; }
	bool volup();
	bool voldown();
	void chanup();
	void chandown();
	void set_mode() { mode = (mode == Antenna) ? Cable : Antenna; }
	void set_input() { input = (input == TV) ? DVD : TV; }
	void settings() const;
private:
	int state;
	int volume;
	int maxchannel;
	int channel;
	int mode;
	int input;
};

inline bool Remote::volup(Tv & t) { return t.volup(); }
inline bool Remote::voldown(Tv & t) { return t.voldown(); }
inline void Remote::onoff(Tv & t) { t.onoff(); }
inline void Remote::chanup(Tv & t) { t.chanup(); }
inline void Remote::chandown(Tv & t) { t.chandown(); }
inline void Remote::set_mode(Tv & t) { t.set_mode(); }
inline void Remote::set_input(Tv & t) { t.set_input(); }
inline void Remote::set_chan(Tv & t, int c) { t.channel = c; }

#endif
显示结果如下
Initial settings for s42" TV:
TV is Off

Adjusted settings for s42" TV:
TV is On
Volume setting = 5
Channel setting = 3
Mode = cable
Input = TV

s42" settings after using remote:
TV is On
Volume setting = 7
Channel setting = 10
Mode = cable
Input = TV

s58" settings:
TV is On
Volume setting = 5
Channel setting = 28
Mode = antenna
Input = TV

如果在tv.cpp和use_tv.cpp中包含tvfm.h而不是tv.h，程序的行为与前一个程序相同，
区别在于，只有一个Remote方法是Tv类的友元，而在原来的版本中，所有的Remote方法都是Tv类的友元。
让整个Remote类成为友元并不需要前向声明，因为友元语句本身已经指出Remote是一个类：
friend class Remote;
可以通过让类彼此成为对方的友元，即Remote是Tv的友元，Tv也是Remote的友元。
需要记住的一点是，对于使用Remote对象的Tv方法，其原型可在Remote类声明之前声明，
但必须在Remote类声明之后定义，以便编译器有足够的信息来编译该方法。这种方案与下面类似：
class Tv
{
public:
    friend class Remote;
    void buzz (Remote & r);
    // ...
};
class Remote
{
public:
    friend class Tv;
    bool volup(Tv &t)
    {
        return t.volup();
    }
    // ...
};
inline void Tv::buzz(Remote & r)
{
    // ...
}
由于Remote的声明位于Tv声明的后面，所以可以在类声明中定义Remote::volup，
但T::buzz方法必须在Tv声明的外部定义，使其位于Remote声明的后面。
如果不希望buzz是内联的，则应在一个单独的方法定义文件中定义它。
如果函数需要访问两个类的私有数据，将函数作为两个类的友元更合理。
例如，假定有一个Probe类和一个Analyzer类，前者表示某种可编程的测量设备，后者表示某种可编程的分析设备。
这两个类都有内部时钟，且希望它们能够同步，则应该包含下述代码行：
class Analyzer;
class Probe
{
public:
    friend void sync (Analyzer & a, Probe & p);
    friend void sync (Probe & p, Analyzer & a);
    // ...
};
class Analyzer
{
public:
    friend void sync (Analyzer & a, Probe & p);
    friend void sync (Probe & p, Analyzer & a);
    // ...
};
inline void sync (Analyzer & a, Probe & p)
{
    // ...
}
inline void sync (Probe & p, Analyzer & a)
{
    // ...
}
可以将类声明放在另一个类中，在另一个类中声明的类被称为嵌套类（nested class）。
包含类的成员函数可以创建和使用被嵌套类的对象；而仅当声明位于公有部分，
才能在包含类的外面使用嵌套类，而且必须使用作用域解析运算符。
对类进行嵌套与包含并不同。包含意味着将类对象作为另一个类的成员，
而对类进行嵌套不创建类成员，而是定义了一种类型，该类型仅在包含嵌套类声明的类中有效。
对类进行嵌套通常是为了帮助实现另一个类，并避免名称冲突。
如果嵌套类是在另一个类的私有部分声明的，则只有后者知道它。
如果嵌套类是在另一个类的保护部分声明的，则它对于后者、后者的派生类来说是可见的，但是对于外部世界则是不可见的。
如果嵌套类是在另一个类的公有部分声明的，则允许后者、后者的派生类以及外部世界使用它，因为它是公有的。
然而，由于嵌套类的作用域为包含它的类，因此在外部世界使用它时，必须使用类限定符。
表15.1 嵌套类、结构和枚举的作用域特征
声明位置         包含它的类是否可以使用它         从包含它的类派生而来的类是否可以使用它         在外部是否可以使用
私有部分           是                                                      否                                                               否
保护部分           是                                                      是                                                               否
公有部分           是                                                      是                                                               是，通过类限定符来使用
对嵌套类访问权的控制规则与对常规类相同。
总之，类声明的位置决定了类的作用域或可见性。
类可见后，访问控制规则（公有、保护、私有、友元）将决定程序对嵌套类成员的访问权限。
程序清单15.5 queuetp2.h
#ifndef QUEUETP2_H_
#define QUEUETP2_H_

template <typename T>
class QueueTP
{
private:
    enum { Q_SIZE = 10 };
    class Node
    {
    public:
        T item;
        Node *next;
        Node(const T &i) : item(i), next(nullptr) { }
    };
    Node *front;
    Node *rear;
    int items;
    const int qsize;
    QueueTP(const QueueTP &q) : qsize(0) {}
    QueueTP &operator=(const QueueTP &q)
    {
        return *this;
    }
public:
    QueueTP(int qs = Q_SIZE);
    ~QueueTP();
    bool isempty() const
    {
        return items == 0;
    }
    bool isfull() const
    {
        return items == qsize;
    }
    int queuecount() const
    {
        return items;
    }
    bool enqueue(const T &item);
    bool dequeue(T &item);
};

template <typename T>
QueueTP<T>::QueueTP(int qs) : qsize(qs)
{
    front = rear = nullptr;
    items = 0;
}

template <typename T>
QueueTP<T>::~QueueTP()
{
    Node *next;
    while (front != nullptr)
    {
        next = front->next;
        delete front;
        front = next;
    }
}
template <typename T>
bool QueueTP<T>::enqueue(const T &item)
{
    if (isfull())
    {
        return false;
    }
    Node *add = new Node(item);
    if (isempty())
    {
        front = add;
        rear = add;
    }
    else
    {
        rear->next = add;
        rear = add;

    }
    items++;
    return true;
}

template <typename T>
bool QueueTP<T>::dequeue(T &item)
{
    if (isempty())
    {
        return false;
    }
    item = front->item;
    Node *next = front->next;
    delete front;
    front = next;
    items--;
    if (items == 0)
    {
        front = rear = nullptr;
    }
    return true;
}

#endif

程序清单15.6 nested_class.cpp
#include <iostream>
#include <string>
#include "queuetp2.h"

int main()
{
    using std::string;
    using std::cin;
    using std::cout;

    QueueTP<string> cs(5);
    string temp;

    while (!cs.isfull())
    {
        cout << "Please enter your name. You will be "
             "served in the order of arrival.\n"
             "name: ";
        std::getline(cin, temp, '\n');
        cs.enqueue(temp);
    }
    cout << "The queue is full. Processing begins!\n";

    while (!cs.isempty())
    {
        cs.dequeue(temp);
        cout << "Now processing " << temp << "\n";
    }

    return 0;
}
显示结果如下
Please enter your name. You will be served in the order of arrival.
name: Peter Smith
Please enter your name. You will be served in the order of arrival.
name: Mike Pence
Please enter your name. You will be served in the order of arrival.
name: Hello World
Please enter your name. You will be served in the order of arrival.
name: Apple
Please enter your name. You will be served in the order of arrival.
name: Orange
The queue is full. Processing begins!
Now processing Peter Smith
Now processing Mike Pence
Now processing Hello World
Now processing Apple
Now processing Orange

程序清单15.7 error1.cpp
#include <iostream>
#include <cstdlib>

double hmean(double a, double b);

int main()
{
    double x, y, z;

    std::cout << "Enter two numbers <q to quit>: ";
    while (std::cin >> x && std::cin >> y)
    {
        z = hmean(x, y);
        std::cout << "Harmonic mean of " << x << " and " << y
                  << " is " << z << std::endl;
        std::cout << "Enter two numbers <q to quit>: ";
    }
    std::cout << "Done.\n";

    return 0;
}

double hmean(double a, double b)
{
    if (a == -b)
    {
        std::cout << "untenable arguments to hmean()\n";
        std::abort();
    }
    return (2.0 * a * b) / (a + b);
}
显示结果如下
Enter two numbers <q to quit>: 2.5 3.5
Harmonic mean of 2.5 and 3.5 is 2.91667
Enter two numbers <q to quit>: 3 3
Harmonic mean of 3 and 3 is 3
Enter two numbers <q to quit>: 5 2
Harmonic mean of 5 and 2 is 2.85714
Enter two numbers <q to quit>: 3 -3
untenable arguments to hmean()
Aborted (core dumped)

程序清单15.8 error2.cpp
#include <iostream>
#include <cfloat>

bool hmean(double a, double b, double *ans);

int main()
{
    double x, y, z;

    std::cout << "Enter two numbers <q to quit>: ";
    while (std::cin >> x && std::cin >> y)
    {
        if (hmean(x, y, &z))
        {
            std::cout << "Harmonic mean of " << x << " and " << y
                      << " is " << z << std::endl;
        }
        else
        {
            std::cout << "One value should not be the negative "
                      << "of the other - try again.\n";
        }
        std::cout << "Enter two numbers <q to quit>: ";
    }
    std::cout << "Done.\n";

    return 0;
}

bool hmean(double a, double b, double *ans)
{
    if (a == -b)
    {
        *ans = DBL_MAX;
        return false;
    }
    else
    {
        *ans = (2.0 * a * b) / (a + b);
        return true;
    }
}
显示结果如下
Enter two numbers <q to quit>: 3 5
Harmonic mean of 3 and 5 is 3.75
Enter two numbers <q to quit>: 3 -3
One value should not be the negative of the other - try again.
Enter two numbers <q to quit>: 5 3
Harmonic mean of 5 and 3 is 3.75
Enter two numbers <q to quit>: 5 2
Harmonic mean of 5 and 2 is 2.85714
Enter two numbers <q to quit>: q
Done.

程序清单15.9 error3.cpp
#include <iostream>
#include <cfloat>

double hmean(double a, double b);

int main()
{
    double x, y, z;

    std::cout << "Enter two numbers <q to quit>: ";
    while (std::cin >> x && std::cin >> y)
    {
        try
        {
            z = hmean(x, y);
        }
        catch (const char *s)
        {
            std::cout << s << std::endl;
            std::cout << "Enter two numbers <q to quit>: ";
            continue;
        }
        std::cout << "Harmonic mean of " << x << " and " << y
                  << " is " << z << std::endl;
        std::cout << "Enter two numbers <q to quit>: ";
    }
    std::cout << "Done.\n";

    return 0;
}

double hmean(double a, double b)
{
    if (a == -b)
    {
        throw "bad hmean() arguments: a = -b not allowed";
    }
    return (2.0 * a * b) / (a + b);
}
显示结果如下
Enter two numbers <q to quit>: 3 5
Harmonic mean of 3 and 5 is 3.75
Enter two numbers <q to quit>: 2 5
Harmonic mean of 2 and 5 is 2.85714
Enter two numbers <q to quit>: 3 -3
bad hmean() arguments: a = -b not allowed
Enter two numbers <q to quit>: 5 2
Harmonic mean of 5 and 2 is 2.85714
Enter two numbers <q to quit>: q
Done.

异常类型可以是字符串（就像这个例子中那样）或其他C++类型；通常为类类型。
double hmean(double a, double b)
{
    if (a == -b)
    {
        throw "bad hmean() arguments: a = -b not allowed";
    }
    return (2.0 * a * b) / (a + b);
}
执行throw语句类似于执行返回语句，但throw不是将控制权返回给调用程序，而是导致程序沿函数调用序列后退，直到找到包含try块的函数。
        try
        {
            z = hmean(x, y);
        }
        catch (const char *s)
        {
            std::cout << s << std::endl;
            std::cout << "Enter two numbers <q to quit>: ";
            continue;
        }
关键字catch表明这是一个处理程序，而const char * s则表明该处理程序与字符串异常匹配。当异常与该处理程序匹配时，程序将执行括号中的代码。
执行完try块中的语句后，如果没有引发任何异常，则程序跳过try块后面的catch块，直接执行处理程序后面的第一条语句。
通常，引发异常的函数将传递一个对象。这样做的重要优点之一是，可以使用不同的异常类型来区分不同的函数在不同情况下引发的异常。
另外，对象可以携带信息，程序员可以根据这些信息来确定引发异常的原因。同时，catch块可以根据这些信息来决定采取什么样的措施。
程序清单15.10 exc_mean.h
#ifndef EXC_MEAN_H_
#define EXC_MEAN_H_
#include <iostream>

class bad_hmean
{
private:
    double v1;
    double v2;
public:
    bad_hmean(double a = 0, double b = 0) : v1(a), v2(b) {}
    void mesg();
};

inline void bad_hmean::mesg()
{
    std::cout << "hmean(" << v1 << ", " << v2 << "): "
              << "invalid arguments: a = -b\n";
}

class bad_gmean
{
public:
    double v1;
    double v2;
    bad_gmean(double a = 0, double b = 0) : v1(a), v2(b) {}
    const char *mesg();
};

inline const char *bad_gmean::mesg()
{
    return "gmean() arguments should be >= 0\n";
}
#endif

程序清单15.11 error4.cpp
#include <iostream>
#include <cmath>
#include "exc_mean.h"

double hmean(double a, double b);
double gmean(double a, double b);

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;

    double x, y, z;

    cout << "Enter two numbers <q to quit>: ";
    while (cin >> x && cin >> y)
    {
        try
        {
            z = hmean(x, y);
            cout << "Harmonic mean of " << x << " and " << y
                 << " is " << z << endl;
            cout << "Geometric mean of " << x << " and " << y
                 << " is " << gmean(x, y) << endl;
            cout << "Enter two numbers <q to quit>: ";
        }
        catch (bad_hmean &bg)
        {
            bg.mesg();
            cout << "Enter two numbers <q to quit>: ";
            continue;
        }
        catch (bad_gmean &hg)
        {
            cout << hg.mesg();
            cout << "Values used: " << hg.v1 << ", " << hg.v2 << endl;
            cout << "Sorry, you don't get to play any more.\n";
            break;
        }
    }
    cout << "Done.\n";

    return 0;
}

double hmean(double a, double b)
{
    if (a == -b)
    {
        throw bad_hmean(a, b);
    }
    return (2.0 * a * b) / (a + b);
}

double gmean(double a, double b)
{
    if (a < 0 || b < 0)
    {
        throw bad_gmean(a, b);
    }
    return std::sqrt(a * b);
}
显示结果如下
Enter two numbers <q to quit>: 2 5
Harmonic mean of 2 and 5 is 2.85714
Geometric mean of 2 and 5 is 3.16228
Enter two numbers <q to quit>: 3 5
Harmonic mean of 3 and 5 is 3.75
Geometric mean of 3 and 5 is 3.87298
Enter two numbers <q to quit>: 3 -3
hmean(3, -3): invalid arguments: a = -b
Enter two numbers <q to quit>: 5 2
Harmonic mean of 5 and 2 is 2.85714
Geometric mean of 5 and 2 is 3.16228
Enter two numbers <q to quit>: 5 -2
Harmonic mean of 5 and -2 is -6.66667
Geometric mean of 5 and -2 is gmean() arguments should be >= 0
Values used: 5, -2
Sorry, you don't get to play any more.
Done.

假设函数由于出现异常（而不是由于返回）而终止，则程序将释放栈中的内存，但不会在释放栈的第一个返回地址后停止，而是继续释放栈，
直到找到一个位于try块（参见图15.3）中的返回地址。随后，控制权将转到块尾的异常处理程序，而不是函数调用后面的第一条语句。这个过程被称为栈解退。
和函数返回一样，对于栈中的自动类对象，类的析构函数将被调用。然而，函数返回仅仅处理该函数放在栈中的对象，
而throw 语句则处理try块和throw之间整个函数调用序列放在栈中的对象。
如果没有栈解退这种特性，则引发异常后，对于中间函数调用放在栈中的自动类对象，其析构函数将不会被调用。
程序清单15.12 error5.cpp
#include <iostream>
#include <string>
#include <cmath>
#include "exc_mean.h"

class demo
{
private:
    std::string word;
public:
    demo(const std::string &str)
    {

        word = str;
        std::cout << "demo " << word << " created\n";
    }
    ~demo()
    {
        std::cout << "demo " << word << " destroyed\n";
    }
    void show() const
    {
        std::cout << "demo " << word << " lives!\n";
    }
};

double hmean(double a, double b);
double gmean(double a, double b);
double means(double a, double b);

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;

    double x, y, z;
    {
        demo d1("found in block in main()");
        cout << "Enter two numbers <q to quit>: ";
        while (cin >> x && cin >> y)
        {
            try
            {
                z = means(x, y);
                cout << "The mean mean of " << x << " and " << y
                     << " is " << z << endl;
                cout << "Enter two numbers <q to quit>: ";
            }
            catch (bad_hmean &bg)
            {
                bg.mesg();
                cout << "Enter two numbers <q to quit>: ";
                continue;
            }
            catch (bad_gmean &hg)
            {
                cout << hg.mesg();
                cout << "Values used: " << hg.v1 << ", " << hg.v2 << endl;
                cout << "Sorry, you don't get to play any more.\n";
                break;
            }
        }
        d1.show();
    }
    cout << "Done.\n";

    return 0;
}
double hmean(double a, double b)
{
    if (a == -b)
    {
        throw bad_hmean(a, b);
    }
    return (2.0 * a * b) / (a + b);
}

double gmean(double a, double b)
{
    if (a < 0 || b < 0)
    {
        throw bad_gmean(a, b);
    }
    return std::sqrt(a * b);
}

double means(double a, double b)
{
    double am, hm, gm;
    demo d2("found in means()");
    am = (a + b) / 2.0;
    try
    {
        hm = hmean(a, b);
        gm = gmean(a, b);
    }
    catch (bad_hmean &bg)
    {
        bg.mesg();
        std::cout << "Caught in means()\n";
        throw;
    }
    d2.show();
    return (am + hm + gm) / 3.0;
}
显示结果如下
demo found in block in main() created
Enter two numbers <q to quit>: 2 5
demo found in means() created
demo found in means() lives!
demo found in means() destroyed
The mean mean of 2 and 5 is 3.17314
Enter two numbers <q to quit>: 3 5
demo found in means() created
demo found in means() lives!
demo found in means() destroyed
The mean mean of 3 and 5 is 3.87433
Enter two numbers <q to quit>: 3 -3
demo found in means() created
hmean(3, -3): invalid arguments: a = -b
Caught in means()
demo found in means() destroyed
hmean(3, -3): invalid arguments: a = -b
Enter two numbers <q to quit>: 5 2
demo found in means() created
demo found in means() lives!
demo found in means() destroyed
The mean mean of 5 and 2 is 3.17314
Enter two numbers <q to quit>: 5 -3
demo found in means() created
demo found in means() destroyed
gmean() arguments should be >= 0
Values used: 5, -3
Sorry, you don't get to play any more.
demo found in block in main() lives!
demo found in block in main() destroyed
Done.

    catch (bad_hmean &bg)
    {
        bg.mesg();
        std::cout << "Caught in means()\n";
        throw;
    }
catch块中的throw 语句导致函数means终止执行，并将异常传递给main函数。
means函数被提前终止，但还是为d2调用了析构函数。
程序进行栈解退以回到能够捕获异常的地方时，将释放栈中的自动存储型变量。如果变量是类对象，将为该对象调用析构函数。
重新引发的异常被传递给main函数，在该函数中，合适的catch块将捕获它并对其进行处理。
虽然throw-catch机制类似于函数参数和函数返回机制，但还是有些不同之处。
其中之一是函数fun中的返回语句将控制权返回到调用fun的函数，但throw语句将控制权向上返回到第一个这样的函数：包含能够捕获相应异常的try-catch组合。
另一个不同之处是，引发异常时编译器总是创建一个临时拷贝，即使catch块中指定的是引用。
因为函数执行完毕后，临时的异常对象将不复存在。
double hmean(double a, double b)
{
    if (a == -b)
    {
        throw bad_hmean(a, b);
    }
    return (2.0 * a * b) / (a + b);
}

double gmean(double a, double b)
{
    if (a < 0 || b < 0)
    {
        throw bad_gmean(a, b);
    }
    return std::sqrt(a * b);
}
引用有一个重要特征：基类引用可以执行派生类对象。
使用基类引用将能够捕获基类及派生类的对象；
而使用派生类对象只能捕获派生类及派生类的派生类的对象。
引发的异常对象将被第一个与之匹配的catch块捕获。这意味着catch块的排列顺序应该与派生顺序相反。
如果有一个异常类继承层次结构，应这样排列catch块：
将捕获位于层次结构最下面的异常类的catch语句放在最前面，将捕获基类异常的catch语句放在最后面。
通过正确地排列catch块的顺序，让您能够在如何处理异常方面有选择的余地。
然而，有时候可能不知道会发生哪些异常。在这种情况下，仍能够捕获异常，即使不知道异常的类型。
方法是使用省略号来表示异常类型，从而捕获任何异常：
catch (...)
{
    // ...
}
如果知道一些可能会引发的异常，可以将上述捕获所有异常的catch块放在最后面，这有点类似于switch语句中的default。
可以创建捕获对象而不是引用的处理程序。在catch语句中使用基类对象时，将捕获所有的派生类对象，
但派生特性将被剥去，因此将使用虚方法的基类版本。

exception头文件定义了exception类，可以把它用作其他异常类的基类。
exception类有一个名为what的虚拟成员函数，它返回一个字符串，可以在从exception派生而来的类中重新定义它。
stdexcept头文件定义了其他几个异常类，它们都是以公有方式从exception派生而来的。
异常类系列logic_error描述了典型的逻辑错误。每个类的名称指出了它用于报告的错误类型：
domain_error；
invalid_argument
length_error；
out_of_bounds。
每个类独有一个类似于logic_error的构造函数，让您能够提供一个供方法what返回的字符串。
异常类系列runtime_error描述了可能在运行期间发生但难以预计和防范的错误。每个类的名称指出了它用于报告的错误类型：
range_error;
overflow_error；
underflow_error。
一般而言，logic_error系列异常表明存在可以通过编程修复的问题，而runtime_error系列异常表明存在无法避免的问题。
所有这些错误类有相同的常规特征，它们之间的主要区别在于：不同的类名让您能够分别处理每种异常。
另一方面，继承关系让您能够一起处理它们（如果您愿意的话）。
对于使用new导致的内存分配问题，C++的最新处理方式是让new引发bad_alloc异常。
头文件new包含bad_alloc类的声明，它是从exception类公有派生而来的。
程序清单15.13 newexcp.cpp
#include <iostream>
#include <new>
#include <cstdlib>

using namespace std;

struct Big
{
    double stuff[20000];
};

int main()
{
    Big *pb;
    try
    {
        cout << "Trying to get a big block of memory:\n";
        pb = new Big[10000];
        cout << "Got past the new request:\n";
    }
    catch (bad_alloc &ba)
    {
        cout << "Caught the exception!\n";
        cout << ba.what() << endl;
        exit(EXIT_FAILURE);
    }
    cout << "Memory successfully allocated\n";
    pb[0].stuff[0] = 4;
    cout << pb[0].stuff[0] << endl;
    delete [] pb;

    return 0;
}

C++标准提供了一种在失败时返回空指针的new，其用法如下
int * p1 = new (std::nothrow) int;
int * pa = new (std::nothrow) int[500];
异常规范和C++11
double harm (double a) throw (bad_thing);   // may throw bad_thing exception
double marm (double) throw ();   // doesn't throw an exception
其中的throw()部分就是异常规范，它可能出现在函数原型和函数定义中，可包含类型列表；也可不包含。
异常规范的作用之一是，告诉用户可能需要使用try块。然而，这项工作也可使用注释轻松地完成。
异常规范的另一个作用是，让编译器添加执行运行阶段检查的代码，检查是否违反了异常规范。这很难检查。
例如，marm可能不会引发异常，但它可能调用一个函数，而这个函数调用的另一个函数引发了异常。
另外，您给函数编写代码时它不会引发异常，但库更新后它却会引发异常。
总之，编程社区（尤其是尽力编写安全代码的开发人员）达成的一致意见是，最好不要使用这项功能。
而C++11也建议您忽略异常规范。然而；C++11确实支持一种特殊的异常规范：
您可使用新增的关键字noexcept指出函数不会引发异常
double marm(double) noexcept;   // doesn't throw an exception
还有运算符noexcept()，它判断其操作数是否会引发异常。
程序清单15.14 sales2.h
#ifndef SALES2_H_
#define SALES2_H_
#include <stdexcept>
#include <string>

class Sales
{
public:
    enum { MONTHS = 12 };
    class bad_index : public std::logic_error
    {
    private:
        int bi;
    public:
        explicit bad_index(int ix, const std::string &s = "Index error in Sales object\n");
        int bi_val() const
        {
            return bi;
        }
        virtual ~bad_index() {}
    };
    explicit Sales(int yy = 0);
    Sales(int yy, const double *gr, int n);
    virtual ~Sales() { }
    int Year() const
    {
        return year;
    }
    virtual double operator[](int i) const;
    virtual double &operator[](int i);
private:
    double gross[MONTHS];
    int year;
};

class LabeledSales : public Sales
{
public:
    class nbad_index : public Sales::bad_index
    {
    private:
        std::string lbl;
    public:
        nbad_index(const std::string &lb, int ix, const std::string &s = "Index error in LabeledSales object\n");
        const std::string &label_val() const
        {
            return lbl;
        }
        virtual ~nbad_index() {}
    };
    explicit LabeledSales(const std::string &lb = "none", int yy = 0);
    LabeledSales(const std::string &lb, int yy, const double *gr, int n);
    virtual ~LabeledSales() { }
    const std::string &Label() const
    {
        return label;
    }
    virtual double operator[](int i) const;
    virtual double &operator[](int i);
private:
    std::string label;
};

#endif

程序清单15.15 sales2.cpp
#include <iostream>
#include "sales2.h"

using std::string;

Sales::bad_index::bad_index(int ix, const string &s) : std::logic_error(s), bi(ix)
{
}
Sales::Sales(int yy)
{
    year = yy;
    for (int i = 0; i < MONTHS; ++i)
    {
        gross[i] = 0;
    }
}

Sales::Sales(int yy, const double *gr, int n)
{
    year = yy;
    int lim = (n < MONTHS) ? n : MONTHS;
    int i;
    for (i = 0; i < lim; ++i)
    {
        gross[i] = gr[i];
    }
    for (; i < MONTHS; ++i)
    {
        gross[i] = 0;
    }
}
double Sales::operator[](int i) const
{
    if (i < 0 || i >= MONTHS)
    {
        throw bad_index(i);
    }
    return gross[i];
}

double &Sales::operator[](int i)
{
    if (i < 0 || i >= MONTHS)
    {
        throw bad_index(i);
    }
    return gross[i];
}

LabeledSales::nbad_index::nbad_index(const string &lb, int ix, const string &s) : Sales::bad_index(ix, s)
{
    lbl = lb;
}
LabeledSales::LabeledSales(const string &lb, int yy) : Sales(yy)
{
    label = lb;
}
LabeledSales::LabeledSales(const string &lb, int yy, const double *gr, int n) : Sales(yy, gr, n)
{
    label = lb;
}
double LabeledSales::operator[](int i) const
{
    if (i < 0 || i >= MONTHS)
    {
        throw nbad_index(Label(), i);
    }
    return Sales::operator[](i);
}
double &LabeledSales::operator[](int i)
{
    if (i < 0 || i >= MONTHS)
    {
        throw nbad_index(Label(), i);
    }
    return Sales::operator[](i);
}

程序清单15.16 use_sales2.cpp
#include <iostream>
#include "sales2.h"

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;

    double vals1[12] =
    {
        1220, 1100, 1122, 2212, 1232, 2334,
        2884, 2393, 3302, 2922, 3002, 3544
    };

    double vals2[12] =
    {
        12, 11, 22, 21, 32, 34,
        28, 29, 33, 29, 32, 35
    };

    Sales sales1(2011, vals1, 12);
    LabeledSales sales2("Blogstar", 2012, vals2, 12);

    cout << "First try block:\n";
    try
    {
        int i;
        cout << "Year = " << sales1.Year() << endl;
        for (i = 0; i < 12; ++i)
        {

            cout << sales1[i] << ' ';
            if (i % 6 == 5)
            {
                cout << endl;
            }
        }
        cout << "Year = " << sales2.Year() << endl;
        cout << "Label = " << sales2.Label() << endl;
        for (i = 0; i <= 12; ++i)
        {

            cout << sales2[i] << ' ';
            if (i % 6 == 5)
            {
                cout << endl;
            }
        }
        cout << "End of try block 1.\n";
    }
    catch (LabeledSales::nbad_index &bad)
    {
        cout << bad.what();
        cout << "Company: " << bad.label_val() << endl;
        cout << "bad index: " << bad.bi_val() << endl;
    }
    catch (Sales::bad_index &bad)
    {
        cout << bad.what();
        cout << "bad index: " << bad.bi_val() << endl;
    }
    cout << "\nNext try block:\n";
    try
    {
        sales2[2] = 37.5;
        sales1[20] = 23345;
        cout << "End of try block 2.\n";
    }
    catch (LabeledSales::nbad_index &bad)
    {
        cout << bad.what();
        cout << "Company: " << bad.label_val() << endl;
        cout << "bad index: " << bad.bi_val() << endl;
    }
    catch (Sales::bad_index &bad)
    {
        cout << bad.what();
        cout << "bad index: " << bad.bi_val() << endl;
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
First try block:
Year = 2011
1220 1100 1122 2212 1232 2334
2884 2393 3302 2922 3002 3544
Year = 2012
Label = Blogstar
12 11 22 21 32 34
28 29 33 29 32 35
Index error in LabeledSales object
Company: Blogstar
bad index: 12

Next try block:
Index error in Sales object
bad index: 20
Done.

异常被引发后，在两种情况下，会导致问题。首先，如果它是在带异常规范的函数中引发的，则必须与规范列表中的某种异常匹配
（在继承层次结构中，类类型与这个类及其派生类的对象匹配），否则称为意外异常（unexpected exception）。
在默认情况下，这将导致程序异常终止（虽然C++11摒弃了异常规范，但仍支持它，且有些现有的代码使用了它）。
如果异常不是在函数中引发的（或者函数没有异常规范），则必须捕获它。
如果没被捕获（在没有try块或没有匹配的catch块时，将出现这种情况），则异常被称为未捕获异常（uncaught cxception）。
在默认情况下，这将导致程序异常终止。然而，可以修改程序对意外异常和未捕获异常的反应。下面来看如何修改，先从未捕获异常开始。
未捕获异常不会导致程序立刻异常终止。相反，程序将首先调用函数terminate。在默认情况下，terminate调用abort函数。
可以指定terminate应调用的函数来修改terminate的这种行为。为此，可调用set_terminate函数。
set_terminate和terminate都是在头文件exception中声明的。
如果发生意外异常，程序将调用unexpected函数。这个函数将调用terminate函数，后者在默认情况下将调用abort函数。
有一个可用于修改unexpected的行为的set_unexpected函数。这些新函数也是在头文件exception中声明的。
unexpected_handler函数可以：
●通过调用terminate（默认行为）、abort或exit来终止程序；
●引发异常。
引发异常（第二种选择）的结果取决于unexpected_handler函数所引发的异常以及引发意外异常的函数的异常规范：
如果新引发的异常与原来的异常规范匹配，则程序将从那里开始进行正常处理，即寻找与新引发的异常匹配的catch块。
基本上，这种方法将用预期的异常取代意外异常；
●如果新引发的异常与原来的异常规范不匹配，且异常规范中没有包括std::bad_exception 类型，则程序将调用terminate。
bad_exception是从ecxccption派生而来的，其声明位于头文件exception中；
●如果新引发的异常与原来的异常规范不匹配，且原来的异常规范中包含了std::bad_exception类型，
则不匹配的异常将被std::bad_exception异常所取代。
总之，如果要捕获所有的异常（不管是预期的异常还是意外异常），则可以这样做：
首先确保异常头文件的声明可用：
#include <exception>
using namespace std;
然后，设计一个替代函数，将意外异常转换为bad_exception异常，该函数的原型如下：
void myUnexpected()
{
    throw std::bad_exception();   // or just throw;
}
仅使用throw，而不指定异常将导致重新引发原来的异常。
如果异常规范中包含了std::bad_exception类型，则该异常将被bad_exception对象所取代。
接下来在程序的开始位置，调用set_unexpected函数：
set_unexpected (myUnexpected);
最后，将bad_exception 类型包括在异常规范中，并添加对应的catch块。
使用异常会增加程序代码，降低程序的运行速度。异常规范不适用于模板，因为模板函数引发的异常可能随特定的具体化而异。
异常和动态内存分配并非总能协同工作。
下面进一步讨论动态内存分配和异常。首先，请看下面的函数：
void test1(int n)
{
    string mesg ("I'm trapped in an endless looop");
    ...
    if (oh_no)
    {
        throw exception();
    }
    ...
}
string类采用动态内存分配。通常，当函数结束时，将为mesg调用string的析构函数。虽然throw语句过早地终止了函数，但它仍然使得析构函数被调用，这要归功于栈解退。因此在这里，内存被正确地管理。
接下来看下面这个函数：
void test2(int n)
{
    double * ar = new double[n];
    ...
    if (oh_no)
    {
        throw exception();
    }
    ...
    delete [] ar;
    ...
}
这里有个问题。解退栈时，将删除栈中的变量ar。但函数过早的终止意味着函数末尾的delete[]语句被忽略。
指针消失了，但它指向的内存块未被释放，并且不可访问。总之，这些内存被泄漏了。
这种泄漏是可以避免的。例如，可以在引发异常的函数中捕获该异常，在catch块中包含一些清理代码，然后重新引发异常：
void test3(int n)
{
    double * ar = new double[n];
    ...
    try
    {
        ...
        if (oh_no)
        {
            throw exception();
        }
        ...
    }
    catch (exception & ex)
    {
        delete [] ar;
        throw;
    }
    ...
    delete [] ar;
    ...
}
然而，这将增加疏忽和产生其他错误的机会。另一种解决方法是使用第16章将讨论的智能指针模板之一。
C++有3个支持RTTI的元素。
如果可能的话，dynamic_cast运算符将使用一个指向基类的指针来生成一个指向派生类的指针：否则，该运算符返回空指针。
typeid运算符返回一个指出对象的类型的值。
type_info结构存储了有关特定类型的信息。
只能将RTTI用于包含虚函数的类层次结构，原因在于只有对于这种类层次结构，才应该将派生对象的地址赋给基类指针。
警告：RTTI 只适用于包含虚函数的类。
下面详细介绍RTTI的这3个元素。
1.dynamic_cast 运算符
dynamic_cast 运算符是最常用的RTTI组件，它不能回答“指针指向的是哪类对象”这样的问题，
但能够回答“是否可以安全地将对象的地址赋给特定类型的指针”这样的问题。我们来看一看这意味着什么。
假设有下面这样的类层次结构：
class Grand {   // has virtual methods };
class Superb : public Grand { ... };
class Magnificent : public Superb { ... };
接下来假设有下面的指针：
Grand * pg = new Grand;
Grand * ps = new Superb;
Grand * pm = new Magnificent;
最后，对于下面的类型转换：
Magnificent * p1 = (Magnificent * ) pm;
Magnificent * p2 = (Magnificent * ) pg;
Superb * p3 = (Magnificent *) pm;
例如，类型转换1就是安全的，因为它将Magificent 类型的指针指向类型为Magnificent的对象。
类型转换2就是不安全的，因为它将基类对象（Grand）的地址赋给派生类（Magnificent）指针。
因为Magnificent对象可能包含一些Grand对象没有的数据成员。
然而，类型转换3是安全的，因为它将派生对象的地址赋给基类指针。即公有派生确保Magnificent对象同时也是一个Superb对象。
因此，将它的地址赋给这3种类型的指针都是安全的。
虚函数确保了将这3种指针中的任何一种指向Magnificent对象时，都将调用Magnificent方法。
注意，与问题“指针指向的是哪种类型的对象”相比，问题“类型转换是否安全”更通用，也更有用。
通常想知道类型的原因在于：知道类型后，就可以知道调用特定的方法是否安全。
要调用方法，类型并不一定要完全匹配，而可以是定义了方法的虚拟版本的基类类型。下面的例子说明了这一点。
程序清单15.17演示了这种处理。首先，它定义了3个类，名称为Grand、Superb和Magnificent。
Grand类定义了一个虚函数Speak，而其他类都重新定义了该虚函数。
Superb类定义了一个虚函数Say，而Magnificent也重新定义了它（参见图15.4）。
程序定义了GetOne函数，该函数随机创建这3种类中某种类的对象，并对其进行初始化，
然后将地址作为Grand *指针返回（GetOne函数模拟用户做出决定）。
循环将该指针赋给Grand *变量pg，然后使用pg调用Speak函数。
因为这个函数是虚拟的，所以代码能够正确地调用指向的对象的Speak版本。
然而，不能用相同的方式（即使用指向Grand的指针）来调用Say函数，因为Grand类没有定义它。
然而，可以使用dynamic_cast运算符来检查是否可将pg的类型安全地转换为Superb指针。
如果对象的类型为Superb或Magnificent，则可以安全转换。在这两种情况下，都可以安全地调用Say函数。
程序清单15.17 rtti1.cpp
#include <iostream>
#include <cstdlib>
#include <ctime>

using std::cout;

class Grand
{
private:
    int hold;
public:
    Grand(int h = 0) : hold(h) {}
    virtual void Speak() const
    {
        cout << "I am a grand class!\n";
    }
    virtual int Value() const
    {
        return hold;
    }
};

class Superb : public Grand
{
public:
    Superb(int h = 0) : Grand(h) {}
    void Speak() const
    {
        cout << "I am a superb class!!\n";
    }
    virtual void Say() const
    {
        cout << "I hold the superb value of " << Value() << "!\n";
    }
};

class Magnificent : public Superb
{
private:
    char ch;
public:
    Magnificent(int h = 0, char c = 'A') : Superb(h), ch(c) {}
    void Speak() const
    {
        cout << "I am a magnificent class!!!\n";
    }
    void Say() const
    {
        cout << "I hold the character " << ch <<
             " and the integer " << Value() << "!\n";
    }
};

Grand *GetOne();

int main()
{
    std::srand(std::time(nullptr));
    Grand *pg;
    Superb *ps;
    for (int i = 0; i < 5; i++)
    {
        pg = GetOne();
        pg->Speak();
        if ( (ps = dynamic_cast<Superb *>(pg) ) != nullptr)
        {
            ps->Say();
        }
    }

    return 0;
}
Grand *GetOne()
{
    Grand *p;
    switch (std::rand() % 3)
    {
    case 0:
        p = new Grand(std::rand() % 100);
        break;
    case 1:
        p = new Superb(std::rand() % 100);
        break;
    case 2:
        p = new Magnificent(std::rand() % 100, 'A' + std::rand() % 26);
        break;
    }
    return p;
}
显示结果如下
I am a superb class!!
I hold the superb value of 96!
I am a grand class!
I am a superb class!!
I hold the superb value of 20!
I am a magnificent class!!!
I hold the character M and the integer 47!
I am a superb class!!
I hold the superb value of 4!

typeid运算符使得能够确定两个对象是否为同种类型。它与sizeof有些相像，可以接受两种参数：
类名；
结果为对象的表达式。
typeid运算符返回一个type_info对象的引用，其中，type_info是在头文件typeinfo中定义的一个类。
type_info类重载了==和!=运算符，以便可以使用这些运算符来对类型进行比较。
例如，如果pg指向的是一个Magnificent对象，则下述表达式的结果为bool值true，否则为false：
typeid (Magnificent) == typeid (*pg)
如果pg是一个空指针，程序将引发bad_typeid异常。该异常类型是从exception类派生而来的，是在头文件typeinfo中声明的。
type_info类的实现随厂商而异，但包含一个name成员，该函数返回一个随实现而异的字符串，通常是类的名称。
程序清单15.18 rtti2.cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <typeinfo>

using namespace std;

class Grand
{
private:
    int hold;
public:
    Grand(int h = 0) : hold(h) {}
    virtual void Speak() const
    {
        cout << "I am a grand class!\n";
    }
    virtual int Value() const
    {
        return hold;
    }
};

class Superb : public Grand
{
public:
    Superb(int h = 0) : Grand(h) {}
    void Speak() const
    {
        cout << "I am a superb class!!\n";
    }
    virtual void Say() const
    {
        cout << "I hold the superb value of " << Value() << "!\n";
    }
};

class Magnificent : public Superb
{
private:
    char ch;
public:
    Magnificent(int h = 0, char cv = 'A') : Superb(h), ch(cv) {}
    void Speak() const
    {
        cout << "I am a magnificent class!!!\n";
    }
    void Say() const
    {
        cout << "I hold the character " << ch << " and the integer " << Value() << "!\n";
    }
};

Grand *GetOne();

int main()
{
    srand(time(nullptr));
    Grand *pg;
    Superb *ps;
    for (int i = 0; i < 5; i++)
    {
        pg = GetOne();
        cout << "Now processing type " << typeid(*pg).name() << ".\n";
        pg->Speak();
        if ( ( ps = dynamic_cast<Superb *>(pg) ) != nullptr )
        {
            ps->Say();
        }
        if (typeid(Magnificent) == typeid(*pg))
        {
            cout << "Yes, you're really magnificent.\n";
        }
    }

    return 0;
}

Grand *GetOne()
{
    Grand *p;

    switch (rand() % 3)
    {
    case 0:
        p = new Grand(rand() % 100);
        break;
    case 1:
        p = new Superb(rand() % 100);
        break;
    case 2:
        p = new Magnificent(rand() % 100, 'A' + rand() % 26);
        break;
    }
    return p;
}
显示结果如下
Now processing type 5Grand.
I am a grand class!
Now processing type 5Grand.
I am a grand class!
Now processing type 5Grand.
I am a grand class!
Now processing type 11Magnificent.
I am a magnificent class!!!
I hold the character O and the integer 5!
Yes, you're really magnificent.
Now processing type 5Grand.
I am a grand class!

Now processing type 6Superb.
I am a superb class!!
I hold the superb value of 39!
Now processing type 6Superb.
I am a superb class!!
I hold the superb value of 13!
Now processing type 5Grand.
I am a grand class!
Now processing type 5Grand.
I am a grand class!
Now processing type 5Grand.
I am a grand class!

1. static_cast
static_cast的转换格式：static_cast <type-id> (expression)
将expression转换为type-id类型，主要用于非多态类型之间的转换，不提供运行时的检查来确保转换的安全性。主要在以下几种场合中使用：
用于类层次结构中，基类和子类之间指针和引用的转换；
当进行上行转换，也就是把子类的指针或引用转换成父类表示，这种转换是安全的；
当进行下行转换，也就是把父类的指针或引用转换成子类表示，这种转换是不安全的，也需要程序员来保证；
用于基本数据类型之间的转换，如把int转换成char，把int转换成enum等等，这种转换的安全性需要程序员来保证；
把void指针转换成目标类型的指针，是及其不安全的；
static_cast不能用于在不同类型的指针之间互相转换，不能用于整型和指针之间的互相转换，不能用于不同类型的引用之间的转换。
static_cast不能转换掉expression的const、volatile等属性。
2. dynamic_cast
dynamic_cast的转换格式：dynamic_cast <type-id> (expression)
将expression转换为type-id类型，type-id必须是类的指针、类的引用或者是void *；
如果type-id是指针类型，那么expression也必须是一个指针；
如果type-id是一个引用，那么expression也必须是一个引用。
dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。
在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；
在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。
在多态类型（基类包含虚函数）之间的转换主要使用dynamic_cast，因为类型提供了运行时信息。
如果expression是type-id的基类，使用dynamic_cast进行转换时，在运行时就会检查expression是否真正的指向一个type-id类型的对象，
如果是，则能进行正确的转换，获得对应的值；否则返回空指针，如果是引用，则在运行时就会抛出异常。
dynamic_cast不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用――这种转换没法保证安全性，只好用reinterpret_cast来完成。
3.reinterpret_cast
reinterpret_cast的转换格式：reinterpret_cast<type-id> (expression)
type-id必须是一个指针、引用、算术类型、函数指针或者成员指针。
它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针
（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。
reinterpret_cast用于各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。
4.const_cast
const指针被转化成非const指针，并且仍然指向原来的对象；
const引用被转换成非const引用，并且仍然指向原来的对象；
const_cast的作用是用来改变表达式里面的常量性（const）或易变性（volatile）。
程序清单15.19 constcast.cpp
#include <iostream>

using std::cout;
using std::endl;

void change(const int *pt, int n);

int main()
{
    int pop1 = 38383;
    const int pop2 = 2000;

    cout << "pop1, pop2: " << pop1 << ", " << pop2 << endl;
    change(&pop1, -103);
    change(&pop2, -103);
    cout << "pop1, pop2: " << pop1 << ", " << pop2 << endl;

    return 0;
}
void change(const int *pt, int n)
{
    int *pc;

    pc = const_cast<int *>(pt);
    *pc += n;
}
显示结果如下
pop1, pop2: 38383, 2000
pop1, pop2: 38280, 2000

调用change时，修改了pop1，但没有修改pop2。在chang中，指针被声明为const int*，因此不能用来修改指向的int。
指针pc删除了const 特征，因此可用来修改指向的值，但仅当指向的值不是const时才可行。
因此，pc可用于修改pop1，但不能用于修改pop2。
15.6 总结
友元使得能够为类开发更灵活的接口。类可以将其他函数、其他类和其他类的成员函数作为友元。
在某些情况下，可能需要使用前向声明，需要特别注意类和方法声明的顺序，以正确地组合友元。
嵌套类是在其他类中声明的类，它有助于设计这样的助手类，即实现其他类，但不必是公有接口的组成部分。
C++异常机制为处理拙劣的编程事件，如不适当的值、I/O失败等，提供了一种灵活的方式。
引发异常将终止当前执行的函数，将控制权传给匹配的catch块。catch块紧跟在try块的后面，
为捕获异常，直接或间接导致异常的函数调用必须位于try块中。这样程序将执行catch块中的代码。
这些代码试图解决问题或终止程序。类可以包含嵌套的异常类，嵌套异常类在相应的问题被检查到时将被引发。
函数可以包含异常规范，指出在该函数中可能引发的异常：但C++11摒弃了这项功能。
未被捕获的异常（没有匹配的catch块的异常）在默认情况下将终止程序，意外异常（不与任何异常规范匹配的异常）也是如此。
RTTI（运行阶段类型信息）特性让程序能够检测对象的类型。
dynamic_cast运算符用于将派生类指针转换为基类指针，其主要用途是确保可以安全地调用虚函数。
Typeid 运算符返回一个type_info 对象。可以对两个typeid的返回值进行比较，以确定对象是否为特定的类型，而返回的type_jinfo 对象可用于获得关于对象的信息。
与通用转换机制相比，dynamic__cast、static_cast、const__cast 和reinterpret_cast提供了更安全、更明确的类型转换。
1.下面建立友元的尝试有什么错误？
a.class snap{
friend clasp；改为friend class clasp;
};
class clasp{...}；

b.
增加前向声明
class muff;

class cuff{
public:
    void snip (muff&) {...}
};
class muff{
friend void cuff::snip (muff&);
};

c.
把cuff类声明在muff类之前，同时在cuff类声明之前增加一个前向声明
class muff;

class cuff{
public:
    void snip (muff &) {...}
};
class muff{
friend void cuff::snip (muff&);
};

2.您知道了如何建立相互类友元的方法。能够创建一种更为严格的友情关系，
即类B只有部分成员是类A的友元，而类A只有部分成员是类B的友元吗？请解释原因。
不能
为使类A拥有一个本身为类B的成员函数的友元，B的声明必须位于A的声明之前。
一个前向声明是不够的，因为这种声明可以告诉A：B是一个类；但它不能指出类成员的名称。
同样，如果B拥有一个本身是A的成员函数的友元，则A的这个声明必须位于B的声明之前。这两个要求是互斥的。

3.下面的嵌套类声明中可能存在什么问题？
class Ribs
{
private:
    class Sauce
    {
        int soy;
        int sugar;
     public:
        Sauce (int s1, int s2) : soy (s1), sugar (s2) {}
    };
    ...
}；
成员soy 和sugar在默认情况下是私有的。
类Sauce的唯一公有方法是构造函数，这意味着只能调用构造函数来创建一个Sauce对象，不能进行其他操作。

4.throw 和return之间的区别何在？
假设函数f1调用函数f2。函数f2中的返回语句导致返回后程序继续执行在函数f1中调用函数f2后面的一条语句。
throw语句导致程序沿函数调用的当前序列回溯，直到找到直接或间接包含对函数f2的调用的try语句块为止。
它可能在f1中、调用函数f1的函数中或其他函数中。找到这样的try语句块后，将执行下一个匹配的catch语句块，
而不是函数调用后的语句。

5.假设有一个从异常基类派生来的异常类层次结构，则应按什么样的顺序放置catch 块？
应按从子孙到祖先的顺序排列catch语句块。

6.对于本章定义的Grand、Superb 和Magnificent 类，假设pg为Grand*指针，
并将其中某个类的对象的地址赋给了它，而ps为Superb*指针，则下面两个代码示例的行为有什么不同？
if ( ps = dynamic_cast<Superb*>(pg) )
{
    ps->say();
}
if ( typeid(*pg) == typeid(Superb) )
{
    ( (Superb *) pg)->say();
}
对于示例1，如果pg指向一个Superb对象或从Superb派生而来的任何类的对象，则if条件为true。
具体地说，如果pg指向Magnificent对象，则if条件也为true。
对于示例2，仅当指向Superb对象时，if条件才为true，如果指向的是从Superb派生出来的对象，则if条件不为true。

7.static_cast运算符与dynamic_cast 运算符有什么不同？
static_cast主要用于非多态类型之间的转换，不提供运行时的检查来确保转换的安全性。主要在以下几种场合中使用：
用于类层次结构中，基类和子类之间指针和引用的转换；
当进行上行转换，也就是把子类的指针或引用转换成父类表示，这种转换是安全的；
当进行下行转换，也就是把父类的指针或引用转换成子类表示，这种转换是不安全的，也需要程序员来保证；
用于基本数据类型之间的转换，如把int转换成char，把int转换成enum等等，这种转换的安全性需要程序员来保证；
把void指针转换成目标类型的指针，这种转换是不安全的；
dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。
在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；
在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。
在多态类型（基类包含虚函数）之间的转换主要使用dynamic_cast，因为类型提供了运行时信息。
如果expression是type-id的基类，使用dynamic_cast进行转换时，
在运行时就会检查expression是否真正的指向一个type-id类型的对象，
如果是，则能进行正确的转换，获得对应的值；否则返回空指针，如果是引用，则在运行时就会抛出异常。

15.8编程练习
1.对Tv和Remote类做如下修改：
a.让它们互为友元；
b.在Remote类中添加一个状态变量成员，该成员描述遥控器是处于常规模式还是互动模式；
c.在Remote中添加一个显示模式的方法；
d.在Tv类中添加一个对Remote中新成员进行切换的方法，该方法应仅当TV处于打开状态时才能运行。
编写一个小程序来测试这些新特性。
tv2.h
#ifndef TV2_H_
#define TV2_H_

class Remote;

class Tv
{
public:
    friend class Remote;
    enum { Off, On };
    enum { MinVal, MaxVal = 20 };
    enum { Antenna, Cable };
    enum { TV, DVD };

    Tv(int s = Off, int mc = 125) : state(s), volume(5), maxchannel(mc), channel(2), mode(Cable), input(TV) {}
    void onoff()
    {
        state = (state == On) ? Off : On;
    }
    bool ison() const
    {
        return state == On;
    }
    bool volup();
    bool voldown();
    void chanup();
    void chandown();
    void set_mode()
    {
        mode = (mode == Antenna) ? Cable : Antenna;
    }
    void set_input()
    {
        input = (input == TV) ? DVD : TV;
    }
    void settings() const;
    void toggleRemoteMode(Remote &r);
private:
    int state;
    int volume;
    int maxchannel;
    int channel;
    int mode;
    int input;
};

class Remote
{
private:
    int mode_d;
    int mode_i;
public:
    friend class Tv;
    enum { Normal, Interactive };
    void settings() const;
    Remote(int md = Tv::TV, int mi = Normal) : mode_d(md), mode_i(mi) {}
    bool volup(Tv &t)
    {
        return t.volup();
    }
    bool voldown(Tv &t)
    {
        return t.voldown();
    }
    void onoff(Tv &t)
    {
        t.onoff();
    }
    void chanup(Tv &t)
    {
        t.chanup();
    }
    void chandown(Tv &t)
    {
        t.chandown();
    }
    void set_chan(Tv &t, int c)
    {
        t.channel = c;
    }
    void set_mode(Tv &t)
    {
        t.set_mode();
    }
    void set_input(Tv &t)
    {
        t.set_input();
    }
};

#endif

tv2.cpp
#include <iostream>
#include "tv2.h"

bool Tv::volup()
{
    if (volume < MaxVal)
    {
        volume++;
        return true;
    }
    else
    {
        return false;
    }
}

bool Tv::voldown()
{
    if (volume > MinVal)
    {
        volume--;
        return true;
    }
    else
    {
        return false;
    }
}

void Tv::chanup()
{
    if (channel < maxchannel)
    {
        channel++;
    }
    else
    {
        channel = 1;
    }
}

void Tv::chandown()
{
    if (channel > 1)
    {
        channel--;
    }
    else
    {
        channel = maxchannel;
    }
}

void Tv::settings() const
{
    std::cout << "TV is " << (state == Off ? "Off" : "On") << std::endl;

    if (state == On)
    {
        std::cout << "Volume setting = " << volume << std::endl;
        std::cout << "Channel setting = " << channel << std::endl;
        std::cout << "Mode = " << (mode == Antenna ? "antenna" : "cable") << std::endl;
        std::cout << "Input = " << (input == TV ? "TV" : "DVD") << std::endl;
    }
}

void Tv::toggleRemoteMode(Remote &r)
{
    if (On == state && r.mode_i == Remote::Interactive)
    {
        r.mode_i = Remote::Normal;
    }
    else if (On == state && r.mode_i == Remote::Normal)
    {
        r.mode_i = Remote::Interactive;
    }
    else
    {
        return;
    }
}
void Remote::settings() const
{
    std::cout << "Remote is set to the " << (mode_d == Tv::TV ? "TV" : "VCR");
    std::cout << " and is in ";
    std::cout << (mode_i == Normal ? "Normal" : "Interactive") << " mode" << std::endl;
}

ch15_p01.cpp
#include <iostream>
#include "tv2.h"

int main()
{
    Tv tv;
    Remote remote;

    tv.onoff();
    std::cout << "Here are our original settings: " << std::endl;
    tv.settings();
    remote.settings();
    std::cout << std::endl;

    tv.toggleRemoteMode(remote);
    std::cout << "These are our new settings:" << std::endl;
    tv.settings();
    remote.settings();
    std::cout << std::endl;

    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Here are our original settings:
TV is On
Volume setting = 5
Channel setting = 2
Mode = cable
Input = TV
Remote is set to the TV and is in Normal mode

These are our new settings:
TV is On
Volume setting = 5
Channel setting = 2
Mode = cable
Input = TV
Remote is set to the TV and is in Interactive mode

Done.

2.修改程序清单15.11，使两种异常类型都是从头文件<stdexcept>提供的logic_error类派生出来的类。
让每个what方法都报告函数名和问题的性质。异常对象不用存储错误的参数值，而只需支持what方法。
ch15_p02.cpp
#include <iostream>
#include <stdexcept>
#include <cmath>

class bad_hmean : public std::logic_error
{
public:
    bad_hmean(const std::string &s = "hmean(a, b) invalid arguments: a = -b\n") : std::logic_error(s) {}
};

class bad_gmean : public std::logic_error
{
public:
    bad_gmean(const std::string &s = "gmean(a, b) arguments should be >= 0\n") : std::logic_error(s) {}
};

double hmean(double a, double b);
double gmean(double a, double b);

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;

    double x, y, z;

    cout << "Enter two numbers <q to quit>: ";
    while (cin >> x && cin >> y)
    {
        try
        {
            z = hmean(x, y);
            cout << "Harmonic mean of " << x << " and " << y
                 << " is " << z << endl;
            z = gmean(x, y);
            cout << "Geometric mean of " << x << " and " << y
                 << " is " << z << endl;
            cout << "Enter two numbers <q to quit>: ";
        }
        catch (bad_hmean &bg)
        {
            cout << bg.what();
            cout << "Enter two numbers <q to quit>: ";
            continue;
        }
        catch (bad_gmean &hg)
        {
            cout << hg.what();
            std::cout << "Sorry, you don't get to play any more.\n";
            break;
        }
    }
    cout << "Done.\n";

    return 0;
}

double hmean(double a, double b)
{
    if (a == -b)
    {
        throw bad_hmean();
    }
    return (2.0 * a * b) / (a + b);
}

double gmean(double a, double b)
{
    if (a < 0 || b < 0)
    {
        throw bad_gmean();
    }
    return std::sqrt(a * b);
}
显示结果如下
Enter two numbers <q to quit>: 2 5
Harmonic mean of 2 and 5 is 2.85714
Geometric mean of 2 and 5 is 3.16228
Enter two numbers <q to quit>: 3 5
Harmonic mean of 3 and 5 is 3.75
Geometric mean of 3 and 5 is 3.87298
Enter two numbers <q to quit>: 3 -3
hmean(a, b) invalid arguments: a = -b
Enter two numbers <q to quit>: 5 3
Harmonic mean of 5 and 3 is 3.75
Geometric mean of 5 and 3 is 3.87298
Enter two numbers <q to quit>: 5 -3
Harmonic mean of 5 and -3 is -15
gmean(a, b) arguments should be >= 0
Sorry, you don't get to play any more.
Done.

3.这个练习与编程练习2相同，但异常类是从一个这样的基类派生而来的：它是丛logic error派生而来的，并存储两个参数值。
异常类应该有一个这样的方法：报告这些值以及函数名。
程序使用一个catch块来捕获基类异常，其中任何一种从该基类异常派生而来的异常都将导致循环结束。
ch15_p03.cpp
#include <iostream>
#include <stdexcept>
#include <typeinfo>
#include <cmath>

double hmean(double a, double b);
double gmean(double a, double b);

class bad_hmean : public std::invalid_argument
{
private:
    int arg1;
    int arg2;
public:
    bad_hmean(int a, int b, const std::string &s = "hmean(a, b) invalid arguments: a = -b\n") : std::invalid_argument(s), arg1(a), arg2(b) {}
    void display() const;
};

void bad_hmean::display() const
{
    std::cout << "For function hmean(a, b), a != -b" << std::endl;
    std::cout << "You entered a = " << arg1 << ", b = " << arg2 << std::endl;
}
class bad_gmean : public std::domain_error
{
private:
    int arg1;
    int arg2;
public:
    bad_gmean(int a, int b, const std::string &s = "gmean(a, b) arguments should be >= 0\n") : std::domain_error(s), arg1(a), arg2(b) {}
    void display() const;
};
void bad_gmean::display() const
{
    std::cout << "For function gmean(a, b), a >= 0 and b >= 0" << std::endl;
    std::cout << "You entered a = " << arg1 << ", b = " << arg2 << std::endl;
}

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;

    double x, y, z;

    cout << "Enter two numbers <q to quit>: ";
    while (cin >> x && cin >> y)
    {
        try
        {
            z = hmean(x, y);
            cout << "Harmonic mean of " << x << " and " << y
                 << " is " << z << endl;
            z = gmean(x, y);
            cout << "Geometric mean of " << x << " and " << y
                 << " is " << z << endl;
            cout << "Enter two numbers <q to quit>: ";
        }
        catch (std::exception &e)
        {
            if (typeid(bad_hmean &) == typeid(e))
            {
                bad_hmean &bhm = dynamic_cast<bad_hmean &>(e);
                bhm.display();
            }
            else if(typeid(bad_gmean &) == typeid(e))
            {
                bad_gmean &bgm = dynamic_cast<bad_gmean &>(e);
                bgm.display();
            }
            cout << "Sorry, you don't get to play any more.\n";
            break;
        }
    }
    cout << "Done.\n";

    return 0;
}

double hmean(double a, double b)
{
    if (a == -b)
    {
        throw bad_hmean(a, b);
    }
    return (2.0 * a * b) / (a + b);
}

double gmean(double a, double b)
{
    if (a < 0 || b < 0)
    {
        throw bad_gmean(a, b);
    }
    return std::sqrt(a * b);
}
显示结果如下
Enter two numbers <q to quit>: 2 5
Harmonic mean of 2 and 5 is 2.85714
Geometric mean of 2 and 5 is 3.16228
Enter two numbers <q to quit>: 3 5
Harmonic mean of 3 and 5 is 3.75
Geometric mean of 3 and 5 is 3.87298
Enter two numbers <q to quit>: 3 -3
For function hmean(a, b), a != -b
You entered a = 3, b = -3
Sorry, you don't get to play any more.
Done.

Enter two numbers <q to quit>: 5 3
Harmonic mean of 5 and 3 is 3.75
Geometric mean of 5 and 3 is 3.87298
Enter two numbers <q to quit>: 5 -3
Harmonic mean of 5 and -3 is -15
For function gmean(a, b), a >= 0 and b >= 0
You entered a = 5, b = -3
Sorry, you don't get to play any more.
Done.

4.程序清单15.16在每个try后面都使用两个catch块，以确保nbad_index异常导致方法label_val被调用。
请修改该程序，在每个try块后面只使用一个catch块，并使用RTTI来确保合适时调用label_val。
ch15_p04.cpp
#include <iostream>
#include <typeinfo>
#include "sales2.h"

int main()
{
    double vals1[12] =
    {
        1220, 1100, 1122, 2212, 1232, 2334,
        2884, 2393, 3302, 2922, 3002, 3544
    };

    double vals2[12] =
    {
        12, 11, 22, 21, 32, 34,
        28, 29, 33, 29, 32, 35
    };

    Sales sales1(2004, vals1, 12);
    LabeledSales sales2("Blogstar", 2005, vals2, 12 );

    std::cout << "First try block:\n";
    try
    {
        std::cout << "Year = " << sales1.Year() << std::endl;
        for (int i = 0; i < 12; ++i)
        {
            std::cout << sales1[i] << ' ';

            if (i % 6 == 5)
            {
                std::cout << std::endl;
            }
        }
        std::cout << "Year = " << sales2.Year() << std::endl;
        std::cout << "Label = " << sales2.Label() << std::endl;

        for (int i = 0; i <= 12; ++i)
        {
            std::cout << sales2[i] << ' ';

            if (i % 6 == 5)
            {
                std::cout << std::endl;
            }
        }
        std::cout << "End of try block 1.\n";
    }
    catch(Sales::bad_index &bad)
    {
        std::cout << bad.what();

        if(typeid(LabeledSales::nbad_index &) == typeid(bad))
        {
            LabeledSales::nbad_index &nbi = dynamic_cast<LabeledSales::nbad_index &>(bad);
            std::cout << "Company: " << nbi.label_val() << std::endl;
        }
        std::cout << "bad index: " << bad.bi_val() << std::endl;
    }
    std::cout << "\nNext try block:\n";

    try
    {
        sales2[2] = 37.5;
        sales1[20] = 23345;
        std::cout << "End of try block 2.\n";
    }
    catch(Sales::bad_index &bad)
    {
        std::cout << bad.what();

        if ( typeid(LabeledSales::nbad_index &) == typeid(bad) )
        {
            LabeledSales::nbad_index &nbi = dynamic_cast<LabeledSales::nbad_index &>(bad);
            std::cout << "Company: " << nbi.label_val() << std::endl;
        }
        std::cout << "bad index: " << bad.bi_val() << std::endl;
    }
    std::cout << "Done.\n";

    return 0;
}
显示结果如下
First try block:
Year = 2004
1220 1100 1122 2212 1232 2334
2884 2393 3302 2922 3002 3544
Year = 2005
Label = Blogstar
12 11 22 21 32 34
28 29 33 29 32 35
Index error in LabeledSales object
Company: Blogstar
bad index: 12

Next try block:
Index error in Sales object
bad index: 20
Done.

第16章 string类和标准模板库
16.1 string类
16.1.1 构造字符串
16.1.2 string类输入
16.1.3 使用字符串
16.1.4 string还提供了哪些功能
16.1.5 字符串种类
16.2 智能指针模板类
16.2.1 使用智能指针
16.2.2 有关智能指针的注意事项
16.2.3 unique_ptr为何优于auto_ptr
16.2.4 选择智能指针
16.3 标准模板库
16.3.1 模板类vector
16.3.2 可对vector执行的操作
16.3.3 可对vector执行的其他操作
16.3.4 基于范围的for循环（C++11）
16.4 泛型编程
16.4.1 为何使用迭代器
16.4.2 迭代器类型
16.4.3 迭代器层次结构
16.4.4 概念、改进和模型
16.4.5 容器种类
16.4.6 关联容器
16.4.7 无序关联容器（C++11）.
16.5 函数对象
16.5.1 函数符概念
16.5.2 预定义的函数符
16.5.3 自适应函数符和函数适配器.
16.6 算法
16.6.1 算法组
16.6.2 算法的通用特征
16.6.3 STL和string类
16.6.4 函数和容器方法
16.6.5 使用STL
16.7 其他库
16.7.1 vector、valarray和array
16.7.2 模板initializer_list（C++11）
16.7.3 使用initializer_list
16.8 总结
16.9 复习题
16.10 编程练习
本章内容包括：
标准C++ string类。
模板 auto_ptr、unique_ptr和shared_ptr。
标准模板库（STL）。
容器类。
迭代器。
函数对象（functor）。
STL算法。
模板 initializer_list。
程序清单16.1 str1.cpp
#include <iostream>
#include <string>

int main()
{
    using namespace std;
    string one("Lottery Winner!");
    cout << one << endl;
    string two(20, '$');
    cout << two << endl;
    string three(one);
    cout << three << endl;
    one += " Oops!";
    cout << one << endl;
    two = "Sorry! That was ";
    three[0] = 'P';
    string four;
    four = two + three;
    cout << four << endl;
    char alls[] = "All's well that ends well";
    string five(alls, 20);
    cout << five << "!\n";
    string six(alls + 6, alls + 10);
    cout << six << ", ";
    string seven(&five[6], &five[10]);
    cout << seven << "...\n";
    string eight(four, 7, 16);
    cout << eight << " in motion!" << endl;

    return 0;
}
显示结果如下
Lottery Winner!
$$$$$$$$$$$$$$$$$$$$
Lottery Winner!
Lottery Winner! Oops!
Sorry! That was Pottery Winner!
All's well that ends!
well, well...
That was Pottery in motion!

程序清单16.2 strfile.cpp
#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>

int main()
{
    using namespace std;
    ifstream fin;
    fin.open("strfile.txt");
    if (fin.is_open() == false)
    {
        cerr << "Can't open file. Bye.\n";
        exit(EXIT_FAILURE);
    }
    string item;
    int count = 0;

    getline(fin, item, ':');
    while (fin)
    {
        ++count;
        cout << count << ": " << item << endl;
        getline(fin, item, ':');
    }
    cout << "Done.\n";
    fin.close();

    return 0;
}
显示结果如下
1: Peter Smith
2: Mike Pence
3: Hello World
4: Apple
5: Orange
6: Egg
Done.

cat strfile.txt
Peter Smith:Mike Pence:Hello World:Apple:Orange:Egg

注意，将 : 指定为分界字符后，换行符将被视为常规字符。
string::npos是字符串可存储的最大字符数，通常是无符号int或无符号long的最大取值。
程序清单16.3 hangman.cpp
#include <iostream>
#include <string>
#include <cstdlib>
#include <ctime>
#include <cctype>

using std::string;

const int NUM = 26;

const string wordlist[NUM] =
{
    "apiary", "beetle", "cereal",
    "danger", "ensign", "florid", "garage", "health", "insult",
    "jackal", "keeper", "loaner", "manage", "nonce", "onset",
    "plaid", "quilt", "remote", "stolid", "train", "useful",
    "valid", "whence", "xenon", "yearn", "zippy"
};

int main()
{
    using std::cout;
    using std::cin;
    using std::tolower;
    using std::endl;

    std::srand(std::time(nullptr));
    char play;
    cout << "Will you play a word game? <y/n> ";
    cin >> play;
    while (cin.get() != '\n')
    {
        continue;
    }
    play = tolower(play);
    while (play == 'y')
    {
        string target = wordlist[std::rand() % NUM];
        int length = target.length();
        string attempt(length, '-');
        string badchars;
        int guesses = 6;
        cout << "Guess my secret word. It has " << length
             << " letters, and you guess\n"
             << "one letter at a time. You get " << guesses
             << " wrong guesses.\n";
        cout << "Your word: " << attempt << endl;
        while (guesses > 0 && attempt != target)
        {
            char letter;
            cout << "Guess a letter: ";
            cin >> letter;
            while (cin.get() != '\n')
            {
                continue;
            }
            if (badchars.find(letter) != string::npos || attempt.find(letter) != string::npos)
            {
                cout << "You already guessed that. Try again.\n";
                continue;
            }
            int loc = target.find(letter);
            if (loc == string::npos)
            {
                cout << "Oh, bad guess!\n";
                --guesses;
                badchars += letter;
            }
            else
            {
                cout << "Good guess!\n";
                attempt[loc] = letter;
                loc = target.find(letter, loc + 1);
                while (loc != string::npos)
                {
                    attempt[loc] = letter;
                    loc = target.find(letter, loc + 1);
                }
            }
            cout << "Your word: " << attempt << endl;
            if (attempt != target)
            {
                if (badchars.length() > 0)
                {
                    cout << "Bad choices: " << badchars << endl;
                }
                cout << guesses << " bad guesses left\n";
            }
        }
        if (guesses > 0)
        {
            cout << "That's right!\n";
        }
        else
        {
            cout << "Sorry, the word is " << target << ".\n";
        }

        cout << "Will you play another? <y/n> ";
        cin >> play;
        while (cin.get() != '\n')
        {
            continue;
        }
        play = tolower(play);
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Will you play a word game? <y/n> y
Guess my secret word. It has 5 letters, and you guess
one letter at a time. You get 6 wrong guesses.
Your word: -----
Guess a letter: v
Oh, bad guess!
Your word: -----
Bad choices: v
5 bad guesses left
Guess a letter: p
Oh, bad guess!
Your word: -----
Bad choices: vp
4 bad guesses left
Guess a letter: x
Oh, bad guess!
Your word: -----
Bad choices: vpx
3 bad guesses left
Guess a letter: y
Oh, bad guess!
Your word: -----
Bad choices: vpxy
2 bad guesses left
Guess a letter: z
Oh, bad guess!
Your word: -----
Bad choices: vpxyz
1 bad guesses left
Guess a letter: q
Oh, bad guess!
Your word: -----
Bad choices: vpxyzq
0 bad guesses left
Sorry, the word is nonce.
Will you play another? <y/n> y
Guess my secret word. It has 5 letters, and you guess
one letter at a time. You get 6 wrong guesses.
Your word: -----
Guess a letter: n
Oh, bad guess!
Your word: -----
Bad choices: n
5 bad guesses left
Guess a letter: o
Oh, bad guess!
Your word: -----
Bad choices: no
4 bad guesses left
Guess a letter: p
Good guess!
Your word: p----
Bad choices: no
4 bad guesses left
Guess a letter: l
Good guess!
Your word: pl---
Bad choices: no
4 bad guesses left
Guess a letter: a
Good guess!
Your word: pla--
Bad choices: no
4 bad guesses left
Guess a letter: i
Good guess!
Your word: plai-
Bad choices: no
4 bad guesses left
Guess a letter: d
Good guess!
Your word: plaid
That's right!
Will you play another? <y/n> n
Done.

程序清单16.4 str2.cpp
#include <iostream>
#include <string>

int main()
{
    using namespace std;
    string empty;
    string small = "bit";
    string larger = "Elephants are a girl's best friend";
    cout << "Sizes:\n";
    cout << "\tempty: " << empty.size() << endl;
    cout << "\tsmall: " << small.size() << endl;
    cout << "\tlarger: " << larger.size() << endl;
    cout << "Capacities:\n";
    cout << "\tempty: " << empty.capacity() << endl;
    cout << "\tsmall: " << small.capacity() << endl;
    cout << "\tlarger: " << larger.capacity() << endl;
    empty.reserve(50);
    cout << "Capacity after empty.reserve(50): " << empty.capacity() << endl;

    return 0;
}
显示结果如下
Sizes:
        empty: 0
        small: 3
        larger: 34
Capacities:
        empty: 15
        small: 15
        larger: 34
Capacity after empty.reserve(50): 50

程序清单16.5 smrtptrs.cpp
#include <iostream>
#include <string>
#include <memory>

class Report
{
private:
    std::string str;
public:
    Report(const std::string s) : str(s)
    {
        std::cout << "Object of class Report created!\n";
    }
    ~Report()
    {
        std::cout << "Object of class Report deleted!\n";
    }
    void comment() const
    {
        std::cout << str << "\n";
    }
};

int main()
{
    {
        std::auto_ptr<Report> ps(new Report("using auto_ptr"));
        ps->comment();
    }
    {
        std::shared_ptr<Report> ps(new Report("using shared_ptr"));
        ps->comment();
    }
    {
        std::unique_ptr<Report> ps(new Report("using unique_ptr"));
        ps->comment();
    }

    return 0;
}
显示结果如下
Object of class Report created!
using auto_ptr
Object of class Report deleted!
Object of class Report created!
using shared_ptr
Object of class Report deleted!
Object of class Report created!
using unique_ptr
Object of class Report deleted!

程序清单16.6 fowl_ap.cpp
#include <iostream>
#include <string>
#include <memory>

int main()
{
    using namespace std;
    auto_ptr<string> films[5] =
    {
        auto_ptr<string>(new string("Fowl Balls")),
        auto_ptr<string>(new string("Duck Walks")),
        auto_ptr<string>(new string("Chicken Runs")),
        auto_ptr<string>(new string("Turkey Errors")),
        auto_ptr<string>(new string("Goose Eggs"))
    };
    auto_ptr<string> pwin;
    pwin = films[2];

    cout << "The nominees for best avian baseball film are\n";
    for (int i = 0; i < 5; i++)
    {
        cout << *films[i] << endl;
    }
    cout << "The winner is " << *pwin << "!\n";

    return 0;
}
显示结果如下
The nominees for best avian baseball film are
Fowl Balls
Duck Walks
Segmentation fault (core dumped)

fowl_sp.cpp
#include <iostream>
#include <string>
#include <memory>

int main()
{
    using namespace std;
    shared_ptr<string> films[5] =
    {
        shared_ptr<string>(new string("Fowl Balls")),
        shared_ptr<string>(new string("Duck Walks")),
        shared_ptr<string>(new string("Chicken Runs")),
        shared_ptr<string>(new string("Turkey Errors")),
        shared_ptr<string>(new string("Goose Eggs"))
    };
    shared_ptr<string> pwin;
    pwin = films[2];

    cout << "The nominees for best avian baseball film are\n";
    for (int i = 0; i < 5; i++)
    {
        cout << *films[i] << endl;
    }
    cout << "The winner is " << *pwin << "!\n";

    return 0;
}
显示结果如下
The nominees for best avian baseball film are
Fowl Balls
Duck Walks
Chicken Runs
Turkey Errors
Goose Eggs
The winner is Chicken Runs!

fowl_up.cpp
#include <iostream>
#include <string>
#include <memory>

int main()
{
    using namespace std;
    unique_ptr<string> films[5] =
    {
        unique_ptr<string>(new string("Fowl Balls")),
        unique_ptr<string>(new string("Duck Walks")),
        unique_ptr<string>(new string("Chicken Runs")),
        unique_ptr<string>(new string("Turkey Errors")),
        unique_ptr<string>(new string("Goose Eggs"))
    };
    unique_ptr<string> pwin;
    pwin = films[2];

    cout << "The nominees for best avian baseball film are\n";
    for (int i = 0; i < 5; i++)
    {
        cout << *films[i] << endl;
    }
    cout << "The winner is " << *pwin << "!\n";

    return 0;
}
编译命令如下
fowl_up.cpp: In function ‘int main()’:
fowl_up.cpp:17:19: error: use of deleted function ‘std::unique_ptr<_Tp, _Dp>& std::unique_ptr<_Tp, _Dp>::operator=(const std::unique_ptr<_Tp, _Dp>&) [with _Tp = std::__cxx11::basic_string<char>; _Dp = std::default_delete<std::__cxx11::basic_string<char> >]’
   17 |     pwin = films[2];
      |                   ^
In file included from /usr/include/c++/10.2.0/memory:83,
                 from fowl_up.cpp:3:
/usr/include/c++/10.2.0/bits/unique_ptr.h:469:19: note: declared here
  469 |       unique_ptr& operator=(const unique_ptr&) = delete;

unique_ptr代表的是专属所有权，即由 unique_ptr 管理的内存，只能被一个对象持有。
所以，unique_ptr 不支持复制和赋值，只支持移动。
如果想要把一个 unique_ptr 的内存交给另外一个 unique_ptr 对象管理。只能使用 std::move 转移当前对象的所有权。
转移之后，当前对象不再持有此内存，新的对象将获得专属所有权。
unique_ptr 在默认情况下和裸指针的大小是一样的。所以，内存上没有任何的额外消耗，性能是最优的。
shared_ptr 代表的是共享所有权，即多个 shared_ptr 可以共享同一块内存。
因此，shared_ptr 支持复制和赋值，也支持移动。
shared_ptr 内部是利用引用计数来实现内存的自动管理，每当复制一个 shared_ptr，引用计数会+1。
当一个 shared_ptr 离开作用域时，引用计数会-1。当引用计数为 0 的时候，则 delete 内存。
shared_ptr 的内存占用是裸指针的两倍。因为除了要管理一个裸指针外，还要维护一个引用计数。
因此相比于 unique_ptr, shared_ptr 的内存占用更高
考虑到线程安全问题，引用计数的增减必须是原子操作。而原子操作一般情况下都比非原子操作慢。
shared_ptr 在性能上固然是低于 unique_ptr。而通常情况，我们也可以尽量避免 shared_ptr 复制。
如果，一个 shared_ptr 需要将所有权共享给另外一个新的 shared_ptr，而我们确定在之后的代码中都不再使用这个 shared_ptr。
对于此种场景，我们尽量使用 std::move，将 shared_ptr 转移给新的对象。因为移动不用增加引用计数，性能比复制更好。
weak_ptr 是为了解决 shared_ptr 双向引用的问题。weak_ptr 不会增加引用计数，因此可以打破 shared_ptr 的循环引用。
成员函数lock返回shared_ptr对象，若对应内存已经删除，则shared_ptr对象==nullptr。
weak_ptr对象可以拷贝构造，拷贝构造出来的对象和原对象观察的是同一段内存。
成员函数reset可以解除对内存的观察，注意，是解除观察，并不会删除对应内存对象。

程序清单16.7 vector1.cpp
#include <iostream>
#include <string>
#include <vector>

const int NUM = 5;

int main()
{
    using std::vector;
    using std::string;
    using std::cin;
    using std::cout;
    using std::endl;

    vector<int> ratings(NUM);
    vector<string> titles(NUM);
    cout << "You will do exactly as told. You will enter\n"
         << NUM << " book titles and your ratings (0-10).\n";
    int i;
    for (i = 0; i < NUM; i++)
    {
        cout << "Enter title #" << i + 1 << ": ";
        std::getline(cin, titles[i], '\n');
        cout << "Enter your rating (0-10): ";
        cin >> ratings[i];
        cin.get();
    }
    cout << "Thank you. You entered the following:\n";
    cout << "Rating\tBook\n";
    for (i = 0; i < NUM; i++)
    {
        cout << ratings[i] << "\t" << titles[i] << endl;
    }

    return 0;
}
显示结果如下
You will do exactly as told. You will enter
5 book titles and your ratings (0-10).
Enter title #1: Mike Pence
Enter your rating (0-10): 3
Enter title #2: Peter Smith
Enter your rating (0-10): 5
Enter title #3: Hello World
Enter your rating (0-10): 2
Enter title #4: Apple
Enter your rating (0-10): 1
Enter title #5: Orange
Enter your rating (0-10): 6
Thank you. You entered the following:
Rating  Book
3       Mike Pence
5       Peter Smith
2       Hello World
1       Apple
6       Orange

程序清单16.8 vector2.cpp
#include <iostream>
#include <string>
#include <vector>

struct Review
{
    std::string title;
    int rating;
};

bool FillReview(Review &rr);
void ShowReview(const Review &rr);

int main()
{
    using std::cout;
    using std::vector;
    vector<Review> books;
    Review temp;
    while (FillReview(temp))
    {
        books.push_back(temp);
    }
    int num = books.size();
    if (num > 0)
    {
        cout << "Thank you. You entered the following:\n"
             << "Rating\tBook\n";
        for (int i = 0; i < num; i++)
        {
            ShowReview(books[i]);
        }
        cout << "Reprising:\n"
             << "Rating\tBook\n";
        vector<Review>::iterator pr;
        for (pr = books.begin(); pr != books.end(); pr++)
        {
            ShowReview(*pr);
        }
        vector <Review> oldlist(books);
        if (num > 3)
        {
            books.erase(books.begin() + 1, books.begin() + 3);
            cout << "After erasure:\n";
            for (pr = books.begin(); pr != books.end(); pr++)
            {
                ShowReview(*pr);
            }
            books.insert(books.begin(), oldlist.begin() + 1,
                         oldlist.begin() + 2);
            cout << "After insertion:\n";
            for (pr = books.begin(); pr != books.end(); pr++)
            {
                ShowReview(*pr);
            }
        }
        books.swap(oldlist);
        cout << "Swapping oldlist with books:\n";
        for (pr = books.begin(); pr != books.end(); pr++)
        {
            ShowReview(*pr);
        }
    }
    else
    {
        cout << "Nothing entered, nothing gained.\n";
    }

    return 0;
}
bool FillReview(Review &rr)
{
    std::cout << "Enter book title (quit to quit): ";
    std::getline(std::cin, rr.title, '\n');
    if (rr.title == "quit")
    {
        return false;
    }
    std::cout << "Enter book rating: ";
    std::cin >> rr.rating;
    if (!std::cin)
    {
        return false;
    }
    while (std::cin.get() != '\n')
    {
        continue;
    }
    return true;
}
void ShowReview(const Review &rr)
{
    std::cout << rr.rating << "\t" << rr.title << std::endl;
}
显示结果如下
Enter book title (quit to quit): Mike Pence
Enter book rating: 3
Enter book title (quit to quit): Peter Smith
Enter book rating: 5
Enter book title (quit to quit): Hello World
Enter book rating: 6
Enter book title (quit to quit): Apple
Enter book rating: 1
Enter book title (quit to quit): Orange
Enter book rating: 9
Enter book title (quit to quit): Egg
Enter book rating: 2
Enter book title (quit to quit): quit
Thank you. You entered the following:
Rating  Book
3       Mike Pence
5       Peter Smith
6       Hello World
1       Apple
9       Orange
2       Egg
Reprising:
Rating  Book
3       Mike Pence
5       Peter Smith
6       Hello World
1       Apple
9       Orange
2       Egg
After erasure:
3       Mike Pence
1       Apple
9       Orange
2       Egg
After insertion:
5       Peter Smith
3       Mike Pence
1       Apple
9       Orange
2       Egg
Swapping oldlist with books:
3       Mike Pence
5       Peter Smith
6       Hello World
1       Apple
9       Orange
2       Egg

程序清单16.9 vector3.cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

struct Review
{
    std::string title;
    int rating;
};

bool operator<(const Review &r1, const Review &r2);
bool worseThan(const Review &r1, const Review &r2);
bool FillReview(Review &rr);
void ShowReview(const Review &rr);

int main()
{
    using namespace std;

    vector<Review> books;
    Review temp;
    while (FillReview(temp))
    {
        books.push_back(temp);
    }
    if (books.size() > 0)
    {
        cout << "Thank you. You entered the following "
             << books.size() << " ratings:\n"
             << "Rating\tBook\n";
        for_each(books.begin(), books.end(), ShowReview);

        sort(books.begin(), books.end());
        cout << "Sorted by title:\nRating\tBook\n";
        for_each(books.begin(), books.end(), ShowReview);
        sort(books.begin(), books.end(), worseThan);
        cout << "Sorted by rating:\nRating\tBook\n";
        for_each(books.begin(), books.end(), ShowReview);
        random_shuffle(books.begin(), books.end());
        cout << "After shuffling:\nRating\tBook\n";
        for_each(books.begin(), books.end(), ShowReview);
    }
    else
    {
        cout << "No entries.\n";
    }
    cout << "Done.\n";

    return 0;
}
bool operator<(const Review &r1, const Review &r2)
{
    if (r1.title < r2.title)
    {
        return true;
    }
    else if (r1.title == r2.title && r1.rating < r2.rating)
    {
        return true;
    }
    else
    {
        return false;
    }
}
bool worseThan(const Review &r1, const Review &r2)
{
    if (r1.rating < r2.rating)
    {
        return true;
    }
    else
    {
        return false;
    }
}
bool FillReview(Review &rr)
{
    std::cout << "Enter book title (quit to quit): ";
    std::getline(std::cin, rr.title, '\n');
    if (rr.title == "quit")
    {
        return false;
    }
    std::cout << "Enter book rating: ";
    std::cin >> rr.rating;
    if (!std::cin)
    {
        return false;
    }
    while (std::cin.get() != '\n')
    {
        continue;
    }
    return true;
}

void ShowReview(const Review &rr)
{
    std::cout << rr.rating << "\t" << rr.title << std::endl;
}
显示结果如下
Enter book title (quit to quit): Mike Pence
Enter book rating: 3
Enter book title (quit to quit): Peter Smith
Enter book rating: 5
Enter book title (quit to quit): Hello World
Enter book rating: 6
Enter book title (quit to quit): Apple
Enter book rating: 1
Enter book title (quit to quit): Orange
Enter book rating: 9
Enter book title (quit to quit): Egg
Enter book rating: 2
Enter book title (quit to quit): quit
Thank you. You entered the following 6 ratings:
Rating  Book
3       Mike Pence
5       Peter Smith
6       Hello World
1       Apple
9       Orange
2       Egg
Sorted by title:
Rating  Book
1       Apple
2       Egg
6       Hello World
3       Mike Pence
9       Orange
5       Peter Smith
Sorted by rating:
Rating  Book
1       Apple
2       Egg
3       Mike Pence
5       Peter Smith
6       Hello World
9       Orange
After shuffling:
Rating  Book
6       Hello World
5       Peter Smith
2       Egg
3       Mike Pence
1       Apple
9       Orange
Done.

        for_each(books.begin(), books.end(), ShowReview);
可以替换为
for (auto x : books) {ShowReview(x);}
如果需要修改x，可以改成：
for (auto & x : books) {InflateReview(x);}

程序清单16.10 copyit.cpp
#include <iostream>
#include <iterator>
#include <vector>

int main()
{
    using namespace std;

    int casts[10] = { 6, 7, 2, 9, 4, 11, 8, 7, 10, 5 };
    vector<int> dice(10);
    copy(casts, casts + 10, dice.begin());
    cout << "Let the dice be cast!\n";
    ostream_iterator<int, char> out_iter(cout, " ");
    copy(dice.begin(), dice.end(), out_iter);
    cout << endl;
    cout << "Implicit use of reverse iterator.\n";
    copy(dice.rbegin(), dice.rend(), out_iter);
    cout << endl;
    cout << "Explicit use of reverse iterator.\n";
    vector<int>::reverse_iterator ri;
    for (auto ri = dice.rbegin(); ri != dice.rend(); ++ri)
    {
        cout << *ri << ' ';
    }
    cout << endl;

    return 0;
}
显示结果如下
Let the dice be cast!
6 7 2 9 4 11 8 7 10 5
Implicit use of reverse iterator.
5 10 7 8 11 4 9 2 7 6
Explicit use of reverse iterator.
5 10 7 8 11 4 9 2 7 6

程序清单16.11 inserts.cpp
#include <iostream>
#include <string>
#include <iterator>
#include <vector>
#include <algorithm>

void output(const std::string &s)
{
    std::cout << s << " ";
}

int main()
{
    using namespace std;
    string s1[4] = { "fine", "fish", "fashion", "fate" };
    string s2[2] = { "busy", "bats" };
    string s3[2] = { "silly", "singers" };
    vector<string> words(4);
    copy(s1, s1 + 4, words.begin());
    for_each(words.begin(), words.end(), output);
    cout << endl;

    copy(s2, s2 + 2, back_insert_iterator<vector<string> >(words));
    for_each(words.begin(), words.end(), output);
    cout << endl;

    copy(s3, s3 + 2, insert_iterator<vector<string> >(words, words.begin()));
    for_each(words.begin(), words.end(), output);
    cout << endl;

    return 0;
}
显示结果如下
fine fish fashion fate
fine fish fashion fate busy bats
silly singers fine fish fashion fate busy bats

程序清单16.12 list.cpp
#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>

void outint(int n)
{
    std::cout << n << " ";
}

int main()
{
    using namespace std;
    list<int> one(5, 2);
    int stuff[5] = { 1, 2, 4, 8, 6 };
    list<int> two;
    two.insert(two.begin(), stuff, stuff + 5);
    int more[6] = { 6, 4, 2, 4, 6, 5 };
    list<int> three(two);
    three.insert(three.end(), more, more + 6);

    cout << "List one: ";
    for_each(one.begin(), one.end(), outint);
    cout << endl << "List two: ";
    for_each(two.begin(), two.end(), outint);
    cout << endl << "List three: ";
    for_each(three.begin(), three.end(), outint);
    three.remove(2);
    cout << endl << "List three minus 2s: ";
    for_each(three.begin(), three.end(), outint);
    three.splice(three.begin(), one);
    cout << endl << "List three after splice: ";
    for_each(three.begin(), three.end(), outint);
    cout << endl << "List one: ";
    for_each(one.begin(), one.end(), outint);
    three.unique();
    cout << endl << "List three after unique: ";
    for_each(three.begin(), three.end(), outint);
    three.sort();
    three.unique();
    cout << endl << "List three after sort & unique: ";
    for_each(three.begin(), three.end(), outint);
    two.sort();
    three.merge(two);
    cout << endl << "Sorted two merged into three: ";
    for_each(three.begin(), three.end(), outint);
    cout << endl;

    return 0;
}
显示结果如下
List one: 2 2 2 2 2
List two: 1 2 4 8 6
List three: 1 2 4 8 6 6 4 2 4 6 5
List three minus 2s: 1 4 8 6 6 4 4 6 5
List three after splice: 2 2 2 2 2 1 4 8 6 6 4 4 6 5
List one:
List three after unique: 2 1 4 8 6 4 6 5
List three after sort & unique: 1 2 4 5 6 8
Sorted two merged into three: 1 1 2 2 4 4 5 6 6 8 8

程序清单16.13 setops.cpp
#include <iostream>
#include <string>
#include <set>
#include <algorithm>
#include <iterator>

int main()
{
    using namespace std;
    const int N = 6;
    string s1[N] = { "buffoon", "thinkers", "for", "heavy", "can", "for" };
    string s2[N] = { "metal", "any", "food", "elegant", "deliver", "for" };

    set<string> A(s1, s1 + N);
    set<string> B(s2, s2 + N);

    ostream_iterator<string, char> out(cout, " ");
    cout << "Set A: ";
    copy(A.begin(), A.end(), out);
    cout << endl;
    cout << "Set B: ";
    copy(B.begin(), B.end(), out);
    cout << endl;

    cout << "Union of A and B:\n";
    set_union(A.begin(), A.end(), B.begin(), B.end(), out);
    cout << endl;

    cout << "Intersection of A and B:\n";
    set_intersection(A.begin(), A.end(), B.begin(), B.end(), out);
    cout << endl;

    cout << "Difference of A and B:\n";
    set_difference(A.begin(), A.end(), B.begin(), B.end(), out);
    cout << endl;

    set<string> C;
    cout << "Set C:\n";
    set_union(A.begin(), A.end(), B.begin(), B.end(),
              insert_iterator<set<string> >(C, C.begin()));
    copy(C.begin(), C.end(), out);
    cout << endl;

    string s3("grungy");
    C.insert(s3);
    cout << "Set C after insertion:\n";
    copy(C.begin(), C.end(), out);
    cout << endl;

    cout << "Showing a range:\n";
    copy(C.lower_bound("ghost"), C.upper_bound("spook"), out);
    cout << endl;

    return 0;
}
显示结果如下
Set A: buffoon can for heavy thinkers
Set B: any deliver elegant food for metal
Union of A and B:
any buffoon can deliver elegant food for heavy metal thinkers
Intersection of A and B:
for
Difference of A and B:
buffoon can heavy thinkers
Set C:
any buffoon can deliver elegant food for heavy metal thinkers
Set C after insertion:
any buffoon can deliver elegant food for grungy heavy metal thinkers
Showing a range:
grungy heavy metal

程序清单16.14 multimap.cpp
#include <iostream>
#include <string>
#include <map>
#include <algorithm>

typedef int KeyType;
typedef std::pair<const KeyType, std::string> Pair;
typedef std::multimap<KeyType, std::string> MapCode;

int main()
{
    using namespace std;
    MapCode codes;

    codes.insert(Pair(415, "San Francisco"));
    codes.insert(Pair(510, "Oakland"));
    codes.insert(Pair(718, "Brooklyn"));
    codes.insert(Pair(718, "Staten Island"));
    codes.insert(Pair(415, "San Rafael"));
    codes.insert(Pair(510, "Berkeley"));

    cout << "Number of cities with area code 415: "
         << codes.count(415) << endl;
    cout << "Number of cities with area code 718: "
         << codes.count(718) << endl;
    cout << "Number of cities with area code 510: "
         << codes.count(510) << endl;
    cout << "Area Code   City\n";
    MapCode::iterator it;
    for (it = codes.begin(); it != codes.end(); ++it)
    {
        cout << "    " << (*it).first << "     "
             << (*it).second << endl;
    }

    auto range = codes.equal_range(718);
    cout << "Cities with area code 718:\n";
    for (it = range.first; it != range.second; ++it)
    {
        cout << (*it).second << endl;
    }

    return 0;
}
显示结果如下
Number of cities with area code 415: 2
Number of cities with area code 718: 2
Number of cities with area code 510: 2
Area Code   City
    415     San Francisco
    415     San Rafael
    510     Oakland
    510     Berkeley
    718     Brooklyn
    718     Staten Island
Cities with area code 718:
Brooklyn
Staten Island

程序清单16.15 functor.cpp
#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>

template<class T>
class TooBig
{
private:
    T cutoff;
public:
    TooBig(const T &t) : cutoff(t) {}
    bool operator()(const T &v)
    {
        return v > cutoff;
    }
};

void outint(int n)
{
    std::cout << n << " ";
}

int main()
{
    using std::list;
    using std::cout;
    using std::endl;
    using std::for_each;
    using std::remove_if;

    TooBig<int> f100(100);
    int vals[10] = { 50, 100, 90, 180, 60, 210, 415, 88, 188, 201 };
    list<int> yadayada(vals, vals + 10);
    list<int> etcetera(vals, vals + 10);

    cout << "Original lists:\n";
    for_each(yadayada.begin(), yadayada.end(), outint);
    cout << endl;
    for_each(etcetera.begin(), etcetera.end(), outint);
    cout << endl;
    yadayada.remove_if(f100);
    etcetera.remove_if(TooBig<int>(200));
    cout << "Trimmed lists:\n";
    for_each(yadayada.begin(), yadayada.end(), outint);
    cout << endl;
    for_each(etcetera.begin(), etcetera.end(), outint);
    cout << endl;

    return 0;
}
显示结果如下
Original lists:
50 100 90 180 60 210 415 88 188 201
50 100 90 180 60 210 415 88 188 201
Trimmed lists:
50 100 90 60 88
50 100 90 180 60 88 188

程序清单16.16 funadap.cpp
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>
#include <functional>

const int LIM = 6;

void Show(double);

int main()
{
    using namespace std;
    double arr1[LIM] = { 28, 29, 30, 35, 38, 59 };
    double arr2[LIM] = { 63, 65, 69, 75, 80, 99 };
    vector<double> gr8(arr1, arr1 + LIM);
    vector<double> m8(arr2, arr2 + LIM);
    cout.setf(ios_base::fixed);
    cout.precision(1);
    cout << "gr8:\t";
    for_each(gr8.begin(), gr8.end(), Show);
    cout << endl;
    cout << "m8:\t";
    for_each(m8.begin(), m8.end(), Show);
    cout << endl;

    vector<double> sum(LIM);
    transform(gr8.begin(), gr8.end(), m8.begin(), sum.begin(), plus<double>());
    cout << "sum:\t";
    for_each(sum.begin(), sum.end(), Show);
    cout << endl;

    vector<double> prod(LIM);
    transform(gr8.begin(), gr8.end(), prod.begin(), bind1st(multiplies<double>(), 2.5));
    cout << "prod:\t";
    for_each(prod.begin(), prod.end(), Show);
    cout << endl;

    return 0;
}

void Show(double v)
{
    std::cout.width(6);
    std::cout << v << ' ';
}
显示结果如下
gr8:      28.0   29.0   30.0   35.0   38.0   59.0
m8:       63.0   65.0   69.0   75.0   80.0   99.0
sum:      91.0   94.0   99.0  110.0  118.0  158.0
prod:     70.0   72.5   75.0   87.5   95.0  147.5


程序清单16.17 strgstl.cpp
#include <iostream>
#include <string>
#include <algorithm>

int main()
{
    using namespace std;
    string letters;

    cout << "Enter the letter grouping (quit to quit): ";
    while (cin >> letters && letters != "quit")
    {
        cout << "Permutations of " << letters << endl;
        sort(letters.begin(), letters.end());
        cout << letters << endl;
        while ( next_permutation( letters.begin(), letters.end() ) )
        {
            cout << letters << endl;
        }
        cout << "Enter next sequence (quit to quit): ";
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Enter the letter grouping (quit to quit): Water
Permutations of Water
Waert
Waetr
Waret
Warte
Water
Watre
Weart
Weatr
Werat
Werta
Wetar
Wetra
Wraet
Wrate
Wreat
Wreta
Wrtae
Wrtea
Wtaer
Wtare
Wtear
Wtera
Wtrae
Wtrea
aWert
aWetr
aWret
aWrte
aWter
aWtre
aeWrt
aeWtr
aerWt
aertW
aetWr
aetrW
arWet
arWte
areWt
aretW
artWe
arteW
atWer
atWre
ateWr
aterW
atrWe
atreW
eWart
eWatr
eWrat
eWrta
eWtar
eWtra
eaWrt
eaWtr
earWt
eartW
eatWr
eatrW
erWat
erWta
eraWt
eratW
ertWa
ertaW
etWar
etWra
etaWr
etarW
etrWa
etraW
rWaet
rWate
rWeat
rWeta
rWtae
rWtea
raWet
raWte
raeWt
raetW
ratWe
rateW
reWat
reWta
reaWt
reatW
retWa
retaW
rtWae
rtWea
rtaWe
rtaeW
rteWa
rteaW
tWaer
tWare
tWear
tWera
tWrae
tWrea
taWer
taWre
taeWr
taerW
tarWe
tareW
teWar
teWra
teaWr
tearW
terWa
teraW
trWae
trWea
traWe
traeW
treWa
treaW
Enter next sequence (quit to quit): quit
Done.

程序清单16.18 listrmv.cpp
#include <iostream>
#include <list>
#include <algorithm>

const int LIM = 10;

void Show(int);

int main()
{
    using namespace std;
    int ar[LIM] = { 4, 5, 4, 2, 2, 3, 4, 8, 1, 4 };
    list<int> la(ar, ar + LIM);
    list<int> lb(la);

    cout << "Original list contents:\n\t";
    for_each(la.begin(), la.end(), Show);
    cout << endl;
    la.remove(4);
    cout << "After using the remove() method:\n";
    cout << "la:\t";
    for_each(la.begin(), la.end(), Show);
    cout << endl;
    list<int>::iterator last;
    last = remove(lb.begin(), lb.end(), 4);
    cout << "After using the remove() function:\n";
    cout << "lb:\t";
    for_each(lb.begin(), lb.end(), Show);
    cout << endl;
    lb.erase(last, lb.end());
    cout << "After using the erase() method:\n";
    cout << "lb:\t";
    for_each(lb.begin(), lb.end(), Show);
    cout << endl;

    return 0;
}

void Show(int v)
{
    std::cout << v << ' ';
}
显示结果如下
Original list contents:
        4 5 4 2 2 3 4 8 1 4
After using the remove() method:
la:     5 2 2 3 8 1
After using the remove() function:
lb:     5 2 2 3 8 1 4 8 1 4
After using the erase() method:
lb:     5 2 2 3 8 1

程序清单16.19 usealgo.cpp
#include <iostream>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <iterator>
#include <algorithm>
#include <cctype>

using namespace std;

char toLower(char ch)
{
    return tolower(ch);
}
string &ToLower(string &st);
void display(const string &s);

int main()
{
    vector<string> words;
    cout << "Enter words (enter quit to quit):\n";
    string input;
    while (cin >> input && input != "quit")
    {
        words.push_back(input);
    }

    cout << "You entered the following words:\n";
    for_each(words.begin(), words.end(), display);
    cout << endl;

    set<string> wordset;
    transform(words.begin(), words.end(),
              insert_iterator<set<string> >(wordset, wordset.begin()),
              ToLower);
    cout << "\nAlphabetic list of words:\n";
    for_each(wordset.begin(), wordset.end(), display);
    cout << endl;

    map<string, int> wordmap;
    set<string>::iterator si;
    for (si = wordset.begin(); si != wordset.end(); si++)
    {
        wordmap[*si] = count(words.begin(), words.end(), *si);
    }

    cout << "\nWord frequency:\n";
    for (si = wordset.begin(); si != wordset.end(); si++)
    {
        cout << *si << ": " << wordmap[*si] << endl;
    }

    return 0;
}

string &ToLower(string &st)
{
    transform(st.begin(), st.end(), st.begin(), toLower);
    return st;
}

void display(const string &s)
{
    cout << s << " ";
}
显示结果如下
Enter words (enter quit to quit):
Apple
Orange
Egg
Water
Banana
Sun
Apple
Egg
Water
Sun
Water
World
Water
quit
You entered the following words:
Apple Orange Egg Water Banana Sun Apple Egg Water Sun Water World Water

Alphabetic list of words:
apple banana egg orange sun water world

Word frequency:
apple: 2
banana: 1
egg: 2
orange: 1
sun: 2
water: 4
world: 1

程序清单16.20 valvect.cpp
#include <iostream>
#include <valarray>
#include <vector>
#include <algorithm>

int main()
{
    using namespace std;
    vector<double> data;
    double temp;

    cout << "Enter numbers (<=0 to quit):\n";
    while (cin >> temp && temp > 0)
    {
        data.push_back(temp);
    }
    sort(data.begin(), data.end());
    int size = data.size();
    valarray<double> numbers(size);
    int i;
    for (i = 0; i < size; i++)
    {
        numbers[i] = data[i];
    }
    valarray<double> sq_rts(size);
    sq_rts = sqrt(numbers);
    valarray<double> results(size);
    results = numbers + 2.0 * sq_rts;
    cout.setf(ios_base::fixed);
    cout.precision(4);
    for (i = 0; i < size; i++)
    {
        cout.width(8);
        cout << numbers[i] << ": ";
        cout.width(8);
        cout << results[i] << endl;
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Enter numbers (<=0 to quit):
1 2 3 4 5 6 7 8 9 -1
  1.0000:   3.0000
  2.0000:   4.8284
  3.0000:   6.4641
  4.0000:   8.0000
  5.0000:   9.4721
  6.0000:  10.8990
  7.0000:  12.2915
  8.0000:  13.6569
  9.0000:  15.0000
Done.

程序清单16.21 vslice.cpp
#include <iostream>
#include <valarray>
#include <cstdlib>
#include <ctime>

const int SIZE = 12;
typedef std::valarray<int> vint;

void show(const vint &v, int cols);

int main()
{
    using std::slice;
    using std::cout;
    vint valint(SIZE);

    std::srand(std::time(nullptr));

    int i;
    for (i = 0; i < SIZE; ++i)
    {
        valint[i] = std::rand() % 10;
    }
    cout << "Original array:\n";
    show(valint, 3);
    vint vcol(valint[slice(1, 4, 3)]);
    cout << "Second column:\n";
    show(vcol, 1);
    vint vrow(valint[slice(3, 3, 1)]);
    cout << "Second row:\n";
    show(vrow, 3);
    valint[slice(2, 4, 3)] = 10;
    cout << "Set last column to 10:\n";
    show(valint, 3);
    cout << "Set first column to sum of next two:\n";
    valint[slice(0, 4, 3)] = vint(valint[slice(1, 4, 3)])
                             + vint(valint[slice(2, 4, 3)]);
    show(valint, 3);

    return 0;
}

void show(const vint &v, int cols)
{
    using std::cout;
    using std::endl;

    int lim = v.size();
    int i;
    for (i = 0; i < lim; ++i)
    {
        cout.width(3);
        cout << v[i];
        if (i % cols == cols - 1)
        {
            cout << endl;
        }
        else
        {
            cout << ' ';
        }
    }
    if (i % cols != 0)
    {
        cout << endl;
    }
}
显示结果如下
Original array:
  7   1   4
  2   2   5
  4   1   0
  0   1   2
Second column:
  1
  2
  1
  1
Second row:
  2   2   5
Set last column to 10:
  7   1  10
  2   2  10
  4   1  10
  0   1  10
Set first column to sum of next two:
 11   1  10
 12   2  10
 11   1  10
 11   1  10

程序清单16.22 ilist.cpp
#include <iostream>
#include <initializer_list>

double sum(std::initializer_list<double> il);
double average(const std::initializer_list<double> &ril);

int main()
{
    using std::cout;

    cout << "List 1: sum = " << sum({ 2, 3, 4 })
         << ", ave = " << average({ 2, 3, 4 }) << '\n';
    std::initializer_list<double> dl = { 1.1, 2.2, 3.3, 4.4, 5.5 };
    cout << "List 2: sum = " << sum(dl)
         << ", ave = " << average(dl) << '\n';
    dl = { 16.0, 25.0, 36.0, 40.0, 64.0 };
    cout << "List 3: sum = " << sum(dl)
         << ", ave = " << average(dl) << '\n';

    return 0;
}

double sum(std::initializer_list<double> il)
{
    double tot = 0;
    for (auto p = il.begin(); p != il.end(); p++)
    {
        tot += *p;
    }
    return tot;
}

double average(const std::initializer_list<double> &ril)
{
    double tot = 0;
    int n = ril.size();
    double ave = 0.0;

    if (n > 0)
    {
        for (auto p = ril.begin(); p != ril.end(); p++)
        {
            tot += *p;
        }
        ave = tot / n;
    }
    return ave;
}
显示结果如下
List 1: sum = 9, ave = 3
List 2: sum = 16.5, ave = 3.3
List 3: sum = 181, ave = 36.2

16.9复习题
1.考虑下面的类声明：
class RQ1
{
private:
    char * st;
public:
    RQ1() {st =new char[1];strcpy (st, "");}
    RQ1 (const char * s) { st =new char[strlen(s)+1]; strcpy(st, s);}
    RQ1 (const RQ1 & rq) { st =new char[strlen(rq.st)+1]; strcpy(st, rq.st);}
    ~RQ1() { delete [ ] st; }
    RQ & operator = (const RQ & rq);
};
将它转换为使用string对象的声明。哪些方法不再需要显式定义？
不再需要显式复制构造函数、析构程序和赋值运算符，因为string对象提供了自己的内存管理功能。

2.在易于使用方面，指出string对象至少两个优于C风格字符串的地方。
可以将一个string对象赋给另一个。string对象提供了自己的内存管理功能，所以一般不需要担心字符串超出存储容量。

3.编写一个函数，用string对象作为参数，将string对象转换为全部大写。
#include <string>
#include <cctype>

void ToUpper(std::string & str)
{
    for (int i = 0; i < str.size(); i++)
    {
        str[i] = std::toupper(str[i]);
    }
}
4.从概念上或语法上说，下面哪个不是正确使用auto_ptr的方法（假设已经包含了所需的头文件）？
auto_ptr<int> pia = new int[20];   // wrong, use with new, not new []
auto_ptr<string> (new string);   // wrong, no name for pointer
int rigue = 7;
auto_ptr<int> pr (&rigue);   // wrong, use with new, not variable
auto_ptr dbl = new double;   // wrong, auto_ptr<double>

5.如果可以生成一个存储高尔夫球棍（而不是数字）的栈，为何它（从概念上说）是一个坏的高尔夫袋子？
栈的特点是后入先出，每次只能从栈顶取数据。所以，要得到想要的数据，可能要先从栈顶取出很多其他数据。

6.为什么说对于逐洞记录高尔夫成绩来说，set容器是糟糕的选择？
set不允许键值重复，如果需要重复插入键值，可以使用multiset。

7.既然指针是一个迭代器，为什么STL设计人员没有简单地使用指针来代替迭代器呢？
使用迭代器能够遍历不以数组方式组织的数据，如双向链表中的数据。

8.为什么STL设计人员仅定义了迭代器基类，而使用继承来派生其他迭代器类型的类，并根据这些迭代器类来表示算法？
这样可以将STL函数用于指向常规数组的常规指针以及指向STL容器类的迭代器，提高了通用性。

9.给出vector对象比常规数组方便的3个例子。
可以将一个vector对象赋给另一个。vector管理自己的内存，因此可以将元素插入到矢量中，并让它自动调整长度。
使用at()方法，可以自动检查边界。

10.如果程序清单16.9是使用list（而不是vector）实现的，则该程序的哪些部分将是非法的？
非法部分能够轻松修复吗？如果可以，如何修复呢？
sort函数和random_shuffle函数要求随机访问迭代器，而list对象只有双向迭代器。可以使用list 模板类的sort成员函数，而不是通用函数来排序，
但没有与random_shuffle等效的成员函数。然而，可以将list复制到vector中，然后调用random_shuffle函数，并将结果重新复制到链表中。

11.假设有程序清单16.15所示的函数符TooBig，下面的代码有何功能？赋给bo的是什么值？
bool bo = TooBig<int>(10)(15);
15 > 10
bo = true

16.10编程练习
1.回文指的是顺读和逆读都一样的字符串。例如，“tot”和“otto”都是简短的回文。
编写一个程序，让用户输入字符串，并将字符串引用传递给一个bool函数。
如果字符串是回文，该函数将返回true，否则返回false。
#include <iostream>
#include <string>

bool isPalindrome(std::string &str);

int main()
{
    std::cout << "Enter a string: ";
    std::string str;
    std::getline(std::cin, str, '\n');

    if (isPalindrome(str))
    {
        std::cout << str << " is a palindrome" << std::endl;
    }
    else
    {
        std::cout << str << " is not a palindrome" << std::endl;
    }

    return 0;
}

bool isPalindrome(std::string &str)
{
    for (int i = 0, j = str.size() - 1; i < j; i++, j--)
    {
        if (str[i] != str[j])
        {
            return false;
        }
    }
    return true;
}
显示结果如下
Enter a string: aBBa
aBBa is a palindrome

Enter a string: Hello
Hello is not a palindrome

Enter a string: otto
otto is a palindrome

Enter a string: tot
tot is a palindrome

2.与编程练习1中给出的问题相同，但要考虑诸如大小写、空格和标点符号这样的复杂问题。
#include <iostream>
#include <string>
#include <cctype>

bool isPalindrome(std::string &str);

int main()
{
    std::cout << "Enter a string: ";
    std::string str;
    std::getline(std::cin, str, '\n');

    if (isPalindrome(str))
    {
        std::cout << str << " is a palindrome" << std::endl;
    }
    else
    {
        std::cout << str << " is not a palindrome" << std::endl;
    }

    return 0;
}

bool isPalindrome(std::string &str)
{
    std::string palind;
    for (int i = 0; i < str.size(); i++)
    {
        if (isalpha(str[i]))
        {
            palind.push_back(tolower(str[i]));
        }
    }

    for (int i = 0, j = palind.size() - 1; i < j; i++, j--)
    {
        if (palind[i] != palind[j])
        {
            return false;
        }
    }
    return true;
}
显示结果如下
Enter a string: Aba
Aba is a palindrome

Enter a string: cBa
cBa is not a palindrome

Enter a string: Toot
Toot is a palindrome

3.修改程序清单16.3，使之从文件中读取单词。一种方案是，使用vector<string>对象而不是string数组。
#include <iostream>
#include <string>
#include <cstdlib>
#include <ctime>
#include <cctype>
#include <fstream>
#include <vector>

int main()
{
    std::ifstream myfile("ch16_p03.txt");

    if (!myfile.good())
    {
        std::cout << "Unable to open Text.txt" << std::endl;
        exit(EXIT_FAILURE);
    }

    std::vector<std::string> wordlist;
    std::string word;
    while (myfile >> word)
    {
        wordlist.push_back(word);
    }
    myfile.close();

    long num = wordlist.size();

    std::srand(std::time(nullptr));

    char play;
    std::cout << "Will you play a word game? <y/n> ";
    std::cin >> play;
    while (std::cin.get() != '\n')
    {
        continue;
    }
    play = std::tolower(play);

    while (play == 'y')
    {
        std::string target = wordlist[std::rand() % num];
        int length = target.length();
        std::string attempt(length, '-');
        std::string badchars;
        int guesses = 6;

        std::cout << "Guess my secret word. It has " << length;
        std::cout << " letters, and you guess\n";
        std::cout << "one letter at a time. You get " << guesses;
        std::cout << " wrong guesses.\n";
        std::cout << "Your word: " << attempt << std::endl;

        while (guesses > 0 && attempt != target)
        {
            char letter;
            std::cout << "Guess a letter: ";
            std::cin >> letter;
            while (std::cin.get() != '\n')
            {
                continue;
            }
            if (badchars.find(letter) != std::string::npos || attempt.find(letter) != std::string::npos)
            {
                std::cout << "You already guessed that. Try again.\n";
                continue;
            }

            int loc = target.find(letter);
            if (loc == std::string::npos)
            {
                std::cout << "Oh, bad guess!\n";
                --guesses;
                badchars += letter;
            }
            else
            {
                std::cout << "Good guess!\n";
                attempt[loc] = letter;
                loc = target.find(letter, loc + 1);
                while (loc != std::string::npos)
                {
                    attempt[loc] = letter;
                    loc = target.find(letter, loc + 1);
                }
            }
            std::cout << "Your word: " << attempt << std::endl;
            if (attempt != target)
            {
                if (badchars.length() > 0)
                {
                    std::cout << "Bad choices: " << badchars << std::endl;
                }
                std::cout << guesses << " bad guesses left\n";
            }
        }
        if (guesses > 0)
        {
            std::cout << "That's right!\n";
        }
        else
        {
            std::cout << "Sorry, the word is " << target << ".\n";
        }

        std::cout << "Will you play another? <y/n> ";
        std::cin >> play;
        while (std::cin.get() != '\n')
        {
            continue;
        }
        play = std::tolower(play);
    }
    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Will you play a word game? <y/n> y
Guess my secret word. It has 3 letters, and you guess
one letter at a time. You get 6 wrong guesses.
Your word: ---
Guess a letter: S
Good guess!
Your word: S--
6 bad guesses left
Guess a letter: u
Good guess!
Your word: Su-
6 bad guesses left
Guess a letter: n
Good guess!
Your word: Sun
That's right!
Will you play another? <y/n> y
Guess my secret word. It has 5 letters, and you guess
one letter at a time. You get 6 wrong guesses.
Your word: -----
Guess a letter: A
Oh, bad guess!
Your word: -----
Bad choices: A
5 bad guesses left
Guess a letter: W
Good guess!
Your word: W----
Bad choices: A
5 bad guesses left
Guess a letter: a
Good guess!
Your word: Wa---
Bad choices: A
5 bad guesses left
Guess a letter: t
Good guess!
Your word: Wat--
Bad choices: A
5 bad guesses left
Guess a letter: a
You already guessed that. Try again.
Guess a letter: b
Oh, bad guess!
Your word: Wat--
Bad choices: Ab
4 bad guesses left
Guess a letter: e
Good guess!
Your word: Wate-
Bad choices: Ab
4 bad guesses left
Guess a letter: r
Good guess!
Your word: Water
That's right!
Will you play another? <y/n> n
Done.

cat ch16_p03.txt
Apple Orange Egg Sun Water Food

4.编写一个具有老式风格接口的函数，其原型如下：
int reduce (long ar[], int n);
实参应是数组名和数组中的元素个数。该函数对数组进行排序，删除重复的值，返回缩减后数组中的元素数目。
请使用STL函数编写该函数（如果决定使用通用的unique（）函数，请注意它将返回结果区间的结尾）。使用一个小程序测试该函数。
#include <iostream>
#include <vector>
#include <algorithm>

const int SIZE = 15;

int reduce(long ar[], int n);

int main()
{

    std::cout << "Enter up to " << SIZE << " numbers (quit to quit):";

    long num = 0;
    long ar[SIZE];
    int i = 0;

    while (std::cin >> num && i < SIZE)
    {
        ar[i++] = num;
    }

    if (0 == i)
    {
        std::cout << "No values were entered" << std::endl;
        return 0;
    }

    std::cout << "You entered ";
    for (int j = 0; j < i; j++)
    {
        std::cout << ar[j] << " ";
    }
    std::cout << std::endl;

    std::cout << "Here's your sorted array, without duplicates: ";

    int j = reduce(ar, i);
    for (int k = 0; k < j; k++)
    {
        std::cout << ar[k] << " ";
    }
    std::cout << std::endl;

    return 0;
}

int reduce(long ar[], int n)
{
    std::vector<long> var;
    for (int i = 0; i < n; i++)
    {
        var.push_back(ar[i]);
    }

    sort(var.begin(), var.end());
    std::vector<long>::iterator end = unique(var.begin(), var.end());
    var.erase(end, var.end());
    std::vector<long>::iterator iv = var.begin();

    for (int i = 0; iv != var.end(); iv++, i++)
    {
        ar[i] = *iv;
    }
    return var.size();
}
显示结果如下
Enter up to 15 numbers (quit to quit):
1 3 5 7 9 1 2 3 5 6 7 8 q
You entered 1 3 5 7 9 1 2 3 5 6 7 8
Here's your sorted array, without duplicates: 1 2 3 5 6 7 8 9

5.问题与编程练习4相同，但要编写一个模板函数：
template <classT>
int reduce (T ar[], int n);
在一个使用long实例和string实例的小程序中测试该函数。
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <cctype>
#include <cstdlib>

const int SIZE = 15;

template <typename T>
int reduce(T ar[], int n);

template <>
int reduce<std::string>(std::string ar[], int n);

template <typename T>
int data_input(T ar[], int n);

template <>
int data_input<std::string>(std::string ar[], int n);

template <typename T>
void display(T ar[], int begin, int end);

bool string_compare(std::string s1, std::string s2);

int main()
{
    std::cout << "Would you like to enter strings or integers? "
              << "(s for strings, i for integers)" << std::endl;
    char ch;
    ch = std::cin.get();
    while (std::cin.get() != '\n')
    {
        continue;
    }
    ch = tolower(ch);
    if (ch != 's' && ch != 'i')
    {
        std::cout << "Input should be \"s\" or \"i\" (case insensitive)";
        std::cout << std::endl;
        std::cout << "Program abort" << std::endl;
        exit(EXIT_FAILURE);
    }

    if (ch == 's')
    {
        std::string sar[SIZE];
        int values = data_input(sar, SIZE);

        if (0 == values)
        {
            std::cout << "No values were entered" << std::endl;
            return 0;
        }

        std::cout << "You entered ";
        display(sar, 0, values);

        std::cout << "Here's your sorted array, without duplicates: \n";
        int j = reduce(sar, values);
        display(sar, 0, j);
    }
    else
    {
        long ar[SIZE];
        int values = data_input(ar, SIZE);

        if (0 == values)
        {
            std::cout << "No values were entered" << std::endl;
            return 0;
        }

        std::cout << "You entered ";
        display(ar, 0, values);

        std::cout << "Here's your sorted array, without duplicates: \n";
        int j = reduce(ar, values);
        display(ar, 0, j);
    }

    return 0;
}
template <typename T>
int reduce(T ar[], int n)
{
    typename std::vector<T> var;
    for (int i = 0; i < n; i++)
    {
        var.push_back(ar[i]);
    }

    sort(var.begin(), var.end());
    typename std::vector<T>::iterator end = unique(var.begin(), var.end());
    var.erase(end, var.end());
    typename std::vector<T>::iterator iv = var.begin();

    for (int i = 0; iv != var.end(); iv++, i++)
    {
        ar[i] = *iv;
    }
    return var.size();
}
template <>
int reduce<std::string>(std::string ar[], int n)
{
    std::vector<std::string> var;
    for (int i = 0; i < n; i++)
    {
        var.push_back(ar[i]);
    }

    sort(var.begin(), var.end(), string_compare);
    std::vector<std::string>::iterator end = unique(var.begin(), var.end());
    var.erase(end, var.end());
    std::vector<std::string>::iterator iv = var.begin();

    for (int i = 0; iv != var.end(); iv++, i++)
    {
        ar[i] = *iv;
    }
    return var.size();
}
template <typename T>
int data_input(T ar[], int n)
{
    std::cout << "Enter up to " << n << " values (quit to quit):";

    T value;
    int i = 0;

    while (std::cin >> value && i < n)
    {
        ar[i++] = value;
    }
    return i;
}
template <>
int data_input<std::string>(std::string ar[], int n)
{
    std::cout << "Enter up to " << n << " strings (quit to quit):";

    std::string value;
    int i = 0;

    while (std::cin >> value && i < n && value != "quit")
    {
        ar[i++] = value;
    }
    return i;
}
template <class T>
void display(T ar[], int begin, int end)
{
    for (int k = begin; k < end; k++)
    {
        std::cout << ar[k] << " ";
    }
    std::cout << std::endl;
}
bool string_compare(std::string s1, std::string s2)
{
    transform(s1.begin(), s1.end(), s1.begin(), ::tolower);
    transform(s2.begin(), s2.end(), s2.begin(), ::tolower);
    return s1 < s2;
}
显示结果如下
Would you like to enter strings or integers? (s for strings, i for integers)
i
Enter up to 15 values (quit to quit):
1 2 3 5 6 7 8 9 3 6 5 1 3 q
You entered 1 2 3 5 6 7 8 9 3 6 5 1 3
Here's your sorted array, without duplicates:
1 2 3 5 6 7 8 9

Would you like to enter strings or integers? (s for strings, i for integers)
s
Enter up to 15 strings (quit to quit):
Apple
Orange
Banana
Egg
Apple
Water
Sun
Strawberry
Egg
quit
You entered Apple Orange Banana Egg Apple Water Sun Strawberry Egg
Here's your sorted array, without duplicates:
Apple Banana Egg Orange Strawberry Sun Water

6.使用STL queue模板类而不是第12章的Queue类，重新编写程序清单12.12所示的示例。
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <queue>

const int MIN_PER_HR = 60;

class Customer
{
private:
    long arrive;
    int processtime;
public:
    Customer()
    {
        arrive = processtime = 0;
    }
    void set(long when);
    long when() const
    {
        return arrive;
    }
    int ptime() const
    {
        return processtime;
    }
};

void Customer::set(long when)
{
    processtime = std::rand() % 3 + 1;
    arrive = when;
}

bool newcustomer(double x);

int main()
{
    std::srand(std::time(nullptr));

    std::cout << "Case Study: Bank of Heather Automatic Teller\n";
    std::cout << "Enter maximum size of queue: ";
    int qs = 0;
    std::cin >> qs;

    std::queue<Customer> line;

    std::cout << "Enter the number of simulation hours: ";
    int hours = 0;
    std::cin >> hours;
    long cyclelimit = MIN_PER_HR * hours;

    std::cout << "Enter the average number of customers per hour: ";
    double perhour = 0.0;
    std::cin >> perhour;

    double min_per_cust = MIN_PER_HR / perhour;

    Customer temp;
    long turnaways = 0;
    long customers = 0;
    long served = 0;
    long sum_line = 0;
    int wait_time = 0;
    long line_wait = 0;

    for (long cycle = 0; cycle < cyclelimit; cycle++)
    {
        if (newcustomer(min_per_cust))
        {
            if (line.size() == (unsigned)qs)
            {
                turnaways++;
            }
            else
            {
                customers++;
                temp.set(cycle);
                line.push(temp);
            }
        }
        if (wait_time <= 0 && !line.empty())
        {
            temp = line.front();
            line.pop();
            wait_time = temp.ptime();
            line_wait += cycle - temp.when();
            served++;
        }
        if (wait_time > 0)
        {
            wait_time--;
        }
        sum_line += line.size();
    }

    if (customers > 0)
    {
        std::cout << "customers accepted: " << customers << std::endl;
        std::cout << "customers served: " << served << std::endl;
        std::cout << "customers turnaways: " << turnaways << std::endl;
        std::cout << "average queue size: ";
        std::cout.precision(2);
        std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);
        std::cout.setf(std::ios_base::showpoint);
        std::cout << (double)sum_line / cyclelimit << std::endl;
        std::cout << "average wait time: ";
        std::cout << (double)line_wait / served << " minutes\n";
    }
    else
    {
        std::cout << "No customers!\n";
    }
    std::cout << "Done.\n";

    return 0;
}
bool newcustomer(double x)
{
    return ( (std::rand() * x) / RAND_MAX < 1);
}
显示结果如下
Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 10
Enter the number of simulation hours: 100
Enter the average number of customers per hour: 30
customers accepted: 2927
customers served: 2923
customers turnaways: 92
average queue size: 4.85
average wait time: 9.94 minutes
Done.

7.彩票卡是一个常见的游戏。卡片上是带编号的圆点，其中一些圆点被随机选中。编写一个lotto()函数，它接受两个参数。
第一个参数是彩票卡上圆点的个数，第二个参数是随机选择的圆点个数。
该函数返回一个vector<int>对象，其中包含（按排列后的顺序）随机选择的号码。
编写一个小程序来测试这个函数。
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdlib>

std::vector<int> Lotto(int spots, int selected);

int main()
{
    std::cout << "Enter the number of spots on the lottery card: ";
    int spots = 0;
    std::cin >> spots;

    std::cout << "Enter the number of spots to be selected: ";
    int selected = 0;
    std::cin >> selected;

    std::vector<int> result = Lotto(spots, selected);
    std::cout << "Your lucky numbers are: ";

    for (int i = 0; i < result.size(); i++)
    {
        std::cout << result[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}

std::vector<int> Lotto(int spots, int selected)
{
    if (spots < selected)
    {
        std::cout << "The second argument of Lotto() must be less than ";
        std::cout << "the first argument." << std::endl;
        std::cout << "Program abort" << std::endl;
        exit(EXIT_FAILURE);
    }

    if (spots < 0 || selected < 0)
    {
        std::cout << "Both arguments of Lotto() must be positive integers";
        std::cout << std::endl;
        std::cout << "Program abort" << std::endl;
        exit(EXIT_FAILURE);
    }

    std::vector<int> v;
    for (int i = 1; i < spots + 1; i++)
    {
        v.push_back(i);
    }

    random_shuffle(v.begin(), v.end());

    std::vector<int> picks;
    for (int i = 0; i < selected; i++)
    {
        picks.push_back(v[i]);
    }
    return picks;
}
显示结果如下
Enter the number of spots on the lottery card: 51
Enter the number of spots to be selected: 6
Your lucky numbers are: 5 29 12 16 25 36

8.Mat和Pat：希望邀请他们的朋友来参加派对。他们要编写一个程序完成下面的任务。
让Mat 输入他朋友的姓名列表。姓名存储在一个容器中，然后按排列后的顺序显示出来。
让Pat输入她朋友的姓名列表。姓名存储在另一个容器中；然后按排列后的顺序显示出来。
创建第三个容器，将两个列表合并，删除重复的部分，并显示这个容器的内容。
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <cctype>
#include <iterator>
#include <string>

bool string_compare(std::string s1, std::string s2);

int main()
{
    std::cout << "Enter Mat's list of friends ";
    std::cout << "(enter after each name, quit to quit):\n";

    std::vector<std::string> mat_list;

    std::string name;
    std::getline(std::cin, name, '\n');
    while (name != "quit")
    {
        if (name != "")
        {
            mat_list.push_back(name);
        }
        std::getline(std::cin, name, '\n');
    }
    std::cout << std::endl;

    std::cout << "Enter Pat's list of friends ";
    std::cout << "(enter after each name, quit to quit):\n";
    std::vector<std::string> pat_list;

    std::getline(std::cin, name, '\n');
    while (name != "quit")
    {
        if (name != "")
        {
            pat_list.push_back(name);
        }
        std::getline(std::cin, name, '\n');
    }
    std::cout << std::endl;

    sort(mat_list.begin(), mat_list.end(), string_compare);
    sort(pat_list.begin(), pat_list.end(), string_compare);
    std::vector<std::string> merged_list;
    std::insert_iterator<std::vector<std::string>> insert(merged_list, merged_list.begin());
    set_union(mat_list.begin(), mat_list.end(), pat_list.begin(), pat_list.end(), insert, string_compare);

    std::cout << "Here is our guestlist: " << std::endl;

    for (int i = 0; i < merged_list.size(); i++)
    {
        std::cout << merged_list[i] << std::endl;
    }

    return 0;
}

bool string_compare(std::string s1, std::string s2)
{
    transform(s1.begin(), s1.end(), s1.begin(), ::tolower);
    transform(s2.begin(), s2.end(), s2.begin(), ::tolower);
    return s1 < s2;
}
显示结果如下
Enter Mat's list of friends (enter after each name, quit to quit):
Peter Smith
Mike Pence
Hello World
Apple Mike
Orange Egg
quit

Enter Pat's list of friends (enter after each name, quit to quit):
Mike Pence
Orange Egg
Sun Java
Water Earth
quit

Here is our guestlist:
Apple Mike
Hello World
Mike Pence
Orange Egg
Peter Smith
Sun Java
Water Earth

9.相对手数组，在链表中添加和删除元素更容易，但排速度更慢。这就引出了一种可能性：
相对于使用链表算法进行排序，将链表复制到数组中，对数组进行排序，再将排序后的结果复制到链表中的速度可能更块；
但这也可能占用更多的内存。请使用如下方法检验上述假设。
a.创建大型vector<int>对象vi0，并使用rand()给它提供初始值。
b.创建vector<int>对象vi和list<int>对象li，它们的长度都和初始值与vi0相同。
c.计算使用STL算法sort()对vi进行排序所需的时间，再计算使用list的方法sort()对li进行排序所需的时间。
d.将li重置为排序的vi0的内容，并计算执行如下操作所需的时间：将li的内容复制到vi中，对vi进行排序，并将结果复制到 li 中。
#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include <cstdlib>
#include <ctime>

int main()
{
    std::srand(std::time(nullptr));
    std::vector <int> vi0(100000);

    for (int i = 0; i < 100000; i++)
    {
        vi0[i] = std::rand();
    }

    std::vector<int> vi = vi0;
    std::list<int> li(100000);
    copy(vi0.begin(), vi0.end(), li.begin());

    clock_t start = clock();
    sort(vi.begin(), vi.end());

    clock_t end = clock();
    std::cout << (double)(end - start) / CLOCKS_PER_SEC << std::endl;

    start = clock();
    li.sort();
    end = clock();
    std::cout << (double)(end - start) / CLOCKS_PER_SEC << std::endl;

    copy(vi0.begin(), vi0.end(), li.begin());

    start = clock();
    copy(li.begin(), li.end(), vi.begin());
    sort(vi.begin(), vi.end());
    copy(vi.begin(), vi.end(), li.begin());
    end = clock();

    std::cout << (double)(end - start) / CLOCKS_PER_SEC << std::endl;

    return 0;
}
显示结果如下
0.035057
0.083333
0.051078

10.请按如下方式修改程序清单16.9（vect3.cpp）。
a.在结构Review中添加成员price。
b.不使用vector<Review>来存储输入，而使用vector<shared_ptr<Review>>。别忘了，必须使用new返回的指针来初始化shared_ptr。
c.在输入阶段结束后，使用一个循环让用户选择如下方式之一显示书籍：
按原始顺序显示、按字母表顺序显示、按评级升序显示、按评级降序显示、按价格升序显示、按价格降序显示、退出。
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <algorithm>

const int SIZE = 2;

struct Review
{
    std::string title;
    int rating;
    int price;
};

bool operator < (const std::shared_ptr<Review> &r1, const std::shared_ptr<Review> &r2);
bool sortByTitle(const std::shared_ptr<Review> &r1, const std::shared_ptr<Review> &r2);
bool sortByRating(const std::shared_ptr<Review> &r1, const std::shared_ptr<Review> &r2);
bool sortByPrice(const std::shared_ptr<Review> &r1, const std::shared_ptr<Review> &r2);
bool FillReview(Review &rr);
void ShowReview(const std::shared_ptr<Review> &rr);
void print_menu();

int main()
{
    std::vector<std::shared_ptr<Review> > books;
    Review temp;

    while (FillReview(temp))
    {
        std::shared_ptr<Review> t(new Review);
        t->title = temp.title;
        t->rating = temp.rating;
        t->price = temp.price;
        books.push_back(t);
    }
    print_menu();

    char select;
    while (std::cin >> select && select != 'q')
    {
        while (std::cin.get() != '\n')
        {
            continue;
        }
        switch (select)
        {
        case 'f':
            std::cout << "Title reserve output:\nRating\tTitle\tPrice" << std::endl;
            for_each(books.rbegin(), books.rend(), ShowReview);
            print_menu();
            break;
        case 't':
            std::cout << "Sort by title:\nRating\tTitle\tPrice" << std::endl;
            sort(books.begin(), books.end(), sortByTitle);
            for_each(books.begin(), books.end(), ShowReview);
            print_menu();
            break;
        case 'r':
            std::cout << "Sort by rating:\nRating\tTitle\tPrice" << std::endl;
            sort(books.begin(), books.end(), sortByRating);
            for_each(books.begin(), books.end(), ShowReview);
            print_menu();
            break;
        case 'p':
            std::cout << "Sort by price:\nRating\tTitle\tPrice" << std::endl;
            sort(books.begin(), books.end(), sortByPrice);
            for_each(books.begin(), books.end(), ShowReview);
            print_menu();
            break;
        default:
            std::cout << "please enter f, t, r, p or q.\n";
            print_menu();
            break;
        }
    }

    std::cout << "Done.\n";

    return 0;
}

bool operator<(const std::shared_ptr<Review> &r1, const std::shared_ptr<Review> &r2)
{
    if (r1->title < r2->title)
    {
        return true;
    }
    else if (r1->title == r2->title && r1->rating < r2->rating)
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool sortByTitle(const std::shared_ptr<Review> &r1, const std::shared_ptr<Review> &r2)
{
    if (r1->title < r2->title)
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool sortByRating(const std::shared_ptr<Review> &r1, const std::shared_ptr<Review> &r2)
{
    if (r1->rating < r2->rating)
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool sortByPrice(const std::shared_ptr<Review> &r1, const std::shared_ptr<Review> &r2)
{
    if (r1->price < r2->price)
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool FillReview(Review &rr)
{
    std::cout << "Enter book title (quit to quit): ";
    std::getline(std::cin, rr.title, '\n');

    if (rr.title == "quit")
    {
        return false;
    }

    std::cout << "Enter book rating: ";
    std::cin >> rr.rating;

    if (!std::cin)
    {
        return false;
    }

    std::cout << "Enter book price: ";
    std::cin >> rr.price;

    if (!std::cin)
    {
        return false;
    }

    while (std::cin.get() != '\n')
    {
        continue;
    }
    return true;
}

void ShowReview(const std::shared_ptr<Review> &rr)
{
    std::cout << rr->rating << "\t" << rr->title << "\t" << rr->price << std::endl;
}
void print_menu()
{
    std::cout << "Please select the sort:" << std::endl;
    std::cout << "t.sort by title       r.sort by rating" << std::endl;
    std::cout << "p.sort by price       f.sort by title reserve" << std::endl;
    std::cout << "q.quit" << std::endl;
}
显示结果如下
Enter book title (quit to quit): Peter Smith
Enter book rating: 3
Enter book price: 6
Enter book title (quit to quit): Mike Pence
Enter book rating: 2
Enter book price: 1
Enter book title (quit to quit): Hello World
Enter book rating: 9
Enter book price: 11
Enter book title (quit to quit): Apple
Enter book rating: 8
Enter book price: 9
Enter book title (quit to quit): Orange
Enter book rating: 3
Enter book price: 11
Enter book title (quit to quit): Egg
Enter book rating: 2
Enter book price: 7
Enter book title (quit to quit): quit
Please select the sort:
t.sort by title       r.sort by rating
p.sort by price       f.sort by title reserve
q.quit
f
Title reserve output:
Rating  Title   Price
2       Egg     7
3       Orange  11
8       Apple   9
9       Hello World     11
2       Mike Pence      1
3       Peter Smith     6
Please select the sort:
t.sort by title       r.sort by rating
p.sort by price       f.sort by title reserve
q.quit
p
Sort by price:
Rating  Title   Price
2       Mike Pence      1
3       Peter Smith     6
2       Egg     7
8       Apple   9
9       Hello World     11
3       Orange  11
Please select the sort:
t.sort by title       r.sort by rating
p.sort by price       f.sort by title reserve
q.quit
r
Sort by rating:
Rating  Title   Price
2       Mike Pence      1
2       Egg     7
3       Peter Smith     6
3       Orange  11
8       Apple   9
9       Hello World     11
Please select the sort:
t.sort by title       r.sort by rating
p.sort by price       f.sort by title reserve
q.quit
t
Sort by title:
Rating  Title   Price
8       Apple   9
2       Egg     7
9       Hello World     11
2       Mike Pence      1
3       Orange  11
3       Peter Smith     6
Please select the sort:
t.sort by title       r.sort by rating
p.sort by price       f.sort by title reserve
q.quit
q
Done.

第17章 输入、输出和文件
17.1 C++输入和输出概述
17.1.1 流和缓冲区
17.1.2 流、缓冲区和iostream文件
17.1.3 重定向
17.2 使用cout进行输出
17.2.1 重载的<<运算符
17.2.2 其他ostream方法
17.2.3 刷新输出缓冲
17.2.4 用cout进行格式化
17.3 使用cin进行输入
17.3.1 cin>>如何检查输入
17.3.2 流状态
17.3.3 其他istream类方法
17.3.4 其他istream方法
17.4 文件输入和输出
17.4.1 简单的文件I/O
17.4.2 流状态检查和 is_open
17.4.3 打开多个文件
17.4.4 命令行处理技术
17.4.5 文件模式
17.4.6 随机存取
17.5 内核格式化
17.6 总结
17.7 复习题
17.8 编程练习
本章内容包括：
C++角度的输入和输出。
iostream类系列。
重定向。
ostream类方法。
格式化输出。
istream类方法。
流状态。
文件I/O。
使用ifstream类从文件输入。
使用ofstream类输出到文件。
使用fstream类进行文件输入和输出。
命令行处理。
二进制文件。
随机文件访问。
内核格式化。
streambuf类为缓冲区提供了内存，并提供了用于填充缓冲区、访问缓冲区内容、刷新缓冲区和管理缓冲区内存的类方法；
ios_base类表示流的一般特征，如是否可读取、是二进制流还是文本流等；
ios类基于ios_base，其中包括了一个指向streambuf对象的指针成员；
ostream类是从ios类派生而来的，提供了输出方法；
istream类也是从ios类派生而来的，提供了输入方法；
iostream类是基于istream和ostream类的，因此继承了输入方法和输出方法。
cin对象对应于标准输入流。在默认情况下，这个流被关联到标准输入设备（通常为键盘）。
wcin对象与此类似，但处理的是wchar_t类型。
cout对象与标准输出流相对应。在默认情况下，这个流被关联到标准输出设备（通常为显示器）。
wcout对象与此类似，但处理的是wchar_t类型。
cerr对象与标准错误流相对应，可用于显示错误消息。在默认情况下，这个流被关联到标准输出设备（通常为显示器）。
这个流没有被缓冲，这意味着信息将被直接发送给屏幕，而不会等到缓冲区填满或新的换行符。
wcerr对象与此类似；但处理的是wchar_t类型。
clog对象也对应着标准错误流。在默认情况下，这个流被关联到标准输出设备（通常为显示器）。这个流被缓冲。
wclog对象与此类似，但处理的是wchar_t类型。
ostream类重载了<<运算符，使之能够识别C++中所有的基本类型。
对于不是char *类型的指针，C++将其对应于void*，并打印地址的数值表示。
如果要获得字符串的地址，则必须将其强制转换为其他类型。
除了各种operator<<()函数外，ostream类还提供了put()法和write()方法，前者用于显示字符，后者用于显示字符串。
write()的第一个参数提供了要显示的字符串的地址，第二个参数指出要显示多少个字符。
程序清单17.1 write.cpp
#include <iostream>
#include <cstring>

int main()
{
    using std::cout;
    using std::endl;
    const char *state1 = "Florida";
    const char *state2 = "Kansas";
    const char *state3 = "Euphoria";
    int len = std::strlen(state2);
    cout << "Increasing loop index:\n";
    int i;
    for (i = 1; i <= len; i++)
    {
        cout.write(state2, i);
        cout << endl;
    }

    cout << "Decreasing loop index:\n";
    for (i = len; i > 0; i--)
    {
        cout.write(state2, i) << endl;
    }

    cout << "Exceeding string length:\n";
    cout.write(state2, len + 5) << endl;

    return 0;
}
注意，write方法并不会在遇到空字符时自动停止打印字符，而只是印指定数目的字符，即使超出了字符串的边界！
显示结果如下
Increasing loop index:
K
Ka
Kan
Kans
Kansa
Kansas
Decreasing loop index:
Kansas
Kansa
Kans
Kan
Ka
K
Exceeding string length:
KansasEuph

控制符flush刷新缓冲区，而控制符endl刷新缓冲区，并插入一个换行符。
事实上，控制符也是函数。ostream类对<<插入运算符进行了重载，使得下述表达式将被替换为函数调用flush(cout)：
cout << flush
程序清单17.2 defaults.cpp
#include <iostream>

int main()
{
    using std::cout;
    cout << "12345678901234567890\n";
    char ch = 'K';
    int t = 273;
    cout << ch << ":\n";
    cout << t << ":\n";
    cout << -t << ":\n";

    double f1 = 1.200;
    cout << f1 << ":\n";
    cout << (f1 + 1.0 / 9.0) << ":\n";

    double f2 = 1.67E2;
    cout << f2 << ":\n";
    f2 += 1.0 / 9.0;
    cout << f2 << ":\n";
    cout << (f2 * 1.0e4) << ":\n";


    double f3 = 2.3e-4;
    cout << f3 << ":\n";
    cout << f3 / 10 << ":\n";

    return 0;
}
显示结果如下
12345678901234567890
K:
273:
-273:
1.2:
1.31111:
167:
167.111:
1.67111e+06:
0.00023:
2.3e-05:


程序清单17.3 manip.cpp
#include <iostream>

int main()
{
    using namespace std;
    cout << "Enter an integer: ";
    int n;
    cin >> n;

    cout << "n     n*n\n";
    cout << n << "     " << n *n << " (decimal)\n";
    cout << hex;
    cout << n << "     ";
    cout << n *n << " (hexadecimal)\n";

    cout << oct << n << "     " << n *n << " (octal)\n";

    dec(cout);
    cout << n << "     " << n *n << " (decimal)\n";

    return 0;
}
显示结果如下
Enter an integer: 32
n     n*n
32     1024 (decimal)
20     400 (hexadecimal)
40     2000 (octal)
32     1024 (decimal)

Enter an integer: 55
n     n*n
55     3025 (decimal)
37     bd1 (hexadecimal)
67     5721 (octal)

可以使用width成员函数将长度不同的数字放到宽度相同的字段中，该方法的原型为：
int width();
int width(int i);
第一种格式返回字段宽度的当前设置；第二种格式将字段宽度设置为i个空格，并返回以前的字段宽度值。
这使得能够保存以前的值，以便以后恢复宽度值时使用。
width()方法只影响将显示的下一个项目，然后字段宽度将恢复为默认值。
程序清单17.4 width.cpp
#include <iostream>

int main()
{
    using std::cout;
    int w = cout.width(30);
    cout << "default field width = " << w << ":\n";

    cout.width(5);
    cout << "N" << ':';
    cout.width(8);
    cout << "N * N" << ":\n";

    for (long i = 1; i <= 100; i *= 10)
    {
        cout.width(5);
        cout << i << ':';
        cout.width(8);
        cout << i *i << ":\n";
    }

    return 0;
}
显示结果如下
        default field width = 0:
    N:   N * N:
    1:       1:
   10:     100:
  100:   10000:

在默认情况下，cout用空格填充字段中未被使用的部分，可以用fill()成员函数来改变填充字符。
程序清单17.5 fill.cpp
#include <iostream>

int main()
{
    using std::cout;
    cout.fill('*');
    const char *staff[2] = { "Waldo Whipsnade", "Wilmarie Wooper" };
    long bonus[2] = { 900, 1350 };

    for (int i = 0; i < 2; i++)
    {
        cout << staff[i] << ": $";
        cout.width(7);
        cout << bonus[i] << "\n";
    }

    return 0;
}
显示结果如下
Waldo Whipsnade: $****900
Wilmarie Wooper: $***1350

C++的浮点数显示精度默认为6位（末尾的0不显示），precision()成员函数使得能够选择其他值。
和width()的情况不同，但与fill类似，新的精度设置将一直有效，直到被重新设置。
程序清单17.6 precise.cpp
#include <iostream>

int main()
{
    using std::cout;
    float price1 = 20.40;
    float price2 = 1.9 + 8.0 / 9.0;

    cout << "\"Furry Friends\" is $" << price1 << "!\n";
    cout << "\"Fiery Fiends\" is $" << price2 << "!\n";

    cout.precision(2);
    cout << "\"Furry Friends\" is $" << price1 << "!\n";
    cout << "\"Fiery Fiends\" is $" << price2 << "!\n";

    return 0;
}
显示结果如下
"Furry Friends" is $20.4!
"Fiery Fiends" is $2.78889!
"Furry Friends" is $20!
"Fiery Fiends" is $2.8!

程序清单17.7 showpt.cpp
#include <iostream>

int main()
{
    using std::cout;
    using std::ios_base;

    float price1 = 20.40;
    float price2 = 1.9 + 8.0 / 9.0;

    cout.setf(ios_base::showpoint);
    cout << "\"Furry Friends\" is $" << price1 << "!\n";
    cout << "\"Fiery Fiends\" is $" << price2 << "!\n";

    cout.precision(2);
    cout << "\"Furry Friends\" is $" << price1 << "!\n";
    cout << "\"Fiery Fiends\" is $" << price2 << "!\n";

    return 0;
}
显示结果如下
"Furry Friends" is $20.4000!
"Fiery Fiends" is $2.78889!
"Furry Friends" is $20.!
"Fiery Fiends" is $2.8!

setf()函数有两个原型。第一个为：
fmtflags setf(fmtflags);
其中，fmtflags是bitmask类型的typedef名，用于存储格式标记。该名称是在ios_base类中定义的。
这个版本的set()用来设置单个位控制的格式信息。参数是一个fmtflags值，指出要设置哪一位。
返回值是类型为fmtflags的数字，指出所有标记以前的设置。如果打算以后恢复原始设置，则可以保存这个值。
程序清单17.8 setf.cpp
#include <iostream>

int main()
{
    using std::cout;
    using std::endl;
    using std::ios_base;

    int temperature = 63;

    cout << "Today's water temperature: ";
    cout.setf(ios_base::showpos);
    cout << temperature << endl;

    cout << "For our programming friends, that's\n";
    cout << std::hex << temperature << endl;
    cout.setf(ios_base::uppercase);
    cout.setf(ios_base::showbase);
    cout << "or\n";
    cout << temperature << endl;
    cout << "How " << true << "!  oops -- How ";
    cout.setf(ios_base::boolalpha);
    cout << true << "!\n";

    return 0;
}
显示结果如下
Today's water temperature: +63
For our programming friends, that's
3f
or
0X3F
How 0X1!  oops -- How true!

第二个setf()原型接受两个参数，并返回以前的设置：
fmtflage setf (fmtflags, fmtflags);
第一个参数和以前一样，也是一个包含了所需设置的fmtflags值。第二参数指出要清除第一个参数中的哪些位。
程序清单17.9 setf2.cpp
#include <iostream>
#include <cmath>

int main()
{
    using namespace std;
    cout.setf(ios_base::left, ios_base::adjustfield);
    cout.setf(ios_base::showpos);
    cout.setf(ios_base::showpoint);
    cout.precision(3);
    ios_base::fmtflags old = cout.setf(ios_base::scientific, ios_base::floatfield);
    cout << "Left Justification:\n";
    long n;
    for (n = 1; n <= 41; n += 10)
    {
        cout.width(4);
        cout << n << "|";
        cout.width(12);
        cout << sqrt(double(n)) << "|\n";
    }

    cout.setf(ios_base::internal, ios_base::adjustfield);
    cout.setf(old, ios_base::floatfield);

    cout << "Internal Justification:\n";
    for (n = 1; n <= 41; n += 10)
    {
        cout.width(4);
        cout << n << "|";
        cout.width(12);
        cout << sqrt(double(n)) << "|\n";
    }

    cout.setf(ios_base::right, ios_base::adjustfield);
    cout.setf(ios_base::fixed, ios_base::floatfield);
    cout << "Right Justification:\n";
    for (n = 1; n <= 41; n += 10)
    {
        cout.width(4);
        cout << n << "|";
        cout.width(12);
        cout << sqrt(double(n)) << "|\n";
    }

    return 0;
}
显示结果如下
Left Justification:
+1  |+1.000e+00  |
+11 |+3.317e+00  |
+21 |+4.583e+00  |
+31 |+5.568e+00  |
+41 |+6.403e+00  |
Internal Justification:
+  1|+       1.00|
+ 11|+       3.32|
+ 21|+       4.58|
+ 31|+       5.57|
+ 41|+       6.40|
Right Justification:
  +1|      +1.000|
 +11|      +3.317|
 +21|      +4.583|
 +31|      +5.568|
 +41|      +6.403|

调用setf()的效果可以通过unsetf()消除，unsetf的原型如下：
void unsetf (fmtflags mask);
setf()将位设置为1，unsetf()将位恢复为0。
cout.unsetf (ios_base::floatfield);   // go to-default mode


程序清单17.10 iomanip.cpp
#include <iostream>
#include <iomanip>
#include <cmath>

int main()
{
    using namespace std;
    cout << fixed << right;

    cout << setw(6) << "N" << setw(14) << "square root"
         << setw(15) << "fourth root\n";

    double root;
    for (int n = 10; n <= 100; n += 10)
    {
        root = sqrt(double(n));
        cout << setw(6) << setfill('.') << n << setfill(' ')
             << setw(12) << setprecision(3) << root
             << setw(14) << setprecision(4) << sqrt(root)
             << endl;
    }

    return 0;
}
显示结果如下
     N   square root   fourth root
....10       3.162        1.7783
....20       4.472        2.1147
....30       5.477        2.3403
....40       6.325        2.5149
....50       7.071        2.6591
....60       7.746        2.7832
....70       8.367        2.8925
....80       8.944        2.9907
....90       9.487        3.0801
...100      10.000        3.1623

通常，可以这样使用cin:
cin >> value_holder;
cin解释输入的方式取决于value_holder 的数据类型。
istream类重载了抽取运算符>>，使之能够识别所有的基本类型。
可以将hex、oct 和dec控制符与cin一起使用，来指定将整数输入解释为十六进制、八进制还是十进制格式。
对于字符指针，istream类将读取输入中的一个单词。
程序清单17.11 check_it.cpp
#include <iostream>

int main()
{
    using namespace std;
    cout << "Enter numbers: ";

    int sum = 0;
    int input;
    while (cin >> input)
    {
        sum += input;
    }

    cout << "Last value entered = " << input << endl;
    cout << "Sum = " << sum << endl;

    return 0;
}
显示结果如下
Enter numbers: 1 2 3 4 5 6 7 8 9 q
Last value entered = 0
Sum = 45

程序清单17.12 cinexcp.cpp
#include <iostream>

int main()
{
    using namespace std;
    cin.exceptions(ios_base::failbit);
    cout << "Enter numbers: ";
    int sum = 0;
    int input;
    try
    {
        while (cin >> input)
        {
            sum += input;
        }
    }
    catch (ios_base::failure &bf)
    {
        cout << bf.what() << endl;
        cout << "O! the horror!\n";
    }

    cout << "Last value entered = " << input << endl;
    cout << "Sum = " << sum << endl;

    return 0;
}
显示结果如下
Enter numbers: 1 2 3 4 5 6 7 8 9 q
basic_ios::clear: iostream error
O! the horror!
Last value entered = 0
Sum = 45

程序清单17.13 get_fun.cpp
#include <iostream>

const int Limit = 255;

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;

    char input[Limit];

    cout << "Enter a string for getline() processing:\n";
    cin.getline(input, Limit, '#');
    cout << "Here is your input:\n";
    cout << input << "\nDone with phase 1\n";

    char ch;
    cin.get(ch);
    cout << "The next input character is " << ch << endl;

    if (ch != '\n')
    {
        cin.ignore(Limit, '\n');
    }

    cout << "Enter a string for get() processing:\n";
    cin.get(input, Limit, '#');
    cout << "Here is your input:\n";
    cout << input << "\nDone with phase 2\n";

    cin.get(ch);
    cout << "The next input character is " << ch << endl;

    return 0;
}
显示结果如下
Enter a string for getline() processing:
Hello World#123 abc
Here is your input:
Hello World
Done with phase 1
The next input character is 1
Enter a string for get() processing:
Hello World#567 efg
Here is your input:
Hello World
Done with phase 2
The next input character is #

getline (char *, int)
如果没有读取任何字符（读取到换行符被视为读取了一个字符），则设置failbit，比如读取到文件结尾EOF
如果读取了最大数目的字符，且行中还有其他字符，则设置failbit
get (char *, int)
如果没有读取任何字符，则设置failbit，比如读取到文件结尾EOF
程序清单17.14 peeker.cpp
#include <iostream>

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;

    char ch;

    while (cin.get(ch))
    {
        if (ch != '#')
        {
            cout << ch;
        }
        else
        {
            cin.putback(ch);
            break;
        }
    }

    if (!cin.eof())
    {
        cin.get(ch);
        cout << endl << ch << " is next input character.\n";
    }
    else
    {
        cout << "End of file reached.\n";
        std::exit(0);
    }

    while (cin.peek() != '#')
    {
        cin.get(ch);
        cout << ch;
    }
    if (!cin.eof())
    {
        cin.get(ch);
        cout << endl << ch << " is next input character.\n";
    }
    else
        cout << "End of file reached.\n";

    return 0;
}
显示结果如下
Hello World#123 abc#
Hello World
# is next input character.
123 abc
# is next input character.

程序清单17.15 truncate.cpp
#include <iostream>

const int SLEN = 10;

inline void eatline()
{
    while (std::cin.get() != '\n') continue;
}

int main()
{
    using std::cin;
    using std::cout;
    using std::endl;

    char name[SLEN];
    char title[SLEN];
    cout << "Enter your name: ";
    cin.get(name, SLEN);
    if (cin.peek() != '\n')
    {
        cout << "Sorry, we only have enough room for "
             << name << endl;
    }
    eatline();
    cout << "Dear " << name << ", enter your title: \n";
    cin.get(title, SLEN);
    if (cin.peek() != '\n')
    {
        cout << "We were forced to truncate your title.\n";
    }
    eatline();
    cout << " Name: " << name
         << "\nTitle: " << title << endl;

    return 0;
}
显示结果如下
Enter your name: Hello World!
Sorry, we only have enough room for Hello Wor
Dear Hello Wor, enter your title:
Peter Smith
We were forced to truncate your title.
 Name: Hello Wor
Title: Peter Smi

程序清单17.16 fileio.cpp
#include <iostream>
#include <fstream>
#include <string>

int main()
{
    using namespace std;
    string filename;

    cout << "Enter name for new file: ";
    cin >> filename;

    ofstream fout(filename.c_str());

    fout << "For your eyes only!\n";
    cout << "Enter your secret number: ";
    double secret;
    cin >> secret;
    fout << "Your secret number is " << secret << endl;
    fout.close();

    ifstream fin(filename.c_str());
    cout << "Here are the contents of " << filename << ":\n";
    char ch;
    while (fin.get(ch))
    {
        cout << ch;
    }
    cout << "Done.\n";
    fin.close();

    return 0;
}
显示结果如下
Enter name for new file: fileio.txt
Enter your secret number: 123.125
Here are the contents of fileio.txt:
For your eyes only!
Your secret number is 123.125
Done.

cat fileio.txt
For your eyes only!
Your secret number is 123.125

程序清单17.17 count.cpp
#include <iostream>
#include <fstream>
#include <cstdlib>

int main(int argc, char *argv[])
{
    using namespace std;
    if (argc == 1)
    {
        cerr << "Usage: " << argv[0] << " filename[s]\n";
        exit(EXIT_FAILURE);
    }

    ifstream fin;
    long count;
    long total = 0;
    char ch;

    for (int file = 1; file < argc; file++)
    {
        fin.open(argv[file]);
        if (!fin.is_open())
        {
            cerr << "Could not open " << argv[file] << endl;
            fin.clear();
            continue;
        }
        count = 0;
        while (fin.get(ch))
        {
            count++;
        }
        cout << count << " characters in " << argv[file] << endl;
        total += count;
        fin.clear();
        fin.close();
    }
    cout << total << " characters in all files\n";

    return 0;
}
显示结果如下
count
Usage: count filename[s]

count fileio.txt
50 characters in fileio.txt
50 characters in all files

ls -l fileio.txt
-rw-r--r-- 1 weiyayun weiyayun 50 Nov  7 06:51 fileio.txt

count count.cpp fileio.txt
876 characters in count.cpp
50 characters in fileio.txt
926 characters in all files

ls -l count.cpp
-rw-r--r-- 1 weiyayun weiyayun 876 Nov  7 07:05 count.cpp

ios::in 为了读取而打开文件
ios::out 为了输出而打开文件
ios::app 在原来文件结尾追加新的输出
ios::ate 在打开文件后立即把位置设为最后
ios::trunc 在打开文件后删除原来文件的内容
ios::binary 以二进制模式打开文件


程序清单17.18 append.cpp
#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>

const char *file = "guests.txt";

int main()
{
    using namespace std;
    char ch;

    ifstream fin;
    fin.open(file);

    if (fin.is_open())
    {
        cout << "Here are the current contents of the "
             << file << " file:\n";
        while (fin.get(ch))
        {
            cout << ch;
        }
        fin.close();
    }

    ofstream fout(file, ios::out | ios::app);
    if (!fout.is_open())
    {
        cerr << "Can't open " << file << " file for output.\n";
        exit(EXIT_FAILURE);
    }

    cout << "Enter guest names (enter a blank line to quit):\n";
    string name;
    while (std::getline(cin, name, '\n') && name.size() > 0)
    {
        fout << name << endl;
    }
    fout.close();

    fin.clear();
    fin.open(file);
    if (fin.is_open())
    {
        cout << "Here are the new contents of the "
             << file << " file:\n";
        while (fin.get(ch))
        {
            cout << ch;
        }
        fin.close();
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
append
Enter guest names (enter a blank line to quit):
Mike Pence
Peter Smith
Hello World

Here are the new contents of the guests.txt file:
Mike Pence
Peter Smith
Hello World
Done.

append
Here are the current contents of the guests.txt file:
Mike Pence
Peter Smith
Hello World
Enter guest names (enter a blank line to quit):
Apple Water
Sun Flower

Here are the new contents of the guests.txt file:
Mike Pence
Peter Smith
Hello World
Apple Water
Sun Flower
Done.

cat guests.txt
Mike Pence
Peter Smith
Hello World
Apple Water
Sun Flower

程序清单17.19 binary.cpp
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdlib>

const char *file = "planets.dat";

inline void eatline()
{
    while (std::cin.get() != '\n') continue;
}

struct planet
{
    char name[20];
    double population;
    double g;
};

int main()
{
    using namespace std;
    planet pl;
    cout << fixed << right;

    ifstream fin;
    fin.open(file, ios_base::in | ios_base::binary);
    if (fin.is_open())
    {
        cout << "Here are the current contents of the "
             << file << " file:\n";
        while (fin.read((char *)&pl, sizeof pl))
        {
            cout << setw(20) << pl.name << ": "
                 << setprecision(0) << setw(12) << pl.population
                 << setprecision(2) << setw(6) << pl.g << endl;
        }
        fin.close();
    }

    ofstream fout(file, ios_base::out | ios_base::app | ios_base::binary);
    if (!fout.is_open())
    {
        cerr << "Can't open " << file << " file for output:\n";
        exit(EXIT_FAILURE);
    }

    cout << "Enter planet name (enter a blank line to quit):\n";
    cin.get(pl.name, 20);
    while (pl.name[0] != '\0')
    {
        eatline();
        cout << "Enter planetary population: ";
        cin >> pl.population;
        cout << "Enter planet's acceleration of gravity: ";
        cin >> pl.g;
        eatline();
        fout.write((char *)&pl, sizeof pl);
        cout << "Enter planet name (enter a blank line to quit):\n";
        cin.get(pl.name, 20);
    }
    fout.close();

    fin.clear();
    fin.open(file, ios_base::in | ios_base::binary);
    if (fin.is_open())
    {
        cout << "Here are the new contents of the "
             << file << " file:\n";
        while (fin.read((char *)&pl, sizeof pl))
        {
            cout << setw(20) << pl.name << ": "
                 << setprecision(0) << setw(12) << pl.population
                 << setprecision(2) << setw(6) << pl.g << endl;
        }
        fin.close();
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Enter planet name (enter a blank line to quit):
Peter Smith
Enter planetary population: 120
Enter planet's acceleration of gravity: 7.15
Enter planet name (enter a blank line to quit):
Mike Pence
Enter planetary population: 221
Enter planet's acceleration of gravity: 8.1
Enter planet name (enter a blank line to quit):
Hello World
Enter planetary population: 188
Enter planet's acceleration of gravity: 7.8
Enter planet name (enter a blank line to quit):

Here are the new contents of the planets.dat file:
         Peter Smith:          120  7.15
          Mike Pence:          221  8.10
         Hello World:          188  7.80
Done.

Here are the current contents of the planets.dat file:
         Peter Smith:          120  7.15
          Mike Pence:          221  8.10
         Hello World:          188  7.80
Enter planet name (enter a blank line to quit):
Apple Water
Enter planetary population: 166
Enter planet's acceleration of gravity: 7.5
Enter planet name (enter a blank line to quit):
Sun Flower
Enter planetary population: 181
Enter planet's acceleration of gravity: 7.9
Enter planet name (enter a blank line to quit):

Here are the new contents of the planets.dat file:
         Peter Smith:          120  7.15
          Mike Pence:          221  8.10
         Hello World:          188  7.80
         Apple Water:          166  7.50
          Sun Flower:          181  7.90
Done.

可以使用tellg和tellp方法来获取当前的位置。这两个方法给你返回当前读取（g代表get） 和写入（p代表put）的位置。
也可以在当前位置的基础上移动来设置你在文件中的位置，使用seekp和seekg。
程序清单17.20 random.cpp
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdlib>

const int LIM = 20;

struct planet
{
    char name[LIM];
    double population;
    double g;
};

const char *file = "planets.dat";

inline void eatline()
{
    while (std::cin.get() != '\n') continue;
}

int main()
{
    using namespace std;
    planet pl;
    cout << fixed;

    fstream finout;
    finout.open(file, ios_base::in | ios_base::out | ios_base::binary);
    int ct = 0;
    if (finout.is_open())
    {
        finout.seekg(0);
        cout << "Here are the current contents of the "
             << file << " file:\n";
        while (finout.read((char *)&pl, sizeof pl))
        {
            cout << ct++ << ": " << setw(LIM) << pl.name << ": "
                 << setprecision(0) << setw(12) << pl.population
                 << setprecision(2) << setw(6) << pl.g << endl;
        }
        if (finout.eof())
        {
            finout.clear();
        }
        else
        {
            cerr << "Error in reading " << file << ".\n";
            exit(EXIT_FAILURE);
        }
    }
    else
    {
        cerr << file << " could not be opened -- bye.\n";
        exit(EXIT_FAILURE);
    }

    cout << "Enter the record number you wish to change: ";
    long rec;
    cin >> rec;
    eatline();
    if (rec < 0 || rec >= ct)
    {
        cerr << "Invalid record number -- bye\n";
        exit(EXIT_FAILURE);
    }
    streampos place = rec * sizeof pl;
    finout.seekg(place);
    if (finout.fail())
    {
        cerr << "Error on attempted seek\n";
        exit(EXIT_FAILURE);
    }

    finout.read((char *)&pl, sizeof pl);
    cout << "Your selection:\n";
    cout << rec << ": " << setw(LIM) << pl.name << ": "
         << setprecision(0) << setw(12) << pl.population
         << setprecision(2) << setw(6) << pl.g << endl;
    if (finout.eof())
    {
        finout.clear();
    }

    cout << "Enter planet name: ";
    cin.get(pl.name, LIM);
    eatline();
    cout << "Enter planetary population: ";
    cin >> pl.population;
    cout << "Enter planet's acceleration of gravity: ";
    cin >> pl.g;
    eatline();
    finout.seekp(place);
    finout.write((char *)&pl, sizeof pl) << flush;
    if (finout.fail())
    {
        cerr << "Error on attempted write\n";
        exit(EXIT_FAILURE);
    }

    ct = 0;
    finout.seekg(0);
    cout << "Here are the new contents of the " << file
         << " file:\n";
    while (finout.read((char *)&pl, sizeof pl))
    {
        cout << ct++ << ": " << setw(LIM) << pl.name << ": "
             << setprecision(0) << setw(12) << pl.population
             << setprecision(2) << setw(6) << pl.g << endl;
    }
    finout.close();
    cout << "Done.\n";

    return 0;
}
显示结果如下
Here are the current contents of the planets.dat file:
0:          Peter Smith:          120  7.15
1:           Mike Pence:          221  8.10
2:          Hello World:          188  7.80
3:          Apple Water:          166  7.50
4:           Sun Flower:          181  7.90
Enter the record number you wish to change: 3
Your selection:
3:          Apple Water:          166  7.50
Enter planet name: Apple Cake
Enter planetary population: 182
Enter planet's acceleration of gravity: 7.68
Here are the new contents of the planets.dat file:
0:          Peter Smith:          120  7.15
1:           Mike Pence:          221  8.10
2:          Hello World:          188  7.80
3:           Apple Cake:          182  7.68
4:           Sun Flower:          181  7.90
Done.

程序清单17.21 strout.cpp
#include <iostream>
#include <sstream>
#include <string>

int main()
{
    using namespace std;
    ostringstream outstr;

    string hdisk;
    cout << "What's the name of your hard disk? ";
    std::getline(cin, hdisk, '\n');
    int cap;
    cout << "What's its capacity in GB? ";
    cin >> cap;
    outstr << "The hard disk " << hdisk << " has a capacity of "
           << cap << " gigabytes.\n";
    string result = outstr.str();
    cout << result;

    return 0;
}
显示结果如下
What's the name of your hard disk? Hello World
What's its capacity in GB? 256
The hard disk Hello World has a capacity of 256 gigabytes.

程序清单17.22 strin.cpp
#include <iostream>
#include <sstream>
#include <string>

int main()
{
    using namespace std;
    string lit = "It was a dark and stormy day, and "
                 " the full moon glowed brilliantly. ";
    istringstream instr(lit);
    string word;
    while (instr >> word)
    {
        cout << word << endl;
    }

    return 0;
}
显示结果如下
It
was
a
dark
and
stormy
day,
and
the
full
moon
glowed
brilliantly.

17.6总结
包含了iostream文件的C++程序将自动打开8个流，并使用8个对象管理它们。
cin对象管理标准输入流，后者默认与标准输入设备（通常为键盘）相连；
cout对象管理标准输出流，后者默认与标准输出设备（通常为显示器）相连；
cerr和clog对象管理与标准错误设备（通常为显示器）相连的未被缓冲的流和被缓冲的流。
这4个对象有都有用于宽字符的副本，它们是wcin，wcout，wcerr和wclog。
istream类定义了多个版本的抽取运算符（>>），用于识别所有的C++基本类型，并将字符输入转换为这些类型。
get方法和getline方法为单字符输入和字符串输入提供了进一步的支持。
同样，ostream类定义了多个版本的插入运算符（<<），用于识别所有的C++基本类型，并将它们转换为相应的字符输出。
put方法对单字符输出提供了进一步的支持。wistream和wostream类对宽字符提供了类似的支持。
使用ios_base类方法以及文件iostream和iomanip中定义的控制符（可与插入运算符拼接的函数），可以控制程序如何格式化输出。
这些方法和控制符使得能够控制计数系统、字段宽度、小数位数、显示浮点变量时采用的计数系统以及其他元素。
fstream文件提供了将iostream方法扩展到文件I/O的类定义。ifstream类是从istream类派生而来的。
通过将ifstream对象与文件关联起来，可以使用所有的istream方法来读取文件。
同样，通过将ofstream对象与文件关联起来，可以使用ostream方法来写文件；
通过将fstream对象与文件关联起来，可以将输入和输出方法用于文件。
要将文件与流关联起来，可以在初始化文件流对象时提供文件名，也可以先创建一个文件流对象，然后用open方法将这个流与文件关联起来。
close方法终止流与文件之间的连接。类构造函数和open方法接受可选的第二个参数，该参数提供文件模式。
文本文件以字符格式存储所有的信息，例如，数字值将被转换为字符表示。
常规的插入和抽取运算符以及get和getline都支持这种模式。
二进制文件使用计算机内部使用的二进制表示来存储信息。
与文本文件相比，二进制文件存储数据（尤其是浮点值）更为精确、简洁，但可移植性较差。
read和write方法都支持二进制输入和输出。
seekg和seekp函数提供对文件的随机存取。这些类方法使得能够将文件指针放置到相对于文件开头、文件尾和当前位置的某个位置。
tellg和tellp方法报告当前的文件位置。
sstream头文件定义了istringstream和ostringstream类，这些类使得能够使用istream和ostream方法来抽取字符串中的信息，
并对要放入到字符串中的信息进行格式化。
17.7 复习题
1.iostream头文件在C++ I/O中扮演何种角色？
iostream头文件定义了用于管理输入和输出的类、常量和操纵符，这些对象管理用于处理I/O的流和缓冲区。
iostream头文件还创建了一些标准对象（cin，cout，cerr和clog以及对应的宽字符对象），用于处理与每个程序相连的标准输入和输出流。

2.为什么键入数字（如121）作为输入要求程序进行转换？
输入121将生成3个字符，每个字符都由一个1字节的二进制码表示。
要将这个值存储为int类型，则必须将这3个字符转换为121值的二进制表示。

3.标准输出与标准错误之间有什么区别？
在默认情况下，标准输出和标准错误都将输出发送给标准输出设备（通常为显示器）。
然而，如果要求操作系统将输出重定向到文件，则标准输出将与文件（而不是显示器）相连，但标准错误仍与显示器相连。

4.为什么在不为每个类型提供明确指示的情况下，cout仍能够显示不同的C++类型？
ostream类为每种C++基本类型定义了一个operator <<()函数的版本。cout会根据要显示的数据类型选择合适的版本。

5.输出方法的定义的哪一特征让您能够拼接输出？
operator <<()函数返回作为输入参数的ostream引用。
这样，通过一个ostream对象调用方法时，将返回该ostream对象的引用。

6.编写一个程序，要求用户输入一个整数，然后以十进制、八进制和十六进制显示该整数。
在宽度为15个字符的字段中显示每种形式，并将它们显示在同一行上，同时显示十进制、八进制、十六进制前缀。
#include <iostream>
#include <iomanip>

int main()
{
    using namespace std;
    cout << "Enter an integer: ";
    int n;
    cin >> n;
    cout << setw(15) << "base ten" << setw(15) << "base sixteen" << setw(15) << "base eight" << endl;
    cout << showbase << setw(15) << n << hex << setw(15) << n << oct << setw(15) << n << endl;

    return 0;
}
显示结果如下
Enter an integer: 129
       base ten   base sixteen     base eight
            129           0x81           0201

7.编写一个程序，请求用户输入下面的信息，并按下面的格式显示它们：
#include <iostream>
#include <iomanip>

int main()
{
    using namespace std;
    char name[20];
    double hourly;
    double hours;

    cout << "Enter your name: ";
    cin.get(name,20).get();
    cout << "Enter your hourly wages: ";
    cin >> hourly;
    cout << "Enter number of hours worked: ";
    cin >> hours;

    cout << showpoint << fixed << right;
    cout << "First format: \n";
    cout << setw(30) << name << ": $" << setprecision(2)
            << setw(10) << hourly << ":" << setprecision(1)
            << setw(5) << hours << "\n";
    cout << "Second format: \n";
    cout << left;
    cout << setw(30) << name << ": $" << setprecision(2)
            << setw(10) << hourly << ":" << setprecision(1)
            << setw(5) << hours << "\n";

    return 0;
}
显示结果如下
Enter your name: Hello World
Enter your hourly wages: 12
Enter number of hours worked: 7.5
First format:
                   Hello World: $     12.00:  7.5
Second format:
Hello World                   : $12.00     :7.5

8.对于下面的程序
#include <iostream>

int main()
{
    using namespace std;
    char ch;
    int ct1 = 0;

    cin >> ch;
    while (ch != 'q')
    {
        ct1++;
        cin >> ch;
    }
    
    int ct2 = 0;
    cin.get(ch);
    while (ch != 'q')
    {
        ct2++;
        cin.get(ch);
    }
    cout << "ct1 = " << ct1 << "; ct2 = " << ct2 << "\n";

    return 0;
}
如果输入如下，该程序将打印什么内容?
I see a q<Enter>
I see a q<Enter>
其中，<Enter>表示按下回车键。
显示结果如下
I see a q
I see a q
ct1 = 5; ct2 = 9

9.下面的两条语句都读取并丢弃行尾之前的所有字符（包括行尾）。这两条语句的行为在哪方面不同？
while (cin.get() != '\n')
{
    continue;
}
cin.ignore(80, '\n');
如果输入行剩余的字符数超过80，while循环仍然能工作，ignore只丢弃前80个字符

17.8编程练习
1・编写一个程序计算输入流中第一个$之前的字符数目，并将$留在输入流中
#include <iostream>

int main()
{
    std::cout << "Please enter string: ";

    char ch;
    std::cin.get(ch);

    int count = 0;
    while (ch != '$')
    {
        count++;
        std::cin.get(ch);
    }
    std::cin.putback(ch);

    std::cout << "count = " << count << std::endl;
    std::cout << "The next character in the input buffer is ";
    std::cout << (char) std::cin.get() << std::endl;

    return 0;
}
显示结果如下
Please enter string: Hello, World$
count = 12
The next character in the input buffer is $

2.编写一个程序，将键盘输入（直到模拟的文件尾）复制到通过命令行指定的文件中。
#include <iostream>
#include <fstream>
#include <cstdlib>

int main(int argc, char *argv[])
{
    if (argc == 1)
    {
        std::cerr << "Error, a filename must be an argument on the command line.";
        std::cerr << std::endl;
        exit(EXIT_FAILURE);
    }

    if (argc > 2)
    {
        std::cout << "Arguments on the command line beyond the first are ignored";
        std::cout << std::endl;
    }

    std::ofstream outfile;
    outfile.open(argv[1]);

    if (!outfile.is_open())
    {
        std::cerr << "Error, could not open file." << std::endl;
        exit(EXIT_FAILURE);
    }

    std::cout << "Enter input (ctrl-D when done): ";

    char ch;
    while (std::cin.get(ch))
    {
        outfile.put(ch);
    }

    if (!std::cin.eof())
    {
        std::cerr << "Warning, input quit due to something other than ";
        std::cerr << "simulated EOF" << std::endl;
    }
    outfile.close();

    return 0;
}
显示结果如下
Enter input (ctrl-D when done): Hello World
Peter Smith
Mike Pence
Apple
Orange
Sun Flower

cat ch17_p02.txt
Hello World
Peter Smith
Mike Pence
Apple
Orange
Sun Flower

3.编写一个程序，将一个文件复制到另一个文件中。让程序通过命令行获取文件名。如果文件无法打开，程序将指出这一点。
#include <iostream>
#include <fstream>
#include <cstdlib>

int main(int argc, char *argv[])
{
    if (argc < 3)
    {
        std::cerr << "Error, two arguments representing filenames are missing";
        std::cerr << std::endl;
        exit(EXIT_FAILURE);
    }
    else  if (argc > 3)
    {
        std::cerr << "More arguments than necessary are detected" << std::endl;
        std::cerr << "Only the first two arguments will be used" << std::endl;
    }

    std::cout << "Warning: this will erase the contents of " << argv[2];
    std::cout << ". Proceed? (y/n) ";

    char ch;
    std::cin >> ch;
    while (std::cin.get() != '\n')
    {
        continue;
    }

    if (ch != 'y' && ch != 'Y')
    {
        return 0;
    }
    else
    {
        std::ifstream infile;
        infile.open(argv[1]);

        if (!infile.is_open())
        {
            std::cerr << "Error, could not open " << argv[1] << std::endl;
            exit(EXIT_FAILURE);
        }

        std::ofstream outfile;
        outfile.open(argv[2]);

        if (!outfile.is_open())
        {
            std::cerr << "Error, could not open " << argv[2] << std::endl;
            exit(EXIT_FAILURE);
        }

        while (infile.get(ch))
        {
            outfile.put(ch);
        }
        infile.close();
        outfile.close();
    }

    return 0;
}
显示结果如下
ch17_p03
Error, two arguments representing filenames are missing

ch17_p03 ch17_p02.txt ch17_p03.txt
Warning: this will erase the contents of ch17_p03.txt. Proceed? (y/n) y

cat ch17_p03.txt
Hello World
Peter Smith
Mike Pence
Apple
Orange
Sun Flower

ls -l ch17_p0?.txt
-rw-r--r-- 1 weiyayun weiyayun 59 Nov  7 11:54 ch17_p02.txt
-rw-r--r-- 1 weiyayun weiyayun 59 Nov  7 12:03 ch17_p03.txt


4・编写一个程序，它打开两个文本文件进行输入，打开一个文本文件进行输出。
该程序将两个输入文件中对应的行并接起来，并用空格分隔，然后将结果写入到输出文件中。
如果一个文件比另一个短，则将较长文件中余下的几行直接复制到输出文件中。
#include <iostream>
#include <fstream>
#include <cstdlib>

int main(int argc, char *argv[])
{
    if (argc < 4)
    {
        std::cerr << "Error, three arguments representing filenames are missing";
        std::cerr << std::endl;
        exit(EXIT_FAILURE);
    }
    else if (argc > 4)
    {
        std::cerr << "More arguments than necessary are detected" << std::endl;
        std::cerr << "Only the first three arguments will be used" << std::endl;
    }

    std::cout << "Warning: this will erase the contents of " << argv[3];
    std::cout << ". Proceed? (y/n) ";

    char ch;
    std::cin >> ch;
    while (std::cin.get() != '\n')
    {
        continue;
    }

    if (ch != 'y' && ch != 'Y')
    {
        return 0;
    }
    else
    {
        std::ifstream infile_first;
        infile_first.open(argv[1]);

        if (!infile_first.is_open())
        {
            std::cerr << "Error, could not open " << argv[1] << std::endl;
            exit(EXIT_FAILURE);
        }

        std::ifstream infile_second;
        infile_second.open(argv[2]);

        if (!infile_second.is_open())
        {
            std::cerr << "Error, could not open " << argv[2] << std::endl;
            exit(EXIT_FAILURE);
        }

        std::ofstream outfile;
        outfile.open(argv[3]);

        if (!outfile.is_open())
        {
            std::cerr << "Error, could not open " << argv[3] << std::endl;
            exit(EXIT_FAILURE);
        }

        infile_first.peek();
        infile_second.peek();
        while (!infile_first.eof() && !infile_second.eof())
        {
            while (infile_first.get(ch) && ch != '\n')
            {
                outfile.put(ch);
            }
            outfile.put(' ');

            while (infile_second.get(ch) && ch != '\n')
            {
                outfile.put(ch);
            }
            outfile.put('\n');

            infile_first.peek();
            infile_second.peek();
        }

        if (infile_first.eof() && !infile_second.eof())
        {
            while (infile_second.get(ch) && ch != '\n')
            {
                outfile.put(ch);
            }
            outfile.put('\n');
        }
        else if (infile_second.eof() && !infile_first.eof())
        {
            while (infile_first.get(ch) && ch != '\n')
            {
                outfile.put(ch);
            }
            outfile.put('\n');
        }
        infile_first.close();
        infile_second.close();
        outfile.close();
    }

    return 0;
}
显示结果如下
ch17_p04
Error, three arguments representing filenames are missing

ch17_p04 ch17_p02.txt ch17_p03.txt ch17_p04.txt
Warning: this will erase the contents of ch17_p04.txt. Proceed? (y/n) y

cat ch17_p04.txt
Hello World Hello World
Peter Smith Peter Smith
Mike Pence Mike Pence
Apple Apple
Orange Orange
Sun Flower Sun Flower

ls -l ch17_p0?.txt
-rw-r--r-- 1 weiyayun weiyayun  59 Nov  7 11:54 ch17_p02.txt
-rw-r--r-- 1 weiyayun weiyayun  59 Nov  7 12:03 ch17_p03.txt
-rw-r--r-- 1 weiyayun weiyayun 118 Nov  7 12:11 ch17_p04.txt

5.Mat和Pat想邀请他们的朋友来参加派对，就像第16章中的编程练习8那样，但现在他们希望程序使用文件。
他们请您编写一个完成下述任务的程序。
从文本文件mat.dat中读取Mat朋友的姓名清单，其中每行为一个朋友。姓名将被存储在容器然后按顺序显示出来
从文本文件pat.dat中读取Pat朋友的姓名清单，其中每行为一个朋友。姓名将被存储在容器中，然后按顺序显示出来。
合并两个清单，删除重复的条目，并将结果保存在文件matnpat.dat中，其中每行为一个朋友。
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <algorithm>
#include <iterator>
#include <cstdlib>
#include <cctype>

void check(std::ifstream &infile, std::string filename);
void check(std::ofstream &infile, std::string filename);
bool stringComp(std::string s1, std::string s2);
bool stringEqual(std::string s1, std::string s2);

int main()
{
    std::ifstream patfile("pat.dat");
    std::ifstream matfile("mat.dat");
    std::ofstream patnmat("matnpat.dat");

    check(patfile, "pat.dat");
    check(matfile, "mat.dat");
    check(patnmat, "matnpat.dat");

    std::string name;
    std::vector<std::string> patlist;
    std::vector<std::string> matlist;

    while (std::getline(patfile, name, '\n') && name != "")
    {
        patlist.push_back(name);
    }

    while (getline(matfile, name) && name != "")
    {
        matlist.push_back(name);
    }

    std::vector<std::string> matnpat_list;
    std::back_insert_iterator<std::vector<std::string>> iiter(matnpat_list);

    copy(patlist.begin(), patlist.end(), iiter);
    copy(matlist.begin(), matlist.end(), iiter);

    sort(matnpat_list.begin(), matnpat_list.end(), stringComp);
    std::vector<std::string>::iterator iv = unique(matnpat_list.begin(), matnpat_list.end(), stringEqual);
    matnpat_list.erase(iv, matnpat_list.end());

    std::ostream_iterator<std::string, char> os_iter(std::cout, "\n");
    std::ostream_iterator<std::string, char> os_iter_file(patnmat, "\n");

    std::cout << "Here is your list of guests: " << std::endl;
    copy(matnpat_list.begin(), matnpat_list.end(), os_iter);

    patnmat << "Here is your list of guests: " << std::endl;
    copy(matnpat_list.begin(), matnpat_list.end(), os_iter_file);

    return 0;
}

void check(std::ifstream &infile, std::string filename)
{
    if (!infile.is_open())
    {
        std::cerr << "Error, cannot open " << filename << std::endl;
        exit(EXIT_FAILURE);
    }
}

void check(std::ofstream &infile, std::string filename)
{
    if (!infile.is_open())
    {
        std::cerr << "Error, cannot open " << filename << std::endl;
        exit(EXIT_FAILURE);
    }
}

bool stringComp(std::string s1, std::string s2)
{
    transform(s1.begin(), s1.end(), s1.begin(), ::tolower);
    transform(s2.begin(), s2.end(), s2.begin(), ::tolower);
    return s1 < s2;
}

bool stringEqual(std::string s1, std::string s2)
{
    transform(s1.begin(), s1.end(), s1.begin(), ::tolower);
    transform(s2.begin(), s2.end(), s2.begin(), ::tolower);
    return s1 == s2;
}
显示结果如下
Here is your list of guests:
a1
a2
a3
a4
a5
a6
b1
b2
b3
b4
b5
b6

cat mat.dat
b1
b2
a3
a5
b3
b4
b5
a6
b6

cat pat.dat
a1
b1
a2
a3
b2
a4
a5
a6

cat matnpat.dat
Here is your list of guests:
a1
a2
a3
a4
a5
a6
b1
b2
b3
b4
b5
b6

6.考虑14章的编程练习5中的类定义。如果还没有完成这个练习，请现在就做，然后完成下面的任务。
编写一个程序，它使用标准C++ I/O、文件I/O以及14章的编程练习5中定义的employee，manager，fink和highfink类型的数据。
该程序应包含程序清单17.17中的代码行，即允许用户将新数据添加到文件中。
该程序首次被运行时，将要求用户输入数据，然后显示所有的数据，并将这些信息保存到一个文件中。
当该程序再次被运行时，将首先读取并显示文件中的数据，然后让用户添加数据，并显示所有的数据。
差别之一是，应通过一个指向employee类型的指针数组来处理数据。这样，指针可以指向employee对象，
也可以指向从employee派生出来的其他三种对象中的任何一种。
使数组较小有助于检查程序，例如，您可能将数组限定为最多包含10个元素。
为通过键盘输入，程序应使用一个菜单，让用户选择要创建的对象类型。
菜单将使用一个switch，以便使用new来创建指定类型的对象，并将它的地址赋给pc数组中的一个指针。
然后该对象可以使用虚函数setall()来提示用户输入相应的数据。
为将数据保存到文件中，应设计一个虚函数writeall()。
注意：对于这个练习，应使用文本I/O，而不是二进制I/O
（遗憾的是，虚对象包含指向虚函数指针表的指针，而write()将把这种信息复制到文件中。
使用read()读取文件的内容，以填充对象时，函数指针值将为乱码，这将扰乱虚函数的行为）。
可使用换行符将字段分隔开，这样在输入时将很容易识别各个字段。
也可以使用二进制I/O，但不能将对象作为一个整体写入，而应该提供分别对每个类成员应用write()和read()的类方法。
这样，程序将只把所需的数据保存到文件中。
比较难处理的部分是使用文件恢复数据。问题在于：
程序如何才能知道接下来要恢复的项目是employee对象、manager对象、fink对象还是highfink对象？
一种方法是，在对象的数据写入文件时，在数据前面加上一个指示对象类型的整数。
这样，在文件输入时，程序便可以读取该整数，并使用switch语句创建一个适当的对象来接收数据。
然后便可以使用指针调用虚函数getall()来读取信息。
emp2.h
#ifndef EMP2_H_
#define EMP2_H_
#include <iostream>
#include <string>
#include <fstream>

class abstr_emp
{
private:
    std::string fname;
    std::string lname;
    std::string job;
public:
    enum classkind { Employee, Manager, Fink, Highfink };
    abstr_emp();
    abstr_emp(const std::string &fn, const std::string   &ln, const std::string   &j);
    virtual void ShowAll() const;
    virtual void SetAll();
    friend std::ostream &operator <<(std::ostream &os, const abstr_emp &e);
    virtual ~abstr_emp() = 0;
    virtual void writeall(std::ofstream &ofs) const;
    virtual void getall(std::ifstream &ofs);
};

class employee : public abstr_emp
{
public:
    employee();
    employee(const std::string &fn, const std::string &ln, const std::string &j);
    virtual void ShowAll() const;
    virtual void SetAll();
    virtual void writeall(std::ofstream &ofs) const;
    virtual void getall(std::ifstream &ofs);
};

class manager : virtual public abstr_emp
{
private:
    int inchargeof;
protected:
    int InChargeOf() const
    {
        return inchargeof;
    }
    int &InChargeOf()
    {
        return inchargeof;
    }
public:
    manager();
    manager(const std::string &fn, const std::string &ln, const std::string &j, int ico = 0);
    manager(const abstr_emp &e, int ico);
    manager(const manager &m);
    virtual void ShowAll() const;
    virtual void SetAll();
    virtual void writeall(std::ofstream &ofs) const;
    virtual void getall(std::ifstream &ofs);
};

class fink : virtual public abstr_emp
{
private:
    std::string reportsto;
protected:
    const std::string &ReportsTo() const
    {
        return reportsto;
    }
    std::string &ReportsTo()
    {
        return reportsto;
    }
public:
    fink();
    fink(const std::string &fn, const std::string &ln, const std::string &j, const std::string &rpo);
    fink(const abstr_emp &e, const std::string &rpo);
    fink(const fink &e);
    virtual void ShowAll() const;
    virtual void SetAll();
    virtual void writeall(std::ofstream &ofs) const;
    virtual void getall(std::ifstream &ofs);
};

class highfink : public manager, public fink
{
public:
    highfink();
    highfink(const std::string &fn, const std::string &ln, const std::string &j, const std::string &rpo, int ico);
    highfink(const abstr_emp &e, const std::string &rpo, int ico);
    highfink(const fink &f, int ico);
    highfink(const manager &m, const std::string &rpo);
    highfink(const highfink &h);
    virtual void ShowAll() const;
    virtual void SetAll();
    virtual void writeall(std::ofstream &ofs) const;
    virtual void getall(std::ifstream &ofs);
};

#endif

emp2.cpp
#include "emp2.h"

abstr_emp::abstr_emp()
{
    fname = "";
    lname = "";
    job = "";
}

abstr_emp::abstr_emp(const std::string &fn, const std::string   &ln, const std::string   &j) : fname(fn), lname(ln), job(j)
{

}

void abstr_emp::ShowAll() const
{
    std::cout << "First name: " << fname << std::endl;
    std::cout << "Last name: " << lname << std::endl;
    std::cout << "Job: " << job << std::endl;
}

void abstr_emp::SetAll()
{
    std::cout << "Enter first name: ";
    std::cin >> fname;

    while (std::cin.get() != '\n')
    {
        continue;
    }

    std::cout << "Enter last name: ";
    std::cin >> lname;

    while (std::cin.get() != '\n')
    {
        continue;
    }

    std::cout << "Enter the job: ";
    std::getline(std::cin, job, '\n');
}

std::ostream &operator<<(std::ostream &os, const abstr_emp &e)
{
    os << e.lname << ", " << e.fname << " : " << e.job;
    return os;
}

abstr_emp::~abstr_emp()
{

}

void abstr_emp::writeall(std::ofstream &ofs) const
{
    ofs << "First name: " << fname << std::endl;
    ofs << "Last name: " << lname << std::endl;
    ofs << "Job: " << job << std::endl;
}
void abstr_emp::getall(std::ifstream &ifs)
{
    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    std::getline(ifs, fname, '\n');
    std::cout << "First name is " << fname << std::endl;

    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    std::getline(ifs, lname, '\n');
    std::cout << "Last name is " << lname << std::endl;

    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    std::getline(ifs, job, '\n');
    std::cout << "Job is " << job << std::endl;
}

employee::employee() : abstr_emp()
{

}

employee::employee(const std::string &fn, const std::string   &ln, const std::string   &j) : abstr_emp(fn, ln, j)
{

}

void employee::ShowAll() const
{
    std::cout << "Status: Employee" << std::endl;
    abstr_emp::ShowAll();
}

void employee::SetAll()
{
    abstr_emp::SetAll();
}

void employee::writeall(std::ofstream &ofs) const
{
    ofs << abstr_emp::Employee << std::endl;
    abstr_emp::writeall(ofs);
}

void employee::getall(std::ifstream &ifs)
{
    abstr_emp::getall(ifs);
}

manager::manager() : abstr_emp()
{
    inchargeof = 0;
}

manager::manager(const std::string &fn, const std::string &ln,
                 const std::string &j, int ico) : abstr_emp(fn, ln, j)
{
    inchargeof = ico;

    if (inchargeof < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        inchargeof = 0;
    }
}

manager::manager(const abstr_emp &e, int ico) : abstr_emp(e)
{
    inchargeof = ico;

    if (inchargeof < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        inchargeof = 0;
    }
}

manager::manager(const manager &m) : abstr_emp(m)
{
    inchargeof = m.inchargeof;
}

void manager::ShowAll() const
{
    std::cout << "Status: Manager" << std::endl;
    abstr_emp::ShowAll();
    std::cout << "In charge of " << inchargeof << " people" << std::endl;
}

void manager::SetAll()
{
    abstr_emp::SetAll();
    std::cout << "Enter the number of people the manager is in charge of: ";
    std::cin >> inchargeof;
    while (std::cin.get() != '\n')
    {
        continue;
    }
    if (inchargeof < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        inchargeof = 0;
    }
}

void manager::writeall(std::ofstream &ofs) const
{
    ofs << abstr_emp::Manager << std::endl;
    abstr_emp::writeall(ofs);
    ofs << "Number of people managed: " << inchargeof << std::endl;
}

void manager::getall(std::ifstream &ifs)
{
    abstr_emp::getall(ifs);
    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    ifs >> inchargeof;
    ifs.get();
}

fink::fink() : abstr_emp(), reportsto("")
{

}

fink::fink(const std::string &fn, const std::string &ln,
           const std::string &j, const std::string &rpo) : abstr_emp(fn, ln, j), reportsto(rpo)
{

}

fink::fink(const abstr_emp &e, const std::string &rpo) : abstr_emp(e), reportsto(rpo)
{

}

fink::fink(const fink &e) : abstr_emp(e)
{
    reportsto = e.reportsto;
}

void fink::ShowAll() const
{
    std::cout << "Status: fink" << std::endl;
    abstr_emp::ShowAll();
    std::cout << "Reports to " << reportsto << std::endl;
}

void fink::SetAll()
{
    abstr_emp::SetAll();
    std::cout << "Enter whomever is reported to: ";
    std::getline(std::cin, reportsto, '\n');
}

void fink::writeall(std::ofstream &ofs) const
{
    ofs << abstr_emp::Fink << std::endl;
    abstr_emp::writeall(ofs);
    ofs << "Reports to: " << reportsto << std::endl;
}

void fink::getall(std::ifstream &ifs)
{
    abstr_emp::getall(ifs);
    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    std::getline(ifs, reportsto, '\n');
}
highfink::highfink() : abstr_emp(), manager(), fink()
{

}
highfink::highfink(const std::string &fn, const std::string &ln,
                   const std::string &j, const std::string &rpo, int ico) : abstr_emp(fn, ln, j), manager(fn, ln, j, ico), fink(fn, ln, j, rpo)
{

}
highfink::highfink(const abstr_emp &e, const std::string &rpo, int ico) : abstr_emp(e), manager(e, ico), fink(e, rpo)
{

}

highfink::highfink(const fink &f, int ico) : abstr_emp(f), manager(f, ico), fink(f)
{

}

highfink::highfink(const manager &m, const std::string &rpo) : abstr_emp(m), manager(m), fink(m, rpo)
{

}

highfink::highfink(const highfink &h) : abstr_emp(h), manager(h), fink(h)
{

}

void highfink::ShowAll() const
{
    std::cout << "Status: Highfink" << std::endl;
    abstr_emp::ShowAll();
    std::cout << "In charge of " << InChargeOf() << " people" << std::endl;
    std::cout << "Reports to " << ReportsTo() << std::endl;
}

void highfink::SetAll()
{
    abstr_emp::SetAll();
    std::cout << "Enter the number of people managed: ";
    std::cin >> InChargeOf();
    while (std::cin.get() != '\n')
    {
        continue;
    }
    if (InChargeOf() < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        InChargeOf() = 0;
    }

    std::cout << "Enter whomever is reported to: ";
    std::getline(std::cin, ReportsTo(), '\n');
}

void highfink::writeall(std::ofstream &ofs) const
{
    ofs << abstr_emp::Highfink << std::endl;
    abstr_emp::writeall(ofs);
    ofs << "Number of people managed: " << InChargeOf() << std::endl;
    ofs << "Reports to: " << ReportsTo() << std::endl;
}

void highfink::getall(std::ifstream &ifs)
{
    abstr_emp::getall(ifs);
    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    ifs >> InChargeOf();
    ifs.get();
    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    std::getline(ifs, ReportsTo(), '\n');
}

ch17_p06.cpp
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdlib>
#include "emp2.h"

const int MAX = 10;

void displayMenu(void);
void eatline(void);

int main()
{
    abstr_emp *pc[MAX];
    std::cout << "You may enter of to " << MAX << " employees" << std::endl;

    int count = 0;
    char ch;
    std::ifstream fin;
    fin.open("employeeList.dat");

    if (fin.is_open())
    {
        int classtype = 0;
        while ( fin >> classtype && fin.get(ch) )
        {
            switch (classtype)
            {
            case abstr_emp::Employee:
                std::cout << "Creating an employee object" << std::endl;
                pc[count] = new employee;
                pc[count++]->getall(fin);
                break;
            case abstr_emp::Manager:
                std::cout << "Creating an manager object" << std::endl;
                pc[count] = new manager;
                pc[count++]->getall(fin);
                break;
            case abstr_emp::Fink:
                std::cout << "Creating an fink object" << std::endl;
                pc[count] = new fink;
                pc[count++]->getall(fin);
                break;
            case abstr_emp::Highfink:
                std::cout << "Creating an highfink object" << std::endl;
                pc[count] = new highfink;
                pc[count++]->getall(fin);
                break;
            default:
                std::cerr << "It looks like an error has occurred" << std::endl;
                break;
            }
        }
        std::cout << "Here is your current employee list: " << std::endl;
        for (int i = 0; i < count; i++)
        {
            pc[i]->ShowAll();
            std::cout << std::endl;
        }
        fin.close();
    }

    while (count < MAX)
    {
        displayMenu();
        std::cin >> ch;
        eatline();

        switch (ch)
        {
        case 'a':
            pc[count] = new employee;
            pc[count]->SetAll();
            count++;
            break;
        case 'b':
            pc[count] = new manager;
            pc[count]->SetAll();
            count++;
            break;
        case 'c':
            pc[count] = new fink;
            pc[count]->SetAll();
            count++;
            break;
        case 'd':
            pc[count] = new highfink;
            pc[count]->SetAll();
            count++;
            break;
        case 'q':
            break;
        default:
            std::cout << "Error input not recognized" << std::endl;
            continue;
            break;
        }
        if (ch == 'q')
        {
            break;
        }
    }

    std::ofstream fout;
    fout.open("employeeList.dat");

    if (!fout.is_open())
    {
        std::cerr << "Error, cannot open employeeList.dat" << std::endl;
        exit(EXIT_FAILURE);
    }

    std::cout << "Here's our updated list: " << std::endl;

    for (int i = 0; i < count; i++)
    {
        pc[i]->ShowAll();
        std::cout << std::endl;
        pc[i]->writeall(fout);
    }
    fout.close();
    for (int i = 0; i < count; i++)
    {
        delete pc[i];
    }

    return 0;
}

void displayMenu(void)
{
    std::cout << "Select one of the following:" << std::endl;
    std::cout << std::left;
    std::cout << std::setw(20) << "a. Employee";
    std::cout << std::setw(20) << "b. Manager";
    std::cout << std::endl;
    std::cout << std::setw(20) << "c. Fink";
    std::cout << std::setw(20) << "d. Highfink";
    std::cout << std::endl;
    std::cout << "(q to quit)" << std::endl;
}

void eatline(void)
{
    while (std::cin.get() != '\n')
    {
        continue;
    }
}
显示结果如下
You may enter of to 10 employees
Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
a
Enter first name: Hello
Enter last name: World
Enter the job: aaabbb
Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
b
Enter first name: Mike
Enter last name: Pence
Enter the job: cccddd
Enter the number of people the manager is in charge of: 5
Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
c
Enter first name: Peter
Enter last name: Smith
Enter the job: eeefff
Enter whomever is reported to: Peter
Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
d
Enter first name: Apple
Enter last name: Water
Enter the job: hhhiii
Enter the number of people managed: 8
Enter whomever is reported to: Mike
Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
q
Here's our updated list:
Status: Employee
First name: Hello
Last name: World
Job: aaabbb

Status: Manager
First name: Mike
Last name: Pence
Job: cccddd
In charge of 5 people

Status: fink
First name: Peter
Last name: Smith
Job: eeefff
Reports to Peter

Status: Highfink
First name: Apple
Last name: Water
Job: hhhiii
In charge of 8 people
Reports to Mike

ch17_p06
You may enter of to 10 employees
Creating an employee object
First name is Hello
Last name is World
Job is aaabbb
Creating an manager object
First name is Mike
Last name is Pence
Job is cccddd
Creating an fink object
First name is Peter
Last name is Smith
Job is eeefff
Creating an highfink object
First name is Apple
Last name is Water
Job is hhhiii
Here is your current employee list:
Status: Employee
First name: Hello
Last name: World
Job: aaabbb

Status: Manager
First name: Mike
Last name: Pence
Job: cccddd
In charge of 5 people

Status: fink
First name: Peter
Last name: Smith
Job: eeefff
Reports to Peter

Status: Highfink
First name: Apple
Last name: Water
Job: hhhiii
In charge of 8 people
Reports to Mike

Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
b
Enter first name: Sun
Enter last name: Flower
Enter the job: jjjkkk
Enter the number of people the manager is in charge of: 9
Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
q
Here's our updated list:
Status: Employee
First name: Hello
Last name: World
Job: aaabbb

Status: Manager
First name: Mike
Last name: Pence
Job: cccddd
In charge of 5 people

Status: fink
First name: Peter
Last name: Smith
Job: eeefff
Reports to Peter

Status: Highfink
First name: Apple
Last name: Water
Job: hhhiii
In charge of 8 people
Reports to Mike

Status: Manager
First name: Sun
Last name: Flower
Job: jjjkkk
In charge of 9 people

7.下面是某个程序的部分代码。该程序将键盘输入读取到一个由string对象组成的vector中，
将字符串内容（而不是string对象）存储到一个文件中，然后该文件的内容复制到另一个由string对象组成的vector中。
该程序以二进制格式打开文件，并想使用read()和write()来完成I/O。余下的工作如下所述。
编写函数void ShowStr (const string &)，它显示一个string对象，并在显示完后换行。
编写函数符Store，它将字符串信息写入到文件中。Store的构造函数应接受一个指定ifstream对象的参数，
而重载的operator() (const string &)应指出要写入到文件中的字符串。
一种可行的计划是，首先将字符串的长度写入到文件中，然后将字符串的内容写入到文件中。
成员函数data()返回一个指针，该指针指向一个其中存储了字符串中字符的数组。
它类似于成员函数c_str()，只是后者在数组末尾加上了一个空字符。
编写函数GetStrs()，它根据文件恢复信息。该函数可以使用read()来获得字符串的长度，然后使用一个循环从文件中读取相应数量的字符，
并将它们附加到一个原来为空的临时string末尾。由于string的数据是私有的，因此必须使用string类的方法来将数据存储到string对象中，
而不能直接存储。
ch17_p07.cpp
#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <algorithm>
#include <cstdlib>

class Store
{
private:
    std::ofstream *pfout;
public:
    Store(std::ofstream &fout)
    {
        pfout = &fout;
    }
    ~Store() {}
    Store &operator()(const std::string &str)
    {
        size_t len = str.length();
        pfout->write((char *)&len, sizeof(size_t));
        pfout->write(str.data(), len);
        return *this;
    }
};

void ShowStr(const std::string &str);
void GetStrs(std::ifstream &fin, std::vector<std::string> &vistr);

int main()
{
    std::vector<std::string> vostr;
    std::string temp;

    std::cout << "Enter strings (empty line to quit) :\n";
    while (std::getline(std::cin, temp, '\n') && temp[0] != '\0')
    {
        vostr.push_back(temp);
    }

    std::cout << "Here is your input. \n";
    for_each(vostr.begin(), vostr.end(), ShowStr);

    std::ofstream fout("strings.dat", std::ios_base::out | std::ios_base::binary);
    for_each(vostr.begin(), vostr.end(), Store(fout));
    fout.close();

    std::vector<std::string> vistr;
    std::ifstream fin("strings.dat", std::ios_base::in | std::ios_base::binary);
    if (!fin.is_open())
    {
        std::cerr << "Could not open file for input. \n";
        exit(EXIT_FAILURE);
    }
    GetStrs(fin, vistr);
    std::cout << "\nHere are the strings read from the file:\n";

    for_each(vistr.begin(), vistr.end(), ShowStr);

    return 0;
}

void ShowStr(const std::string &str)
{
    std::cout << str << std::endl;
}

void GetStrs(std::ifstream &fin, std::vector<std::string> &vistr)
{
    size_t len = 0;
    std::string str;
    char ch;
    fin.peek();
    while (!fin.eof())
    {
        fin.read((char *)&len, sizeof(size_t));
        for (size_t i = 0; i < len; i++)
        {
            fin.read(&ch, sizeof(char));
            str.push_back(ch);
        }
        vistr.push_back(str);
        str.clear();
        fin.peek();
    }
}
显示结果如下
Enter strings (empty line to quit) :
Hello World
Peter Smith
Mike Pence
Apple Water
Sun Flower

Here is your input.
Hello World
Peter Smith
Mike Pence
Apple Water
Sun Flower

Here are the strings read from the file:
Hello World
Peter Smith
Mike Pence
Apple Water
Sun Flower

第18章 探讨C++新标准
18.1 复习前面介绍过的C++11功能
18.1.1 新类型
18.1.2 统一的初始化
18.1.3 声明
18.1.4 智能指针
18.1.5 异常规范方面的修改
18.1.6 作用域内枚举
18.1.7 对类的修改
18.1.8 模板和STL方面的修改
18.1.9 右值引用
18.2 移动语义和右值引用
18.2.1 为何需要移动语义
18.2.2 一个移动示例
18.2.3 移动构造函数解析
18.2.4 赋值
18.2.5 强制移动
18.3 新的类功能
18.3.1 特殊的成员函数
18.3.2 默认的方 法和禁用的方法.
18.3.3 委托构造函数
18.3.4 继承构造函 数
18.3.5 管理方法：override 和final
18.4 Lambda函数
18.4.1 比较函数指针、函数符和Lambda函数
18.4.2 为何使用lambda
18.5 包装器
18.5.1 包装器function及模板的低效性
18.5.2 修复问题
18.5.3 其他方式
18.6 可变参数模板
18.6.1 模板和函数参数包
18.6.2 展开参数包
18.6.3 在可变参数模板函数中使用递归
18.7 C++11新增的其他功能.
18.7.1 并行编程
18.7.2 新增的库
18.7.3 低级编程
18.7.4 杂项
18.8 语言变化
18.8.1 Boost项目
18.8.2 TR1
18.8.3 使用Boost
18.9 接下来的任务
18.10 总结
18.11 复习题
18.12 编程练习
本章首先复习前面介绍过的C++11功能，然后介绍如下主题：
移动语义和右值引用。
Lambda表达式。
包装器模板function
可变参数模板。
C++11新增了类型long long和unsigned long long；新增了类型char16_t和char32_t。
C++11扩大了用大括号括起的列表（初始化列表）的适用范围，使其可用于所有内置类型和用户定义的类型（即类对象），
使用初始化列表时，可添加等号（=），也可不添加。另外，列表初始化语法也可用于new表达式中。
创建对象时，也可使用大括号（而不是圆括号）括起的列表来调用构造函数。
然而，如果类有将模板std:initializerlist作为参数的构造函数，则只有该构造函数可以使用列表初始化形式。
初始化列表语法可防止缩窄，即禁止将数值赋给无法存储它的数值变量。常规初始化允许程序员执行这样的操作。
初始化列表语法允许转换为更宽的类型。另外，只要值在较窄类型的取值范围内，将其转换为较窄的类型也是允许的。
C++11提供了模板类initializer_list，可将其用作构造函数的参数。
如果类有接受initializer_list作为参数的构造函数，则初始化列表语法就只能用于该构造函数。
列表中的元素必须是同种类型或可转换为同一种类型。STL容器提供了将initializer_list作为参数的构造函数。
头文件initializer_list提供了对模板类initializer_list的支持。这个类包含成员函数begin()和end()，可用于获悉列表的范围。
除用于构造函数外，还可将initializer_list用作常规函数的参数。
C++11提供了多种简化声明的功能，尤其在使用模板时。
以前，关键字auto是一个存储类型说明符（见第9章），C++11将其用于实现自动类型推断（见第3章）。
这要求进行显式初始化，让编译器能够将变量的类型设置为初始值的类型。关键字auto还可简化模板声明。
关键字decltype将变量的类型声明为表达式指定的类型。
C++11新增了一种函数声明语法：在函数名和参数列表后面（而不是前面）指定返回类型。
对于冗长或复杂的标识符，如果能够创建其别名将很方便。以前，C++使用typedef来创建别名。
C++11提供了另一种创建别名的语法，使用using =来创建别名。
差别在于，新语法也可用于模板部分具体化，但typedef不能。
C++11新增了关键字nullptr，用于表示空指针；它是指针类型，不能转换为整型类型。
如果在程序中使用new从堆（自由存储区）分配内存，等到不再需要时，应使用delete将其释放。
C++11摒弃了auto_ptr，并新增了三种智能指针：unique_ptr，shared_ptr和weak_ptr。
所有新增的智能指针都能与STL容器和移动语义协同工作。
C++11摒弃了用于指出函数可能引发哪些异常的异常规范。然而，标准委员会认为，指出函数不会引发异常有一定的价值，
他们为此添加了关键字noexcept。
传统的C++枚举提供了一种创建名称常量的方式，枚举名的作用域为枚举定义所属的作用域，
这意味着如果在同一个作用域内定义两个枚举，它们的枚举成员不能同名。
最后枚举可能不是可完全移植的，因为不同的实现可能选择不同的底层类型。
为解决这些问题，C++11新增了一种使用class或struct定义的枚举。
新枚举要求进行显式限定，以免发生名称冲突。因此，引用特定枚举时，需要使用枚举名::常量名。
C++引入了关键字explicit，以禁止单参数构造函数导致的自动转换。
C++11拓展了explicit的这种用法，使得可对转换函数做类似的处理。
C++11可在类定义中初始化成员，可使用等号或大括号版本的初始化，但不能使用圆括号版本的初始化。
其结果与给构造函数提供成员初始化列表相同。
如果构造函数在成员初始化列表中提供了相应的值，这些默认值将被覆盖。
对于内置数组以及包含方法begin()和end()的类（如std:string）和STL容器，
基于范围的for循环对数组或容器中的每个元素执行指定的操作。
如果要在循环中修改数组或容器的每个元素，可使用引用类型。
C++11新增了STL容器forward_list，unordered_map，unordered_multimap，unordered set和unordered_multiset。
容器forward_list是一种单向链表，只能沿一个方向遍历。其他四种容器都是使用哈希表实现的。
C++11还新增了模板array，要实例化这种模板，可指定元素类型和固定的元素数。
由于长度固定，您不能使用任何修改容器大小的方法，如put_back()。但array有begin()和end()方法，
这让您能够对array对象使用众多基于范围的STL算法。
C++11新增了STL方法cbegin()和cend()。与begin()和end()一样，这些新方法也返回一个选代器，
指向容器的第一个元素和最后一个元素的后面，因此可用于指定包含全部元素的区间。
另外，这些新方法将元素视为const。与此类似，crbegin()和crend()是rbegin()和rend()的const版本。
更重要的是，除传统的复制构造函数和常规赋值运算符外，STL容器现在还有移动构造函数和移动赋值运算符。
C++11 添加了两个函数begin()和end()，它们都接受valarray作为参数，并返回迭代器，
这些选代器分别指向valarray对象的第一个元素和最后一个元素后面。这让您能够将基于范围的STL算法用于valarray。
C++11终止了C++98新增的关键字export用法，但仍保留了关键字export，供以后使用。
为避免与运算符>>混淆，C++要求在声明嵌套模板时使用空格将尖括号分开。C++11不再这样要求。
传统的C++引用（现在称为左值引用）使得标识符关联到左值。
左值是一个表示数据的表达式（如变量名或解除引用的指针），程序可获取其地址。
最初，左值可出现在赋值语句的左边，但修饰符const的出现使得可以声明这样的标识符，即不能给它赋值，但可获取其地址。
C++11新增了右值引用，使用&&表示。右值引用可关联到右值，即可出现在赋值表达式右边，但不能对其应用地址运算符。
右值包括字面常量（C风格字符串除外，它表示地址）、诸如x+y等表达式以及返回值的函数（条件是该函数返回的不是引用）。
int x = 10;
int y = 23;
int && r1 = 13;
int && r2 = x + y;
double && r3 = std::sqrt(2.0);
有趣的是，将右值关联到右值引用导致该右值被存储到特定的位置，且可以获取该位置的地址。
也就是说，虽然不能将运算符&用于13，但可将其用于r1。通过将数据与特定的地址关联，使得可以通过右值引用来访问该数据。
程序清单18.1 rvref.cpp
#include <iostream>

inline double f(double tf)
{
    return 5.0 * (tf - 32.0) / 9.0;
};

int main()
{
    double tc = 21.5;
    double &&rd1 = 7.07;
    double &&rd2 = 1.8 * tc + 32.0;
    double &&rd3 = f(rd2);

    std::cout << " tc value and address: " << tc << ", " << &tc << std::endl;
    std::cout << "rd1 value and address: " << rd1 << ", " << &rd1 << std::endl;
    std::cout << "rd2 value and address: " << rd2 << ", " << &rd2 << std::endl;
    std::cout << "rd3 value and address: " << rd3 << ", " << &rd3 << std::endl;

    return 0;
}
显示结果如下
 tc value and address: 21.5, 0x7ffc7f1e7210
rd1 value and address: 7.07, 0x7ffc7f1e7218
rd2 value and address: 70.7, 0x7ffc7f1e7220
rd3 value and address: 21.5, 0x7ffc7f1e7228

引入右值引用的主要目的之一是实现移动语义，C++11支持移动语义。移动语义避免了移动原始数据，而只是修改了记录。
要实现移动语义，需要采取某种方式，让编译器知道什么时候需要复制，什么时候不需要。这就是右值引用发挥作用的地方。
可定义两个构造函数。其中一个是常规复制构造函数，它使用const左值引用作为参数，这个引用关联到左值实参。
另一个是移动构造函数，它使用右值引用作为参数，该引用关联到右值实参。
复制构造函数可执行深复制，而移动构造函数只调整记录。
在将所有权转移给新对象的过程中，移动构造函数可能修改其实参，这意味着右值引用参数不应是const。
程序清单18.2 useless.cpp
#include <iostream>

using namespace std;

class Useless
{
private:
    int n;
    char *pc;
    static int ct;
    void ShowObject() const;
public:
    Useless();
    explicit Useless(int k);
    Useless(int k, char ch);
    Useless(const Useless &f);
    Useless(Useless &&f);
    ~Useless();
    Useless operator+(const Useless &f) const;

    void ShowData() const;
};

int Useless::ct = 0;

Useless::Useless()
{
    ++ct;
    n = 0;
    pc = nullptr;
    cout << "default constructor called; number of objects: " << ct << endl;
    ShowObject();
}
Useless::Useless(int k) : n(k)
{
    ++ct;
    cout << "int constructor called; number of objects: " << ct << endl;
    pc = new char[n];
    ShowObject();
}

Useless::Useless(int k, char ch) : n(k)
{
    ++ct;
    cout << "int, char constructor called; number of objects: " << ct << endl;
    pc = new char[n];
    for (int i = 0; i < n; i++)
    {
        pc[i] = ch;
    }
    ShowObject();
}

Useless::Useless(const Useless &f) : n(f.n)
{
    ++ct;
    cout << "copy const called; number of objects: " << ct << endl;
    pc = new char[n];
    for (int i = 0; i < n; i++)
    {
        pc[i] = f.pc[i];
    }
    ShowObject();
}

Useless::Useless(Useless &&f) : n(f.n)
{
    ++ct;
    cout << "move constructor called; number of objects: " << ct << endl;
    pc = f.pc;
    f.pc = nullptr;
    f.n = 0;
    ShowObject();

}

Useless::~Useless()
{
    cout << "destructor called; objects left: " << --ct << endl;
    cout << "deleted object:\n";
    ShowObject();
    delete[] pc;
}

Useless Useless::operator+(const Useless &f)const
{
    cout << "Entering operator+()\n";
    Useless temp = Useless(n + f.n);
    for (int i = 0; i < n; i++)
    {
        temp.pc[i] = pc[i];
    }
    for (int i = n; i < temp.n; i++)
    {
        temp.pc[i] = f.pc[i - n];
    }
    cout << "temp object:\n";
    cout << "Leaving operator+()\n";
    return temp;
}

void Useless::ShowObject() const
{
    cout << "Number of elements: " << n;
    cout << " Data address: " << (void *)pc << endl;
}

void Useless::ShowData() const
{
    if (n == 0)
    {
        cout << "(object empty)";
    }
    else
    {
        for (int i = 0; i < n; i++)
        {
            cout << pc[i];
        }
    }
    cout << endl;
}

int main()
{
    {
        Useless one(10, 'x');
        Useless two = one;
        Useless three(20, 'o');
        Useless four(one + three);
        cout << "object one: ";
        one.ShowData();
        cout << "object two: ";
        two.ShowData();
        cout << "object three: ";
        three.ShowData();
        cout << "object four: ";
        four.ShowData();
    }

    return 0;
}
显示结果如下
int, char constructor called; number of objects: 1
Number of elements: 10 Data address: 0x5631323e82c0
copy const called; number of objects: 2
Number of elements: 10 Data address: 0x5631323e82e0
int, char constructor called; number of objects: 3
Number of elements: 20 Data address: 0x5631323e8300
Entering operator+()
int constructor called; number of objects: 4
Number of elements: 30 Data address: 0x5631323e8320
temp object:
Leaving operator+()
object one: xxxxxxxxxx
object two: xxxxxxxxxx
object three: oooooooooooooooooooo
object four: xxxxxxxxxxoooooooooooooooooooo
destructor called; objects left: 3
deleted object:
Number of elements: 30 Data address: 0x5631323e8320
destructor called; objects left: 2
deleted object:
Number of elements: 20 Data address: 0x5631323e8300
destructor called; objects left: 1
deleted object:
Number of elements: 10 Data address: 0x5631323e82e0
destructor called; objects left: 0
deleted object:
Number of elements: 10 Data address: 0x5631323e82c0

通过提供一个使用左值引用的构造函数和一个使用右值引用的构造函数，将初始化分成了两组。
使用左值对象初始化对象时，将使用复制构造函数，而使用右值对象初始化对象时，将使用移动构造函数。
程序员可根据需要赋予这些构造函数不同的行为。适用于构造函数的移动语义考虑也适用于赋值运算符。
与移动构造函数一样，移动赋值运算符的参数也不能是const引用。
移动构造函数和移动赋值运算符使用右值。如果要让它们使用左值，可以使用头文件utility中声明的函数std::move()。
程序清单18.3 stdmove.cpp
#include <iostream>
#include <utility>

class Useless
{
private:
    int n;
    char *pc;
    static int ct;
    void ShowObject() const;
public:
    Useless();
    explicit Useless(int k);
    Useless(int k, char ch);
    Useless(const Useless &f);
    Useless(Useless &&f);
    ~Useless();
    Useless operator+(const Useless &f) const;
    Useless &operator=(const Useless &f);
    Useless &operator=(Useless &&f);
    void ShowData() const;
};

int Useless::ct = 0;

Useless::Useless()
{
    ++ct;
    n = 0;
    pc = nullptr;
}

Useless::Useless(int k) : n(k)
{
    ++ct;
    pc = new char[n];
}

Useless::Useless(int k, char ch) : n(k)
{
    ++ct;
    pc = new char[n];
    for (int i = 0; i < n; i++)
    {
        pc[i] = ch;
    }
}

Useless::Useless(const Useless &f) : n(f.n)
{
    ++ct;
    pc = new char[n];
    for (int i = 0; i < n; i++)
    {
        pc[i] = f.pc[i];
    }
}

Useless::Useless(Useless &&f) : n(f.n)
{
    ++ct;
    pc = f.pc;
    f.pc = nullptr;
    f.n = 0;
}

Useless::~Useless()
{
    delete[] pc;
}

Useless &Useless::operator=(const Useless &f)
{
    std::cout << "copy assignment operator called:\n";
    if (this == &f)
    {
        return *this;
    }
    delete[] pc;
    n = f.n;
    pc = new char[n];
    for (int i = 0; i < n; i++)
    {
        pc[i] = f.pc[i];
    }
    return *this;
}

Useless &Useless::operator=(Useless &&f)
{
    std::cout << "move assignment operator called:\n";
    if (this == &f)
    {
        return *this;
    }
    delete[] pc;
    n = f.n;
    pc = f.pc;
    f.n = 0;
    f.pc = nullptr;
    return *this;
}

Useless Useless::operator+(const Useless &f) const
{
    Useless temp = Useless(n + f.n);
    for (int i = 0; i < n; i++)
    {
        temp.pc[i] = pc[i];
    }
    for (int i = n; i < temp.n; i++)
    {
        temp.pc[i] = f.pc[i - n];
    }
    return temp;
}
void Useless::ShowObject() const
{
    std::cout << "Number of elements: " << n;
    std::cout << " Data address: " << (void *) pc << std::endl;
}

void Useless::ShowData() const
{
    if (n == 0)
    {
        std::cout << " (object empty)";
    }
    else
    {
        for (int i = 0; i < n; i++)
        {
            std::cout << pc[i];
        }
    }
    std::cout << std::endl;
}

int main()
{
    using std::cout;
    {
        Useless one(10, 'x');
        Useless two = one + one;
        cout << "object one: ";
        one.ShowData();
        cout << "object two: ";
        two.ShowData();
        Useless three, four;
        cout << "three = one\n";
        three = one;
        cout << "now object three = ";
        three.ShowData();
        cout << "and object one = ";
        one.ShowData();
        cout << "four = one + two\n";
        four = one + two;
        cout << "now object four = ";
        four.ShowData();
        cout << "four = move(one)\n";
        four = std::move(one);
        cout << "now object four = ";
        four.ShowData();
        cout << "and object one = ";
        one.ShowData();
    }

    return 0;
}
显示结果如下
object one: xxxxxxxxxx
object two: xxxxxxxxxxxxxxxxxxxx
three = one
copy assignment operator called:
now object three = xxxxxxxxxx
and object one = xxxxxxxxxx
four = one + two
move assignment operator called:
now object four = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
four = move(one)
move assignment operator called:
now object four = xxxxxxxxxx
and object one =  (object empty)

需要知道的是，函数std:move()并非一定会导致移动操作。如果没有定义移动赋值运算符，编译器将使用复制赋值运算符。
在原有4个特殊成员函数（默认构造函数、复制构造函数、复制赋值运算符和析构函数）的基础上，
C++11新增了两个：移动构造函数和移动赋值运算符。
这些成员函数是编译器在各种情况下自动提供的前面说过，在没有提供任何参数的情况下，将调用默认构造函数。
如果您没有给类定义任何构造函数，编译器将提供一个默认构造函数。这种版本的默认构造函数被称为默认的默认构造函数。
对于使用内置类型的成员，默认的默认构造函数不对其进行初始化；对于属于类对象的成员，则调用其默认构造函数。
另外，如果您没有提供复制构造函数，而代码又需要使用它，编译器将提供一个默认的复制构造函数；
如果您没有提供移动构造函数，而代码又需要使用它，编译器将提供一个默认的移动构造函数。
在类似的情况下，编译器将提供默认的复制运算符和默认的移动运算符。最后，如果您没有提供析构函数，编译器将提供一个。
对于前面描述的情况，有一些例外。
如果您提供了析构函数、复制构造函数或复制赋值运算符，编译器将不会自动提供移动构造函数和移动赋值运算符；
如果您提供了移动构造函数或移动赋值运算符，编译器将不会自动提供复制构造函数和复制赋值运算符。
另外，默认的移动构造函数和移动赋值运算符的工作方式与复制版本类似：
执行逐成员初始化并复制内置类型。如果成员是类对象，将使用相应类的构造函数和赋值运算符，就像参数为右值一样。
如果定义了移动构造函数和移动赋值运算符，这将调用它们；否则将调用复制构造函数和复制赋值运算符。
假定您要使用某个默认的函数，而这个函数由于某种原因不会自动创建。
例如，您提供了移动构造函数，因此编译器不会自动创建默认的构造函数、复制构造函数和复制赋值构造函数。
在这些情况下，您可使用关键字default显式地声明这些方法的默认版本。
编译器将创建在您没有提供移动构造函数的情况下将自动提供的构造函数。
另一方面，关键字delete可用于禁止编译器使用特定方法。例如，要禁止复制对象，可禁用复制构造函数和复制赋值运算符。
第12章说过，要禁止复制，可将复制构造函数和赋值运算符放在类定义的private部分，
但使用delete也能达到这个目的，且更不容易犯错、更容易理解。
如果在启用移动方法的同时禁用复制方法，结果将如何呢？前面说过，移动操作使用的右值引用只能关联到右值表达式，这意味着：
Someclass one;
Someclass two;
Someclass three (one);   // not allowed, one an Ivalue
Someclass four (one + two);   // allowed, expression is an rvalue
关键字default只能用于6个特殊成员函数，但delete可用于任何成员函数。delete的一种可能用法是禁止特定的转换。
如果给类提供了多个构造函数，您可能重复编写相同的代码。也就是说，有些构造函数可能需要包含其他构造函数中已有的代码。
为让编码工作更简单、更可靠，C++11允许您在一个构造函数的定义中使用另一个构造函数。
这被称为委托，因为构造函数暂时将创建对象的工作委托给另一个构造函数。委托使用成员初始化列表语法的变种。
为进一步简化编码工作，C++11提供了一种让派生类能够继承基类构造函数的机制。C++98提供了一种让名称空间中函数可用的语法：
namespace Box
{
    int fn (int) { ... }
    int fn (double) { ... }
    int fn (const char *) { ... }
}
...
using Box::fn;
...
这让函数fn的所有重载版本都可用。也可使用这种方法让基类的所有非特殊成员函数对派生类可用。
class C1
{
public:
    int fn (int j) { ... }
    double fn (double w) { ... }
    void fn (const char * s) { ... }

};
class C2 : public C1
{
public:
    using C1::fn;
    double fn (double) { ... };
};
C2 c2;
int k = c2.fn(3);   // uses C1::fn (int)
double z = c2.fn(2.4);   // uses C2::fn (double)
C2中的using声明让C2对象可使用C1的三个fn()方法，但将选择C2而不是C1定义的方法fn(double)。
C++11将这种方法用于构造函数。这让派生类继承基类的所有构造函数（默认构造函数、复制构造函数和移动构造函数除外），
但不会使用与派生类构造函数的特征标匹配的基类构造函数。注意，派生类要有自己的默认构造函数、复制构造函数和移动构造函数。
继承的基类构造函数只初始化基类成员；如果还要初始化派生类成员，则应使用成员列表初始化语法。
虚方法让基类引用或指针能够根据指向的对象类型调用相应的方法，但虚方法也带来了一些编程陷阱。
例如，假设基类声明了一个虚方法，而您决定在派生类中提供不同的版本，这将覆盖旧版本。
但正如第13章讨论的，如果特征标不匹配，将隐藏而不是覆盖旧版本。
在C+11中，可使用说明符override指出您要覆盖一个虚函数：将其放在参数列表后面。
如果声明与基类方法不匹配，编译器将视为错误。
说明符final解决了另一个问题。您可能想禁止派生类覆盖特定的虚方法，为此可在参数列表后面加上final。
说明符override和final并非关键字，而是具有特殊含义的标识符。
这意味着编译器根据上下文确定它们是否有特殊含义；在其他上下文中，可将它们用作常规标识符，如变量名或枚举。
假设您要生成一个随机整数列表，并判断其中多少个整数可被3整除，多个少整数可被13整除。
生成这样的列表很简单。一种方案是，使用vector<int>存储数字，并使用STL算法generate()在其中填充随机数：
#include <vector>
#include <algorithm>
#include <cmath>
std::vector<int> numbers (1000);
std::generate(numbers.begin(), numbers.end(), std::rand);
函数generate()接受一个区间（由前两个参数指定），并将每个元素设置为第三个参数返回的值，
而第三个参数是一个不接受任何参数的函数对象。在上述示例中，该函数对象是一个指向标准函数rand()的指针。
通过使用算法count_if()，很容易计算出有多少个元素可被3整除。
与函数generate()一样，前两个参数应指定区间，而第三个参数应是一个返回true或false的函数对象。
函数count_if()算这样的元素数，即它使得指定的函数对象返回true。
为判断元素能否被3整除，可使用下面的函数定义：
bool f3(int x) { return x % 3 == 0 }
为判断元素能否被13整除，可使用下面的函数定义：
bool f13(int x) { return x % 13 == 0 }

int count3 = std::count_if(numbers.begin(), numbers.end(), f3);
int count13 = std::count_if(numbers.begin(), numbers.end(), f13);
使用函数符来完成这个任务
class f_mod
{
private:
    int dv;
public:
    f_mod(int d = 1) : dv(d) {}
    bool operator() (int x) { return x % dv == 0;}
};

int count3 = std::count_if(numbers.begin(), numbers.end(), f_mod(3));
int count13 = std::count_if(numbers.begin(), numbers.end(), f_mod(13));

在C++11中，对于接受函数指针或函数符的函数，可使用匿名函数定义（lambda）作为其参数。
与前述函数对应的lambda如下：
[] (int x) { return x % 3 == 0; }
这与f3()的函数定义很像：
bool f3(int x) { return x % 3 == 0 }
差别有两个：使用[]替代了函数名（这就是匿名的由来）；没有声明返回类型。
返回类型相当于使用decltype根据返回值推断得到的，这里为bool。如果lambda不包含返回语句，推断出的返回类型将为void。
就这个示例而言，您将以如下方式使用该lambda：
int count3 = std::count_if(numbers.begin(), numbers.end(), [] (int x) { return x % 3 == 0; });
当lambad表达式完全由一条返回语句组成时，自动类型推断才管用：否则，需要使用新增的返回类型后置语法：
[] (double x) -> double {int y = x; return x - y;}   // return type is double
程序清单18.4 lambda0.cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <ctime>

const long Size1 = 39L;
const long Size2 = 100 * Size1;
const long Size3 = 100 * Size2;

bool f3(int x)
{
    return x % 3 == 0;
}
bool f13(int x)
{
    return x % 13 == 0;
}

int main()
{
    using std::cout;
    std::vector<int> numbers(Size1);
    std::srand(std::time(nullptr));
    std::generate(numbers.begin(), numbers.end(), std::rand);
    cout << "Sample size = " << Size1 << '\n';
    int count3 = std::count_if(numbers.begin(), numbers.end(), f3);
    cout << "Count of numbers divisible by 3: " << count3 << '\n';
    int count13 = std::count_if(numbers.begin(), numbers.end(), f13);
    cout << "Count of numbers divisible by 13: " << count13 << "\n\n";

    numbers.resize(Size2);
    std::generate(numbers.begin(), numbers.end(), std::rand);
    cout << "Sample size = " << Size2 << '\n';

    class f_mod
    {
    private:
        int dv;
    public:
        f_mod(int d = 1) : dv(d) {}
        bool operator () (int x)
        {
            return x % dv == 0;
        }
    };

    count3 = std::count_if(numbers.begin(), numbers.end(), f_mod(3));
    cout << "Count of numbers divisible by 3 : " << count3 << '\n';
    count13 = std::count_if(numbers.begin(), numbers.end(), f_mod(13));
    cout << "Count of numbers divisible by 13: " << count13 << "\n\n";

    numbers.resize(Size3);
    std::generate(numbers.begin(), numbers.end(), std::rand);
    cout << "Sample size = " << Size3 << '\n';

    count3 = std::count_if(numbers.begin(), numbers.end(),
                           [] (int x) -> bool
    {
        return x % 3 == 0;
    });
    cout << "Count of numbers divisible by 3: " << count3 << '\n';
    count13 = std::count_if(numbers.begin(), numbers.end(),
                            [] (int x) -> bool
    {
        return x % 13 == 0;
    });
    cout << "Count of numbers divisible by 13: " << count13 << '\n';

    return 0;
}
显示结果如下
Sample size = 39
Count of numbers divisible by 3: 17
Count of numbers divisible by 13: 5

Sample size = 3900
Count of numbers divisible by 3 : 1332
Count of numbers divisible by 13: 268

Sample size = 390000
Count of numbers divisible by 3: 129294
Count of numbers divisible by 13: 30348

可给lambda指定一个名称
auto mod3 = [] (int x) -> bool { return x % 3 == 0; }   // mod3 a name for the lambda
int count3 = std::count_if(numbers.begin(), numbers.end(), mod3);
您甚至可以像使用常规函数那样使用有名称的lambda：
bool result = mod3(z);   // result is true if z % 3 == 0
lambda可访问作用域内的任何动态变量：要捕获要使用的变量，可将其名称放在中括号内。
如果只指定了变量名，如[z]，将按值访问变量；如果在名称前加上&，如[&count]，将按引用访问变量。
[&]让您能够按引用访问所有动态变量，而[=]让您能够按值访问所有动态变量。
例如，[ted, &ed]让您能够按值访问ted以及按引用访问ed，[&, ted]让您能够按值访问ted以及按引用访问其他所有动态变量，
[=, &ed]让您能够按引用访问ed以及按值访问其他所有动态变量。
程序清单18.5 lambda1.cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <ctime>

const long Size = 390000L;

int main()
{
    using std::cout;
    std::vector<int> numbers(Size);
    std::srand(std::time(nullptr));
    std::generate(numbers.begin(), numbers.end(), std::rand);
    cout << "Sample size = " << Size << '\n';

    int count3 = std::count_if(numbers.begin(), numbers.end(),
                               [] (int x) -> bool {return x % 3 == 0; });
    cout << "Count of numbers divisible by 3 : " << count3 << '\n';
    int count13 = 0;
    std::for_each(numbers.begin(), numbers.end(),
                  [&count13] (int x)
    {
        count13 += (x % 13 == 0);
    });
    cout << "Count of numbers divisible by 13: " << count13 << '\n';

    count3 = count13 = 0;
    std::for_each(numbers.begin(), numbers.end(),
                  [&] (int x)
    {
        count3 += (x % 3 == 0);
        count13 += (x % 13 == 0);
    });
    cout << "Count of numbers divisible by 3: " << count3 << '\n';
    cout << "Count of numbers divisible by 13: " << count13 << '\n';

    return 0;
}
显示结果如下
Sample size = 390000
Count of numbers divisible by 3 : 129948
Count of numbers divisible by 13: 29989
Count of numbers divisible by 3: 129948
Count of numbers divisible by 13: 29989

程序清单18.6 somedefs.h
#ifndef SOMEDEFS_H_
#define SOMEDEFS_H_
#include <iostream>

template <typename T, typename F>
T use_f(T v, F f)
{
    static int count = 0;
    count++;
    std::cout << " use_f count = " << count
              << ", &count = " << &count << std::endl;
    return f(v);
}

class Fp
{
private:
    double z_;
public:
    Fp(double z = 1.0) : z_(z) {}
    double operator () (double p)
    {
        return z_ * p;
    }
};

class Fq
{
private:
    double z_;
public:
    Fq(double z = 1.0) : z_(z) {}
    double operator () (double q)
    {
        return z_ + q;
    }
};

#endif

程序清单18.7 callable.cpp
#include "somedefs.h"

double dub(double x)
{
    return 2.0 * x;
}
double square(double x)
{
    return x * x;
}

int main()
{
    using std::cout;
    using std::endl;
    double y = 1.21;
    cout << "Function pointer dub:\n";
    cout << " " << use_f(y, dub) << endl;
    cout << "Function pointer square:\n";
    cout << " " << use_f(y, square) << endl;
    cout << "Function object Fp:\n";
    cout << " " << use_f(y, Fp(5.0)) << endl;
    cout << "Function object Fq:\n";
    cout << " " << use_f(y, Fq(5.0)) << endl;
    cout << "Lambda expression 1:\n";
    cout << " " << use_f(y, [] (double u) -> double { return u *u; }) << endl;
    cout << "Lambda expression 2:\n";
    cout << " " << use_f(y, [] (double u) -> double { return u + u / 2.0; }) << endl;

    return 0;
}
显示结果如下
Function pointer dub:
  use_f count = 1, &count = 0x562e89e161a0
2.42
Function pointer square:
  use_f count = 2, &count = 0x562e89e161a0
1.4641
Function object Fp:
  use_f count = 1, &count = 0x562e89e161a4
6.05
Function object Fq:
  use_f count = 1, &count = 0x562e89e161a8
6.21
Lambda expression 1:
  use_f count = 1, &count = 0x562e89e16198
1.4641
Lambda expression 2:
  use_f count = 1, &count = 0x562e89e1619c
1.815

程序清单18.8 wrapped.cpp
#include <functional>
#include "somedefs.h"

double dub(double x)
{
    return 2.0 * x;
}
double square(double x)
{
    return x * x;
}

int main()
{
    using std::cout;
    using std::endl;
    using std::function;
    double y = 1.21;
    function<double(double)> ef1 = dub;
    function<double(double)> ef2 = square;
    function<double(double)> ef3 = Fq(10.0);
    function<double(double)> ef4 = Fp(10.0);
    function<double(double)> ef5 = [] (double u) -> double {return u * u; };
    function<double(double)> ef6 = [] (double u) -> double {return u + u / 2.0; };
    cout << "Function pointer dub:\n";
    cout << " " << use_f(y, ef1) << endl;
    cout << "Function pointer square:\n";
    cout << " " << use_f(y, ef2) << endl;
    cout << "Function object Fp:\n";
    cout << " " << use_f(y, ef3) << endl;
    cout << "Function object Fq:\n";
    cout << " " << use_f(y, ef4) << endl;
    cout << "Lambda expression l:\n";
    cout << " " << use_f(y, ef5) << endl;
    cout << "Lambda expression 2:\n";
    cout << " " << use_f(y, ef6) << endl;

    return 0;
}
显示结果如下
Function pointer dub:
  use_f count = 1, &count = 0x5606dc561194
2.42
Function pointer square:
  use_f count = 2, &count = 0x5606dc561194
1.4641
Function object Fp:
  use_f count = 3, &count = 0x5606dc561194
11.21
Function object Fq:
  use_f count = 4, &count = 0x5606dc561194
12.1
Lambda expression l:
  use_f count = 5, &count = 0x5606dc561194
1.4641
Lambda expression 2:
  use_f count = 6, &count = 0x5606dc561194
1.815

#include <functional>
template <typename T>
T use_f (T v, std::function<T (T) > f)
{
    static int count = 0;
    count++;
    std::cout << " use_f count = " << count << ", &count = " << &count << std::endl;
    return f(v);
}

cout << " " << use_f<double>(y, dub) << endl;
cout << " " << use_f<double>(y, Fp(5.0)) << endl;
cout << " " << use_f<double>(y, [] (double u) -> double {return u * u;}) << endl;

可变参数模板
模板参数包（parameter pack）；
函数参数包；
展开（unpack）参数包；
递归。
C++11提供了一个用省略号表示的元运算符（meta-operator），让您能够声明表示模板参数包的标识符，
模板参数包基本上是一个类型列表。同样，它还让您能够声明表示函数参数包的标识符，而函数参数包基本上是一个值列表。其语法如下：
template <typename... Args>
void show_list1(Args... args)
{
    ...
}
其中，Args是一个模板参数包，而args是一个函数参数包。与其他参数名一样，可将这些参数包的名称指定为任何符合C++标识符规则的名称。
Args和T的差别在于，T与一种类型匹配，而Args与任意数量（包括零）的类型匹配。请看下面的函数调用：
show_list1 ('S', 80, "sweet", 4.5);
在这种情况下，参数包Args包含与函数调用中的参数匹配的类型：char，int，const char *和double。
函数参数包args包含的值列表与模板参数包Args包含的类型列表匹配（无论是类型还是数量）。
在上面的示例中，args包含值'S'，80、"sweet"和4.5。
可将省略号放在函数参数包名的右边，将参数包展开。
程序清单18.9 variadic1.cpp
#include <iostream>
#include <string>

void show_list3() {}

template<typename T, typename... Args>
void show_list3(T value, Args... args)
{
    std::cout << value << ", ";
    show_list3(args...);
}

int main()
{
    int n = 14;
    double x = 2.71828;
    std::string mr = "Mr. String objects!";
    show_list3(n, x);
    show_list3(x * x, '!', 7, mr);

    return 0;
}
显示结果如下
14, 2.71828, 7.38905, !, 7, Mr. String objects!, 

在可变参数模板中，可指定展开模式（pattern）。为此，可将下述代码：
show_list3 (Args ... args);
替换为如下代码：
show_list3 (const Args & ... args);
这将对每个函数参数应用模式const &，这样，最后分析的参数将不是std:string mr，而是const std:string & mr。
程序清单18.10 variadic2.cpp
#include <iostream>
#include <string>

void show_list() {}

template<typename T>
void show_list(const T &value)
{
    std::cout << value << '\n';
}

template<typename T, typename ... Args>
void show_list(const T & value, const Args & ... args)
{
    std::cout << value << ", ";
    show_list(args ... );
}

int main()
{
    int n = 14;
    double x = 2.71828;
    std::string mr = "Mr. String objects!";
    show_list(n, x);
    show_list(x * x, '!', 7, mr);

    return 0;
}
显示结果如下
14, 2.71828
7.38905, !, 7, Mr. String objects!

为解决并行编程问题，C++11定义了一个支持线程化执行的内存模型，添加了关键字thread_local，，提供了相关的库支持。
关键字thread_local将变量声明为静态存储，其持续性与特定线程相关，即定义这种变量的线程过期时，变量也将过期。
库支持由原子操作（atomic operation）库和线程支持库组成，其中原子操作库提供了头文件atomic，
而线程支持库提供了头文件thread，mutex，condition_variable和future。
C++11添加了多个专用库。头文件random支持的可扩展随机数库提供了大量比rand()复杂的随机数工具。
例如，您可以选择随机数生成器和分布状态，分布状态包括均匀分布（类似于rand()）、二项式分布和正态分布等。
头文件chrono提供了处理时间间隔的途径。
头文件tuple支持模板tuple，tuple对象是广义的pair对象。
pair对象可存储两个类型不同的值，而tuple对象可存储任意多个类型不同的值。
头文件ratio支持的编译阶段有理数算术库让您能够准确地表示任何有理数，其分子和分母可用最宽的整型表示。
它还支持对这些有理数进行算术运算。
在新增的库中，最有趣的一个是头文件regex支持的正则表达式库。正则表达式指定了一种模式，可用于与文本字符串中的内容匹配。
要获悉有关类型或对象的对齐要求，可使用运算符alignof()，要控制对齐方式，可使用说明符alignas。
constexpr机制让编译器能够在编译阶段计算结果为常量的表达式，让const变量可存储在只读内存中这对嵌入式编程来说很有用
（在运行阶段初始化的变量存储在随机访问内存中）。

18.11 复习题
1.使用用大括号括起的初始化列表语法重写下述代码。重写后的代码不应使用数组ar
class Z200
{
private:
    int j;
    char ch;
    double z;
public:
    Z200(int jv, char chv, zv) : j(jv), ch(chv), z(zv) {}
...
};
double x = 8.8;   // double x {8.8}
std::string s = "What a bracing effect!";   // std::string s {"What a bracing effect!"}
int k(99);   // int k {99};
Z200 zip(200, 'Z', 0.675);   // Z200 zip {200, 'Z', 0.675};
std::vector<int> ai(5);   // std::vector<int> ai {3, 9 ,4, 7, 1};
int ar[5] = {3, 9, 4, 7, 1};
for (auto pt = ai.begin(), int i = 0; pt != ai.end(); ++pt, ++i)
{
    *pt = ar[i];
}

2.在下述简短的程序中，哪些函数调用不对？为什么？对于合法的函数调用，指出其引用参数指向的是什么。
#include <iostream>

using namespace std;

double up(double x)
{
    return 2.0 * x;
}
void r1(const double &rx)
{
    cout << rx << endl;
}
void r2(double &rx)
{
    cout << rx << endl;
}
void r3(double &&rx)
{
    cout << rx << endl;
}
int main()
{
    double w = 10.0;
    r1(w);   // 合法，指向w
    r1(w + 1);   //合法，指向临时变量（被初始化为w+1）
    r1(up(w));   //合法，指向临时变量（被初始化为up(w)）
    r2(w);   // 合法，指向w
    r2(w + 1);   // 非法，w+1是一个右值
    r2(up(w));   // 非法，up(w)的返回值是一个右值
    r3(w);   // 非法，右值引用不能指向左值
    r3(w + 1);   //合法，指向表达式w+1的临时拷贝
    r3(up(w));   //合法，指向up(w)的临时返回值
    return 0;
}

3.a.下述简短的程序显示什么？为什么？
#include <iostream>

using namespace std;

double up(double x)
{
    return 2.0 * x;
}
void r1(const double &rx)
{
    cout << "const double & rx\n";
}
void r1(double &rx)
{
    cout << "double & rx\n";
}
int main()
{
    double w = 10.0;
    r1(w);   //double & rx
    r1(w + 1);   //const double & rx
    r1(up(w));   //const double & rx
    return 0;
}
b.下述简短的程序显示什么？为什么？
#include <iostream>

using namespace std;

double up(double x)
{
    return 2.0 * x;
}
void r1(double &rx)
{
    cout << "double & rx\n";
}
void r1(double &&rx)
{
    cout << "double && rx\n";
}
int main()
{
    double w = 10.0;
    r1(w);   //double & rx
    r1(w + 1);   //double && rx
    r1(up(w));   //double && rx
    return 0;
}
c.下述简短的程序显示什么？为什么？
#include <iostream>
using namespace std;

double up(double x)
{
    return 2.0 * x;
}
void r1(const double &rx)
{
    cout << "const double &rx\n";
}
void r1(double &&rx)
{
    cout << "double &&rx\n";
}
int main()
{
    double w = 10.0;
    r1(w);   //const double & rx
    r1(w + 1);   //double && rx
    r1(up(w));   //double && rx
    return 0;
}
4，哪些成员函数是特殊的成员函数？它们特殊的原因是什么？
默认构造函数、复制构造函数、移动构造函数、析构函数、复制赋值运算符和移动赋值运算符
编译器将根据情况自动提供它们的默认版本。

5，假设Fizzle类只有如下所示的数据成员：
class Fizzle
{
private:
    double bubbles[4000];
    ...
};
为什么不适合给这个类定义移动构造函数？要让这个类适合定义移动构造函数，应如何修改存储4000个doublef的方式？
对于标准数组，没有转让其所有权的机制。如果Fizzle使用指针和动态内存分配，则可将数据的地址赋给新指针，以转让其所有权。

6，修改下述简短的程序，使其使用lambda表达式而不是f1()。请不要修改show2()。
#include <iostream>
#include <algorithm>

template<typename T> 
void show2(double x, T & fp)
{
    std::cout << x << " -> " << fp(x) << '\n';
}
double f1(double x)
{
    return 1.8 * x + 32;
}
int main()
{
    show2(18.0, f1);   //show2(18.0, [] (double x) -> double {return 1.8 * x + 32;});
    return 0;
}

7.修改下述简短而丑陋的程序，使其使用lambda表达式而不是函数符Adder。请不要修改sum()。
#include <iostream>
#include <array>
#include <algorithm>

const int Size = 5;

template<typename T>
void sum(std::array<double, Size> & a, T & fp);

class Adder
{
    double tot;
public:
    Adder(double q = 0) : tot(q) {}
    void operator()(double w)
    {
        tot += w;
    }
    double tot_v () const
    {
        return tot;
    };
};
int main()
{
    double total = 0.0;
    Adder ad(total);
    std::array<double, Size> temp_c = {32.1, 34.3, 37.8, 35.2, 34.7};
    sum(temp_c, ad);   // sum (temp_c, [&total] (double w) {total += w;});
    total = ad.tot_v();
    std::cout << "total: " << total << '\n';
    return 0;
}
template<typename T>
void sum(std::array<double, Size> & a, T & fp)
{
    for(auto pt = a.begin(); pt != a.end(); ++pt)
    {
        fp(*pt);
    }
}

18.12 编程练习
1.下面是一个简短程序的一部分：
int main()
{
    using namespace std;
    auto q = average_list({15.4, 10.7, 9.0});
    cout << q << endl;
    cout << average_list({20, 30, 19, 17, 45, 38})<< endl;
    auto ad = average_list<double>({'A', 70, 65.33});
    cout << ad << endl;
    return 0;
}
请提供函数average list()，让该程序变得完整。它应该是一个模板函数，
其中的类型参数指定了用作函数参数的intitlize_list模板的类型以及函数的返回类型。
#include <iostream>
#include <initializer_list>

template <typename T>
T average_list(std::initializer_list<T> il)
{
    T sum = 0;
    for (auto pi = il.begin(); pi != il.end(); pi++)
    {
        sum += *pi;
    }
    T average = sum / il.size();
    return average;
}

int main()
{
    auto q = average_list({ 15.4, 10.7, 9.0 });
    std::cout << q << std::endl;

    std::cout << average_list({ 20, 30, 19, 17, 45, 38 }) << std::endl;

    auto ad = average_list<double>({ 'A', 70, 65.33 });
    std::cout << ad << std::endl;

    return 0;
}
显示结果如下
11.7
28
66.7767

2.下面是类Cpmv的声明：
class Cpmv
{
public:
    struct Info
    {
        std::string qcode;
        std::string zcode;
    };
private:
    Info *pi;
public:
    Cpmv();
    Cpmv(std::string q, std::string z);
    Cpmv(const Cpmv &cp);
    Cpmv(Cpmv &&mv);
    ~Cpmv();
    Cpmv &operator=(const Cpmv &cp);
    Cpmv &operator=(Cpmv &&mv);
    Cpmv operator+(const Cpmv &obj) const;
    void Display() const;
};
函数operator+()应创建一个对象，其成员qcode和zcode由操作数的相应成员拼接而成。
请提供为移动构造函数和移动赋值运算符实现移动语义的代码。编写一个使用所有这些方法的程序。
为方便测试，让各个方法都显示特定的内容，以便知道它们被调用。
#include <iostream>
#include <string>

class Cpmv
{
public:
    struct Info
    {
        std::string qcode;
        std::string zcode;
    };
private:
    Info *pi;
public:
    Cpmv();
    Cpmv(std::string q, std::string z);
    Cpmv(const Cpmv &cp);
    Cpmv(Cpmv &&mv);
    ~Cpmv();

    Cpmv &operator = (const Cpmv &cp);
    Cpmv &operator = (Cpmv &&mv);
    Cpmv operator + (const Cpmv &obj) const;
    void Display() const;
};

Cpmv::Cpmv()
{
    pi = new Info;
    std::cout << "Default constructor called\n";
    std::cout << "Address " << (void *)pi << std::endl << std::endl;
}

Cpmv::Cpmv(std::string q, std::string z)
{
    pi = new Info;
    pi->qcode = q;
    pi->zcode = z;
    std::cout << "q and z constructor called\n";
    std::cout << "Address " << (void *)pi << std::endl << std::endl;
}

Cpmv::Cpmv(const Cpmv &cp)
{
    std::cout << "Copy constructor called\n";
    pi = new Info;
    pi->qcode = cp.pi->qcode;
    pi->zcode = cp.pi->zcode;
    std::cout << "Address " << (void *)pi << std::endl << std::endl;
}

Cpmv::Cpmv(Cpmv && mv)
{
    std::cout << "Move constructor called\n";
    pi = new Info;
    pi = mv.pi;
    mv.pi = nullptr;
    std::cout << "Address " << (void *)pi << std::endl << std::endl;
}

Cpmv Cpmv::operator + (const Cpmv &obj) const
{
    std::cout << "Entering operator +()\n";
    Cpmv temp;
    temp.pi->qcode = pi->qcode + obj.pi->qcode;
    temp.pi->zcode = pi->zcode + obj.pi->zcode;

    std::cout << "Leaving operator+()\n";
    return temp;
}

Cpmv &Cpmv::operator = (const Cpmv &cp)
{
    std::cout << "Entering operator=(const Cpmv & cp)\n";

    if (this == &cp)
    {
        return *this;
    }

    delete pi;
    pi = new Info;
    pi->qcode = cp.pi->qcode;
    pi->zcode = cp.pi->zcode;

    std::cout << "Leaving operator=()\n";
    return *this;
}

Cpmv &Cpmv::operator = (Cpmv &&mv)
{
    std::cout << "Entering operator=(Cpmv && mv)\n";

    if (this == &mv)
    {
        return *this;
    }

    delete pi;
    pi = mv.pi;
    mv.pi = nullptr;

    std::cout << "Address " << (void *)pi << std::endl << std::endl;
    return *this;
}

Cpmv::~Cpmv()
{
    std::cout << "Destructor called\n";
    std::cout << "Address " << (void *)pi << std::endl << std::endl;

    delete pi;
}

void Cpmv::Display() const
{
    if (pi == nullptr)
    {
        std::cout << "Empty object\n";
    }
    else
    {
        std::cout << " " << pi->qcode << ", ";
        std::cout << pi->zcode << std::endl;
    }
}

int main()
{
    {
        Cpmv one("Hi ", "Sunny");
        Cpmv two = one;

        Cpmv three("Hello", "World!");
        Cpmv four = one + three;

        Cpmv five;
        five = one;

        Cpmv six;
        six = five + three;

        std::cout << "\nobject 1";
        one.Display();

        std::cout << "\nobject 2";
        two.Display();

        std::cout << "\nobject 3";
        three.Display();

        std::cout << "\nobject 4";
        four.Display();

        std::cout << "\nobject 5";
        five.Display();

        std::cout << "\nobject 6";
        six.Display();
    }
    std::cout << std::endl;

    return 0;
}
显示结果如下
q and z constructor called
Address 0x561e7f070eb0

Copy constructor called
Address 0x561e7f071310

q and z constructor called
Address 0x561e7f071360

Entering operator +()
Default constructor called
Address 0x561e7f0713b0

Leaving operator+()
Default constructor called
Address 0x561e7f071400

Entering operator=(const Cpmv & cp)
Leaving operator=()
Default constructor called
Address 0x561e7f071450

Entering operator +()
Default constructor called
Address 0x561e7f0714a0

Leaving operator+()
Entering operator=(Cpmv && mv)
Address 0x561e7f0714a0

Destructor called
Address 0


object 1 Hi , Sunny

object 2 Hi , Sunny

object 3 Hello, World!

object 4 Hi Hello, SunnyWorld!

object 5 Hi , Sunny

object 6 Hi Hello, SunnyWorld!
Destructor called
Address 0x561e7f0714a0

Destructor called
Address 0x561e7f071400

Destructor called
Address 0x561e7f0713b0

Destructor called
Address 0x561e7f071360

Destructor called
Address 0x561e7f071310

Destructor called
Address 0x561e7f070eb0

3，编写并测试可变参数模板函数sum_values()，它接受任意长度的参数列表（其中包含数值，但可以是任何类型），并以long double的方式返回这些数值的和。
#include <iostream>
#include <iomanip>

long double sum_values()
{
    return 0.0;
}

template <typename T, typename ... Args>
long double sum_values(const T &value, const Args &... args)
{
    long double sum = 0;
    sum = value + sum_values(args ...);
    return sum;
}

int main()
{
    std::cout << std::fixed;
    std::cout << sum_values(5, 5, 5) << std::endl;
    std::cout << std::setprecision(10) << sum_values(20.0, 1.0, 8.6578787879, 1) << std::endl;

    return 0;
}
显示结果如下
15.000000
30.6578787879

4.使用lambda重新编写程序清单16.15，具体地说，使用一个有名称的lambda替换函数outint()，并将函数符替换为两个匿名lambda表达式。
#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>

int main()
{
    int vals[10] = { 50, 100, 90, 180, 60, 210, 415, 88, 188, 201 };
    std::list<int> yadayada(vals, vals + 10);
    std::list<int> etcetera(vals, vals + 10);

    auto outint = [](int n)
    {
        std::cout << n << " ";
    };
    std::cout << "Original lists:\n";
    std::for_each(yadayada.begin(), yadayada.end(), outint);
    std::cout << std::endl;
    std::for_each(etcetera.begin(), etcetera.end(), outint);
    std::cout << std::endl;

    yadayada.remove_if([](int x)
    {
        return x > 100;
    });
    etcetera.remove_if([](int x)
    {
        return x > 200;
    });

    std::cout << "Trimmed lists:\n";
    std::for_each(yadayada.begin(), yadayada.end(), outint);
    std::cout << std::endl;
    std::for_each(etcetera.begin(), etcetera.end(), outint);
    std::cout << std::endl;

    return 0;
}
显示结果如下
Original lists:
50 100 90 180 60 210 415 88 188 201
50 100 90 180 60 210 415 88 188 201
Trimmed lists:
50 100 90 60 88
50 100 90 180 60 88 188

Accelerated C++
前言
第0章 开始学习C++
0.1 注释
0.2 #include 指令
0.3 主函数main
0.4 花括号
0.5 使用标准库进行输出
0.6 返回语句
0.7 一些较为深入的观察
0.8 小结
习题
0-0 编译并运行Hello, world!程序。
#include <iostream>

int main()
{
    std::cout << "Hello, World!" << std::endl;
}
显示结果如下
Hello, World!

0-1 下面的表达式是做什么的？
3+4；
#include <iostream>

int main()
{
    std::cout << 3 + 4 << std::endl;
}
显示结果如下
7

0-2 编写一个程序，使它在运行时输出：
This (") is a quote, and this (\) is a backlash.
#include <iostream>

int main()
{
    std::cout << "This (\") is a quote, and this (\\) is a backslash." << std::endl;
}
显示结果如下
This (") is a quote, and this (\) is a backslash.

0-3 字符串字面量"\t"代表一个水平制表符；不同的C++实现以不同的形式显示制表符。
在你的实现中试验一下，看它是怎样处理制表符的。
#include <iostream>

int main()
{
    std::cout << "this is a tab \ttest." << std::endl
              << "\ttab" << std::endl
              << "\ttab \ttest." << std::endl;
}
显示结果如下
this is a tab   test.
        tab
        tab     test.

0-4 编写一个程序，运行时以Hello, world！程序作为这个程序的输出。
#include <iostream>

int main()
{
    std::cout << "// A small C++ program" << std::endl
              << "#include <iostream>" << std::endl << std::endl
              << "int main()" << std::endl
              << "{" << std::endl
              << "\tstd::cout << \"Hello, World!\" << std::endl;" << std::endl
              << "\treturn 0;" << std::endl
              << "}" << std::endl << std::endl;
}
显示结果如下
// A small C++ program
#include <iostream>

int main()
{
        std::cout << "Hello, World!" << std::endl;
        return 0;
}

0-5 下面的程序是一个有效的程序吗？说出理由。
#include <iostream>
int main() std::cout << "Hello, world!" << std::endl;

main函数缺少花括号{}
修改后
#include <iostream>

int main() { std::cout << "Hello, world!" << std::endl; }
显示结果如下
Hello, world!

0-6下面的程序是一个有效的程序吗？说出理由。
#include <iostream>
int main() {{{{{{  std::cout << "Hello, world!" << std::endl;    }}}}}}

有效
显示结果如下
Hello, world!

0-7那下面的这个程序呢？
#include <iostream>
int main()
{
    /* This is a comment that extends over several lines
        because it uses /* and */ as its starting and ending delimiters */
    std::cout << "Does this work?" << std::endl;
    return 0;
}

有问题，and */要修改为and * /
修改后
#include <iostream>

int main()
{
    /* This is a comment that extends over several lines
    because it uses /* and * / as its starting and ending delimiters */
    std::cout << "Does this work?" << std::endl;
    return 0;
}
显示结果如下
Does this work?

0-8  这个呢？
#include <iostream>
int main()
{
    // This is a comment that extends over several lines
    // by using // at the beginning of each line instead of using /*
    // or */ to delimit comments.
    std::cout << "Does this work?" << std::endl;
    return 0;
}

有效
显示结果如下
Does this work?


0-9 最短的有效程序是什么？
int main() {}
0-10 重写Hello, world!程序，让程序中每一个允许出现空白符的地方都换行。
#include <iostream>

int
main
(
)
{
  std
    ::
    cout
    <<
    "Hello, world!"
    <<
    std
    ::
    endl
    ;
  return
    0
    ;
}
显示结果如下
Hello, world!

第1章 使用字符串
1.1 输入
1.2 为姓名装框
1.3 小结
习题
1-0 编译、运行并测试本章中的程序。
#include <iostream>
#include <string>

void AskName(std::ostream &outStream, std::istream &inStream)
{
    outStream << "Please enter your first name: ";
    std::string name;
    inStream >> name;
    outStream << "Hello, " + name + "!" << std::endl;
}

void AskNameFramed(std::ostream &outStream, std::istream &inStream)
{
    outStream << "Please enter your first name: ";
    std::string name;
    inStream >> name;

    const std::string greeting = "Hello, " + name + "!";
    const std::string spaces(greeting.size(), ' ');
    const std::string line3 = '*' + greeting + '*';
    const std::string line2 = '*' + spaces + '*';
    const std::string line1(line2.size(), '*');

    outStream << line1 << std::endl << line2 << std::endl << line3
              << std::endl << line2 << std::endl << line1 << std::endl;
}

int main()
{
    AskName(std::cout, std::cin);
    AskNameFramed(std::cout, std::cin);

    return 0;
}
显示结果如下
Please enter your first name: Peter
Hello, Peter!
Please enter your first name: Mike
**************
*            *
*Hello, Mike!*
*            *
**************

1-1 以下的定义有效吗？理由是什么？
const std::string hello = "Hello";
const std::string message = hello + ", world" + "!";

有效
#include <iostream>
#include <string>

int main()
{
    const std::string hello = "Hello";
    const std::string message = hello + ", world" + "!";

    std::cout << hello << '\n';
    std::cout << message << '\n';

    return 0;
}
显示结果如下
Hello
Hello, world!

1-2 以下的定义有效吗？理由是什么？
const std::string exclam = "!";
const std::string message = "Hello" + ", world" + exclam;

无效，两个C风格的字符串不能直接应用+运算符，
修改后
#include <iostream>
#include <string>

int main()
{
    const std::string exclam = "!";
    const std::string message = "Hello" + (", world" + exclam);

    std::cout << exclam << '\n';
    std::cout << message << '\n';

    return 0;
}
显示结果如下
!
Hello, world!

1-3 以下的程序有效吗？如果有效的话，它是做什么的？如果无效，为什么呢？
#include <iostream>
#include <string>

int main()
{
    {
        const std::string s = "a string";
        std::cout << s << std::endl;
    }

    {
        const std::string s = "another string";
        std::cout << s << std::endl;
    }

    return 0;
}
有效
显示结果如下
a string
another string

1-4 下面的这个程序又怎样呢？如果我们把倒数第三行的}}改成};}的话，会出现什么情况呢？
#include <iostream>
#include <string>

int main()
{
    {
        const std::string s = "a string";
        std::cout << s << std::endl;
        {
            const std::string s = "another string";
            std::cout << s << std::endl;
        }
    }
    return 0;
}
有效
显示结果如下
a string
another string

如果我们把倒数第三行的}}改成};}的话
#include <iostream>
#include <string>

int main()
{
    {
        const std::string s = "a string";
        std::cout << s << std::endl;
        {
            const std::string s = "another string";
            std::cout << s << std::endl;
        };
    }
    return 0;
}
有效
显示结果如下
a string
another string

1-5下面这个程序呢？如果有效，它是做什么的？如果无效，说出理由，然后把它改写成有效的程序。
#include <iostream>
#include <string>

int main()
{
    {
        std::string s = "a string";
        {
            std::string x = s + ", really";
            std::cout << s << std::endl;
        }
        std::cout << x << std::endl;   // 无效，x is undefined in current scope
    }
    return 0;
}

修改后
#include <iostream>
#include <string>

int main()
{
    {
        std::string s = "a string";
        {
            std::string x = s + ", really";
            std::cout << s << std::endl;
            std::cout << x << std::endl;
        }
    }
    return 0;
}
显示结果如下
a string
a string, really

1-6 在下面的程序向你发出输入请求的时候，如果你输入了两个名字（例如，Samuel Beckett），它会怎么样处理呢？
在运行程序之前先预测一下结果，然后上机试一下。
#include <iostream>
#include <string>
int main()
{
    std::cout << "What is your name? ";
    std::string name;
    std::cin >> name;
    std::cout << "Hello, " << name << std::endl << "And what is yours? ";
    std::cin >> name;
    std::cout << "Hello, " << name << "; nice to meet you too!" << std::endl;
    return 0;
}
显示结果如下
What is your name? Peter Simth
Hello, Peter
And what is yours? Hello, Simth; nice to meet you too!

第2章 循环和计数
2.1 问题
2.2 程序的整体结构
2.3 输出数目未知的行
2.4 输出一行
2.5 完整的框架程序
2.6 计数
2.7 小结
习题
2-0 编译并运行我们在本章中介绍的程序。
#include <iostream>
#include <string>

using std::cin;
using std::cout;
using std::endl;
using std::string;

int main()
{
    cout << "Please enter your first name: ";

    string name;
    cin >> name;

    const string greeting = "Hello, " + name + "!";
    const int pad = 1;
    const int rows = pad * 2 + 3;
    const string::size_type cols = greeting.size() + pad * 2 + 2;

    cout << endl;

    for (int r = 0; r != rows; ++r)
    {
        string::size_type c = 0;

        while (c != cols)
        {

            if (r == pad + 1 && c == pad + 1)
            {
                cout << greeting;
                c += greeting.size();
            }
            else
            {
                if (r == 0 || r == rows - 1 || c == 0 || c == cols - 1)
                {
                    cout << "*";
                }
                else
                {
                    cout << " ";
                }
                ++c;
            }
        }

        cout << endl;
    }

    return 0;
}
显示结果如下
Please enter your first name: Peter

*****************
*               *
* Hello, Peter! *
*               *
*****************

2-1 改写框架程序，输出跟框架没有间隔的问候语
#include <iostream>
#include <string>

using std::cin;
using std::cout;
using std::endl;
using std::string;

int main()
{
    cout << "Please enter your first name: ";

    string name;
    cin >> name;

    const string greeting = "Hello, " + name + "!";
    const int pad = 0;
    const int rows = pad * 2 + 3;
    const string::size_type cols = greeting.size() + pad * 2 + 2;

    cout << endl;

    for (int r = 0; r != rows; ++r)
    {
        string::size_type c = 0;

        while (c != cols)
        {

            if (r == pad + 1 && c == pad + 1)
            {
                cout << greeting;
                c += greeting.size();
            }
            else
            {
                if (r == 0 || r == rows - 1 || c == 0 || c == cols - 1)
                {
                    cout << "*";
                }
                else
                {
                    cout << " ";
                }
                ++c;
            }
        }

        cout << endl;
    }

    return 0;
}
显示结果如下
Please enter your first name: Mike

**************
*Hello, Mike!*
**************

2-2 在我们的框架程序中，我们使用了一定数目的空格来把问候语和顶部以及底部边界分隔开来。
现在，重新编写这个程序，在重写的程序中使用数量跟原程序不同的空格来把各边界和问候语分隔开。
#include <iostream>
#include <string>

using std::cin;
using std::cout;
using std::endl;
using std::string;

int main()
{
    cout << "Please enter your first name: ";

    string name;
    cin >> name;

    const string greeting = "Hello, " + name + "!";

    const int vert_pad = 1;
    const int horz_pad = 3;

    const int rows = vert_pad * 2 + 3;
    const string::size_type cols = greeting.size() + horz_pad * 2 + 2;

    cout << endl;

    for (int r = 0; r != rows; ++r)
    {
        string::size_type c = 0;

        while (c != cols)
        {

            if (r == vert_pad + 1 && c == horz_pad + 1)
            {
                cout << greeting;
                c += greeting.size();
            }
            else
            {
                if (r == 0 || r == rows - 1 || c == 0 || c == cols - 1)
                {
                    cout << "*";
                }
                else
                {
                    cout << " ";
                }
                ++c;
            }
        }

        cout << endl;
    }

    return 0;
}
显示结果如下
Please enter your first name: Apple

*********************
*                   *
*   Hello, Apple!   *
*                   *
*********************

2-3重写框果程序，让用户自己提供在框架和问候语之间的空格个数。
#include <iostream>
#include <string>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::string;

int FrameDynamic(istream &in, ostream &out, const int pad)
{
    out << "Please enter your first name: ";

    string name;
    in >> name;

    const string greeting = "Hello, " + name + "!";
    const int rows = pad * 2 + 3;
    const string::size_type cols = greeting.size() + pad * 2 + 2;

    out << endl;

    for (int r = 0; r != rows; ++r)
    {
        string::size_type c = 0;

        while (c != cols)
        {

            if (r == pad + 1 && c == pad + 1)
            {
                out << greeting;
                c += greeting.size();
            }
            else
            {
                if (r == 0 || r == rows - 1 || c == 0 || c == cols - 1)
                {
                    out << "*";
                }
                else
                {
                    out << " ";
                }
                ++c;
            }
        }

        out << endl;
    }

    return 0;
}

int main()
{
    int padding;
    cout << "Please enter frame padding: ";
    cin >> padding;
    cout << endl;

    return FrameDynamic(cin, cout, padding);
}
显示结果如下
Please enter frame padding: 3

Please enter your first name: Flower

**********************
*                    *
*                    *
*                    *
*   Hello, Flower!   *
*                    *
*                    *
*                    *
**********************

2-4 在框架程序中的空白行是用来把边界和问候语分隔开的，程序每次一个字符地输出了大部分的空白行。
改写这个程序，让它在单独的一条输出表达式中输出所有的空白行。
#include <iostream>
#include <string>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::string;

int FrameDynamicAlt(istream &in, ostream &out, const int pad)
{
    out << "Please enter your first name: ";
    string name;
    in >> name;
    out << endl;

    const string greeting = "Hello, " + name + "!";
    const int rows = pad * 2 + 3;
    const string::size_type cols = greeting.size() + pad * 2 + 2;

    for (int r = 0; r != rows; r++)
    {
        string::size_type c = 0;
        while (c != cols)
        {
            if (r == rows / 2 && c == pad + 1)
            {
                out << greeting;
                c += greeting.size();
            }
            else if (r != 0 && r != rows - 1 && r != rows / 2 && c != 0 && c != cols - 1)
            {
                out << string(cols - 2, ' ');
                c += cols - 2;
            }
            else
            {
                if (r == 0 || r == rows - 1 || c == 0 || c == cols - 1)
                {
                    out << "*";
                }
                else
                {
                    out << " ";
                }
                c++;
            }
        }
        out << std::endl;
    }

    return 0;
}

int main()
{
    int padding;
    cout << "Please enter frame padding: ";
    cin >> padding;
    cout << endl;

    return FrameDynamicAlt(cin, cout, padding);
}
显示结果如下
Please enter frame padding: 5

Please enter your first name: Water

*************************
*                       *
*                       *
*                       *
*                       *
*                       *
*     Hello, Water!     *
*                       *
*                       *
*                       *
*                       *
*                       *
*************************

2-5 编写一个程序，让它输出一系列的“*”字符，程序输出的这些字符将构成一个正方形，一个长方形和一个三角形
#include <iostream>
using std::cout;
using std::endl;

int main()
{
    for (int i = 0; i < 7; i++)
    {
        for (int j = 0; j < 10; j++)
        {
            if (j == 0 || j == 10 - 1 || i == 0 || i == 7 - 1)
            {
                cout << "*";
            }
            else
            {
                cout << " ";
            }
        }
        cout << endl;
    }

    cout << endl;

    for (int i = 0; i < 10; i++)
    {
        for (int j = 0; j < 10; j++)
        {
            if (j == 0 || j == 10 - 1 || i == 0 || i == 10 - 1)
            {
                cout << "*";
            }
            else
            {
                cout << " ";
            }
        }
        cout << endl;
    }

    cout << endl;

    const int height = 7;
    const int width = height * 2 - 1;

    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < width; j++)
        {
            if ((i == height - 1) || (i == 0 && j == height - 1))
            {
                cout << "*";
            }
            else if (i > 0 && (j == height - 1 + i || j == height - 1 - i))
            {
                cout << "*";
            }
            else
            {
                cout << " ";
            }
        }
        cout << endl;
    }

    return 0;
}
显示结果如下
**********
*        *
*        *
*        *
*        *
*        *
**********

**********
*        *
*        *
*        *
*        *
*        *
*        *
*        *
*        *
**********

      *
     * *
    *   *
   *     *
  *       *
 *         *
*************

2-6下面的代码是做什么的？
#include <iostream>

int main()
{
    int i = 0;

    while (i < 10)
    {
        i += 1;
        std::cout << i << std::endl;
    }

    return 0;
}
显示结果如下
1
2
3
4
5
6
7
8
9
10

2-7 编写一个程序来依次输出从10到-5的整数。
#include <iostream>
using std::cout;
using std::endl;

int main()
{
    int x = 10;

    while (x >= -5)
    {
        cout << x-- << endl;
    }

    return 0;
}
显示结果如下
10
9
8
7
6
5
4
3
2
1
0
-1
-2
-3
-4
-5

2-8 编写一个程序来计算区间[1, 10)中的所有数值的乘积。
#include <iostream>
using std::cout;
using std::endl;

int main()
{
    int product = 1;

    for (int i = product + 1; i < 10; i++)
    {
        product *= i;
    }

    cout << product << endl;

    return 0;
}
显示结果如下
362880

2-9 编写一个程序，让用户输入两个数值并告知用户在这两个数值中哪一个较大。
#include <iostream>
using std::cin;
using std::cout;
using std::endl;

int main()
{
    int num1, num2;

    cout << "Enter the first number: ";
    cin >> num1;
    cout << "Enter the second number: ";
    cin >> num2;
    if (num1 == num2)
    {
        cout << "Both numbers are equal" << endl;
    }
    else if (num1 > num2)
    {
        cout << num1 << " is bigger than " << num2 << endl;
    }
    else
    {
        cout << num2 << " is bigger than " << num1 << endl;
    }

    return 0;
}
显示结果如下
Enter the first number: 13
Enter the second number: 23
23 is bigger than 13

Enter the first number: 5
Enter the second number: 5
Both numbers are equal

Enter the first number: 8
Enter the second number: 3
8 is bigger than 3

2-10 在下面的程序中，对std::的每一次使用进行解释。
#include <iostream>

const int n = 5;

int main()
{
    int k = 0;
    while (k != n)
    {
        using std::cout;   // the using statement is only relevant to the local while scope
        cout << "*";
        ++k;
    }
    std::cout << std::endl;   // std:: is required here
    return 0;
}
显示结果如下
*****

第3章 使用批量数据
3.1 计算学生成绩
3.2 用中值代替平均值
3.3 小结
习题
3-0 编译、运行并测试本章中的程序。
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <iomanip>

using std::cin;
using std::cout;
using std::endl;
using std::streamsize;
using std::string;
using std::vector;
using std::setprecision;
using std::sort;

void StudentGradeAverage()
{
    cout << "Please enter your name: ";
    string name;
    std::getline(cin, name, '\n');
    cout << "Hello, " << name << "!" << endl;

    cout << "Please enter your midterm and final exam grades: ";
    double midterm, final;
    cin >> midterm >> final;

    cout << "Enter all your homework grades, "
         "followed by end-of-file: ";

    int count = 0;
    double sum = 0;

    double x;

    while (cin >> x)
    {
        ++count;
        sum += x;
    }
    cin.clear();
    while (cin.get() != '\n')
    {
        continue;
    }

    streamsize prec = cout.precision();
    cout << "Your final grade is " << setprecision(3)
         << 0.2 * midterm + 0.4 * final + 0.4 * sum / count
         << setprecision(prec) << endl;
}

int StudentGradeMedian()
{
    cout << "Please enter your name: ";
    string name;
    std::getline(cin, name, '\n');
    cout << "Hello, " << name << "!" << endl;

    cout << "Please enter your midterm and final exam grades: ";
    double midterm, final;
    cin >> midterm >> final;

    cout << "Enter all your homework grades, "
         "followed by end-of-file: ";

    double x;
    vector<double> homework;

    while (cin >> x)
    {
        homework.push_back(x);
    }
    cin.clear();
    while (cin.get() != '\n')
    {
        continue;
    }


    typedef vector<double>::size_type vector_size;
    vector_size size = homework.size();

    if (size == 0)
    {
        cout << endl << "You must enter your grades. "
             "Please try again." << endl;
        return 1;
    }

    sort(homework.begin(), homework.end());

    vector_size mid = size / 2;
    double median = size % 2 == 0 ? (homework[mid - 1] + homework[mid]) / 2 : homework[mid];

    double result = 0.2 * midterm + 0.4 * final + 0.4 * median;

    streamsize prec = cout.precision();
    cout << "Your final grade is " << setprecision(3)
         << result << setprecision(prec) << endl;

    return 0;
}

int main()
{
    cout << std::fixed;
    cout << "Grade average:" << endl;
    StudentGradeAverage();
    cout << "Grade median:" << endl;
    return StudentGradeMedian();
}
显示结果如下
Grade average:
Please enter your name: Peter Smith
Hello, Peter Smith!
Please enter your midterm and final exam grades: 3.96 4.23
Enter all your homework grades, followed by end-of-file:
3.98 4.03 4.15 q
Your final grade is 4.105
Grade median:
Please enter your name: Mike Pence
Hello, Mike Pence!
Please enter your midterm and final exam grades: 4.01 4.33
Enter all your homework grades, followed by end-of-file:
3.99 4.05 4.19 q
Your final grade is 4.154

3-2把一个整数集合分为个数相等的四部分，而且第一部分含有的整数值比其他各部分的都大，
第二部分的值比第一部分的小比其他两部分的大，剩下的两部分则以此类推。
按照上面的要求，编写一个程序来计算并且打印这四部分。
#include <iostream>
#include <sstream>
#include <vector>
#include <algorithm>
#include <iterator>

using std::ostream;
using std::cout;
using std::endl;
using std::stringstream;
using std::vector;
using std::sort;
using std::copy;

int quartiles(vector<int> &someInts)
{
    sort(someInts.begin(), someInts.end());

    int quarter = someInts.size() / 4;
    int remainder = someInts.size() % 4;

    if (quarter == 0)
    {
        cout << "Vector is smaller than 4 elements." << endl;
        return 1;
    }

    int start = someInts.size();

    for (int i = 0; i < 4; i++, remainder--)
    {
        stringstream result;
        int quarterSize = remainder > 0 ? quarter + 1 : quarter;
        int stop = start - quarterSize;
        vector<int>::const_iterator first = someInts.begin() + stop;
        vector<int>::const_iterator last = someInts.begin() + start;
        copy(first, last, std::ostream_iterator<int, char>(result, " "));
        cout << "Quarter " << i + 1 << ": " << result.str() << endl;
        start -= quarterSize;
    }

    return 0;
}

int main()
{
    vector<int> someInts = { 10, 12, 5, 8, 13, 25, 1, 121, 85, 99, 120, 180, 75, 205, 16, 22, 99, 16 };

    return quartiles(someInts);
}
显示结果如下
Quarter 1: 99 120 121 180 205
Quarter 2: 22 25 75 85 99
Quarter 3: 12 13 16 16
Quarter 4: 1 5 8 10

3-3 编写一个程序来计算在它的输入中每个不同的单词所出现的次数。
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using std::cout;
using std::cin;
using std::endl;
using std::vector;
using std::string;
using std::sort;

vector<string> GetInput()
{
    string word;
    vector<string> words;

    cout << "Please enter some words:" << endl;

    while (cin >> word)
    {
        words.push_back(word);
    }

    return words;
}


int CountDistinctWord(vector<string> words)
{
    if (words.size() < 2)
    {
        cout << "Please enter atleast 2 words." << endl;
        return 1;
    }

    sort(words.begin(), words.end());

    for (vector<string>::size_type i = 0, counter = 0; i < words.size(); i++)
    {
        counter++;
        if (i + 1 == words.size() || words[i] != words[i + 1])
        {
            cout << words[i] << ": " << counter << endl;
            counter = 0;
        }
    }

    return 0;
}

int main()
{
    return CountDistinctWord(GetInput());
}
显示结果如下
Please enter some words:
Peter Smith Mike Pence Hello World Sun Flower Hello Smith Mike Sun
Flower: 1
Hello: 2
Mike: 2
Pence: 1
Peter: 1
Smith: 2
Sun: 2
World: 1

3-4 编写一个程序来报告它的输入中最长以及最短的字符串的长度。
#include <iostream>
#include <vector>
#include <string>

using std::cout;
using std::cin;
using std::endl;
using std::vector;
using std::string;


vector<string> GetInput()
{
    string word;
    vector<string> words;

    cout << "Please enter some words:" << endl;

    while (cin >> word)
    {
        words.push_back(word);
    }

    return words;
}

int LongestShortestString(const vector<string> &words)
{

    if (words.size() < 1)
    {
        cout << "Please enter atleast 1 words." << endl;
        return 1;
    }

    vector<string>::size_type shortest, longest;
    shortest = longest = words[0].size();

    for (vector<string>::size_type i = 1; i < words.size(); i++)
    {
        if (words[i].size() < shortest)
        {
            shortest = words[i].size();
        }
        if (words[i].size() > longest)
        {
            longest = words[i].size();
        }
    }

    cout << "The shortest word is " << shortest << " characters long." << endl
         << "The longest word is " << longest << " characters long." << endl;

    return 0;
}

int main()
{
    return LongestShortestString(GetInput());
}
显示结果如下
Please enter some words:
Peter Smith Mike Pence Sun Flower Apple Water Egg
The shortest word is 3 characters long.
The longest word is 6 characters long.

3-5 编写一个程序来同时跟踪n个学生的成绩。要求程序能够保持两个向量的同步：
第一个应保存学生的姓名；第二个保存总成绩，而这个总成绩能根据读到的输入来计算。
读者应假定家庭作业成绩的个数是固定的。
#include <iostream>
#include <vector>
#include <string>
#include <iomanip>

using std::cin;
using std::cout;
using std::endl;
using std::streamsize;
using std::vector;
using std::string;
using std::setprecision;

int StudentGradeAverage(double &result, string &name)
{
    cout << "Please enter your name: ";
    std::getline(cin, name, '\n');
    cout << "Hello, " << name << "!" << endl;

    cout << "Please enter your midterm and final exam grades: ";
    double midterm, final;
    cin >> midterm >> final;

    cout << "Enter all your homework grades, "
         "followed by end-of-file: ";

    int count = 0;
    double sum = 0;
    double x;

    while (cin >> x)
    {
        ++count;
        sum += x;
    }
    cin.clear();
    while (cin.get() != '\n')
    {
        continue;
    }

    double homework = count == 0 ? 0 : sum / count;

    result = 0.2 * midterm + 0.4 * final + 0.4 * homework;

    return 0;
}

void OuputGradeAverage(double grade)
{
    streamsize prec = cout.precision();
    cout << "Your final grade is " << setprecision(3)
         << grade << setprecision(prec) << endl;
}

int StudentNamesGrades()
{
    vector<string> names;
    vector<double> grades;
    string answer;
    bool finish;

    do
    {
        string name;
        double grade;
        if (StudentGradeAverage(grade, name))
        {
            return 1;
        }

        names.push_back(name);
        grades.push_back(grade);

        cout << "Enter (y)es if you want to enter more grades and students: ";
        std::getline(cin, answer, '\n');
        if ( answer.size() > 0 && (answer.at(0) == 'y' || answer.at(0) == 'Y') )
        {
            finish = false;
            cout << endl;
        }
        else
        {
            finish = true;
        }
    }
    while (finish == false);

    cout << endl;
    for (vector<string>::size_type i = 0; i < names.size(); i++)
    {
        cout << names[i] << ":" << endl;
        OuputGradeAverage(grades[i]);
    }

    return 0;
}

int main()
{
    return StudentNamesGrades();
}
显示结果如下
Please enter your name: Peter Smith
Hello, Peter Smith!
Please enter your midterm and final exam grades: 3.99 4.18
Enter all your homework grades, followed by end-of-file:
3.96 4.05 4.23 q
Enter (y)es if you want to enter more grades and students: y

Please enter your name: Mike Pence
Hello, Mike Pence!
Please enter your midterm and final exam grades: 3.95 4.15
Enter all your homework grades, followed by end-of-file:
3.92 4.09 4.25 q
Enter (y)es if you want to enter more grades and students: y

Please enter your name: Hello World
Hello, Hello World!
Please enter your midterm and final exam grades: 3.97 4.08
Enter all your homework grades, followed by end-of-file:
3.99 4.03 4.06 q
Enter (y)es if you want to enter more grades and students:

Peter Smith:
Your final grade is 4.1
Mike Pence:
Your final grade is 4.08
Hello World:
Your final grade is 4.04

3-6 The average-grade computation in 3.1 might divide by zero if the student didn't enter any grades.
Division by zero is undefined in C++, which means that the implementation is permitted to do anything it likes.
What does your C++ implementation do in this case? Rewrite the program so that its behavior does not depend on 
how the implementation treats division by zero.

#include <iostream>
#include <string>
#include <iomanip>

using std::cin;
using std::cout;
using std::endl;
using std::streamsize;
using std::string;
using std::setprecision;

void StudentGradeAverageRobust()
{
    cout << "Please enter your name: ";
    string name;
    std::getline(cin, name, '\n');
    cout << "Hello, " << name << "!" << endl;

    cout << "Please enter your midterm and final exam grades: ";
    double midterm, final;
    cin >> midterm >> final;

    cout << "Enter all your homework grades, "
         "followed by end-of-file: ";

    int count = 0;
    double sum = 0;
    double x;

    while (cin >> x)
    {
        ++count;
        sum += x;
    }
    cin.clear();
    while (cin.get() != '\n')
    {
        continue;
    }

    double homework = count == 0 ? 0 : sum / count;

    streamsize prec = cout.precision();
    cout << "Your final grade is " << setprecision(3)
         << 0.2 * midterm + 0.4 * final + 0.4 * homework
         << setprecision(prec) << endl;
}

int main()
{
    cout << std::fixed;
    StudentGradeAverageRobust();

    return 0;
}
显示结果如下
Please enter your name: Peter Smith
Hello, Peter Smith!
Please enter your midterm and final exam grades: 3.99 4.09
Enter all your homework grades, followed by end-of-file:
3.97 4.07 4.18 q
Your final grade is 4.063

第4章 组织程序和数据
4.1 组织计算
4.2 组织数据
4.3 把各部分代码连接到一起
4.4 把计算成绩的程序分块
4.5 修正后的计算成绩的程序
4.6 小结
习题
4-0 编译、运行并测试本章中的程序。
student_info.h
#ifndef STUDENT_INFO_H_
#define STUDENT_INFO_H_

#include <string>
#include <vector>
#include <iostream>

struct Student_info {
  std::string name;
  double midterm, final;
  std::vector<double> homework;
};

bool compare(const Student_info&, const Student_info&);
std::istream& read(std::istream&, Student_info&);
std::istream& read_hw(std::istream&, std::vector<double>&);

#endif

grade.h
#ifndef GRADE_H_
#define GRADE_H_

#include <vector>
#include "student_info.h"

double grade(double, double, double);
double grade(double, double, const std::vector<double>&);
double grade(const Student_info&);

#endif

median.h
#ifndef MEDIAN_H_
#define MEDIAN_H_

#include <vector>

double median(std::vector<double>);

#endif

median.cpp
#include <vector>
#include <algorithm>
#include <stdexcept>
#include "median.h"

using std::vector;
using std::sort;
using std::domain_error;

double median(vector<double> vec)
{
  typedef vector<double>::size_type vec_sz;

  vec_sz size = vec.size();
  if (size == 0)
  {
    throw domain_error("median of empty vector");
  }

  sort(vec.begin(), vec.end());
  vec_sz mid = size / 2;
  
  return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

grade.cpp
#include <vector>
#include <stdexcept>
#include "grade.h"
#include "median.h"
#include "student_info.h"

using std::vector;
using std::domain_error;

double grade(double midterm, double final, double homework)
{
  return 0.2 *midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const std::vector<double>& hw)
{
  if (hw.size() == 0)
  {
    throw domain_error("Student has done no homework");
  }
  return grade(midterm, final, median(hw));
}

double grade(const Student_info& s)
{
  return grade(s.midterm, s.final, s.homework);
}

student_info.cpp
#include <iostream>
#include "student_info.h"
#include "grade.h"

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::vector;

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name < y.name;
}

istream &read(istream &is, Student_info &s)
{
    cout << "Please enter your name: ";
    std::getline(is, s.name, '\n');
    if (is && s.name != "")
    {
        cout << "Please enter your midterm and final exam grades: ";
        is >> s.midterm >> s.final;
        cout << "Enter all your homework grades: ";
        read_hw(is, s.homework);
    }
    return is;
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }
        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

ch04_p00.cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <iomanip>
#include <exception>
#include <stdexcept>

using std::cin;
using std::cout;
using std::streamsize;
using std::endl;
using std::vector;
using std::string;
using std::setprecision;
using std::sort;
using std::max;
using std::domain_error;

#include "student_info.h"
#include "grade.h"

int main()
{
  vector<Student_info> students;
  Student_info record;
  string::size_type maxlen = 0;

  cout << std::fixed << std::left;

  while (read(cin, record) && record.name != "")
  {
    maxlen = max(maxlen, record.name.size());
    students.push_back(record);
    record.homework.clear();
  }

  sort(students.begin(), students.end(), compare);

  for (vector<Student_info>::size_type i = 0; i != students.size(); i++) 
  {
    cout << std::setw(maxlen+1) << students[i].name;

    try 
    {
      double final_grade = grade(students[i]);
      streamsize prec = cout.precision();
      cout << setprecision(3) << final_grade << setprecision(prec);
    }
    catch (domain_error & e) 
    {
      cout << e.what();
    }
    cout << endl;
  }

  return 0;
}
显示结果如下
Please enter your name: Peter Smith
Please enter your midterm and final exam grades: 3.99 4.07
Enter all your homework grades: 3.97 4.13 4.09 q
Please enter your name: Mike Pence
Please enter your midterm and final exam grades: 3.96 4.13
Enter all your homework grades: 3.99 4.06 4.16 q
Please enter your name: Hello World
Please enter your midterm and final exam grades: 3.97 4.10
Enter all your homework grades: q
Please enter your name: Sun Flower
Please enter your midterm and final exam grades: 3.95 4.15
Enter all your homework grades: 4.03 4.08 4.13 q
Please enter your name:
Hello World Student has done no homework
Mike Pence  4.068
Peter Smith 4.062
Sun Flower  4.082

4-1 我们注意到，在84.2.3中，在调用max的时候，必须让参数的类型严格匹配。
下面的代码正确吗？如果有问题的话，那你将怎样改正它呢？
int maxlen;
Student_info s;
max(s.name.size(), maxlen);

修改后
string::size_type maxlen;
Student_info s;
maxlen = max(s.name.size(), maxlen);

4-2 编写一个程序来计算从1-100的整数（int）值的平方。
程序的输出分为两列：第一列是整数值，第二列是整数值的平方。
使用控制器来控制输出，让数值按列排列起来。
#include <iostream>
#include <vector>
#include <stdexcept>
#include <iomanip>
#include <cmath>

using std::ostream;
using std::streamsize;
using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::domain_error;
using std::setw;

vector<int> square(unsigned int range)
{
    vector<int> squares;
    if (range > squares.max_size())
    {
        throw domain_error("Range argument exceeds vector limit.");
    }

    for (unsigned int i = 0; i < range; i++)
    {
        squares.push_back(i * i);
    }

    return squares;
}

unsigned GetNumberOfDigits(unsigned i)
{
    return i > 0 ? (int)log10((double)i) + 1 : 1;
}

ostream &print_squares(ostream &os, const vector<int> &v)
{
    if (os)
    {
        streamsize s_size = os.width();
        for (vector<int>::size_type i = 0; i < v.size(); i++)
        {
            os << setw(3) << i << " " << setw(6) << v[i] << endl;
        }
        os.width(s_size);
    }

    return os;
}

int main()
{
    vector<int> v = square(101);
    print_squares(cout, v);

    return 0;
}

4-3如果我们重写了上题中的程序，让它计算从1到999的整数的平方。
但是，我们忘记了更改setw的参数的值。这样做会有什么问题呢？重写这个程序，让它具有更好的适应性。
重写后的程序应实现这样的目标：当i增长时我们不需要修正setw的参数。
#include <iostream>
#include <vector>
#include <stdexcept>
#include <iomanip>
#include <cmath>

using std::ostream;
using std::streamsize;
using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::domain_error;
using std::setw;

vector<int> square(unsigned int range)
{
    vector<int> squares;
    if (range > squares.max_size())
    {
        throw domain_error("Range argument exceeds vector limit.");
    }

    for (unsigned int i = 0; i < range; i++)
    {
        squares.push_back(i * i);
    }

    return squares;
}

unsigned GetNumberOfDigits(unsigned i)
{
    return i > 0 ? (int)log10((double)i) + 1 : 1;
}

ostream &print_squares_robust(ostream &os, const vector<int> &v)
{
    if (os)
    {
        unsigned digits_i = GetNumberOfDigits(v.size());
        unsigned digits_v = GetNumberOfDigits(v.back());
        streamsize s_size = os.width();
        for (vector<int>::size_type i = 0; i < v.size(); i++)
        {
            os << setw(digits_i + 1) << i << " " << setw(digits_v + 1) << v[i] << endl;
        }
        os.width(s_size);
    }

    return os;
}

int main()
{
    vector<int> v = square(1000);
    print_squares_robust(cout, v);

    return 0;
}

4-4现在，再次修改你的求平方程序，用它来求double类型而不是int类型的值的平方。
使用控制器来控制输出，让数值按列排列起来。
#include <iostream>
#include <vector>
#include <stdexcept>
#include <iomanip>
#include <cmath>

using std::ostream;
using std::streamsize;
using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::domain_error;
using std::setw;

vector<double> square_double(unsigned int range)
{
    vector<double> squares;
    if (range > squares.max_size())
    {
        throw domain_error("Range argument exceeds vector limit.");
    }

    for (unsigned int i = 0; i < range; i++)
    {
        squares.push_back(i * i);
    }

    return squares;
}

double GetNumberOfDigits(double i)
{
    return i > 0 ? log10(i) + 1 : 1;
}

ostream &print_squares(ostream &os, const vector<double> &v)
{
    if (os)
    {
        streamsize digits_i = (streamsize) GetNumberOfDigits(v.size());
        streamsize digits_v = (streamsize) GetNumberOfDigits(v.back());

        streamsize s_size = os.width();
        for (vector<double>::size_type i = 0; i < v.size(); i++)
        {
            os << setw(digits_i + 1) << i << " " << setw(digits_v + 1) << v[i] << endl;
        }
        os.width(s_size);
    }

    return os;
}

int main()
{
    vector<double> v = square_double(500);
    print_squares(cout, v);

    return 0;
}

4-5 编写一个函数来从输入流读单词，把读到的单词存储在一个向量中。
利用这个函数编写一个程序来计算输入的单词的数目以及每一个单词所出现的次数。
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <stdexcept>

using std::istream;
using std::ostream;
using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::string;
using std::sort;
using std::domain_error;

istream &read(istream &is, vector<string> &v)
{
    if (is)
    {
        string s;
        while (is >> s)
        {
            v.push_back(s);
        }
        is.clear();
    }

    return is;
}

unsigned count_distinct(vector<string> words)
{
    if (words.size() < 2)
    {
        return words.size();
    }

    sort(words.begin(), words.end());

    unsigned count = 1;

    for (vector<string>::size_type i = 1; i < words.size(); i++)
    {
        if (words[i] != words[i - 1])
        {
            count++;
        }
    }

    return count;
}

ostream &count_occurence(ostream &os, vector<string> words)
{
    if (words.size() < 2)
    {
        throw domain_error("Vector should have atleast two elements.");
    }

    sort(words.begin(), words.end());

    for (vector<string>::size_type i = 0, counter = 0; i < words.size(); i++)
    {
        counter++;
        if (i + 1 == words.size() || words[i] != words[i + 1])
        {
            os << words[i] << ": " << counter << endl;
            counter = 0;
        }
    }

    return os;
}

int main()
{
    cout << "Please enter some different word: " << endl;
    vector<string> words;
    read(cin, words);
    cout << "Number of distinct words: " << count_distinct(words) << endl;
    count_occurence(cout, words);

    return 0;
}
显示结果如下
Please enter some different word:
Peter Smith Mike Pence Hello World Apple Water Sun Flower
Mike Water Egg Mike Peter
Number of distinct words: 11
Apple: 1
Egg: 1
Flower: 1
Hello: 1
Mike: 3
Pence: 1
Peter: 2
Smith: 1
Sun: 1
Water: 2
World: 1

4-6重写Student_info结构并使用重写后的结构来直接计算成绩，要求在程序中仅仅存储总成绩。
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <iomanip>
#include <stdexcept>

using std::istream;
using std::streamsize;
using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::string;
using std::max;
using std::sort;
using std::setprecision;
using std::domain_error;

struct Student_info_extra
{
    std::string name;
    double grade;
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const std::vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }
        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

bool compare_students(const Student_info_extra &x, const Student_info_extra &y)
{
    return x.name < y.name;
}

istream &read(istream &is, Student_info_extra &s)
{
    double midterm, final;
    vector<double> homework;
    cout << "Please enter your name: ";
    std::getline(is, s.name, '\n');
    if (is && s.name != "")
    {
        cout << "Please enter your midterm and final exam grades: ";
        is >> midterm >> final;
        cout << "Enter all your homework grades: ";
        read_hw(is, homework);
        s.grade = grade(midterm, final, homework);

    }

    return is;
}

int main()
{
    vector<Student_info_extra> students;
    Student_info_extra record;
    string::size_type maxlen = 0;

    cout << std::fixed << std::left;

    try
    {
        while (read(cin, record) && record.name != "")
        {
            maxlen = max(maxlen, record.name.size());
            students.push_back(record);
        }
    }
    catch (domain_error e)
    {
        cout << e.what() << endl;
    }

    sort(students.begin(), students.end(), compare_students);

    for (vector<Student_info_extra>::size_type i = 0; i != students.size(); i++)
    {
        cout << std::setw(maxlen + 1) << students[i].name;
        streamsize prec = cout.precision();
        cout << setprecision(3) << students[i].grade << setprecision(prec);

        cout << endl;
    }

    return 0;
}
显示结果如下
Please enter your name: Peter Smith
Please enter your midterm and final exam grades: 3.99 4.13
Enter all your homework grades: 3.98 4.05 4.19 q
Please enter your name: Mike Pence
Please enter your midterm and final exam grades: 3.97 4.08
Enter all your homework grades: 3.96 4.09 4.21 q
Please enter your name: Hello World
Please enter your midterm and final exam grades: 3.98 4.15
Enter all your homework grades: q
Student has done no homework
Mike Pence  4.062
Peter Smith 4.070

4-7 编写一个程序来计算存储在一个vector<double>类型的向量中的数据的平均值。
#include <iostream>
#include <vector>

using std::vector;
using std::cin;
using std::cout;
using std::endl;

double average(const vector<double> &nums)
{
    double sum = 0;

    for (vector<double>::size_type i = 0; i < nums.size(); i++)
    {
        sum += nums[i];
    }

    return sum / nums.size();
}

int main()
{
    vector<double> numbers = { 10.2, 15.7, 18.5, 9.7, 25.2 };
    cout << average(numbers) << endl;

    return 0;
}
显示结果如下
15.86

4-8如果下面的代码是合法的，那么对于f的返回类型我们能做出什么推断呢？
double d = f()[n];
f的返回类型要支持[]操作符，可以是vector，也可以是指向数组的指针

#include <iostream>
#include <vector>

using std::cin;
using std::cout;
using std::endl;
using std::vector;

vector<double> f()
{
    return { 10.2, 17.5 };
}

int main()
{
    int n = 1;
    cout << f()[n] << endl;

    return 0;
}
显示结果如下
17.5

第5章 使用顺序容器并分析字符串
5.1 按类别来区分学生
5.2 迭代器
5.3 用迭代器来代替索引
5.4 重新思考数据结构以实现更好的性能
5.5 list类型
5.6 分割字符串
5.7 测试split函数
5.8 连接字符串
5.9 小结
习题
5.0编译、运行并测试本章中的程序。
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <functional>

using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::string;
using std::max;
using std::transform;

vector<string> split(const string &s)
{
    vector<string> ret;
    typedef string::size_type string_size;
    string_size i = 0;

    while (i != s.size())
    {
        while (i != s.size() && isspace(s[i]))
        {
            ++i;
        }

        string_size j = i;

        while (j != s.size() && !isspace(s[j]))
        {
            ++j;
        }

        if (i != j)
        {
            ret.push_back(s.substr(i, j - i));
            i = j;
        }
    }
    return ret;
}

string::size_type width(const vector<string> &v)
{
    string::size_type maxlen = 0;

    for (vector<string>::size_type i = 0; i != v.size(); ++i)
    {
        maxlen = max(maxlen, v[i].size());
    }

    return maxlen;
}

vector<string> frame(const vector<string> &v)
{
    vector<string> ret;
    string::size_type maxlen = width(v);
    string border(maxlen + 4, '*');

    ret.push_back(border);

    for (vector<string>::size_type i = 0; i != v.size(); ++i)
    {
        ret.push_back("* " + v[i] + string(maxlen - v[i].size(), ' ')  + " *");
    }

    ret.push_back(border);

    return ret;
}

vector<string> vcat(const vector<string> &top, const vector<string> &bottom)
{
    vector<string> ret = top;

    ret.insert(ret.end(), bottom.begin(), bottom.end());

    return ret;
}

vector<string> hcat(const vector<string> &left, const vector<string> &right)
{
    vector<string> ret;

    string::size_type width1 = width(left) + 1;

    vector<string>::size_type i = 0, j = 0;

    while (i != left.size() || j != right.size())
    {
        string s;

        if (i != left.size())
        {
            s = left[i++];
        }

        s += string(width1 - s.size(), ' ');

        if (j != right.size())
        {
            s += right[j++];
        }

        ret.push_back(s);
    }

    return ret;
}

bool compare_ignore_case(string s1, string s2)
{
    transform(s1.begin(), s1.end(), s1.begin(), ::tolower);
    transform(s2.begin(), s2.end(), s2.begin(), ::tolower);

    return s1 < s2;
}

int test_string_split()
{
    string s;

    cout << "Please enter some words: \n";
    while (std::getline(cin, s, '\n') && s != "")
    {
        vector<string> v = split(s);

        for (vector<string>::size_type i = 0; i != v.size(); ++i)
        {
            cout << v[i] << endl;
        }
        cout << "Please enter some words: \n";
    }

    return 0;
}

int test_input_split()
{
    string s;

    cout << "Please enter some words: \n";
    while (cin >> s && s != "quit")
    {
        cout << s << endl;
    }

    return 0;
}

int test_frame()
{
    vector<string> v1 = { "one test", "two test", "aye caramba" };
    vector<string> v2 = { "one direction", "mama mia", "mamo testo", "lake district mall" };

    vector<string> vert = vcat(frame(v1), frame(v2));

    vector<string>::const_iterator iter = vert.begin();

    while (iter != vert.end())
    {
        cout << *(iter++) << endl;
    }

    vector<string> horz = hcat(frame(v1), frame(v2));

    iter = horz.begin();

    while (iter != horz.end())
    {
        cout << *(iter++) << endl;
    }

    return 0;
}

int main()
{
    test_string_split();
    test_frame();
    test_input_split();
    return 0;
}
显示结果如下
Please enter some words:
Peter Smith Mike Pence Hello World quit
Peter
Smith
Mike
Pence
Hello
World
quit
Please enter some words:

***************
* one test    *
* two test    *
* aye caramba *
***************
**********************
* one direction      *
* mama mia           *
* mamo testo         *
* lake district mall *
**********************
*************** **********************
* one test    * * one direction      *
* two test    * * mama mia           *
* aye caramba * * mamo testo         *
*************** * lake district mall *
                **********************
Please enter some words:
Peter Smith Mike Pence Hello World quit
Peter
Smith
Mike
Pence
Hello
World

5-1 设计和实现一个程序来产生一个置换索引。在一个置换索引中，每一个短语都是以这个短语的每一个单词作为索引的。
因此，假如有如下的输入：
The quick brown fox
jumped over the fence
那么，输出将会是：
          The quick     brown fox
jumped over the     fence
The quick brown     fox
                               jumped over the fence
              jumped     over the fence
              The           quick brown fox
          jumped over  the fence
                              The quick brown fox
在Aho，Kernighan和Weinberger所著的《The AWK Programming Language》
（Addison-Wesley，1988）一书中有一个很好的算法。它分三个步骤来处理这个问题
1，读入输入的每一行并对每一行输入产生一个轮转的集合。每一个轮转都把输入的下一个单词放到第一个位置上，
并把原先的第一个单词旋转到短语的末尾。因此，输入的第一行所表示的短语的输出将会是：
The guick brown fox
quick brown fox The
brown fox The quick
fox The quick brown
当然，重要的是要知道最初的短语是在哪里结束，而轮转的开头又是从哪里开始的。
2，对这些轮转集合排序
3，反向轮转并输出置换索引，其中包含了查找分隔符号、把短语重新连接到一起以及以正确的格式输出短语等操作。
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <functional>

using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::string;
using std::max;
using std::transform;
using std::sort;

vector<string> split(const string &s)
{
    vector<string> ret;
    typedef string::size_type string_size;
    string_size i = 0;

    while (i != s.size())
    {
        while (i != s.size() && isspace(s[i]))
        {
            ++i;
        }

        string_size j = i;

        while (j != s.size() && !isspace(s[j]))
        {
            ++j;
        }

        if (i != j)
        {
            ret.push_back(s.substr(i, j - i));
            i = j;
        }
    }
    return ret;
}

string::size_type width(const vector<string> &v)
{
    string::size_type maxlen = 0;

    for (vector<string>::size_type i = 0; i != v.size(); ++i)
    {
        maxlen = max(maxlen, v[i].size());
    }

    return maxlen;
}

vector<string> frame(const vector<string> &v)
{
    vector<string> ret;
    string::size_type maxlen = width(v);
    string border(maxlen + 4, '*');

    ret.push_back(border);

    for (vector<string>::size_type i = 0; i != v.size(); ++i)
    {
        ret.push_back("* " + v[i] + string(maxlen - v[i].size(), ' ')  + " *");
    }

    ret.push_back(border);

    return ret;
}

vector<string> vcat(const vector<string> &top, const vector<string> &bottom)
{
    vector<string> ret = top;

    ret.insert(ret.end(), bottom.begin(), bottom.end());

    return ret;
}

vector<string> hcat(const vector<string> &left, const vector<string> &right)
{
    vector<string> ret;

    string::size_type width1 = width(left) + 1;

    vector<string>::size_type i = 0, j = 0;

    while (i != left.size() || j != right.size())
    {
        string s;

        if (i != left.size())
        {
            s = left[i++];
        }

        s += string(width1 - s.size(), ' ');

        if (j != right.size())
        {
            s += right[j++];
        }

        ret.push_back(s);
    }

    return ret;
}

bool compare_ignore_case(string s1, string s2)
{
    transform(s1.begin(), s1.end(), s1.begin(), ::tolower);
    transform(s2.begin(), s2.end(), s2.begin(), ::tolower);

    return s1 < s2;
}

vector<string> rotate(const string &s)
{
    vector<string> ret;
    typedef string::size_type string_size;
    string_size i = 0;

    while (i != s.size())
    {
        while (i != s.size() && isspace(s[i]))
        {
            ++i;
        }

        string_size j = i;

        while (j != s.size() && !isspace(s[j]))
        {
            ++j;
        }

        if (i != j)
        {
            string line = s.substr(i, s.size() - i);
            line += '\t';
            if (i > 0)
            {
                line += s.substr(0, i);
            }
            ret.push_back(line);
            i = j;
        }
    }
    return ret;
}

void unrotate(vector<string> &v)
{
    vector<string> v1, v2;
    vector<string>::iterator iter = v.begin();

    typedef string::size_type s_size;

    while (iter != v.end())
    {
        s_size seperator = iter->find('\t');
        if(seperator >= iter->size() - 1)
        {
            v1.push_back(string(2, ' '));
        }
        else
        {
            v1.push_back( iter->substr( seperator + 1, iter->size() - 1 - seperator ) );
        }
        v2.push_back( iter->substr(0, seperator) );
        ++iter;
    }

    iter = v.begin();
    vector<string>::iterator iter_v1 = v1.begin();
    vector<string>::iterator iter_v2 = v2.begin();
    s_size maxlen = width(v1);

    while (iter != v.end())
    {
        *iter = string(maxlen - iter_v1->size(), ' ') + *iter_v1 + '\t' + *iter_v2;
        ++iter;
        ++iter_v1;
        ++iter_v2;
    }
}

vector<string> permuted_index(const vector<string> &v)
{
    vector<string>::const_iterator iter = v.begin();
    vector<string> permuted_v;

    while (iter != v.end())
    {
        vector<string> rotated_v = rotate(*iter++);
        permuted_v.insert(permuted_v.end(), rotated_v.begin(), rotated_v.end());
    }

    sort(permuted_v.begin(), permuted_v.end(), compare_ignore_case);

    unrotate(permuted_v);

    return permuted_v;
}

int main()
{
    vector<string> v = { "The quick brown fox", "jumped over the fence" };
    vector<string> permuted_v = permuted_index(v);

    vector<string>::const_iterator iter = permuted_v.begin();

    while (iter != permuted_v.end())
    {
        cout << *iter++ << endl;
    }

    return 0;
}
显示结果如下
      The quick         brown fox
jumped over the         fence
The quick brown         fox
                        jumped over the fence
         jumped         over the fence
            The         quick brown fox
    jumped over         the fence
                        The quick brown fox

rotate之后
The quick brown fox \t   8
quick brown fox \t The   6
brown fox \t The quick    1
fox \t The quick brown   3
jumped over the fence \t 4
over the fence \t jumped 5
the fence \t jumped over 7
fence \t jumped over the   2

sort之后
brown fox \t The quick    1
fence \t jumped over the   2
fox \t The quick brown   3
jumped over the fence \t 4
over the fence \t jumped 5
quick brown fox \t The   6
the fence \t jumped over 7
The quick brown fox \t   8

unrotate之后
          The quick     brown fox
jumped over the     fence
The quick brown     fox
                               jumped over the fence
              jumped     over the fence
              The           quick brown fox
          jumped over  the fence
                              The quick brown fox
5-2 编写一个新的程序来计算学生的成绩，要求使用向量来抽取不及格学生的记录。
然后再编写这个程序的另外一个版本，要求在这个版本中使用list，
对于10行、100行和10000行的输入文件分别比较一下两个程序在性能上的差异。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <string>
#include <chrono>
#include <algorithm>
#include <stdexcept>

using std::cin;
using std::cout;
using std::endl;
using std::ifstream;
using std::istream;
using std::stringstream;
using std::vector;
using std::list;
using std::string;
using std::chrono::steady_clock;
using std::sort;
using std::domain_error;

struct Student_info
{
    std::string name;
    double grade;
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const std::vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

double grade(const Student_info &s)
{
    return s.grade;
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name < y.name;
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

istream &read(istream &is, Student_info &s)
{
    double midterm, final;
    vector<double> homework;

    is >> s.name >> midterm >> final;
    read_hw(is, homework);

    if (is)
    {
        s.grade = grade(midterm, final, homework);
    }

    return is;
}

istream &read(istream &is, vector<Student_info> &v)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student;
        read(ss, student);
        v.push_back(student);
    }

    return is;
}

istream &read(istream &is, list<Student_info> &l)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student;
        read(ss, student);
        l.push_back(student);
    }

    return is;
}

bool fgrade(const Student_info &s)
{
    return grade(s) < 60;
}

vector<Student_info> extract_fails(vector<Student_info> &students)
{
    vector<Student_info> fail;
    vector<Student_info>::iterator iter = students.begin();

    while (iter != students.end())
    {
        if (fgrade(*iter))
        {
            fail.push_back(*iter);
            iter = students.erase(iter);
        }
        else
        {
            ++iter;
        }
    }
    return fail;
}

list<Student_info> extract_fails(list<Student_info> &students)
{
    list<Student_info> fail;
    list<Student_info>::iterator iter = students.begin();

    while (iter != students.end())
    {
        if (fgrade(*iter))
        {
            fail.push_back(*iter);
            iter = students.erase(iter);
        }
        else
        {
            ++iter;
        }
    }
    return fail;
}

vector<Student_info> test_student_info(string file, vector<Student_info> &s)
{
    ifstream infile;
    vector<Student_info> failed;

    infile.open(file);
    steady_clock::time_point begin = std::chrono::steady_clock::now();
    read(infile, s);
    steady_clock::time_point end = std::chrono::steady_clock::now();
    cout << "Microseconds to read " << file << " into vector = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;
    infile.close();
    infile.clear();

    begin = std::chrono::steady_clock::now();
    failed = extract_fails(s);
    end = std::chrono::steady_clock::now();
    cout << "Microseconds to extract failed from " << file << " student vector = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;

    return failed;
}

list<Student_info> test_student_info(string file, list<Student_info> &s)
{
    ifstream infile;
    list<Student_info> failed;

    infile.open(file);
    steady_clock::time_point begin = std::chrono::steady_clock::now();
    read(infile, s);
    steady_clock::time_point end = std::chrono::steady_clock::now();
    cout << "Microseconds to read " << file << " into list = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;
    infile.close();
    infile.clear();

    begin = std::chrono::steady_clock::now();
    failed = extract_fails(s);
    end = std::chrono::steady_clock::now();
    cout << "Microseconds to extract failed from " << file << " student list = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;

    return failed;
}

void test_student_info(string amount)
{
    string file = "students" + amount + ".txt";
    ifstream infile;

    vector<Student_info> students_v;
    list<Student_info> students_l;

    test_student_info(file, students_v);
    test_student_info(file, students_l);
}

int main()
{
    test_student_info("10");
    test_student_info("100");
    test_student_info("1000");
    test_student_info("10000");

    return 0;
}
显示结果如下
Microseconds to read students10.txt into vector = 49
Microseconds to extract failed from students10.txt student vector = 3
Microseconds to read students10.txt into list = 31
Microseconds to extract failed from students10.txt student list = 2
Microseconds to read students100.txt into vector = 364
Microseconds to extract failed from students100.txt student vector = 34
Microseconds to read students100.txt into list = 404
Microseconds to extract failed from students100.txt student list = 10
Microseconds to read students1000.txt into vector = 2711
Microseconds to extract failed from students1000.txt student vector = 2210
Microseconds to read students1000.txt into list = 2930
Microseconds to extract failed from students1000.txt student list = 85
Microseconds to read students10000.txt into vector = 27443
Microseconds to extract failed from students10000.txt student vector = 207476
Microseconds to read students10000.txt into list = 27092
Microseconds to extract failed from students10000.txt student list = 2609

5-3 使用一个typedef，我们就能编写出上面的程序的一个既可以基于向量解决方案又可以基于list解决方案的版本。
编写并测试程序的这个版本
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <string>
#include <chrono>
#include <algorithm>
#include <stdexcept>

using std::cin;
using std::cout;
using std::endl;
using std::ifstream;
using std::istream;
using std::stringstream;
using std::vector;
using std::list;
using std::string;
using std::chrono::steady_clock;
using std::sort;
using std::domain_error;

struct Student_info
{
    std::string name;
    double grade;
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const std::vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

double grade(const Student_info &s)
{
    return s.grade;
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name < y.name;
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

istream &read(istream &is, Student_info &s)
{
    double midterm, final;
    vector<double> homework;

    is >> s.name >> midterm >> final;
    read_hw(is, homework);

    if (is)
    {
        s.grade = grade(midterm, final, homework);
    }

    return is;
}

istream &read(istream &is, vector<Student_info> &v)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student;
        read(ss, student);
        v.push_back(student);
    }

    return is;
}

istream &read(istream &is, list<Student_info> &l)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student;
        read(ss, student);
        l.push_back(student);
    }

    return is;
}

bool fgrade(const Student_info &s)
{
    return grade(s) < 60;
}

typedef list<Student_info> students_t;

students_t extract_fails(students_t &students)
{
    students_t fail;
    students_t::iterator iter = students.begin();

    while (iter != students.end())
    {
        if (fgrade(*iter))
        {
            fail.push_back(*iter);
            iter = students.erase(iter);
        }
        else
        {
            ++iter;
        }
    }
    return fail;
}

void test_student_info(string file, students_t &s)
{
    ifstream infile;
    students_t failed;

    infile.open(file);
    steady_clock::time_point begin = std::chrono::steady_clock::now();
    read(infile, s);
    steady_clock::time_point end = std::chrono::steady_clock::now();
    cout << "Microseconds to read " << file << " into students_t s = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;
    infile.close();
    infile.clear();

    begin = std::chrono::steady_clock::now();
    failed = extract_fails(s);
    end = std::chrono::steady_clock::now();
    cout << "Microseconds to extract failed from " << file << " students_t s = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;
}

void test_student_info(string amount)
{
    string file = "students" + amount + ".txt";
    ifstream infile;

    students_t students;

    test_student_info(file, students);
}

int main()
{
    test_student_info("10");
    test_student_info("100");
    test_student_info("1000");
    test_student_info("10000");

    return 0;
}
显示结果如下
Microseconds to read students10.txt into students_t s = 65
Microseconds to extract failed from students10.txt students_t s = 3
Microseconds to read students100.txt into students_t s = 410
Microseconds to extract failed from students100.txt students_t s = 13
Microseconds to read students1000.txt into students_t s = 3159
Microseconds to extract failed from students1000.txt students_t s = 111
Microseconds to read students10000.txt into students_t s = 34146
Microseconds to extract failed from students10000.txt students_t s = 1129

5-4 回顾一下在前面的练习中你所编写的程序，值得注意的是，我们完全可以编写出一个这样的程序；
对于list和向量，这个程序仅仅在用来保存输入文件的数据结构的类型声明上有所不同。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <string>
#include <chrono>
#include <algorithm>
#include <stdexcept>

using std::cin;
using std::cout;
using std::endl;
using std::ifstream;
using std::istream;
using std::stringstream;
using std::vector;
using std::list;
using std::string;
using std::chrono::steady_clock;
using std::sort;
using std::domain_error;

struct Student_info
{
    std::string name;
    double grade;
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const std::vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

double grade(const Student_info &s)
{
    return s.grade;
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name < y.name;
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

istream &read(istream &is, Student_info &s)
{
    double midterm, final;
    vector<double> homework;

    is >> s.name >> midterm >> final;
    read_hw(is, homework);

    if (is)
    {
        s.grade = grade(midterm, final, homework);
    }

    return is;
}

istream &read(istream &is, vector<Student_info> &v)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student;
        read(ss, student);
        v.push_back(student);
    }

    return is;
}

istream &read(istream &is, list<Student_info> &l)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student;
        read(ss, student);
        l.push_back(student);
    }

    return is;
}

bool fgrade(const Student_info &s)
{
    return grade(s) < 60;
}

typedef vector<Student_info> students_t;

students_t extract_fails(students_t &students)
{
    students_t fail;
    students_t::iterator iter = students.begin();

    while (iter != students.end())
    {
        if (fgrade(*iter))
        {
            fail.push_back(*iter);
            iter = students.erase(iter);
        }
        else
        {
            ++iter;
        }
    }
    return fail;
}

void test_student_info(string file, students_t &s)
{
    ifstream infile;
    students_t failed;

    infile.open(file);
    steady_clock::time_point begin = std::chrono::steady_clock::now();
    read(infile, s);
    steady_clock::time_point end = std::chrono::steady_clock::now();
    cout << "Microseconds to read " << file << " into students_t s = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;
    infile.close();
    infile.clear();

    begin = std::chrono::steady_clock::now();
    failed = extract_fails(s);
    end = std::chrono::steady_clock::now();
    cout << "Microseconds to extract failed from " << file << " students_t s = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;
}

void test_student_info(string amount)
{
    string file = "students" + amount + ".txt";

    students_t students;

    test_student_info(file, students);
}

int main()
{
    test_student_info("10");
    test_student_info("100");
    test_student_info("1000");
    test_student_info("10000");

    return 0;
}
显示结果如下
Microseconds to read students10.txt into students_t s = 65
Microseconds to extract failed from students10.txt students_t s = 4
Microseconds to read students100.txt into students_t s = 538
Microseconds to extract failed from students100.txt students_t s = 34
Microseconds to read students1000.txt into students_t s = 3157
Microseconds to extract failed from students1000.txt students_t s = 2171
Microseconds to read students10000.txt into students_t s = 29786
Microseconds to extract failed from students10000.txt students_t s = 215950

5-5 编写一个名为center（const vector<string>&）的函数。这个函数返回一幅图案，
在这幅图案中，原始图案的所有行都会被填充满（也就是，每一行都跟原图案中最长的行一样长）。
要求在图案的左侧和右侧尽可能均匀地分布填充料。
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::string;
using std::max;

string::size_type width(const vector<string> &v)
{
    string::size_type maxlen = 0;

    for (vector<string>::size_type i = 0; i != v.size(); ++i)
    {
        maxlen = max(maxlen, v[i].size());
    }

    return maxlen;
}

vector<string> center(const vector<string> &v)
{
    vector<string> v_out;
    vector<string>::size_type maxlen = width(v);
    vector<string>::const_iterator iter = v.begin();

    while (iter != v.end())
    {
        int spaces_l = (maxlen - iter->size()) / 2;
        int spaces_r = maxlen - iter->size() - spaces_l;
        v_out.push_back(string(spaces_l, '*') + *iter++ + string(spaces_r, '*'));
    }

    return v_out;
}

int main()
{
    vector<string> v = { "This is really great", "really", "super awesome", "awesomesauce" };
    vector<string> centered_v = center(v);

    vector<string>::const_iterator iter = centered_v.begin();

    while (iter != centered_v.end())
    {
        cout << *iter++ << endl;
    }

    return 0;
}
显示结果如下
This is really great
*******really*******
***super awesome****
****awesomesauce****

5-6在5.1.1中的extract_fails函数删除了输入向量v的所有不及格的学生记录，
重写这个函数，让它不用删除v的不及格记录而直接地把及格的学生记录复制到v的开头，
然后使用resize函数来从v的尾部删除多余的元素。和5.1.1的中那个函数相比，这个版本的性能是怎样的呢？
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <string>
#include <chrono>
#include <algorithm>
#include <stdexcept>

using std::cin;
using std::cout;
using std::endl;
using std::ifstream;
using std::istream;
using std::stringstream;
using std::vector;
using std::list;
using std::string;
using std::chrono::steady_clock;
using std::sort;
using std::domain_error;

struct Student_info
{
    std::string name;
    double grade;
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const std::vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

double grade(const Student_info &s)
{
    return s.grade;
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name < y.name;
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

istream &read(istream &is, Student_info &s)
{
    double midterm, final;
    vector<double> homework;

    is >> s.name >> midterm >> final;
    read_hw(is, homework);

    if (is)
    {
        s.grade = grade(midterm, final, homework);
    }

    return is;
}

istream &read(istream &is, vector<Student_info> &v)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student;
        read(ss, student);
        v.push_back(student);
    }

    return is;
}

istream &read(istream &is, list<Student_info> &l)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student;
        read(ss, student);
        l.push_back(student);
    }

    return is;
}

bool fgrade(const Student_info &s)
{
    return grade(s) < 60;
}

typedef vector<Student_info> students_t;

students_t extract_fails(students_t &students)
{
    students_t fail;
  students_t::size_type s_size = students.size();
  students_t::size_type counter = 0;

  for (students_t::size_type i = 0; i < s_size; i++)
  {
    if (fgrade(students[i])) 
    {
      fail.push_back(students[i]);
    }
    else
    {
      students[counter++] = students[i];
    }
  }

  students.resize(counter);

    return fail;
}

void test_student_info(string file, students_t &s)
{
    ifstream infile;
    students_t failed;

    infile.open(file);
    steady_clock::time_point begin = std::chrono::steady_clock::now();
    read(infile, s);
    steady_clock::time_point end = std::chrono::steady_clock::now();
    cout << "Microseconds to read " << file << " into students_t s = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;
    infile.close();
    infile.clear();

    begin = std::chrono::steady_clock::now();
    failed = extract_fails(s);
    end = std::chrono::steady_clock::now();
    cout << "Microseconds to extract failed from " << file << " students_t s = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;
}

void test_student_info(string amount)
{
    string file = "students" + amount + ".txt";

    students_t students;

    test_student_info(file, students);
}

int main()
{
    test_student_info("10");
    test_student_info("100");
    test_student_info("1000");
    test_student_info("10000");

    return 0;
}
显示结果如下
Microseconds to read students10.txt into students_t s = 53
Microseconds to extract failed from students10.txt students_t s = 3
Microseconds to read students100.txt into students_t s = 509
Microseconds to extract failed from students100.txt students_t s = 9
Microseconds to read students1000.txt into students_t s = 4947
Microseconds to extract failed from students1000.txt students_t s = 71
Microseconds to read students10000.txt into students_t s = 44202
Microseconds to extract failed from students10000.txt students_t s = 891

5-7 假定我们有5.8.1中的frame函数，而且我们编写了下面的代码片段
vector<string> v;
frame(v);
描述一下在这个调用中出现的情况。特别地，跟踪一下width和frame函数的操作。
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::string;
using std::max;


string::size_type width(const vector<string> &v)
{
    string::size_type maxlen = 0;

    for (vector<string>::size_type i = 0; i != v.size(); ++i)
    {
        maxlen = max(maxlen, v[i].size());
    }

    return maxlen;
}

vector<string> frame(const vector<string> &v)
{
    vector<string> ret;
    string::size_type maxlen = width(v);
    string border(maxlen + 4, '*');

    ret.push_back(border);

    for (vector<string>::size_type i = 0; i != v.size(); ++i)
    {
        ret.push_back("* " + v[i] + string(maxlen - v[i].size(), ' ')  + " *");
    }

    ret.push_back(border);

    return ret;
}

int test_frame()
{
    vector<string> v;
    vector<string> v_framed = frame(v);

    vector<string>::const_iterator iter = v_framed.begin();

    while (iter != v_framed.end())
    {
        cout << *iter++ << endl;
    }

    return 0;
}

int main()
{
    test_frame();

    return 0;
}
显示结果如下
****
****

5-8 在5.8.3的hcat函数中，如果我们在while的作用域之外定义s的话，那会怎样呢？
重写并运行这个程序以证实你的推测。
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::string;
using std::max;

string::size_type width(const vector<string> &v)
{
    string::size_type maxlen = 0;

    for (vector<string>::size_type i = 0; i != v.size(); ++i)
    {
        maxlen = max(maxlen, v[i].size());
    }

    return maxlen;
}

vector<string> frame(const vector<string> &v)
{
    vector<string> ret;
    string::size_type maxlen = width(v);
    string border(maxlen + 4, '*');

    ret.push_back(border);

    for (vector<string>::size_type i = 0; i != v.size(); ++i)
    {
        ret.push_back("* " + v[i] + string(maxlen - v[i].size(), ' ')  + " *");
    }

    ret.push_back(border);

    return ret;
}

vector<string> hcat(const vector<string> &left, const vector<string> &right)
{
    vector<string> ret;

    string::size_type width1 = width(left) + 1;

    vector<string>::size_type i = 0, j = 0;

    while (i != left.size() || j != right.size())
    {
        string s;

        if (i != left.size())
        {
            s = left[i++];
        }

        s += string(width1 - s.size(), ' ');

        if (j != right.size())
        {
            s += right[j++];
        }

        ret.push_back(s);
    }

    return ret;
}

vector<string> hcat_alternative(const vector<string> &left, const vector<string> &right)
{
    vector<string> ret;

    string::size_type width1 = width(left) + 1;

    vector<string>::size_type i = 0, j = 0;

    string s;
    while (i != left.size() || j != right.size())
    {
        if (i != left.size())
        {
            s = left[i++];
        }

        s += string(width1 - s.size(), ' ');

        if (j != right.size())
        {
            s += right[j++];
        }

        ret.push_back(s);
    }

    return ret;
}

int test_frame()
{
    vector<string> v1 = { "one test", "two test", "aye caramba" };
    vector<string> v2 = { "one direction", "mama mia", "mamo testo", "lake district mall" };

    vector<string> vert = hcat(frame(v1), frame(v2));

    vector<string>::const_iterator iter = vert.begin();

    while (iter != vert.end())
    {
        cout << *(iter++) << endl;
    }

   cout << endl;

    vector<string> horz = hcat_alternative(frame(v1), frame(v2));

    iter = horz.begin();

    while (iter != horz.end())
    {
        cout << *(iter++) << endl;
    }

    return 0;
}

int main()
{
    test_frame();

    return 0;
}
显示结果如下
*************** **********************
* one test    * * one direction      *
* two test    * * mama mia           *
* aye caramba * * mamo testo         *
*************** * lake district mall *
                **********************

terminate called after throwing an instance of 'std::length_error'
  what():  basic_string::_M_create
Aborted (core dumped)

修改hcat_alternative，在while循环的开始部分增加        s = "";
vector<string> hcat_alternative(const vector<string> &left, const vector<string> &right)
{
    vector<string> ret;

    string::size_type width1 = width(left) + 1;

    vector<string>::size_type i = 0, j = 0;

    string s;
    while (i != left.size() || j != right.size())
    {
        s = "";
        if (i != left.size())
        {
            s = left[i++];
        }

        s += string(width1 - s.size(), ' ');

        if (j != right.size())
        {
            s += right[j++];
        }

        ret.push_back(s);
    }

    return ret;
}
显示结果如下
*************** **********************
* one test    * * one direction      *
* two test    * * mama mia           *
* aye caramba * * mamo testo         *
*************** * lake district mall *
                **********************

*************** **********************
* one test    * * one direction      *
* two test    * * mama mia           *
* aye caramba * * mamo testo         *
*************** * lake district mall *
                **********************

5-9编写一个程序来输出在输入中的单词，输出的格式是：先输出全部的小写单词，然后再输出大写单词。
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <functional>

using std::cin;
using std::cout;
using std::endl;
using std::ostream;
using std::vector;
using std::string;
using std::sort;
using std::greater;

ostream &write_lower_upper(ostream &os, const vector<string> &v)
{
    vector<string> v_copy = v;
    sort(v_copy.begin(), v_copy.end(), greater<string>());

    for (vector<string>::size_type i = 0; i < v_copy.size(); i++)
    {
        os << v_copy[i] << endl;
    }

    return os;
}

int main()
{
    vector<string> words = { "TEST", "test", "mountain", "BIKE", "six", "seven", "EIGHT", "NINE", "ten" };
    write_lower_upper(cout, words);

    return 0;
}
显示结果如下
test
ten
six
seven
mountain
TEST
NINE
EIGHT
BIKE

5-10回文是指一种顺读和倒读都一样的单词。编写一个程序，让它找出一个单词集中的所有回文并且找出最长的回文。
#include <iostream>
#include <vector>
#include <string>

using std::cin;
using std::cout;
using std::endl;
using std::ostream;
using std::vector;
using std::string;


bool is_palindrome(const string &s)
{
    string::const_iterator iter = s.begin();
    string::const_reverse_iterator r_iter = s.rbegin();

    while (iter != r_iter.base() && iter + 1 != r_iter.base())
    {
        if (tolower(*iter++) != tolower(*r_iter++))
        {
            return false;
        }
    }

    return true;
}

vector<string> get_palindromes(const vector<string> &v)
{
    vector<string> p;
    vector<string>::const_iterator iter = v.begin();

    while (iter != v.end())
    {
        if (is_palindrome(*iter))
        {
            p.push_back(*iter);
        }
        ++iter;
    }

    return p;
}

ostream &write_palindromes(ostream &os, const vector<string> &v)
{
    vector<string> palindromes = get_palindromes(v);

    for (vector<string>::size_type i = 0; i < palindromes.size(); i++)
    {
        os << palindromes[i] << endl;
    }

    return os;
}

int main()
{
    vector<string> words = { "TEST", "teet", "racecar", "BIKE", "six", "madam", "EIGHT", "reDder", "ten" };
    write_palindromes(cout, words);

    return 0;
}
显示结果如下
teet
racecar
madam
reDder

5-11 在文本处理工作中，有时候，了解一下一个单词中是否有上行字母或下行字母是很有必要的。
上行字母是向上超出了文本行的小写字母；在英文字母表中，字母b，d、f，h、k、l以及t都是上行字母。
同样地，下行字母是向下超出了文本行的小写字母；在英文字母表中，字母g、j，p、q和y都是下行字母。
编写一个程序来判断在一个单词中是否包含有上行字母或下行字母。
扩充这个程序，用它来找出既没有上行字母也没有下行字母的单词集中的最长的单词。
#include <iostream>
#include <vector>
#include <list>
#include <string>

using std::cin;
using std::cout;
using std::endl;
using std::ostream;
using std::vector;
using std::list;
using std::string;

bool has_asc_desc(const string &s)
{
    string::const_iterator iter = s.begin();
    string asc_desc = "bdfhkltgjpqy";

    while (iter != s.end())
    {
        std::size_t found = asc_desc.find(tolower(*iter++));
        if (found != std::string::npos)
        {
            return true;
        }
    }

    return false;
}

list<string> extract_asc_desc(list<string> &l)
{
    list<string> l_ad;
    list<string>::const_iterator iter = l.begin();

    while (iter != l.end())
    {
        if (has_asc_desc(*iter))
        {
            l_ad.push_back(*iter);
            iter = l.erase(iter);
        }
        else
        {
            ++iter;
        }
    }
    return l_ad;
}

string longest_not_asc_desc(list<string> l)
{
    extract_asc_desc(l);
    string longest;

    for (list<string>::const_iterator iter = l.begin(); iter != l.end(); iter++)
    {
        if (iter->length() > longest.length())
        {
            longest = *iter;
        }
    }

    return longest;
}

int main()
{
    list<string> words = { "TEST", "teet", "racecar", "BIKE", "six", "madam", "EIGHT", "reDder", "ten", "multilangual" };
    cout << longest_not_asc_desc(words) << endl;

    return 0;
}
显示结果如下
racecar

第6章 使用库算法
6.1 分析字符串
6.2 对计算成绩的方案进行比较
6.3 对学生进行分类并回顾一下我们的问题
6.4 算法、容器以及迭代器
6.5 小结
习题
6-0编译、运行并测试本章中的程序。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ifstream;
using std::ostream;
using std::stringstream;
using std::vector;
using std::string;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::remove_if;
using std::remove_copy_if;
using std::remove_copy;
using std::stable_partition;
using std::sort;
using std::accumulate;
using std::find;

struct Student_info
{
    std::string name;
    std::vector<double> homework;
    double midterm;
    double final;
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double average(const vector<double> &v)
{
    return accumulate(v.begin(), v.end(), 0.0) / v.size();
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const std::vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

double grade(const Student_info &s)
{
    return grade(s.midterm, s.final, s.homework);
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name < y.name;
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

istream &read(istream &is, Student_info &s)
{
    is >> s.name >> s.midterm >> s.final;
    read_hw(is, s.homework);

    return is;
}

istream &read(istream &is, vector<Student_info> &v)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student;
        read(ss, student);
        v.push_back(student);
    }

    return is;
}

bool did_all_hw(const Student_info &s)
{
    return ( find(s.homework.begin(), s.homework.end(), 0) == s.homework.end() );
}

bool fgrade(const Student_info &s)
{
    return grade(s) < 60;
}

bool pgrade(const Student_info &s)
{
    return !fgrade(s);
}

double grade_aux(const Student_info &s)
{
    try
    {
        return grade(s);
    }
    catch (domain_error)
    {
        return grade(s.midterm, s.final, 0);
    }
}

double median_analysis(const vector<Student_info> &students)
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), grade_aux);
    return median(grades);
}

double average_grade(const Student_info &s)
{
    return grade(s.midterm, s.final, average(s.homework));
}

double average_analysis(const vector<Student_info> &students)
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), average_grade);
    return median(grades);
}

double optimistic_median(const Student_info &s)
{
    vector<double> nonzero;

    remove_copy(s.homework.begin(), s.homework.end(), back_inserter(nonzero), 0);

    if (nonzero.empty())
    {
        return grade(s.midterm, s.final, 0);
    }
    else
    {
        return grade(s.midterm, s.final, median(nonzero));
    }
}

void write_analysis(ostream &out, const string &name, double analysis(const vector<Student_info> &),
                    const vector<Student_info> &did, const vector<Student_info> &didnt)
{
    out << name << ": median(did) = " << analysis(did) << ", median(didnt) = " << analysis(didnt) << endl;
}

vector<Student_info> extract_fails(vector<Student_info> &students)
{
    vector<Student_info> fail;
    remove_copy_if(students.begin(), students.end(), back_inserter(fail), pgrade);
    students.erase(remove_if(students.begin(), students.end(), fgrade), students.end());

    return fail;
}

int main()
{
    vector<Student_info> did, didnt;
    vector<Student_info> all, failed;
    Student_info student;

    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read(infile, all);
    infile.close();
    infile.clear();

    for (vector<Student_info>::const_iterator iter = all.begin(); iter != all.end(); iter++)
    {
        if (did_all_hw(*iter))
        {
            cout << "did.push_back() ";
            did.push_back(*iter);
        }
        else
        {
            cout << "didnt.push_back() ";
            didnt.push_back(*iter);
        }
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;

    if (did.empty())
    {
        cout << "No student did all the homework!" << endl;
        return 1;
    }

    if (didnt.empty())
    {
        cout << "Every student did all the homework!" << endl;
        return 1;
    }

    write_analysis(cout, "median", median_analysis, did, didnt);
    write_analysis(cout, "average", average_analysis, did, didnt);

    failed = extract_fails(all);
    for (vector<Student_info>::const_iterator iter = all.begin(); iter != all.end(); iter++)
    {
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;

    for (vector<Student_info>::const_iterator iter = failed.begin(); iter != failed.end(); iter++)
    {
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;

    return 0;
}
显示结果如下
did.push_back() Geert: 50, 80, 4
didnt.push_back() Pieter: 40, 50, 5
did.push_back() Lotte: 40, 80, 4
didnt.push_back() Jan: 30, 20, 5
did.push_back() Joris: 80, 90, 5
did.push_back() Geert: 50, 80, 4
didnt.push_back() Pieter: 40, 50, 5
did.push_back() Lotte: 40, 80, 4
didnt.push_back() Jan: 30, 20, 5
did.push_back() Joris: 80, 90, 5

median: median(did) = 67, median(didnt) = 37
average: median(did) = 66.5, median(didnt) = 35.4
Geert: 50, 80, 4
Lotte: 40, 80, 4
Joris: 80, 90, 5
Geert: 50, 80, 4
Lotte: 40, 80, 4
Joris: 80, 90, 5

Pieter: 40, 50, 5
Jan: 30, 20, 5
Pieter: 40, 50, 5
Jan: 30, 20, 5

6-1使用迭代器来重新实现5.8.1和5.8.3中的frame以及hcat操作。
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::string;
using std::max;

string::size_type width(const vector<string> &v)
{
    string::size_type maxlen = 0;
    typedef vector<string>::const_iterator iter;
    iter it = v.begin();

    while (it != v.end())
    {
        maxlen = max(maxlen, it->size());
        it++;
    }

    return maxlen;
}

vector<string> frame(const vector<string> &v)
{
    vector<string> ret;
    string::size_type maxlen = width(v);
    string border(maxlen + 4, '*');

    ret.push_back(border);

    vector<string>::const_iterator iter = v.begin();
    while (iter != v.end())
    {
        ret.push_back("* " + *iter + string(maxlen - iter->size(), ' ') + " *");
        iter++;
    }

    ret.push_back(border);

    return ret;
}

vector<string> vcat(const vector<string> &top, const vector<string> &bottom)
{
    vector<string> ret = top;

    ret.insert(ret.end(), bottom.begin(), bottom.end());

    return ret;
}

vector<string> hcat(const vector<string> &left, const vector<string> &right)
{
    vector<string> ret;

    string::size_type width1 = width(left) + 1;

    typedef vector<string>::const_iterator iter;
    iter iter_l = left.begin();
    iter iter_r = right.begin();
    while (iter_l != left.end() || iter_r != right.end())
    {
        string s;

        if (iter_l != left.end())
        {
            s = *iter_l++;
        }

        s += string(width1 - s.size(), ' ');

        if (iter_r != right.end())
        {
            s += *iter_r++;
        }

        ret.push_back(s);
    }

    return ret;
}

int test_frame()
{
    vector<string> v1 = { "one test", "two test", "aye caramba" };
    vector<string> v2 = { "one direction", "mama mia", "mamo testo", "lake district mall" };

    vector<string> vert = vcat(frame(v1), frame(v2));

    vector<string>::const_iterator iter = vert.begin();

    while (iter != vert.end())
    {
        cout << *(iter++) << endl;
    }

    vector<string> horz = hcat(frame(v1), frame(v2));

    iter = horz.begin();

    while (iter != horz.end())
    {
        cout << *(iter++) << endl;
    }

    return 0;
}

int main()
{
    test_frame();
    return 0;
}
显示结果如下
***************
* one test    *
* two test    *
* aye caramba *
***************
**********************
* one direction      *
* mama mia           *
* mamo testo         *
* lake district mall *
**********************
*************** **********************
* one test    * * one direction      *
* two test    * * mama mia           *
* aye caramba * * mamo testo         *
*************** * lake district mall *
                **********************

6-2编写一个程序来测试find_urls函数。
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cctype>

using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::string;
using std::equal;
using std::find;
using std::find_if;
using std::search;

bool space(char c)
{
    return isspace(c) != 0;
}

bool not_space(char c)
{
    return !isspace(c);
}

bool not_url_char(char c)
{
    static const string url_ch = "~;/?:@=&$-_.+!*'(),";

    return !(isalnum(c) || find(url_ch.begin(), url_ch.end(), c) != url_ch.end());
}

bool is_palindrome(const std::string &s)
{
    return equal(s.begin(), s.end(), s.rbegin());
}

vector<string> split(const string &str)
{
    typedef string::const_iterator iter;
    vector<string> ret;

    iter i = str.begin();
    while (i != str.end())
    {
        i = find_if(i, str.end(), not_space);

        iter j = find_if(i, str.end(), space);

        if (i != j)
        {
            ret.push_back(string(i, j));
            i = j;
        }
    }
    return ret;
}


string::const_iterator url_beg(string::const_iterator b, string::const_iterator e)
{
    static const string sep = "://";

    typedef string::const_iterator iter;

    iter i = b;

    while ( ( i = search(i, e, sep.begin(), sep.end()) ) != e )
    {

        if (i != b && i + sep.size() != e)
        {

            iter beg = i;
            while (beg != b && isalpha(beg[-1]))
            {
                --beg;
            }

            if ( beg != i && !not_url_char( i[sep.size()] ) )
            {
                return beg;
            }
        }

        i += sep.size();
    }

    return e;
}

string::const_iterator url_end(string::const_iterator b, string::const_iterator e)
{
    return find_if(b, e, not_url_char);
}

vector<string> find_urls(const string &s)
{
    vector<string> ret;
    typedef string::const_iterator iter;
    iter b = s.begin(), e = s.end();

    while (b != e)
    {
        b = url_beg(b, e);

        if (b != e)
        {
            iter after = url_end(b, e);

            ret.push_back(string(b, after));

            b = after;
        }
    }

    return ret;
}

int main()
{
    string s = "http:// http://test.com toast.com ftp://fttpt :// ://google.be f://l";
    vector<string> v = find_urls(s);
    vector<string>::iterator iter = v.begin();

    while (iter != v.end())
    {
        cout << *iter++ << endl;
    }

    return 0;
}
显示结果如下
http://test.com
ftp://fttpt
f://l

6-3下面的这个程序片段是做什么的？
vector<int> u(10, 100);
vector<int> v;
copy (u.begin(), u.end(), v.begin());
编写一个包含这个片段的程序并编译以及运行这个程序。
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::copy;

int main()
{
    vector<int> u(10, 100);
    copy(u.begin(), u.end(), std::ostream_iterator<int, char>(cout, " "));
    cout << endl;
    vector<int> v;
    copy (u.begin(), u.end(), back_inserter(v));
    copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, ","));
    cout << endl;
    return 0;
}
显示结果如下
100 100 100 100 100 100 100 100 100 100
100,100,100,100,100,100,100,100,100,100,

6-4 改进你在上面的那个练习所编写的从u复制到v的程序。至少存在着改进这个程序的两种可能的方法。实现这两种方法并描述这两种方法之间的优缺点。
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::copy;

int main()
{
    vector<int> u(10, 100);
    copy(u.begin(), u.end(), std::ostream_iterator<int, char>(cout, " "));
    cout << endl;
    vector<int> v(u.size());
    copy(u.begin(), u.end(), v.begin());
    copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, ","));
    cout << endl;
    return 0;
}
显示结果如下
100 100 100 100 100 100 100 100 100 100
100,100,100,100,100,100,100,100,100,100,

6-5 编写一个分析函数来调用optimistic-median。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ifstream;
using std::ostream;
using std::stringstream;
using std::vector;
using std::string;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::remove_if;
using std::remove_copy_if;
using std::remove_copy;
using std::stable_partition;
using std::sort;
using std::accumulate;
using std::find;

struct Student_info
{
    std::string name;
    std::vector<double> homework;
    double midterm;
    double final;
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double average(const vector<double> &v)
{
    return accumulate(v.begin(), v.end(), 0.0) / v.size();
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const std::vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

double grade(const Student_info &s)
{
    return grade(s.midterm, s.final, s.homework);
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name < y.name;
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

istream &read(istream &is, Student_info &s)
{
    is >> s.name >> s.midterm >> s.final;
    read_hw(is, s.homework);

    return is;
}

istream &read(istream &is, vector<Student_info> &v)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student;
        read(ss, student);
        v.push_back(student);
    }

    return is;
}

bool did_all_hw(const Student_info &s)
{
    return ( find(s.homework.begin(), s.homework.end(), 0) == s.homework.end() );
}

bool fgrade(const Student_info &s)
{
    return grade(s) < 60;
}

bool pgrade(const Student_info &s)
{
    return !fgrade(s);
}

double grade_aux(const Student_info &s)
{
    try
    {
        return grade(s);
    }
    catch (domain_error)
    {
        return grade(s.midterm, s.final, 0);
    }
}

double median_analysis(const vector<Student_info> &students)
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), grade_aux);
    return median(grades);
}

double average_grade(const Student_info &s)
{
    return grade(s.midterm, s.final, average(s.homework));
}

double average_analysis(const vector<Student_info> &students)
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), average_grade);
    return median(grades);
}

double optimistic_median(const Student_info &s)
{
    vector<double> nonzero;

    remove_copy(s.homework.begin(), s.homework.end(), back_inserter(nonzero), 0);

    if (nonzero.empty())
    {
        return grade(s.midterm, s.final, 0);
    }
    else
    {
        return grade(s.midterm, s.final, median(nonzero));
    }
}

double optimistic_median_analysis(const vector<Student_info>& students) 
{
  vector<double> grades;
  transform(students.begin(), students.end(), back_inserter(grades), optimistic_median);
  return median(grades);
}

void write_analysis(ostream &out, const string &name, double analysis(const vector<Student_info> &),
                    const vector<Student_info> &did, const vector<Student_info> &didnt)
{
    out << name << ": median(did) = " << analysis(did) << ", median(didnt) = " << analysis(didnt) << endl;
}

vector<Student_info> extract_fails(vector<Student_info> &students)
{
    vector<Student_info> fail;
    remove_copy_if(students.begin(), students.end(), back_inserter(fail), pgrade);
    students.erase(remove_if(students.begin(), students.end(), fgrade), students.end());

    return fail;
}

int main()
{
    vector<Student_info> did, didnt;
    vector<Student_info> all, failed;
    Student_info student;

    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read(infile, all);
    infile.close();
    infile.clear();

    for (vector<Student_info>::const_iterator iter = all.begin(); iter != all.end(); iter++)
    {
        if (did_all_hw(*iter))
        {
            cout << "did.push_back() ";
            did.push_back(*iter);
        }
        else
        {
            cout << "didnt.push_back() ";
            didnt.push_back(*iter);
        }
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;

    if (did.empty())
    {
        cout << "No student did all the homework!" << endl;
        return 1;
    }

    if (didnt.empty())
    {
        cout << "Every student did all the homework!" << endl;
        return 1;
    }

    write_analysis(cout, "median", median_analysis, did, didnt);
    write_analysis(cout, "average", average_analysis, did, didnt);
    write_analysis(cout, "optimistic median", optimistic_median_analysis, did, didnt);

    failed = extract_fails(all);
    for (vector<Student_info>::const_iterator iter = all.begin(); iter != all.end(); iter++)
    {
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;

    for (vector<Student_info>::const_iterator iter = failed.begin(); iter != failed.end(); iter++)
    {
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;

    return 0;
}
显示结果如下
did.push_back() Geert: 50, 80, 4
didnt.push_back() Pieter: 40, 50, 5
did.push_back() Lotte: 40, 80, 4
didnt.push_back() Jan: 30, 20, 5
did.push_back() Joris: 80, 90, 5
did.push_back() Geert: 50, 80, 4
didnt.push_back() Pieter: 40, 50, 5
did.push_back() Lotte: 40, 80, 4
didnt.push_back() Jan: 30, 20, 5
did.push_back() Joris: 80, 90, 5

median: median(did) = 67, median(didnt) = 37
average: median(did) = 66.5, median(didnt) = 35.4
optimistic median: median(did) = 67, median(didnt) = 38
Geert: 50, 80, 4
Lotte: 40, 80, 4
Joris: 80, 90, 5
Geert: 50, 80, 4
Lotte: 40, 80, 4
Joris: 80, 90, 5

Pieter: 40, 50, 5
Jan: 30, 20, 5
Pieter: 40, 50, 5
Jan: 30, 20, 5

6-6注意到在前面的练习中的函数和6.2.2以及6.2.3中的那两个函数完成了同样的功能。把这三个分析函数合并成一个单独的函数。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ifstream;
using std::ostream;
using std::stringstream;
using std::vector;
using std::string;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::remove_if;
using std::remove_copy_if;
using std::remove_copy;
using std::stable_partition;
using std::sort;
using std::accumulate;
using std::find;

struct Student_info
{
    std::string name;
    std::vector<double> homework;
    double midterm;
    double final;
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double average(const vector<double> &v)
{
    return accumulate(v.begin(), v.end(), 0.0) / v.size();
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const std::vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

double grade(const Student_info &s)
{
    return grade(s.midterm, s.final, s.homework);
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name < y.name;
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

istream &read(istream &is, Student_info &s)
{
    is >> s.name >> s.midterm >> s.final;
    read_hw(is, s.homework);

    return is;
}

istream &read(istream &is, vector<Student_info> &v)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student;
        read(ss, student);
        v.push_back(student);
    }

    return is;
}

bool did_all_hw(const Student_info &s)
{
    return ( find(s.homework.begin(), s.homework.end(), 0) == s.homework.end() );
}

bool fgrade(const Student_info &s)
{
    return grade(s) < 60;
}

bool pgrade(const Student_info &s)
{
    return !fgrade(s);
}

double grade_aux(const Student_info &s)
{
    try
    {
        return grade(s);
    }
    catch (domain_error)
    {
        return grade(s.midterm, s.final, 0);
    }
}

double median_analysis(const vector<Student_info> &students)
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), grade_aux);
    return median(grades);
}

double average_grade(const Student_info &s)
{
    return grade(s.midterm, s.final, average(s.homework));
}

double average_analysis(const vector<Student_info> &students)
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), average_grade);
    return median(grades);
}

double optimistic_median(const Student_info &s)
{
    vector<double> nonzero;

    remove_copy(s.homework.begin(), s.homework.end(), back_inserter(nonzero), 0);

    if (nonzero.empty())
    {
        return grade(s.midterm, s.final, 0);
    }
    else
    {
        return grade(s.midterm, s.final, median(nonzero));
    }
}

double optimistic_median_analysis(const vector<Student_info> &students)
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), optimistic_median);
    return median(grades);
}

double analysis(const vector<Student_info> &students, double method(const Student_info &))
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), method);
    return median(grades);
}

void write_analysis(ostream &out, const string &name, double method(const Student_info &),
                    const vector<Student_info> &did, const vector<Student_info> &didnt)
{
    out << name << ": median(did) = " << analysis(did, method) << ", median(didnt) = " << analysis(didnt, method) << endl;
}

void write_analysis(ostream &out, const string &name, double method(const vector<Student_info> &),
                    const vector<Student_info> &did, const vector<Student_info> &didnt)
{
    out << name << ": median(did) = " << method(did) << ", median(didnt) = " << method(didnt) << endl;
}

vector<Student_info> extract_fails(vector<Student_info> &students)
{
    vector<Student_info> fail;
    remove_copy_if(students.begin(), students.end(), back_inserter(fail), pgrade);
    students.erase(remove_if(students.begin(), students.end(), fgrade), students.end());

    return fail;
}

int main()
{
    vector<Student_info> did, didnt;
    vector<Student_info> all, failed;
    Student_info student;

    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read(infile, all);
    infile.close();
    infile.clear();

    for (vector<Student_info>::const_iterator iter = all.begin(); iter != all.end(); iter++)
    {
        if (did_all_hw(*iter))
        {
            cout << "did.push_back() ";
            did.push_back(*iter);
        }
        else
        {
            cout << "didnt.push_back() ";
            didnt.push_back(*iter);
        }
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;

    if (did.empty())
    {
        cout << "No student did all the homework!" << endl;
        return 1;
    }

    if (didnt.empty())
    {
        cout << "Every student did all the homework!" << endl;
        return 1;
    }

    write_analysis(cout, "median", median_analysis, did, didnt);
    write_analysis(cout, "average", average_analysis, did, didnt);
    write_analysis(cout, "optimistic median", optimistic_median_analysis, did, didnt);
    write_analysis(cout, "median", grade_aux, did, didnt);
    write_analysis(cout, "average", average_grade, did, didnt);
    write_analysis(cout, "optimistic median", optimistic_median, did, didnt);

    failed = extract_fails(all);
    for (vector<Student_info>::const_iterator iter = all.begin(); iter != all.end(); iter++)
    {
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;

    for (vector<Student_info>::const_iterator iter = failed.begin(); iter != failed.end(); iter++)
    {
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;

    return 0;
}
显示结果如下
did.push_back() Geert: 50, 80, 4
didnt.push_back() Pieter: 40, 50, 5
did.push_back() Lotte: 40, 80, 4
didnt.push_back() Jan: 30, 20, 5
did.push_back() Joris: 80, 90, 5
did.push_back() Geert: 50, 80, 4
didnt.push_back() Pieter: 40, 50, 5
did.push_back() Lotte: 40, 80, 4
didnt.push_back() Jan: 30, 20, 5
did.push_back() Joris: 80, 90, 5

median: median(did) = 67, median(didnt) = 37
average: median(did) = 66.5, median(didnt) = 35.4
optimistic median: median(did) = 67, median(didnt) = 38
median: median(did) = 67, median(didnt) = 37
average: median(did) = 66.5, median(didnt) = 35.4
optimistic median: median(did) = 67, median(didnt) = 38
Geert: 50, 80, 4
Lotte: 40, 80, 4
Joris: 80, 90, 5
Geert: 50, 80, 4
Lotte: 40, 80, 4
Joris: 80, 90, 5

Pieter: 40, 50, 5
Jan: 30, 20, 5
Pieter: 40, 50, 5
Jan: 30, 20, 5

6-7 在6.2.2中，那个计算成绩的分析程序的一部分功能是读入学生记录并对其进行分类，这一部分程序依赖于学生是否做了（或没有做）全部的家庭作业。
这个问题跟我们在extract_fails中所解决的那个类似。写一个函数来处理这个子问题。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ifstream;
using std::ostream;
using std::stringstream;
using std::vector;
using std::string;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::remove_if;
using std::remove_copy_if;
using std::remove_copy;
using std::stable_partition;
using std::sort;
using std::accumulate;
using std::find;

struct Student_info
{
    std::string name;
    std::vector<double> homework;
    double midterm;
    double final;
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double average(const vector<double> &v)
{
    return accumulate(v.begin(), v.end(), 0.0) / v.size();
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const std::vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

double grade(const Student_info &s)
{
    return grade(s.midterm, s.final, s.homework);
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name < y.name;
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

istream &read(istream &is, Student_info &s)
{
    is >> s.name >> s.midterm >> s.final;
    read_hw(is, s.homework);

    return is;
}

istream &read(istream &is, vector<Student_info> &v)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student;
        read(ss, student);
        v.push_back(student);
    }

    return is;
}

bool did_all_hw(const Student_info &s)
{
    return ( find(s.homework.begin(), s.homework.end(), 0) == s.homework.end() );
}

bool fgrade(const Student_info &s)
{
    return grade(s) < 60;
}

bool pgrade(const Student_info &s)
{
    return !fgrade(s);
}

double grade_aux(const Student_info &s)
{
    try
    {
        return grade(s);
    }
    catch (domain_error)
    {
        return grade(s.midterm, s.final, 0);
    }
}

double median_analysis(const vector<Student_info> &students)
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), grade_aux);
    return median(grades);
}

double average_grade(const Student_info &s)
{
    return grade(s.midterm, s.final, average(s.homework));
}

double average_analysis(const vector<Student_info> &students)
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), average_grade);
    return median(grades);
}

double optimistic_median(const Student_info &s)
{
    vector<double> nonzero;

    remove_copy(s.homework.begin(), s.homework.end(), back_inserter(nonzero), 0);

    if (nonzero.empty())
    {
        return grade(s.midterm, s.final, 0);
    }
    else
    {
        return grade(s.midterm, s.final, median(nonzero));
    }
}

double optimistic_median_analysis(const vector<Student_info> &students)
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), optimistic_median);
    return median(grades);
}

double analysis(const vector<Student_info> &students, double method(const Student_info &))
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), method);
    return median(grades);
}

void write_analysis(ostream &out, const string &name, double method(const Student_info &),
                    const vector<Student_info> &did, const vector<Student_info> &didnt)
{
    out << name << ": median(did) = " << analysis(did, method) << ", median(didnt) = " << analysis(didnt, method) << endl;
}

void write_analysis(ostream &out, const string &name, double method(const vector<Student_info> &),
                    const vector<Student_info> &did, const vector<Student_info> &didnt)
{
    out << name << ": median(did) = " << method(did) << ", median(didnt) = " << method(didnt) << endl;
}

vector<Student_info> extract_fails(vector<Student_info> &students)
{
    vector<Student_info> fail;
    remove_copy_if(students.begin(), students.end(), back_inserter(fail), pgrade);
    students.erase(remove_if(students.begin(), students.end(), fgrade), students.end());

    return fail;
}

vector<Student_info> extract_not_all_hw(vector<Student_info>& students) 
{
  vector<Student_info>::iterator iter = stable_partition(students.begin(), students.end(), did_all_hw);
  vector<Student_info> not_all_hw(iter, students.end());
  students.erase(iter, students.end());

  return not_all_hw;
}

int main()
{
    vector<Student_info> all, failed;
    Student_info student;

    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read(infile, all);
    infile.close();
    infile.clear();

    for (vector<Student_info>::const_iterator iter = all.begin(); iter != all.end(); iter++)
    {
        if (did_all_hw(*iter))
        {
            cout << "did ";
        }
        else
        {
            cout << "didnt ";
        }
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;
    vector<Student_info> did (all);
    vector<Student_info> didnt = extract_not_all_hw(did);

    if (did.empty())
    {
        cout << "No student did all the homework!" << endl;
        return 1;
    }

    if (didnt.empty())
    {
        cout << "Every student did all the homework!" << endl;
        return 1;
    }

    write_analysis(cout, "median", median_analysis, did, didnt);
    write_analysis(cout, "average", average_analysis, did, didnt);
    write_analysis(cout, "optimistic median", optimistic_median_analysis, did, didnt);
    write_analysis(cout, "median", grade_aux, did, didnt);
    write_analysis(cout, "average", average_grade, did, didnt);
    write_analysis(cout, "optimistic median", optimistic_median, did, didnt);

    failed = extract_fails(all);
    for (vector<Student_info>::const_iterator iter = all.begin(); iter != all.end(); iter++)
    {
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;

    for (vector<Student_info>::const_iterator iter = failed.begin(); iter != failed.end(); iter++)
    {
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;

    return 0;
}
显示结果如下
did Geert: 50, 80, 4
didnt Pieter: 40, 50, 5
did Lotte: 40, 80, 4
didnt Jan: 30, 20, 5
did Joris: 80, 90, 5
did Geert: 50, 80, 4
didnt Pieter: 40, 50, 5
did Lotte: 40, 80, 4
didnt Jan: 30, 20, 5
did Joris: 80, 90, 5

median: median(did) = 67, median(didnt) = 37
average: median(did) = 66.5, median(didnt) = 35.4
optimistic median: median(did) = 67, median(didnt) = 38
median: median(did) = 67, median(didnt) = 37
average: median(did) = 66.5, median(didnt) = 35.4
optimistic median: median(did) = 67, median(didnt) = 38
Geert: 50, 80, 4
Lotte: 40, 80, 4
Joris: 80, 90, 5
Geert: 50, 80, 4
Lotte: 40, 80, 4
Joris: 80, 90, 5

Pieter: 40, 50, 5
Jan: 30, 20, 5
Pieter: 40, 50, 5
Jan: 30, 20, 5

6-8编写一个函数，用这个函数来按照你自己的选择准则来对学生进行分类。
使用它来代替extract_fails程序从而对它进行测试，并在程序中用它来分析学生的成绩。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ifstream;
using std::ostream;
using std::stringstream;
using std::vector;
using std::string;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::remove_if;
using std::remove_copy_if;
using std::remove_copy;
using std::stable_partition;
using std::sort;
using std::accumulate;
using std::find;

struct Student_info
{
    std::string name;
    std::vector<double> homework;
    double midterm;
    double final;
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double average(const vector<double> &v)
{
    return accumulate(v.begin(), v.end(), 0.0) / v.size();
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const std::vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

double grade(const Student_info &s)
{
    return grade(s.midterm, s.final, s.homework);
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name < y.name;
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

istream &read(istream &is, Student_info &s)
{
    is >> s.name >> s.midterm >> s.final;
    read_hw(is, s.homework);

    return is;
}

istream &read(istream &is, vector<Student_info> &v)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student;
        read(ss, student);
        v.push_back(student);
    }

    return is;
}

bool did_all_hw(const Student_info &s)
{
    return ( find(s.homework.begin(), s.homework.end(), 0) == s.homework.end() );
}

bool fgrade(const Student_info &s)
{
    return grade(s) < 60;
}

bool pgrade(const Student_info &s)
{
    return !fgrade(s);
}

double grade_aux(const Student_info &s)
{
    try
    {
        return grade(s);
    }
    catch (domain_error)
    {
        return grade(s.midterm, s.final, 0);
    }
}

double median_analysis(const vector<Student_info> &students)
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), grade_aux);
    return median(grades);
}

double average_grade(const Student_info &s)
{
    return grade(s.midterm, s.final, average(s.homework));
}

double average_analysis(const vector<Student_info> &students)
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), average_grade);
    return median(grades);
}

double optimistic_median(const Student_info &s)
{
    vector<double> nonzero;

    remove_copy(s.homework.begin(), s.homework.end(), back_inserter(nonzero), 0);

    if (nonzero.empty())
    {
        return grade(s.midterm, s.final, 0);
    }
    else
    {
        return grade(s.midterm, s.final, median(nonzero));
    }
}

double optimistic_median_analysis(const vector<Student_info> &students)
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), optimistic_median);
    return median(grades);
}

double analysis(const vector<Student_info> &students, double method(const Student_info &))
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), method);
    return median(grades);
}

void write_analysis(ostream &out, const string &name, double method(const Student_info &),
                    const vector<Student_info> &did, const vector<Student_info> &didnt)
{
    out << name << ": median(did) = " << analysis(did, method) << ", median(didnt) = " << analysis(didnt, method) << endl;
}

void write_analysis(ostream &out, const string &name, double method(const vector<Student_info> &),
                    const vector<Student_info> &did, const vector<Student_info> &didnt)
{
    out << name << ": median(did) = " << method(did) << ", median(didnt) = " << method(didnt) << endl;
}

vector<Student_info> extract_fails(vector<Student_info> &students)
{
    vector<Student_info> fail;
    remove_copy_if(students.begin(), students.end(), back_inserter(fail), pgrade);
    students.erase(remove_if(students.begin(), students.end(), fgrade), students.end());

    return fail;
}

vector<Student_info> extract_not_all_hw(vector<Student_info>& students) 
{
  vector<Student_info>::iterator iter = stable_partition(students.begin(), students.end(), did_all_hw);
  vector<Student_info> not_all_hw(iter, students.end());
  students.erase(iter, students.end());

  return not_all_hw;
}

vector<Student_info> extract(vector<Student_info>& students, bool criteria(const Student_info&)) 
{
  vector<Student_info>::iterator iter = stable_partition(students.begin(), students.end(), criteria);
  vector<Student_info> extracted(iter, students.end());
  students.erase(iter, students.end());

  return extracted;
}

int main()
{
    vector<Student_info> all;
    Student_info student;

    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read(infile, all);
    infile.close();
    infile.clear();

    for (vector<Student_info>::const_iterator iter = all.begin(); iter != all.end(); iter++)
    {
        if (did_all_hw(*iter))
        {
            cout << "did ";
        }
        else
        {
            cout << "didnt ";
        }
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;
    vector<Student_info> did (all);
    vector<Student_info> didnt = extract(did, did_all_hw);

    if (did.empty())
    {
        cout << "No student did all the homework!" << endl;
        return 1;
    }

    if (didnt.empty())
    {
        cout << "Every student did all the homework!" << endl;
        return 1;
    }

    write_analysis(cout, "median", median_analysis, did, didnt);
    write_analysis(cout, "average", average_analysis, did, didnt);
    write_analysis(cout, "optimistic median", optimistic_median_analysis, did, didnt);
    write_analysis(cout, "median", grade_aux, did, didnt);
    write_analysis(cout, "average", average_grade, did, didnt);
    write_analysis(cout, "optimistic median", optimistic_median, did, didnt);

    vector<Student_info> failed = extract(all, pgrade);
    for (vector<Student_info>::const_iterator iter = all.begin(); iter != all.end(); iter++)
    {
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;

    for (vector<Student_info>::const_iterator iter = failed.begin(); iter != failed.end(); iter++)
    {
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;

    return 0;
}
显示结果如下
did Geert: 50, 80, 4
didnt Pieter: 40, 50, 5
did Lotte: 40, 80, 4
didnt Jan: 30, 20, 5
did Joris: 80, 90, 5
did Geert: 50, 80, 4
didnt Pieter: 40, 50, 5
did Lotte: 40, 80, 4
didnt Jan: 30, 20, 5
did Joris: 80, 90, 5

median: median(did) = 67, median(didnt) = 37
average: median(did) = 66.5, median(didnt) = 35.4
optimistic median: median(did) = 67, median(didnt) = 38
median: median(did) = 67, median(didnt) = 37
average: median(did) = 66.5, median(didnt) = 35.4
optimistic median: median(did) = 67, median(didnt) = 38
Geert: 50, 80, 4
Lotte: 40, 80, 4
Joris: 80, 90, 5
Geert: 50, 80, 4
Lotte: 40, 80, 4
Joris: 80, 90, 5

Pieter: 40, 50, 5
Jan: 30, 20, 5
Pieter: 40, 50, 5
Jan: 30, 20, 5

6-9使用一个库算法来连接一个vector<string>对象中的所有元素。
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <numeric>

using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::string;
using std::accumulate;

string concat(const vector<string> &v)
{
    string s;
    return accumulate(v.begin(), v.end(), s);
}

int main()
{
    vector<string> v = { "one direction", "mama mia", "mamo testo", "lake district mall" };
    cout << concat(v) << endl;

    return 0;
}
显示结果如下
one directionmama miamamo testolake district mall

第7章 使用关联容器
7.1 支持高效查找的容器
7.2 计算单词数
7.3 产生一个交叉引用表
7.4 生成句子
7.5 关于性能的一点说明
7.6 小结
习题
7-0编译、运行并测试本章中的程序。
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <map>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <cstdlib>
#include <cctype>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::vector;
using std::string;
using std::map;
using std::getline;
using std::find_if;
using std::search;
using std::copy;
using std::logic_error;
using std::domain_error;

typedef std::vector<std::string> Rule;
typedef std::vector<Rule> Rule_collection;
typedef std::map<std::string, Rule_collection> Grammar;

int nrand(int n)
{
    if (n <= 0 || n > RAND_MAX)
    {
        throw domain_error("Argument to nrand is out of range");
    }

    const int bucket_size = RAND_MAX / n;
    int r;

    do
    {
        r = rand() / bucket_size;
    }
    while (r >= n);

    return r;
}

istream &count_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    for (map<string, int>::const_iterator it = counters.begin(); it != counters.end(); ++it)
    {
        os << it->first << "\t" << it->second << endl;
    }

    return is;
}

bool space(char c)
{
    return isspace(c) != 0;
}

bool not_space(char c)
{
    return !isspace(c);
}

vector<string> split(const string &str)
{
    typedef string::const_iterator iter;
    vector<string> ret;

    iter i = str.begin();
    while (i != str.end())
    {

        i = find_if(i, str.end(), not_space);

        iter j = find_if(i, str.end(), space);

        if (i != j)
        {
            ret.push_back(string(i, j));
            i = j;
        }
    }
    return ret;
}

map<string, vector<int> > xref(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    return ret;
}

bool bracketed(const string &s)
{
    return s.size() > 1 && s[0] == '<' && s[s.size() - 1] == '>';
}

Grammar read_grammar(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        vector<string> entry = split(line);

        if (entry.size() > 1)
        {
            ret[entry[0]].push_back( Rule( entry.begin() + 1, entry.end() ) );
        }
    }

    return ret;
}

void gen_aux(const Grammar &g, const string &word, vector<string> &ret)
{

    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[nrand(c.size())];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}

vector<string> gen_sentence(const Grammar &g)
{
    vector<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

bool not_url_char(char c)
{
    static const string url_ch = "~;/?:@=&$-_.+!*'(),";

    return !(isalnum(c) || find(url_ch.begin(), url_ch.end(), c) != url_ch.end());
}

string::const_iterator url_beg(string::const_iterator b, string::const_iterator e)
{
    static const string sep = "://";

    typedef string::const_iterator iter;

    iter i = b;

    while ( ( i = search(i, e, sep.begin(), sep.end()) ) != e )
    {

        if (i != b && i + sep.size() != e)
        {

            iter beg = i;
            while (beg != b && isalpha(beg[-1]))
            {
                --beg;
            }

            if (beg != i && !not_url_char( i[sep.size()] ))
            {
                return beg;
            }
        }

        i += sep.size();
    }

    return e;
}

string::const_iterator url_end(string::const_iterator b, string::const_iterator e)
{
    return find_if(b, e, not_url_char);
}

vector<string> find_urls(const string &s)
{
    vector<string> ret;
    typedef string::const_iterator iter;
    iter b = s.begin(), e = s.end();

    while (b != e)
    {

        b = url_beg(b, e);

        if (b != e)
        {
            iter after = url_end(b, e);

            ret.push_back(string(b, after));

            b = after;
        }
    }

    return ret;
}

int test_xref()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret = xref(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret.begin(); it != ret.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }

    return 0;
}

int test_generate_sentence()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    vector<string> sentence = gen_sentence(read_grammar(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;
    return 0;
}

int main()
{
    test_xref();
    cout << endl;
    test_generate_sentence();
    return 0;
}
显示结果如下
<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

the table sits wherever it wants

7-1 扩充7.2中的程序，按出现次数来构造它的输出。也就是说，程序在输出的时候应该对所有的单词分组，
首先是输出出现了一次的，然后是出现了两次的，以此类推。
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <map>
#include <algorithm>
#include <iterator>
#include <utility>
#include <stdexcept>
#include <cstdlib>
#include <cctype>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::vector;
using std::string;
using std::map;
using std::multimap;
using std::pair;
using std::getline;
using std::find_if;
using std::search;
using std::copy;
using std::transform;
using std::inserter;
using std::logic_error;
using std::domain_error;

typedef std::vector<std::string> Rule;
typedef std::vector<Rule> Rule_collection;
typedef std::map<std::string, Rule_collection> Grammar;

int nrand(int n)
{
    if (n <= 0 || n > RAND_MAX)
    {
        throw domain_error("Argument to nrand is out of range");
    }

    const int bucket_size = RAND_MAX / n;
    int r;

    do
    {
        r = rand() / bucket_size;
    }
    while (r >= n);

    return r;
}

istream &count_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    for (map<string, int>::const_iterator it = counters.begin(); it != counters.end(); ++it)
    {
        os << it->first << "\t" << it->second << endl;
    }

    return is;
}

pair<int, string> flip_count_pair(pair<string, int> p) 
{
  return pair<int, string>(p.second, p.first);
}

istream& count_sort_words(istream& is, ostream& os)
{
  string s;
  map<string, int> counters;

  while (is >> s)
  {
    ++counters[s];
  }

  multimap<int, string> counters_r;
  transform(counters.begin(), counters.end(), inserter(counters_r, counters_r.begin()), flip_count_pair);

  for (multimap<int, string>::const_iterator it = counters_r.begin(); it != counters_r.end(); ++it)
  {
    os << it->second << "\t" << it->first << endl;
  }

  return is;
}

bool space(char c)
{
    return isspace(c) != 0;
}

bool not_space(char c)
{
    return !isspace(c);
}

vector<string> split(const string &str)
{
    typedef string::const_iterator iter;
    vector<string> ret;

    iter i = str.begin();
    while (i != str.end())
    {

        i = find_if(i, str.end(), not_space);

        iter j = find_if(i, str.end(), space);

        if (i != j)
        {
            ret.push_back(string(i, j));
            i = j;
        }
    }
    return ret;
}

map<string, vector<int> > xref(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    return ret;
}

bool bracketed(const string &s)
{
    return s.size() > 1 && s[0] == '<' && s[s.size() - 1] == '>';
}

Grammar read_grammar(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        vector<string> entry = split(line);

        if (entry.size() > 1)
        {
            ret[entry[0]].push_back( Rule( entry.begin() + 1, entry.end() ) );
        }
    }

    return ret;
}

void gen_aux(const Grammar &g, const string &word, vector<string> &ret)
{

    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[nrand(c.size())];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}

vector<string> gen_sentence(const Grammar &g)
{
    vector<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

bool not_url_char(char c)
{
    static const string url_ch = "~;/?:@=&$-_.+!*'(),";

    return !(isalnum(c) || find(url_ch.begin(), url_ch.end(), c) != url_ch.end());
}

string::const_iterator url_beg(string::const_iterator b, string::const_iterator e)
{
    static const string sep = "://";

    typedef string::const_iterator iter;

    iter i = b;

    while ( ( i = search(i, e, sep.begin(), sep.end()) ) != e )
    {

        if (i != b && i + sep.size() != e)
        {

            iter beg = i;
            while (beg != b && isalpha(beg[-1]))
            {
                --beg;
            }

            if (beg != i && !not_url_char( i[sep.size()] ))
            {
                return beg;
            }
        }

        i += sep.size();
    }

    return e;
}

string::const_iterator url_end(string::const_iterator b, string::const_iterator e)
{
    return find_if(b, e, not_url_char);
}

vector<string> find_urls(const string &s)
{
    vector<string> ret;
    typedef string::const_iterator iter;
    iter b = s.begin(), e = s.end();

    while (b != e)
    {

        b = url_beg(b, e);

        if (b != e)
        {
            iter after = url_end(b, e);

            ret.push_back(string(b, after));

            b = after;
        }
    }

    return ret;
}

int test_xref()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret = xref(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret.begin(); it != ret.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }

    return 0;
}

int test_generate_sentence()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    vector<string> sentence = gen_sentence(read_grammar(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;
    return 0;
}

int test_count_words()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    count_sort_words(infile, cout);
    infile.close();
    infile.clear();
    return 0;
}

int main()
{
    test_xref();
    cout << endl;
    test_generate_sentence();
    cout << endl;
    test_count_words();
    return 0;
}
显示结果如下
<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

the table sits wherever it wants

<sentence>      1
absurd  1
brown   1
cat     1
dog     1
it      1
jumps   1
large   1
on      1
sits    1
sky     1
stairs  1
table   1
under   1
wants   1
wherever        1
the     3
<verb>  3
<adjective>     4
<location>      4
<noun-phrase>   4
<noun>  4

7-2 扩充4.2.3中的程序，按分数范围评出等级，在输出中列出每一种类有多少个学生。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ifstream;
using std::ostream;
using std::stringstream;
using std::vector;
using std::string;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::remove_if;
using std::remove_copy_if;
using std::remove_copy;
using std::stable_partition;
using std::sort;
using std::accumulate;
using std::find;
using std::streamsize;
using std::setprecision;
using std::max;
using std::map;

struct Student_info
{
    std::string name;
    std::vector<double> homework;
    double midterm;
    double final;
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double average(const vector<double> &v)
{
    return accumulate(v.begin(), v.end(), 0.0) / v.size();
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const std::vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

double grade(const Student_info &s)
{
    return grade(s.midterm, s.final, s.homework);
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name < y.name;
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

istream &read(istream &is, Student_info &s)
{
    is >> s.name >> s.midterm >> s.final;
    read_hw(is, s.homework);

    return is;
}

istream &read(istream &is, vector<Student_info> &v)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student;
        read(ss, student);
        v.push_back(student);
    }

    return is;
}

bool did_all_hw(const Student_info &s)
{
    return ( find(s.homework.begin(), s.homework.end(), 0) == s.homework.end() );
}

bool fgrade(const Student_info &s)
{
    return grade(s) < 60;
}

bool pgrade(const Student_info &s)
{
    return !fgrade(s);
}

double grade_aux(const Student_info &s)
{
    try
    {
        return grade(s);
    }
    catch (domain_error)
    {
        return grade(s.midterm, s.final, 0);
    }
}

double median_analysis(const vector<Student_info> &students)
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), grade_aux);
    return median(grades);
}

double average_grade(const Student_info &s)
{
    return grade(s.midterm, s.final, average(s.homework));
}

double average_analysis(const vector<Student_info> &students)
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), average_grade);
    return median(grades);
}

double optimistic_median(const Student_info &s)
{
    vector<double> nonzero;

    remove_copy(s.homework.begin(), s.homework.end(), back_inserter(nonzero), 0);

    if (nonzero.empty())
    {
        return grade(s.midterm, s.final, 0);
    }
    else
    {
        return grade(s.midterm, s.final, median(nonzero));
    }
}

double optimistic_median_analysis(const vector<Student_info> &students)
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), optimistic_median);
    return median(grades);
}

double analysis(const vector<Student_info> &students, double method(const Student_info &))
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), method);
    return median(grades);
}

void write_analysis(ostream &out, const string &name, double method(const Student_info &),
                    const vector<Student_info> &did, const vector<Student_info> &didnt)
{
    out << name << ": median(did) = " << analysis(did, method) << ", median(didnt) = " << analysis(didnt, method) << endl;
}

void write_analysis(ostream &out, const string &name, double method(const vector<Student_info> &),
                    const vector<Student_info> &did, const vector<Student_info> &didnt)
{
    out << name << ": median(did) = " << method(did) << ", median(didnt) = " << method(didnt) << endl;
}

vector<Student_info> extract_fails(vector<Student_info> &students)
{
    vector<Student_info> fail;
    remove_copy_if(students.begin(), students.end(), back_inserter(fail), pgrade);
    students.erase(remove_if(students.begin(), students.end(), fgrade), students.end());

    return fail;
}

vector<Student_info> extract_not_all_hw(vector<Student_info> &students)
{
    vector<Student_info>::iterator iter = stable_partition(students.begin(), students.end(), did_all_hw);
    vector<Student_info> not_all_hw(iter, students.end());
    students.erase(iter, students.end());

    return not_all_hw;
}

vector<Student_info> extract(vector<Student_info> &students, bool criteria(const Student_info &))
{
    vector<Student_info>::iterator iter = stable_partition(students.begin(), students.end(), criteria);
    vector<Student_info> extracted(iter, students.end());
    students.erase(iter, students.end());

    return extracted;
}
istream &read_and_grade(istream &is, vector<Student_info> &students)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];
    string::size_type maxlen = 0;

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student;
        read(ss, student);
        maxlen = max(maxlen, student.name.size());
        students.push_back(student);
    }
    sort(students.begin(), students.end(), compare);
    for (vector<Student_info>::size_type i = 0; i != students.size(); i++)
    {
        cout << students[i].name << string(maxlen + 1 - students[i].name.size(), ' ');

        try
        {
            double final_grade = grade(students[i]);
            streamsize prec = cout.precision();
            cout << setprecision(3) << final_grade << setprecision(prec);
        }
        catch (domain_error e)
        {
            cout << e.what();
        }
        cout << endl;
    }

    return is;
}

int grade_by_range()
{
    vector<Student_info> students;
    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read_and_grade(infile, students);
    infile.close();
    infile.clear();
    map<char, int> graded_students;

    for (vector<Student_info>::const_iterator iter = students.begin(); iter != students.end(); ++iter)
    {
        try
        {
            double final_grade = grade(*iter);
            if (final_grade >= 90)
            {
                ++graded_students['A'];
            }
            else if (final_grade >= 80)
            {
                ++graded_students['B'];
            }
            else if (final_grade >= 70)
            {
                ++graded_students['C'];
            }
            else if (final_grade >= 60)
            {
                ++graded_students['D'];
            }
            else
            {
                ++graded_students['F'];
            }
        }
        catch (domain_error e)
        {
            cout << e.what() << endl;
        }
    }

    for (map<char, int>::const_iterator iter = graded_students.begin(); iter != graded_students.end(); ++iter)
    {
        cout << iter->first << " : " << iter->second << " students" << endl;
    }

    return 0;
}

int main()
{
    vector<Student_info> all;
    Student_info student;

    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read(infile, all);
    infile.close();
    infile.clear();

    for (vector<Student_info>::const_iterator iter = all.begin(); iter != all.end(); iter++)
    {
        if (did_all_hw(*iter))
        {
            cout << "did ";
        }
        else
        {
            cout << "didnt ";
        }
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;
    vector<Student_info> did (all);
    vector<Student_info> didnt = extract(did, did_all_hw);

    if (did.empty())
    {
        cout << "No student did all the homework!" << endl;
        return 1;
    }

    if (didnt.empty())
    {
        cout << "Every student did all the homework!" << endl;
        return 1;
    }

    write_analysis(cout, "median", median_analysis, did, didnt);
    write_analysis(cout, "average", average_analysis, did, didnt);
    write_analysis(cout, "optimistic median", optimistic_median_analysis, did, didnt);
    write_analysis(cout, "median", grade_aux, did, didnt);
    write_analysis(cout, "average", average_grade, did, didnt);
    write_analysis(cout, "optimistic median", optimistic_median, did, didnt);

    vector<Student_info> failed = extract(all, pgrade);
    for (vector<Student_info>::const_iterator iter = all.begin(); iter != all.end(); iter++)
    {
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;

    for (vector<Student_info>::const_iterator iter = failed.begin(); iter != failed.end(); iter++)
    {
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;
    grade_by_range();

    return 0;
}
显示结果如下
did Geert: 50, 80, 4
didnt Pieter: 40, 50, 5
did Lotte: 40, 80, 4
didnt Jan: 30, 20, 5
did Joris: 80, 90, 5
did Geert: 50, 80, 4
didnt Pieter: 40, 50, 5
did Lotte: 40, 80, 4
didnt Jan: 30, 20, 5
did Joris: 80, 90, 5

median: median(did) = 67, median(didnt) = 37
average: median(did) = 66.5, median(didnt) = 35.4
optimistic median: median(did) = 67, median(didnt) = 38
median: median(did) = 67, median(didnt) = 37
average: median(did) = 66.5, median(didnt) = 35.4
optimistic median: median(did) = 67, median(didnt) = 38
Geert: 50, 80, 4
Lotte: 40, 80, 4
Joris: 80, 90, 5
Geert: 50, 80, 4
Lotte: 40, 80, 4
Joris: 80, 90, 5

Pieter: 40, 50, 5
Jan: 30, 20, 5
Pieter: 40, 50, 5
Jan: 30, 20, 5

Geert  67
Geert  67
Jan    30
Jan    30
Joris  76
Joris  76
Lotte  66
Lotte  66
Pieter 44
Pieter 44
C : 2 students
D : 4 students
F : 4 students

7-3 在7.3中的交叉引用程序是可以改进的：正如它所示，如果一个单词在同一输入行中多次出现的话，那么程序将会多次报告这一行。
修改代码以使它能够检测到同一个行编号的多次重复出现并且仅仅插入这个行编号一次。
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <map>
#include <algorithm>
#include <iterator>
#include <utility>
#include <stdexcept>
#include <cstdlib>
#include <cctype>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::vector;
using std::string;
using std::map;
using std::multimap;
using std::pair;
using std::getline;
using std::find_if;
using std::search;
using std::copy;
using std::transform;
using std::inserter;
using std::logic_error;
using std::domain_error;
using std::to_string;
using std::distance;
using std::unique;

typedef std::vector<std::string> Rule;
typedef std::vector<Rule> Rule_collection;
typedef std::map<std::string, Rule_collection> Grammar;

int nrand(int n)
{
    if (n <= 0 || n > RAND_MAX)
    {
        throw domain_error("Argument to nrand is out of range");
    }

    const int bucket_size = RAND_MAX / n;
    int r;

    do
    {
        r = rand() / bucket_size;
    }
    while (r >= n);

    return r;
}

istream &count_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    for (map<string, int>::const_iterator it = counters.begin(); it != counters.end(); ++it)
    {
        os << it->first << "\t" << it->second << endl;
    }

    return is;
}

pair<int, string> flip_count_pair(pair<string, int> p) 
{
  return pair<int, string>(p.second, p.first);
}

istream& count_sort_words(istream& is, ostream& os)
{
  string s;
  map<string, int> counters;

  while (is >> s)
  {
    ++counters[s];
  }

  multimap<int, string> counters_r;
  transform(counters.begin(), counters.end(), inserter(counters_r, counters_r.begin()), flip_count_pair);

  for (multimap<int, string>::const_iterator it = counters_r.begin(); it != counters_r.end(); ++it)
  {
    os << it->second << "\t" << it->first << endl;
  }

  return is;
}

bool space(char c)
{
    return isspace(c) != 0;
}

bool not_space(char c)
{
    return !isspace(c);
}

vector<string> split(const string &str)
{
    typedef string::const_iterator iter;
    vector<string> ret;

    iter i = str.begin();
    while (i != str.end())
    {

        i = find_if(i, str.end(), not_space);

        iter j = find_if(i, str.end(), space);

        if (i != j)
        {
            ret.push_back(string(i, j));
            i = j;
        }
    }
    return ret;
}

map<string, vector<int> > xref(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    return ret;
}

map<string, vector<int> > xref_unique(istream& in, vector<string> find_words(const string&)) 
{
  string line;
  int line_number = 0;
  map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
  {
    ++line_number;

    vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
  }

  for (map<string, vector<int> >::iterator it = ret.begin(); it != ret.end(); ++it)
  {
    it->second.resize( distance(it->second.begin(), unique(it->second.begin(), it->second.end()) ) );
  }

  return ret;
}

bool bracketed(const string &s)
{
    return s.size() > 1 && s[0] == '<' && s[s.size() - 1] == '>';
}

Grammar read_grammar(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        vector<string> entry = split(line);

        if (entry.size() > 1)
        {
            ret[entry[0]].push_back( Rule( entry.begin() + 1, entry.end() ) );
        }
    }

    return ret;
}

void gen_aux(const Grammar &g, const string &word, vector<string> &ret)
{

    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[nrand(c.size())];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}

vector<string> gen_sentence(const Grammar &g)
{
    vector<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

bool not_url_char(char c)
{
    static const string url_ch = "~;/?:@=&$-_.+!*'(),";

    return !(isalnum(c) || find(url_ch.begin(), url_ch.end(), c) != url_ch.end());
}

string::const_iterator url_beg(string::const_iterator b, string::const_iterator e)
{
    static const string sep = "://";

    typedef string::const_iterator iter;

    iter i = b;

    while ( ( i = search(i, e, sep.begin(), sep.end()) ) != e )
    {

        if (i != b && i + sep.size() != e)
        {

            iter beg = i;
            while (beg != b && isalpha(beg[-1]))
            {
                --beg;
            }

            if (beg != i && !not_url_char( i[sep.size()] ))
            {
                return beg;
            }
        }

        i += sep.size();
    }

    return e;
}

string::const_iterator url_end(string::const_iterator b, string::const_iterator e)
{
    return find_if(b, e, not_url_char);
}

vector<string> find_urls(const string &s)
{
    vector<string> ret;
    typedef string::const_iterator iter;
    iter b = s.begin(), e = s.end();

    while (b != e)
    {

        b = url_beg(b, e);

        if (b != e)
        {
            iter after = url_end(b, e);

            ret.push_back(string(b, after));

            b = after;
        }
    }

    return ret;
}

int test_xref()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret = xref(infile, split);
    infile.close();
    infile.clear();
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret.begin(); it != ret.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    cout << endl;
    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    return 0;
}

int test_generate_sentence()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    vector<string> sentence = gen_sentence(read_grammar(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;
    return 0;
}

int test_count_words()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    count_sort_words(infile, cout);
    infile.close();
    infile.clear();
    return 0;
}

int main()
{
    test_xref();
    cout << endl;
    test_generate_sentence();
    cout << endl;
    test_count_words();
    return 0;
}
显示结果如下
<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

the table sits wherever it wants

<sentence>      1
absurd  1
brown   1
cat     1
dog     1
it      1
jumps   1
large   1
on      1
sits    1
sky     1
stairs  1
table   1
under   1
wants   1
wherever        1
the     3
<verb>  3
<adjective>     4
<location>      4
<noun-phrase>   4
<noun>  4

7-4 如果输入文件太大的话，那么交叉引用程序所产生的输出的格式将会不够美观。重新编写这个程序以使它在行太长的时候换行输出。
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <map>
#include <algorithm>
#include <iterator>
#include <utility>
#include <stdexcept>
#include <cstdlib>
#include <cctype>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::vector;
using std::string;
using std::map;
using std::multimap;
using std::pair;
using std::getline;
using std::find_if;
using std::search;
using std::copy;
using std::transform;
using std::inserter;
using std::logic_error;
using std::domain_error;
using std::to_string;
using std::distance;
using std::unique;

typedef std::vector<std::string> Rule;
typedef std::vector<Rule> Rule_collection;
typedef std::map<std::string, Rule_collection> Grammar;

int nrand(int n)
{
    if (n <= 0 || n > RAND_MAX)
    {
        throw domain_error("Argument to nrand is out of range");
    }

    const int bucket_size = RAND_MAX / n;
    int r;

    do
    {
        r = rand() / bucket_size;
    }
    while (r >= n);

    return r;
}

istream &count_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    for (map<string, int>::const_iterator it = counters.begin(); it != counters.end(); ++it)
    {
        os << it->first << "\t" << it->second << endl;
    }

    return is;
}

pair<int, string> flip_count_pair(pair<string, int> p)
{
    return pair<int, string>(p.second, p.first);
}

istream &count_sort_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    multimap<int, string> counters_r;
    transform(counters.begin(), counters.end(), inserter(counters_r, counters_r.begin()), flip_count_pair);

    for (multimap<int, string>::const_iterator it = counters_r.begin(); it != counters_r.end(); ++it)
    {
        os << it->second << "\t" << it->first << endl;
    }

    return is;
}

bool space(char c)
{
    return isspace(c) != 0;
}

bool not_space(char c)
{
    return !isspace(c);
}

vector<string> split(const string &str)
{
    typedef string::const_iterator iter;
    vector<string> ret;

    iter i = str.begin();
    while (i != str.end())
    {

        i = find_if(i, str.end(), not_space);

        iter j = find_if(i, str.end(), space);

        if (i != j)
        {
            ret.push_back(string(i, j));
            i = j;
        }
    }
    return ret;
}

map<string, vector<int> > xref(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    return ret;
}

map<string, vector<int> > xref_unique(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    for (map<string, vector<int> >::iterator it = ret.begin(); it != ret.end(); ++it)
    {
        it->second.resize( distance(it->second.begin(), unique(it->second.begin(), it->second.end()) ) );
    }

    return ret;
}

bool bracketed(const string &s)
{
    return s.size() > 1 && s[0] == '<' && s[s.size() - 1] == '>';
}

Grammar read_grammar(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        vector<string> entry = split(line);

        if (entry.size() > 1)
        {
            ret[entry[0]].push_back( Rule( entry.begin() + 1, entry.end() ) );
        }
    }

    return ret;
}

void gen_aux(const Grammar &g, const string &word, vector<string> &ret)
{

    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[nrand(c.size())];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}

vector<string> gen_sentence(const Grammar &g)
{
    vector<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

bool not_url_char(char c)
{
    static const string url_ch = "~;/?:@=&$-_.+!*'(),";

    return !(isalnum(c) || find(url_ch.begin(), url_ch.end(), c) != url_ch.end());
}

string::const_iterator url_beg(string::const_iterator b, string::const_iterator e)
{
    static const string sep = "://";

    typedef string::const_iterator iter;

    iter i = b;

    while ( ( i = search(i, e, sep.begin(), sep.end()) ) != e )
    {

        if (i != b && i + sep.size() != e)
        {

            iter beg = i;
            while (beg != b && isalpha(beg[-1]))
            {
                --beg;
            }

            if (beg != i && !not_url_char( i[sep.size()] ))
            {
                return beg;
            }
        }

        i += sep.size();
    }

    return e;
}

string::const_iterator url_end(string::const_iterator b, string::const_iterator e)
{
    return find_if(b, e, not_url_char);
}

vector<string> find_urls(const string &s)
{
    vector<string> ret;
    typedef string::const_iterator iter;
    iter b = s.begin(), e = s.end();

    while (b != e)
    {

        b = url_beg(b, e);

        if (b != e)
        {
            iter after = url_end(b, e);

            ret.push_back(string(b, after));

            b = after;
        }
    }

    return ret;
}

int print_formatted_xref(string file, size_t line_length)
{
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        string s = it->first + " occurs on line(s): ";
        string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
    }

    return 0;
}

int test_xref()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret = xref(infile, split);
    infile.close();
    infile.clear();
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret.begin(); it != ret.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    cout << endl;
    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    return 0;
}

int test_generate_sentence()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    vector<string> sentence = gen_sentence(read_grammar(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;
    return 0;
}

int test_count_words()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    count_sort_words(infile, cout);
    infile.close();
    infile.clear();
    return 0;
}

int main()
{
    test_xref();
    cout << endl;
    test_generate_sentence();
    cout << endl;
    test_count_words();
    cout << endl;
    print_formatted_xref("lines_ch07.txt", 60);
    return 0;
}
显示结果如下
<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

the table sits wherever it wants

<sentence>      1
absurd  1
brown   1
cat     1
dog     1
it      1
jumps   1
large   1
on      1
sits    1
sky     1
stairs  1
table   1
under   1
wants   1
wherever        1
the     3
<verb>  3
<adjective>     4
<location>      4
<noun-phrase>   4
<noun>  4

Anna occurs on line(s): 3, 8, 13, 18, 23, 28, 33, 38, 43,
                        48, 53, 58, 63, 68, 73, 78, 83, 88
Baab occurs on line(s): 1
Peter occurs on line(s): 2, 7, 12, 17, 22, 27, 32, 37, 42,
                         47, 52, 57, 62, 67, 72, 77, 82, 87
Super! occurs on line(s): 4, 9, 14, 19, 24, 29, 34, 39, 44,
                          49, 54, 59, 64, 69, 74, 79, 84, 89
The occurs on line(s): 6, 11, 16, 21, 26, 31, 36, 41, 46,
                       51, 56, 61, 66, 71, 76, 81, 86, 91
This occurs on line(s): 4, 5, 9, 10, 14, 15, 19, 20, 24,
                        25, 29, 30, 34, 35, 39, 40, 44, 45,
                        49, 50, 54, 55, 59, 60, 64, 65, 69,
                        70, 74, 75, 79, 80, 84, 85, 89, 90
bakery. occurs on line(s): 2, 7, 12, 17, 22, 27, 32, 37,
                           42, 47, 52, 57, 62, 67, 72, 77,
                           82, 87
bigger occurs on line(s): 5, 10, 15, 20, 25, 30, 35, 40,
                          45, 50, 55, 60, 65, 70, 75, 80,
                          85, 90
former. occurs on line(s): 6, 11, 16, 21, 26, 31, 36, 41,
                           46, 51, 56, 61, 66, 71, 76, 81,
                           86, 91
goes occurs on line(s): 2, 7, 12, 17, 22, 27, 32, 37, 42,
                        47, 52, 57, 62, 67, 72, 77, 82, 87
greater occurs on line(s): 6, 11, 16, 21, 26, 31, 36, 41,
                           46, 51, 56, 61, 66, 71, 76, 81,
                           86, 91
is occurs on line(s): 4, 5, 6, 9, 10, 11, 14, 15, 16, 19,
                      20, 21, 24, 25, 26, 29, 30, 31, 34,
                      35, 36, 39, 40, 41, 44, 45, 46, 49,
                      50, 51, 54, 55, 56, 59, 60, 61, 64,
                      65, 66, 69, 70, 71, 74, 75, 76, 79,
                      80, 81, 84, 85, 86, 89, 90, 91
latter occurs on line(s): 6, 11, 16, 21, 26, 31, 36, 41,
                          46, 51, 56, 61, 66, 71, 76, 81,
                          86, 91
lottery. occurs on line(s): 3, 8, 13, 18, 23, 28, 33, 38,
                            43, 48, 53, 58, 63, 68, 73, 78,
                            83, 88
smaller. occurs on line(s): 5, 10, 15, 20, 25, 30, 35, 40,
                            45, 50, 55, 60, 65, 70, 75, 80,
                            85, 90
super! occurs on line(s): 4, 9, 14, 19, 24, 29, 34, 39, 44,
                          49, 54, 59, 64, 69, 74, 79, 84, 89
than occurs on line(s): 5, 6, 10, 11, 15, 16, 20, 21, 25,
                        26, 30, 31, 35, 36, 40, 41, 45, 46,
                        50, 51, 55, 56, 60, 61, 65, 66, 70,
                        71, 75, 76, 80, 81, 85, 86, 90, 91
that occurs on line(s): 5, 10, 15, 20, 25, 30, 35, 40, 45,
                        50, 55, 60, 65, 70, 75, 80, 85, 90
the occurs on line(s): 2, 3, 6, 7, 8, 11, 12, 13, 16, 17,
                       18, 21, 22, 23, 26, 27, 28, 31, 32,
                       33, 36, 37, 38, 41, 42, 43, 46, 47,
                       48, 51, 52, 53, 56, 57, 58, 61, 62,
                       63, 66, 67, 68, 71, 72, 73, 76, 77,
                       78, 81, 82, 83, 86, 87, 88, 91
to occurs on line(s): 2, 7, 12, 17, 22, 27, 32, 37, 42, 47,
                      52, 57, 62, 67, 72, 77, 82, 87
won occurs on line(s): 3, 8, 13, 18, 23, 28, 33, 38, 43,
                       48, 53, 58, 63, 68, 73, 78, 83, 88

7-5 用表（链表）来作为数据结构而重新实现那个文法程序，让这个程序构造一个句子。
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <map>
#include <list>
#include <algorithm>
#include <iterator>
#include <utility>
#include <stdexcept>
#include <cstdlib>
#include <ctime>
#include <cctype>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::vector;
using std::string;
using std::map;
using std::multimap;
using std::pair;
using std::list;
using std::getline;
using std::find_if;
using std::search;
using std::copy;
using std::transform;
using std::inserter;
using std::back_inserter;
using std::logic_error;
using std::domain_error;
using std::to_string;
using std::distance;
using std::unique;

typedef std::vector<std::string> Rule;
typedef std::vector<Rule> Rule_collection;
typedef std::map<std::string, Rule_collection> Grammar;

int nrand(int n)
{
    if (n <= 0 || n > RAND_MAX)
    {
        throw domain_error("Argument to nrand is out of range");
    }

    const int bucket_size = RAND_MAX / n;
    int r;

    do
    {
        r = rand() / bucket_size;
    }
    while (r >= n);

    return r;
}

istream &count_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    for (map<string, int>::const_iterator it = counters.begin(); it != counters.end(); ++it)
    {
        os << it->first << "\t" << it->second << endl;
    }

    return is;
}

pair<int, string> flip_count_pair(pair<string, int> p)
{
    return pair<int, string>(p.second, p.first);
}

istream &count_sort_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    multimap<int, string> counters_r;
    transform(counters.begin(), counters.end(), inserter(counters_r, counters_r.begin()), flip_count_pair);

    for (multimap<int, string>::const_iterator it = counters_r.begin(); it != counters_r.end(); ++it)
    {
        os << it->second << "\t" << it->first << endl;
    }

    return is;
}

bool space(char c)
{
    return isspace(c) != 0;
}

bool not_space(char c)
{
    return !isspace(c);
}

vector<string> split(const string &str)
{
    typedef string::const_iterator iter;
    vector<string> ret;

    iter i = str.begin();
    while (i != str.end())
    {

        i = find_if(i, str.end(), not_space);

        iter j = find_if(i, str.end(), space);

        if (i != j)
        {
            ret.push_back(string(i, j));
            i = j;
        }
    }
    return ret;
}

list<string> split_to_list(const string &str)
{
    vector<string> ret = split(str);
    list <string> list;
    copy(ret.begin(), ret.end(), back_inserter(list));

    return list;
}

map<string, vector<int> > xref(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    return ret;
}

map<string, vector<int> > xref_unique(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    for (map<string, vector<int> >::iterator it = ret.begin(); it != ret.end(); ++it)
    {
        it->second.resize( distance(it->second.begin(), unique(it->second.begin(), it->second.end()) ) );
    }

    return ret;
}

bool bracketed(const string &s)
{
    return s.size() > 1 && s[0] == '<' && s[s.size() - 1] == '>';
}

Grammar read_grammar(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        vector<string> entry = split(line);

        if (entry.size() > 1)
        {
            ret[entry[0]].push_back( Rule( entry.begin() + 1, entry.end() ) );
        }
    }

    return ret;
}

Grammar read_grammar_list(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        list<string> entry = split_to_list(line);

        if (entry.size() > 1)
        {
            ret[entry.front()].push_back( Rule( ++entry.begin(), entry.end() ) );
        }
    }

    return ret;
}
void gen_aux(const Grammar &g, const string &word, vector<string> &ret)
{
    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[nrand(c.size())];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}

void gen_aux(const Grammar &g, const string &word, list<string> &ret)
{
    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[nrand(c.size())];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}
vector<string> gen_sentence(const Grammar &g)
{
    vector<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

list<string> gen_sentence_list(const Grammar &g)
{
    list<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

int generate_sentence_list_output(string file)
{
    ifstream infile;
    infile.open(file);
    list<string> sentence = gen_sentence_list(read_grammar_list(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;

    return 0;
}

bool not_url_char(char c)
{
    static const string url_ch = "~;/?:@=&$-_.+!*'(),";

    return !(isalnum(c) || find(url_ch.begin(), url_ch.end(), c) != url_ch.end());
}

string::const_iterator url_beg(string::const_iterator b, string::const_iterator e)
{
    static const string sep = "://";

    typedef string::const_iterator iter;

    iter i = b;

    while ( ( i = search(i, e, sep.begin(), sep.end()) ) != e )
    {

        if (i != b && i + sep.size() != e)
        {

            iter beg = i;
            while (beg != b && isalpha(beg[-1]))
            {
                --beg;
            }

            if (beg != i && !not_url_char( i[sep.size()] ))
            {
                return beg;
            }
        }

        i += sep.size();
    }

    return e;
}

string::const_iterator url_end(string::const_iterator b, string::const_iterator e)
{
    return find_if(b, e, not_url_char);
}

vector<string> find_urls(const string &s)
{
    vector<string> ret;
    typedef string::const_iterator iter;
    iter b = s.begin(), e = s.end();

    while (b != e)
    {

        b = url_beg(b, e);

        if (b != e)
        {
            iter after = url_end(b, e);

            ret.push_back(string(b, after));

            b = after;
        }
    }

    return ret;
}

int print_formatted_xref(string file, size_t line_length)
{
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        string s = it->first + " occurs on line(s): ";
        string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
    }

    return 0;
}

int test_xref()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret = xref(infile, split);
    infile.close();
    infile.clear();
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret.begin(); it != ret.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    cout << endl;
    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    return 0;
}

int test_generate_sentence()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    vector<string> sentence = gen_sentence(read_grammar(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;
    return 0;
}

int test_count_words()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    count_sort_words(infile, cout);
    infile.close();
    infile.clear();
    return 0;
}

int main()
{
    std::srand(std::time(nullptr));
    test_xref();
    cout << endl;
    test_generate_sentence();
    cout << endl;
    generate_sentence_list_output("grammar_ch07.txt");
    cout << endl;
    test_count_words();
    cout << endl;

    return 0;
}
显示结果如下
<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

the brown table sits on the stairs

the large large brown absurd cat jumps under the sky

<sentence>      1
absurd  1
brown   1
cat     1
dog     1
it      1
jumps   1
large   1
on      1
sits    1
sky     1
stairs  1
table   1
under   1
wants   1
wherever        1
the     3
<verb>  3
<adjective>     4
<location>      4
<noun-phrase>   4
<noun>  4

7-6 使用两个向量来重新实现gen-sentence程序：
一个向量保存程序生成的那个完全展开的句子；另一个则被用作堆栈，程序将用它来保存规则。在程序中不允许使用任何递归调用。
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <map>
#include <list>
#include <algorithm>
#include <iterator>
#include <utility>
#include <stdexcept>
#include <cstdlib>
#include <ctime>
#include <cctype>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::vector;
using std::string;
using std::map;
using std::multimap;
using std::pair;
using std::list;
using std::getline;
using std::find_if;
using std::search;
using std::copy;
using std::transform;
using std::inserter;
using std::back_inserter;
using std::logic_error;
using std::domain_error;
using std::to_string;
using std::distance;
using std::unique;

typedef std::vector<std::string> Rule;
typedef std::vector<Rule> Rule_collection;
typedef std::map<std::string, Rule_collection> Grammar;

int nrand(int n)
{
    if (n <= 0 || n > RAND_MAX)
    {
        throw domain_error("Argument to nrand is out of range");
    }

    const int bucket_size = RAND_MAX / n;
    int r;

    do
    {
        r = rand() / bucket_size;
    }
    while (r >= n);

    return r;
}

istream &count_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    for (map<string, int>::const_iterator it = counters.begin(); it != counters.end(); ++it)
    {
        os << it->first << "\t" << it->second << endl;
    }

    return is;
}

pair<int, string> flip_count_pair(pair<string, int> p)
{
    return pair<int, string>(p.second, p.first);
}

istream &count_sort_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    multimap<int, string> counters_r;
    transform(counters.begin(), counters.end(), inserter(counters_r, counters_r.begin()), flip_count_pair);

    for (multimap<int, string>::const_iterator it = counters_r.begin(); it != counters_r.end(); ++it)
    {
        os << it->second << "\t" << it->first << endl;
    }

    return is;
}

bool space(char c)
{
    return isspace(c) != 0;
}

bool not_space(char c)
{
    return !isspace(c);
}

vector<string> split(const string &str)
{
    typedef string::const_iterator iter;
    vector<string> ret;

    iter i = str.begin();
    while (i != str.end())
    {

        i = find_if(i, str.end(), not_space);

        iter j = find_if(i, str.end(), space);

        if (i != j)
        {
            ret.push_back(string(i, j));
            i = j;
        }
    }
    return ret;
}

list<string> split_to_list(const string &str)
{
    vector<string> ret = split(str);
    list <string> list;
    copy(ret.begin(), ret.end(), back_inserter(list));

    return list;
}

map<string, vector<int> > xref(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    return ret;
}

map<string, vector<int> > xref_unique(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    for (map<string, vector<int> >::iterator it = ret.begin(); it != ret.end(); ++it)
    {
        it->second.resize( distance(it->second.begin(), unique(it->second.begin(), it->second.end()) ) );
    }

    return ret;
}

bool bracketed(const string &s)
{
    return s.size() > 1 && s[0] == '<' && s[s.size() - 1] == '>';
}

Grammar read_grammar(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        vector<string> entry = split(line);

        if (entry.size() > 1)
        {
            ret[entry[0]].push_back( Rule( entry.begin() + 1, entry.end() ) );
        }
    }

    return ret;
}

Grammar read_grammar_list(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        list<string> entry = split_to_list(line);

        if (entry.size() > 1)
        {
            ret[entry.front()].push_back( Rule( ++entry.begin(), entry.end() ) );
        }
    }

    return ret;
}
void gen_aux(const Grammar &g, const string &word, vector<string> &ret)
{
    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[nrand(c.size())];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}

void gen_aux(const Grammar &g, const string &word, list<string> &ret)
{
    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[nrand(c.size())];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}
vector<string> gen_sentence(const Grammar &g)
{
    vector<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

list<string> gen_sentence_list(const Grammar &g)
{
    list<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

int generate_sentence_list_output(string file)
{
    ifstream infile;
    infile.open(file);
    list<string> sentence = gen_sentence_list(read_grammar_list(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;

    return 0;
}

vector<string> gen_sentence_vectors(const Grammar &g)
{
    vector<string> ret;
    vector<string> rules;

    rules.push_back("<sentence>");

    while (!rules.empty())
    {
        string segment = rules.back();
        rules.pop_back();

        if (!bracketed(segment))
        {
            ret.push_back(segment);
        }
        else
        {

            Grammar::const_iterator it = g.find(segment);

            if (it == g.end())
            {
                throw logic_error("empty rule");
            }

            const Rule_collection &c = it->second;

            const Rule &r = c[nrand(c.size())];

            for (Rule::const_reverse_iterator i = r.rbegin(); i != r.rend(); ++i)
            {
                rules.push_back(*i);
            }
        }
    }

    return ret;
}

int generate_sentence_vectors_output(string file)
{
    ifstream infile;
    infile.open(file);
    vector<string> sentence = gen_sentence_vectors(read_grammar(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;

    return 0;
}

bool not_url_char(char c)
{
    static const string url_ch = "~;/?:@=&$-_.+!*'(),";

    return !(isalnum(c) || find(url_ch.begin(), url_ch.end(), c) != url_ch.end());
}

string::const_iterator url_beg(string::const_iterator b, string::const_iterator e)
{
    static const string sep = "://";

    typedef string::const_iterator iter;

    iter i = b;

    while ( ( i = search(i, e, sep.begin(), sep.end()) ) != e )
    {

        if (i != b && i + sep.size() != e)
        {

            iter beg = i;
            while (beg != b && isalpha(beg[-1]))
            {
                --beg;
            }

            if (beg != i && !not_url_char( i[sep.size()] ))
            {
                return beg;
            }
        }

        i += sep.size();
    }

    return e;
}

string::const_iterator url_end(string::const_iterator b, string::const_iterator e)
{
    return find_if(b, e, not_url_char);
}

vector<string> find_urls(const string &s)
{
    vector<string> ret;
    typedef string::const_iterator iter;
    iter b = s.begin(), e = s.end();

    while (b != e)
    {

        b = url_beg(b, e);

        if (b != e)
        {
            iter after = url_end(b, e);

            ret.push_back(string(b, after));

            b = after;
        }
    }

    return ret;
}

int print_formatted_xref(string file, size_t line_length)
{
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        string s = it->first + " occurs on line(s): ";
        string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
    }

    return 0;
}

int test_xref()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret = xref(infile, split);
    infile.close();
    infile.clear();
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret.begin(); it != ret.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    cout << endl;
    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    return 0;
}

int test_generate_sentence()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    vector<string> sentence = gen_sentence(read_grammar(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;
    return 0;
}

int test_count_words()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    count_sort_words(infile, cout);
    infile.close();
    infile.clear();
    return 0;
}

int main()
{
    std::srand(std::time(nullptr));
    test_xref();
    cout << endl;
    test_generate_sentence();
    cout << endl;
    generate_sentence_list_output("grammar_ch07.txt");
    cout << endl;
    generate_sentence_vectors_output("grammar_ch07.txt");
    cout << endl;
    test_count_words();
    cout << endl;

    return 0;
}
显示结果如下
<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

the brown absurd brown brown brown table sits on the stairs

the dog sits wherever it wants

the brown dog sits under the sky

<sentence>      1
absurd  1
brown   1
cat     1
dog     1
it      1
jumps   1
large   1
on      1
sits    1
sky     1
stairs  1
table   1
under   1
wants   1
wherever        1
the     3
<verb>  3
<adjective>     4
<location>      4
<noun-phrase>   4
<noun>  4

7-7 修改那个交叉引用程序的驱动程序，使它在只有一行时输出line，否则就输出lines。
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <map>
#include <list>
#include <algorithm>
#include <iterator>
#include <utility>
#include <stdexcept>
#include <cstdlib>
#include <ctime>
#include <cctype>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::vector;
using std::string;
using std::map;
using std::multimap;
using std::pair;
using std::list;
using std::getline;
using std::find_if;
using std::search;
using std::copy;
using std::transform;
using std::inserter;
using std::back_inserter;
using std::logic_error;
using std::domain_error;
using std::to_string;
using std::distance;
using std::unique;

typedef std::vector<std::string> Rule;
typedef std::vector<Rule> Rule_collection;
typedef std::map<std::string, Rule_collection> Grammar;

int nrand(int n)
{
    if (n <= 0 || n > RAND_MAX)
    {
        throw domain_error("Argument to nrand is out of range");
    }

    const int bucket_size = RAND_MAX / n;
    int r;

    do
    {
        r = rand() / bucket_size;
    }
    while (r >= n);

    return r;
}

istream &count_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    for (map<string, int>::const_iterator it = counters.begin(); it != counters.end(); ++it)
    {
        os << it->first << "\t" << it->second << endl;
    }

    return is;
}

pair<int, string> flip_count_pair(pair<string, int> p)
{
    return pair<int, string>(p.second, p.first);
}

istream &count_sort_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    multimap<int, string> counters_r;
    transform(counters.begin(), counters.end(), inserter(counters_r, counters_r.begin()), flip_count_pair);

    for (multimap<int, string>::const_iterator it = counters_r.begin(); it != counters_r.end(); ++it)
    {
        os << it->second << "\t" << it->first << endl;
    }

    return is;
}

bool space(char c)
{
    return isspace(c) != 0;
}

bool not_space(char c)
{
    return !isspace(c);
}

vector<string> split(const string &str)
{
    typedef string::const_iterator iter;
    vector<string> ret;

    iter i = str.begin();
    while (i != str.end())
    {

        i = find_if(i, str.end(), not_space);

        iter j = find_if(i, str.end(), space);

        if (i != j)
        {
            ret.push_back(string(i, j));
            i = j;
        }
    }
    return ret;
}

list<string> split_to_list(const string &str)
{
    vector<string> ret = split(str);
    list <string> list;
    copy(ret.begin(), ret.end(), back_inserter(list));

    return list;
}

map<string, vector<int> > xref(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    return ret;
}

map<string, vector<int> > xref_unique(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    for (map<string, vector<int> >::iterator it = ret.begin(); it != ret.end(); ++it)
    {
        it->second.resize( distance(it->second.begin(), unique(it->second.begin(), it->second.end()) ) );
    }

    return ret;
}

bool bracketed(const string &s)
{
    return s.size() > 1 && s[0] == '<' && s[s.size() - 1] == '>';
}

Grammar read_grammar(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        vector<string> entry = split(line);

        if (entry.size() > 1)
        {
            ret[entry[0]].push_back( Rule( entry.begin() + 1, entry.end() ) );
        }
    }

    return ret;
}

Grammar read_grammar_list(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        list<string> entry = split_to_list(line);

        if (entry.size() > 1)
        {
            ret[entry.front()].push_back( Rule( ++entry.begin(), entry.end() ) );
        }
    }

    return ret;
}
void gen_aux(const Grammar &g, const string &word, vector<string> &ret)
{
    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[nrand(c.size())];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}

void gen_aux(const Grammar &g, const string &word, list<string> &ret)
{
    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[nrand(c.size())];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}
vector<string> gen_sentence(const Grammar &g)
{
    vector<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

list<string> gen_sentence_list(const Grammar &g)
{
    list<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

int generate_sentence_list_output(string file)
{
    ifstream infile;
    infile.open(file);
    list<string> sentence = gen_sentence_list(read_grammar_list(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;

    return 0;
}

vector<string> gen_sentence_vectors(const Grammar &g)
{
    vector<string> ret;
    vector<string> rules;

    rules.push_back("<sentence>");

    while (!rules.empty())
    {
        string segment = rules.back();
        rules.pop_back();

        if (!bracketed(segment))
        {
            ret.push_back(segment);
        }
        else
        {

            Grammar::const_iterator it = g.find(segment);

            if (it == g.end())
            {
                throw logic_error("empty rule");
            }

            const Rule_collection &c = it->second;

            const Rule &r = c[nrand(c.size())];

            for (Rule::const_reverse_iterator i = r.rbegin(); i != r.rend(); ++i)
            {
                rules.push_back(*i);
            }
        }
    }

    return ret;
}

int generate_sentence_vectors_output(string file)
{
    ifstream infile;
    infile.open(file);
    vector<string> sentence = gen_sentence_vectors(read_grammar(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;

    return 0;
}

bool not_url_char(char c)
{
    static const string url_ch = "~;/?:@=&$-_.+!*'(),";

    return !(isalnum(c) || find(url_ch.begin(), url_ch.end(), c) != url_ch.end());
}

string::const_iterator url_beg(string::const_iterator b, string::const_iterator e)
{
    static const string sep = "://";

    typedef string::const_iterator iter;

    iter i = b;

    while ( ( i = search(i, e, sep.begin(), sep.end()) ) != e )
    {

        if (i != b && i + sep.size() != e)
        {

            iter beg = i;
            while (beg != b && isalpha(beg[-1]))
            {
                --beg;
            }

            if (beg != i && !not_url_char( i[sep.size()] ))
            {
                return beg;
            }
        }

        i += sep.size();
    }

    return e;
}

string::const_iterator url_end(string::const_iterator b, string::const_iterator e)
{
    return find_if(b, e, not_url_char);
}

vector<string> find_urls(const string &s)
{
    vector<string> ret;
    typedef string::const_iterator iter;
    iter b = s.begin(), e = s.end();

    while (b != e)
    {

        b = url_beg(b, e);

        if (b != e)
        {
            iter after = url_end(b, e);

            ret.push_back(string(b, after));

            b = after;
        }
    }

    return ret;
}

int print_formatted_xref(string file, size_t line_length)
{
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        string s = it->first + " occurs on line(s): ";
        string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
    }

    return 0;
}

int print_formatted_line_xref(string file, size_t line_length)
{
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        string line = it->second.size() > 1 ? "lines" : "line";
        string s = it->first + " occurs on " + line + ": ";
        string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
    }

    return 0;
}

int test_xref()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret = xref(infile, split);
    infile.close();
    infile.clear();
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret.begin(); it != ret.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    cout << endl;
    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    return 0;
}

int test_generate_sentence()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    vector<string> sentence = gen_sentence(read_grammar(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;
    return 0;
}

int test_count_words()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    count_sort_words(infile, cout);
    infile.close();
    infile.clear();
    return 0;
}

int main()
{
    std::srand(std::time(nullptr));
    test_xref();
    cout << endl;
    test_generate_sentence();
    cout << endl;
    generate_sentence_list_output("grammar_ch07.txt");
    cout << endl;
    generate_sentence_vectors_output("grammar_ch07.txt");
    cout << endl;
    test_count_words();
    cout << endl;
    print_formatted_line_xref("grammar_ch07.txt", 60);
    return 0;
}
显示结果如下

<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

the large large absurd brown absurd cat jumps wherever it wants

the dog sits wherever it wants

the table sits wherever it wants

<sentence>      1
absurd  1
brown   1
cat     1
dog     1
it      1
jumps   1
large   1
on      1
sits    1
sky     1
stairs  1
table   1
under   1
wants   1
wherever        1
the     3
<verb>  3
<adjective>     4
<location>      4
<noun-phrase>   4
<noun>  4

<adjective> occurs on lines: 5, 6, 7, 8
<location> occurs on lines: 11, 12, 13, 14
<noun-phrase> occurs on lines: 4, 5, 14
<noun> occurs on lines: 1, 2, 3, 4
<sentence> occurs on line: 14
<verb> occurs on lines: 9, 10, 14
absurd occurs on line: 8
brown occurs on line: 7
cat occurs on line: 1
dog occurs on line: 2
it occurs on line: 13
jumps occurs on line: 9
large occurs on line: 6
on occurs on line: 11
sits occurs on line: 10
sky occurs on line: 12
stairs occurs on line: 11
table occurs on line: 3
the occurs on lines: 11, 12, 14
under occurs on line: 12
wants occurs on line: 13
wherever occurs on line: 13

7-8 修改那个交叉引用程序以查找一个文件中的所有URL，并且输出每一个不同的URL在其中出现的所有行。
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <map>
#include <list>
#include <algorithm>
#include <iterator>
#include <utility>
#include <stdexcept>
#include <cstdlib>
#include <ctime>
#include <cctype>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::vector;
using std::string;
using std::map;
using std::multimap;
using std::pair;
using std::list;
using std::getline;
using std::find_if;
using std::search;
using std::copy;
using std::transform;
using std::inserter;
using std::back_inserter;
using std::logic_error;
using std::domain_error;
using std::to_string;
using std::distance;
using std::unique;

typedef std::vector<std::string> Rule;
typedef std::vector<Rule> Rule_collection;
typedef std::map<std::string, Rule_collection> Grammar;

int nrand(int n)
{
    if (n <= 0 || n > RAND_MAX)
    {
        throw domain_error("Argument to nrand is out of range");
    }

    const int bucket_size = RAND_MAX / n;
    int r;

    do
    {
        r = rand() / bucket_size;
    }
    while (r >= n);

    return r;
}

istream &count_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    for (map<string, int>::const_iterator it = counters.begin(); it != counters.end(); ++it)
    {
        os << it->first << "\t" << it->second << endl;
    }

    return is;
}

pair<int, string> flip_count_pair(pair<string, int> p)
{
    return pair<int, string>(p.second, p.first);
}

istream &count_sort_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    multimap<int, string> counters_r;
    transform(counters.begin(), counters.end(), inserter(counters_r, counters_r.begin()), flip_count_pair);

    for (multimap<int, string>::const_iterator it = counters_r.begin(); it != counters_r.end(); ++it)
    {
        os << it->second << "\t" << it->first << endl;
    }

    return is;
}

bool space(char c)
{
    return isspace(c) != 0;
}

bool not_space(char c)
{
    return !isspace(c);
}

vector<string> split(const string &str)
{
    typedef string::const_iterator iter;
    vector<string> ret;

    iter i = str.begin();
    while (i != str.end())
    {

        i = find_if(i, str.end(), not_space);

        iter j = find_if(i, str.end(), space);

        if (i != j)
        {
            ret.push_back(string(i, j));
            i = j;
        }
    }
    return ret;
}

list<string> split_to_list(const string &str)
{
    vector<string> ret = split(str);
    list <string> list;
    copy(ret.begin(), ret.end(), back_inserter(list));

    return list;
}

map<string, vector<int> > xref(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    return ret;
}

map<string, vector<int> > xref_unique(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    for (map<string, vector<int> >::iterator it = ret.begin(); it != ret.end(); ++it)
    {
        it->second.resize( distance(it->second.begin(), unique(it->second.begin(), it->second.end()) ) );
    }

    return ret;
}

bool bracketed(const string &s)
{
    return s.size() > 1 && s[0] == '<' && s[s.size() - 1] == '>';
}

Grammar read_grammar(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        vector<string> entry = split(line);

        if (entry.size() > 1)
        {
            ret[entry[0]].push_back( Rule( entry.begin() + 1, entry.end() ) );
        }
    }

    return ret;
}

Grammar read_grammar_list(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        list<string> entry = split_to_list(line);

        if (entry.size() > 1)
        {
            ret[entry.front()].push_back( Rule( ++entry.begin(), entry.end() ) );
        }
    }

    return ret;
}
void gen_aux(const Grammar &g, const string &word, vector<string> &ret)
{
    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[nrand(c.size())];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}

void gen_aux(const Grammar &g, const string &word, list<string> &ret)
{
    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[nrand(c.size())];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}
vector<string> gen_sentence(const Grammar &g)
{
    vector<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

list<string> gen_sentence_list(const Grammar &g)
{
    list<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

int generate_sentence_list_output(string file)
{
    ifstream infile;
    infile.open(file);
    list<string> sentence = gen_sentence_list(read_grammar_list(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;

    return 0;
}

vector<string> gen_sentence_vectors(const Grammar &g)
{
    vector<string> ret;
    vector<string> rules;

    rules.push_back("<sentence>");

    while (!rules.empty())
    {
        string segment = rules.back();
        rules.pop_back();

        if (!bracketed(segment))
        {
            ret.push_back(segment);
        }
        else
        {

            Grammar::const_iterator it = g.find(segment);

            if (it == g.end())
            {
                throw logic_error("empty rule");
            }

            const Rule_collection &c = it->second;

            const Rule &r = c[nrand(c.size())];

            for (Rule::const_reverse_iterator i = r.rbegin(); i != r.rend(); ++i)
            {
                rules.push_back(*i);
            }
        }
    }

    return ret;
}

int generate_sentence_vectors_output(string file)
{
    ifstream infile;
    infile.open(file);
    vector<string> sentence = gen_sentence_vectors(read_grammar(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;

    return 0;
}

bool not_url_char(char c)
{
    static const string url_ch = "~;/?:@=&$-_.+!*'(),";

    return !(isalnum(c) || find(url_ch.begin(), url_ch.end(), c) != url_ch.end());
}

string::const_iterator url_beg(string::const_iterator b, string::const_iterator e)
{
    static const string sep = "://";

    typedef string::const_iterator iter;

    iter i = b;

    while ( ( i = search(i, e, sep.begin(), sep.end()) ) != e )
    {

        if (i != b && i + sep.size() != e)
        {

            iter beg = i;
            while (beg != b && isalpha(beg[-1]))
            {
                --beg;
            }

            if (beg != i && !not_url_char( i[sep.size()] ))
            {
                return beg;
            }
        }

        i += sep.size();
    }

    return e;
}

string::const_iterator url_end(string::const_iterator b, string::const_iterator e)
{
    return find_if(b, e, not_url_char);
}

vector<string> find_urls(const string &s)
{
    vector<string> ret;
    typedef string::const_iterator iter;
    iter b = s.begin(), e = s.end();

    while (b != e)
    {

        b = url_beg(b, e);

        if (b != e)
        {
            iter after = url_end(b, e);

            ret.push_back(string(b, after));

            b = after;
        }
    }

    return ret;
}

int print_formatted_xref(string file, size_t line_length)
{
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        string s = it->first + " occurs on line(s): ";
        string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
    }

    return 0;
}

int print_formatted_line_xref(string file, size_t line_length)
{
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        string line = it->second.size() > 1 ? "lines" : "line";
        string s = it->first + " occurs on " + line + ": ";
        string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
    }

    return 0;
}

int print_xref_urls(string file, size_t line_length)
{
  ifstream infile;
  infile.open(file);
  map<string, vector<int> > ret_uniq = xref_unique(infile, find_urls);
  infile.close();
  infile.clear();
  for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
  {
    string line = it->second.size() > 1 ? "lines" : "line";
    string s = it->first + " occurs on " + line + ": ";
    string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
  }

  return 0;
}

int test_xref()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret = xref(infile, split);
    infile.close();
    infile.clear();
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret.begin(); it != ret.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    cout << endl;
    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    return 0;
}

int test_generate_sentence()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    vector<string> sentence = gen_sentence(read_grammar(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;
    return 0;
}

int test_count_words()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    count_sort_words(infile, cout);
    infile.close();
    infile.clear();
    return 0;
}

int main()
{
    std::srand(std::time(nullptr));
    test_xref();
    cout << endl;
    test_generate_sentence();
    cout << endl;
    generate_sentence_list_output("grammar_ch07.txt");
    cout << endl;
    generate_sentence_vectors_output("grammar_ch07.txt");
    cout << endl;
    test_count_words();
    cout << endl;
    print_formatted_line_xref("grammar_ch07.txt", 60);
    cout << endl;
    print_xref_urls("urls_ch07.txt", 60);
    return 0;
}
显示结果如下
<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

the cat sits wherever it wants

the dog jumps on the stairs

the cat sits on the stairs

<sentence>      1
absurd  1
brown   1
cat     1
dog     1
it      1
jumps   1
large   1
on      1
sits    1
sky     1
stairs  1
table   1
under   1
wants   1
wherever        1
the     3
<verb>  3
<adjective>     4
<location>      4
<noun-phrase>   4
<noun>  4

<adjective> occurs on lines: 5, 6, 7, 8
<location> occurs on lines: 11, 12, 13, 14
<noun-phrase> occurs on lines: 4, 5, 14
<noun> occurs on lines: 1, 2, 3, 4
<sentence> occurs on line: 14
<verb> occurs on lines: 9, 10, 14
absurd occurs on line: 8
brown occurs on line: 7
cat occurs on line: 1
dog occurs on line: 2
it occurs on line: 13
jumps occurs on line: 9
large occurs on line: 6
on occurs on line: 11
sits occurs on line: 10
sky occurs on line: 12
stairs occurs on line: 11
table occurs on line: 3
the occurs on lines: 11, 12, 14
under occurs on line: 12
wants occurs on line: 13
wherever occurs on line: 13

ftp://www.telenet.be occurs on line: 5
http://www.amazon.com occurs on lines: 2, 6, 7
http://www.disneyland.com occurs on line: 4
http://www.google.be occurs on lines: 1, 4

7-9 在7.4.4中，nrand的实现在参数大于RAND_MAX的时候将会失效。通常，这个限制是不会有问题的，
因为在一般情况下，无论如何RAND_MAX都能等于可能存在的最大的整数。然而，在某些系统环境中RAND_MAX会比可能存在的最大的整数小得多。
例如，RAND_MAX等于32767，而可能存在的最大的整数等于2147483647的例子并不少见。重新实现nrand，使它对所有的n都能表现良好。
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <map>
#include <list>
#include <algorithm>
#include <iterator>
#include <utility>
#include <chrono>
#include <random>
#include <stdexcept>
#include <cstdlib>
#include <ctime>
#include <cctype>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::vector;
using std::string;
using std::map;
using std::multimap;
using std::pair;
using std::list;
using std::getline;
using std::find_if;
using std::search;
using std::copy;
using std::transform;
using std::inserter;
using std::back_inserter;
using std::logic_error;
using std::domain_error;
using std::to_string;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

typedef std::vector<std::string> Rule;
typedef std::vector<Rule> Rule_collection;
typedef std::map<std::string, Rule_collection> Grammar;

int nrand(int n)
{
    if (n <= 0 || n > RAND_MAX)
    {
        throw domain_error("Argument to nrand is out of range");
    }

    const int bucket_size = RAND_MAX / n;
    int r;

    do
    {
        r = rand() / bucket_size;
    }
    while (r >= n);

    return r;
}

int nrand_improved(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n-1);
    return d(e);
}

istream &count_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    for (map<string, int>::const_iterator it = counters.begin(); it != counters.end(); ++it)
    {
        os << it->first << "\t" << it->second << endl;
    }

    return is;
}

pair<int, string> flip_count_pair(pair<string, int> p)
{
    return pair<int, string>(p.second, p.first);
}

istream &count_sort_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    multimap<int, string> counters_r;
    transform(counters.begin(), counters.end(), inserter(counters_r, counters_r.begin()), flip_count_pair);

    for (multimap<int, string>::const_iterator it = counters_r.begin(); it != counters_r.end(); ++it)
    {
        os << it->second << "\t" << it->first << endl;
    }

    return is;
}

bool space(char c)
{
    return isspace(c) != 0;
}

bool not_space(char c)
{
    return !isspace(c);
}

vector<string> split(const string &str)
{
    typedef string::const_iterator iter;
    vector<string> ret;

    iter i = str.begin();
    while (i != str.end())
    {

        i = find_if(i, str.end(), not_space);

        iter j = find_if(i, str.end(), space);

        if (i != j)
        {
            ret.push_back(string(i, j));
            i = j;
        }
    }
    return ret;
}

list<string> split_to_list(const string &str)
{
    vector<string> ret = split(str);
    list <string> list;
    copy(ret.begin(), ret.end(), back_inserter(list));

    return list;
}

map<string, vector<int> > xref(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    return ret;
}

map<string, vector<int> > xref_unique(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    for (map<string, vector<int> >::iterator it = ret.begin(); it != ret.end(); ++it)
    {
        it->second.resize( distance(it->second.begin(), unique(it->second.begin(), it->second.end()) ) );
    }

    return ret;
}

bool bracketed(const string &s)
{
    return s.size() > 1 && s[0] == '<' && s[s.size() - 1] == '>';
}

Grammar read_grammar(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        vector<string> entry = split(line);

        if (entry.size() > 1)
        {
            ret[entry[0]].push_back( Rule( entry.begin() + 1, entry.end() ) );
        }
    }

    return ret;
}

Grammar read_grammar_list(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        list<string> entry = split_to_list(line);

        if (entry.size() > 1)
        {
            ret[entry.front()].push_back( Rule( ++entry.begin(), entry.end() ) );
        }
    }

    return ret;
}
void gen_aux(const Grammar &g, const string &word, vector<string> &ret)
{
    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[nrand(c.size())];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}

void gen_aux(const Grammar &g, const string &word, list<string> &ret)
{
    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[nrand(c.size())];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}
vector<string> gen_sentence(const Grammar &g)
{
    vector<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

list<string> gen_sentence_list(const Grammar &g)
{
    list<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

int generate_sentence_list_output(string file)
{
    ifstream infile;
    infile.open(file);
    list<string> sentence = gen_sentence_list(read_grammar_list(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;

    return 0;
}

vector<string> gen_sentence_vectors(const Grammar &g)
{
    vector<string> ret;
    vector<string> rules;

    rules.push_back("<sentence>");

    while (!rules.empty())
    {
        string segment = rules.back();
        rules.pop_back();

        if (!bracketed(segment))
        {
            ret.push_back(segment);
        }
        else
        {

            Grammar::const_iterator it = g.find(segment);

            if (it == g.end())
            {
                throw logic_error("empty rule");
            }

            const Rule_collection &c = it->second;

            const Rule &r = c[nrand(c.size())];

            for (Rule::const_reverse_iterator i = r.rbegin(); i != r.rend(); ++i)
            {
                rules.push_back(*i);
            }
        }
    }

    return ret;
}

int generate_sentence_vectors_output(string file)
{
    ifstream infile;
    infile.open(file);
    vector<string> sentence = gen_sentence_vectors(read_grammar(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;

    return 0;
}

bool not_url_char(char c)
{
    static const string url_ch = "~;/?:@=&$-_.+!*'(),";

    return !(isalnum(c) || find(url_ch.begin(), url_ch.end(), c) != url_ch.end());
}

string::const_iterator url_beg(string::const_iterator b, string::const_iterator e)
{
    static const string sep = "://";

    typedef string::const_iterator iter;

    iter i = b;

    while ( ( i = search(i, e, sep.begin(), sep.end()) ) != e )
    {

        if (i != b && i + sep.size() != e)
        {

            iter beg = i;
            while (beg != b && isalpha(beg[-1]))
            {
                --beg;
            }

            if (beg != i && !not_url_char( i[sep.size()] ))
            {
                return beg;
            }
        }

        i += sep.size();
    }

    return e;
}

string::const_iterator url_end(string::const_iterator b, string::const_iterator e)
{
    return find_if(b, e, not_url_char);
}

vector<string> find_urls(const string &s)
{
    vector<string> ret;
    typedef string::const_iterator iter;
    iter b = s.begin(), e = s.end();

    while (b != e)
    {

        b = url_beg(b, e);

        if (b != e)
        {
            iter after = url_end(b, e);

            ret.push_back(string(b, after));

            b = after;
        }
    }

    return ret;
}

int print_formatted_xref(string file, size_t line_length)
{
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        string s = it->first + " occurs on line(s): ";
        string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
    }

    return 0;
}

int print_formatted_line_xref(string file, size_t line_length)
{
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        string line = it->second.size() > 1 ? "lines" : "line";
        string s = it->first + " occurs on " + line + ": ";
        string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
    }

    return 0;
}

int print_xref_urls(string file, size_t line_length)
{
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, find_urls);
    infile.close();
    infile.clear();
    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        string line = it->second.size() > 1 ? "lines" : "line";
        string s = it->first + " occurs on " + line + ": ";
        string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
    }

    return 0;
}

int test_xref()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret = xref(infile, split);
    infile.close();
    infile.clear();
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret.begin(); it != ret.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    cout << endl;
    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    return 0;
}

int test_generate_sentence()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    vector<string> sentence = gen_sentence(read_grammar(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;
    return 0;
}

int test_count_words()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    count_sort_words(infile, cout);
    infile.close();
    infile.clear();
    return 0;
}

int main()
{
    std::srand(std::time(nullptr));
    test_xref();
    cout << endl;
    test_generate_sentence();
    cout << endl;
    generate_sentence_list_output("grammar_ch07.txt");
    cout << endl;
    generate_sentence_vectors_output("grammar_ch07.txt");
    cout << endl;
    test_count_words();
    cout << endl;
    print_formatted_line_xref("grammar_ch07.txt", 60);
    cout << endl;
    print_xref_urls("urls_ch07.txt", 60);
    cout << endl;
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);
    for (int i = 0; i < 100; i++)
    {
        cout << nrand_improved(100, engine) << endl;
    }
    return 0;
}
显示结果如下
<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

the large brown table jumps wherever it wants

the dog sits under the sky

the absurd brown large brown brown table sits wherever it wants

<sentence>      1
absurd  1
brown   1
cat     1
dog     1
it      1
jumps   1
large   1
on      1
sits    1
sky     1
stairs  1
table   1
under   1
wants   1
wherever        1
the     3
<verb>  3
<adjective>     4
<location>      4
<noun-phrase>   4
<noun>  4

<adjective> occurs on lines: 5, 6, 7, 8
<location> occurs on lines: 11, 12, 13, 14
<noun-phrase> occurs on lines: 4, 5, 14
<noun> occurs on lines: 1, 2, 3, 4
<sentence> occurs on line: 14
<verb> occurs on lines: 9, 10, 14
absurd occurs on line: 8
brown occurs on line: 7
cat occurs on line: 1
dog occurs on line: 2
it occurs on line: 13
jumps occurs on line: 9
large occurs on line: 6
on occurs on line: 11
sits occurs on line: 10
sky occurs on line: 12
stairs occurs on line: 11
table occurs on line: 3
the occurs on lines: 11, 12, 14
under occurs on line: 12
wants occurs on line: 13
wherever occurs on line: 13

ftp://www.telenet.be occurs on line: 5
http://www.amazon.com occurs on lines: 2, 6, 7
http://www.disneyland.com occurs on line: 4
http://www.google.be occurs on lines: 1, 4

30
72
92
18
17
35
69
95
30
17
40
67
34
88
65
16
28
63
8
26
15
80
20
87
48
49
42
14
24
69
19
90
63
65
73
14
81
10
11
68
92
57
42
84
59
32
73
94
89
71
12
99
4
39
8
45
79
72
6
24
6
28
84
17
70
83
29
97
32
6
67
81
4
24
16
76
42
87
51
79
42
28
58
27
17
34
99
15
56
67
9
86
88
98
73
50
14
80
89
12

第8章 编写泛型函数
8.1 泛型函数是什么？
8.2 数据结构独立性
8.3 输入输出选代器
8.4 用迭代器来提高适应性
8.5 小结
习题
8-0编译、运行并测试本章中的程序。
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <map>
#include <list>
#include <algorithm>
#include <numeric>
#include <iterator>
#include <utility>
#include <chrono>
#include <random>
#include <stdexcept>
#include <cstdlib>
#include <ctime>
#include <cctype>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::vector;
using std::string;
using std::map;
using std::multimap;
using std::pair;
using std::list;
using std::getline;
using std::find_if;
using std::search;
using std::copy;
using std::sort;
using std::transform;
using std::accumulate;
using std::inserter;
using std::istream_iterator;
using std::ostream_iterator;
using std::back_inserter;
using std::logic_error;
using std::domain_error;
using std::to_string;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

typedef std::vector<std::string> Rule;
typedef std::vector<Rule> Rule_collection;
typedef std::map<std::string, Rule_collection> Grammar;

template<typename T>
T median(vector<T> v)
{
    typedef typename vector<T>::size_type vec_sz;
    vec_sz size = v.size();
    if (size == 0)
    {
        throw domain_error("median of an empty vector");
    }
    sort(v.begin(), v.end());

    vec_sz mid = size / 2;
    return size % 2 == 0 ? (v[mid] + v[mid - 1]) / 2 : v[mid];
}

inline double average(const vector<double> &v)
{
    return accumulate(v.begin(), v.end(), 0.0) / v.size();
}

int nrand(int n)
{
    if (n <= 0 || n > RAND_MAX)
    {
        throw domain_error("Argument to nrand is out of range");
    }

    const int bucket_size = RAND_MAX / n;
    int r;

    do
    {
        r = rand() / bucket_size;
    }
    while (r >= n);

    return r;
}

int nrand_improved(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

istream &count_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    for (map<string, int>::const_iterator it = counters.begin(); it != counters.end(); ++it)
    {
        os << it->first << "\t" << it->second << endl;
    }

    return is;
}

pair<int, string> flip_count_pair(pair<string, int> p)
{
    return pair<int, string>(p.second, p.first);
}

istream &count_sort_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    multimap<int, string> counters_r;
    transform(counters.begin(), counters.end(), inserter(counters_r, counters_r.begin()), flip_count_pair);

    for (multimap<int, string>::const_iterator it = counters_r.begin(); it != counters_r.end(); ++it)
    {
        os << it->second << "\t" << it->first << endl;
    }

    return is;
}

bool space(char c)
{
    return isspace(c) != 0;
}

bool not_space(char c)
{
    return !isspace(c);
}

vector<string> split(const string &str)
{
    typedef string::const_iterator iter;
    vector<string> ret;

    iter i = str.begin();
    while (i != str.end())
    {

        i = find_if(i, str.end(), not_space);

        iter j = find_if(i, str.end(), space);

        if (i != j)
        {
            ret.push_back(string(i, j));
            i = j;
        }
    }
    return ret;
}

list<string> split_to_list(const string &str)
{
    vector<string> ret = split(str);
    list <string> list;
    copy(ret.begin(), ret.end(), back_inserter(list));

    return list;
}

template <typename T>
void split(const string &str, T os)
{
    typedef string::const_iterator iter;
    iter i = str.begin();
    while (i != str.end())
    {
        i = std::find_if(i, str.end(), not_space);

        iter j = std::find_if(i, str.end(), space);

        if (i != j)
        {
            *os++ = string(i, j);
            i = j;
        }
    }
}

map<string, vector<int> > xref(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    return ret;
}

map<string, vector<int> > xref_unique(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    for (map<string, vector<int> >::iterator it = ret.begin(); it != ret.end(); ++it)
    {
        it->second.resize( distance(it->second.begin(), unique(it->second.begin(), it->second.end()) ) );
    }

    return ret;
}

bool bracketed(const string &s)
{
    return s.size() > 1 && s[0] == '<' && s[s.size() - 1] == '>';
}

Grammar read_grammar(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        vector<string> entry = split(line);

        if (entry.size() > 1)
        {
            ret[entry[0]].push_back( Rule( entry.begin() + 1, entry.end() ) );
        }
    }

    return ret;
}

Grammar read_grammar_list(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        list<string> entry = split_to_list(line);

        if (entry.size() > 1)
        {
            ret[entry.front()].push_back( Rule( ++entry.begin(), entry.end() ) );
        }
    }

    return ret;
}
void gen_aux(const Grammar &g, const string &word, vector<string> &ret)
{
    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[nrand(c.size())];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}

void gen_aux(const Grammar &g, const string &word, list<string> &ret)
{
    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[nrand(c.size())];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}
vector<string> gen_sentence(const Grammar &g)
{
    vector<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

list<string> gen_sentence_list(const Grammar &g)
{
    list<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

int generate_sentence_list_output(string file)
{
    ifstream infile;
    infile.open(file);
    list<string> sentence = gen_sentence_list(read_grammar_list(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;

    return 0;
}

vector<string> gen_sentence_vectors(const Grammar &g)
{
    vector<string> ret;
    vector<string> rules;

    rules.push_back("<sentence>");

    while (!rules.empty())
    {
        string segment = rules.back();
        rules.pop_back();

        if (!bracketed(segment))
        {
            ret.push_back(segment);
        }
        else
        {

            Grammar::const_iterator it = g.find(segment);

            if (it == g.end())
            {
                throw logic_error("empty rule");
            }

            const Rule_collection &c = it->second;

            const Rule &r = c[nrand(c.size())];

            for (Rule::const_reverse_iterator i = r.rbegin(); i != r.rend(); ++i)
            {
                rules.push_back(*i);
            }
        }
    }

    return ret;
}

int generate_sentence_vectors_output(string file)
{
    ifstream infile;
    infile.open(file);
    vector<string> sentence = gen_sentence_vectors(read_grammar(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;

    return 0;
}

bool not_url_char(char c)
{
    static const string url_ch = "~;/?:@=&$-_.+!*'(),";

    return !(isalnum(c) || find(url_ch.begin(), url_ch.end(), c) != url_ch.end());
}

string::const_iterator url_beg(string::const_iterator b, string::const_iterator e)
{
    static const string sep = "://";

    typedef string::const_iterator iter;

    iter i = b;

    while ( ( i = search(i, e, sep.begin(), sep.end()) ) != e )
    {

        if (i != b && i + sep.size() != e)
        {

            iter beg = i;
            while (beg != b && isalpha(beg[-1]))
            {
                --beg;
            }

            if (beg != i && !not_url_char( i[sep.size()] ))
            {
                return beg;
            }
        }

        i += sep.size();
    }

    return e;
}

string::const_iterator url_end(string::const_iterator b, string::const_iterator e)
{
    return find_if(b, e, not_url_char);
}

vector<string> find_urls(const string &s)
{
    vector<string> ret;
    typedef string::const_iterator iter;
    iter b = s.begin(), e = s.end();

    while (b != e)
    {

        b = url_beg(b, e);

        if (b != e)
        {
            iter after = url_end(b, e);

            ret.push_back(string(b, after));

            b = after;
        }
    }

    return ret;
}

int print_formatted_xref(string file, size_t line_length)
{
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        string s = it->first + " occurs on line(s): ";
        string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
    }

    return 0;
}

int print_formatted_line_xref(string file, size_t line_length)
{
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        string line = it->second.size() > 1 ? "lines" : "line";
        string s = it->first + " occurs on " + line + ": ";
        string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
    }

    return 0;
}

int print_xref_urls(string file, size_t line_length)
{
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, find_urls);
    infile.close();
    infile.clear();
    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        string line = it->second.size() > 1 ? "lines" : "line";
        string s = it->first + " occurs on " + line + ": ";
        string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
    }

    return 0;
}

int test_xref()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret = xref(infile, split);
    infile.close();
    infile.clear();
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret.begin(); it != ret.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    cout << endl;
    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    return 0;
}

int test_generate_sentence()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    vector<string> sentence = gen_sentence(read_grammar(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;
    return 0;
}

int test_count_words()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    count_sort_words(infile, cout);
    infile.close();
    infile.clear();
    return 0;
}

int test_split()
{
    cout << "Enter lines to split: " << endl;
    string s;
    while (getline(cin, s, '\n'))
    {
        split(s, ostream_iterator<string, char>(cout, "\n"));
    }
    return 0;
}

void test_stream_iterators()
{
    cout << "Enter a few integers: ";

    vector<int> v;
    copy(istream_iterator<int>(cin), istream_iterator<int>(), back_inserter(v));
    cout << endl;

    copy(v.begin(), v.end(), ostream_iterator<int>(cout, " "));
    cout << endl;
}

void test_median()
{
    vector<double> v_double = { 12.5, 16.3, 25.7 };
    cout << median(v_double) << endl;

    vector<int> v_int = { 12, 25, 16, 30 };
    cout << median(v_int) << endl;
}

int main()
{
    std::srand(std::time(nullptr));
    test_xref();
    cout << endl;
    test_generate_sentence();
    cout << endl;
    generate_sentence_list_output("grammar_ch07.txt");
    cout << endl;
    generate_sentence_vectors_output("grammar_ch07.txt");
    cout << endl;
    test_count_words();
    cout << endl;
    print_formatted_line_xref("grammar_ch07.txt", 60);
    cout << endl;
    print_xref_urls("urls_ch07.txt", 60);
    cout << endl;
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);
    for (int i = 0; i < 10; i++)
    {
        cout << nrand_improved(100, engine) << endl;
    }
    cout << endl;
    test_median();
    test_stream_iterators();
    cin.clear();
    while (cin.get() != '\n')
    {
        continue;
    }
    test_split();
    return 0;
}
显示结果如下

<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

the cat sits wherever it wants

the brown cat sits under the sky

the large dog jumps on the stairs

<sentence>      1
absurd  1
brown   1
cat     1
dog     1
it      1
jumps   1
large   1
on      1
sits    1
sky     1
stairs  1
table   1
under   1
wants   1
wherever        1
the     3
<verb>  3
<adjective>     4
<location>      4
<noun-phrase>   4
<noun>  4

<adjective> occurs on lines: 5, 6, 7, 8
<location> occurs on lines: 11, 12, 13, 14
<noun-phrase> occurs on lines: 4, 5, 14
<noun> occurs on lines: 1, 2, 3, 4
<sentence> occurs on line: 14
<verb> occurs on lines: 9, 10, 14
absurd occurs on line: 8
brown occurs on line: 7
cat occurs on line: 1
dog occurs on line: 2
it occurs on line: 13
jumps occurs on line: 9
large occurs on line: 6
on occurs on line: 11
sits occurs on line: 10
sky occurs on line: 12
stairs occurs on line: 11
table occurs on line: 3
the occurs on lines: 11, 12, 14
under occurs on line: 12
wants occurs on line: 13
wherever occurs on line: 13

ftp://www.telenet.be occurs on line: 5
http://www.amazon.com occurs on lines: 2, 6, 7
http://www.disneyland.com occurs on line: 4
http://www.google.be occurs on lines: 1, 4

93
24
66
35
64
98
21
43
58
38

16.3
20
Enter a few integers: 1 2 3 4 5 6 7 8 9 q

1 2 3 4 5 6 7 8 9
Enter lines to split:
Peter Smith Mike Pence Hello World
Peter
Smith
Mike
Pence
Hello
World

8-1 注意一下，我们在6.2中编写的各个analysis函数都具有同样的行为特性；这些函数的差异在于：它们调用了不同的函数来计算总成绩。
编写一个模板函数，根据计算成绩函数的类型而对这个函数进行参数化，并且用这个函数来评估那些计算成绩方案。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ifstream;
using std::ostream;
using std::stringstream;
using std::vector;
using std::string;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::remove_if;
using std::remove_copy_if;
using std::remove_copy;
using std::stable_partition;
using std::sort;
using std::accumulate;
using std::find;
using std::streamsize;
using std::setprecision;
using std::max;
using std::map;

struct Student_info
{
    std::string name;
    std::vector<double> homework;
    double midterm;
    double final;
};

template<typename T>
T median(vector<T> v)
{
  typedef typename vector<T>::size_type vec_sz;
  vec_sz size = v.size();
  if (size == 0)
  {
    throw domain_error("median of empty vector");
  }
  std::sort(v.begin(), v.end());

  vec_sz mid = size / 2;
  return size % 2 == 0 ? (v[mid] + v[mid - 1]) / 2 : v[mid];
}

inline double average(const vector<double>& v)
{
  return accumulate(v.begin(), v.end(), 0.0) / v.size();
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const std::vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

double grade(const Student_info &s)
{
    return grade(s.midterm, s.final, s.homework);
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name < y.name;
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

istream &read(istream &is, Student_info &s)
{
    is >> s.name >> s.midterm >> s.final;
    read_hw(is, s.homework);

    return is;
}

istream &read(istream &is, vector<Student_info> &v)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student;
        read(ss, student);
        v.push_back(student);
    }

    return is;
}

bool did_all_hw(const Student_info &s)
{
    return ( find(s.homework.begin(), s.homework.end(), 0) == s.homework.end() );
}

bool fgrade(const Student_info &s)
{
    return grade(s) < 60;
}

bool pgrade(const Student_info &s)
{
    return !fgrade(s);
}

double grade_aux(const Student_info &s)
{
    try
    {
        return grade(s);
    }
    catch (domain_error)
    {
        return grade(s.midterm, s.final, 0);
    }
}

double median_analysis(const vector<Student_info> &students)
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), grade_aux);
    return median(grades);
}

double average_grade(const Student_info &s)
{
    return grade(s.midterm, s.final, average(s.homework));
}

double average_analysis(const vector<Student_info> &students)
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), average_grade);
    return median(grades);
}

double optimistic_median(const Student_info &s)
{
    vector<double> nonzero;

    remove_copy(s.homework.begin(), s.homework.end(), back_inserter(nonzero), 0);

    if (nonzero.empty())
    {
        return grade(s.midterm, s.final, 0);
    }
    else
    {
        return grade(s.midterm, s.final, median(nonzero));
    }
}

double optimistic_median_analysis(const vector<Student_info> &students)
{
    vector<double> grades;
    transform(students.begin(), students.end(), back_inserter(grades), optimistic_median);
    return median(grades);
}

void write_analysis(ostream &out, const string &name, double method(const vector<Student_info> &),
                    const vector<Student_info> &did, const vector<Student_info> &didnt)
{
    out << name << ": median(did) = " << method(did) << ", median(didnt) = " << method(didnt) << endl;
}

template <typename T>
double analysis(const vector<Student_info>& students, T grading_method)
{
  vector<double> grades;
  transform(students.begin(), students.end(), back_inserter(grades), grading_method);
  return median(grades);
}

template <typename T>
void write_analysis(ostream& out, const string& name, T grading_method,
                    const vector<Student_info>& did, const vector<Student_info>& didnt)
{
  out << name << ": median(did) = " << analysis(did, grading_method) << ", median(didnt) = " << analysis(didnt, grading_method) << endl;
}

vector<Student_info> extract_fails(vector<Student_info> &students)
{
    vector<Student_info> fail;
    remove_copy_if(students.begin(), students.end(), back_inserter(fail), pgrade);
    students.erase(remove_if(students.begin(), students.end(), fgrade), students.end());

    return fail;
}

vector<Student_info> extract_not_all_hw(vector<Student_info> &students)
{
    vector<Student_info>::iterator iter = stable_partition(students.begin(), students.end(), did_all_hw);
    vector<Student_info> not_all_hw(iter, students.end());
    students.erase(iter, students.end());

    return not_all_hw;
}

vector<Student_info> extract(vector<Student_info> &students, bool criteria(const Student_info &))
{
    vector<Student_info>::iterator iter = stable_partition(students.begin(), students.end(), criteria);
    vector<Student_info> extracted(iter, students.end());
    students.erase(iter, students.end());

    return extracted;
}
istream &read_and_grade(istream &is, vector<Student_info> &students)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];
    string::size_type maxlen = 0;

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student;
        read(ss, student);
        maxlen = max(maxlen, student.name.size());
        students.push_back(student);
    }
    sort(students.begin(), students.end(), compare);
    for (vector<Student_info>::size_type i = 0; i != students.size(); i++)
    {
        cout << students[i].name << string(maxlen + 1 - students[i].name.size(), ' ');

        try
        {
            double final_grade = grade(students[i]);
            streamsize prec = cout.precision();
            cout << setprecision(3) << final_grade << setprecision(prec);
        }
        catch (domain_error e)
        {
            cout << e.what();
        }
        cout << endl;
    }

    return is;
}

int grade_by_range()
{
    vector<Student_info> students;
    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read_and_grade(infile, students);
    infile.close();
    infile.clear();
    map<char, int> graded_students;

    for (vector<Student_info>::const_iterator iter = students.begin(); iter != students.end(); ++iter)
    {
        try
        {
            double final_grade = grade(*iter);
            if (final_grade >= 90)
            {
                ++graded_students['A'];
            }
            else if (final_grade >= 80)
            {
                ++graded_students['B'];
            }
            else if (final_grade >= 70)
            {
                ++graded_students['C'];
            }
            else if (final_grade >= 60)
            {
                ++graded_students['D'];
            }
            else
            {
                ++graded_students['F'];
            }
        }
        catch (domain_error e)
        {
            cout << e.what() << endl;
        }
    }

    for (map<char, int>::const_iterator iter = graded_students.begin(); iter != graded_students.end(); ++iter)
    {
        cout << iter->first << " : " << iter->second << " students" << endl;
    }

    return 0;
}

int main()
{
    vector<Student_info> all;
    Student_info student;

    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read(infile, all);
    infile.close();
    infile.clear();

    for (vector<Student_info>::const_iterator iter = all.begin(); iter != all.end(); iter++)
    {
        if (did_all_hw(*iter))
        {
            cout << "did ";
        }
        else
        {
            cout << "didnt ";
        }
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;
    vector<Student_info> did (all);
    vector<Student_info> didnt = extract(did, did_all_hw);

    if (did.empty())
    {
        cout << "No student did all the homework!" << endl;
        return 1;
    }

    if (didnt.empty())
    {
        cout << "Every student did all the homework!" << endl;
        return 1;
    }

    write_analysis(cout, "median", median_analysis, did, didnt);
    write_analysis(cout, "average", average_analysis, did, didnt);
    write_analysis(cout, "optimistic median", optimistic_median_analysis, did, didnt);
    write_analysis(cout, "median", grade_aux, did, didnt);
    write_analysis(cout, "average", average_grade, did, didnt);
    write_analysis(cout, "optimistic median", optimistic_median, did, didnt);

    vector<Student_info> failed = extract(all, pgrade);
    for (vector<Student_info>::const_iterator iter = all.begin(); iter != all.end(); iter++)
    {
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;

    for (vector<Student_info>::const_iterator iter = failed.begin(); iter != failed.end(); iter++)
    {
        cout << iter->name << ": " << iter->midterm << ", " << iter->final << ", " << iter->homework.size() << endl;
    }
    cout << endl;
    grade_by_range();

    return 0;
}
显示结果如下
did Geert: 50, 80, 4
didnt Pieter: 40, 50, 5
did Lotte: 40, 80, 4
didnt Jan: 30, 20, 5
did Joris: 80, 90, 5
did Geert: 50, 80, 4
didnt Pieter: 40, 50, 5
did Lotte: 40, 80, 4
didnt Jan: 30, 20, 5
did Joris: 80, 90, 5

median: median(did) = 67, median(didnt) = 37
average: median(did) = 66.5, median(didnt) = 35.4
optimistic median: median(did) = 67, median(didnt) = 38
median: median(did) = 67, median(didnt) = 37
average: median(did) = 66.5, median(didnt) = 35.4
optimistic median: median(did) = 67, median(didnt) = 38
Geert: 50, 80, 4
Lotte: 40, 80, 4
Joris: 80, 90, 5
Geert: 50, 80, 4
Lotte: 40, 80, 4
Joris: 80, 90, 5

Pieter: 40, 50, 5
Jan: 30, 20, 5
Pieter: 40, 50, 5
Jan: 30, 20, 5

Geert  67
Geert  67
Jan    30
Jan    30
Joris  76
Joris  76
Lotte  66
Lotte  66
Pieter 44
Pieter 44
C : 2 students
D : 4 students
F : 4 students

8-2实现下面的库算法--我们在第6章使用过它们，在6.5中描述了它们。指定它们所要求的迭代器种类。
尽量把把每一个函数所需要的不同的迭代器操作的个数降到最少。在实现了这些算法之后，对照一下8.3，看看你做得好不好。
equal (b, e, d)
search (b, e, b2, e2)
find (b, e, t)
find_if (b, e, p)
copy (b, e, d)
remove_copy (b, e, d, t)
remove_copy_if (b, e, d, p)
remove (b, e, t)
transform (b, e, d, f)
partition (b, e, p)
accumulate (b, e, t)

#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::stringstream;
using std::vector;
using std::string;
using std::domain_error;
using std::back_inserter;
using std::streamsize;
using std::setprecision;

class algorithms
{
public:
    template <typename In1, typename In2>
    static bool equal(In1 b, In1 e, In2 d)
    {
        while (b != e)
        {
            if (*b++ != *d++)
            {
                return false;
            }
        }

        return true;
    }

    template <typename Fw1, typename Fw2>
    static Fw1 search(Fw1 b, Fw1 e, Fw2 b2, Fw2 e2)
    {
        while (b != e)
        {
            Fw1 b_pat = b;
            Fw2 b2_pat = b2;

            while (*b_pat++ == *b2_pat++)
            {
                if (b2_pat == e2)
                {
                    return b;
                }
                if (b_pat == e)
                {
                    return e;
                }
            }

            ++b;
        }

        return e;
    }

    template <typename In, typename X>
    static In find(In b, In e, const X &t)
    {
        while (b != e && *b != t)
        {
            ++b;
        }

        return b;
    }

    template <typename In, typename P>
    static In find_if(In b, In e, P p)
    {
        while (b != e && !p(*b))
        {
            ++b;
        }

        return b;
    }

    template <typename In, typename Out>
    static Out copy(In b, In e, Out d)
    {
        while (b != e)
        {
            *d++ = *b++;
        }

        return d;
    }

    template <typename In, typename Out, typename X>
    static Out remove_copy(In b, In e, Out d, const X &t)
    {
        while (b != e)
        {
            if (*b != t)
            {
                *d++ = *b;
            }
            ++b;
        }

        return d;
    }

    template <typename In, typename Out, typename P>
    static Out remove_copy_if(In b, In e, Out d, P p)
    {
        while (b != e)
        {
            if (!p(*b))
            {
                *d++ = *b;
            }
            ++b;
        }

        return d;
    }

    template <typename Fw, typename X>
    static Fw remove(Fw b, Fw e, const X &t)
    {
        Fw b_in = b;

        while (b_in != e)
        {
            if (*b_in != t)
            {
                *b++ = *b_in;
            }

            ++b_in;
        }

        return b;
    }

    template <typename In, typename Out, typename P>
    static Out transform(In b, In e, Out d, P p)
    {
        while (b != e)
        {
            *d++ = p(*b++);
        }

        return d;
    }

    template <typename Fw, typename P>
    static Fw partition(Fw b, Fw e, P p)
    {
        Fw b_out = b;

        while (b != e)
        {
            if (p(*b))
            {
                std::iter_swap(b, b_out++);
            }
            b++;
        }

        return b_out;
    }

    template <typename In, typename X>
    static X accumulate(In b, In e, X t)
    {
        while (b != e)
        {
            t += *b++;
        }

        return t;
    }

};

template <typename In>
string print_vector(In b, In e)
{
    if (b == e)
    {
        throw domain_error("Empty range");
    }

    stringstream ss;

    ss << "[ " << *b++;

    while (b != e)
    {
        ss << ", " << *b++;
    }

    ss << " ]";

    return ss.str();
}

template <typename X>
string print_vector(const vector<X> &vec)
{
    return print_vector(vec.begin(), vec.end());
}

bool is_40(int x)
{
    return x == 40;
}

int minus_5(int x)
{
    return x - 5;
}

bool divisible_10(int x)
{
    return x % 10 == 0;
}

int main()
{
    vector<int> vec1 = { 10, 25, 35, 40, 50 };
    vector<int> vec2 = { 10, 27, 35, 40, 50 };
    vector<int> vec3 = { 10, 25, 35, 40, 50 };

    cout << "Is " << print_vector(vec1) << " equal to " << print_vector(vec2)
         << " ? " << algorithms::equal(vec1.begin(), vec1.end(), vec2.begin()) << endl;
    cout << "Is " << print_vector(vec1) << " equal to " << print_vector(vec3)
         << " ? " << algorithms::equal(vec1.begin(), vec1.end(), vec3.begin()) << endl << endl;

    vector<int> vec4 = { 35, 40 };
    cout << "Search " << print_vector(vec4) << " in " << print_vector(vec2) << " => "
         << *algorithms::search(vec2.begin(), vec2.end(), vec4.begin(), vec4.end()) << endl << endl;

    cout << "Find 35 in " << print_vector(vec1) << " => " << *algorithms::find(vec1.begin(), vec1.end(), 35) << endl << endl;

    cout << "Find if 40 in " << print_vector(vec1) << " => " << *algorithms::find_if(vec1.begin(), vec1.end(), is_40) << endl << endl;

    vector<int> vec5 = { 10, 20 };
    cout << "Copy " << print_vector(vec1) << " into " << print_vector(vec5) << " => ";
    algorithms::copy(vec1.begin(), vec1.end(), back_inserter(vec5));
    cout << print_vector(vec5) << endl << endl;

    vector<int> vec6;
    cout << "Copy " << print_vector(vec1) << " and remove 35 " << " => ";
    algorithms::remove_copy(vec1.begin(), vec1.end(), back_inserter(vec6), 35);
    cout << print_vector(vec6) << endl << endl;

    vector<int> vec7;
    cout << "Copy " << print_vector(vec1) << " and remove element if equal to 40 " << " => ";
    algorithms::remove_copy_if(vec1.begin(), vec1.end(), back_inserter(vec7), is_40);
    cout << print_vector(vec7) << endl << endl;

    cout << "Remove from " << print_vector(vec5) << " elements not equal to 10 " << " => ";
    cout << print_vector(vec5.begin(), algorithms::remove(vec5.begin(), vec5.end(), 10)) << endl << endl;

    vector<int> vec8;
    cout << "Transform " << print_vector(vec5) << " by detracting 5 from each element " << " => ";
    algorithms::transform(vec5.begin(), vec5.end(), back_inserter(vec8), minus_5);
    cout << print_vector(vec8) << endl << endl;

    cout << "Partition " << print_vector(vec1) << " by condition \" divisible by 10 \"" << " => ";
    algorithms::partition(vec1.begin(), vec1.end(), divisible_10);
    cout << print_vector(vec1) << endl << endl;

    cout << "Add " << print_vector(vec1) << " to 15" << " => "
         << algorithms::accumulate(vec1.begin(), vec1.end(), 15) << endl << endl;

    return 0;
}
显示结果如下
Is [ 10, 25, 35, 40, 50 ] equal to [ 10, 27, 35, 40, 50 ] ? 0
Is [ 10, 25, 35, 40, 50 ] equal to [ 10, 25, 35, 40, 50 ] ? 1

Search [ 35, 40 ] in [ 10, 27, 35, 40, 50 ] => 35

Find 35 in [ 10, 25, 35, 40, 50 ] => 35

Find if 40 in [ 10, 25, 35, 40, 50 ] => 40

Copy [ 10, 25, 35, 40, 50 ] into [ 10, 20 ] => [ 10, 20, 10, 25, 35, 40, 50 ]

Copy [ 10, 25, 35, 40, 50 ] and remove 35  => [ 10, 25, 40, 50 ]

Copy [ 10, 25, 35, 40, 50 ] and remove element if equal to 40  => [ 10, 25, 35, 50 ]

Remove from [ 10, 20, 10, 25, 35, 40, 50 ] elements not equal to 10  => [ 20, 25, 35, 40, 50 ]

Transform [ 20, 25, 35, 40, 50, 40, 50 ] by detracting 5 from each element  => [ 15, 20, 30, 35, 45, 35, 45 ]

Partition [ 10, 25, 35, 40, 50 ] by condition " divisible by 10 " => [ 10, 40, 50, 25, 35 ]

Add [ 10, 40, 50, 25, 35 ] to 15 => 175

8-3 正如我们在4.14中所了解到的那样，按值返回（或传递）一个容器的代价可能是很大的。
然而，我们在8.1.1中编写的median函数还是按值传递了向量。我们可以重写这个median函数，让它对迭代器操作而不是传递向量吗？
如果我们这样做，那么，你觉得对性能的影响将会是怎样的呢
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::stringstream;
using std::vector;
using std::string;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::accumulate;
using std::find;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;


template <typename In>
string print_vector(In b, In e)
{
    if (b == e)
    {
        throw domain_error("Empty range");
    }

    stringstream ss;

    ss << "[ " << *b++;

    while (b != e)
    {
        ss << ", " << *b++;
    }

    ss << " ]";

    return ss.str();
}

template <typename T>
string print_vector(const vector<T> &vec)
{
    return print_vector(vec.begin(), vec.end());
}

template<typename In>
auto median_iter(In b, In e) -> decltype((*b + *b) / 2)
{
    auto count = std::distance(b, e);

    if (count == 0)
    {
        throw std::domain_error("median of empty container");
    }

    std::sort(b, e);

    auto mid = count / 2;

    std::advance(b, mid - 1);

    return count % 2 == 0 ? (*b++ + *b) / 2 : *++b;
}

template<typename T>
T median(vector<T> v)
{
    typedef typename vector<T>::size_type vec_sz;
    vec_sz size = v.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }
    std::sort(v.begin(), v.end());

    vec_sz mid = size / 2;
    return size % 2 == 0 ? (v[mid] + v[mid - 1]) / 2 : v[mid];
}

int main()
{
    vector<int> vec1 = { 85, 74, 75, 45, 49, 66};
    cout << print_vector(vec1) << endl;
    steady_clock::time_point begin = std::chrono::steady_clock::now();

    for (int i = 0; i < 100; i++)
    {
        median(vec1);
    }

    steady_clock::time_point end = std::chrono::steady_clock::now();
    cout << "Microseconds to run median 100 times using pass by value = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;
    cout << print_vector(vec1) << endl;
    begin = std::chrono::steady_clock::now();
    for (int i = 0; i < 100; i++)
    {
        median_iter<vector<int>::iterator>(vec1.begin(), vec1.end());
    }

    end = std::chrono::steady_clock::now();
    cout << "Microseconds to run median 100 times using iterators = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;
    cout << print_vector(vec1) << endl;
    return 0;
}
显示结果如下
[ 85, 74, 75, 45, 49, 66 ]
Microseconds to run median 100 times using pass by value = 318
[ 85, 74, 75, 45, 49, 66 ]
Microseconds to run median 100 times using iterators = 360
[ 45, 49, 66, 74, 75, 85 ]

8-4 实现我们在8.2.5中使用的swap函数。为什么我们要调用swap而不是直接交换*beg和*end的值呢？提示：实践一下，看看会有什么样的结果吧
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::stringstream;
using std::vector;
using std::string;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::accumulate;
using std::find;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;

template <typename T>
void swap(T &l, T &r)
{
    T t = l;
    l = r;
    r = t;
}

template <typename In>
void reversing(In begin, In end)
{
    while (begin != end)
    {
        --end;
        if (begin != end)
        {
            swap(*begin++, *end);
        }
    }
}


template <typename In>
string print_vector(In b, In e)
{
    if (b == e)
    {
        throw domain_error("Empty range");
    }

    stringstream ss;

    ss << "[ " << *b++;

    while (b != e)
    {
        ss << ", " << *b++;
    }

    ss << " ]";

    return ss.str();
}

template <typename T>
string print_vector(const vector<T> &vec)
{
    return print_vector(vec.begin(), vec.end());
}

template<typename In>
auto median_iter(In b, In e) -> decltype((*b + *b) / 2)
{
    auto count = std::distance(b, e);

    if (count == 0)
    {
        throw std::domain_error("median of empty container");
    }

    std::sort(b, e);

    auto mid = count / 2;

    std::advance(b, mid - 1);

    return count % 2 == 0 ? (*b++ + *b) / 2 : *++b;
}

template<typename T>
T median(vector<T> v)
{
    typedef typename vector<T>::size_type vec_sz;
    vec_sz size = v.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }
    std::sort(v.begin(), v.end());

    vec_sz mid = size / 2;
    return size % 2 == 0 ? (v[mid] + v[mid - 1]) / 2 : v[mid];
}

int main()
{
    vector<int> vec1 = { 85, 74, 75, 45, 49, 66};
    cout << print_vector(vec1) << endl;
    steady_clock::time_point begin = std::chrono::steady_clock::now();

    for (int i = 0; i < 100; i++)
    {
        median(vec1);
    }

    steady_clock::time_point end = std::chrono::steady_clock::now();
    cout << "Microseconds to run median 100 times using pass by value = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;
    cout << print_vector(vec1) << endl;
    begin = std::chrono::steady_clock::now();
    for (int i = 0; i < 100; i++)
    {
        median_iter<vector<int>::iterator>(vec1.begin(), vec1.end());
    }

    end = std::chrono::steady_clock::now();
    cout << "Microseconds to run median 100 times using iterators = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;
    cout << print_vector(vec1) << endl;

    vector<int> vec2 = { 10, 15, 30, 105, 45, 70 };

    cout << "Reverse vector " << print_vector(vec2.begin(), vec2.end()) << " => ";
    reversing(vec2.begin(), vec2.end());
    cout << print_vector(vec2.begin(), vec2.end()) << endl;

    return 0;
}
显示结果如下
[ 85, 74, 75, 45, 49, 66 ]
Microseconds to run median 100 times using pass by value = 210
[ 85, 74, 75, 45, 49, 66 ]
Microseconds to run median 100 times using iterators = 142
[ 45, 49, 66, 74, 75, 85 ]
Reverse vector [ 10, 15, 30, 105, 45, 70 ] => [ 70, 45, 105, 30, 15, 10 ]

8-5 重新实现第7章的gen-sentence和xref函数，使用输出迭代器而不是把它们的输出直接写到一个vector<sting>类型的向量。
测试这些新版本，编写程序来把输出选代器与标准输出直接连接起来，把结果分别存储在list<string>类型和vector<string>类型的变量中。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <map>
#include <list>
#include <algorithm>
#include <numeric>
#include <iterator>
#include <utility>
#include <chrono>
#include <random>
#include <stdexcept>
#include <cstdlib>
#include <ctime>
#include <cctype>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::stringstream;
using std::vector;
using std::string;
using std::map;
using std::multimap;
using std::pair;
using std::list;
using std::getline;
using std::find_if;
using std::search;
using std::copy;
using std::sort;
using std::transform;
using std::accumulate;
using std::inserter;
using std::istream_iterator;
using std::ostream_iterator;
using std::back_inserter;
using std::logic_error;
using std::domain_error;
using std::to_string;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

typedef std::vector<std::string> Rule;
typedef std::vector<Rule> Rule_collection;
typedef std::map<std::string, Rule_collection> Grammar;

template<typename T>
T median(vector<T> v)
{
    typedef typename vector<T>::size_type vec_sz;
    vec_sz size = v.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }
    sort(v.begin(), v.end());

    vec_sz mid = size / 2;
    return size % 2 == 0 ? (v[mid] + v[mid - 1]) / 2 : v[mid];
}

double average(const vector<double> &v)
{
    return accumulate(v.begin(), v.end(), 0.0) / v.size();
}

int nrand(int n)
{
    if (n <= 0 || n > RAND_MAX)
    {
        throw domain_error("Argument to nrand is out of range");
    }

    const int bucket_size = RAND_MAX / n;
    int r;

    do
    {
        r = rand() / bucket_size;
    }
    while (r >= n);

    return r;
}

int nrand_improved(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

istream &count_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    for (map<string, int>::const_iterator it = counters.begin(); it != counters.end(); ++it)
    {
        os << it->first << "\t" << it->second << endl;
    }

    return is;
}

pair<int, string> flip_count_pair(const pair<string, int> &p)
{
    return pair<int, string>(p.second, p.first);
}

istream &count_sort_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    multimap<int, string> counters_r;
    transform(counters.begin(), counters.end(), inserter(counters_r, counters_r.begin()), flip_count_pair);

    for (multimap<int, string>::const_iterator it = counters_r.begin(); it != counters_r.end(); ++it)
    {
        os << it->second << "\t" << it->first << endl;
    }

    return is;
}

bool space(char c)
{
    return isspace(c) != 0;
}

bool not_space(char c)
{
    return !isspace(c);
}

vector<string> split(const string &str)
{
    typedef string::const_iterator iter;
    vector<string> ret;

    iter i = str.begin();
    while (i != str.end())
    {

        i = find_if(i, str.end(), not_space);

        iter j = find_if(i, str.end(), space);

        if (i != j)
        {
            ret.push_back(string(i, j));
            i = j;
        }
    }
    return ret;
}

list<string> split_to_list(const string &str)
{
    vector<string> ret = split(str);
    list <string> list;
    copy(ret.begin(), ret.end(), back_inserter(list));

    return list;
}

template <typename T>
void split(const string &str, T os)
{
    typedef string::const_iterator iter;
    iter i = str.begin();
    while (i != str.end())
    {
        i = std::find_if(i, str.end(), not_space);

        iter j = std::find_if(i, str.end(), space);

        if (i != j)
        {
            *os++ = string(i, j);
            i = j;
        }
    }
}

map<string, vector<int> > xref(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    return ret;
}

map<string, vector<int> > xref_unique(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    for (map<string, vector<int> >::iterator it = ret.begin(); it != ret.end(); ++it)
    {
        it->second.resize( distance(it->second.begin(), unique(it->second.begin(), it->second.end()) ) );
    }

    return ret;
}

template <typename Out>
void xref_uniq(istream &in, Out os, vector<string> find_words(const string &))
{
    const map<string, vector<int> > ret = xref_unique(in, find_words);

    for (map<string, vector<int> >::const_iterator it = ret.begin(); it != ret.end(); ++it)
    {
        stringstream ss;
        ss << it->first << " occurs on line(s): ";

        vector<int>::const_iterator line_it = it->second.begin();
        ss << *line_it++;

        while (line_it != it->second.end())
        {
            ss << ", " << *line_it++;
        }

        *os++ = ss.str();
    }

    in.clear();
    in.seekg(0, std::ios::beg);
}

bool bracketed(const string &s)
{
    return s.size() > 1 && s[0] == '<' && s[s.size() - 1] == '>';
}

Grammar read_grammar(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        vector<string> entry = split(line);

        if (entry.size() > 1)
        {
            ret[entry[0]].push_back( Rule( entry.begin() + 1, entry.end() ) );
        }
    }

    return ret;
}

Grammar read_grammar_list(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        list<string> entry = split_to_list(line);

        if (entry.size() > 1)
        {
            ret[entry.front()].push_back( Rule( ++entry.begin(), entry.end() ) );
        }
    }

    return ret;
}
void gen_aux(const Grammar &g, const string &word, vector<string> &ret)
{
    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[nrand(c.size())];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}

void gen_aux(const Grammar &g, const string &word, list<string> &ret)
{
    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[nrand(c.size())];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}

template <typename Out>
void gen_aux(const Grammar &g, const string &word, Out os)
{
    if (!bracketed(word))
    {
        *os++ = word;
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[nrand(c.size())];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, os);
        }
    }
}

vector<string> gen_sentence(const Grammar &g)
{
    vector<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

list<string> gen_sentence_list(const Grammar &g)
{
    list<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

template <typename Out>
void gen_sentence(const Grammar &g, Out os)
{
    gen_aux(g, "<sentence>", os);
}

int generate_sentence_list_output(string file)
{
    ifstream infile;
    infile.open(file);
    list<string> sentence = gen_sentence_list(read_grammar_list(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;

    return 0;
}

vector<string> gen_sentence_vectors(const Grammar &g)
{
    vector<string> ret;
    vector<string> rules;

    rules.push_back("<sentence>");

    while (!rules.empty())
    {
        string segment = rules.back();
        rules.pop_back();

        if (!bracketed(segment))
        {
            ret.push_back(segment);
        }
        else
        {

            Grammar::const_iterator it = g.find(segment);

            if (it == g.end())
            {
                throw logic_error("empty rule");
            }

            const Rule_collection &c = it->second;

            const Rule &r = c[nrand(c.size())];

            for (Rule::const_reverse_iterator i = r.rbegin(); i != r.rend(); ++i)
            {
                rules.push_back(*i);
            }
        }
    }

    return ret;
}

int generate_sentence_vectors_output(string file)
{
    ifstream infile;
    infile.open(file);
    vector<string> sentence = gen_sentence_vectors(read_grammar(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;

    return 0;
}

int test_generate_sentence(string file)
{
    ifstream infile;
    infile.open(file);
    Grammar g = read_grammar(infile);

    vector<string> sentence_vector;
    list<string> sentence_list;

    gen_sentence(g, back_inserter(sentence_vector));
    gen_sentence(g, back_inserter(sentence_list));
    gen_sentence(g, ostream_iterator<string>(cout, " "));

    cout << endl;

    vector<string>::const_iterator itv = sentence_vector.begin();
    if (!sentence_vector.empty())
    {
        cout << *itv++;
    }
    while (itv != sentence_vector.end())
    {
        cout << " " << *itv++;
    }
    cout << endl;

    list<string>::const_iterator itl = sentence_list.begin();
    if (!sentence_list.empty())
    {
        cout << *itl++;
    }
    while (itl != sentence_list.end())
    {
        cout << " " << *itl++;
    }
    cout << endl;

    return 0;
}

bool not_url_char(char c)
{
    static const string url_ch = "~;/?:@=&$-_.+!*'(),";

    return !(isalnum(c) || find(url_ch.begin(), url_ch.end(), c) != url_ch.end());
}

string::const_iterator url_beg(string::const_iterator b, string::const_iterator e)
{
    static const string sep = "://";

    typedef string::const_iterator iter;

    iter i = b;

    while ( ( i = search(i, e, sep.begin(), sep.end()) ) != e )
    {

        if (i != b && i + sep.size() != e)
        {

            iter beg = i;
            while (beg != b && isalpha(beg[-1]))
            {
                --beg;
            }

            if (beg != i && !not_url_char( i[sep.size()] ))
            {
                return beg;
            }
        }

        i += sep.size();
    }

    return e;
}

string::const_iterator url_end(string::const_iterator b, string::const_iterator e)
{
    return find_if(b, e, not_url_char);
}

vector<string> find_urls(const string &s)
{
    vector<string> ret;
    typedef string::const_iterator iter;
    iter b = s.begin(), e = s.end();

    while (b != e)
    {

        b = url_beg(b, e);

        if (b != e)
        {
            iter after = url_end(b, e);

            ret.push_back(string(b, after));

            b = after;
        }
    }

    return ret;
}

int print_formatted_xref(string file, size_t line_length)
{
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        string s = it->first + " occurs on line(s): ";
        string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
    }

    return 0;
}

int print_formatted_line_xref(string file, size_t line_length)
{
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        string line = it->second.size() > 1 ? "lines" : "line";
        string s = it->first + " occurs on " + line + ": ";
        string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
    }

    return 0;
}

int print_xref_urls(string file, size_t line_length)
{
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, find_urls);
    infile.close();
    infile.clear();
    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        string line = it->second.size() > 1 ? "lines" : "line";
        string s = it->first + " occurs on " + line + ": ";
        string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
    }

    return 0;
}

int test_xref()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret = xref(infile, split);
    infile.close();
    infile.clear();
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret.begin(); it != ret.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    cout << endl;
    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    return 0;
}

int test_xref(string file)
{
    ifstream infile;
    infile.open(file);

    vector<string> xref_vector;
    list<string> xref_list;

    xref_uniq(infile, back_inserter(xref_vector), split);
    xref_uniq(infile, back_inserter(xref_list), split);
    xref_uniq(infile, ostream_iterator<string>(cout, "\n"), split);

    cout << endl;

    vector<string>::const_iterator itv = xref_vector.begin();
    if (!xref_vector.empty())
    {
        cout << *itv++ << endl;
    }
    while (itv != xref_vector.end())
    {
        cout << *itv++ << endl;
    }
    cout << endl;

    list<string>::const_iterator itl = xref_list.begin();
    if (!xref_list.empty())
    {
        cout << *itl++ << endl;
    }
    while (itl != xref_list.end())
    {
        cout << *itl++ << endl;
    }
    cout << endl;

    return 0;
}

int test_generate_sentence()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    vector<string> sentence = gen_sentence(read_grammar(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;
    return 0;
}

int test_count_words()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    count_sort_words(infile, cout);
    infile.close();
    infile.clear();
    return 0;
}

int test_split()
{
    cout << "Enter lines to split: " << endl;
    string s;
    while (getline(cin, s, '\n') && s != "quit")
    {
        split(s, ostream_iterator<string, char>(cout, "\n"));
    }
    return 0;
}

void test_stream_iterators()
{
    cout << "Enter a few integers: ";

    vector<int> v;
    copy(istream_iterator<int>(cin), istream_iterator<int>(), back_inserter(v));
    cout << endl;

    copy(v.begin(), v.end(), ostream_iterator<int>(cout, " "));
    cout << endl;
}

void test_median()
{
    vector<double> v_double = { 12.5, 16.3, 25.7 };
    cout << median(v_double) << endl;

    vector<int> v_int = { 12, 25, 16, 30 };
    cout << median(v_int) << endl;
}

int main()
{
    std::srand(std::time(nullptr));
    test_xref();
    cout << endl;
    test_generate_sentence();
    cout << endl;
    generate_sentence_list_output("grammar_ch07.txt");
    cout << endl;
    generate_sentence_vectors_output("grammar_ch07.txt");
    cout << endl;
    test_count_words();
    cout << endl;
    print_formatted_line_xref("grammar_ch07.txt", 60);
    cout << endl;
    print_xref_urls("urls_ch07.txt", 60);
    cout << endl;
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);
    for (int i = 0; i < 10; i++)
    {
        cout << nrand_improved(100, engine) << endl;
    }
    cout << endl;
    test_median();
    test_stream_iterators();
    cin.clear();
    while (cin.get() != '\n')
    {
        continue;
    }
    test_split();
    cout << endl;
    test_generate_sentence("grammar_ch07.txt");
    cout << endl;
    test_xref("grammar_ch07.txt");
    return 0;
}
显示结果如下
<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

the brown table jumps under the sky

the cat jumps on the stairs

the brown table sits under the sky

<sentence>      1
absurd  1
brown   1
cat     1
dog     1
it      1
jumps   1
large   1
on      1
sits    1
sky     1
stairs  1
table   1
under   1
wants   1
wherever        1
the     3
<verb>  3
<adjective>     4
<location>      4
<noun-phrase>   4
<noun>  4

<adjective> occurs on lines: 5, 6, 7, 8
<location> occurs on lines: 11, 12, 13, 14
<noun-phrase> occurs on lines: 4, 5, 14
<noun> occurs on lines: 1, 2, 3, 4
<sentence> occurs on line: 14
<verb> occurs on lines: 9, 10, 14
absurd occurs on line: 8
brown occurs on line: 7
cat occurs on line: 1
dog occurs on line: 2
it occurs on line: 13
jumps occurs on line: 9
large occurs on line: 6
on occurs on line: 11
sits occurs on line: 10
sky occurs on line: 12
stairs occurs on line: 11
table occurs on line: 3
the occurs on lines: 11, 12, 14
under occurs on line: 12
wants occurs on line: 13
wherever occurs on line: 13

ftp://www.telenet.be occurs on line: 5
http://www.amazon.com occurs on lines: 2, 6, 7
http://www.disneyland.com occurs on line: 4
http://www.google.be occurs on lines: 1, 4

48
97
68
4
47
1
72
84
35
46

16.3
20
Enter a few integers: 1 2 3 4 5 6 q

1 2 3 4 5 6
Enter lines to split:
Hello World Peter Smith Mike Pence
Hello
World
Peter
Smith
Mike
Pence
quit

the brown cat sits on the stairs
the cat jumps wherever it wants
the table sits wherever it wants

<adjective> occurs on line(s): 5, 6, 7, 8
<location> occurs on line(s): 11, 12, 13, 14
<noun-phrase> occurs on line(s): 4, 5, 14
<noun> occurs on line(s): 1, 2, 3, 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9, 10, 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11, 12, 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

<adjective> occurs on line(s): 5, 6, 7, 8
<location> occurs on line(s): 11, 12, 13, 14
<noun-phrase> occurs on line(s): 4, 5, 14
<noun> occurs on line(s): 1, 2, 3, 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9, 10, 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11, 12, 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

<adjective> occurs on line(s): 5, 6, 7, 8
<location> occurs on line(s): 11, 12, 13, 14
<noun-phrase> occurs on line(s): 4, 5, 14
<noun> occurs on line(s): 1, 2, 3, 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9, 10, 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11, 12, 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13


8-6 假定m的类型是map<int, string>，而且我们遇到了一个调用copy (m.begin(), m.end(), back inserter(x))，那我们应该怎样看待x的类型呢？
如果这个调用的形式是copy(x.begin(), x.end(), back_inserter(m))的话那又怎样呢？
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <map>
#include <list>
#include <algorithm>
#include <numeric>
#include <iterator>
#include <utility>
#include <chrono>
#include <random>
#include <stdexcept>
#include <cstdlib>
#include <ctime>
#include <cctype>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::stringstream;
using std::vector;
using std::string;
using std::map;
using std::multimap;
using std::pair;
using std::list;
using std::getline;
using std::find_if;
using std::search;
using std::copy;
using std::sort;
using std::transform;
using std::accumulate;
using std::inserter;
using std::istream_iterator;
using std::ostream_iterator;
using std::back_inserter;
using std::logic_error;
using std::domain_error;
using std::to_string;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;


int main()
{
    map<int, string> m1 = { { 1, "hello" }, { 3, "bye" } };
    vector<pair<int, string>> v1;

    cout << v1.size() << endl;
    copy(m1.begin(), m1.end(), back_inserter(v1));
    cout << v1.size() << endl;

    map<int, string> m2;
    vector<pair<int, string>> v2 = { { 1, "thanks" }, { 3, "yo" } };

    cout << m2.size() << endl;
    copy(v2.begin(), v2.end(), inserter(m2, m2.begin()));
    cout << m2.size() << endl;

    return 0;
}
显示结果如下
0
2
0
2

8-7 为什么max函数不使用两个模板参数（各用于一个参数类型）呢？
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <map>
#include <list>
#include <algorithm>
#include <numeric>
#include <iterator>
#include <utility>
#include <chrono>
#include <random>
#include <stdexcept>
#include <cstdlib>
#include <ctime>
#include <cctype>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::stringstream;
using std::vector;
using std::string;
using std::map;
using std::multimap;
using std::pair;
using std::list;
using std::getline;
using std::find_if;
using std::search;
using std::copy;
using std::sort;
using std::transform;
using std::accumulate;
using std::inserter;
using std::istream_iterator;
using std::ostream_iterator;
using std::back_inserter;
using std::logic_error;
using std::domain_error;
using std::to_string;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

template<typename L, typename R, typename O>
O max(const L& left, const R& right)
{
  return left > right ? left : right;
}

int main()
{
  cout << max<int, double, double>(5, 6.5) << endl;
  cout << max<int, double, int>(5, 6.5) << endl;
  return 0;
}
显示结果如下
6.5
6

8-8 在8.2.6的binary-search函数中，我们为什么不编写（begin + end）/2来代替那个更为复杂的begin +（end-begin）/2呢？
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <map>
#include <list>
#include <algorithm>
#include <numeric>
#include <iterator>
#include <utility>
#include <chrono>
#include <random>
#include <stdexcept>
#include <cstdlib>
#include <ctime>
#include <cctype>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::stringstream;
using std::vector;
using std::string;
using std::map;
using std::multimap;
using std::pair;
using std::list;
using std::getline;
using std::find_if;
using std::search;
using std::copy;
using std::sort;
using std::transform;
using std::accumulate;
using std::inserter;
using std::istream_iterator;
using std::ostream_iterator;
using std::back_inserter;
using std::logic_error;
using std::domain_error;
using std::to_string;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

template<typename In, typename T>
bool binarySearch(In b, In e, const T &x)
{
    while (b < e)
    {
        In mid = b + (e - b) / 2;
        if (x < *mid)
        {
            e = mid;
        }
        else if (*mid < x)
        {
            b = mid + 1;
        }
        else
        {
            return true;
        }
    }
    return false;
}

int main()
{
    vector<int> v = { 4, 17, 9, 23, 36 };

    cout << binarySearch<vector<int>::iterator,int>(v.begin(), v.end(), 23) << endl;
    cout << binarySearch<vector<int>::iterator,int>(v.begin(), v.end(), 35) << endl;

    return 0;
}
显示结果如下
1
0

第9章 定义新类型
9.1 回题一下Student_info
9.2 自定义类型
9.3 保护
9.4 Student_info类
9.5 构造函数
9.6 使用Stuadent_info类
9.7 小结
习题
9-0 编译、运行并测试本章中的程序。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::stringstream;
using std::vector;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::accumulate;
using std::find;
using std::max;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;

class Student_info
{
private:
    string _name;
    double midterm, final;
    vector<double> homework;

public:
    Student_info();
    Student_info(istream &);

    istream &read(istream &);
    double grade() const;
    const string &name() const
    {
        return _name;
    }
    bool valid() const
    {
        return !homework.empty();
    }
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

Student_info::Student_info() : midterm(0), final(0) { }

Student_info::Student_info(istream &is)
{
    read(is);
}

istream &Student_info::read(istream &in)
{
    in >> _name >> midterm >> final;
    read_hw(in, homework);
    return in;
}

double Student_info::grade() const
{
    return ::grade(midterm, final, homework);
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name() < y.name();
}

istream &read_and_grade(istream &is, vector<Student_info> &students)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];
    string::size_type maxlen = 0;

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student(ss);
        maxlen = max(maxlen, student.name().size());
        students.push_back(student);
    }
    sort(students.begin(), students.end(), compare);
    for (vector<Student_info>::size_type i = 0; i != students.size(); i++)
    {
        cout << students[i].name() << string(maxlen + 1 - students[i].name().size(), ' ');

        try
        {
            double final_grade = students[i].grade();
            streamsize prec = cout.precision();
            cout << setprecision(3) << final_grade << setprecision(prec) << endl;
        }
        catch (domain_error e)
        {
            cout << e.what() << endl;
        }
    }

    return is;
}


int test_read_and_grade()
{
    vector<Student_info> students;
    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read_and_grade(infile, students);
    infile.close();
    infile.clear();

    for (vector<Student_info>::const_iterator iter = students.begin(); iter != students.end(); ++iter)
    {
        cout << iter->name() << " is valid = " << iter->valid() << endl;
    }

    return 0;
}

int main()
{
    test_read_and_grade();
    return 0;
}
显示结果如下
Geert  67
Geert  67
Jan    30
Jan    30
Joris  76
Joris  76
Lotte  66
Lotte  66
Pieter 44
Pieter 44
Geert is valid = 1
Geert is valid = 1
Jan is valid = 1
Jan is valid = 1
Joris is valid = 1
Joris is valid = 1
Lotte is valid = 1
Lotte is valid = 1
Pieter is valid = 1
Pieter is valid = 1

9-1重新实现Studentinfo类，让它在读学生记录的时候计算总成绩，把成绩存储在对象中。重新实现grade函数，让它使用这个预计算的值。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::stringstream;
using std::vector;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::accumulate;
using std::find;
using std::max;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;

class Student_info
{
private:
    string _name;
    double _grade;
    double midterm, final;
    vector<double> homework;

public:
    Student_info();
    Student_info(istream &);

    istream &read(istream &);
    double grade() const
    {
        return _grade;
    }
    const string &name() const
    {
        return _name;
    }
    bool valid() const
    {
        return !homework.empty();
    }
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

Student_info::Student_info() : _grade(0), midterm(0), final(0) { }

Student_info::Student_info(istream &is)
{
    read(is);
}

istream &Student_info::read(istream &in)
{
    in >> _name >> midterm >> final;
    read_hw(in, homework);
    try
    {
        _grade = ::grade(midterm, final, homework);
    }
    catch (domain_error &e)
    {
        cout << e.what() << endl;
        _grade = ::grade(midterm, final, 0);
    }

    return in;
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name() < y.name();
}

istream &read_and_grade(istream &is, vector<Student_info> &students)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];
    string::size_type maxlen = 0;

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student(ss);
        maxlen = max(maxlen, student.name().size());
        students.push_back(student);
    }
    sort(students.begin(), students.end(), compare);
    for (vector<Student_info>::size_type i = 0; i != students.size(); i++)
    {
        cout << students[i].name() << string(maxlen + 1 - students[i].name().size(), ' ');
        streamsize prec = cout.precision();
        cout << setprecision(3) << students[i].grade() << setprecision(prec) << endl;
    }

    return is;
}


int test_read_and_grade()
{
    vector<Student_info> students;
    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read_and_grade(infile, students);
    infile.close();
    infile.clear();

    for (vector<Student_info>::const_iterator iter = students.begin(); iter != students.end(); ++iter)
    {
        cout << iter->name() << " is valid = " << iter->valid() << endl;
    }

    return 0;
}

int main()
{
    test_read_and_grade();
    return 0;
}
显示结果如下
Geert  67
Geert  67
Jan    30
Jan    30
Joris  76
Joris  76
Lotte  66
Lotte  66
Pieter 44
Pieter 44
Geert is valid = 1
Geert is valid = 1
Jan is valid = 1
Jan is valid = 1
Joris is valid = 1
Joris is valid = 1
Lotte is valid = 1
Lotte is valid = 1
Pieter is valid = 1
Pieter is valid = 1

9-2如果我们把name函数定义成一个简单的、非常量的成员函数，那么在我们的系统中，
其他的函数必须做什么改动以及为什么要做这些改动呢？
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::stringstream;
using std::vector;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::accumulate;
using std::find;
using std::max;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;

class Student_info
{
private:
    string _name;
    double _grade;
    double midterm, final;
    vector<double> homework;

public:
    Student_info();
    Student_info(istream &);

    istream &read(istream &);
    double grade() const
    {
        return _grade;
    }
    string name()
    {
        return _name;
    }
    bool valid() const
    {
        return !homework.empty();
    }
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

Student_info::Student_info() : _grade(0), midterm(0), final(0) { }

Student_info::Student_info(istream &is)
{
    read(is);
}

istream &Student_info::read(istream &in)
{
    in >> _name >> midterm >> final;
    read_hw(in, homework);
    try
    {
        _grade = ::grade(midterm, final, homework);
    }
    catch (domain_error &e)
    {
        cout << e.what() << endl;
        _grade = ::grade(midterm, final, 0);
    }

    return in;
}

bool compare(Student_info &x, Student_info &y)
{
    return x.name() < y.name();
}

istream &read_and_grade(istream &is, vector<Student_info> &students)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];
    string::size_type maxlen = 0;

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student(ss);
        maxlen = max(maxlen, student.name().size());
        students.push_back(student);
    }
    sort(students.begin(), students.end(), compare);
    for (vector<Student_info>::size_type i = 0; i != students.size(); i++)
    {
        cout << students[i].name() << string(maxlen + 1 - students[i].name().size(), ' ');
        streamsize prec = cout.precision();
        cout << setprecision(3) << students[i].grade() << setprecision(prec) << endl;
    }

    return is;
}


int test_read_and_grade()
{
    vector<Student_info> students;
    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read_and_grade(infile, students);
    infile.close();
    infile.clear();

    for (vector<Student_info>::iterator iter = students.begin(); iter != students.end(); ++iter)
    {
        cout << iter->name() << " is valid = " << iter->valid() << endl;
    }

    return 0;
}

int main()
{
    test_read_and_grade();
    return 0;
}
显示结果如下
Geert  67
Geert  67
Jan    30
Jan    30
Joris  76
Joris  76
Lotte  66
Lotte  66
Pieter 44
Pieter 44
Geert is valid = 1
Geert is valid = 1
Jan is valid = 1
Jan is valid = 1
Joris is valid = 1
Joris is valid = 1
Lotte is valid = 1
Lotte is valid = 1
Pieter is valid = 1
Pieter is valid = 1

9-3如果在还没有读入一个Student info对象的值的情况下，一个用户就试图对这个对象计算成绩，那么我们的grade函数就会引发一个异常。
这就要求用户自己去捕获这个异常。编写一个程序来触发这个异常但不捕获它。然后，编写另一个程序来捕获这个异常。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::stringstream;
using std::vector;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::accumulate;
using std::find;
using std::max;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;

class Student_info
{
private:
    string _name;
    double midterm, final;
    vector<double> homework;

public:
    Student_info();
    Student_info(istream &);

    istream &read(istream &);
    double grade() const;
    const string &name() const
    {
        return _name;
    }
    bool valid() const
    {
        return !homework.empty();
    }
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

Student_info::Student_info() : midterm(0), final(0) { }

Student_info::Student_info(istream &is)
{
    read(is);
}

istream &Student_info::read(istream &in)
{
    in >> _name >> midterm >> final;
    read_hw(in, homework);
    return in;
}

double Student_info::grade() const
{
    return ::grade(midterm, final, homework);
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name() < y.name();
}

istream &read_and_grade(istream &is, vector<Student_info> &students)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];
    string::size_type maxlen = 0;

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student(ss);
        maxlen = max(maxlen, student.name().size());
        students.push_back(student);
    }
    sort(students.begin(), students.end(), compare);
    for (vector<Student_info>::size_type i = 0; i != students.size(); i++)
    {
        cout << students[i].name() << string(maxlen + 1 - students[i].name().size(), ' ');

        try
        {
            double final_grade = students[i].grade();
            streamsize prec = cout.precision();
            cout << setprecision(3) << final_grade << setprecision(prec) << endl;
        }
        catch (domain_error e)
        {
            cout << e.what() << endl;
        }
    }

    return is;
}


int test_read_and_grade()
{
    vector<Student_info> students;
    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read_and_grade(infile, students);
    infile.close();
    infile.clear();

    for (vector<Student_info>::const_iterator iter = students.begin(); iter != students.end(); ++iter)
    {
        cout << iter->name() << " is valid = " << iter->valid() << endl;
    }

    return 0;
}

int main()
{
    test_read_and_grade();
    Student_info student;

    try
    {
        double final_grade = student.grade();
        streamsize prec = cout.precision();
        cout << setprecision(3) << final_grade << setprecision(prec) << endl;
    }
    catch (domain_error e)
    {
        cout << e.what() << endl;
    }
    return 0;
}
显示结果如下
Geert  67
Geert  67
Jan    30
Jan    30
Joris  76
Joris  76
Lotte  66
Lotte  66
Pieter 44
Pieter 44
Geert is valid = 1
Geert is valid = 1
Jan is valid = 1
Jan is valid = 1
Joris is valid = 1
Joris is valid = 1
Lotte is valid = 1
Lotte is valid = 1
Pieter is valid = 1
Pieter is valid = 1
Student has done no homework

9-4 重新编写在前面的练习中的程序，使用valid函数来避免异常的发生。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::stringstream;
using std::vector;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::accumulate;
using std::find;
using std::max;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;

class Student_info
{
private:
    string _name;
    double midterm, final;
    vector<double> homework;

public:
    Student_info();
    Student_info(istream &);

    istream &read(istream &);
    double grade() const;
    const string &name() const
    {
        return _name;
    }
    bool valid() const
    {
        return !homework.empty();
    }
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

Student_info::Student_info() : midterm(0), final(0) { }

Student_info::Student_info(istream &is)
{
    read(is);
}

istream &Student_info::read(istream &in)
{
    in >> _name >> midterm >> final;
    read_hw(in, homework);
    return in;
}

double Student_info::grade() const
{
    return ::grade(midterm, final, homework);
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name() < y.name();
}

istream &read_and_grade(istream &is, vector<Student_info> &students)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];
    string::size_type maxlen = 0;

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student(ss);
        maxlen = max(maxlen, student.name().size());
        students.push_back(student);
    }
    sort(students.begin(), students.end(), compare);
    for (vector<Student_info>::size_type i = 0; i != students.size(); i++)
    {
        cout << students[i].name() << string(maxlen + 1 - students[i].name().size(), ' ');

        try
        {
            double final_grade = students[i].grade();
            streamsize prec = cout.precision();
            cout << setprecision(3) << final_grade << setprecision(prec) << endl;
        }
        catch (domain_error e)
        {
            cout << e.what() << endl;
        }
    }

    return is;
}


int test_read_and_grade()
{
    vector<Student_info> students;
    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read_and_grade(infile, students);
    infile.close();
    infile.clear();

    for (vector<Student_info>::const_iterator iter = students.begin(); iter != students.end(); ++iter)
    {
        cout << iter->name() << " is valid = " << iter->valid() << endl;
    }

    return 0;
}

int main()
{
    test_read_and_grade();
    Student_info student;

    if (student.valid())
    {
        streamsize prec = cout.precision();
        cout << setprecision(3) << student.grade() << setprecision(prec) << endl;
    }
    else
    {
        cout << "student is invalid" << endl;
    }
    return 0;
}
显示结果如下
Geert  67
Geert  67
Jan    30
Jan    30
Joris  76
Joris  76
Lotte  66
Lotte  66
Pieter 44
Pieter 44
Geert is valid = 1
Geert is valid = 1
Jan is valid = 1
Jan is valid = 1
Joris is valid = 1
Joris is valid = 1
Lotte is valid = 1
Lotte is valid = 1
Pieter is valid = 1
Pieter is valid = 1
student is invalid

9-5 编写一个类以及相关的函数来为学生产生成绩，用pass（及格）/fail（不及格）来表示成绩。
假定只根据期中和期末成绩来计算，而且，如果一个学生的平均考试分数大于等于60的话，那这个学生及格。
输出时按字母顺序列出学生姓名并列出相应的成绩，成绩用P或F来表示。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::stringstream;
using std::vector;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::accumulate;
using std::find;
using std::max;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;

class Student_info
{
private:
    string _name;
    double _grade;
    double midterm, final;

public:
    Student_info();
    Student_info(istream &);

    istream &read(istream &);
    double grade() const
    {
        return _grade;
    }
    const string &name() const
    {
        return _name;
    }
    bool passing() const
    {
        return _grade >= 60;
    }
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

Student_info::Student_info() : _grade(0), midterm(0), final(0) { }

Student_info::Student_info(istream &is)
{
    read(is);
}

istream &Student_info::read(istream &in)
{
    in >> _name >> midterm >> final;
    double x;
    while (in >> x)
    {
        continue;
    }
    in.clear();
    _grade = (midterm + final) / 2;

    return in;
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name() < y.name();
}

istream &read_and_grade(istream &is, vector<Student_info> &students)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];
    string::size_type maxlen = 0;

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student(ss);
        maxlen = max(maxlen, student.name().size());
        students.push_back(student);
    }
    sort(students.begin(), students.end(), compare);
    for (vector<Student_info>::size_type i = 0; i != students.size(); i++)
    {
        cout << students[i].name() << string(maxlen + 1 - students[i].name().size(), ' ');
        double final_grade = students[i].grade();
        streamsize prec = cout.precision();
        cout << setprecision(3) << final_grade << setprecision(prec) << " ";
        cout << (students[i].passing() ? 'P' : 'F') << endl;
    }

    return is;
}


int test_read_and_grade()
{
    vector<Student_info> students;
    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read_and_grade(infile, students);
    infile.close();
    infile.clear();

    return 0;
}

int main()
{
    test_read_and_grade();
    return 0;
}
显示结果如下
Geert  65 P
Geert  65 P
Jan    25 F
Jan    25 F
Joris  85 P
Joris  85 P
Lotte  60 P
Lotte  60 P
Pieter 45 F
Pieter 45 F

9-6 为pass（及格）/fail（不及格）的学生重新编写那个计算成绩的程序，输出的时候首先出示所有及格的学生，跟着就输出不及格的学生。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::stringstream;
using std::vector;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::max;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::stable_partition;

class Student_info
{
private:
    string _name;
    double _grade;
    double midterm, final;

public:
    Student_info();
    Student_info(istream &);

    istream &read(istream &);
    double grade() const
    {
        return _grade;
    }
    const string &name() const
    {
        return _name;
    }
    bool passing() const
    {
        return _grade >= 60;
    }
};

bool passing(const Student_info & student)
{
  return student.passing();
}

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

Student_info::Student_info() : _grade(0), midterm(0), final(0) { }

Student_info::Student_info(istream &is)
{
    read(is);
}

istream &Student_info::read(istream &in)
{
    in >> _name >> midterm >> final;
    double x;
    while (in >> x)
    {
        continue;
    }
    in.clear();
    _grade = (midterm + final) / 2;

    return in;
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name() < y.name();
}

istream &read_and_grade(istream &is, vector<Student_info> &students)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];
    string::size_type maxlen = 0;

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student(ss);
        maxlen = max(maxlen, student.name().size());
        students.push_back(student);
    }
    sort(students.begin(), students.end(), compare);
    stable_partition(students.begin(), students.end(), passing);

    for (vector<Student_info>::size_type i = 0; i != students.size(); i++)
    {
        cout << students[i].name() << string(maxlen + 1 - students[i].name().size(), ' ');
        double final_grade = students[i].grade();
        streamsize prec = cout.precision();
        cout << setprecision(3) << final_grade << setprecision(prec) << " ";
        cout << (students[i].passing() ? 'P' : 'F') << endl;
    }

    return is;
}


int test_read_and_grade()
{
    vector<Student_info> students;
    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read_and_grade(infile, students);
    infile.close();
    infile.clear();

    return 0;
}

int main()
{
    test_read_and_grade();
    return 0;
}
显示结果如下
Geert  65 P
Geert  65 P
Joris  85 P
Joris  85 P
Lotte  60 P
Lotte  60 P
Jan    25 F
Jan    25 F
Pieter 45 F
Pieter 45 F

9-7 在4.1.3中的read_hw函数解决了一个很一般的问题（把一系列的数据读到一个向量中）――尽管它的名称表明了，它应该是Student_info实现的一部分。
当然，我们能改变它的名称-但是，让我们假设，尽管从表面上看它是很一般的，但是，为了表明我们不打算让它成为公有访问的，
我们还是希望把它和其余的Student_info代码结合在一起，那么我们应该如何做到这一点呢？
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>

using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::stringstream;
using std::vector;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::accumulate;
using std::find;
using std::max;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;

class Student_info
{
private:
    string _name;
    double midterm, final;
    vector<double> homework;
    istream &read_hw(istream &is);

public:
    Student_info();
    Student_info(istream &);

    istream &read(istream &);
    double grade() const;
    const string &name() const
    {
        return _name;
    }
    bool valid() const
    {
        return !homework.empty();
    }
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &Student_info::read_hw(istream &is)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            homework.push_back(x);
        }

        is.clear();
    }

    return is;
}

Student_info::Student_info() : midterm(0), final(0) { }

Student_info::Student_info(istream &is)
{
    read(is);
}

istream &Student_info::read(istream &in)
{
    in >> _name >> midterm >> final;
    read_hw(in);
    return in;
}

double Student_info::grade() const
{
    return ::grade(midterm, final, homework);
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name() < y.name();
}

istream &read_and_grade(istream &is, vector<Student_info> &students)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];
    string::size_type maxlen = 0;

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student(ss);
        maxlen = max(maxlen, student.name().size());
        students.push_back(student);
    }
    sort(students.begin(), students.end(), compare);
    for (vector<Student_info>::size_type i = 0; i != students.size(); i++)
    {
        cout << students[i].name() << string(maxlen + 1 - students[i].name().size(), ' ');

        try
        {
            double final_grade = students[i].grade();
            streamsize prec = cout.precision();
            cout << setprecision(3) << final_grade << setprecision(prec) << endl;
        }
        catch (domain_error e)
        {
            cout << e.what() << endl;
        }
    }

    return is;
}


int test_read_and_grade()
{
    vector<Student_info> students;
    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read_and_grade(infile, students);
    infile.close();
    infile.clear();

    for (vector<Student_info>::const_iterator iter = students.begin(); iter != students.end(); ++iter)
    {
        cout << iter->name() << " is valid = " << iter->valid() << endl;
    }

    return 0;
}

int main()
{
    test_read_and_grade();
    return 0;
}
显示结果如下
Geert  67
Geert  67
Jan    30
Jan    30
Joris  76
Joris  76
Lotte  66
Lotte  66
Pieter 44
Pieter 44
Geert is valid = 1
Geert is valid = 1
Jan is valid = 1
Jan is valid = 1
Joris is valid = 1
Joris is valid = 1
Lotte is valid = 1
Lotte is valid = 1
Pieter is valid = 1
Pieter is valid = 1

第10章 管理内存和低级数据结构
10.1 指针与数组
10.2 再看字符串常量
10.3 初始化字符串指针数组
10.4 main函数的参数
10.5 文件读写
10.6 三种内存分配方法
10.7 小结
习题
10-0编译、运行并测试本章的例程。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <cstdlib>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::max;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;

int pointers()
{
    int x = 5;

    int *p = &x;
    cout << "x = " << x << endl;

    *p = 6;
    cout << "x = " << x << endl;
    return 0;
}

string letter_grade(double grade)
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };
    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };
    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);
    for (size_t i = 0; i < ngrades; ++i)
    {
        if (grade >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

int copy_file(string in, string out)
{
    ifstream infile(in);
    ofstream outfile(out);
    string s;
    while (getline(infile, s, '\n'))
    {
        outfile << s << endl;
    }
    return 0;
}

int print_files(int argc, const char * argv[])
{
    int fail_count = 0;
    for (int i = 0; i < argc; ++i)
    {
        ifstream in(argv[i]);
        if (in)
        {
            string s;
            while (getline(in, s, '\n'))
            {
                cout << s << endl;
            }
        }
        else
        {
            cerr << "cannot open file " << argv[i] << endl;
            ++fail_count;
        }
    }
    return fail_count;
}

char *duplicate_chars(const char *p)
{
    size_t length = strlen(p) + 1;
    char *result = new char[length];
    copy(p, p + length, result);
    return result;
}

int main()
{
    pointers();
    cout << letter_grade(75.0) << endl;
    copy_file("in_ch10.txt", "out_ch10.txt");
    const char *files[] = { "in_ch10.txt", "out_ch10.txt" };
    print_files(2, files);
    char *str = duplicate_chars("test");
    cout << str << endl;
    return 0;
}
显示结果如下
x = 5
x = 6
C
hello sir
how are you
doing today?
hello sir
how are you
doing today?
test

cat in_ch10.txt
hello sir
how are you
doing today?

cat out_ch10.txt
hello sir
how are you
doing today?

10-1 重写9.6的学生成绩程序，要求生成字母成绩。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <cstdlib>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::max;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;

class Student_info
{
private:
    string _name;
    double midterm, final;
    vector<double> homework;

public:
    Student_info();
    Student_info(istream &);

    istream &read(istream &);
    double grade() const;
    const string &name() const
    {
        return _name;
    }
    bool valid() const
    {
        return !homework.empty();
    }
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

Student_info::Student_info() : midterm(0), final(0) { }

Student_info::Student_info(istream &is)
{
    read(is);
}

istream &Student_info::read(istream &in)
{
    in >> _name >> midterm >> final;
    read_hw(in, homework);
    return in;
}

double Student_info::grade() const
{
    return ::grade(midterm, final, homework);
}

string letter_grade(double grade)
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };
    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };
    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);
    for (size_t i = 0; i < ngrades; ++i)
    {
        if (grade >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name() < y.name();
}

istream &read_and_grade(istream &is, vector<Student_info> &students)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];
    string::size_type maxlen = 0;

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student(ss);
        maxlen = max(maxlen, student.name().size());
        students.push_back(student);
    }
    sort(students.begin(), students.end(), compare);
    for (vector<Student_info>::size_type i = 0; i != students.size(); i++)
    {
        cout << students[i].name() << string(maxlen + 1 - students[i].name().size(), ' ');

        try
        {
            double final_grade = students[i].grade();
            streamsize prec = cout.precision();
            cout << setprecision(3) << final_grade << setprecision(prec) << " ";
            cout << letter_grade(final_grade) << endl;
        }
        catch (domain_error e)
        {
            cout << e.what() << endl;
        }
    }

    return is;
}


int test_read_and_grade()
{
    vector<Student_info> students;
    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read_and_grade(infile, students);
    infile.close();
    infile.clear();

    return 0;
}

int main()
{
    test_read_and_grade();
    return 0;
}
显示结果如下
Geert  67 D
Geert  67 D
Jan    30 F
Jan    30 F
Joris  76 C
Joris  76 C
Lotte  66 D
Lotte  66 D
Pieter 44 F
Pieter 44 F

10-2 重写8.1.1的median函数，使之可以通过向量或者C++自带的数组来调用该函数。该函数要求可以调用容纳有任何算术类型的容器
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <cstdlib>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::max;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::end;

class Student_info
{
private:
    string _name;
    double midterm, final;
    vector<double> homework;

public:
    Student_info();
    Student_info(istream &);

    istream &read(istream &);
    double grade() const;
    const string &name() const
    {
        return _name;
    }
    bool valid() const
    {
        return !homework.empty();
    }
};

template<typename In>
auto median_iter(In b, In e) -> decltype((*b + *b) / 2)
{
    if (b == e)
    {
        throw domain_error("median of empty container");
    }

    typedef decltype((*b + *b) / 2) T1;
    vector<T1> v1;
    copy(b, e, back_inserter(v1));
    sort(v1.begin(), v1.end());

    auto count = v1.size();
    auto mid = count / 2;
    return count % 2 == 0 ? (v1[mid] + v1[mid - 1]) / 2 : v1[mid];
}

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

Student_info::Student_info() : midterm(0), final(0) { }

Student_info::Student_info(istream &is)
{
    read(is);
}

istream &Student_info::read(istream &in)
{
    in >> _name >> midterm >> final;
    read_hw(in, homework);
    return in;
}

double Student_info::grade() const
{
    return ::grade(midterm, final, homework);
}

string letter_grade(double grade)
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };
    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };
    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);
    for (size_t i = 0; i < ngrades; ++i)
    {
        if (grade >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name() < y.name();
}

istream &read_and_grade(istream &is, vector<Student_info> &students)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];
    string::size_type maxlen = 0;

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student(ss);
        maxlen = max(maxlen, student.name().size());
        students.push_back(student);
    }
    sort(students.begin(), students.end(), compare);
    for (vector<Student_info>::size_type i = 0; i != students.size(); i++)
    {
        cout << students[i].name() << string(maxlen + 1 - students[i].name().size(), ' ');

        try
        {
            double final_grade = students[i].grade();
            streamsize prec = cout.precision();
            cout << setprecision(3) << final_grade << setprecision(prec) << " ";
            cout << letter_grade(final_grade) << endl;
        }
        catch (domain_error e)
        {
            cout << e.what() << endl;
        }
    }

    return is;
}


int test_read_and_grade()
{
    vector<Student_info> students;
    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read_and_grade(infile, students);
    infile.close();
    infile.clear();

    return 0;
}

int main()
{
    test_read_and_grade();

    double arr_double[] = { 12.5, 16.3, 25.7 };
    vector<double> vec_double(arr_double, end(arr_double));
    int arr_int[] = { 12, 26, 16, 30 };
    vector<int> vec_int(arr_int, end(arr_int));

    cout << median_iter<double *>(arr_double, end(arr_double)) << endl;
    cout << median_iter<vector<double>::iterator>(vec_double.begin(), vec_double.end()) << endl;
    cout << median_iter<int *>(arr_int, end(arr_int)) << endl;
    cout << median_iter<vector<int>::iterator>(vec_int.begin(), vec_int.end()) << endl;

    return 0;
}
显示结果如下
Geert  67 D
Geert  67 D
Jan    30 F
Jan    30 F
Joris  76 C
Joris  76 C
Lotte  66 D
Lotte  66 D
Pieter 44 F
Pieter 44 F
16.3
16.3
21
21

10-3 写一个测试程序验证刚才写的median函数。确保调用median函数时不会改变容器内的元素的先后顺序。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <cstdlib>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::max;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::end;

class Student_info
{
private:
    string _name;
    double midterm, final;
    vector<double> homework;

public:
    Student_info();
    Student_info(istream &);

    istream &read(istream &);
    double grade() const;
    const string &name() const
    {
        return _name;
    }
    bool valid() const
    {
        return !homework.empty();
    }
};

template<class T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename In>
auto median_iter(In b, In e) -> decltype((*b + *b) / 2)
{
    if (b == e)
    {
        throw domain_error("median of empty container");
    }

    typedef decltype((*b + *b) / 2) T1;
    vector<T1> v1;
    copy(b, e, back_inserter(v1));
    sort(v1.begin(), v1.end());

    auto count = v1.size();
    auto mid = count / 2;
    return count % 2 == 0 ? (v1[mid] + v1[mid - 1]) / 2 : v1[mid];
}

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

Student_info::Student_info() : midterm(0), final(0) { }

Student_info::Student_info(istream &is)
{
    read(is);
}

istream &Student_info::read(istream &in)
{
    in >> _name >> midterm >> final;
    read_hw(in, homework);
    return in;
}

double Student_info::grade() const
{
    return ::grade(midterm, final, homework);
}

string letter_grade(double grade)
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };
    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };
    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);
    for (size_t i = 0; i < ngrades; ++i)
    {
        if (grade >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name() < y.name();
}

istream &read_and_grade(istream &is, vector<Student_info> &students)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];
    string::size_type maxlen = 0;

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student(ss);
        maxlen = max(maxlen, student.name().size());
        students.push_back(student);
    }
    sort(students.begin(), students.end(), compare);
    for (vector<Student_info>::size_type i = 0; i != students.size(); i++)
    {
        cout << students[i].name() << string(maxlen + 1 - students[i].name().size(), ' ');

        try
        {
            double final_grade = students[i].grade();
            streamsize prec = cout.precision();
            cout << setprecision(3) << final_grade << setprecision(prec) << " ";
            cout << letter_grade(final_grade) << endl;
        }
        catch (domain_error e)
        {
            cout << e.what() << endl;
        }
    }

    return is;
}


int test_read_and_grade()
{
    vector<Student_info> students;
    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read_and_grade(infile, students);
    infile.close();
    infile.clear();

    return 0;
}

int main()
{
    test_read_and_grade();

    double arr_double[] = { 12.5, 5.25, 25.7, 16.3, 1.26 };
    vector<double> vec_double(arr_double, end(arr_double));
    int arr_int[] = { 12, 26, 16, 30 };
    vector<int> vec_int(arr_int, end(arr_int));

    cout << median_iter<double *>(arr_double, end(arr_double)) << endl;
    print_vector(vec_double, cout);
    cout << median_iter<vector<double>::iterator>(vec_double.begin(), vec_double.end()) << endl;
    print_vector(vec_double, cout);
    cout << median_iter<int *>(arr_int, end(arr_int)) << endl;
    print_vector(vec_int, cout);
    cout << median_iter<vector<int>::iterator>(vec_int.begin(), vec_int.end()) << endl;
    print_vector(vec_int, cout);

    return 0;
}
显示结果如下
Geert  67 D
Geert  67 D
Jan    30 F
Jan    30 F
Joris  76 C
Joris  76 C
Lotte  66 D
Lotte  66 D
Pieter 44 F
Pieter 44 F
12.5
12.5, 5.25, 25.7, 16.3, 1.26
12.5
12.5, 5.25, 25.7, 16.3, 1.26
21
12, 26, 16, 30
21
12, 26, 16, 30

10-4写一个类使之成为一个可以存储strings的链表。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <cstdlib>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::max;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::end;


class String_list
{
private:
  string *l;
  string::size_type size;
  string::size_type max;

  void resize();
public:
  typedef string* iterator;

  String_list() : l(new string[1]), size(0), max(1) {};
  String_list(const String_list & src);
  ~String_list();

  void push_back(string);
  string* begin() { return l; }
  string* end() { return l + size; };
};

String_list::String_list(const String_list& src)
{
  size = src.size;
  max = src.max;
  l = new string[max];

  for (string::size_type i = 0; i < size; i++)
  {
    l[i] = src.l[i];
  }
}

String_list::~String_list()
{
  delete[] l;
}

void String_list::resize()
{
  max *= 2;

  string* copy = new string[max];

  for (string::size_type i = 0; i < size; i++)
  {
    copy[i] = l[i];
  }

  delete[] l;

  l = copy;
}

void String_list::push_back(string str)
{
  if (size == max)
  {
    resize();
  }

  l[size++] = str;
}

int main()
{
  String_list str_list;

  str_list.push_back("test");
  str_list.push_back("more");
  str_list.push_back("testing");
  str_list.push_back("even more");
  str_list.push_back("yup");

  String_list::iterator iter = str_list.begin();

  while (iter != str_list.end())
  {
    cout << *iter++ << endl;
  }

  return 0;
}
显示结果如下
test
more
testing
even more
yup

10-5 为上面的String list类写一个双向迭代器。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <cstdlib>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::max;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::end;


class String_list
{
private:
    string *l;
    string::size_type size;
    string::size_type max;

    void resize();
public:
    typedef string *iterator;

    String_list() : l(new string[1]), size(0), max(1) {};
    String_list(const String_list &src);
    ~String_list();

    void push_back(string);
    string *begin()
    {
        return l;
    }
    string *end()
    {
        return l + size;
    };
};

String_list::String_list(const String_list &src)
{
    size = src.size;
    max = src.max;
    l = new string[max];

    for (string::size_type i = 0; i < size; i++)
    {
        l[i] = src.l[i];
    }
}

String_list::~String_list()
{
    delete[] l;
}

void String_list::resize()
{
    max *= 2;

    string *copy = new string[max];

    for (string::size_type i = 0; i < size; i++)
    {
        copy[i] = l[i];
    }

    delete[] l;

    l = copy;
}

void String_list::push_back(string str)
{
    if (size == max)
    {
        resize();
    }

    l[size++] = str;
}

int main()
{
    String_list str_list;

    str_list.push_back("test");
    str_list.push_back("more");
    str_list.push_back("testing");
    str_list.push_back("even more");
    str_list.push_back("yup");

    String_list::iterator iter = str_list.begin();

    while (iter != str_list.end())
    {
        cout << *iter++ << endl;
    }

    while (iter != str_list.begin())
    {
        cout << *(--iter) << endl;
    }

    return 0;
}
显示结果如下
test
more
testing
even more
yup
yup
even more
testing
more
test

10-6为了检验上面的类，重写split函数把结果输入到String_list类中。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <cctype>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::end;


class String_list
{
private:
    string *l;
    string::size_type size;
    string::size_type max;

    void resize();
public:
    typedef string *iterator;

    String_list() : l(new string[1]), size(0), max(1) {};
    String_list(const String_list &src);
    ~String_list();

    String_list &operator = (const String_list &str_list);
    void push_back(string);
    string *begin()
    {
        return l;
    }
    string *end()
    {
        return l + size;
    };
};

String_list::String_list(const String_list &src)
{
    size = src.size;
    max = src.max;
    l = new string[max];

    for (string::size_type i = 0; i < size; i++)
    {
        l[i] = src.l[i];
    }
}

String_list::~String_list()
{
    delete[] l;
}

String_list &String_list::operator = (const String_list &str_list)
{
    if (this == &str_list)
    {
        return *this;
    }

    delete[] l;
    size = str_list.size;
    max = str_list.max;
    l = new string[max];

    for (string::size_type i = 0; i < size; i++)
    {
        l[i] = str_list.l[i];
    }

    return *this;
}

void String_list::resize()
{
    max *= 2;

    string *copy = new string[max];

    for (string::size_type i = 0; i < size; i++)
    {
        copy[i] = l[i];
    }

    delete[] l;

    l = copy;
}

void String_list::push_back(string str)
{
    if (size == max)
    {
        resize();
    }

    l[size++] = str;
}

bool space(char c)
{
    return isspace(c) != 0;
}

bool not_space(char c)
{
    return !isspace(c);
}

String_list split(const string &str)
{
    typedef string::const_iterator iter;
    String_list ret;

    iter i = str.begin();
    while (i != str.end())
    {
        i = find_if(i, str.end(), not_space);

        iter j = find_if(i, str.end(), space);

        if (i != j)
        {
            ret.push_back(string(i, j));
            i = j;
        }
    }
    return ret;
}

int main()
{
    string str = "Please split this amazing string!";
    String_list str_l = split(str);
    String_list::iterator iter = str_l.begin();

    while (iter != str_l.end())
    {
        cout << *iter++ << endl;
    }

    return 0;
}
显示结果如下
Please
split
this
amazing
string!

第11章 定义抽象数据类型
11.1 Vec类
11.2 实现Vec类
11.3 复制控制
11.4 动态的Vec类型对象
11.5 灵活的内存管理
11.6 小结
习题
11-0编译、执行并测试本章讲到的程序。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}


int main()
{
    Vec<int> v1(5, 5);
    Vec<int> v2;

    v2 = v1;

    for (Vec<int>::size_type i = 2; i < v1.size(); i++)
    {
        v1[i] = 7;
    }

    for (Vec<int>::size_type i = 0; i < 10; i++)
    {
        v2.push_back(10);
    }

    v1.print_vec(cout);
    v2.print_vec(cout);

    return 0;
}
显示结果如下
5, 5, 7, 7, 7
5, 5, 5, 5, 5, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10

11-1 在第9章中定义的Student info结构中没有定义复制构造函数，也没有定义赋值操作或者析构函数，为什么？
Student_info类的数据成员是标准库模板类或基本类型变量，
编译器提供的默认复制构造函数、默认赋值操作符函数、默认析构函数可以正确处理这些成员。

11-2 在那个结构中也没有定义一个默认的构造函数，为什么？
Student_info类的数据成员是标准库模板类或基本类型变量，
编译器提供的默认构造函数可以正确处理这些成员。

11-3 Student_info的对象在调用自动生成的赋值操作函数时具体有什么操作？
针对每个成员执行浅复制，如果成员是类对象，则调用对应类的赋值操作符函数来完成浅复制。
如果成员是基本类型变量，则使用直接赋值来完成浅复制。

11-4 在Student_info中，自动生成的析构函数删除了多少个成员变量？
如果成员是类对象，则先依次调用这些成员的析构函数，再释放Student_info的对象。

11-5 在Studentinfo类加入计数代码，计算一下对象被创建、复制、赋值或者删除了多少次。
用这个可计数的类来运行第6章的学生成绩程序。使用这个具有计数功能的Student_info类可以算出在库中的算法进行了多少次复制操作。
对比库中不同的类测到的复制次数，可以估计出这些不同的类对资源的消耗量。试一试进行计数并对结果进行分析。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::accumulate;
using std::find;
using std::max;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;

class Student_info
{
private:
    string _name;
    double midterm, final;
    vector<double> homework;

    static int default_constructor_calls;
    static int stream_constructor_calls;
    static int copy_constructor_calls;
    static int assignment_calls;
    static int destructor_calls;

public:
    Student_info();
    Student_info(istream &);
    Student_info(const Student_info &);

    Student_info &operator=(const Student_info &);
    ~Student_info();

    istream &read(istream &);
    double grade() const;
    const string &name() const
    {
        return _name;
    }
    bool valid() const
    {
        return !homework.empty();
    }

    static void reset_class_info();
    static ostream &print_class_info(ostream &);
};

int Student_info::default_constructor_calls = 0;
int Student_info::stream_constructor_calls = 0;
int Student_info::copy_constructor_calls = 0;
int Student_info::assignment_calls = 0;
int Student_info::destructor_calls = 0;

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

Student_info::Student_info() : midterm(0), final(0)
{
    ++default_constructor_calls;
}

Student_info::Student_info(istream &is)
{
    ++stream_constructor_calls;
    read(is);
}

Student_info::Student_info(const Student_info &student)
{
    ++copy_constructor_calls;

    _name = student._name;
    midterm = student.midterm;
    final = student.final;
    homework = student.homework;
}

Student_info &Student_info::operator=(const Student_info &student)
{
    ++assignment_calls;

    if (this == &student)
    {
        return *this;
    }
    _name = student._name;
    midterm = student.midterm;
    final = student.final;
    homework = student.homework;

    return *this;
}

Student_info::~Student_info()
{
    ++destructor_calls;
}

istream &Student_info::read(istream &in)
{
    in >> _name >> midterm >> final;
    read_hw(in, homework);
    return in;
}

double Student_info::grade() const
{
    return ::grade(midterm, final, homework);
}

void Student_info::reset_class_info()
{
    default_constructor_calls = 0;
    stream_constructor_calls = 0;
    copy_constructor_calls = 0;
    assignment_calls = 0;
    destructor_calls = 0;
}

ostream &Student_info::print_class_info(ostream &os)
{
    os << default_constructor_calls << '\t' << "default constructor calls" << endl;
    os << stream_constructor_calls << '\t' << "stream constructor calls" << endl;
    os << copy_constructor_calls << '\t' << "copy constructor calls" << endl;
    os << assignment_calls << '\t' << "assignment calls" << endl;
    os << destructor_calls << '\t' << "destructor calls" << endl;

    return os;
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name() < y.name();
}

istream &read_and_grade(istream &is, vector<Student_info> &students)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];
    string::size_type maxlen = 0;

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student(ss);
        maxlen = max(maxlen, student.name().size());
        students.push_back(student);
    }
    sort(students.begin(), students.end(), compare);
    for (vector<Student_info>::size_type i = 0; i != students.size(); i++)
    {
        cout << students[i].name() << string(maxlen + 1 - students[i].name().size(), ' ');

        try
        {
            double final_grade = students[i].grade();
            streamsize prec = cout.precision();
            cout << setprecision(3) << final_grade << setprecision(prec) << endl;
        }
        catch (domain_error e)
        {
            cout << e.what() << endl;
        }
    }

    return is;
}


int test_read_and_grade()
{
    vector<Student_info> students;
    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read_and_grade(infile, students);
    infile.close();
    infile.clear();

    for (vector<Student_info>::const_iterator iter = students.begin(); iter != students.end(); ++iter)
    {
        cout << iter->name() << " is valid = " << iter->valid() << endl;
    }

    return 0;
}

istream &read(istream &is, vector<Student_info> &v)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student(ss);
        v.push_back(student);
    }

    return is;
}

bool fgrade(const Student_info &student)
{
    return student.grade() < 60;
}

bool pgrade(const Student_info &student)
{
    return !fgrade(student);
}

vector<Student_info> extract(vector<Student_info> &students, bool criteria(const Student_info &))
{
    vector<Student_info>::iterator iter = stable_partition(students.begin(), students.end(), criteria);
    vector<Student_info> extracted(iter, students.end());
    students.erase(iter, students.end());

    return extracted;
}

void test_student_info(string file)
{
    Student_info::reset_class_info();
    ifstream infile;
    vector<Student_info> students;
    vector<Student_info> failed;

    infile.open(file);
    steady_clock::time_point begin = std::chrono::steady_clock::now();
    read(infile, students);
    steady_clock::time_point end = std::chrono::steady_clock::now();
    cout << "Microseconds to read " << file << " into vector = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;
    Student_info::print_class_info(cout);
    infile.close();
    infile.clear();
    Student_info::reset_class_info();

    begin = std::chrono::steady_clock::now();
    failed = extract(students, pgrade);
    end = std::chrono::steady_clock::now();
    cout << "Microseconds to extract failed from " << file << " student vector = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;
    Student_info::print_class_info(cout);
}

void test_student_info()
{
    test_student_info("students10.txt");
    cout << endl;
    test_student_info("students100.txt");
    cout << endl;
    test_student_info("students1000.txt");
    cout << endl;
    test_student_info("students10000.txt");
}

int main()
{
    test_read_and_grade();
    test_student_info();

    return 0;
}
显示结果如下

Geert  67
Geert  67
Jan    30
Jan    30
Joris  76
Joris  76
Lotte  66
Lotte  66
Pieter 44
Pieter 44
Geert is valid = 1
Geert is valid = 1
Jan is valid = 1
Jan is valid = 1
Joris is valid = 1
Joris is valid = 1
Lotte is valid = 1
Lotte is valid = 1
Pieter is valid = 1
Pieter is valid = 1
Microseconds to read students10.txt into vector = 39
0       default constructor calls
10      stream constructor calls
25      copy constructor calls
0       assignment calls
25      destructor calls
Microseconds to extract failed from students10.txt student vector = 64
0       default constructor calls
0       stream constructor calls
13      copy constructor calls
14      assignment calls
13      destructor calls

Microseconds to read students100.txt into vector = 436
0       default constructor calls
100     stream constructor calls
227     copy constructor calls
0       assignment calls
227     destructor calls
Microseconds to extract failed from students100.txt student vector = 197
0       default constructor calls
0       stream constructor calls
139     copy constructor calls
140     assignment calls
139     destructor calls

Microseconds to read students1000.txt into vector = 3631
0       default constructor calls
1000    stream constructor calls
2023    copy constructor calls
0       assignment calls
2023    destructor calls
Microseconds to extract failed from students1000.txt student vector = 1681
0       default constructor calls
0       stream constructor calls
1399    copy constructor calls
1400    assignment calls
1399    destructor calls

Microseconds to read students10000.txt into vector = 28098
0       default constructor calls
10000   stream constructor calls
26383   copy constructor calls
0       assignment calls
26383   destructor calls
Microseconds to extract failed from students10000.txt student vector = 11680
0       default constructor calls
0       stream constructor calls
13999   copy constructor calls
14000   assignment calls
13999   destructor calls

11-6 在Vec类中增加一个删除其中一个元素的操作，再增加一个清空整个Vec类型对象的操作。它们的作用与向量类中的erase与clear成员函数相同。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

int main()
{
    Vec<int> v(10, 10);
    v.print_vec(cout);
    v.clear();
    if (v.size() == 0)
    {
        cout << "vector is empty\n";
    }
    v.print_vec(cout);
    cout << endl;
    for (Vec<int>::size_type i = 0; i < 10; i++)
    {
        v.push_back(i);
    }
    v.print_vec(cout);
    v.erase(v.begin() + 2);
    v.print_vec(cout);
    v.erase(v.begin() + 4, v.begin() + 7);
    v.print_vec(cout);

    return 0;
}
显示结果如下
10, 10, 10, 10, 10, 10, 10, 10, 10, 10
vector is empty

0, 1, 2, 3, 4, 5, 6, 7, 8, 9
0, 1, 3, 4, 5, 6, 7, 8, 9
0, 1, 3, 4, 8, 9

11-7在向Vec类中加入了erase与clear函数后，在本书前面举出的大部分例程中都可以用Vec类代替向量类。
用Vec代替向量，重写第9章的Student info程序和第5章中处理字符图形的程序。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

class Student_info
{
private:
    string _name;
    double midterm, final;
    vector<double> homework;

    static int default_constructor_calls;
    static int stream_constructor_calls;
    static int copy_constructor_calls;
    static int assignment_calls;
    static int destructor_calls;

public:
    Student_info();
    Student_info(istream &);
    Student_info(const Student_info &);

    Student_info &operator=(const Student_info &);
    ~Student_info();

    istream &read(istream &);
    double grade() const;
    const string &name() const
    {
        return _name;
    }
    bool valid() const
    {
        return !homework.empty();
    }

    static void reset_class_info();
    static ostream &print_class_info(ostream &);
};

int Student_info::default_constructor_calls = 0;
int Student_info::stream_constructor_calls = 0;
int Student_info::copy_constructor_calls = 0;
int Student_info::assignment_calls = 0;
int Student_info::destructor_calls = 0;

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

Student_info::Student_info() : midterm(0), final(0)
{
    ++default_constructor_calls;
}

Student_info::Student_info(istream &is)
{
    ++stream_constructor_calls;
    read(is);
}

Student_info::Student_info(const Student_info &student)
{
    ++copy_constructor_calls;

    _name = student._name;
    midterm = student.midterm;
    final = student.final;
    homework = student.homework;
}

Student_info &Student_info::operator=(const Student_info &student)
{
    ++assignment_calls;

    if (this == &student)
    {
        return *this;
    }
    _name = student._name;
    midterm = student.midterm;
    final = student.final;
    homework = student.homework;

    return *this;
}

Student_info::~Student_info()
{
    ++destructor_calls;
}

istream &Student_info::read(istream &in)
{
    in >> _name >> midterm >> final;
    read_hw(in, homework);
    return in;
}

double Student_info::grade() const
{
    return ::grade(midterm, final, homework);
}

void Student_info::reset_class_info()
{
    default_constructor_calls = 0;
    stream_constructor_calls = 0;
    copy_constructor_calls = 0;
    assignment_calls = 0;
    destructor_calls = 0;
}

ostream &Student_info::print_class_info(ostream &os)
{
    os << default_constructor_calls << '\t' << "default constructor calls" << endl;
    os << stream_constructor_calls << '\t' << "stream constructor calls" << endl;
    os << copy_constructor_calls << '\t' << "copy constructor calls" << endl;
    os << assignment_calls << '\t' << "assignment calls" << endl;
    os << destructor_calls << '\t' << "destructor calls" << endl;

    return os;
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name() < y.name();
}

istream &read_and_grade(istream &is, Vec<Student_info> &students)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];
    string::size_type maxlen = 0;

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student(ss);
        maxlen = max(maxlen, student.name().size());
        students.push_back(student);
    }
    sort(students.begin(), students.end(), compare);
    for (Vec<Student_info>::size_type i = 0; i != students.size(); i++)
    {
        cout << students[i].name() << string(maxlen + 1 - students[i].name().size(), ' ');

        try
        {
            double final_grade = students[i].grade();
            streamsize prec = cout.precision();
            cout << setprecision(3) << final_grade << setprecision(prec) << endl;
        }
        catch (domain_error e)
        {
            cout << e.what() << endl;
        }
    }

    return is;
}


int test_read_and_grade()
{
    Vec<Student_info> students;
    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read_and_grade(infile, students);
    infile.close();
    infile.clear();

    for (Vec<Student_info>::const_iterator iter = students.begin(); iter != students.end(); ++iter)
    {
        cout << iter->name() << " is valid = " << iter->valid() << endl;
    }

    return 0;
}

istream &read(istream &is, Vec<Student_info> &v)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student(ss);
        v.push_back(student);
    }

    return is;
}

bool fgrade(const Student_info &student)
{
    return student.grade() < 60;
}

bool pgrade(const Student_info &student)
{
    return !fgrade(student);
}

vector<Student_info> extract(Vec<Student_info> &students, bool criteria(const Student_info &))
{
    Vec<Student_info>::iterator iter = stable_partition(students.begin(), students.end(), criteria);
    vector<Student_info> extracted(iter, students.end());
    students.erase(iter, students.end());

    return extracted;
}

void test_student_info(string file)
{
    Student_info::reset_class_info();
    ifstream infile;
    Vec<Student_info> students;
    vector<Student_info> failed;

    infile.open(file);
    steady_clock::time_point begin = std::chrono::steady_clock::now();
    read(infile, students);
    steady_clock::time_point end = std::chrono::steady_clock::now();
    cout << "Microseconds to read " << file << " into vector = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;
    Student_info::print_class_info(cout);
    infile.close();
    infile.clear();
    Student_info::reset_class_info();

    begin = std::chrono::steady_clock::now();
    failed = extract(students, pgrade);
    end = std::chrono::steady_clock::now();
    cout << "Microseconds to extract failed from " << file << " student vector = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;
    Student_info::print_class_info(cout);
}

void test_student_info()
{
    test_student_info("students10.txt");
    cout << endl;
    test_student_info("students100.txt");
    cout << endl;
    test_student_info("students1000.txt");
    cout << endl;
    test_student_info("students10000.txt");
}

string::size_type width(const Vec<string>& v)
{
  string::size_type maxlen = 0;

  for (Vec<string>::size_type i = 0; i != v.size(); ++i)
  {
    maxlen = max(maxlen, v[i].size());
  }

  return maxlen;
}

Vec<string> frame(const Vec<string>& v)
{
  Vec<string> ret;
  string::size_type maxlen = width(v);
  string border(maxlen + 4, '*');

  ret.push_back(border);

  for (Vec<string>::size_type i = 0; i != v.size(); ++i)
  {
    ret.push_back("* " + v[i] + string(maxlen - v[i].size(), ' ') + " *");
  }

  ret.push_back(border);

  return ret;
}

Vec<string> vcat(const Vec<string>& top, const Vec<string>& bottom)
{
  Vec<string> ret = top;

  for (Vec<string>::const_iterator it = bottom.begin(); it != bottom.end(); ++it)
  {
    ret.push_back(*it);
  }

  return ret;
}

Vec<string> hcat(const Vec<string>& left, const Vec<string>& right)
{
  Vec<string> ret;

  string::size_type width1 = width(left) + 1;

  Vec<string>::size_type i = 0, j = 0;

  while (i != left.size() || j != right.size())
  {
    string s;

    if (i != left.size())
    {
      s = left[i++];
    }

    s += string(width1 - s.size(), ' ');

    if (j != right.size())
    {
      s += right[j++];
    }

    ret.push_back(s);
  }

  return ret;
}

int test_frame()
{
  Vec<string> v1;
  v1.push_back("one test");
  v1.push_back("two test");
  v1.push_back("aye caramba");

  Vec<string> v2;
  v2.push_back("one direction");
  v2.push_back("mama mia");
  v2.push_back("mamo testo");
  v2.push_back("lake district mall");

  Vec<string> vert = vcat(frame(v1), frame(v2));

  Vec<string>::const_iterator iter = vert.begin();

  while (iter != vert.end())
  {
    cout << *iter++ << endl;
  }

  Vec<string> horz = hcat(frame(v1), frame(v2));

  iter = horz.begin();

  while (iter != horz.end())
  {
    cout << *iter++ << endl;
  }

  return 0;
}

int main()
{
    test_read_and_grade();
    test_student_info();
    cout << endl;
    test_frame();

    return 0;
}
显示结果如下
Geert  67
Geert  67
Jan    30
Jan    30
Joris  76
Joris  76
Lotte  66
Lotte  66
Pieter 44
Pieter 44
Geert is valid = 1
Geert is valid = 1
Jan is valid = 1
Jan is valid = 1
Joris is valid = 1
Joris is valid = 1
Lotte is valid = 1
Lotte is valid = 1
Pieter is valid = 1
Pieter is valid = 1
Microseconds to read students10.txt into vector = 38
0       default constructor calls
10      stream constructor calls
25      copy constructor calls
0       assignment calls
25      destructor calls
Microseconds to extract failed from students10.txt student vector = 23
0       default constructor calls
0       stream constructor calls
13      copy constructor calls
14      assignment calls
13      destructor calls

Microseconds to read students100.txt into vector = 447
0       default constructor calls
100     stream constructor calls
227     copy constructor calls
0       assignment calls
227     destructor calls
Microseconds to extract failed from students100.txt student vector = 208
0       default constructor calls
0       stream constructor calls
139     copy constructor calls
140     assignment calls
139     destructor calls

Microseconds to read students1000.txt into vector = 2929
0       default constructor calls
1000    stream constructor calls
2023    copy constructor calls
0       assignment calls
2023    destructor calls
Microseconds to extract failed from students1000.txt student vector = 1245
0       default constructor calls
0       stream constructor calls
1399    copy constructor calls
1400    assignment calls
1399    destructor calls

Microseconds to read students10000.txt into vector = 27478
0       default constructor calls
10000   stream constructor calls
26383   copy constructor calls
0       assignment calls
26383   destructor calls
Microseconds to extract failed from students10000.txt student vector = 11486
0       default constructor calls
0       stream constructor calls
13999   copy constructor calls
14000   assignment calls
13999   destructor calls

***************
* one test    *
* two test    *
* aye caramba *
***************
**********************
* one direction      *
* mama mia           *
* mamo testo         *
* lake district mall *
**********************
*************** **********************
* one test    * * one direction      *
* two test    * * mama mia           *
* aye caramba * * mamo testo         *
*************** * lake district mall *
                **********************

11-8 为标准list类以及它的相关迭代器写一个简化版本
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
struct Node
{
    T data;
    Node<T> *previous;
    Node<T> *next;

    Node() : data(T()), previous(nullptr), next(nullptr) {};
    Node(const T &d) : data(d), previous(nullptr), next(nullptr) {};
};

template <typename T>
class NodeIterator
{
public:
    NodeIterator(Node<T> *ptr) : node_ptr(ptr) {};

    NodeIterator &operator++();
    NodeIterator &operator--();
    NodeIterator  operator++(int);
    NodeIterator  operator--(int);
    bool operator!=(const NodeIterator &) const;
    T &operator*() const;

private:
    Node<T> *node_ptr;
};

template <typename T>
NodeIterator<T> &NodeIterator<T>::operator++()
{
    node_ptr = node_ptr->next;
    return *this;
}

template <typename T>
NodeIterator<T> &NodeIterator<T>::operator--()
{
    node_ptr = node_ptr->previous;
    return *this;
}

template <typename T>
NodeIterator<T> NodeIterator<T>::operator++(int)
{
    NodeIterator<T> ret(this->node_ptr);
    node_ptr = node_ptr->next;
    return ret;
}

template <typename T>
NodeIterator<T> NodeIterator<T>::operator--(int)
{
    NodeIterator<T> ret(this->node_ptr);
    node_ptr = node_ptr->previous;
    return ret;
}

template <typename T>
bool NodeIterator<T>::operator!=(const NodeIterator &rhs) const
{
    return this->node_ptr != rhs.node_ptr;
}

template <typename T>
T &NodeIterator<T>::operator*() const
{
    return node_ptr->data;
}

template <typename T>
class LList
{
public:
    typedef NodeIterator<T> iterator;
    typedef const NodeIterator<T> const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    LList() : front(nullptr), back(nullptr), _size(0) {}
    explicit LList(size_type n, const T &val = T()) : front(nullptr), back(nullptr), _size(0)
    {
        create(n, val);
    }
    LList(const LList &l) : front(nullptr), back(nullptr), _size(0)
    {
        create(l.begin(), l.end());
    }

    LList &operator=(const LList &);
    ~LList()
    {
        uncreate();
    }

    void push_back(const T &val)
    {
        append(val);
    }

    size_type size() const
    {
        return _size;
    }
    iterator begin()
    {
        return iterator(front);
    }
    const_iterator begin() const
    {
        return iterator(front);
    }
    iterator end()
    {
        return iterator(nullptr);
    }
    const_iterator end() const
    {
        return iterator(nullptr);
    }

private:
    Node<T> *front;
    Node<T> *back;
    size_type _size;

    void create(size_type, const T &);
    void create(iterator, iterator);
    void append(const T &);
    void uncreate();

};

template <typename T>
LList<T> &LList<T>::operator=(const LList &l)
{
    if (this == &l)
    {
        return *this;
    }
    uncreate();
    create(l.begin(), l.end());
    return *this;
}

template <typename T>
void LList<T>::create(size_type n, const T &val)
{
    for (size_type i = 0; i < n; i++)
    {
        append(val);
    }
}

template <typename T>
void LList<T>::create(iterator b, iterator e)
{
    while (b != e)
    {
        append(*b++);
    }
}

template <typename T>
void LList<T>::append(const T &val)
{
    Node<T> *node = new Node<T>(val);

    if (_size == 0)
    {
        front = back = node;
    }
    else if (_size == 1)
    {
        node->previous = front;
        front->next = node;
        back = node;
    }
    else
    {
        node->previous = back;
        back->next = node;
        back = node;
    }

    _size++;
}

template <typename T>
void LList<T>::uncreate()
{
    Node<T> *node = back;

    while (node != nullptr)
    {
        Node<T> *node_delete = node;
        node = node->previous;
        delete node_delete;
    }

    front = back = nullptr;
    _size = 0;
}

int main()
{
    LList<int> list;
    list.push_back(5);
    list.push_back(10);
    list.push_back(15);

    LList<int>::iterator iter = list.begin();

    cout << *++iter << endl;
    cout << *--iter << endl;

    while (iter != list.end())
    {
        cout << *iter++ << endl;
    }

    LList<string> stringlist(5, "test");
    LList<string> stringlist_copy = stringlist;
    LList<string>::iterator listIter = stringlist.begin();

    *listIter = "first";

    while (listIter != stringlist.end())
    {
        cout << *listIter++ << endl;
    }

    if (stringlist_copy.size() > 0)
    {
        listIter = stringlist_copy.begin();
        while (listIter != stringlist.end())
        {
            cout << *listIter++ << endl;
        }
    }

    return 0;
}
显示结果如下
10
5
5
10
15
first
test
test
test
test
test
test
test
test
test

11-9 11.5.1中的grow函数为程序分配了实际需要的两倍的内存空间。
估算一下这种方法能对工作效率有多大的提高。如果你能估计出它的不同之处，请适当地改写grow函数，然后测量一下它们的差别。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

class Student_info
{
private:
    string _name;
    double midterm, final;
    vector<double> homework;

    static int default_constructor_calls;
    static int stream_constructor_calls;
    static int copy_constructor_calls;
    static int assignment_calls;
    static int destructor_calls;

public:
    Student_info();
    Student_info(istream &);
    Student_info(const Student_info &);

    Student_info &operator=(const Student_info &);
    ~Student_info();

    istream &read(istream &);
    double grade() const;
    const string &name() const
    {
        return _name;
    }
    bool valid() const
    {
        return !homework.empty();
    }

    static void reset_class_info();
    static ostream &print_class_info(ostream &);
};

int Student_info::default_constructor_calls = 0;
int Student_info::stream_constructor_calls = 0;
int Student_info::copy_constructor_calls = 0;
int Student_info::assignment_calls = 0;
int Student_info::destructor_calls = 0;

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

Student_info::Student_info() : midterm(0), final(0)
{
    ++default_constructor_calls;
}

Student_info::Student_info(istream &is)
{
    ++stream_constructor_calls;
    read(is);
}

Student_info::Student_info(const Student_info &student)
{
    ++copy_constructor_calls;

    _name = student._name;
    midterm = student.midterm;
    final = student.final;
    homework = student.homework;
}

Student_info &Student_info::operator=(const Student_info &student)
{
    ++assignment_calls;

    if (this == &student)
    {
        return *this;
    }
    _name = student._name;
    midterm = student.midterm;
    final = student.final;
    homework = student.homework;

    return *this;
}

Student_info::~Student_info()
{
    ++destructor_calls;
}

istream &Student_info::read(istream &in)
{
    in >> _name >> midterm >> final;
    read_hw(in, homework);
    return in;
}

double Student_info::grade() const
{
    return ::grade(midterm, final, homework);
}

void Student_info::reset_class_info()
{
    default_constructor_calls = 0;
    stream_constructor_calls = 0;
    copy_constructor_calls = 0;
    assignment_calls = 0;
    destructor_calls = 0;
}

ostream &Student_info::print_class_info(ostream &os)
{
    os << default_constructor_calls << '\t' << "default constructor calls" << endl;
    os << stream_constructor_calls << '\t' << "stream constructor calls" << endl;
    os << copy_constructor_calls << '\t' << "copy constructor calls" << endl;
    os << assignment_calls << '\t' << "assignment calls" << endl;
    os << destructor_calls << '\t' << "destructor calls" << endl;

    return os;
}

bool compare(const Student_info &x, const Student_info &y)
{
    return x.name() < y.name();
}

istream &read_and_grade(istream &is, Vec<Student_info> &students)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];
    string::size_type maxlen = 0;

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student(ss);
        maxlen = max(maxlen, student.name().size());
        students.push_back(student);
    }
    sort(students.begin(), students.end(), compare);
    for (Vec<Student_info>::size_type i = 0; i != students.size(); i++)
    {
        cout << students[i].name() << string(maxlen + 1 - students[i].name().size(), ' ');

        try
        {
            double final_grade = students[i].grade();
            streamsize prec = cout.precision();
            cout << setprecision(3) << final_grade << setprecision(prec) << endl;
        }
        catch (domain_error e)
        {
            cout << e.what() << endl;
        }
    }

    return is;
}


int test_read_and_grade()
{
    Vec<Student_info> students;
    string file = "students10_ch06.txt";
    ifstream infile;
    infile.open(file);
    read_and_grade(infile, students);
    infile.close();
    infile.clear();

    for (Vec<Student_info>::const_iterator iter = students.begin(); iter != students.end(); ++iter)
    {
        cout << iter->name() << " is valid = " << iter->valid() << endl;
    }

    return 0;
}

istream &read(istream &is, Vec<Student_info> &v)
{
    const int BUFFSIZE = 128;

    stringstream ss;
    char buff[BUFFSIZE];

    while (is.getline(buff, BUFFSIZE))
    {
        ss << buff;
        Student_info student(ss);
        v.push_back(student);
    }

    return is;
}

bool fgrade(const Student_info &student)
{
    return student.grade() < 60;
}

bool pgrade(const Student_info &student)
{
    return !fgrade(student);
}

vector<Student_info> extract(Vec<Student_info> &students, bool criteria(const Student_info &))
{
    Vec<Student_info>::iterator iter = stable_partition(students.begin(), students.end(), criteria);
    vector<Student_info> extracted(iter, students.end());
    students.erase(iter, students.end());

    return extracted;
}

void test_student_info(string file)
{
    Student_info::reset_class_info();
    ifstream infile;
    Vec<Student_info> students;
    vector<Student_info> failed;

    infile.open(file);
    steady_clock::time_point begin = std::chrono::steady_clock::now();
    read(infile, students);
    steady_clock::time_point end = std::chrono::steady_clock::now();
    cout << "Microseconds to read " << file << " into vector = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;
    Student_info::print_class_info(cout);
    infile.close();
    infile.clear();
    Student_info::reset_class_info();

    begin = std::chrono::steady_clock::now();
    failed = extract(students, pgrade);
    end = std::chrono::steady_clock::now();
    cout << "Microseconds to extract failed from " << file << " student vector = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;
    Student_info::print_class_info(cout);
}

void test_student_info()
{
    test_student_info("students10.txt");
    cout << endl;
    test_student_info("students100.txt");
    cout << endl;
    test_student_info("students1000.txt");
    cout << endl;
    test_student_info("students10000.txt");
}

string::size_type width(const Vec<string>& v)
{
  string::size_type maxlen = 0;

  for (Vec<string>::size_type i = 0; i != v.size(); ++i)
  {
    maxlen = max(maxlen, v[i].size());
  }

  return maxlen;
}

Vec<string> frame(const Vec<string>& v)
{
  Vec<string> ret;
  string::size_type maxlen = width(v);
  string border(maxlen + 4, '*');

  ret.push_back(border);

  for (Vec<string>::size_type i = 0; i != v.size(); ++i)
  {
    ret.push_back("* " + v[i] + string(maxlen - v[i].size(), ' ') + " *");
  }

  ret.push_back(border);

  return ret;
}

Vec<string> vcat(const Vec<string>& top, const Vec<string>& bottom)
{
  Vec<string> ret = top;

  for (Vec<string>::const_iterator it = bottom.begin(); it != bottom.end(); ++it)
  {
    ret.push_back(*it);
  }

  return ret;
}

Vec<string> hcat(const Vec<string>& left, const Vec<string>& right)
{
  Vec<string> ret;

  string::size_type width1 = width(left) + 1;

  Vec<string>::size_type i = 0, j = 0;

  while (i != left.size() || j != right.size())
  {
    string s;

    if (i != left.size())
    {
      s = left[i++];
    }

    s += string(width1 - s.size(), ' ');

    if (j != right.size())
    {
      s += right[j++];
    }

    ret.push_back(s);
  }

  return ret;
}

int test_frame()
{
  Vec<string> v1;
  v1.push_back("one test");
  v1.push_back("two test");
  v1.push_back("aye caramba");

  Vec<string> v2;
  v2.push_back("one direction");
  v2.push_back("mama mia");
  v2.push_back("mamo testo");
  v2.push_back("lake district mall");

  Vec<string> vert = vcat(frame(v1), frame(v2));

  Vec<string>::const_iterator iter = vert.begin();

  while (iter != vert.end())
  {
    cout << *iter++ << endl;
  }

  Vec<string> horz = hcat(frame(v1), frame(v2));

  iter = horz.begin();

  while (iter != horz.end())
  {
    cout << *iter++ << endl;
  }

  return 0;
}

int test_grow(int appends)
{
  Vec<int> v1;
  Vec<int> v2;

  steady_clock::time_point begin = std::chrono::steady_clock::now();
  for (int i = 0; i < appends; i++)
  {
    v1.push_back(i);
  }
  steady_clock::time_point end = std::chrono::steady_clock::now();
  cout << "Microseconds to add " << appends << " to vector using double memory method = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;


  begin = std::chrono::steady_clock::now();
  for (int i = 0; i < appends; i++)
  {
    v2.push_back(i, false);
  }
  end = std::chrono::steady_clock::now();
  cout << "Microseconds to add " << appends << " to vector without using double memory method = " << std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() << endl;

  return 0;
}

int main()
{
    test_read_and_grade();
    test_student_info();
    cout << endl;
    test_frame();
    cout << endl;
    test_grow(1000);

    return 0;
}
显示结果如下

Geert  67
Geert  67
Jan    30
Jan    30
Joris  76
Joris  76
Lotte  66
Lotte  66
Pieter 44
Pieter 44
Geert is valid = 1
Geert is valid = 1
Jan is valid = 1
Jan is valid = 1
Joris is valid = 1
Joris is valid = 1
Lotte is valid = 1
Lotte is valid = 1
Pieter is valid = 1
Pieter is valid = 1
Microseconds to read students10.txt into vector = 39
0       default constructor calls
10      stream constructor calls
25      copy constructor calls
0       assignment calls
25      destructor calls
Microseconds to extract failed from students10.txt student vector = 16
0       default constructor calls
0       stream constructor calls
13      copy constructor calls
14      assignment calls
13      destructor calls

Microseconds to read students100.txt into vector = 537
0       default constructor calls
100     stream constructor calls
227     copy constructor calls
0       assignment calls
227     destructor calls
Microseconds to extract failed from students100.txt student vector = 151
0       default constructor calls
0       stream constructor calls
139     copy constructor calls
140     assignment calls
139     destructor calls

Microseconds to read students1000.txt into vector = 2747
0       default constructor calls
1000    stream constructor calls
2023    copy constructor calls
0       assignment calls
2023    destructor calls
Microseconds to extract failed from students1000.txt student vector = 1101
0       default constructor calls
0       stream constructor calls
1399    copy constructor calls
1400    assignment calls
1399    destructor calls

Microseconds to read students10000.txt into vector = 29080
0       default constructor calls
10000   stream constructor calls
26383   copy constructor calls
0       assignment calls
26383   destructor calls
Microseconds to extract failed from students10000.txt student vector = 13457
0       default constructor calls
0       stream constructor calls
13999   copy constructor calls
14000   assignment calls
13999   destructor calls

***************
* one test    *
* two test    *
* aye caramba *
***************
**********************
* one direction      *
* mama mia           *
* mamo testo         *
* lake district mall *
**********************
*************** **********************
* one test    * * one direction      *
* two test    * * mama mia           *
* aye caramba * * mamo testo         *
*************** * lake district mall *
                **********************

Microseconds to add 1000 to vector using double memory method = 160
Microseconds to add 1000 to vector without using double memory method = 1843

第12章 使类对象像一个数值一样工作
12.1 一个简单的string类
12.2 自动转换
12.3 Str操作
12.4 有些转换是危险的
12.5 类型转换操作函数
12.6 类型转换与内存管理
12.7 小结
习题
12-0 编译、运行并测试本章举的例程。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() { }
    Str(size_type n, char c) : data(n, c) { }
    Str(const char *cp)
    {
        copy(cp, cp + strlen(cp), back_inserter(data));
    }

    template<typename In>
    Str(In b, In e) : data(b, e) { }

    size_type size() const
    {
        return data.size();
    }

    char &operator[](size_type i)
    {
        return data[i];
    }
    const char &operator[](size_type i) const
    {
        return data[i];
    }

    Str &operator+=(const Str &s)
    {
        copy(s.data.begin(), s.data.end(), back_inserter(data));
        return *this;
    }

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        data.insert(position, first, last);
    };

    iterator begin()
    {
        return data.begin();
    };
    const_iterator begin() const
    {
        return data.begin();
    };
    iterator end()
    {
        return data.end();
    };
    const_iterator end() const
    {
        return data.end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data.clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data.push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }
    friend ostream &operator<<(ostream &os, const Str &s)
    {
        for (size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }
    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Vec<char> data;
};

int main()
{
    Str s("hello1");
    cout << s << endl;
    Str t = "hello2";
    cout << t << endl;
    s = "hello3";
    cout << s << endl;
    Str s1 = "test";
    Str s2 = "ing";
    cout << s1 << endl;
    cout << s2 << endl;

    cout << "Enter a string: ";
    cin >> s;
    cout << s << endl;
    cout << s[3] << endl;
    cout << s1 + s2 << endl;

    Str name = "Geert";
    Str greeting = "Hello, " + name + "!";
    cout << name << endl;
    cout << greeting << endl;

    Str temp1("Hello, ");
    Str temp2 = temp1 + name;
    Str temp3("!");
    greeting = temp2 + temp3;
    cout << temp1 << endl;
    cout << temp2 << endl;
    cout << temp3 << endl;
    cout << greeting << endl;

    return 0;
}
显示结果如下
hello1
hello2
hello3
test
ing
Enter a string: Peter
Peter
e
testing
Geert
Hello, Geert!
Hello,
Hello, Geert
!
Hello, Geert!

12-1重写Str类，要求新的Str类可以自己管理内存。例如可以保存一个字符数组和一个长度。
在编程的时候要注意这一改变导致的对复制控制的要求。还要考虑到在使用Vec时候的资源消耗情况（例如在内存资源上的花费）。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() { }
    Str(size_type n, char c) : data(n, c) { }
    Str(const char *cp)
    {
        copy(cp, cp + strlen(cp), back_inserter(data));
    }

    template<typename In>
    Str(In b, In e) : data(b, e) { }

    size_type size() const
    {
        return data.size();
    }

    char &operator[](size_type i)
    {
        return data[i];
    }
    const char &operator[](size_type i) const
    {
        return data[i];
    }

    Str &operator+=(const Str &s)
    {
        copy(s.data.begin(), s.data.end(), back_inserter(data));
        return *this;
    }

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        data.insert(position, first, last);
    };

    iterator begin()
    {
        return data.begin();
    };
    const_iterator begin() const
    {
        return data.begin();
    };
    iterator end()
    {
        return data.end();
    };
    const_iterator end() const
    {
        return data.end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data.clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data.push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }
    friend ostream &operator<<(ostream &os, const Str &s)
    {
        for (size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }
    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Vec<char> data;
};

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

int main()
{
    Str_c s("hello1");
    cout << s << endl;
    Str_c t = "hello2";
    cout << t << endl;
    s = "hello3";
    cout << s << endl;
    Str_c s1 = "test";
    Str_c s2 = "ing";
    cout << s1 << endl;
    cout << s2 << endl;

    cout << "Enter a string: ";
    cin >> s;
    cout << s << endl;
    cout << s[3] << endl;
    cout << s1 + s2 << endl;

    Str_c name = "Geert";
    Str_c greeting = "Hello, " + name + "!";
    cout << name << endl;
    cout << greeting << endl;

    Str_c temp1("Hello, ");
    Str_c temp2 = temp1 + name;
    Str_c temp3("!");
    greeting = temp2 + temp3;
    cout << temp1 << endl;
    cout << temp2 << endl;
    cout << temp3 << endl;
    cout << greeting << endl;

    return 0;
}
显示结果如下
hello1
hello2
hello3
test
ing
Enter a string: Peter
Peter
e
testing
Geert
Hello, Geert!
Hello,
Hello, Geert
!
Hello, Geert!

12-2 实现c_str，data和copy函数。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() { }
    Str(size_type n, char c) : data(n, c) { }
    Str(const char *cp)
    {
        copy(cp, cp + strlen(cp), back_inserter(data));
    }

    template<typename In>
    Str(In b, In e) : data(b, e) { }

    size_type size() const
    {
        return data.size();
    }

    char &operator[](size_type i)
    {
        return data[i];
    }
    const char &operator[](size_type i) const
    {
        return data[i];
    }

    Str &operator+=(const Str &s)
    {
        copy(s.data.begin(), s.data.end(), back_inserter(data));
        return *this;
    }

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        data.insert(position, first, last);
    };

    iterator begin()
    {
        return data.begin();
    };
    const_iterator begin() const
    {
        return data.begin();
    };
    iterator end()
    {
        return data.end();
    };
    const_iterator end() const
    {
        return data.end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data.clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data.push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }
    friend ostream &operator<<(ostream &os, const Str &s)
    {
        for (size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }
    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Vec<char> data;
};

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

int main()
{
    Str_c str = "Aviation industry";
    const char *data = str.data();

    for (size_t i = 0; i < str.size(); i++)
    {
        cout << data[i];
    }
    cout << endl;

    const char *c = str.c_str();

    cout << c << endl;

    char copied[8];
    str.copy(copied, sizeof(copied));

    for (size_t i = 0; i < sizeof(copied); i++)
    {
        cout << copied[i];
    }
    cout << endl;

    return 0;
}
显示结果如下
Aviation industry
Aviation industry
Aviation

12-3为Str类定义一个相关运算符函数。提示：在<cstring>头文件中定义了一个名为strcmp的函数，该函数对两个字符指针进行比较。
如果第一个指针指向以空字符结尾的字符数组比第二个指针指向的数组小，函数返回一个负整数，如果两个数组一样大，函数返回零，
如果第一个数组比第二个数组大，则返回个正整数。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() { }
    Str(size_type n, char c) : data(n, c) { }
    Str(const char *cp)
    {
        copy(cp, cp + strlen(cp), back_inserter(data));
    }

    template<typename In>
    Str(In b, In e) : data(b, e) { }

    size_type size() const
    {
        return data.size();
    }

    char &operator[](size_type i)
    {
        return data[i];
    }
    const char &operator[](size_type i) const
    {
        return data[i];
    }

    Str &operator+=(const Str &s)
    {
        copy(s.data.begin(), s.data.end(), back_inserter(data));
        return *this;
    }

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        data.insert(position, first, last);
    };

    iterator begin()
    {
        return data.begin();
    };
    const_iterator begin() const
    {
        return data.begin();
    };
    iterator end()
    {
        return data.end();
    };
    const_iterator end() const
    {
        return data.end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data.clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data.push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }
    friend ostream &operator<<(ostream &os, const Str &s)
    {
        for (size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }
    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Vec<char> data;
};

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

int main()
{
    Str_c short_str = "audio";
    Str_c default_str1 = "Aviation";
    Str_c default_str2 = "aviation";
    Str_c long_str = "aviation industry";

    cout << short_str << " is smaller than " << default_str2 << " ? " << (short_str < default_str2) << endl;
    cout << long_str << " is smaller or equal to " << default_str2 << " ? " << (long_str <= default_str2) << endl;
    cout << short_str << " is bigger than " << long_str << " ? " << (short_str > long_str) << endl;
    cout << long_str << " is bigger or equal to " << long_str << " ? " << (long_str >= long_str) << endl;

    return 0;
}
显示结果如下
audio is smaller than aviation ? 1
aviation industry is smaller or equal to aviation ? 0
audio is bigger than aviation industry ? 0
aviation industry is bigger or equal to aviation industry ? 1

12-4 为Str类写一个等号运算符函数和一个不等号运算符函数。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() { }
    Str(size_type n, char c) : data(n, c) { }
    Str(const char *cp)
    {
        copy(cp, cp + strlen(cp), back_inserter(data));
    }

    template<typename In>
    Str(In b, In e) : data(b, e) { }

    size_type size() const
    {
        return data.size();
    }

    char &operator[](size_type i)
    {
        return data[i];
    }
    const char &operator[](size_type i) const
    {
        return data[i];
    }

    Str &operator+=(const Str &s)
    {
        copy(s.data.begin(), s.data.end(), back_inserter(data));
        return *this;
    }

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        data.insert(position, first, last);
    };

    iterator begin()
    {
        return data.begin();
    };
    const_iterator begin() const
    {
        return data.begin();
    };
    iterator end()
    {
        return data.end();
    };
    const_iterator end() const
    {
        return data.end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data.clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data.push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }
    friend ostream &operator<<(ostream &os, const Str &s)
    {
        for (size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }
    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Vec<char> data;
};

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

int main()
{
    Str_c str1 = "Aviation";
    Str_c str2 = "aviation";
    Str_c str3 = "Aviation";

    cout << str1 << " is equal to " << str2 << " ? " << (str1 == str2) << endl;
    cout << str2 << " is not equal to " << str3 << " ? " << (str2 != str3) << endl;
    cout << str1 << " is equal to " << str3 << " ? " << (str1 == str3) << endl;

    return 0;
}
显示结果如下
Aviation is equal to aviation ? 0
aviation is not equal to Aviation ? 1
Aviation is equal to Aviation ? 1

12-5 写一个用于Str类型对象与字符串常量串连的函数，使得操作不再依赖于从const char*类型到Str类型的转换函数。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() { }
    Str(size_type n, char c) : data(n, c) { }
    Str(const char *cp)
    {
        copy(cp, cp + strlen(cp), back_inserter(data));
    }

    template<typename In>
    Str(In b, In e) : data(b, e) { }

    size_type size() const
    {
        return data.size();
    }

    char &operator[](size_type i)
    {
        return data[i];
    }
    const char &operator[](size_type i) const
    {
        return data[i];
    }

    Str &operator+=(const Str &s)
    {
        copy(s.data.begin(), s.data.end(), back_inserter(data));
        return *this;
    }

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        data.insert(position, first, last);
    };

    iterator begin()
    {
        return data.begin();
    };
    const_iterator begin() const
    {
        return data.begin();
    };
    iterator end()
    {
        return data.end();
    };
    const_iterator end() const
    {
        return data.end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data.clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data.push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }
    friend ostream &operator<<(ostream &os, const Str &s)
    {
        for (size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }
    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Vec<char> data;
};

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

int main()
{
    Str_c name = "Geert";
    Str_c greeting = "Hello, " + name;

    cout << greeting << endl;

    Str_c goodbye = name + ", bye!";
    cout << goodbye << endl;

    Str_c complete = "Hello, " + name + " and goodbye!";
    cout << complete << endl;

    return 0;
}
显示结果如下
Hello, Geert
Geert, bye!
Hello, Geert and goodbye!

12-6 为Str写一个操作函数，以使用户可以隐式地使用一个Str对象做为条件表达式。
要求在Str为空的时候表达式值为假（FALSE），否则表达式值为真（TRUE）。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() { }
    Str(size_type n, char c) : data(n, c) { }
    Str(const char *cp)
    {
        copy(cp, cp + strlen(cp), back_inserter(data));
    }

    template<typename In>
    Str(In b, In e) : data(b, e) { }

    size_type size() const
    {
        return data.size();
    }

    char &operator[](size_type i)
    {
        return data[i];
    }
    const char &operator[](size_type i) const
    {
        return data[i];
    }

    Str &operator+=(const Str &s)
    {
        copy(s.data.begin(), s.data.end(), back_inserter(data));
        return *this;
    }

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        data.insert(position, first, last);
    };

    iterator begin()
    {
        return data.begin();
    };
    const_iterator begin() const
    {
        return data.begin();
    };
    iterator end()
    {
        return data.end();
    };
    const_iterator end() const
    {
        return data.end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data.clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data.push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }
    friend ostream &operator<<(ostream &os, const Str &s)
    {
        for (size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }
    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Vec<char> data;
};

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

int main()
{
    Str_c name = "Geert";

    if (name)
    {
        cout << "Hello " << name << "!" << endl;
    }

    Str_c nickname;

    if (nickname)
    {
        cout << "Hello " << nickname << "!" << endl;
    }

    return 0;
}
显示结果如下
Hello Geert!

12-7 标准的string类提供一个随机访问迭代器来对字符串的字符进行操作。为Str类添加迭代器与迭代器操作begin与end函数。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() { }
    Str(size_type n, char c) : data(n, c) { }
    Str(const char *cp)
    {
        copy(cp, cp + strlen(cp), back_inserter(data));
    }

    template<typename In>
    Str(In b, In e) : data(b, e) { }

    size_type size() const
    {
        return data.size();
    }

    char &operator[](size_type i)
    {
        return data[i];
    }
    const char &operator[](size_type i) const
    {
        return data[i];
    }

    Str &operator+=(const Str &s)
    {
        copy(s.data.begin(), s.data.end(), back_inserter(data));
        return *this;
    }

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        data.insert(position, first, last);
    };

    iterator begin()
    {
        return data.begin();
    };
    const_iterator begin() const
    {
        return data.begin();
    };
    iterator end()
    {
        return data.end();
    };
    const_iterator end() const
    {
        return data.end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data.clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data.push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }
    friend ostream &operator<<(ostream &os, const Str &s)
    {
        for (size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }
    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Vec<char> data;
};

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

int main()
{
    Str_c greeting = "Hello buddy!";
    Str_c::const_iterator iter = greeting.begin();

    while (iter != greeting.end())
    {
        cout << *iter++;
    }
    cout << endl;

    return 0;
}
显示结果如下
Hello buddy!

12-8 为Str类添加getline函数。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() { }
    Str(size_type n, char c) : data(n, c) { }
    Str(const char *cp)
    {
        copy(cp, cp + strlen(cp), back_inserter(data));
    }

    template<typename In>
    Str(In b, In e) : data(b, e) { }

    size_type size() const
    {
        return data.size();
    }

    char &operator[](size_type i)
    {
        return data[i];
    }
    const char &operator[](size_type i) const
    {
        return data[i];
    }

    Str &operator+=(const Str &s)
    {
        copy(s.data.begin(), s.data.end(), back_inserter(data));
        return *this;
    }

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        data.insert(position, first, last);
    };

    iterator begin()
    {
        return data.begin();
    };
    const_iterator begin() const
    {
        return data.begin();
    };
    iterator end()
    {
        return data.end();
    };
    const_iterator end() const
    {
        return data.end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data.clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data.push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }
    friend ostream &operator<<(ostream &os, const Str &s)
    {
        for (size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }
    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Vec<char> data;
};

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

int main()
{
    Str_c input;

    while (getline(std::cin, input))
    {
        cout << input << endl;
    }

    return 0;
}
显示结果如下
Peter Smith Mike Pence Hello World
Peter Smith Mike Pence Hello World

12-9 使用ostream_iterator类来重写Str类的输出运算符函数。想想为什么不用istream_iterator类来重写该函数？
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() { }
    Str(size_type n, char c) : data(n, c) { }
    Str(const char *cp)
    {
        copy(cp, cp + strlen(cp), back_inserter(data));
    }

    template<typename In>
    Str(In b, In e) : data(b, e) { }

    size_type size() const
    {
        return data.size();
    }

    char &operator[](size_type i)
    {
        return data[i];
    }
    const char &operator[](size_type i) const
    {
        return data[i];
    }

    Str &operator+=(const Str &s)
    {
        copy(s.data.begin(), s.data.end(), back_inserter(data));
        return *this;
    }

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        data.insert(position, first, last);
    };

    iterator begin()
    {
        return data.begin();
    };
    const_iterator begin() const
    {
        return data.begin();
    };
    iterator end()
    {
        return data.end();
    };
    const_iterator end() const
    {
        return data.end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data.clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data.push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }
    friend ostream &operator<<(ostream &os, const Str &s)
    {
        for (size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }
    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Vec<char> data;
};

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

int main()
{
    Str_c s = "Fantastic news!";
    cout << s << endl;

    return 0;
}
显示结果如下
Fantastic news!

12-10 在12.1中我们学习了如何在Str中定义一个带有两个迭代器参数的构造函数，这种构造函数在Vec类中也很有用。
试一试往Vec类中加入这种构造函数，然后不要调用copy函数，而是调用Vec的构造函数来重写Str类。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() { }
    Str(size_type n, char c) : data(n, c) { }
    Str(const char *cp)
    {
        copy(cp, cp + strlen(cp), back_inserter(data));
    }

    template<typename In>
    Str(In b, In e) : data(b, e) { }

    size_type size() const
    {
        return data.size();
    }

    char &operator[](size_type i)
    {
        return data[i];
    }
    const char &operator[](size_type i) const
    {
        return data[i];
    }

    Str &operator+=(const Str &s)
    {
        copy(s.data.begin(), s.data.end(), back_inserter(data));
        return *this;
    }

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        data.insert(position, first, last);
    };

    iterator begin()
    {
        return data.begin();
    };
    const_iterator begin() const
    {
        return data.begin();
    };
    iterator end()
    {
        return data.end();
    };
    const_iterator end() const
    {
        return data.end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data.clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data.push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }
    friend ostream &operator<<(ostream &os, const Str &s)
    {
        for (size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }
    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Vec<char> data;
};

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

int main()
{
    string greeting = "Hello buddy, how are you doing?";

    Str str(greeting.begin(), greeting.end());
    cout << str << endl;

    return 0;
}
显示结果如下
Hello buddy, how are you doing?

12-11 如果你往Str类中添加了本练习中提出的操作函数，你就可以在本书中的所有例程用这个Str类。
用新的Str类重写第5章的字符图形操作函数，5.6和6.1.1的split函数。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() { }
    Str(size_type n, char c) : data(n, c) { }
    Str(const char *cp)
    {
        copy(cp, cp + strlen(cp), back_inserter(data));
    }

    template<typename In>
    Str(In b, In e) : data(b, e) { }

    size_type size() const
    {
        return data.size();
    }

    char &operator[](size_type i)
    {
        return data[i];
    }
    const char &operator[](size_type i) const
    {
        return data[i];
    }

    Str &operator+=(const Str &s)
    {
        copy(s.data.begin(), s.data.end(), back_inserter(data));
        return *this;
    }

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        data.insert(position, first, last);
    };

    iterator begin()
    {
        return data.begin();
    };
    const_iterator begin() const
    {
        return data.begin();
    };
    iterator end()
    {
        return data.end();
    };
    const_iterator end() const
    {
        return data.end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data.clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data.push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }
    friend ostream &operator<<(ostream &os, const Str &s)
    {
        for (size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }
    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Vec<char> data;
};

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

Str_c::size_type width(const vector<Str_c> &v)
{
    Str_c::size_type maxlen = 0;

    for (vector<Str_c>::size_type i = 0; i != v.size(); ++i)
    {
        maxlen = max(maxlen, v[i].size());
    }

    return maxlen;
}

vector<Str_c> frame(const vector<Str_c> &v)
{
    vector<Str_c> ret;
    Str_c::size_type maxlen = width(v);
    Str_c border(maxlen + 4, '*');

    ret.push_back(border);

    for (vector<Str_c>::size_type i = 0; i != v.size(); ++i)
    {
        ret.push_back("* " + v[i] + Str_c(maxlen - v[i].size(), ' ') + " *");
    }

    ret.push_back(border);

    return ret;
}

vector<Str_c> vcat(const vector<Str_c> &top, const vector<Str_c> &bottom)
{
    vector<Str_c> ret = top;

    ret.insert(ret.end(), bottom.begin(), bottom.end());

    return ret;
}

vector<Str_c> hcat(const vector<Str_c> &left, const vector<Str_c> &right)
{
    vector<Str_c> ret;

    Str_c::size_type width1 = width(left) + 1;

    vector<Str_c>::size_type i = 0, j = 0;

    while (i != left.size() || j != right.size())
    {
        Str_c s;

        if (i != left.size())
        {
            s = left[i++];
        }

        s += Str_c(width1 - s.size(), ' ');

        if (j != right.size())
        {
            s += right[j++];
        }

        ret.push_back(s);
    }

    return ret;
}

vector<Str_c> center(const vector<Str_c> &v)
{
    vector<Str_c> v_out;
    vector<Str_c>::size_type maxlen = width(v);
    vector<Str_c>::const_iterator iter = v.begin();

    while (iter != v.end())
    {
        int spaces_l = (maxlen - iter->size()) / 2;
        int spaces_r = maxlen - iter->size() - spaces_l;
        v_out.push_back(Str_c(spaces_l, ' ') + *iter++ + Str_c(spaces_r, ' '));
    }

    return v_out;
}

vector<Str_c> split(const Str_c &s)
{
    vector<Str_c> ret;
    typedef Str_c::size_type Str_c_size;
    Str_c_size i = 0;

    while (i != s.size())
    {
        while (i != s.size() && isspace(s[i]))
        {
            ++i;
        }

        Str_c_size j = i;

        while (j != s.size() && !isspace(s[j]))
        {
            ++j;
        }

        if (i != j)
        {
            ret.push_back(Str_c(s.begin() + i, s.begin() + j));
            i = j;
        }
    }
    return ret;
}

bool space(char c)
{
    return isspace(c) != 0;
}

bool not_space(char c)
{
    return !isspace(c);
}

vector<Str_c> split_alt(const Str_c &str)
{
    typedef Str_c::const_iterator iter;
    vector<Str_c> ret;

    iter i = str.begin();
    while (i != str.end())
    {
        i = find_if(i, str.end(), not_space);

        iter j = find_if(i, str.end(), space);

        if (i != j)
        {
            ret.push_back(Str_c(i, j));
            i = j;
        }
    }
    return ret;
}

int test_frame()
{
    vector<Str_c> v1 = { "one test", "two test", "aye caramba" };
    vector<Str_c> v2 = { "one direction", "mama mia", "mamo testo", "lake district mall" };

    vector<Str_c> vert = vcat(frame(v1), frame(v2));

    vector<Str_c>::const_iterator iter = vert.begin();

    while (iter != vert.end())
    {
        cout << *iter++ << endl;
    }

    vector<Str_c> horz = hcat(frame(v1), frame(v2));

    iter = horz.begin();

    while (iter != horz.end())
    {
        cout << *iter++ << endl;
    }

    return 0;
}

int test_center()
{
    vector<Str_c> v = { "This is really great", "really", "super awesome", "awesomesauce" };
    vector<Str_c> centered_v = center(v);

    vector<Str_c>::const_iterator iter = centered_v.begin();

    while (iter != centered_v.end())
    {
        cout << *iter++ << endl;
    }

    return 0;
}

int test_string_split()
{
    Str_c s = "Split this string!";

    vector<Str_c> v = split(s);

    for (vector<Str_c>::size_type i = 0; i != v.size(); ++i)
    {
        cout << v[i] << endl;
    }

    return 0;
}

int test_string_split_alt()
{
    Str_c s = "And this one too!";

    vector<Str_c> v = split_alt(s);

    for (vector<Str_c>::size_type i = 0; i != v.size(); ++i)
    {
        cout << v[i] << endl;
    }

    return 0;
}

int main()
{
    test_frame();
    cout << endl;
    test_center();
    cout << endl;
    test_string_split();
    cout << endl;
    test_string_split_alt();
    cout << endl;

    return 0;
}
显示结果如下
***************
* one test    *
* two test    *
* aye caramba *
***************
**********************
* one direction      *
* mama mia           *
* mamo testo         *
* lake district mall *
**********************
*************** **********************
* one test    * * one direction      *
* two test    * * mama mia           *
* aye caramba * * mamo testo         *
*************** * lake district mall *
                **********************

This is really great
       really
   super awesome
    awesomesauce

Split
this
string!

And
this
one
too!

12-12 为Vec类与Str类分别定义带两个迭代器参数的insert函数。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() { }
    Str(size_type n, char c) : data(n, c) { }
    Str(const char *cp)
    {
        copy(cp, cp + strlen(cp), back_inserter(data));
    }

    template<typename In>
    Str(In b, In e) : data(b, e) { }

    size_type size() const
    {
        return data.size();
    }

    char &operator[](size_type i)
    {
        return data[i];
    }
    const char &operator[](size_type i) const
    {
        return data[i];
    }

    Str &operator+=(const Str &s)
    {
        copy(s.data.begin(), s.data.end(), back_inserter(data));
        return *this;
    }

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        data.insert(position, first, last);
    };

    iterator begin()
    {
        return data.begin();
    };
    const_iterator begin() const
    {
        return data.begin();
    };
    iterator end()
    {
        return data.end();
    };
    const_iterator end() const
    {
        return data.end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data.clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data.push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }
    friend ostream &operator<<(ostream &os, const Str &s)
    {
        for (size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }
    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Vec<char> data;
};

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

int main()
{
    Str greeting = "Hello , how are you?";
    Str name = "Geert";

    greeting.insert(greeting.begin() + 6, name.begin(), name.end());

    cout << greeting << endl;

    return 0;
}
显示结果如下
Hello Geert, how are you?

12-13 提供一个assign函数，用来把一个数组的值赋给一个Vec类型对象。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() { }
    Str(size_type n, char c) : data(n, c) { }
    Str(const char *cp)
    {
        copy(cp, cp + strlen(cp), back_inserter(data));
    }

    template<typename In>
    Str(In b, In e) : data(b, e) { }

    size_type size() const
    {
        return data.size();
    }

    char &operator[](size_type i)
    {
        return data[i];
    }
    const char &operator[](size_type i) const
    {
        return data[i];
    }

    Str &operator+=(const Str &s)
    {
        copy(s.data.begin(), s.data.end(), back_inserter(data));
        return *this;
    }

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        data.insert(position, first, last);
    };

    iterator begin()
    {
        return data.begin();
    };
    const_iterator begin() const
    {
        return data.begin();
    };
    iterator end()
    {
        return data.end();
    };
    const_iterator end() const
    {
        return data.end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data.clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data.push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }
    friend ostream &operator<<(ostream &os, const Str &s)
    {
        for (size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }
    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Vec<char> data;
};

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

int main()
{
    Vec<char> v;

    char data[] = { 'h', 'e', 'l', 'l', 'o' };
    v.assign(data, data + sizeof(data));

    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i];
    }
    cout << endl;

    return 0;
}
显示结果如下
hello

12-14 写一个程序用一个string变量初始化一个Vec类型对象。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() { }
    Str(size_type n, char c) : data(n, c) { }
    Str(const char *cp)
    {
        copy(cp, cp + strlen(cp), back_inserter(data));
    }

    template<typename In>
    Str(In b, In e) : data(b, e) { }

    size_type size() const
    {
        return data.size();
    }

    char &operator[](size_type i)
    {
        return data[i];
    }
    const char &operator[](size_type i) const
    {
        return data[i];
    }

    Str &operator+=(const Str &s)
    {
        copy(s.data.begin(), s.data.end(), back_inserter(data));
        return *this;
    }

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        data.insert(position, first, last);
    };

    iterator begin()
    {
        return data.begin();
    };
    const_iterator begin() const
    {
        return data.begin();
    };
    iterator end()
    {
        return data.end();
    };
    const_iterator end() const
    {
        return data.end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data.clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data.push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }
    friend ostream &operator<<(ostream &os, const Str &s)
    {
        for (size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }
    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Vec<char> data;
};

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

int main()
{
    string s = "A lonesome string.";

    Vec<char> v(s.begin(), s.end());

    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i];
    }
    cout << endl;

    return 0;
}
显示结果如下
A lonesome string.

12-15 4.1.3中的read_hw函数从一个流中读取并检验每个字符，以判断函数是否遇到流的结尾，或者遇到一个无效的输入。
我们的Str类中没有相应的操作，为什么？Str类可能会使输入流处于无效状态吗？
is >> x碰到无效的输入，会使输入流处于无效状态
is.get(c)可以处理各种输入的字符，没有无效的输入
当遇到流的结尾时，都会结束输入

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
    }

    return is;
}

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data.clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data.push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }

第13章 使用继承与动态绑定
13.1 一个简单的string类
13.2 多态和虚拟函数
13.3 用继承来解决我们的问题
13.4 一个简单的句柄类
13.5 使用句柄类
13.6 微妙之处
13.7 小结
习题
13-0编译、运行并测试本章的例程。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

class Core
{
public:
    friend class Student_info;
    friend class Audit;
    Core() : midterm(0), final(0) {}
    Core(istream &is)
    {
        read(is);
    }

    virtual ~Core() { }

    const string &name() const
    {
        return _name;
    }
    virtual double grade() const
    {
        return ::grade(midterm, final, homework);
    }
    string letter_grade() const;
    virtual istream &read(istream &);

    bool valid() const
    {
        return !homework.empty();
    }
    virtual bool requirements_met() const
    {
        return find(homework.begin(), homework.end(), 0.0) == homework.end();
    }

protected:
    virtual Core *clone() const
    {
        return new Core(*this);
    }
    istream &read_common(istream &in)
    {
        in >> _name >> midterm >> final;
        return in;
    }
    double midterm, final;
    vector<double> homework;

private:
    string _name;
};

istream &Core::read(istream &in)
{
    read_common(in);
    read_hw(in, homework);
    return in;
}

string Core::letter_grade() const
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };

    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };

    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);

    double result = grade();

    for (size_t i = 0; i < ngrades; ++i)
    {
        if (result >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

inline bool compare(const Core &c1, const Core &c2)
{
    return c1.name() < c2.name();
}

inline bool compare_Core_ptrs(const Core *cp1, const Core *cp2)
{
    return compare(*cp1, *cp2);
}

class Grad : public Core
{
public:
    Grad() : thesis(0.0) {}
    Grad(istream &is)
    {
        read(is);
    }

    double grade() const;
    istream &read(istream &);

    bool requirements_met() const
    {
        return Core::requirements_met() && thesis != 0.0;
    }

protected:
    Grad *clone() const
    {
        return new Grad(*this);
    }

private:
    double thesis;
};

istream &Grad::read(istream &in)
{
    Core::read_common(in);
    in >> Grad::thesis;
    read_hw(in, Core::homework);
    return in;
}

double Grad::grade() const
{
    return min(Core::grade(), Grad::thesis);
}

class Credit : public Core
{
public:
    Credit() {}
    Credit(istream &is) : Core(is) {}

    double grade() const;
    bool passed() const
    {
        return grade() >= 60;
    }

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }

protected:
    Credit *clone() const
    {
        return new Credit(*this);
    }
};

double Credit::grade() const
{
    if (Core::homework.empty())
    {
        return (midterm + final) / 2.0;
    }
    else
    {
        return Core::grade();
    }
}

class Audit : public Core
{
public:
    Audit() {}
    Audit(istream &is)
    {
        read(is);
    }

    istream &read(istream &in)
    {
        in >> _name;
        return in;
    }

    double grade() const
    {
        return 0.0;
    };

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }

protected:
    Audit *clone() const
    {
        return new Audit(*this);
    }
};

class Student_info
{
public:
    Student_info() : cp(nullptr) { }
    Student_info(istream &is) : cp(nullptr)
    {
        read(is);
    }
    Student_info(const Student_info &);
    Student_info &operator=(const Student_info &);
    ~Student_info()
    {
        delete cp;
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp != nullptr)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp != nullptr)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Core *cp;
};


istream &Student_info::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        delete cp;
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

Student_info::Student_info(const Student_info &s) : cp(nullptr)
{
    if (s.cp != nullptr)
    {
        cp = s.cp->clone();
    }
}

Student_info &Student_info::operator=(const Student_info &s)
{
    if (this == &s)
    {
        return *this;
    }
    delete cp;
    if (s.cp != nullptr)
    {
        cp = s.cp->clone();
    }
    else
    {
        cp = nullptr;
    }
    return *this;
}

inline bool compare_info(const Student_info &s1, const Student_info &s2)
{
    return s1.name() < s2.name();
}

int test_method_1()
{
    vector<Core *> students;
    Core *record;
    char ch;
    string::size_type maxlen = 0;
    cout << "Enter U for new Core, G for new Grad" << endl;
    while (cin >> ch && ch != 'Q')
    {
        if (ch == 'U')
        {
            record = new Core;
            cout << "new Core" << endl;
        }
        else
        {
            record = new Grad;
            cout << "new Grad" << endl;
        }
        record->read(cin);
        maxlen = max(maxlen, record->name().size());
        students.push_back(record);
        cout << "Enter U for new Core, G for new Grad" << endl;
    }
    sort(students.begin(), students.end(), compare_Core_ptrs);
    for (vector<Core *>::size_type i = 0; i != students.size(); ++i)
    {
        cout << students[i]->name() << string(maxlen + 1 - students[i]->name().size(), ' ');
        try
        {
            double final_grade = students[i]->grade();
            streamsize prec = cout.precision();
            cout << setprecision(3) << final_grade << setprecision(prec) << endl;
        }
        catch (domain_error e)
        {
            cout << e.what() << endl;
        }
        delete students[i];
    }
    return 0;
}

int test_method_2()
{
    vector<Student_info> students;
    Student_info record;
    Student_info temp;
    string::size_type maxlen = 0;
    while (record.read(cin))
    {
        maxlen = max(maxlen, record.name().size());
        students.push_back(record);
    }
    record = temp;
    sort(students.begin(), students.end(), compare_info);
    for (vector<Student_info>::size_type i = 0; i != students.size(); ++i)
    {
        cout << students[i].name() << string(maxlen + 1 - students[i].name().size(), ' ');
        try
        {
            double final_grade = students[i].grade();
            streamsize prec = cout.precision();
            cout << setprecision(3) << final_grade << setprecision(prec) << endl;
        }
        catch (domain_error &e1)
        {
            cout << e1.what() << endl;
        }
        catch (runtime_error &e2)
        {
            cout << e2.what() << endl;
        }
    }
    return 0;
}

int main()
{
    cout << "First method" << endl;
    test_method_1();
    cout << "Second method" << endl;
    cin.clear();
    test_method_2();

    return 0;
}
显示结果如下
First method
Enter U for new Core, G for new Grad
U
new Core
Geert 50 80 90 45 30 80 end
Enter U for new Core, G for new Grad
G
new Grad
Pieter 40 50 80 30 40 50 50 40 end
Enter U for new Core, G for new Grad
G
new Grad
Lotte 40 80 62 90 45 60 70 end
Enter U for new Core, G for new Grad
U
new Core
Jan 30 20 80 40 50 30 40 end
Enter U for new Core, G for new Grad
U
new Core
Joris 80 90 60 70 60 70 60 end
Enter U for new Core, G for new Grad
Q
Geert  67
Jan    30
Joris  76
Lotte  62
Pieter 44
Second method
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
U
new Core
Geert 50 80 90 45 30 80 end
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
C
new Credit
Pieter 40 50 30 40 50 50 40 end
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
A
new Audit
Lotte
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
G
new Grad
Joris 80 90 62 60 70 60 70 60 end
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
Geert  67
Joris  62
Lotte  0
Pieter 44

13-1 在Core类与Grad类的构造函数中加入输出函数，使构造函数在执行的时候输出构造函数名与⑹列表。
例如：cerr<<"Grad：：Grad（istream&）"<<endl；你可以向带有一个istream&类型参数的Grad构造函数中加入上面这行语句。
然后写一个小程序检验每个构造函数。预测一下会有什么输出结果。不断修改程序并做出预测，直到预测与实际输出的结果相符。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

class Core
{
public:
    friend class Student_info;
    friend class Audit;
    Core() : midterm(0), final(0)
    {
        cerr << "constructor Core()" << endl;
    }
    Core(istream &is)
    {
        cerr << "constructor Core(istream &is)" << endl;
        read(is);
    }

    virtual ~Core()
    {
        cerr << "destructor ~Core()" << endl;
    }

    const string &name() const
    {
        return _name;
    }
    virtual double grade() const
    {
        return ::grade(midterm, final, homework);
    }
    string letter_grade() const;
    virtual istream &read(istream &);

    bool valid() const
    {
        return !homework.empty();
    }
    virtual bool requirements_met() const
    {
        return find(homework.begin(), homework.end(), 0.0) == homework.end();
    }

protected:
    virtual Core *clone() const
    {
        return new Core(*this);
    }
    istream &read_common(istream &in)
    {
        in >> _name >> midterm >> final;
        return in;
    }
    double midterm, final;
    vector<double> homework;

private:
    string _name;
};

istream &Core::read(istream &in)
{
    read_common(in);
    read_hw(in, homework);
    return in;
}

string Core::letter_grade() const
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };

    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };

    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);

    double result = grade();

    for (size_t i = 0; i < ngrades; ++i)
    {
        if (result >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

inline bool compare(const Core &c1, const Core &c2)
{
    return c1.name() < c2.name();
}

inline bool compare_Core_ptrs(const Core *cp1, const Core *cp2)
{
    return compare(*cp1, *cp2);
}

class Grad : public Core
{
public:
    Grad() : thesis(0.0)
    {
        cerr << "constructor Grad()" << endl;
    }
    Grad(istream &is)
    {
        cerr << "constructor Grad(istream &is)" << endl;
        read(is);
    }

    double grade() const;
    istream &read(istream &);

    bool requirements_met() const
    {
        return Core::requirements_met() && thesis != 0.0;
    }

protected:
    Grad *clone() const
    {
        return new Grad(*this);
    }

private:
    double thesis;
};

istream &Grad::read(istream &in)
{
    Core::read_common(in);
    in >> Grad::thesis;
    read_hw(in, Core::homework);
    return in;
}

double Grad::grade() const
{
    return min(Core::grade(), Grad::thesis);
}

class Credit : public Core
{
public:
    Credit() {}
    Credit(istream &is) : Core(is) {}

    double grade() const;
    bool passed() const
    {
        return grade() >= 60;
    }

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }

protected:
    Credit *clone() const
    {
        return new Credit(*this);
    }
};

double Credit::grade() const
{
    if (Core::homework.empty())
    {
        return (midterm + final) / 2.0;
    }
    else
    {
        return Core::grade();
    }
}

class Audit : public Core
{
public:
    Audit() {}
    Audit(istream &is)
    {
        read(is);
    }

    istream &read(istream &in)
    {
        in >> _name;
        return in;
    }

    double grade() const
    {
        return 0.0;
    };

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }

protected:
    Audit *clone() const
    {
        return new Audit(*this);
    }
};

class Student_info
{
public:
    Student_info() : cp(nullptr) { }
    Student_info(istream &is) : cp(nullptr)
    {
        read(is);
    }
    Student_info(const Student_info &);
    Student_info &operator=(const Student_info &);
    ~Student_info()
    {
        delete cp;
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp != nullptr)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp != nullptr)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Core *cp;
};


istream &Student_info::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        delete cp;
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

Student_info::Student_info(const Student_info &s) : cp(nullptr)
{
    if (s.cp != nullptr)
    {
        cp = s.cp->clone();
    }
}

Student_info &Student_info::operator=(const Student_info &s)
{
    if (this == &s)
    {
        return *this;
    }
    delete cp;
    if (s.cp != nullptr)
    {
        cp = s.cp->clone();
    }
    else
    {
        cp = nullptr;
    }
    return *this;
}

inline bool compare_info(const Student_info &s1, const Student_info &s2)
{
    return s1.name() < s2.name();
}

int main()
{
    Core core1;
    Grad grad1;

    cout << "Enter Core student info:" << endl;
    Core core2(cin);

    cout << "Enter Grad student info:" << endl;
    Grad grad2(cin);

    cout << core2.name() << ", " << core2.grade() << endl;
    cout << grad2.name() << ", " << grad2.grade() << endl;

    return 0;
}
显示结果如下
constructor Core()
constructor Core()
constructor Grad()
Enter Core student info:
constructor Core(istream &is)
Geert 50 80 90 45 30 80 end
Enter Grad student info:
constructor Core()
constructor Grad(istream &is)
Joris 80 90 62 60 70 60 70 60 end
Geert, 67
Joris, 62
destructor ~Core()
destructor ~Core()
destructor ~Core()
destructor ~Core()

13-2 对于在本章已经定义的Core类与Grad类，指出下面的各条语句实际上会调用哪个函数：
Core * p1 = new Core;
Core * p2 = new Grad;
core s1;
Grad s2;
p1->grade();
p1->name();
p2->grade();
p2->name();

s1.name();
s1.grade();
s2.name();
s2.grade();
在name函数与grade函数中加入输出语句输出信息表明调用了哪个函数，看看你的判断是否正确。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

class Core
{
public:
    friend class Student_info;
    friend class Audit;
    Core() : midterm(0), final(0)
    {
        cerr << "constructor Core()" << endl;
    }
    Core(istream &is)
    {
        cerr << "constructor Core(istream &is)" << endl;
        read(is);
    }

    virtual ~Core()
    {
        cerr << "destructor ~Core()" << endl;
    }

    const string &name() const
    {
        cerr << "Core::name()" << endl;
        return _name;
    }
    virtual double grade() const
    {
        cerr << "Core::grade()" << endl;
        return ::grade(midterm, final, homework);
    }
    string letter_grade() const;
    virtual istream &read(istream &);

    bool valid() const
    {
        return !homework.empty();
    }
    virtual bool requirements_met() const
    {
        return find(homework.begin(), homework.end(), 0.0) == homework.end();
    }

protected:
    virtual Core *clone() const
    {
        return new Core(*this);
    }
    istream &read_common(istream &in)
    {
        in >> _name >> midterm >> final;
        return in;
    }
    double midterm, final;
    vector<double> homework;

private:
    string _name;
};

istream &Core::read(istream &in)
{
    read_common(in);
    read_hw(in, homework);
    return in;
}

string Core::letter_grade() const
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };

    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };

    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);

    double result = grade();

    for (size_t i = 0; i < ngrades; ++i)
    {
        if (result >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

inline bool compare(const Core &c1, const Core &c2)
{
    return c1.name() < c2.name();
}

inline bool compare_Core_ptrs(const Core *cp1, const Core *cp2)
{
    return compare(*cp1, *cp2);
}

class Grad : public Core
{
public:
    Grad() : thesis(0.0)
    {
        cerr << "constructor Grad()" << endl;
    }
    Grad(istream &is)
    {
        cerr << "constructor Grad(istream &is)" << endl;
        read(is);
    }

    ~Grad()
    {
        cerr << "destructor ~Grad()" << endl;
    }
    double grade() const;
    istream &read(istream &);

    bool requirements_met() const
    {
        return Core::requirements_met() && thesis != 0.0;
    }

protected:
    Grad *clone() const
    {
        return new Grad(*this);
    }

private:
    double thesis;
};

istream &Grad::read(istream &in)
{
    Core::read_common(in);
    in >> Grad::thesis;
    read_hw(in, Core::homework);
    return in;
}

double Grad::grade() const
{
    cerr << "Grad::grade()" << endl;
    return min(Core::grade(), Grad::thesis);
}

class Credit : public Core
{
public:
    Credit() {}
    Credit(istream &is) : Core(is) {}

    double grade() const;
    bool passed() const
    {
        return grade() >= 60;
    }

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }

protected:
    Credit *clone() const
    {
        return new Credit(*this);
    }
};

double Credit::grade() const
{
    if (Core::homework.empty())
    {
        return (midterm + final) / 2.0;
    }
    else
    {
        return Core::grade();
    }
}

class Audit : public Core
{
public:
    Audit() {}
    Audit(istream &is)
    {
        read(is);
    }

    istream &read(istream &in)
    {
        in >> _name;
        return in;
    }

    double grade() const
    {
        return 0.0;
    };

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }

protected:
    Audit *clone() const
    {
        return new Audit(*this);
    }
};

class Student_info
{
public:
    Student_info() : cp(nullptr) { }
    Student_info(istream &is) : cp(nullptr)
    {
        read(is);
    }
    Student_info(const Student_info &);
    Student_info &operator=(const Student_info &);
    ~Student_info()
    {
        delete cp;
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp != nullptr)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp != nullptr)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Core *cp;
};


istream &Student_info::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        delete cp;
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

Student_info::Student_info(const Student_info &s) : cp(nullptr)
{
    if (s.cp != nullptr)
    {
        cp = s.cp->clone();
    }
}

Student_info &Student_info::operator=(const Student_info &s)
{
    if (this == &s)
    {
        return *this;
    }
    delete cp;
    if (s.cp != nullptr)
    {
        cp = s.cp->clone();
    }
    else
    {
        cp = nullptr;
    }
    return *this;
}

inline bool compare_info(const Student_info &s1, const Student_info &s2)
{
    return s1.name() < s2.name();
}

int main()
{
    Core *p1 = new Core;
    Core *p2 = new Grad;
    Core s1;
    Grad s2;

    p1->read(cin);
    p2->read(cin);
    s1.read(cin);
    s2.read(cin);

    cout << p1->name() << ", " << p1->grade() << endl;
    cout << p2->name() << ", " << p2->grade() << endl;
    cout << s1.name() << ", " << s1.grade() << endl;
    cout << s2.name() << ", " << s2.grade() << endl;

    delete p1;
    delete p2;

    return 0;
}
显示结果如下
constructor Core()
constructor Core()
constructor Grad()
constructor Core()
constructor Core()
constructor Grad()
Geert 50 80 90 45 30 80 end
Lotte 40 80 62 90 45 60 70 end
Jan 30 20 80 40 50 30 40 end
Joris 80 90 62 60 70 60 70 60 end
Core::name()
Geert, Core::grade()
67
Core::name()
Lotte, Grad::grade()
Core::grade()
62
Core::name()
Jan, Core::grade()
30
Core::name()
Joris, Grad::grade()
Core::grade()
62
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()

13-3 在第9章写的类中包括一个成员数据valid，它是用来让用户检测该对象是否储存着一个学生的记录的。在本章的类的继承树中加入同样的功能。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

class Core
{
public:
    friend class Student_info;
    friend class Audit;
    Core() : midterm(0), final(0)
    {
        cerr << "constructor Core()" << endl;
    }
    Core(istream &is)
    {
        cerr << "constructor Core(istream &is)" << endl;
        read(is);
    }

    virtual ~Core()
    {
        cerr << "destructor ~Core()" << endl;
    }

    const string &name() const
    {
        return _name;
    }
    virtual double grade() const
    {
        return ::grade(midterm, final, homework);
    }
    string letter_grade() const;
    virtual istream &read(istream &);

    bool valid() const
    {
        return !homework.empty();
    }
    virtual bool requirements_met() const
    {
        return find(homework.begin(), homework.end(), 0.0) == homework.end();
    }

protected:
    virtual Core *clone() const
    {
        return new Core(*this);
    }
    istream &read_common(istream &in)
    {
        in >> _name >> midterm >> final;
        return in;
    }
    double midterm, final;
    vector<double> homework;

private:
    string _name;
};

istream &Core::read(istream &in)
{
    read_common(in);
    read_hw(in, homework);
    return in;
}

string Core::letter_grade() const
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };

    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };

    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);

    double result = grade();

    for (size_t i = 0; i < ngrades; ++i)
    {
        if (result >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

inline bool compare(const Core &c1, const Core &c2)
{
    return c1.name() < c2.name();
}

inline bool compare_Core_ptrs(const Core *cp1, const Core *cp2)
{
    return compare(*cp1, *cp2);
}

class Grad : public Core
{
public:
    Grad() : thesis(0.0)
    {
        cerr << "constructor Grad()" << endl;
    }
    Grad(istream &is)
    {
        cerr << "constructor Grad(istream &is)" << endl;
        read(is);
    }

    ~Grad()
    {
        cerr << "destructor ~Grad()" << endl;
    }
    double grade() const;
    istream &read(istream &);

    bool requirements_met() const
    {
        return Core::requirements_met() && thesis != 0.0;
    }

protected:
    Grad *clone() const
    {
        return new Grad(*this);
    }

private:
    double thesis;
};

istream &Grad::read(istream &in)
{
    Core::read_common(in);
    in >> Grad::thesis;
    read_hw(in, Core::homework);
    return in;
}

double Grad::grade() const
{
    return min(Core::grade(), Grad::thesis);
}

class Credit : public Core
{
public:
    Credit() {}
    Credit(istream &is) : Core(is) {}

    double grade() const;
    bool passed() const
    {
        return grade() >= 60;
    }

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }

protected:
    Credit *clone() const
    {
        return new Credit(*this);
    }
};

double Credit::grade() const
{
    if (Core::homework.empty())
    {
        return (midterm + final) / 2.0;
    }
    else
    {
        return Core::grade();
    }
}

class Audit : public Core
{
public:
    Audit() {}
    Audit(istream &is)
    {
        read(is);
    }

    istream &read(istream &in)
    {
        in >> _name;
        return in;
    }

    double grade() const
    {
        return 0.0;
    };

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }

protected:
    Audit *clone() const
    {
        return new Audit(*this);
    }
};

class Student_info
{
public:
    Student_info() : cp(nullptr) { }
    Student_info(istream &is) : cp(nullptr)
    {
        read(is);
    }
    Student_info(const Student_info &);
    Student_info &operator=(const Student_info &);
    ~Student_info()
    {
        delete cp;
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp != nullptr)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp != nullptr)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Core *cp;
};


istream &Student_info::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        delete cp;
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

Student_info::Student_info(const Student_info &s) : cp(nullptr)
{
    if (s.cp != nullptr)
    {
        cp = s.cp->clone();
    }
}

Student_info &Student_info::operator=(const Student_info &s)
{
    if (this == &s)
    {
        return *this;
    }
    delete cp;
    if (s.cp != nullptr)
    {
        cp = s.cp->clone();
    }
    else
    {
        cp = nullptr;
    }
    return *this;
}

inline bool compare_info(const Student_info &s1, const Student_info &s2)
{
    return s1.name() < s2.name();
}

int main()
{
    Grad grad(cin);

    if (grad.valid())
    {
        cout << "Grade: " << grad.name() << ", " << grad.grade() << endl;
    }

    return 0;
}
显示结果如下
constructor Core()
constructor Grad(istream &is)
Joris 80 90 62 60 70 60 70 60 end
Grade: Joris, 62
destructor ~Grad()
destructor ~Core()

13-4 向这些类中添加一个函数，根据10.3中讲到的方法把一个分数成绩转换成相应的字母成绩。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

class Core
{
public:
    friend class Student_info;
    friend class Audit;
    Core() : midterm(0), final(0)
    {
        cerr << "constructor Core()" << endl;
    }
    Core(istream &is)
    {
        cerr << "constructor Core(istream &is)" << endl;
        read(is);
    }

    virtual ~Core()
    {
        cerr << "destructor ~Core()" << endl;
    }

    const string &name() const
    {
        return _name;
    }
    virtual double grade() const
    {
        return ::grade(midterm, final, homework);
    }
    string letter_grade() const;
    virtual istream &read(istream &);

    bool valid() const
    {
        return !homework.empty();
    }
    virtual bool requirements_met() const
    {
        return find(homework.begin(), homework.end(), 0.0) == homework.end();
    }

protected:
    virtual Core *clone() const
    {
        return new Core(*this);
    }
    istream &read_common(istream &in)
    {
        in >> _name >> midterm >> final;
        return in;
    }
    double midterm, final;
    vector<double> homework;

private:
    string _name;
};

istream &Core::read(istream &in)
{
    read_common(in);
    read_hw(in, homework);
    return in;
}

string Core::letter_grade() const
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };

    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };

    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);

    double result = grade();

    for (size_t i = 0; i < ngrades; ++i)
    {
        if (result >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

inline bool compare(const Core &c1, const Core &c2)
{
    return c1.name() < c2.name();
}

inline bool compare_Core_ptrs(const Core *cp1, const Core *cp2)
{
    return compare(*cp1, *cp2);
}

class Grad : public Core
{
public:
    Grad() : thesis(0.0)
    {
        cerr << "constructor Grad()" << endl;
    }
    Grad(istream &is)
    {
        cerr << "constructor Grad(istream &is)" << endl;
        read(is);
    }

    ~Grad()
    {
        cerr << "destructor ~Grad()" << endl;
    }
    double grade() const;
    istream &read(istream &);

    bool requirements_met() const
    {
        return Core::requirements_met() && thesis != 0.0;
    }

protected:
    Grad *clone() const
    {
        return new Grad(*this);
    }

private:
    double thesis;
};

istream &Grad::read(istream &in)
{
    Core::read_common(in);
    in >> Grad::thesis;
    read_hw(in, Core::homework);
    return in;
}

double Grad::grade() const
{
    return min(Core::grade(), Grad::thesis);
}

class Credit : public Core
{
public:
    Credit() {}
    Credit(istream &is) : Core(is) {}

    double grade() const;
    bool passed() const
    {
        return grade() >= 60;
    }

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }

protected:
    Credit *clone() const
    {
        return new Credit(*this);
    }
};

double Credit::grade() const
{
    if (Core::homework.empty())
    {
        return (midterm + final) / 2.0;
    }
    else
    {
        return Core::grade();
    }
}

class Audit : public Core
{
public:
    Audit() {}
    Audit(istream &is)
    {
        read(is);
    }

    istream &read(istream &in)
    {
        in >> _name;
        return in;
    }

    double grade() const
    {
        return 0.0;
    };

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }

protected:
    Audit *clone() const
    {
        return new Audit(*this);
    }
};

class Student_info
{
public:
    Student_info() : cp(nullptr) { }
    Student_info(istream &is) : cp(nullptr)
    {
        read(is);
    }
    Student_info(const Student_info &);
    Student_info &operator=(const Student_info &);
    ~Student_info()
    {
        delete cp;
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp != nullptr)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp != nullptr)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Core *cp;
};


istream &Student_info::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        delete cp;
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

Student_info::Student_info(const Student_info &s) : cp(nullptr)
{
    if (s.cp != nullptr)
    {
        cp = s.cp->clone();
    }
}

Student_info &Student_info::operator=(const Student_info &s)
{
    if (this == &s)
    {
        return *this;
    }
    delete cp;
    if (s.cp != nullptr)
    {
        cp = s.cp->clone();
    }
    else
    {
        cp = nullptr;
    }
    return *this;
}

inline bool compare_info(const Student_info &s1, const Student_info &s2)
{
    return s1.name() < s2.name();
}

int main()
{
    cout << "Enter a Core student: " << endl;
    Core core(cin);
    cout << "Grade: " << core.grade() << ", " << core.letter_grade() << endl;

    cout << "Enter a Grad student: " << endl;
    Grad grad(cin);
    cout << "Grade: " << grad.grade() << ", " << grad.letter_grade() << endl;

    return 0;
}
显示结果如下
Enter a Core student:
constructor Core(istream &is)
Geert 50 80 90 45 30 80 end
Grade: 67, D
Enter a Grad student:
constructor Core()
constructor Grad(istream &is)
Joris 80 90 62 60 70 60 70 60 end
Grade: 62, D
destructor ~Grad()
destructor ~Core()
destructor ~Core()

13-5 写一个判断语句判断一个指定的学生是否达到了所有相应的要求，也就是说，
检查一下这个学生有没有做完所有的家庭作业，是不是一个研究生，如果是的话有没有写出一篇论文来，等等。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

class Core
{
public:
    friend class Student_info;
    friend class Audit;
    Core() : midterm(0), final(0)
    {
        cerr << "constructor Core()" << endl;
    }
    Core(istream &is)
    {
        cerr << "constructor Core(istream &is)" << endl;
        read(is);
    }

    virtual ~Core()
    {
        cerr << "destructor ~Core()" << endl;
    }

    const string &name() const
    {
        return _name;
    }
    virtual double grade() const
    {
        return ::grade(midterm, final, homework);
    }
    string letter_grade() const;
    virtual istream &read(istream &);

    bool valid() const
    {
        return !homework.empty();
    }
    virtual bool requirements_met() const
    {
        return find(homework.begin(), homework.end(), 0.0) == homework.end();
    }

protected:
    virtual Core *clone() const
    {
        return new Core(*this);
    }
    istream &read_common(istream &in)
    {
        in >> _name >> midterm >> final;
        return in;
    }
    double midterm, final;
    vector<double> homework;

private:
    string _name;
};

istream &Core::read(istream &in)
{
    read_common(in);
    read_hw(in, homework);
    return in;
}

string Core::letter_grade() const
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };

    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };

    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);

    double result = grade();

    for (size_t i = 0; i < ngrades; ++i)
    {
        if (result >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

inline bool compare(const Core &c1, const Core &c2)
{
    return c1.name() < c2.name();
}

inline bool compare_Core_ptrs(const Core *cp1, const Core *cp2)
{
    return compare(*cp1, *cp2);
}

class Grad : public Core
{
public:
    Grad() : thesis(0.0)
    {
        cerr << "constructor Grad()" << endl;
    }
    Grad(istream &is)
    {
        cerr << "constructor Grad(istream &is)" << endl;
        read(is);
    }

    ~Grad()
    {
        cerr << "destructor ~Grad()" << endl;
    }
    double grade() const;
    istream &read(istream &);

    bool requirements_met() const
    {
        return Core::requirements_met() && thesis != 0.0;
    }

protected:
    Grad *clone() const
    {
        return new Grad(*this);
    }

private:
    double thesis;
};

istream &Grad::read(istream &in)
{
    Core::read_common(in);
    in >> Grad::thesis;
    read_hw(in, Core::homework);
    return in;
}

double Grad::grade() const
{
    return min(Core::grade(), Grad::thesis);
}

class Credit : public Core
{
public:
    Credit() {}
    Credit(istream &is) : Core(is) {}

    double grade() const;
    bool passed() const
    {
        return grade() >= 60;
    }

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }

protected:
    Credit *clone() const
    {
        return new Credit(*this);
    }
};

double Credit::grade() const
{
    if (Core::homework.empty())
    {
        return (midterm + final) / 2.0;
    }
    else
    {
        return Core::grade();
    }
}

class Audit : public Core
{
public:
    Audit() {}
    Audit(istream &is)
    {
        read(is);
    }

    istream &read(istream &in)
    {
        in >> _name;
        return in;
    }

    double grade() const
    {
        return 0.0;
    };

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }

protected:
    Audit *clone() const
    {
        return new Audit(*this);
    }
};

class Student_info
{
public:
    Student_info() : cp(nullptr) { }
    Student_info(istream &is) : cp(nullptr)
    {
        read(is);
    }
    Student_info(const Student_info &);
    Student_info &operator=(const Student_info &);
    ~Student_info()
    {
        delete cp;
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp != nullptr)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp != nullptr)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Core *cp;
};


istream &Student_info::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        delete cp;
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

Student_info::Student_info(const Student_info &s) : cp(nullptr)
{
    if (s.cp != nullptr)
    {
        cp = s.cp->clone();
    }
}

Student_info &Student_info::operator=(const Student_info &s)
{
    if (this == &s)
    {
        return *this;
    }
    delete cp;
    if (s.cp != nullptr)
    {
        cp = s.cp->clone();
    }
    else
    {
        cp = nullptr;
    }
    return *this;
}

inline bool compare_info(const Student_info &s1, const Student_info &s2)
{
    return s1.name() < s2.name();
}

int main()
{
    cout << "Enter a Core student: " << endl;
    Core core(cin);
    cout << core.name() << ", " << core.grade() << endl;
    cout << "Requirements met? " << core.requirements_met() << endl;

    cout << "Enter a Grad student: " << endl;
    Grad grad(cin);
    cout << grad.name() << ", " << grad.grade() << endl;
    cout << "Requirements met? " << grad.requirements_met() << endl;

    return 0;
}
显示结果如下
Enter a Core student:
constructor Core(istream &is)
Geert 50 80 90 45 30 80 end
Geert, 67
Requirements met? 1
Enter a Grad student:
constructor Core()
constructor Grad(istream &is)
Joris 80 90 62 60 70 60 70 60 end
Joris, 62
Requirements met? 1
destructor ~Grad()
destructor ~Core()
destructor ~Core()

13-6 为系统添加一个新的类，这个类用来代表选取修可过/可不过的学分的学生。假设这些学生没有被要求一定要完成家庭作业，但是他们也可能会自觉地做作业。
如果他们做了作业，那么根据正常的计算公式，这些作业成绩会对总分成绩的计算起作用。
如果他们没有做家庭作业，那么就只拿他们的期中考试成绩与期末考试成绩求平均来得到他的最后成绩。在最后成绩为60分或者60分以上的时候才算通过。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

class Core
{
public:
    friend class Student_info;
    friend class Audit;
    Core() : midterm(0), final(0)
    {
        cerr << "constructor Core()" << endl;
    }
    Core(istream &is)
    {
        cerr << "constructor Core(istream &is)" << endl;
        read(is);
    }

    virtual ~Core()
    {
        cerr << "destructor ~Core()" << endl;
    }

    const string &name() const
    {
        return _name;
    }
    virtual double grade() const
    {
        return ::grade(midterm, final, homework);
    }
    string letter_grade() const;
    virtual istream &read(istream &);

    bool valid() const
    {
        return !homework.empty();
    }
    virtual bool requirements_met() const
    {
        return find(homework.begin(), homework.end(), 0.0) == homework.end();
    }

protected:
    virtual Core *clone() const
    {
        return new Core(*this);
    }
    istream &read_common(istream &in)
    {
        in >> _name >> midterm >> final;
        return in;
    }
    double midterm, final;
    vector<double> homework;

private:
    string _name;
};

istream &Core::read(istream &in)
{
    read_common(in);
    read_hw(in, homework);
    return in;
}

string Core::letter_grade() const
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };

    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };

    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);

    double result = grade();

    for (size_t i = 0; i < ngrades; ++i)
    {
        if (result >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

inline bool compare(const Core &c1, const Core &c2)
{
    return c1.name() < c2.name();
}

inline bool compare_Core_ptrs(const Core *cp1, const Core *cp2)
{
    return compare(*cp1, *cp2);
}

class Grad : public Core
{
public:
    Grad() : thesis(0.0)
    {
        cerr << "constructor Grad()" << endl;
    }
    Grad(istream &is)
    {
        cerr << "constructor Grad(istream &is)" << endl;
        read(is);
    }

    ~Grad()
    {
        cerr << "destructor ~Grad()" << endl;
    }
    double grade() const;
    istream &read(istream &);

    bool requirements_met() const
    {
        return Core::requirements_met() && thesis != 0.0;
    }

protected:
    Grad *clone() const
    {
        return new Grad(*this);
    }

private:
    double thesis;
};

istream &Grad::read(istream &in)
{
    Core::read_common(in);
    in >> Grad::thesis;
    read_hw(in, Core::homework);
    return in;
}

double Grad::grade() const
{
    return min(Core::grade(), Grad::thesis);
}

class Credit : public Core
{
public:
    Credit() {}
    Credit(istream &is) : Core(is) {}

    double grade() const;
    bool passed() const
    {
        return grade() >= 60;
    }

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }

protected:
    Credit *clone() const
    {
        return new Credit(*this);
    }
};

double Credit::grade() const
{
    if (Core::homework.empty())
    {
        return (midterm + final) / 2.0;
    }
    else
    {
        return Core::grade();
    }
}

class Audit : public Core
{
public:
    Audit() {}
    Audit(istream &is)
    {
        read(is);
    }

    istream &read(istream &in)
    {
        in >> _name;
        return in;
    }

    double grade() const
    {
        return 0.0;
    };

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }

protected:
    Audit *clone() const
    {
        return new Audit(*this);
    }
};

class Student_info
{
public:
    Student_info() : cp(nullptr) { }
    Student_info(istream &is) : cp(nullptr)
    {
        read(is);
    }
    Student_info(const Student_info &);
    Student_info &operator=(const Student_info &);
    ~Student_info()
    {
        delete cp;
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp != nullptr)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp != nullptr)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Core *cp;
};


istream &Student_info::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        delete cp;
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

Student_info::Student_info(const Student_info &s) : cp(nullptr)
{
    if (s.cp != nullptr)
    {
        cp = s.cp->clone();
    }
}

Student_info &Student_info::operator=(const Student_info &s)
{
    if (this == &s)
    {
        return *this;
    }
    delete cp;
    if (s.cp != nullptr)
    {
        cp = s.cp->clone();
    }
    else
    {
        cp = nullptr;
    }
    return *this;
}

inline bool compare_info(const Student_info &s1, const Student_info &s2)
{
    return s1.name() < s2.name();
}

int main()
{
    cout << "Enter a Credit student: " << endl;
    Credit credit(cin);
    cout << credit.name() << ", " << credit.grade() << endl;
    cout << "Passed? " << credit.passed() << endl;

    return 0;
}
显示结果如下
Enter a Credit student:
constructor Core(istream &is)
Geert 50 80 90 45 30 80 end
Geert, 67
Passed? 1
destructor ~Core()

13-7 为系统添加一个类，该类用来表示查分的学生。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

class Core
{
public:
    friend class Student_info;
    friend class Audit;
    Core() : midterm(0), final(0)
    {
        cerr << "constructor Core()" << endl;
    }
    Core(istream &is)
    {
        cerr << "constructor Core(istream &is)" << endl;
        read(is);
    }

    virtual ~Core()
    {
        cerr << "destructor ~Core()" << endl;
    }

    const string &name() const
    {
        return _name;
    }
    virtual double grade() const
    {
        return ::grade(midterm, final, homework);
    }
    string letter_grade() const;
    virtual istream &read(istream &);

    bool valid() const
    {
        return !homework.empty();
    }
    virtual bool requirements_met() const
    {
        return find(homework.begin(), homework.end(), 0.0) == homework.end();
    }

protected:
    virtual Core *clone() const
    {
        return new Core(*this);
    }
    istream &read_common(istream &in)
    {
        in >> _name >> midterm >> final;
        return in;
    }
    double midterm, final;
    vector<double> homework;

private:
    string _name;
};

istream &Core::read(istream &in)
{
    read_common(in);
    read_hw(in, homework);
    return in;
}

string Core::letter_grade() const
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };

    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };

    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);

    double result = grade();

    for (size_t i = 0; i < ngrades; ++i)
    {
        if (result >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

inline bool compare(const Core &c1, const Core &c2)
{
    return c1.name() < c2.name();
}

inline bool compare_Core_ptrs(const Core *cp1, const Core *cp2)
{
    return compare(*cp1, *cp2);
}

class Grad : public Core
{
public:
    Grad() : thesis(0.0)
    {
        cerr << "constructor Grad()" << endl;
    }
    Grad(istream &is)
    {
        cerr << "constructor Grad(istream &is)" << endl;
        read(is);
    }

    ~Grad()
    {
        cerr << "destructor ~Grad()" << endl;
    }
    double grade() const;
    istream &read(istream &);

    bool requirements_met() const
    {
        return Core::requirements_met() && thesis != 0.0;
    }

protected:
    Grad *clone() const
    {
        return new Grad(*this);
    }

private:
    double thesis;
};

istream &Grad::read(istream &in)
{
    Core::read_common(in);
    in >> Grad::thesis;
    read_hw(in, Core::homework);
    return in;
}

double Grad::grade() const
{
    return min(Core::grade(), Grad::thesis);
}

class Credit : public Core
{
public:
    Credit() {}
    Credit(istream &is) : Core(is) {}

    double grade() const;
    bool passed() const
    {
        return grade() >= 60;
    }

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }

protected:
    Credit *clone() const
    {
        return new Credit(*this);
    }
};

double Credit::grade() const
{
    if (Core::homework.empty())
    {
        return (midterm + final) / 2.0;
    }
    else
    {
        return Core::grade();
    }
}

class Audit : public Core
{
public:
    Audit() {}
    Audit(istream &is)
    {
        read(is);
    }

    istream &read(istream &in)
    {
        in >> _name;
        return in;
    }

    double grade() const
    {
        return 0.0;
    };

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }

protected:
    Audit *clone() const
    {
        return new Audit(*this);
    }
};

class Student_info
{
public:
    Student_info() : cp(nullptr) { }
    Student_info(istream &is) : cp(nullptr)
    {
        read(is);
    }
    Student_info(const Student_info &);
    Student_info &operator=(const Student_info &);
    ~Student_info()
    {
        delete cp;
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp != nullptr)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp != nullptr)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Core *cp;
};


istream &Student_info::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        delete cp;
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

Student_info::Student_info(const Student_info &s) : cp(nullptr)
{
    if (s.cp != nullptr)
    {
        cp = s.cp->clone();
    }
}

Student_info &Student_info::operator=(const Student_info &s)
{
    if (this == &s)
    {
        return *this;
    }
    delete cp;
    if (s.cp != nullptr)
    {
        cp = s.cp->clone();
    }
    else
    {
        cp = nullptr;
    }
    return *this;
}

inline bool compare_info(const Student_info &s1, const Student_info &s2)
{
    return s1.name() < s2.name();
}

int main()
{
    cout << "Enter an Audit student: " << endl;
    Audit audit(cin);
    cout << audit.name() << ", " << audit.grade() << endl;
    cout << "Requirements met? " << audit.requirements_met() << endl;

    return 0;
}
显示结果如下
Enter an Audit student:
constructor Core()
Geert 50 80 90 45 30 80 end
Geert, 0
Requirements met? 1
destructor ~Core()

13-8 写一个程序生成一个成绩报表，它可以处理上面提到的所有四种学生类的对象。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

class Core
{
public:
    friend class Student_info;
    friend class Audit;
    Core() : midterm(0), final(0)
    {
        cerr << "constructor Core()" << endl;
    }
    Core(istream &is)
    {
        cerr << "constructor Core(istream &is)" << endl;
        read(is);
    }

    virtual ~Core()
    {
        cerr << "destructor ~Core()" << endl;
    }

    const string &name() const
    {
        return _name;
    }
    virtual double grade() const
    {
        return ::grade(midterm, final, homework);
    }
    string letter_grade() const;
    virtual istream &read(istream &);

    bool valid() const
    {
        return !homework.empty();
    }
    virtual bool requirements_met() const
    {
        return find(homework.begin(), homework.end(), 0.0) == homework.end();
    }

protected:
    virtual Core *clone() const
    {
        return new Core(*this);
    }
    istream &read_common(istream &in)
    {
        in >> _name >> midterm >> final;
        return in;
    }
    double midterm, final;
    vector<double> homework;

private:
    string _name;
};

istream &Core::read(istream &in)
{
    read_common(in);
    read_hw(in, homework);
    return in;
}

string Core::letter_grade() const
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };

    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };

    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);

    double result = grade();

    for (size_t i = 0; i < ngrades; ++i)
    {
        if (result >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

inline bool compare(const Core &c1, const Core &c2)
{
    return c1.name() < c2.name();
}

inline bool compare_Core_ptrs(const Core *cp1, const Core *cp2)
{
    return compare(*cp1, *cp2);
}

class Grad : public Core
{
public:
    Grad() : thesis(0.0)
    {
        cerr << "constructor Grad()" << endl;
    }
    Grad(istream &is)
    {
        cerr << "constructor Grad(istream &is)" << endl;
        read(is);
    }

    ~Grad()
    {
        cerr << "destructor ~Grad()" << endl;
    }
    double grade() const;
    istream &read(istream &);

    bool requirements_met() const
    {
        return Core::requirements_met() && thesis != 0.0;
    }

protected:
    Grad *clone() const
    {
        return new Grad(*this);
    }

private:
    double thesis;
};

istream &Grad::read(istream &in)
{
    Core::read_common(in);
    in >> Grad::thesis;
    read_hw(in, Core::homework);
    return in;
}

double Grad::grade() const
{
    return min(Core::grade(), Grad::thesis);
}

class Credit : public Core
{
public:
    Credit() {}
    Credit(istream &is) : Core(is) {}

    double grade() const;
    bool passed() const
    {
        return grade() >= 60;
    }

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }

protected:
    Credit *clone() const
    {
        return new Credit(*this);
    }
};

double Credit::grade() const
{
    if (Core::homework.empty())
    {
        return (midterm + final) / 2.0;
    }
    else
    {
        return Core::grade();
    }
}

class Audit : public Core
{
public:
    Audit() {}
    Audit(istream &is)
    {
        read(is);
    }

    istream &read(istream &in)
    {
        in >> _name;
        return in;
    }

    double grade() const
    {
        return 0.0;
    };

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }

protected:
    Audit *clone() const
    {
        return new Audit(*this);
    }
};

class Student_info
{
public:
    Student_info() : cp(nullptr) { }
    Student_info(istream &is) : cp(nullptr)
    {
        read(is);
    }
    Student_info(const Student_info &);
    Student_info &operator=(const Student_info &);
    ~Student_info()
    {
        delete cp;
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp != nullptr)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp != nullptr)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Core *cp;
};


istream &Student_info::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        delete cp;
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

Student_info::Student_info(const Student_info &s) : cp(nullptr)
{
    if (s.cp != nullptr)
    {
        cp = s.cp->clone();
    }
}

Student_info &Student_info::operator=(const Student_info &s)
{
    if (this == &s)
    {
        return *this;
    }
    delete cp;
    if (s.cp != nullptr)
    {
        cp = s.cp->clone();
    }
    else
    {
        cp = nullptr;
    }
    return *this;
}

inline bool compare_info(const Student_info &s1, const Student_info &s2)
{
    return s1.name() < s2.name();
}

int main()
{
    vector<Student_info> students;
    Student_info record;
    Student_info temp;
    string::size_type maxlen = 0;

    cout << "Enter students (U = Core, G = Grad, C = Credit, A = Audit)" << endl;
    while (record.read(cin))
    {
        maxlen = max(maxlen, record.name().size());
        students.push_back(record);
    }
    record = temp;
    sort(students.begin(), students.end(), compare_info);

    for (vector<Student_info>::size_type i = 0; i != students.size(); ++i)
    {
        cout << students[i].name() << string(maxlen + 1 - students[i].name().size(), ' ');
        try
        {
            double final_grade = students[i].grade();
            streamsize prec = cout.precision();
            cout << setprecision(3) << final_grade << setprecision(prec) << endl;
        }
        catch (domain_error &e1)
        {
            cout << e1.what() << endl;
        }
        catch (runtime_error &e2)
        {
            cout << e2.what() << endl;
        }
    }

    return 0;
}
显示结果如下
Enter students (U = Core, G = Grad, C = Credit, A = Audit)
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
U
new Core
constructor Core(istream &is)
Geert 50 80 90 45 30 80 end
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
C
destructor ~Core()
new Credit
constructor Core(istream &is)
Pieter 40 50 30 40 50 50 40 end
destructor ~Core()
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
A
destructor ~Core()
new Audit
constructor Core()
Lotte
destructor ~Core()
destructor ~Core()
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
G
destructor ~Core()
new Grad
constructor Core()
constructor Grad(istream &is)
Joris 80 90 62 60 70 60 70 60 end
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Core()
destructor ~Core()
destructor ~Core()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
Geert  67
Joris  62
Lotte  0
Pieter 44
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Core()

13-9 想想看，在13.4.2中定义的赋值操作函数如果不能判断一个赋值操作是否是自我赋值，结果会发生什么？
如果不判断是否是自我赋值，则把原先的数据成员delete释放后，赋值就会出问题

Student_info &Student_info::operator=(const Student_info &s)
{
    if (this == &s)
    {
        return *this;
    }
    delete cp;
    if (s.cp != nullptr)
    {
        cp = s.cp->clone();
    }
    else
    {
        cp = nullptr;
    }
    return *this;
}

第14章 近乎自动地管理内存
14.1 用来复制对象的句柄
14.2 引用计数句柄
14.3 可以让你决定什么时候共享数据的句柄
14.4 可控句柄的一个改进
14.5 小结
习题
14-0 编译、运行并测试本章的例程。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Handle
{
public:
    Handle() : p(nullptr) { }
    Handle(T *t) : p(t) { }
    Handle(const Handle<T> &s) : p(nullptr)
    {
        if (s.p != nullptr)
        {
            p = s.p->clone();
        }
    }

    Handle<T> &operator=(const Handle<T> &);
    ~Handle()
    {
        delete p;
    }

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const;
    T *operator->() const;

private:
    T *p;
};

template<typename T>
Handle<T> &Handle<T>::operator=(const Handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    delete p;
    p = rhs.p != nullptr ? rhs.p->clone() : nullptr;
    return *this;
}

template <typename T>
T &Handle<T>::operator*() const
{
    if (p != nullptr)
    {
        return *p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
T *Handle<T>::operator->() const
{
    if (p != nullptr)
    {
        return p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
class Ref_handle
{
public:
    Ref_handle() : refptr(new size_t(1)), p(nullptr) { }
    Ref_handle(T *t) : refptr(new size_t(1)), p(t) { }

    Ref_handle(const Ref_handle<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ref_handle<T> &operator=(const Ref_handle<T> &);

    ~Ref_handle();

    operator bool() const
    {
        return p != nullptr;
    }
    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ref_handle");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ref_handle");
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ref_handle<T> &Ref_handle<T>::operator=(const Ref_handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;

    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }

    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ref_handle<T>::~Ref_handle()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

class Ref_counter
{
public:
    Ref_counter() : counter(new size_t(1)) { };
    Ref_counter(size_t s) : counter(new size_t(s)) { };
    Ref_counter(const Ref_counter &r) : counter(r.counter) { };

    Ref_counter &operator=(const Ref_counter &rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        if (*counter <= 0)
        {
            delete counter;
        }
        counter = rhs.counter;
        return *this;
    };

    Ref_counter &operator++()
    {
        (*counter)++;
        return *this;
    };

    Ref_counter &operator--()
    {
        (*counter)--;
        return *this;
    };

    Ref_counter operator++(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)++;
        return ret;
    };

    Ref_counter operator--(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)--;
        return ret;
    };

    ~Ref_counter()
    {
        if (*counter <= 0)
        {
            delete counter;
        }
    };

    size_t count()
    {
        return *counter;
    };

private:
    size_t *counter;
};


template<typename T>
T *clone(const T *tp)
{
    return tp->clone();
}

template<typename T>
class Ptr
{
public:
    Ptr() : refptr(new size_t(1)), p(nullptr) { }
    Ptr(T *t) : refptr(new size_t(1)), p(t) { }
    Ptr(const Ptr<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ptr<T> &operator=(const Ptr<T> &);
    ~Ptr();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr");
    }

    void make_unique()
    {
        if (*refptr > 1)
        {
            --*refptr;
            refptr = new size_t(1);
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ptr<T> &Ptr<T>::operator=(const Ptr<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ptr<T>::~Ptr()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

template<typename T>
class Ptr_r
{
public:
    Ptr_r() : p(nullptr) { }
    Ptr_r(T *t) : p(t) { }
    Ptr_r(const Ptr_r<T> &h) : ref_c(h.ref_c), p(h.p)
    {
        ++ref_c;
    }

    Ptr_r<T> &operator=(const Ptr_r<T> &);
    ~Ptr_r();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    void make_unique()
    {
        if (ref_c.count() > 1)
        {
            --ref_c;
            ref_c = Ref_counter();
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    Ref_counter ref_c;
};

template<typename T>
Ptr_r<T> &Ptr_r<T>::operator=(const Ptr_r<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
    ref_c = rhs.ref_c;
    p = rhs.p;
    ++ref_c;
    return *this;
}

template<typename T>
Ptr_r<T>::~Ptr_r()
{
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
}

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

template<>
inline Vec<char> *clone< Vec<char> >(const Vec<char> *vp)
{
    return new Vec<char>(*vp);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() : data(new Vec<char>) { }
    Str(size_type n, char c) : data(new Vec<char>(n, c)) { }
    Str(const char *cp) : data(new Vec<char>)
    {
        copy(cp, cp + strlen(cp), back_inserter(*data));
    }
    template<class In>
    Str(In b, In e) : data(new Vec<char>(b, e)) { }

    size_type size() const
    {
        return data->size();
    }

    char &operator[](size_type i)
    {
        data.make_unique();
        return (*data)[i];
    }

    const char &operator[](size_type i) const
    {
        return (*data)[i];
    }

    Str &operator+=(const Str &s)
    {
        data.make_unique();
        copy(s.data->begin(), s.data->end(), back_inserter(*data));
        return *this;
    }

    iterator begin()
    {
        return data->begin();
    };
    const_iterator begin() const
    {
        return data->begin();
    };
    iterator end()
    {
        return data->end();
    };
    const_iterator end() const
    {
        return data->end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data->clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data->push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }

    friend ostream &operator<< (ostream &os, const Str &s)
    {
        for (Str::size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }

    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Ptr< Vec<char> > data;
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

class Core
{
public:
    friend class Student_info;
    friend class Audit;
    Core() : midterm(0), final(0)
    {
        cerr << "constructor Core()" << endl;
    }
    Core(istream &is)
    {
        cerr << "constructor Core(istream &is)" << endl;
        read(is);
    }

    virtual ~Core()
    {
        cerr << "destructor ~Core()" << endl;
    }

    const string &name() const
    {
        return _name;
    }
    virtual double grade() const
    {
        return ::grade(midterm, final, homework);
    }
    string letter_grade() const;
    virtual istream &read(istream &);

    bool valid() const
    {
        return !homework.empty();
    }
    virtual bool requirements_met() const
    {
        return find(homework.begin(), homework.end(), 0.0) == homework.end();
    }
    virtual Core *clone() const
    {
        return new Core(*this);
    }

protected:
    istream &read_common(istream &in)
    {
        in >> _name >> midterm >> final;
        return in;
    }
    double midterm, final;
    vector<double> homework;

private:
    string _name;
};

istream &Core::read(istream &in)
{
    read_common(in);
    read_hw(in, homework);
    return in;
}

string Core::letter_grade() const
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };

    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };

    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);

    double result = grade();

    for (size_t i = 0; i < ngrades; ++i)
    {
        if (result >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

inline bool compare(const Core &c1, const Core &c2)
{
    return c1.name() < c2.name();
}

inline bool compare_Core_ptrs(const Core *cp1, const Core *cp2)
{
    return compare(*cp1, *cp2);
}

class Grad : public Core
{
public:
    Grad() : thesis(0.0)
    {
        cerr << "constructor Grad()" << endl;
    }
    Grad(istream &is)
    {
        cerr << "constructor Grad(istream &is)" << endl;
        read(is);
    }

    ~Grad()
    {
        cerr << "destructor ~Grad()" << endl;
    }
    double grade() const;
    istream &read(istream &);

    bool requirements_met() const
    {
        return Core::requirements_met() && thesis != 0.0;
    }
    Grad *clone() const
    {
        return new Grad(*this);
    }

protected:

private:
    double thesis;
};

istream &Grad::read(istream &in)
{
    Core::read_common(in);
    in >> Grad::thesis;
    read_hw(in, Core::homework);
    return in;
}

double Grad::grade() const
{
    return min(Core::grade(), Grad::thesis);
}

class Credit : public Core
{
public:
    Credit() {}
    Credit(istream &is) : Core(is) {}

    double grade() const;
    bool passed() const
    {
        return grade() >= 60;
    }

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }
    Credit *clone() const
    {
        return new Credit(*this);
    }

protected:
};

double Credit::grade() const
{
    if (Core::homework.empty())
    {
        return (midterm + final) / 2.0;
    }
    else
    {
        return Core::grade();
    }
}

class Audit : public Core
{
public:
    Audit() {}
    Audit(istream &is)
    {
        read(is);
    }

    istream &read(istream &in)
    {
        in >> _name;
        return in;
    }

    double grade() const
    {
        return 0.0;
    };

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }
    Audit *clone() const
    {
        return new Audit(*this);
    }

protected:
};

class Student_info
{
public:
    Student_info() { }
    Student_info(istream &is)
    {
        read(is);
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Handle<Core> cp;
};

istream &Student_info::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

inline bool compare_info(const Student_info &s1, const Student_info &s2)
{
    return s1.name() < s2.name();
}

class Student_info_p
{
public:
    Student_info_p() { }
    Student_info_p(istream &is)
    {
        read(is);
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Ptr<Core> cp;
};

istream &Student_info_p::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

inline bool compare_info_p(const Student_info_p &s1, const Student_info_p &s2)
{
    return s1.name() < s2.name();
}


bool compare_Core_handles(const Handle<Core> hc1, const Handle<Core> hc2)
{
    return compare(*hc1, *hc2);
}

int test_handle()
{
    vector< Handle<Core> > students;
    Handle<Core> record;
    char ch;
    string::size_type maxlen = 0;
    while (cin >> ch && ch != 'Q')
    {
        if (ch == 'U')
        {
            record = new Core;
        }
        else
        {
            record = new Grad;
        }
        record->read(cin);
        maxlen = max(maxlen, record->name().size());
        students.push_back(record);
    }
    sort(students.begin(), students.end(), compare_Core_handles);
    for (vector< Handle<Core> >::size_type i = 0; i != students.size(); ++i)
    {
        cout << students[i]->name() << string(maxlen + 1 - students[i]->name().size(), ' ');
        try
        {
            double final_grade = students[i]->grade();
            streamsize prec = cout.precision();
            cout << setprecision(3) << final_grade << setprecision(prec) << endl;
        }
        catch (domain_error &e1)
        {
            cout << e1.what() << endl;
        }
        catch (runtime_error &e2)
        {
            cout << e2.what() << endl;
        }
    }
    return 0;
}

int test_str()
{
    Str s1 = "Hello ";
    Str s2;
    cout << "Please enter your name: ";
    cin >> s2;
    Str s3 = s1 + s2 + " how are you?";
    cout << s3 << endl;

    return 0;
}

int main()
{
    test_handle();
    cin.clear();
    test_str();

    return 0;
}
显示结果如下

U
constructor Core()
destructor ~Core()
Geert 50 80 90 45 30 80 end
G
constructor Core()
constructor Grad()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
Joris 80 90 62 60 70 60 70 60 end
destructor ~Core()
U
constructor Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()
Pieter 40 50 30 40 50 50 40 end
destructor ~Core()
destructor ~Grad()
destructor ~Core()
G
constructor Core()
constructor Grad()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
Lotte 40 80 62 90 45 60 70 end
Q
destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Core()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
Geert  67
Joris  62
Lotte  62
Pieter 44
destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()
Please enter your name: Peter Smith
Hello Peter how are you?

14-1 实现Ptr<Core>类的对比操作函数。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Handle
{
public:
    Handle() : p(nullptr) { }
    Handle(T *t) : p(t) { }
    Handle(const Handle<T> &s) : p(nullptr)
    {
        if (s.p != nullptr)
        {
            p = s.p->clone();
        }
    }

    Handle<T> &operator=(const Handle<T> &);
    ~Handle()
    {
        delete p;
    }

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const;
    T *operator->() const;

private:
    T *p;
};

template<typename T>
Handle<T> &Handle<T>::operator=(const Handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    delete p;
    p = rhs.p != nullptr ? rhs.p->clone() : nullptr;
    return *this;
}

template <typename T>
T &Handle<T>::operator*() const
{
    if (p != nullptr)
    {
        return *p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
T *Handle<T>::operator->() const
{
    if (p != nullptr)
    {
        return p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
class Ref_handle
{
public:
    Ref_handle() : refptr(new size_t(1)), p(nullptr) { }
    Ref_handle(T *t) : refptr(new size_t(1)), p(t) { }

    Ref_handle(const Ref_handle<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ref_handle<T> &operator=(const Ref_handle<T> &);

    ~Ref_handle();

    operator bool() const
    {
        return p != nullptr;
    }
    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ref_handle");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ref_handle");
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ref_handle<T> &Ref_handle<T>::operator=(const Ref_handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;

    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }

    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ref_handle<T>::~Ref_handle()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

class Ref_counter
{
public:
    Ref_counter() : counter(new size_t(1)) { };
    Ref_counter(size_t s) : counter(new size_t(s)) { };
    Ref_counter(const Ref_counter &r) : counter(r.counter) { };

    Ref_counter &operator=(const Ref_counter &rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        if (*counter <= 0)
        {
            delete counter;
        }
        counter = rhs.counter;
        return *this;
    };

    Ref_counter &operator++()
    {
        (*counter)++;
        return *this;
    };

    Ref_counter &operator--()
    {
        (*counter)--;
        return *this;
    };

    Ref_counter operator++(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)++;
        return ret;
    };

    Ref_counter operator--(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)--;
        return ret;
    };

    ~Ref_counter()
    {
        if (*counter <= 0)
        {
            delete counter;
        }
    };

    size_t count()
    {
        return *counter;
    };

private:
    size_t *counter;
};


template<typename T>
T *clone(const T *tp)
{
    return tp->clone();
}

template<typename T>
class Ptr
{
public:
    Ptr() : refptr(new size_t(1)), p(nullptr) { }
    Ptr(T *t) : refptr(new size_t(1)), p(t) { }
    Ptr(const Ptr<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ptr<T> &operator=(const Ptr<T> &);
    ~Ptr();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr");
    }

    void make_unique()
    {
        if (*refptr > 1)
        {
            --*refptr;
            refptr = new size_t(1);
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ptr<T> &Ptr<T>::operator=(const Ptr<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ptr<T>::~Ptr()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

template<typename T>
class Ptr_r
{
public:
    Ptr_r() : p(nullptr) { }
    Ptr_r(T *t) : p(t) { }
    Ptr_r(const Ptr_r<T> &h) : ref_c(h.ref_c), p(h.p)
    {
        ++ref_c;
    }

    Ptr_r<T> &operator=(const Ptr_r<T> &);
    ~Ptr_r();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    void make_unique()
    {
        if (ref_c.count() > 1)
        {
            --ref_c;
            ref_c = Ref_counter();
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    Ref_counter ref_c;
};

template<typename T>
Ptr_r<T> &Ptr_r<T>::operator=(const Ptr_r<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
    ref_c = rhs.ref_c;
    p = rhs.p;
    ++ref_c;
    return *this;
}

template<typename T>
Ptr_r<T>::~Ptr_r()
{
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
}

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

template<>
inline Vec<char> *clone< Vec<char> >(const Vec<char> *vp)
{
    return new Vec<char>(*vp);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() : data(new Vec<char>) { }
    Str(size_type n, char c) : data(new Vec<char>(n, c)) { }
    Str(const char *cp) : data(new Vec<char>)
    {
        copy(cp, cp + strlen(cp), back_inserter(*data));
    }
    template<class In>
    Str(In b, In e) : data(new Vec<char>(b, e)) { }

    size_type size() const
    {
        return data->size();
    }

    char &operator[](size_type i)
    {
        data.make_unique();
        return (*data)[i];
    }

    const char &operator[](size_type i) const
    {
        return (*data)[i];
    }

    Str &operator+=(const Str &s)
    {
        data.make_unique();
        copy(s.data->begin(), s.data->end(), back_inserter(*data));
        return *this;
    }

    iterator begin()
    {
        return data->begin();
    };
    const_iterator begin() const
    {
        return data->begin();
    };
    iterator end()
    {
        return data->end();
    };
    const_iterator end() const
    {
        return data->end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data->clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data->push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }

    friend ostream &operator<< (ostream &os, const Str &s)
    {
        for (Str::size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }

    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Ptr< Vec<char> > data;
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

class Core
{
public:
    friend class Student_info;
    friend class Audit;
    Core() : midterm(0), final(0)
    {
        cerr << "constructor Core()" << endl;
    }
    Core(istream &is)
    {
        cerr << "constructor Core(istream &is)" << endl;
        read(is);
    }

    virtual ~Core()
    {
        cerr << "destructor ~Core()" << endl;
    }

    const string &name() const
    {
        return _name;
    }
    virtual double grade() const
    {
        return ::grade(midterm, final, homework);
    }
    string letter_grade() const;
    virtual istream &read(istream &);

    bool valid() const
    {
        return !homework.empty();
    }
    virtual bool requirements_met() const
    {
        return find(homework.begin(), homework.end(), 0.0) == homework.end();
    }
    virtual Core *clone() const
    {
        return new Core(*this);
    }

protected:
    istream &read_common(istream &in)
    {
        in >> _name >> midterm >> final;
        return in;
    }
    double midterm, final;
    vector<double> homework;

private:
    string _name;
};

istream &Core::read(istream &in)
{
    read_common(in);
    read_hw(in, homework);
    return in;
}

string Core::letter_grade() const
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };

    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };

    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);

    double result = grade();

    for (size_t i = 0; i < ngrades; ++i)
    {
        if (result >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

inline bool compare(const Core &c1, const Core &c2)
{
    return c1.name() < c2.name();
}

inline bool compare_Core_ptrs(const Core *cp1, const Core *cp2)
{
    return compare(*cp1, *cp2);
}

class Grad : public Core
{
public:
    Grad() : thesis(0.0)
    {
        cerr << "constructor Grad()" << endl;
    }
    Grad(istream &is)
    {
        cerr << "constructor Grad(istream &is)" << endl;
        read(is);
    }

    ~Grad()
    {
        cerr << "destructor ~Grad()" << endl;
    }
    double grade() const;
    istream &read(istream &);

    bool requirements_met() const
    {
        return Core::requirements_met() && thesis != 0.0;
    }
    Grad *clone() const
    {
        return new Grad(*this);
    }

protected:

private:
    double thesis;
};

istream &Grad::read(istream &in)
{
    Core::read_common(in);
    in >> Grad::thesis;
    read_hw(in, Core::homework);
    return in;
}

double Grad::grade() const
{
    return min(Core::grade(), Grad::thesis);
}

class Credit : public Core
{
public:
    Credit() {}
    Credit(istream &is) : Core(is) {}

    double grade() const;
    bool passed() const
    {
        return grade() >= 60;
    }

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }
    Credit *clone() const
    {
        return new Credit(*this);
    }

protected:
};

double Credit::grade() const
{
    if (Core::homework.empty())
    {
        return (midterm + final) / 2.0;
    }
    else
    {
        return Core::grade();
    }
}

class Audit : public Core
{
public:
    Audit() {}
    Audit(istream &is)
    {
        read(is);
    }

    istream &read(istream &in)
    {
        in >> _name;
        return in;
    }

    double grade() const
    {
        return 0.0;
    };

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }
    Audit *clone() const
    {
        return new Audit(*this);
    }

protected:
};

class Student_info
{
public:
    Student_info() { }
    Student_info(istream &is)
    {
        read(is);
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Handle<Core> cp;
};

istream &Student_info::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

inline bool compare_info(const Student_info &s1, const Student_info &s2)
{
    return s1.name() < s2.name();
}

class Student_info_p
{
public:
    Student_info_p() { }
    Student_info_p(istream &is)
    {
        read(is);
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Ptr<Core> cp;
};

istream &Student_info_p::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

inline bool compare_info_p(const Student_info_p &s1, const Student_info_p &s2)
{
    return s1.name() < s2.name();
}

inline bool compare_Core_handles(const Handle<Core> hc1, const Handle<Core> hc2)
{
    return compare(*hc1, *hc2);
}

inline bool compare_Core_Ptr(const Ptr<Core> hc1, const Ptr<Core> hc2)
{
    return compare(*hc1, *hc2);
}

int main()
{
    Ptr<Core> p1 = new Core(cin);
    Ptr<Core> p2 = new Grad(cin);

    cout << p1->name() << ", " << p1->grade() << endl;
    cout << p2->name() << ", " << p2->grade() << endl;
    cout << "compare_Core_Ptr(p1, p2) = " << compare_Core_Ptr(p1, p2) << endl;

    return 0;
}
显示结果如下
constructor Core(istream &is)
Geert 50 80 90 45 30 80 end
constructor Core()
constructor Grad(istream &is)
Joris 80 90 62 60 70 60 70 60 end
Geert, 67
Joris, 62
compare_Core_Ptr(p1, p2) = 1
destructor ~Grad()
destructor ~Core()
destructor ~Core()

14-2 使用Ptr<Core>对象实现学生成绩程序并对其进行检验。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Handle
{
public:
    Handle() : p(nullptr) { }
    Handle(T *t) : p(t) { }
    Handle(const Handle<T> &s) : p(nullptr)
    {
        if (s.p != nullptr)
        {
            p = s.p->clone();
        }
    }

    Handle<T> &operator=(const Handle<T> &);
    ~Handle()
    {
        delete p;
    }

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const;
    T *operator->() const;

private:
    T *p;
};

template<typename T>
Handle<T> &Handle<T>::operator=(const Handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    delete p;
    p = rhs.p != nullptr ? rhs.p->clone() : nullptr;
    return *this;
}

template <typename T>
T &Handle<T>::operator*() const
{
    if (p != nullptr)
    {
        return *p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
T *Handle<T>::operator->() const
{
    if (p != nullptr)
    {
        return p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
class Ref_handle
{
public:
    Ref_handle() : refptr(new size_t(1)), p(nullptr) { }
    Ref_handle(T *t) : refptr(new size_t(1)), p(t) { }

    Ref_handle(const Ref_handle<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ref_handle<T> &operator=(const Ref_handle<T> &);

    ~Ref_handle();

    operator bool() const
    {
        return p != nullptr;
    }
    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ref_handle");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ref_handle");
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ref_handle<T> &Ref_handle<T>::operator=(const Ref_handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;

    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }

    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ref_handle<T>::~Ref_handle()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

class Ref_counter
{
public:
    Ref_counter() : counter(new size_t(1)) { };
    Ref_counter(size_t s) : counter(new size_t(s)) { };
    Ref_counter(const Ref_counter &r) : counter(r.counter) { };

    Ref_counter &operator=(const Ref_counter &rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        if (*counter <= 0)
        {
            delete counter;
        }
        counter = rhs.counter;
        return *this;
    };

    Ref_counter &operator++()
    {
        (*counter)++;
        return *this;
    };

    Ref_counter &operator--()
    {
        (*counter)--;
        return *this;
    };

    Ref_counter operator++(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)++;
        return ret;
    };

    Ref_counter operator--(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)--;
        return ret;
    };

    ~Ref_counter()
    {
        if (*counter <= 0)
        {
            delete counter;
        }
    };

    size_t count()
    {
        return *counter;
    };

private:
    size_t *counter;
};


template<typename T>
T *clone(const T *tp)
{
    return tp->clone();
}

template<typename T>
class Ptr
{
public:
    Ptr() : refptr(new size_t(1)), p(nullptr) { }
    Ptr(T *t) : refptr(new size_t(1)), p(t) { }
    Ptr(const Ptr<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ptr<T> &operator=(const Ptr<T> &);
    ~Ptr();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr");
    }

    void make_unique()
    {
        if (*refptr > 1)
        {
            --*refptr;
            refptr = new size_t(1);
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ptr<T> &Ptr<T>::operator=(const Ptr<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ptr<T>::~Ptr()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

template<typename T>
class Ptr_r
{
public:
    Ptr_r() : p(nullptr) { }
    Ptr_r(T *t) : p(t) { }
    Ptr_r(const Ptr_r<T> &h) : ref_c(h.ref_c), p(h.p)
    {
        ++ref_c;
    }

    Ptr_r<T> &operator=(const Ptr_r<T> &);
    ~Ptr_r();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    void make_unique()
    {
        if (ref_c.count() > 1)
        {
            --ref_c;
            ref_c = Ref_counter();
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    Ref_counter ref_c;
};

template<typename T>
Ptr_r<T> &Ptr_r<T>::operator=(const Ptr_r<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
    ref_c = rhs.ref_c;
    p = rhs.p;
    ++ref_c;
    return *this;
}

template<typename T>
Ptr_r<T>::~Ptr_r()
{
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
}

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

template<>
inline Vec<char> *clone< Vec<char> >(const Vec<char> *vp)
{
    return new Vec<char>(*vp);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() : data(new Vec<char>) { }
    Str(size_type n, char c) : data(new Vec<char>(n, c)) { }
    Str(const char *cp) : data(new Vec<char>)
    {
        copy(cp, cp + strlen(cp), back_inserter(*data));
    }
    template<class In>
    Str(In b, In e) : data(new Vec<char>(b, e)) { }

    size_type size() const
    {
        return data->size();
    }

    char &operator[](size_type i)
    {
        data.make_unique();
        return (*data)[i];
    }

    const char &operator[](size_type i) const
    {
        return (*data)[i];
    }

    Str &operator+=(const Str &s)
    {
        data.make_unique();
        copy(s.data->begin(), s.data->end(), back_inserter(*data));
        return *this;
    }

    iterator begin()
    {
        return data->begin();
    };
    const_iterator begin() const
    {
        return data->begin();
    };
    iterator end()
    {
        return data->end();
    };
    const_iterator end() const
    {
        return data->end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data->clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data->push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }

    friend ostream &operator<< (ostream &os, const Str &s)
    {
        for (Str::size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }

    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Ptr< Vec<char> > data;
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

class Core
{
public:
    friend class Student_info;
    friend class Audit;
    Core() : midterm(0), final(0)
    {
        cerr << "constructor Core()" << endl;
    }
    Core(istream &is)
    {
        cerr << "constructor Core(istream &is)" << endl;
        read(is);
    }

    virtual ~Core()
    {
        cerr << "destructor ~Core()" << endl;
    }

    const string &name() const
    {
        return _name;
    }
    virtual double grade() const
    {
        return ::grade(midterm, final, homework);
    }
    string letter_grade() const;
    virtual istream &read(istream &);

    bool valid() const
    {
        return !homework.empty();
    }
    virtual bool requirements_met() const
    {
        return find(homework.begin(), homework.end(), 0.0) == homework.end();
    }
    virtual Core *clone() const
    {
        return new Core(*this);
    }

protected:
    istream &read_common(istream &in)
    {
        in >> _name >> midterm >> final;
        return in;
    }
    double midterm, final;
    vector<double> homework;

private:
    string _name;
};

istream &Core::read(istream &in)
{
    read_common(in);
    read_hw(in, homework);
    return in;
}

string Core::letter_grade() const
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };

    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };

    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);

    double result = grade();

    for (size_t i = 0; i < ngrades; ++i)
    {
        if (result >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

inline bool compare(const Core &c1, const Core &c2)
{
    return c1.name() < c2.name();
}

inline bool compare_Core_ptrs(const Core *cp1, const Core *cp2)
{
    return compare(*cp1, *cp2);
}

class Grad : public Core
{
public:
    Grad() : thesis(0.0)
    {
        cerr << "constructor Grad()" << endl;
    }
    Grad(istream &is)
    {
        cerr << "constructor Grad(istream &is)" << endl;
        read(is);
    }

    ~Grad()
    {
        cerr << "destructor ~Grad()" << endl;
    }
    double grade() const;
    istream &read(istream &);

    bool requirements_met() const
    {
        return Core::requirements_met() && thesis != 0.0;
    }
    Grad *clone() const
    {
        return new Grad(*this);
    }

protected:

private:
    double thesis;
};

istream &Grad::read(istream &in)
{
    Core::read_common(in);
    in >> Grad::thesis;
    read_hw(in, Core::homework);
    return in;
}

double Grad::grade() const
{
    return min(Core::grade(), Grad::thesis);
}

class Credit : public Core
{
public:
    Credit() {}
    Credit(istream &is) : Core(is) {}

    double grade() const;
    bool passed() const
    {
        return grade() >= 60;
    }

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }
    Credit *clone() const
    {
        return new Credit(*this);
    }

protected:
};

double Credit::grade() const
{
    if (Core::homework.empty())
    {
        return (midterm + final) / 2.0;
    }
    else
    {
        return Core::grade();
    }
}

class Audit : public Core
{
public:
    Audit() {}
    Audit(istream &is)
    {
        read(is);
    }

    istream &read(istream &in)
    {
        in >> _name;
        return in;
    }

    double grade() const
    {
        return 0.0;
    };

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }
    Audit *clone() const
    {
        return new Audit(*this);
    }

protected:
};

class Student_info
{
public:
    Student_info() { }
    Student_info(istream &is)
    {
        read(is);
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Handle<Core> cp;
};

istream &Student_info::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

inline bool compare_info(const Student_info &s1, const Student_info &s2)
{
    return s1.name() < s2.name();
}

class Student_info_p
{
public:
    Student_info_p() { }
    Student_info_p(istream &is)
    {
        read(is);
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Ptr<Core> cp;
};

istream &Student_info_p::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

inline bool compare_info_p(const Student_info_p &s1, const Student_info_p &s2)
{
    return s1.name() < s2.name();
}

inline bool compare_Core_handles(const Handle<Core> hc1, const Handle<Core> hc2)
{
    return compare(*hc1, *hc2);
}

inline bool compare_Core_Ptr(const Ptr<Core> hc1, const Ptr<Core> hc2)
{
    return compare(*hc1, *hc2);
}

int main()
{
    vector< Ptr<Core> > students;
    Ptr<Core> record;
    char ch;
    string::size_type maxlen = 0;
    while (cin >> ch && ch != 'Q')
    {
        if (ch == 'U')
        {
            record = new Core;
        }
        else
        {
            record = new Grad;
        }
        record->read(cin);
        maxlen = max(maxlen, record->name().size());
        students.push_back(record);
    }
    sort(students.begin(), students.end(), compare_Core_Ptr);
    for (vector< Ptr<Core> >::size_type i = 0; i != students.size(); ++i)
    {
        cout << students[i]->name() << string(maxlen + 1 - students[i]->name().size(), ' ');
        try
        {
            double final_grade = students[i]->grade();
            streamsize prec = cout.precision();
            cout << setprecision(3) << final_grade << setprecision(prec) << endl;
        }
        catch (domain_error &e1)
        {
            cout << e1.what() << endl;
        }
        catch (runtime_error &e2)
        {
            cout << e2.what() << endl;
        }
    }

    return 0;
}
显示结果如下
U
constructor Core()
Geert 50 80 90 45 30 80 end
G
constructor Core()
constructor Grad()
Joris 80 90 62 60 70 60 70 60 end
U
constructor Core()
Pieter 40 50 30 40 50 50 40 end
G
constructor Core()
constructor Grad()
Lotte 40 80 62 90 45 60 70 end
Q
Geert  67
Joris  62
Lotte  62
Pieter 44
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()

14-3 使用Ptr类的最终版本来实现Student info类，然后用这一版本的Student_info类来实现13.5的学生成绩程序。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Handle
{
public:
    Handle() : p(nullptr) { }
    Handle(T *t) : p(t) { }
    Handle(const Handle<T> &s) : p(nullptr)
    {
        if (s.p != nullptr)
        {
            p = s.p->clone();
        }
    }

    Handle<T> &operator=(const Handle<T> &);
    ~Handle()
    {
        delete p;
    }

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const;
    T *operator->() const;

private:
    T *p;
};

template<typename T>
Handle<T> &Handle<T>::operator=(const Handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    delete p;
    p = rhs.p != nullptr ? rhs.p->clone() : nullptr;
    return *this;
}

template <typename T>
T &Handle<T>::operator*() const
{
    if (p != nullptr)
    {
        return *p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
T *Handle<T>::operator->() const
{
    if (p != nullptr)
    {
        return p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
class Ref_handle
{
public:
    Ref_handle() : refptr(new size_t(1)), p(nullptr) { }
    Ref_handle(T *t) : refptr(new size_t(1)), p(t) { }

    Ref_handle(const Ref_handle<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ref_handle<T> &operator=(const Ref_handle<T> &);

    ~Ref_handle();

    operator bool() const
    {
        return p != nullptr;
    }
    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ref_handle");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ref_handle");
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ref_handle<T> &Ref_handle<T>::operator=(const Ref_handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;

    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }

    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ref_handle<T>::~Ref_handle()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

class Ref_counter
{
public:
    Ref_counter() : counter(new size_t(1)) { };
    Ref_counter(size_t s) : counter(new size_t(s)) { };
    Ref_counter(const Ref_counter &r) : counter(r.counter) { };

    Ref_counter &operator=(const Ref_counter &rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        if (*counter <= 0)
        {
            delete counter;
        }
        counter = rhs.counter;
        return *this;
    };

    Ref_counter &operator++()
    {
        (*counter)++;
        return *this;
    };

    Ref_counter &operator--()
    {
        (*counter)--;
        return *this;
    };

    Ref_counter operator++(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)++;
        return ret;
    };

    Ref_counter operator--(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)--;
        return ret;
    };

    ~Ref_counter()
    {
        if (*counter <= 0)
        {
            delete counter;
        }
    };

    size_t count()
    {
        return *counter;
    };

private:
    size_t *counter;
};


template<typename T>
T *clone(const T *tp)
{
    return tp->clone();
}

template<typename T>
class Ptr
{
public:
    Ptr() : refptr(new size_t(1)), p(nullptr) { }
    Ptr(T *t) : refptr(new size_t(1)), p(t) { }
    Ptr(const Ptr<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ptr<T> &operator=(const Ptr<T> &);
    ~Ptr();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr");
    }

    void make_unique()
    {
        if (*refptr > 1)
        {
            --*refptr;
            refptr = new size_t(1);
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ptr<T> &Ptr<T>::operator=(const Ptr<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ptr<T>::~Ptr()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

template<typename T>
class Ptr_r
{
public:
    Ptr_r() : p(nullptr) { }
    Ptr_r(T *t) : p(t) { }
    Ptr_r(const Ptr_r<T> &h) : ref_c(h.ref_c), p(h.p)
    {
        ++ref_c;
    }

    Ptr_r<T> &operator=(const Ptr_r<T> &);
    ~Ptr_r();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    void make_unique()
    {
        if (ref_c.count() > 1)
        {
            --ref_c;
            ref_c = Ref_counter();
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    Ref_counter ref_c;
};

template<typename T>
Ptr_r<T> &Ptr_r<T>::operator=(const Ptr_r<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
    ref_c = rhs.ref_c;
    p = rhs.p;
    ++ref_c;
    return *this;
}

template<typename T>
Ptr_r<T>::~Ptr_r()
{
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
}

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

template<>
inline Vec<char> *clone< Vec<char> >(const Vec<char> *vp)
{
    return new Vec<char>(*vp);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() : data(new Vec<char>) { }
    Str(size_type n, char c) : data(new Vec<char>(n, c)) { }
    Str(const char *cp) : data(new Vec<char>)
    {
        copy(cp, cp + strlen(cp), back_inserter(*data));
    }
    template<class In>
    Str(In b, In e) : data(new Vec<char>(b, e)) { }

    size_type size() const
    {
        return data->size();
    }

    char &operator[](size_type i)
    {
        data.make_unique();
        return (*data)[i];
    }

    const char &operator[](size_type i) const
    {
        return (*data)[i];
    }

    Str &operator+=(const Str &s)
    {
        data.make_unique();
        copy(s.data->begin(), s.data->end(), back_inserter(*data));
        return *this;
    }

    iterator begin()
    {
        return data->begin();
    };
    const_iterator begin() const
    {
        return data->begin();
    };
    iterator end()
    {
        return data->end();
    };
    const_iterator end() const
    {
        return data->end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data->clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data->push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }

    friend ostream &operator<< (ostream &os, const Str &s)
    {
        for (Str::size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }

    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Ptr< Vec<char> > data;
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

class Core
{
public:
    friend class Student_info;
    friend class Audit;
    Core() : midterm(0), final(0)
    {
        cerr << "constructor Core()" << endl;
    }
    Core(istream &is)
    {
        cerr << "constructor Core(istream &is)" << endl;
        read(is);
    }

    virtual ~Core()
    {
        cerr << "destructor ~Core()" << endl;
    }

    const string &name() const
    {
        return _name;
    }
    virtual double grade() const
    {
        return ::grade(midterm, final, homework);
    }
    string letter_grade() const;
    virtual istream &read(istream &);

    bool valid() const
    {
        return !homework.empty();
    }
    virtual bool requirements_met() const
    {
        return find(homework.begin(), homework.end(), 0.0) == homework.end();
    }
    virtual Core *clone() const
    {
        return new Core(*this);
    }

protected:
    istream &read_common(istream &in)
    {
        in >> _name >> midterm >> final;
        return in;
    }
    double midterm, final;
    vector<double> homework;

private:
    string _name;
};

istream &Core::read(istream &in)
{
    read_common(in);
    read_hw(in, homework);
    return in;
}

string Core::letter_grade() const
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };

    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };

    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);

    double result = grade();

    for (size_t i = 0; i < ngrades; ++i)
    {
        if (result >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

inline bool compare(const Core &c1, const Core &c2)
{
    return c1.name() < c2.name();
}

inline bool compare_Core_ptrs(const Core *cp1, const Core *cp2)
{
    return compare(*cp1, *cp2);
}

class Grad : public Core
{
public:
    Grad() : thesis(0.0)
    {
        cerr << "constructor Grad()" << endl;
    }
    Grad(istream &is)
    {
        cerr << "constructor Grad(istream &is)" << endl;
        read(is);
    }

    ~Grad()
    {
        cerr << "destructor ~Grad()" << endl;
    }
    double grade() const;
    istream &read(istream &);

    bool requirements_met() const
    {
        return Core::requirements_met() && thesis != 0.0;
    }
    Grad *clone() const
    {
        return new Grad(*this);
    }

protected:

private:
    double thesis;
};

istream &Grad::read(istream &in)
{
    Core::read_common(in);
    in >> Grad::thesis;
    read_hw(in, Core::homework);
    return in;
}

double Grad::grade() const
{
    return min(Core::grade(), Grad::thesis);
}

class Credit : public Core
{
public:
    Credit() {}
    Credit(istream &is) : Core(is) {}

    double grade() const;
    bool passed() const
    {
        return grade() >= 60;
    }

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }
    Credit *clone() const
    {
        return new Credit(*this);
    }

protected:
};

double Credit::grade() const
{
    if (Core::homework.empty())
    {
        return (midterm + final) / 2.0;
    }
    else
    {
        return Core::grade();
    }
}

class Audit : public Core
{
public:
    Audit() {}
    Audit(istream &is)
    {
        read(is);
    }

    istream &read(istream &in)
    {
        in >> _name;
        return in;
    }

    double grade() const
    {
        return 0.0;
    };

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }
    Audit *clone() const
    {
        return new Audit(*this);
    }

protected:
};

class Student_info
{
public:
    Student_info() { }
    Student_info(istream &is)
    {
        read(is);
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Handle<Core> cp;
};

istream &Student_info::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

inline bool compare_info(const Student_info &s1, const Student_info &s2)
{
    return s1.name() < s2.name();
}

class Student_info_p
{
public:
    Student_info_p() { }
    Student_info_p(istream &is)
    {
        read(is);
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Ptr<Core> cp;
};

istream &Student_info_p::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

inline bool compare_info_p(const Student_info_p &s1, const Student_info_p &s2)
{
    return s1.name() < s2.name();
}

inline bool compare_Core_handles(const Handle<Core> hc1, const Handle<Core> hc2)
{
    return compare(*hc1, *hc2);
}

inline bool compare_Core_Ptr(const Ptr<Core> hc1, const Ptr<Core> hc2)
{
    return compare(*hc1, *hc2);
}

int main()
{
    vector<Student_info_p> students;
    Student_info_p record;
    string::size_type maxlen = 0;
    while (record.read(cin))
    {
        maxlen = max(maxlen, record.name().size());
        students.push_back(record);
    }
    sort(students.begin(), students.end(), compare_info_p);
    for (vector<Student_info_p>::size_type i = 0; i != students.size(); ++i)
    {
        cout << students[i].name() << string(maxlen + 1 - students[i].name().size(), ' ');
        try
        {
            double final_grade = students[i].grade();
            streamsize prec = cout.precision();
            cout << setprecision(3) << final_grade << setprecision(prec) << endl;
        }
        catch (domain_error &e1)
        {
            cout << e1.what() << endl;
        }
        catch (runtime_error &e2)
        {
            cout << e2.what() << endl;
        }
    }

    return 0;
}
显示结果如下
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
U
new Core
constructor Core(istream &is)
Geert 50 80 90 45 30 80 end
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
G
new Grad
constructor Core()
constructor Grad(istream &is)
Joris 80 90 62 60 70 60 70 60 end
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
C
new Credit
constructor Core(istream &is)
Pieter 40 50 30 40 50 50 40 end
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
A
new Audit
constructor Core()
Lotte
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
Geert  67
Joris  62
Lotte  0
Pieter 44
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Core()

14-4 使用Ptr类的最终版本重写Str类。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Handle
{
public:
    Handle() : p(nullptr) { }
    Handle(T *t) : p(t) { }
    Handle(const Handle<T> &s) : p(nullptr)
    {
        if (s.p != nullptr)
        {
            p = s.p->clone();
        }
    }

    Handle<T> &operator=(const Handle<T> &);
    ~Handle()
    {
        delete p;
    }

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const;
    T *operator->() const;

private:
    T *p;
};

template<typename T>
Handle<T> &Handle<T>::operator=(const Handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    delete p;
    p = rhs.p != nullptr ? rhs.p->clone() : nullptr;
    return *this;
}

template <typename T>
T &Handle<T>::operator*() const
{
    if (p != nullptr)
    {
        return *p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
T *Handle<T>::operator->() const
{
    if (p != nullptr)
    {
        return p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
class Ref_handle
{
public:
    Ref_handle() : refptr(new size_t(1)), p(nullptr) { }
    Ref_handle(T *t) : refptr(new size_t(1)), p(t) { }

    Ref_handle(const Ref_handle<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ref_handle<T> &operator=(const Ref_handle<T> &);

    ~Ref_handle();

    operator bool() const
    {
        return p != nullptr;
    }
    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ref_handle");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ref_handle");
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ref_handle<T> &Ref_handle<T>::operator=(const Ref_handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;

    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }

    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ref_handle<T>::~Ref_handle()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

class Ref_counter
{
public:
    Ref_counter() : counter(new size_t(1)) { };
    Ref_counter(size_t s) : counter(new size_t(s)) { };
    Ref_counter(const Ref_counter &r) : counter(r.counter) { };

    Ref_counter &operator=(const Ref_counter &rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        if (*counter <= 0)
        {
            delete counter;
        }
        counter = rhs.counter;
        return *this;
    };

    Ref_counter &operator++()
    {
        (*counter)++;
        return *this;
    };

    Ref_counter &operator--()
    {
        (*counter)--;
        return *this;
    };

    Ref_counter operator++(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)++;
        return ret;
    };

    Ref_counter operator--(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)--;
        return ret;
    };

    ~Ref_counter()
    {
        if (*counter <= 0)
        {
            delete counter;
        }
    };

    size_t count()
    {
        return *counter;
    };

private:
    size_t *counter;
};


template<typename T>
T *clone(const T *tp)
{
    return tp->clone();
}

template<typename T>
class Ptr
{
public:
    Ptr() : refptr(new size_t(1)), p(nullptr) { }
    Ptr(T *t) : refptr(new size_t(1)), p(t) { }
    Ptr(const Ptr<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ptr<T> &operator=(const Ptr<T> &);
    ~Ptr();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr");
    }

    void make_unique()
    {
        if (*refptr > 1)
        {
            --*refptr;
            refptr = new size_t(1);
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ptr<T> &Ptr<T>::operator=(const Ptr<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ptr<T>::~Ptr()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

template<typename T>
class Ptr_r
{
public:
    Ptr_r() : p(nullptr) { }
    Ptr_r(T *t) : p(t) { }
    Ptr_r(const Ptr_r<T> &h) : ref_c(h.ref_c), p(h.p)
    {
        ++ref_c;
    }

    Ptr_r<T> &operator=(const Ptr_r<T> &);
    ~Ptr_r();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    void make_unique()
    {
        if (ref_c.count() > 1)
        {
            --ref_c;
            ref_c = Ref_counter();
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    Ref_counter ref_c;
};

template<typename T>
Ptr_r<T> &Ptr_r<T>::operator=(const Ptr_r<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
    ref_c = rhs.ref_c;
    p = rhs.p;
    ++ref_c;
    return *this;
}

template<typename T>
Ptr_r<T>::~Ptr_r()
{
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
}

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

template<>
inline Vec<char> *clone< Vec<char> >(const Vec<char> *vp)
{
    return new Vec<char>(*vp);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() : data(new Vec<char>) { }
    Str(size_type n, char c) : data(new Vec<char>(n, c)) { }
    Str(const char *cp) : data(new Vec<char>)
    {
        copy(cp, cp + strlen(cp), back_inserter(*data));
    }
    template<class In>
    Str(In b, In e) : data(new Vec<char>(b, e)) { }

    size_type size() const
    {
        return data->size();
    }

    char &operator[](size_type i)
    {
        data.make_unique();
        return (*data)[i];
    }

    const char &operator[](size_type i) const
    {
        return (*data)[i];
    }

    Str &operator+=(const Str &s)
    {
        data.make_unique();
        copy(s.data->begin(), s.data->end(), back_inserter(*data));
        return *this;
    }

    iterator begin()
    {
        return data->begin();
    };
    const_iterator begin() const
    {
        return data->begin();
    };
    iterator end()
    {
        return data->end();
    };
    const_iterator end() const
    {
        return data->end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data->clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data->push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }

    friend ostream &operator<< (ostream &os, const Str &s)
    {
        for (Str::size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }

    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Ptr< Vec<char> > data;
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

class Core
{
public:
    friend class Student_info;
    friend class Audit;
    Core() : midterm(0), final(0)
    {
        cerr << "constructor Core()" << endl;
    }
    Core(istream &is)
    {
        cerr << "constructor Core(istream &is)" << endl;
        read(is);
    }

    virtual ~Core()
    {
        cerr << "destructor ~Core()" << endl;
    }

    const string &name() const
    {
        return _name;
    }
    virtual double grade() const
    {
        return ::grade(midterm, final, homework);
    }
    string letter_grade() const;
    virtual istream &read(istream &);

    bool valid() const
    {
        return !homework.empty();
    }
    virtual bool requirements_met() const
    {
        return find(homework.begin(), homework.end(), 0.0) == homework.end();
    }
    virtual Core *clone() const
    {
        return new Core(*this);
    }

protected:
    istream &read_common(istream &in)
    {
        in >> _name >> midterm >> final;
        return in;
    }
    double midterm, final;
    vector<double> homework;

private:
    string _name;
};

istream &Core::read(istream &in)
{
    read_common(in);
    read_hw(in, homework);
    return in;
}

string Core::letter_grade() const
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };

    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };

    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);

    double result = grade();

    for (size_t i = 0; i < ngrades; ++i)
    {
        if (result >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

inline bool compare(const Core &c1, const Core &c2)
{
    return c1.name() < c2.name();
}

inline bool compare_Core_ptrs(const Core *cp1, const Core *cp2)
{
    return compare(*cp1, *cp2);
}

class Grad : public Core
{
public:
    Grad() : thesis(0.0)
    {
        cerr << "constructor Grad()" << endl;
    }
    Grad(istream &is)
    {
        cerr << "constructor Grad(istream &is)" << endl;
        read(is);
    }

    ~Grad()
    {
        cerr << "destructor ~Grad()" << endl;
    }
    double grade() const;
    istream &read(istream &);

    bool requirements_met() const
    {
        return Core::requirements_met() && thesis != 0.0;
    }
    Grad *clone() const
    {
        return new Grad(*this);
    }

protected:

private:
    double thesis;
};

istream &Grad::read(istream &in)
{
    Core::read_common(in);
    in >> Grad::thesis;
    read_hw(in, Core::homework);
    return in;
}

double Grad::grade() const
{
    return min(Core::grade(), Grad::thesis);
}

class Credit : public Core
{
public:
    Credit() {}
    Credit(istream &is) : Core(is) {}

    double grade() const;
    bool passed() const
    {
        return grade() >= 60;
    }

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }
    Credit *clone() const
    {
        return new Credit(*this);
    }

protected:
};

double Credit::grade() const
{
    if (Core::homework.empty())
    {
        return (midterm + final) / 2.0;
    }
    else
    {
        return Core::grade();
    }
}

class Audit : public Core
{
public:
    Audit() {}
    Audit(istream &is)
    {
        read(is);
    }

    istream &read(istream &in)
    {
        in >> _name;
        return in;
    }

    double grade() const
    {
        return 0.0;
    };

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }
    Audit *clone() const
    {
        return new Audit(*this);
    }

protected:
};

class Student_info
{
public:
    Student_info() { }
    Student_info(istream &is)
    {
        read(is);
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Handle<Core> cp;
};

istream &Student_info::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

inline bool compare_info(const Student_info &s1, const Student_info &s2)
{
    return s1.name() < s2.name();
}

class Student_info_p
{
public:
    Student_info_p() { }
    Student_info_p(istream &is)
    {
        read(is);
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Ptr<Core> cp;
};

istream &Student_info_p::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

inline bool compare_info_p(const Student_info_p &s1, const Student_info_p &s2)
{
    return s1.name() < s2.name();
}

inline bool compare_Core_handles(const Handle<Core> hc1, const Handle<Core> hc2)
{
    return compare(*hc1, *hc2);
}

inline bool compare_Core_Ptr(const Ptr<Core> hc1, const Ptr<Core> hc2)
{
    return compare(*hc1, *hc2);
}

int main()
{
    Str s1 = "Hello ";
    Str s2;
    cout << "Please enter your name: ";
    cin >> s2;
    Str s3 = s1 + s2 + " how are you?";
    cout << s3 << endl;

    return 0;
}
显示结果如下
Please enter your name: Mike Pence
Hello Mike how are you?

14-5 通过编译重写后的Str类并运行使用了Str的程序（例如split函数和使用了Vec<Str类的图形操作函数）检验这个类的正确性。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Handle
{
public:
    Handle() : p(nullptr) { }
    Handle(T *t) : p(t) { }
    Handle(const Handle<T> &s) : p(nullptr)
    {
        if (s.p != nullptr)
        {
            p = s.p->clone();
        }
    }

    Handle<T> &operator=(const Handle<T> &);
    ~Handle()
    {
        delete p;
    }

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const;
    T *operator->() const;

private:
    T *p;
};

template<typename T>
Handle<T> &Handle<T>::operator=(const Handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    delete p;
    p = rhs.p != nullptr ? rhs.p->clone() : nullptr;
    return *this;
}

template <typename T>
T &Handle<T>::operator*() const
{
    if (p != nullptr)
    {
        return *p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
T *Handle<T>::operator->() const
{
    if (p != nullptr)
    {
        return p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
class Ref_handle
{
public:
    Ref_handle() : refptr(new size_t(1)), p(nullptr) { }
    Ref_handle(T *t) : refptr(new size_t(1)), p(t) { }

    Ref_handle(const Ref_handle<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ref_handle<T> &operator=(const Ref_handle<T> &);

    ~Ref_handle();

    operator bool() const
    {
        return p != nullptr;
    }
    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ref_handle");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ref_handle");
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ref_handle<T> &Ref_handle<T>::operator=(const Ref_handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;

    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }

    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ref_handle<T>::~Ref_handle()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

class Ref_counter
{
public:
    Ref_counter() : counter(new size_t(1)) { };
    Ref_counter(size_t s) : counter(new size_t(s)) { };
    Ref_counter(const Ref_counter &r) : counter(r.counter) { };

    Ref_counter &operator=(const Ref_counter &rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        if (*counter <= 0)
        {
            delete counter;
        }
        counter = rhs.counter;
        return *this;
    };

    Ref_counter &operator++()
    {
        (*counter)++;
        return *this;
    };

    Ref_counter &operator--()
    {
        (*counter)--;
        return *this;
    };

    Ref_counter operator++(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)++;
        return ret;
    };

    Ref_counter operator--(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)--;
        return ret;
    };

    ~Ref_counter()
    {
        if (*counter <= 0)
        {
            delete counter;
        }
    };

    size_t count()
    {
        return *counter;
    };

private:
    size_t *counter;
};


template<typename T>
T *clone(const T *tp)
{
    return tp->clone();
}

template<typename T>
class Ptr
{
public:
    Ptr() : refptr(new size_t(1)), p(nullptr) { }
    Ptr(T *t) : refptr(new size_t(1)), p(t) { }
    Ptr(const Ptr<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ptr<T> &operator=(const Ptr<T> &);
    ~Ptr();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr");
    }

    void make_unique()
    {
        if (*refptr > 1)
        {
            --*refptr;
            refptr = new size_t(1);
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ptr<T> &Ptr<T>::operator=(const Ptr<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ptr<T>::~Ptr()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

template<typename T>
class Ptr_r
{
public:
    Ptr_r() : p(nullptr) { }
    Ptr_r(T *t) : p(t) { }
    Ptr_r(const Ptr_r<T> &h) : ref_c(h.ref_c), p(h.p)
    {
        ++ref_c;
    }

    Ptr_r<T> &operator=(const Ptr_r<T> &);
    ~Ptr_r();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    void make_unique()
    {
        if (ref_c.count() > 1)
        {
            --ref_c;
            ref_c = Ref_counter();
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    Ref_counter ref_c;
};

template<typename T>
Ptr_r<T> &Ptr_r<T>::operator=(const Ptr_r<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
    ref_c = rhs.ref_c;
    p = rhs.p;
    ++ref_c;
    return *this;
}

template<typename T>
Ptr_r<T>::~Ptr_r()
{
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
}

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

template<>
inline Vec<char> *clone< Vec<char> >(const Vec<char> *vp)
{
    return new Vec<char>(*vp);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() : data(new Vec<char>) { }
    Str(size_type n, char c) : data(new Vec<char>(n, c)) { }
    Str(const char *cp) : data(new Vec<char>)
    {
        copy(cp, cp + strlen(cp), back_inserter(*data));
    }
    template<class In>
    Str(In b, In e) : data(new Vec<char>(b, e)) { }

    size_type size() const
    {
        return data->size();
    }

    char &operator[](size_type i)
    {
        data.make_unique();
        return (*data)[i];
    }

    const char &operator[](size_type i) const
    {
        return (*data)[i];
    }

    Str &operator+=(const Str &s)
    {
        data.make_unique();
        copy(s.data->begin(), s.data->end(), back_inserter(*data));
        return *this;
    }

    iterator begin()
    {
        return data->begin();
    };
    const_iterator begin() const
    {
        return data->begin();
    };
    iterator end()
    {
        return data->end();
    };
    const_iterator end() const
    {
        return data->end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data->clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data->push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }

    friend ostream &operator<< (ostream &os, const Str &s)
    {
        for (Str::size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }

    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Ptr< Vec<char> > data;
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

class Core
{
public:
    friend class Student_info;
    friend class Audit;
    Core() : midterm(0), final(0)
    {
        cerr << "constructor Core()" << endl;
    }
    Core(istream &is)
    {
        cerr << "constructor Core(istream &is)" << endl;
        read(is);
    }

    virtual ~Core()
    {
        cerr << "destructor ~Core()" << endl;
    }

    const string &name() const
    {
        return _name;
    }
    virtual double grade() const
    {
        return ::grade(midterm, final, homework);
    }
    string letter_grade() const;
    virtual istream &read(istream &);

    bool valid() const
    {
        return !homework.empty();
    }
    virtual bool requirements_met() const
    {
        return find(homework.begin(), homework.end(), 0.0) == homework.end();
    }
    virtual Core *clone() const
    {
        return new Core(*this);
    }

protected:
    istream &read_common(istream &in)
    {
        in >> _name >> midterm >> final;
        return in;
    }
    double midterm, final;
    vector<double> homework;

private:
    string _name;
};

istream &Core::read(istream &in)
{
    read_common(in);
    read_hw(in, homework);
    return in;
}

string Core::letter_grade() const
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };

    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };

    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);

    double result = grade();

    for (size_t i = 0; i < ngrades; ++i)
    {
        if (result >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

inline bool compare(const Core &c1, const Core &c2)
{
    return c1.name() < c2.name();
}

inline bool compare_Core_ptrs(const Core *cp1, const Core *cp2)
{
    return compare(*cp1, *cp2);
}

class Grad : public Core
{
public:
    Grad() : thesis(0.0)
    {
        cerr << "constructor Grad()" << endl;
    }
    Grad(istream &is)
    {
        cerr << "constructor Grad(istream &is)" << endl;
        read(is);
    }

    ~Grad()
    {
        cerr << "destructor ~Grad()" << endl;
    }
    double grade() const;
    istream &read(istream &);

    bool requirements_met() const
    {
        return Core::requirements_met() && thesis != 0.0;
    }
    Grad *clone() const
    {
        return new Grad(*this);
    }

protected:

private:
    double thesis;
};

istream &Grad::read(istream &in)
{
    Core::read_common(in);
    in >> Grad::thesis;
    read_hw(in, Core::homework);
    return in;
}

double Grad::grade() const
{
    return min(Core::grade(), Grad::thesis);
}

class Credit : public Core
{
public:
    Credit() {}
    Credit(istream &is) : Core(is) {}

    double grade() const;
    bool passed() const
    {
        return grade() >= 60;
    }

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }
    Credit *clone() const
    {
        return new Credit(*this);
    }

protected:
};

double Credit::grade() const
{
    if (Core::homework.empty())
    {
        return (midterm + final) / 2.0;
    }
    else
    {
        return Core::grade();
    }
}

class Audit : public Core
{
public:
    Audit() {}
    Audit(istream &is)
    {
        read(is);
    }

    istream &read(istream &in)
    {
        in >> _name;
        return in;
    }

    double grade() const
    {
        return 0.0;
    };

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }
    Audit *clone() const
    {
        return new Audit(*this);
    }

protected:
};

class Student_info
{
public:
    Student_info() { }
    Student_info(istream &is)
    {
        read(is);
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Handle<Core> cp;
};

istream &Student_info::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

inline bool compare_info(const Student_info &s1, const Student_info &s2)
{
    return s1.name() < s2.name();
}

class Student_info_p
{
public:
    Student_info_p() { }
    Student_info_p(istream &is)
    {
        read(is);
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Ptr<Core> cp;
};

istream &Student_info_p::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

inline bool compare_info_p(const Student_info_p &s1, const Student_info_p &s2)
{
    return s1.name() < s2.name();
}

inline bool compare_Core_handles(const Handle<Core> hc1, const Handle<Core> hc2)
{
    return compare(*hc1, *hc2);
}

inline bool compare_Core_Ptr(const Ptr<Core> hc1, const Ptr<Core> hc2)
{
    return compare(*hc1, *hc2);
}

Str::size_type width(const vector<Str> &v)
{
    Str::size_type maxlen = 0;

    for (vector<Str>::size_type i = 0; i != v.size(); ++i)
    {
        maxlen = max(maxlen, v[i].size());
    }

    return maxlen;
}

vector<Str> frame(const vector<Str> &v)
{
    vector<Str> ret;
    Str::size_type maxlen = width(v);
    Str border(maxlen + 4, '*');

    ret.push_back(border);

    for (vector<Str>::size_type i = 0; i != v.size(); ++i)
    {
        ret.push_back("* " + v[i] + Str(maxlen - v[i].size(), ' ') + " *");
    }

    ret.push_back(border);

    return ret;
}

vector<Str> vcat(const vector<Str> &top, const vector<Str> &bottom)
{
    vector<Str> ret = top;

    ret.insert(ret.end(), bottom.begin(), bottom.end());

    return ret;
}

vector<Str> hcat(const vector<Str> &left, const vector<Str> &right)
{
    vector<Str> ret;

    Str::size_type width1 = width(left) + 1;

    vector<Str>::size_type i = 0, j = 0;

    while (i != left.size() || j != right.size())
    {
        Str s;

        if (i != left.size())
        {
            s = left[i++];
        }

        s += Str(width1 - s.size(), ' ');

        if (j != right.size())
        {
            s += right[j++];
        }

        ret.push_back(s);
    }

    return ret;
}

vector<Str> center(const vector<Str> &v)
{
    vector<Str> v_out;
    vector<Str>::size_type maxlen = width(v);
    vector<Str>::const_iterator iter = v.begin();

    while (iter != v.end())
    {
        int spaces_l = (maxlen - iter->size()) / 2;
        int spaces_r = maxlen - iter->size() - spaces_l;

        if (spaces_l != 0)
        {
            v_out.push_back(Str(spaces_l, ' ') + *iter++ + Str(spaces_r, ' '));
        }
        else
        {
            v_out.push_back(*iter++);
        }
    }

    return v_out;
}

vector<Str> split(const Str &s)
{
    vector<Str> ret;
    typedef Str::size_type Str_size;
    Str_size i = 0;

    while (i != s.size())
    {
        while (i != s.size() && isspace(s[i]))
        {
            ++i;
        }

        Str_size j = i;

        while (j != s.size() && !isspace(s[j]))
        {
            ++j;
        }

        if (i != j)
        {
            ret.push_back(Str(s.begin() + i, s.begin() + j));
            i = j;
        }
    }
    return ret;
}

bool space(char c)
{
    return isspace(c) != 0;
}

bool not_space(char c)
{
    return !isspace(c);
}

vector<Str> split_alt(const Str &str)
{
    typedef Str::const_iterator iter;
    vector<Str> ret;

    iter i = str.begin();
    while (i != str.end())
    {
        i = find_if(i, str.end(), not_space);

        iter j = find_if(i, str.end(), space);

        if (i != j)
        {
            ret.push_back(Str(i, j));
            i = j;
        }
    }
    return ret;
}

int test_frame()
{
    vector<Str> v1 = { "one test", "two test", "aye caramba" };
    vector<Str> v2 = { "one direction", "mama mia", "mamo testo", "lake district mall" };

    vector<Str> vert = vcat(frame(v1), frame(v2));

    vector<Str>::const_iterator iter = vert.begin();

    while (iter != vert.end())
    {
        cout << *iter++ << endl;
    }

    vector<Str> horz = hcat(frame(v1), frame(v2));

    iter = horz.begin();

    while (iter != horz.end())
    {
        cout << *iter++ << endl;
    }

    return 0;
}

int test_center()
{
    vector<Str> v = { "This is really great", "really", "super awesome", "awesomesauce" };
    vector<Str> centered_v = center(v);

    vector<Str>::const_iterator iter = centered_v.begin();

    while (iter != centered_v.end())
    {
        cout << *iter++ << endl;
    }

    return 0;
}

int test_string_split()
{
    Str s = "Split this string!";

    vector<Str> v = split(s);

    for (vector<Str>::size_type i = 0; i != v.size(); ++i)
    {
        cout << v[i] << endl;
    }

    return 0;
}

int test_string_split_alt()
{
    Str s = "And this one too!";

    vector<Str> v = split_alt(s);

    for (vector<Str>::size_type i = 0; i != v.size(); ++i)
    {
        cout << v[i] << endl;
    }

    return 0;
}

int main()
{
    test_frame();
    cout << endl;
    test_center();
    cout << endl;
    test_string_split();
    cout << endl;
    test_string_split_alt();
    cout << endl;

    return 0;
}
显示结果如下
***************
* one test    *
* two test    *
* aye caramba *
***************
**********************
* one direction      *
* mama mia           *
* mamo testo         *
* lake district mall *
**********************
*************** **********************
* one test    * * one direction      *
* two test    * * mama mia           *
* aye caramba * * mamo testo         *
*************** * lake district mall *
                **********************

This is really great
       really
   super awesome
    awesomesauce

Split
this
string!

And
this
one
too!

14-6 Ptr类实际上解决了两个问题：保留了引用计数，为对象分配内存和释放内存。请定义一个只负责引用计数的类；然后用该类重新实现Ptr类。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Handle
{
public:
    Handle() : p(nullptr) { }
    Handle(T *t) : p(t) { }
    Handle(const Handle<T> &s) : p(nullptr)
    {
        if (s.p != nullptr)
        {
            p = s.p->clone();
        }
    }

    Handle<T> &operator=(const Handle<T> &);
    ~Handle()
    {
        delete p;
    }

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const;
    T *operator->() const;

private:
    T *p;
};

template<typename T>
Handle<T> &Handle<T>::operator=(const Handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    delete p;
    p = rhs.p != nullptr ? rhs.p->clone() : nullptr;
    return *this;
}

template <typename T>
T &Handle<T>::operator*() const
{
    if (p != nullptr)
    {
        return *p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
T *Handle<T>::operator->() const
{
    if (p != nullptr)
    {
        return p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
class Ref_handle
{
public:
    Ref_handle() : refptr(new size_t(1)), p(nullptr) { }
    Ref_handle(T *t) : refptr(new size_t(1)), p(t) { }

    Ref_handle(const Ref_handle<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ref_handle<T> &operator=(const Ref_handle<T> &);

    ~Ref_handle();

    operator bool() const
    {
        return p != nullptr;
    }
    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ref_handle");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ref_handle");
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ref_handle<T> &Ref_handle<T>::operator=(const Ref_handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;

    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }

    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ref_handle<T>::~Ref_handle()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

class Ref_counter
{
public:
    Ref_counter() : counter(new size_t(1)) { };
    Ref_counter(size_t s) : counter(new size_t(s)) { };
    Ref_counter(const Ref_counter &r) : counter(r.counter) { };

    Ref_counter &operator=(const Ref_counter &rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        if (*counter <= 0)
        {
            delete counter;
        }
        counter = rhs.counter;
        return *this;
    };

    Ref_counter &operator++()
    {
        (*counter)++;
        return *this;
    };

    Ref_counter &operator--()
    {
        (*counter)--;
        return *this;
    };

    Ref_counter operator++(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)++;
        return ret;
    };

    Ref_counter operator--(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)--;
        return ret;
    };

    ~Ref_counter()
    {
        if (*counter <= 0)
        {
            delete counter;
        }
    };

    size_t count()
    {
        return *counter;
    };

private:
    size_t *counter;
};


template<typename T>
T *clone(const T *tp)
{
    return tp->clone();
}

template<typename T>
class Ptr
{
public:
    Ptr() : refptr(new size_t(1)), p(nullptr) { }
    Ptr(T *t) : refptr(new size_t(1)), p(t) { }
    Ptr(const Ptr<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ptr<T> &operator=(const Ptr<T> &);
    ~Ptr();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr");
    }

    void make_unique()
    {
        if (*refptr > 1)
        {
            --*refptr;
            refptr = new size_t(1);
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ptr<T> &Ptr<T>::operator=(const Ptr<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ptr<T>::~Ptr()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

template<typename T>
class Ptr_r
{
public:
    Ptr_r() : p(nullptr) { }
    Ptr_r(T *t) : p(t) { }
    Ptr_r(const Ptr_r<T> &h) : ref_c(h.ref_c), p(h.p)
    {
        ++ref_c;
    }

    Ptr_r<T> &operator=(const Ptr_r<T> &);
    ~Ptr_r();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    void make_unique()
    {
        if (ref_c.count() > 1)
        {
            --ref_c;
            ref_c = Ref_counter();
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    Ref_counter ref_c;
};

template<typename T>
Ptr_r<T> &Ptr_r<T>::operator=(const Ptr_r<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
    ref_c = rhs.ref_c;
    p = rhs.p;
    ++ref_c;
    return *this;
}

template<typename T>
Ptr_r<T>::~Ptr_r()
{
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
}

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

template<>
inline Vec<char> *clone< Vec<char> >(const Vec<char> *vp)
{
    return new Vec<char>(*vp);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() : data(new Vec<char>) { }
    Str(size_type n, char c) : data(new Vec<char>(n, c)) { }
    Str(const char *cp) : data(new Vec<char>)
    {
        copy(cp, cp + strlen(cp), back_inserter(*data));
    }
    template<class In>
    Str(In b, In e) : data(new Vec<char>(b, e)) { }

    size_type size() const
    {
        return data->size();
    }

    char &operator[](size_type i)
    {
        data.make_unique();
        return (*data)[i];
    }

    const char &operator[](size_type i) const
    {
        return (*data)[i];
    }

    Str &operator+=(const Str &s)
    {
        data.make_unique();
        copy(s.data->begin(), s.data->end(), back_inserter(*data));
        return *this;
    }

    iterator begin()
    {
        return data->begin();
    };
    const_iterator begin() const
    {
        return data->begin();
    };
    iterator end()
    {
        return data->end();
    };
    const_iterator end() const
    {
        return data->end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data->clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data->push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }

    friend ostream &operator<< (ostream &os, const Str &s)
    {
        for (Str::size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }

    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Ptr< Vec<char> > data;
};

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

class Core
{
public:
    friend class Student_info;
    friend class Audit;
    Core() : midterm(0), final(0)
    {
        cerr << "constructor Core()" << endl;
    }
    Core(istream &is)
    {
        cerr << "constructor Core(istream &is)" << endl;
        read(is);
    }

    virtual ~Core()
    {
        cerr << "destructor ~Core()" << endl;
    }

    const string &name() const
    {
        return _name;
    }
    virtual double grade() const
    {
        return ::grade(midterm, final, homework);
    }
    string letter_grade() const;
    virtual istream &read(istream &);

    bool valid() const
    {
        return !homework.empty();
    }
    virtual bool requirements_met() const
    {
        return find(homework.begin(), homework.end(), 0.0) == homework.end();
    }
    virtual Core *clone() const
    {
        return new Core(*this);
    }

protected:
    istream &read_common(istream &in)
    {
        in >> _name >> midterm >> final;
        return in;
    }
    double midterm, final;
    vector<double> homework;

private:
    string _name;
};

istream &Core::read(istream &in)
{
    read_common(in);
    read_hw(in, homework);
    return in;
}

string Core::letter_grade() const
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };

    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };

    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);

    double result = grade();

    for (size_t i = 0; i < ngrades; ++i)
    {
        if (result >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

inline bool compare(const Core &c1, const Core &c2)
{
    return c1.name() < c2.name();
}

inline bool compare_Core_ptrs(const Core *cp1, const Core *cp2)
{
    return compare(*cp1, *cp2);
}

class Grad : public Core
{
public:
    Grad() : thesis(0.0)
    {
        cerr << "constructor Grad()" << endl;
    }
    Grad(istream &is)
    {
        cerr << "constructor Grad(istream &is)" << endl;
        read(is);
    }

    ~Grad()
    {
        cerr << "destructor ~Grad()" << endl;
    }
    double grade() const;
    istream &read(istream &);

    bool requirements_met() const
    {
        return Core::requirements_met() && thesis != 0.0;
    }
    Grad *clone() const
    {
        return new Grad(*this);
    }

protected:

private:
    double thesis;
};

istream &Grad::read(istream &in)
{
    Core::read_common(in);
    in >> Grad::thesis;
    read_hw(in, Core::homework);
    return in;
}

double Grad::grade() const
{
    return min(Core::grade(), Grad::thesis);
}

class Credit : public Core
{
public:
    Credit() {}
    Credit(istream &is) : Core(is) {}

    double grade() const;
    bool passed() const
    {
        return grade() >= 60;
    }

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }
    Credit *clone() const
    {
        return new Credit(*this);
    }

protected:
};

double Credit::grade() const
{
    if (Core::homework.empty())
    {
        return (midterm + final) / 2.0;
    }
    else
    {
        return Core::grade();
    }
}

class Audit : public Core
{
public:
    Audit() {}
    Audit(istream &is)
    {
        read(is);
    }

    istream &read(istream &in)
    {
        in >> _name;
        return in;
    }

    double grade() const
    {
        return 0.0;
    };

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }
    Audit *clone() const
    {
        return new Audit(*this);
    }

protected:
};

class Student_info
{
public:
    Student_info() { }
    Student_info(istream &is)
    {
        read(is);
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Handle<Core> cp;
};

istream &Student_info::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

inline bool compare_info(const Student_info &s1, const Student_info &s2)
{
    return s1.name() < s2.name();
}

class Student_info_p
{
public:
    Student_info_p() { }
    Student_info_p(istream &is)
    {
        read(is);
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Ptr<Core> cp;
};

istream &Student_info_p::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

inline bool compare_info_p(const Student_info_p &s1, const Student_info_p &s2)
{
    return s1.name() < s2.name();
}

inline bool compare_Core_handles(const Handle<Core> hc1, const Handle<Core> hc2)
{
    return compare(*hc1, *hc2);
}

inline bool compare_Core_Ptr(const Ptr<Core> hc1, const Ptr<Core> hc2)
{
    return compare(*hc1, *hc2);
}

inline bool compare_Core_Ptr_r(const Ptr_r<Core> hc1, const Ptr_r<Core> hc2)
{
    return compare(*hc1, *hc2);
}

int main()
{
    vector< Ptr_r<Core> > students;
    Ptr_r<Core> record;
    char ch;
    string::size_type maxlen = 0;
    while (cin >> ch && ch != 'Q')
    {
        if (ch == 'U')
        {
            record = new Core;
        }
        else
        {
            record = new Grad;
        }
        record->read(cin);
        maxlen = max(maxlen, record->name().size());
        students.push_back(record);
    }
    sort(students.begin(), students.end(), compare_Core_Ptr_r);
    for (vector< Ptr_r<Core> >::size_type i = 0; i != students.size(); ++i)
    {
        cout << students[i]->name() << string(maxlen + 1 - students[i]->name().size(), ' ');
        try
        {
            double final_grade = students[i]->grade();
            streamsize prec = cout.precision();
            cout << setprecision(3) << final_grade << setprecision(prec) << endl;
        }
        catch (domain_error &e1)
        {
            cout << e1.what() << endl;
        }
        catch (runtime_error &e2)
        {
            cout << e2.what() << endl;
        }
    }

    return 0;
}
显示结果如下
U
constructor Core()
Geert 50 80 90 45 30 80 end
G
constructor Core()
constructor Grad()
Joris 80 90 62 60 70 60 70 60 end
U
constructor Core()
Pieter 40 50 30 40 50 50 40 end
G
constructor Core()
constructor Grad()
Lotte 40 80 62 90 45 60 70 end
Q
Geert  67
Joris  62
Lotte  62
Pieter 44
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()

第15章再探字符图形
15.1 设计
15.2 实现
15.3 小结
习题
15-0编译、运行并测试本章举的例程。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Handle
{
public:
    Handle() : p(nullptr) { }
    Handle(T *t) : p(t) { }
    Handle(const Handle<T> &s) : p(nullptr)
    {
        if (s.p != nullptr)
        {
            p = s.p->clone();
        }
    }

    Handle<T> &operator=(const Handle<T> &);
    ~Handle()
    {
        delete p;
    }

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const;
    T *operator->() const;

private:
    T *p;
};

template<typename T>
Handle<T> &Handle<T>::operator=(const Handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    delete p;
    p = rhs.p != nullptr ? rhs.p->clone() : nullptr;
    return *this;
}

template <typename T>
T &Handle<T>::operator*() const
{
    if (p != nullptr)
    {
        return *p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
T *Handle<T>::operator->() const
{
    if (p != nullptr)
    {
        return p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
class Ref_handle
{
public:
    Ref_handle() : refptr(new size_t(1)), p(nullptr) { }
    Ref_handle(T *t) : refptr(new size_t(1)), p(t) { }

    Ref_handle(const Ref_handle<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ref_handle<T> &operator=(const Ref_handle<T> &);

    ~Ref_handle();

    operator bool() const
    {
        return p != nullptr;
    }
    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ref_handle");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ref_handle");
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ref_handle<T> &Ref_handle<T>::operator=(const Ref_handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;

    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }

    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ref_handle<T>::~Ref_handle()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

class Ref_counter
{
public:
    Ref_counter() : counter(new size_t(1)) { };
    Ref_counter(size_t s) : counter(new size_t(s)) { };
    Ref_counter(const Ref_counter &r) : counter(r.counter) { };

    Ref_counter &operator=(const Ref_counter &rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        if (*counter <= 0)
        {
            delete counter;
        }
        counter = rhs.counter;
        return *this;
    };

    Ref_counter &operator++()
    {
        (*counter)++;
        return *this;
    };

    Ref_counter &operator--()
    {
        (*counter)--;
        return *this;
    };

    Ref_counter operator++(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)++;
        return ret;
    };

    Ref_counter operator--(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)--;
        return ret;
    };

    ~Ref_counter()
    {
        if (*counter <= 0)
        {
            delete counter;
        }
    };

    size_t count()
    {
        return *counter;
    };

private:
    size_t *counter;
};


template<typename T>
T *clone(const T *tp)
{
    return tp->clone();
}

template<typename T>
class Ptr
{
public:
    Ptr() : refptr(new size_t(1)), p(nullptr) { }
    Ptr(T *t) : refptr(new size_t(1)), p(t) { }
    Ptr(const Ptr<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ptr<T> &operator=(const Ptr<T> &);
    ~Ptr();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr");
    }

    void make_unique()
    {
        if (*refptr > 1)
        {
            --*refptr;
            refptr = new size_t(1);
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ptr<T> &Ptr<T>::operator=(const Ptr<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ptr<T>::~Ptr()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

template<typename T>
class Ptr_r
{
public:
    Ptr_r() : p(nullptr) { }
    Ptr_r(T *t) : p(t) { }
    Ptr_r(const Ptr_r<T> &h) : ref_c(h.ref_c), p(h.p)
    {
        ++ref_c;
    }

    Ptr_r<T> &operator=(const Ptr_r<T> &);
    ~Ptr_r();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    void make_unique()
    {
        if (ref_c.count() > 1)
        {
            --ref_c;
            ref_c = Ref_counter();
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    Ref_counter ref_c;
};

template<typename T>
Ptr_r<T> &Ptr_r<T>::operator=(const Ptr_r<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
    ref_c = rhs.ref_c;
    p = rhs.p;
    ++ref_c;
    return *this;
}

template<typename T>
Ptr_r<T>::~Ptr_r()
{
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
}

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

template<>
inline Vec<char> *clone< Vec<char> >(const Vec<char> *vp)
{
    return new Vec<char>(*vp);
}

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() : data(new Vec<char>) { }
    Str(size_type n, char c) : data(new Vec<char>(n, c)) { }
    Str(const char *cp) : data(new Vec<char>)
    {
        copy(cp, cp + strlen(cp), back_inserter(*data));
    }
    template<class In>
    Str(In b, In e) : data(new Vec<char>(b, e)) { }

    size_type size() const
    {
        return data->size();
    }

    char &operator[](size_type i)
    {
        data.make_unique();
        return (*data)[i];
    }

    const char &operator[](size_type i) const
    {
        return (*data)[i];
    }

    Str &operator+=(const Str &s)
    {
        data.make_unique();
        copy(s.data->begin(), s.data->end(), back_inserter(*data));
        return *this;
    }

    iterator begin()
    {
        return data->begin();
    };
    const_iterator begin() const
    {
        return data->begin();
    };
    iterator end()
    {
        return data->end();
    };
    const_iterator end() const
    {
        return data->end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data->clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data->push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }

    friend ostream &operator<< (ostream &os, const Str &s)
    {
        for (Str::size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }

    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Ptr< Vec<char> > data;
};

class Picture;

class Pic_base
{
    friend class Frame_Pic;
    friend class HCat_Pic;
    friend class VCat_Pic;
    friend class String_Pic;
    friend class Picture;
    friend ostream &operator<<(ostream &, const Picture &);

    typedef vector<string>::size_type ht_sz;
    typedef string::size_type wd_sz;

    virtual wd_sz width() const = 0;
    virtual ht_sz height() const = 0;
    virtual void display(ostream &, ht_sz, bool) const = 0;

protected:
    static void pad(ostream &os, wd_sz beg, wd_sz end);
};

class Frame_Pic : public Pic_base
{
    friend Picture frame(const Picture &);
    friend Picture frame(const Picture &, const char, const char, const char);

    Ptr<Pic_base> p;
    char corner;
    char top_bottom;
    char side;

    Frame_Pic(const Ptr<Pic_base> &pic, const char corner_val = '+',
              const char top_bottom_val = '-', const char side_val = '|')
        : p(pic), corner(corner_val), top_bottom(top_bottom_val), side(side_val) { }

    wd_sz width() const
    {
        return p->width() + 4;
    }
    ht_sz height() const
    {
        return p->height() + 4;
    }

    void display(ostream &, ht_sz, bool) const;
};

class VCat_Pic : public Pic_base
{
    friend Picture vcat(const Picture &, const Picture &);

    Ptr<Pic_base> top, bottom;

    VCat_Pic(const Ptr<Pic_base> &t, const Ptr<Pic_base> &b) : top(t), bottom(b) { }

    wd_sz width() const
    {
        return max(top->width(), bottom->width());
    }

    ht_sz height() const
    {
        return top->height() + bottom->height();
    }

    void display(ostream &, ht_sz, bool) const;
};

class HCat_Pic : public Pic_base
{
    friend Picture hcat(const Picture &, const Picture &);

    Ptr<Pic_base> left, right;

    HCat_Pic(const Ptr<Pic_base> &l, const Ptr<Pic_base> &r) : left(l), right(r) { }

    wd_sz width() const
    {
        return left->width() + right->width();
    }

    ht_sz height() const
    {
        return max(left->height(), right->height());
    }

    void display(ostream &, ht_sz, bool) const;
};

class String_Pic : public Pic_base
{
    friend class Picture;

    vector<string> data;
    String_Pic(const vector<string> &v) : data(v) { }

    wd_sz width() const;
    ht_sz height() const
    {
        return data.size();
    };
    void display(ostream &, ht_sz, bool) const;
};

class Picture
{
    friend Picture frame(const Picture &);
    friend Picture frame(const Picture &, const char, const char, const char);
    friend Picture hcat(const Picture &, const Picture &);
    friend Picture vcat(const Picture &, const Picture &);
    friend ostream &operator<<(ostream &, const Picture &);

public:
    Picture(const vector<string> & = vector<string>());

private:
    Ptr<Pic_base> p;

    Picture(Pic_base *ptr) : p(ptr) { }
};

Picture frame(const Picture &pic)
{
    return new Frame_Pic(pic.p);
}

Picture frame(const Picture &pic, const char corner_val, const char top_bottom_val, const char side_val)
{
    return new Frame_Pic(pic.p, corner_val, top_bottom_val, side_val);
}

Picture hcat(const Picture &l, const Picture &r)
{
    return new HCat_Pic(l.p, r.p);
}

Picture vcat(const Picture &t, const Picture &b)
{
    return new VCat_Pic(t.p, b.p);
}

Picture::Picture(const vector<string> &v) : p(new String_Pic(v)) { }

ostream &operator<<(ostream &os, const Picture &picture)
{
    const Pic_base::ht_sz ht = picture.p->height();
    for (Pic_base::ht_sz i = 0; i != ht; ++i)
    {
        picture.p->display(os, i, false);
        os << endl;
    }
    return os;
};

Pic_base::wd_sz String_Pic::width() const
{
    Pic_base::wd_sz n = 0;
    for (Pic_base::ht_sz i = 0; i != data.size(); ++i)
    {
        n = max(n, data[i].size());
    }
    return n;
}

void String_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz start = 0;
    if (row < height())
    {
        os << data[row];
        start = data[row].size();
    }
    if (do_pad)
    {
        pad(os, start, width());
    }
}

void VCat_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz w = 0;
    if (row < top->height())
    {
        top->display(os, row, do_pad);
        w = top->width();
    }
    else if (row < height())
    {
        bottom->display(os, row - top->height(), do_pad);
        w = bottom->width();
    }
    if (do_pad)
    {
        pad(os, w, width());
    }
}

void HCat_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    ht_sz left_row = row;
    ht_sz right_row = row;

    if (left->height() > right->height())
    {
        ht_sz index = ((left->height() - right->height()) / 2);

        if (row >= index)
        {
            right_row = row - index;
        }
        else
        {
            right_row = right->height();
        }
    }
    else
    {
        ht_sz index = ((right->height() - left->height()) / 2);

        if (row >= index)
        {
            left_row = row - index;
        }
        else
        {
            left_row = left->height();
        }
    }

    left->display(os, left_row, do_pad || right_row < right->height());
    right->display(os, right_row, do_pad);
}

void Frame_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    if (row >= height())
    {
        if (do_pad)
        {
            pad(os, 0, width());
        }
    }
    else
    {
        if (row == 0 || row == height() - 1)
        {
            os << corner << string(width() - 2, top_bottom) << corner;
        }
        else if (row == 1 || row == height() - 2)
        {
            os << side;
            pad(os, 1, width() - 1);
            os << side;
        }
        else
        {
            os << side << ' ';
            p->display(os, row - 2, true);
            os << ' ' << side;
        }
    }
}

void Pic_base::pad(ostream &os, wd_sz beg, wd_sz end)
{
    while (beg != end)
    {
        os << " ";
        ++beg;
    }
}

class Picture_v;

class Pic_base_v
{
    friend class Frame_Pic_v;
    friend class HCat_Pic_v;
    friend class VCat_Pic_v;
    friend class String_Pic_v;
    friend class Picture_v;
    friend ostream &operator<<(ostream &, const Picture_v &);

    typedef Vec<Str>::size_type ht_sz;
    typedef Str::size_type wd_sz;

    virtual wd_sz width() const = 0;
    virtual ht_sz height() const = 0;
    virtual void display(ostream &, ht_sz, bool) const = 0;

protected:
    static void pad(ostream &os, wd_sz beg, wd_sz end);
};

class Frame_Pic_v : public Pic_base_v
{
    friend Picture_v frame(const Picture_v &);

    Ptr<Pic_base_v> p;

    Frame_Pic_v(const Ptr<Pic_base_v> &pic) : p(pic) { }

    wd_sz width() const
    {
        return p->width() + 4;
    }
    ht_sz height() const
    {
        return p->height() + 4;
    }

    void display(ostream &, ht_sz, bool) const;
};

class VCat_Pic_v : public Pic_base_v
{
    friend Picture_v vcat(const Picture_v &, const Picture_v &);

    Ptr<Pic_base_v> top, bottom;

    VCat_Pic_v(const Ptr<Pic_base_v> &t, const Ptr<Pic_base_v> &b) : top(t), bottom(b) { }

    wd_sz width() const
    {
        return max(top->width(), bottom->width());
    }

    ht_sz height() const
    {
        return top->height() + bottom->height();
    }

    void display(ostream &, ht_sz, bool) const;
};

class HCat_Pic_v : public Pic_base_v
{
    friend Picture_v hcat(const Picture_v &, const Picture_v &);

    Ptr<Pic_base_v> left, right;

    HCat_Pic_v(const Ptr<Pic_base_v> &l, const Ptr<Pic_base_v> &r) : left(l), right(r) { }

    wd_sz width() const
    {
        return left->width() + right->width();
    }

    ht_sz height() const
    {
        return max(left->height(), right->height());
    }

    void display(ostream &, ht_sz, bool) const;
};

class String_Pic_v : public Pic_base_v
{
    friend class Picture_v;

    Vec<Str> data;
    String_Pic_v(const Vec<Str> &v) : data(v) { }

    wd_sz width() const;
    ht_sz height() const
    {
        return data.size();
    };
    void display(ostream &, ht_sz, bool) const;
};

class Picture_v
{
    friend Picture_v frame(const Picture_v &);
    friend Picture_v hcat(const Picture_v &, const Picture_v &);
    friend Picture_v vcat(const Picture_v &, const Picture_v &);
    friend ostream &operator<<(ostream &, const Picture_v &);

public:
    Picture_v(const Vec<Str> & = Vec<Str>());

private:
    Ptr<Pic_base_v> p;
    Picture_v(Pic_base_v *ptr) : p(ptr) { }
};

Picture_v frame(const Picture_v &pic)
{
    return new Frame_Pic_v(pic.p);
}

Picture_v hcat(const Picture_v &l, const Picture_v &r)
{
    return new HCat_Pic_v(l.p, r.p);
}

Picture_v vcat(const Picture_v &t, const Picture_v &b)
{
    return new VCat_Pic_v(t.p, b.p);
}

Picture_v::Picture_v(const Vec<Str> &v) : p(new String_Pic_v(v)) { }

ostream &operator<<(ostream &os, const Picture_v &picture_v)
{
    const Pic_base_v::ht_sz ht = picture_v.p->height();
    for (Pic_base_v::ht_sz i = 0; i != ht; ++i)
    {
        picture_v.p->display(os, i, false);
        os << endl;
    }
    return os;
};

Pic_base_v::wd_sz String_Pic_v::width() const
{
    Pic_base_v::wd_sz n = 0;
    for (Pic_base_v::ht_sz i = 0; i != data.size(); ++i)
    {
        n = max(n, data[i].size());
    }
    return n;
}

void String_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz start = 0;
    if (row < height())
    {
        os << data[row];
        start = data[row].size();
    }
    if (do_pad)
    {
        pad(os, start, width());
    }
}

void VCat_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz w = 0;
    if (row < top->height())
    {
        top->display(os, row, do_pad);
        w = top->width();
    }
    else if (row < height())
    {
        bottom->display(os, row - top->height(), do_pad);
        w = bottom->width();
    }
    if (do_pad)
    {
        pad(os, w, width());
    }
}

void HCat_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    left->display(os, row, do_pad || row < right->height());
    right->display(os, row, do_pad);
}

void Frame_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    if (row >= height())
    {
        if (do_pad)
        {
            pad(os, 0, width());
        }
    }
    else
    {
        if (row == 0 || row == height() - 1)
        {
            os << Str(width(), '*');
        }
        else if (row == 1 || row == height() - 2)
        {
            os << '*';
            pad(os, 1, width() - 1);
            os << '*';
        }
        else
        {
            os << "* ";
            p->display(os, row - 2, true);
            os << " *";
        }
    }
}

void Pic_base_v::pad(ostream &os, wd_sz beg, wd_sz end)
{
    while (beg != end)
    {
        os << " ";
        ++beg;
    }
}

int main()
{
    vector<string> v1 = { "one test", "two test", "aye caramba" };
    vector<string> v2 = { "one direction", "mama mia", "mamo testo", "lake district mall" };

    cout << frame(v1) << endl;
    cout << hcat(v1, v2) << endl;
    cout << vcat(frame(v1), frame(v2)) << endl;

    return 0;
}
显示结果如下
+-------------+
|             |
| one test    |
| two test    |
| aye caramba |
|             |
+-------------+

one test   one direction
two test   mama mia
aye carambamamo testo
           lake district mall

+-------------+
|             |
| one test    |
| two test    |
| aye caramba |
|             |
+-------------+
+--------------------+
|                    |
| one direction      |
| mama mia           |
| mamo testo         |
| lake district mall |
|                    |
+--------------------+

15-1 写一个测试程序，执行下面的语句：
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Handle
{
public:
    Handle() : p(nullptr) { }
    Handle(T *t) : p(t) { }
    Handle(const Handle<T> &s) : p(nullptr)
    {
        if (s.p != nullptr)
        {
            p = s.p->clone();
        }
    }

    Handle<T> &operator=(const Handle<T> &);
    ~Handle()
    {
        delete p;
    }

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const;
    T *operator->() const;

private:
    T *p;
};

template<typename T>
Handle<T> &Handle<T>::operator=(const Handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    delete p;
    p = rhs.p != nullptr ? rhs.p->clone() : nullptr;
    return *this;
}

template <typename T>
T &Handle<T>::operator*() const
{
    if (p != nullptr)
    {
        return *p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
T *Handle<T>::operator->() const
{
    if (p != nullptr)
    {
        return p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
class Ref_handle
{
public:
    Ref_handle() : refptr(new size_t(1)), p(nullptr) { }
    Ref_handle(T *t) : refptr(new size_t(1)), p(t) { }

    Ref_handle(const Ref_handle<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ref_handle<T> &operator=(const Ref_handle<T> &);

    ~Ref_handle();

    operator bool() const
    {
        return p != nullptr;
    }
    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ref_handle");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ref_handle");
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ref_handle<T> &Ref_handle<T>::operator=(const Ref_handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;

    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }

    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ref_handle<T>::~Ref_handle()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

class Ref_counter
{
public:
    Ref_counter() : counter(new size_t(1)) { };
    Ref_counter(size_t s) : counter(new size_t(s)) { };
    Ref_counter(const Ref_counter &r) : counter(r.counter) { };

    Ref_counter &operator=(const Ref_counter &rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        if (*counter <= 0)
        {
            delete counter;
        }
        counter = rhs.counter;
        return *this;
    };

    Ref_counter &operator++()
    {
        (*counter)++;
        return *this;
    };

    Ref_counter &operator--()
    {
        (*counter)--;
        return *this;
    };

    Ref_counter operator++(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)++;
        return ret;
    };

    Ref_counter operator--(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)--;
        return ret;
    };

    ~Ref_counter()
    {
        if (*counter <= 0)
        {
            delete counter;
        }
    };

    size_t count()
    {
        return *counter;
    };

private:
    size_t *counter;
};


template<typename T>
T *clone(const T *tp)
{
    return tp->clone();
}

template<typename T>
class Ptr
{
public:
    Ptr() : refptr(new size_t(1)), p(nullptr) { }
    Ptr(T *t) : refptr(new size_t(1)), p(t) { }
    Ptr(const Ptr<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ptr<T> &operator=(const Ptr<T> &);
    ~Ptr();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr");
    }

    void make_unique()
    {
        if (*refptr > 1)
        {
            --*refptr;
            refptr = new size_t(1);
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ptr<T> &Ptr<T>::operator=(const Ptr<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ptr<T>::~Ptr()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

template<typename T>
class Ptr_r
{
public:
    Ptr_r() : p(nullptr) { }
    Ptr_r(T *t) : p(t) { }
    Ptr_r(const Ptr_r<T> &h) : ref_c(h.ref_c), p(h.p)
    {
        ++ref_c;
    }

    Ptr_r<T> &operator=(const Ptr_r<T> &);
    ~Ptr_r();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    void make_unique()
    {
        if (ref_c.count() > 1)
        {
            --ref_c;
            ref_c = Ref_counter();
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    Ref_counter ref_c;
};

template<typename T>
Ptr_r<T> &Ptr_r<T>::operator=(const Ptr_r<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
    ref_c = rhs.ref_c;
    p = rhs.p;
    ++ref_c;
    return *this;
}

template<typename T>
Ptr_r<T>::~Ptr_r()
{
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
}

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

template<>
inline Vec<char> *clone< Vec<char> >(const Vec<char> *vp)
{
    return new Vec<char>(*vp);
}

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() : data(new Vec<char>) { }
    Str(size_type n, char c) : data(new Vec<char>(n, c)) { }
    Str(const char *cp) : data(new Vec<char>)
    {
        copy(cp, cp + strlen(cp), back_inserter(*data));
    }
    template<class In>
    Str(In b, In e) : data(new Vec<char>(b, e)) { }

    size_type size() const
    {
        return data->size();
    }

    char &operator[](size_type i)
    {
        data.make_unique();
        return (*data)[i];
    }

    const char &operator[](size_type i) const
    {
        return (*data)[i];
    }

    Str &operator+=(const Str &s)
    {
        data.make_unique();
        copy(s.data->begin(), s.data->end(), back_inserter(*data));
        return *this;
    }

    iterator begin()
    {
        return data->begin();
    };
    const_iterator begin() const
    {
        return data->begin();
    };
    iterator end()
    {
        return data->end();
    };
    const_iterator end() const
    {
        return data->end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data->clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data->push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }

    friend ostream &operator<< (ostream &os, const Str &s)
    {
        for (Str::size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }

    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Ptr< Vec<char> > data;
};

class Picture;

class Pic_base
{
    friend class Frame_Pic;
    friend class HCat_Pic;
    friend class VCat_Pic;
    friend class String_Pic;
    friend class Picture;
    friend ostream &operator<<(ostream &, const Picture &);

    typedef vector<string>::size_type ht_sz;
    typedef string::size_type wd_sz;

    virtual wd_sz width() const = 0;
    virtual ht_sz height() const = 0;
    virtual void display(ostream &, ht_sz, bool) const = 0;

protected:
    static void pad(ostream &os, wd_sz beg, wd_sz end);
};

class Frame_Pic : public Pic_base
{
    friend Picture frame(const Picture &);
    friend Picture frame(const Picture &, const char, const char, const char);

    Ptr<Pic_base> p;
    char corner;
    char top_bottom;
    char side;

    Frame_Pic(const Ptr<Pic_base> &pic, const char corner_val = '+',
              const char top_bottom_val = '-', const char side_val = '|')
        : p(pic), corner(corner_val), top_bottom(top_bottom_val), side(side_val) { }

    wd_sz width() const
    {
        return p->width() + 4;
    }
    ht_sz height() const
    {
        return p->height() + 4;
    }

    void display(ostream &, ht_sz, bool) const;
};

class VCat_Pic : public Pic_base
{
    friend Picture vcat(const Picture &, const Picture &);

    Ptr<Pic_base> top, bottom;

    VCat_Pic(const Ptr<Pic_base> &t, const Ptr<Pic_base> &b) : top(t), bottom(b) { }

    wd_sz width() const
    {
        return max(top->width(), bottom->width());
    }

    ht_sz height() const
    {
        return top->height() + bottom->height();
    }

    void display(ostream &, ht_sz, bool) const;
};

class HCat_Pic : public Pic_base
{
    friend Picture hcat(const Picture &, const Picture &);

    Ptr<Pic_base> left, right;

    HCat_Pic(const Ptr<Pic_base> &l, const Ptr<Pic_base> &r) : left(l), right(r) { }

    wd_sz width() const
    {
        return left->width() + right->width();
    }

    ht_sz height() const
    {
        return max(left->height(), right->height());
    }

    void display(ostream &, ht_sz, bool) const;
};

class String_Pic : public Pic_base
{
    friend class Picture;

    vector<string> data;
    String_Pic(const vector<string> &v) : data(v) { }

    wd_sz width() const;
    ht_sz height() const
    {
        return data.size();
    };
    void display(ostream &, ht_sz, bool) const;
};

class Picture
{
    friend Picture frame(const Picture &);
    friend Picture frame(const Picture &, const char, const char, const char);
    friend Picture hcat(const Picture &, const Picture &);
    friend Picture vcat(const Picture &, const Picture &);
    friend ostream &operator<<(ostream &, const Picture &);

public:
    Picture(const vector<string> & = vector<string>());

private:
    Ptr<Pic_base> p;

    Picture(Pic_base *ptr) : p(ptr) { }
};

Picture frame(const Picture &pic)
{
    return new Frame_Pic(pic.p);
}

Picture frame(const Picture &pic, const char corner_val, const char top_bottom_val, const char side_val)
{
    return new Frame_Pic(pic.p, corner_val, top_bottom_val, side_val);
}

Picture hcat(const Picture &l, const Picture &r)
{
    return new HCat_Pic(l.p, r.p);
}

Picture vcat(const Picture &t, const Picture &b)
{
    return new VCat_Pic(t.p, b.p);
}

Picture::Picture(const vector<string> &v) : p(new String_Pic(v)) { }

ostream &operator<<(ostream &os, const Picture &picture)
{
    const Pic_base::ht_sz ht = picture.p->height();
    for (Pic_base::ht_sz i = 0; i != ht; ++i)
    {
        picture.p->display(os, i, false);
        os << endl;
    }
    return os;
};

Pic_base::wd_sz String_Pic::width() const
{
    Pic_base::wd_sz n = 0;
    for (Pic_base::ht_sz i = 0; i != data.size(); ++i)
    {
        n = max(n, data[i].size());
    }
    return n;
}

void String_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz start = 0;
    if (row < height())
    {
        os << data[row];
        start = data[row].size();
    }
    if (do_pad)
    {
        pad(os, start, width());
    }
}

void VCat_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz w = 0;
    if (row < top->height())
    {
        top->display(os, row, do_pad);
        w = top->width();
    }
    else if (row < height())
    {
        bottom->display(os, row - top->height(), do_pad);
        w = bottom->width();
    }
    if (do_pad)
    {
        pad(os, w, width());
    }
}

void HCat_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    ht_sz left_row = row;
    ht_sz right_row = row;

    if (left->height() > right->height())
    {
        ht_sz index = ((left->height() - right->height()) / 2);

        if (row >= index)
        {
            right_row = row - index;
        }
        else
        {
            right_row = right->height();
        }
    }
    else
    {
        ht_sz index = ((right->height() - left->height()) / 2);

        if (row >= index)
        {
            left_row = row - index;
        }
        else
        {
            left_row = left->height();
        }
    }

    left->display(os, left_row, do_pad || right_row < right->height());
    right->display(os, right_row, do_pad);
}

void Frame_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    if (row >= height())
    {
        if (do_pad)
        {
            pad(os, 0, width());
        }
    }
    else
    {
        if (row == 0 || row == height() - 1)
        {
            os << corner << string(width() - 2, top_bottom) << corner;
        }
        else if (row == 1 || row == height() - 2)
        {
            os << side;
            pad(os, 1, width() - 1);
            os << side;
        }
        else
        {
            os << side << ' ';
            p->display(os, row - 2, true);
            os << ' ' << side;
        }
    }
}

void Pic_base::pad(ostream &os, wd_sz beg, wd_sz end)
{
    while (beg != end)
    {
        os << " ";
        ++beg;
    }
}

class Picture_v;

class Pic_base_v
{
    friend class Frame_Pic_v;
    friend class HCat_Pic_v;
    friend class VCat_Pic_v;
    friend class String_Pic_v;
    friend class Picture_v;
    friend ostream &operator<<(ostream &, const Picture_v &);

    typedef Vec<Str>::size_type ht_sz;
    typedef Str::size_type wd_sz;

    virtual wd_sz width() const = 0;
    virtual ht_sz height() const = 0;
    virtual void display(ostream &, ht_sz, bool) const = 0;

protected:
    static void pad(ostream &os, wd_sz beg, wd_sz end);
};

class Frame_Pic_v : public Pic_base_v
{
    friend Picture_v frame(const Picture_v &);

    Ptr<Pic_base_v> p;

    Frame_Pic_v(const Ptr<Pic_base_v> &pic) : p(pic) { }

    wd_sz width() const
    {
        return p->width() + 4;
    }
    ht_sz height() const
    {
        return p->height() + 4;
    }

    void display(ostream &, ht_sz, bool) const;
};

class VCat_Pic_v : public Pic_base_v
{
    friend Picture_v vcat(const Picture_v &, const Picture_v &);

    Ptr<Pic_base_v> top, bottom;

    VCat_Pic_v(const Ptr<Pic_base_v> &t, const Ptr<Pic_base_v> &b) : top(t), bottom(b) { }

    wd_sz width() const
    {
        return max(top->width(), bottom->width());
    }

    ht_sz height() const
    {
        return top->height() + bottom->height();
    }

    void display(ostream &, ht_sz, bool) const;
};

class HCat_Pic_v : public Pic_base_v
{
    friend Picture_v hcat(const Picture_v &, const Picture_v &);

    Ptr<Pic_base_v> left, right;

    HCat_Pic_v(const Ptr<Pic_base_v> &l, const Ptr<Pic_base_v> &r) : left(l), right(r) { }

    wd_sz width() const
    {
        return left->width() + right->width();
    }

    ht_sz height() const
    {
        return max(left->height(), right->height());
    }

    void display(ostream &, ht_sz, bool) const;
};

class String_Pic_v : public Pic_base_v
{
    friend class Picture_v;

    Vec<Str> data;
    String_Pic_v(const Vec<Str> &v) : data(v) { }

    wd_sz width() const;
    ht_sz height() const
    {
        return data.size();
    };
    void display(ostream &, ht_sz, bool) const;
};

class Picture_v
{
    friend Picture_v frame(const Picture_v &);
    friend Picture_v hcat(const Picture_v &, const Picture_v &);
    friend Picture_v vcat(const Picture_v &, const Picture_v &);
    friend ostream &operator<<(ostream &, const Picture_v &);

public:
    Picture_v(const Vec<Str> & = Vec<Str>());

private:
    Ptr<Pic_base_v> p;
    Picture_v(Pic_base_v *ptr) : p(ptr) { }
};

Picture_v frame(const Picture_v &pic)
{
    return new Frame_Pic_v(pic.p);
}

Picture_v hcat(const Picture_v &l, const Picture_v &r)
{
    return new HCat_Pic_v(l.p, r.p);
}

Picture_v vcat(const Picture_v &t, const Picture_v &b)
{
    return new VCat_Pic_v(t.p, b.p);
}

Picture_v::Picture_v(const Vec<Str> &v) : p(new String_Pic_v(v)) { }

ostream &operator<<(ostream &os, const Picture_v &picture_v)
{
    const Pic_base_v::ht_sz ht = picture_v.p->height();
    for (Pic_base_v::ht_sz i = 0; i != ht; ++i)
    {
        picture_v.p->display(os, i, false);
        os << endl;
    }
    return os;
};

Pic_base_v::wd_sz String_Pic_v::width() const
{
    Pic_base_v::wd_sz n = 0;
    for (Pic_base_v::ht_sz i = 0; i != data.size(); ++i)
    {
        n = max(n, data[i].size());
    }
    return n;
}

void String_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz start = 0;
    if (row < height())
    {
        os << data[row];
        start = data[row].size();
    }
    if (do_pad)
    {
        pad(os, start, width());
    }
}

void VCat_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz w = 0;
    if (row < top->height())
    {
        top->display(os, row, do_pad);
        w = top->width();
    }
    else if (row < height())
    {
        bottom->display(os, row - top->height(), do_pad);
        w = bottom->width();
    }
    if (do_pad)
    {
        pad(os, w, width());
    }
}

void HCat_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    left->display(os, row, do_pad || row < right->height());
    right->display(os, row, do_pad);
}

void Frame_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    if (row >= height())
    {
        if (do_pad)
        {
            pad(os, 0, width());
        }
    }
    else
    {
        if (row == 0 || row == height() - 1)
        {
            os << Str(width(), '*');
        }
        else if (row == 1 || row == height() - 2)
        {
            os << '*';
            pad(os, 1, width() - 1);
            os << '*';
        }
        else
        {
            os << "* ";
            p->display(os, row - 2, true);
            os << " *";
        }
    }
}

void Pic_base_v::pad(ostream &os, wd_sz beg, wd_sz end)
{
    while (beg != end)
    {
        os << " ";
        ++beg;
    }
}

int main()
{
    vector<string> v1 = { "one test", "two test", "aye caramba" };
    Picture p = v1;
    Picture q = frame(p);
    Picture r = hcat(p, q);
    Picture s = vcat(q, r);
    cout << frame(hcat(s, vcat(r, q))) << endl;

    return 0;
}
显示结果如下
+------------------------------------------------------+
|                                                      |
| +-------------+                      +-------------+ |
| |             |                      |             | |
| | one test    |           one test   | one test    | |
| | two test    |           two test   | two test    | |
| | aye caramba |           aye caramba| aye caramba | |
| |             |                      |             | |
| +-------------+                      +-------------+ |
|            +-------------++-------------+            |
|            |             ||             |            |
| one test   | one test    || one test    |            |
| two test   | two test    || two test    |            |
| aye caramba| aye caramba || aye caramba |            |
|            |             ||             |            |
|            +-------------++-------------+            |
|                                                      |
+------------------------------------------------------+

15-2重写Frame_Pic类，在为源图形加上边框时使用三种字符：一种字符用于边框的四个角；另一种字符用于顶边与底边；还有一种字符用于两条垂直的边。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Handle
{
public:
    Handle() : p(nullptr) { }
    Handle(T *t) : p(t) { }
    Handle(const Handle<T> &s) : p(nullptr)
    {
        if (s.p != nullptr)
        {
            p = s.p->clone();
        }
    }

    Handle<T> &operator=(const Handle<T> &);
    ~Handle()
    {
        delete p;
    }

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const;
    T *operator->() const;

private:
    T *p;
};

template<typename T>
Handle<T> &Handle<T>::operator=(const Handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    delete p;
    p = rhs.p != nullptr ? rhs.p->clone() : nullptr;
    return *this;
}

template <typename T>
T &Handle<T>::operator*() const
{
    if (p != nullptr)
    {
        return *p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
T *Handle<T>::operator->() const
{
    if (p != nullptr)
    {
        return p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
class Ref_handle
{
public:
    Ref_handle() : refptr(new size_t(1)), p(nullptr) { }
    Ref_handle(T *t) : refptr(new size_t(1)), p(t) { }

    Ref_handle(const Ref_handle<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ref_handle<T> &operator=(const Ref_handle<T> &);

    ~Ref_handle();

    operator bool() const
    {
        return p != nullptr;
    }
    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ref_handle");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ref_handle");
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ref_handle<T> &Ref_handle<T>::operator=(const Ref_handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;

    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }

    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ref_handle<T>::~Ref_handle()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

class Ref_counter
{
public:
    Ref_counter() : counter(new size_t(1)) { };
    Ref_counter(size_t s) : counter(new size_t(s)) { };
    Ref_counter(const Ref_counter &r) : counter(r.counter) { };

    Ref_counter &operator=(const Ref_counter &rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        if (*counter <= 0)
        {
            delete counter;
        }
        counter = rhs.counter;
        return *this;
    };

    Ref_counter &operator++()
    {
        (*counter)++;
        return *this;
    };

    Ref_counter &operator--()
    {
        (*counter)--;
        return *this;
    };

    Ref_counter operator++(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)++;
        return ret;
    };

    Ref_counter operator--(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)--;
        return ret;
    };

    ~Ref_counter()
    {
        if (*counter <= 0)
        {
            delete counter;
        }
    };

    size_t count()
    {
        return *counter;
    };

private:
    size_t *counter;
};


template<typename T>
T *clone(const T *tp)
{
    return tp->clone();
}

template<typename T>
class Ptr
{
public:
    Ptr() : refptr(new size_t(1)), p(nullptr) { }
    Ptr(T *t) : refptr(new size_t(1)), p(t) { }
    Ptr(const Ptr<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ptr<T> &operator=(const Ptr<T> &);
    ~Ptr();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr");
    }

    void make_unique()
    {
        if (*refptr > 1)
        {
            --*refptr;
            refptr = new size_t(1);
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ptr<T> &Ptr<T>::operator=(const Ptr<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ptr<T>::~Ptr()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

template<typename T>
class Ptr_r
{
public:
    Ptr_r() : p(nullptr) { }
    Ptr_r(T *t) : p(t) { }
    Ptr_r(const Ptr_r<T> &h) : ref_c(h.ref_c), p(h.p)
    {
        ++ref_c;
    }

    Ptr_r<T> &operator=(const Ptr_r<T> &);
    ~Ptr_r();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    void make_unique()
    {
        if (ref_c.count() > 1)
        {
            --ref_c;
            ref_c = Ref_counter();
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    Ref_counter ref_c;
};

template<typename T>
Ptr_r<T> &Ptr_r<T>::operator=(const Ptr_r<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
    ref_c = rhs.ref_c;
    p = rhs.p;
    ++ref_c;
    return *this;
}

template<typename T>
Ptr_r<T>::~Ptr_r()
{
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
}

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

template<>
inline Vec<char> *clone< Vec<char> >(const Vec<char> *vp)
{
    return new Vec<char>(*vp);
}

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() : data(new Vec<char>) { }
    Str(size_type n, char c) : data(new Vec<char>(n, c)) { }
    Str(const char *cp) : data(new Vec<char>)
    {
        copy(cp, cp + strlen(cp), back_inserter(*data));
    }
    template<class In>
    Str(In b, In e) : data(new Vec<char>(b, e)) { }

    size_type size() const
    {
        return data->size();
    }

    char &operator[](size_type i)
    {
        data.make_unique();
        return (*data)[i];
    }

    const char &operator[](size_type i) const
    {
        return (*data)[i];
    }

    Str &operator+=(const Str &s)
    {
        data.make_unique();
        copy(s.data->begin(), s.data->end(), back_inserter(*data));
        return *this;
    }

    iterator begin()
    {
        return data->begin();
    };
    const_iterator begin() const
    {
        return data->begin();
    };
    iterator end()
    {
        return data->end();
    };
    const_iterator end() const
    {
        return data->end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data->clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data->push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }

    friend ostream &operator<< (ostream &os, const Str &s)
    {
        for (Str::size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }

    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Ptr< Vec<char> > data;
};

class Picture;

class Pic_base
{
    friend class Frame_Pic;
    friend class HCat_Pic;
    friend class VCat_Pic;
    friend class String_Pic;
    friend class Picture;
    friend ostream &operator<<(ostream &, const Picture &);

    typedef vector<string>::size_type ht_sz;
    typedef string::size_type wd_sz;

    virtual wd_sz width() const = 0;
    virtual ht_sz height() const = 0;
    virtual void display(ostream &, ht_sz, bool) const = 0;

protected:
    static void pad(ostream &os, wd_sz beg, wd_sz end);
};

class Frame_Pic : public Pic_base
{
    friend Picture frame(const Picture &);
    friend Picture frame(const Picture &, const char, const char, const char);

    Ptr<Pic_base> p;
    char corner;
    char top_bottom;
    char side;

    Frame_Pic(const Ptr<Pic_base> &pic, const char corner_val = '+',
              const char top_bottom_val = '-', const char side_val = '|')
        : p(pic), corner(corner_val), top_bottom(top_bottom_val), side(side_val) { }

    wd_sz width() const
    {
        return p->width() + 4;
    }
    ht_sz height() const
    {
        return p->height() + 4;
    }

    void display(ostream &, ht_sz, bool) const;
};

class VCat_Pic : public Pic_base
{
    friend Picture vcat(const Picture &, const Picture &);

    Ptr<Pic_base> top, bottom;

    VCat_Pic(const Ptr<Pic_base> &t, const Ptr<Pic_base> &b) : top(t), bottom(b) { }

    wd_sz width() const
    {
        return max(top->width(), bottom->width());
    }

    ht_sz height() const
    {
        return top->height() + bottom->height();
    }

    void display(ostream &, ht_sz, bool) const;
};

class HCat_Pic : public Pic_base
{
    friend Picture hcat(const Picture &, const Picture &);

    Ptr<Pic_base> left, right;

    HCat_Pic(const Ptr<Pic_base> &l, const Ptr<Pic_base> &r) : left(l), right(r) { }

    wd_sz width() const
    {
        return left->width() + right->width();
    }

    ht_sz height() const
    {
        return max(left->height(), right->height());
    }

    void display(ostream &, ht_sz, bool) const;
};

class String_Pic : public Pic_base
{
    friend class Picture;

    vector<string> data;
    String_Pic(const vector<string> &v) : data(v) { }

    wd_sz width() const;
    ht_sz height() const
    {
        return data.size();
    };
    void display(ostream &, ht_sz, bool) const;
};

class Picture
{
    friend Picture frame(const Picture &);
    friend Picture frame(const Picture &, const char, const char, const char);
    friend Picture hcat(const Picture &, const Picture &);
    friend Picture vcat(const Picture &, const Picture &);
    friend ostream &operator<<(ostream &, const Picture &);

public:
    Picture(const vector<string> & = vector<string>());

private:
    Ptr<Pic_base> p;

    Picture(Pic_base *ptr) : p(ptr) { }
};

Picture frame(const Picture &pic)
{
    return new Frame_Pic(pic.p);
}

Picture frame(const Picture &pic, const char corner_val, const char top_bottom_val, const char side_val)
{
    return new Frame_Pic(pic.p, corner_val, top_bottom_val, side_val);
}

Picture hcat(const Picture &l, const Picture &r)
{
    return new HCat_Pic(l.p, r.p);
}

Picture vcat(const Picture &t, const Picture &b)
{
    return new VCat_Pic(t.p, b.p);
}

Picture::Picture(const vector<string> &v) : p(new String_Pic(v)) { }

ostream &operator<<(ostream &os, const Picture &picture)
{
    const Pic_base::ht_sz ht = picture.p->height();
    for (Pic_base::ht_sz i = 0; i != ht; ++i)
    {
        picture.p->display(os, i, false);
        os << endl;
    }
    return os;
};

Pic_base::wd_sz String_Pic::width() const
{
    Pic_base::wd_sz n = 0;
    for (Pic_base::ht_sz i = 0; i != data.size(); ++i)
    {
        n = max(n, data[i].size());
    }
    return n;
}

void String_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz start = 0;
    if (row < height())
    {
        os << data[row];
        start = data[row].size();
    }
    if (do_pad)
    {
        pad(os, start, width());
    }
}

void VCat_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz w = 0;
    if (row < top->height())
    {
        top->display(os, row, do_pad);
        w = top->width();
    }
    else if (row < height())
    {
        bottom->display(os, row - top->height(), do_pad);
        w = bottom->width();
    }
    if (do_pad)
    {
        pad(os, w, width());
    }
}

void HCat_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    ht_sz left_row = row;
    ht_sz right_row = row;

    if (left->height() > right->height())
    {
        ht_sz index = ((left->height() - right->height()) / 2);

        if (row >= index)
        {
            right_row = row - index;
        }
        else
        {
            right_row = right->height();
        }
    }
    else
    {
        ht_sz index = ((right->height() - left->height()) / 2);

        if (row >= index)
        {
            left_row = row - index;
        }
        else
        {
            left_row = left->height();
        }
    }

    left->display(os, left_row, do_pad || right_row < right->height());
    right->display(os, right_row, do_pad);
}

void Frame_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    if (row >= height())
    {
        if (do_pad)
        {
            pad(os, 0, width());
        }
    }
    else
    {
        if (row == 0 || row == height() - 1)
        {
            os << corner << string(width() - 2, top_bottom) << corner;
        }
        else if (row == 1 || row == height() - 2)
        {
            os << side;
            pad(os, 1, width() - 1);
            os << side;
        }
        else
        {
            os << side << ' ';
            p->display(os, row - 2, true);
            os << ' ' << side;
        }
    }
}

void Pic_base::pad(ostream &os, wd_sz beg, wd_sz end)
{
    while (beg != end)
    {
        os << " ";
        ++beg;
    }
}

class Picture_v;

class Pic_base_v
{
    friend class Frame_Pic_v;
    friend class HCat_Pic_v;
    friend class VCat_Pic_v;
    friend class String_Pic_v;
    friend class Picture_v;
    friend ostream &operator<<(ostream &, const Picture_v &);

    typedef Vec<Str>::size_type ht_sz;
    typedef Str::size_type wd_sz;

    virtual wd_sz width() const = 0;
    virtual ht_sz height() const = 0;
    virtual void display(ostream &, ht_sz, bool) const = 0;

protected:
    static void pad(ostream &os, wd_sz beg, wd_sz end);
};

class Frame_Pic_v : public Pic_base_v
{
    friend Picture_v frame(const Picture_v &);

    Ptr<Pic_base_v> p;

    Frame_Pic_v(const Ptr<Pic_base_v> &pic) : p(pic) { }

    wd_sz width() const
    {
        return p->width() + 4;
    }
    ht_sz height() const
    {
        return p->height() + 4;
    }

    void display(ostream &, ht_sz, bool) const;
};

class VCat_Pic_v : public Pic_base_v
{
    friend Picture_v vcat(const Picture_v &, const Picture_v &);

    Ptr<Pic_base_v> top, bottom;

    VCat_Pic_v(const Ptr<Pic_base_v> &t, const Ptr<Pic_base_v> &b) : top(t), bottom(b) { }

    wd_sz width() const
    {
        return max(top->width(), bottom->width());
    }

    ht_sz height() const
    {
        return top->height() + bottom->height();
    }

    void display(ostream &, ht_sz, bool) const;
};

class HCat_Pic_v : public Pic_base_v
{
    friend Picture_v hcat(const Picture_v &, const Picture_v &);

    Ptr<Pic_base_v> left, right;

    HCat_Pic_v(const Ptr<Pic_base_v> &l, const Ptr<Pic_base_v> &r) : left(l), right(r) { }

    wd_sz width() const
    {
        return left->width() + right->width();
    }

    ht_sz height() const
    {
        return max(left->height(), right->height());
    }

    void display(ostream &, ht_sz, bool) const;
};

class String_Pic_v : public Pic_base_v
{
    friend class Picture_v;

    Vec<Str> data;
    String_Pic_v(const Vec<Str> &v) : data(v) { }

    wd_sz width() const;
    ht_sz height() const
    {
        return data.size();
    };
    void display(ostream &, ht_sz, bool) const;
};

class Picture_v
{
    friend Picture_v frame(const Picture_v &);
    friend Picture_v hcat(const Picture_v &, const Picture_v &);
    friend Picture_v vcat(const Picture_v &, const Picture_v &);
    friend ostream &operator<<(ostream &, const Picture_v &);

public:
    Picture_v(const Vec<Str> & = Vec<Str>());

private:
    Ptr<Pic_base_v> p;
    Picture_v(Pic_base_v *ptr) : p(ptr) { }
};

Picture_v frame(const Picture_v &pic)
{
    return new Frame_Pic_v(pic.p);
}

Picture_v hcat(const Picture_v &l, const Picture_v &r)
{
    return new HCat_Pic_v(l.p, r.p);
}

Picture_v vcat(const Picture_v &t, const Picture_v &b)
{
    return new VCat_Pic_v(t.p, b.p);
}

Picture_v::Picture_v(const Vec<Str> &v) : p(new String_Pic_v(v)) { }

ostream &operator<<(ostream &os, const Picture_v &picture_v)
{
    const Pic_base_v::ht_sz ht = picture_v.p->height();
    for (Pic_base_v::ht_sz i = 0; i != ht; ++i)
    {
        picture_v.p->display(os, i, false);
        os << endl;
    }
    return os;
};

Pic_base_v::wd_sz String_Pic_v::width() const
{
    Pic_base_v::wd_sz n = 0;
    for (Pic_base_v::ht_sz i = 0; i != data.size(); ++i)
    {
        n = max(n, data[i].size());
    }
    return n;
}

void String_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz start = 0;
    if (row < height())
    {
        os << data[row];
        start = data[row].size();
    }
    if (do_pad)
    {
        pad(os, start, width());
    }
}

void VCat_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz w = 0;
    if (row < top->height())
    {
        top->display(os, row, do_pad);
        w = top->width();
    }
    else if (row < height())
    {
        bottom->display(os, row - top->height(), do_pad);
        w = bottom->width();
    }
    if (do_pad)
    {
        pad(os, w, width());
    }
}

void HCat_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    left->display(os, row, do_pad || row < right->height());
    right->display(os, row, do_pad);
}

void Frame_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    if (row >= height())
    {
        if (do_pad)
        {
            pad(os, 0, width());
        }
    }
    else
    {
        if (row == 0 || row == height() - 1)
        {
            os << Str(width(), '*');
        }
        else if (row == 1 || row == height() - 2)
        {
            os << '*';
            pad(os, 1, width() - 1);
            os << '*';
        }
        else
        {
            os << "* ";
            p->display(os, row - 2, true);
            os << " *";
        }
    }
}

void Pic_base_v::pad(ostream &os, wd_sz beg, wd_sz end)
{
    while (beg != end)
    {
        os << " ";
        ++beg;
    }
}

int main()
{
    vector<string> v1 = { "one test", "two test", "aye caramba" };
    Picture p = v1;
    Picture q = frame(p);
    Picture r = hcat(p, q);
    Picture s = vcat(q, r);
    cout << frame(hcat(s, vcat(r, q))) << endl;

    return 0;
}
显示结果如下
+------------------------------------------------------+
|                                                      |
| +-------------+                      +-------------+ |
| |             |                      |             | |
| | one test    |           one test   | one test    | |
| | two test    |           two test   | two test    | |
| | aye caramba |           aye caramba| aye caramba | |
| |             |                      |             | |
| +-------------+                      +-------------+ |
|            +-------------++-------------+            |
|            |             ||             |            |
| one test   | one test    || one test    |            |
| two test   | two test    || two test    |            |
| aye caramba| aye caramba || aye caramba |            |
|            |             ||             |            |
|            +-------------++-------------+            |
|                                                      |
+------------------------------------------------------+

15-3 改写上面所说的类，让用户可以自己选择用什么字符来形成边框。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Handle
{
public:
    Handle() : p(nullptr) { }
    Handle(T *t) : p(t) { }
    Handle(const Handle<T> &s) : p(nullptr)
    {
        if (s.p != nullptr)
        {
            p = s.p->clone();
        }
    }

    Handle<T> &operator=(const Handle<T> &);
    ~Handle()
    {
        delete p;
    }

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const;
    T *operator->() const;

private:
    T *p;
};

template<typename T>
Handle<T> &Handle<T>::operator=(const Handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    delete p;
    p = rhs.p != nullptr ? rhs.p->clone() : nullptr;
    return *this;
}

template <typename T>
T &Handle<T>::operator*() const
{
    if (p != nullptr)
    {
        return *p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
T *Handle<T>::operator->() const
{
    if (p != nullptr)
    {
        return p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
class Ref_handle
{
public:
    Ref_handle() : refptr(new size_t(1)), p(nullptr) { }
    Ref_handle(T *t) : refptr(new size_t(1)), p(t) { }

    Ref_handle(const Ref_handle<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ref_handle<T> &operator=(const Ref_handle<T> &);

    ~Ref_handle();

    operator bool() const
    {
        return p != nullptr;
    }
    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ref_handle");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ref_handle");
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ref_handle<T> &Ref_handle<T>::operator=(const Ref_handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;

    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }

    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ref_handle<T>::~Ref_handle()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

class Ref_counter
{
public:
    Ref_counter() : counter(new size_t(1)) { };
    Ref_counter(size_t s) : counter(new size_t(s)) { };
    Ref_counter(const Ref_counter &r) : counter(r.counter) { };

    Ref_counter &operator=(const Ref_counter &rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        if (*counter <= 0)
        {
            delete counter;
        }
        counter = rhs.counter;
        return *this;
    };

    Ref_counter &operator++()
    {
        (*counter)++;
        return *this;
    };

    Ref_counter &operator--()
    {
        (*counter)--;
        return *this;
    };

    Ref_counter operator++(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)++;
        return ret;
    };

    Ref_counter operator--(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)--;
        return ret;
    };

    ~Ref_counter()
    {
        if (*counter <= 0)
        {
            delete counter;
        }
    };

    size_t count()
    {
        return *counter;
    };

private:
    size_t *counter;
};


template<typename T>
T *clone(const T *tp)
{
    return tp->clone();
}

template<typename T>
class Ptr
{
public:
    Ptr() : refptr(new size_t(1)), p(nullptr) { }
    Ptr(T *t) : refptr(new size_t(1)), p(t) { }
    Ptr(const Ptr<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ptr<T> &operator=(const Ptr<T> &);
    ~Ptr();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr");
    }

    void make_unique()
    {
        if (*refptr > 1)
        {
            --*refptr;
            refptr = new size_t(1);
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ptr<T> &Ptr<T>::operator=(const Ptr<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ptr<T>::~Ptr()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

template<typename T>
class Ptr_r
{
public:
    Ptr_r() : p(nullptr) { }
    Ptr_r(T *t) : p(t) { }
    Ptr_r(const Ptr_r<T> &h) : ref_c(h.ref_c), p(h.p)
    {
        ++ref_c;
    }

    Ptr_r<T> &operator=(const Ptr_r<T> &);
    ~Ptr_r();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    void make_unique()
    {
        if (ref_c.count() > 1)
        {
            --ref_c;
            ref_c = Ref_counter();
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    Ref_counter ref_c;
};

template<typename T>
Ptr_r<T> &Ptr_r<T>::operator=(const Ptr_r<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
    ref_c = rhs.ref_c;
    p = rhs.p;
    ++ref_c;
    return *this;
}

template<typename T>
Ptr_r<T>::~Ptr_r()
{
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
}

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

template<>
inline Vec<char> *clone< Vec<char> >(const Vec<char> *vp)
{
    return new Vec<char>(*vp);
}

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() : data(new Vec<char>) { }
    Str(size_type n, char c) : data(new Vec<char>(n, c)) { }
    Str(const char *cp) : data(new Vec<char>)
    {
        copy(cp, cp + strlen(cp), back_inserter(*data));
    }
    template<class In>
    Str(In b, In e) : data(new Vec<char>(b, e)) { }

    size_type size() const
    {
        return data->size();
    }

    char &operator[](size_type i)
    {
        data.make_unique();
        return (*data)[i];
    }

    const char &operator[](size_type i) const
    {
        return (*data)[i];
    }

    Str &operator+=(const Str &s)
    {
        data.make_unique();
        copy(s.data->begin(), s.data->end(), back_inserter(*data));
        return *this;
    }

    iterator begin()
    {
        return data->begin();
    };
    const_iterator begin() const
    {
        return data->begin();
    };
    iterator end()
    {
        return data->end();
    };
    const_iterator end() const
    {
        return data->end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data->clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data->push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }

    friend ostream &operator<< (ostream &os, const Str &s)
    {
        for (Str::size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }

    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Ptr< Vec<char> > data;
};

class Picture;

class Pic_base
{
    friend class Frame_Pic;
    friend class HCat_Pic;
    friend class VCat_Pic;
    friend class String_Pic;
    friend class Picture;
    friend ostream &operator<<(ostream &, const Picture &);

    typedef vector<string>::size_type ht_sz;
    typedef string::size_type wd_sz;

    virtual wd_sz width() const = 0;
    virtual ht_sz height() const = 0;
    virtual void display(ostream &, ht_sz, bool) const = 0;

protected:
    static void pad(ostream &os, wd_sz beg, wd_sz end);
};

class Frame_Pic : public Pic_base
{
    friend Picture frame(const Picture &);
    friend Picture frame(const Picture &, const char, const char, const char);

    Ptr<Pic_base> p;
    char corner;
    char top_bottom;
    char side;

    Frame_Pic(const Ptr<Pic_base> &pic, const char corner_val = '+',
              const char top_bottom_val = '-', const char side_val = '|')
        : p(pic), corner(corner_val), top_bottom(top_bottom_val), side(side_val) { }

    wd_sz width() const
    {
        return p->width() + 4;
    }
    ht_sz height() const
    {
        return p->height() + 4;
    }

    void display(ostream &, ht_sz, bool) const;
};

class VCat_Pic : public Pic_base
{
    friend Picture vcat(const Picture &, const Picture &);

    Ptr<Pic_base> top, bottom;

    VCat_Pic(const Ptr<Pic_base> &t, const Ptr<Pic_base> &b) : top(t), bottom(b) { }

    wd_sz width() const
    {
        return max(top->width(), bottom->width());
    }

    ht_sz height() const
    {
        return top->height() + bottom->height();
    }

    void display(ostream &, ht_sz, bool) const;
};

class HCat_Pic : public Pic_base
{
    friend Picture hcat(const Picture &, const Picture &);

    Ptr<Pic_base> left, right;

    HCat_Pic(const Ptr<Pic_base> &l, const Ptr<Pic_base> &r) : left(l), right(r) { }

    wd_sz width() const
    {
        return left->width() + right->width();
    }

    ht_sz height() const
    {
        return max(left->height(), right->height());
    }

    void display(ostream &, ht_sz, bool) const;
};

class String_Pic : public Pic_base
{
    friend class Picture;

    vector<string> data;
    String_Pic(const vector<string> &v) : data(v) { }

    wd_sz width() const;
    ht_sz height() const
    {
        return data.size();
    };
    void display(ostream &, ht_sz, bool) const;
};

class Picture
{
    friend Picture frame(const Picture &);
    friend Picture frame(const Picture &, const char, const char, const char);
    friend Picture hcat(const Picture &, const Picture &);
    friend Picture vcat(const Picture &, const Picture &);
    friend ostream &operator<<(ostream &, const Picture &);

public:
    Picture(const vector<string> & = vector<string>());

private:
    Ptr<Pic_base> p;

    Picture(Pic_base *ptr) : p(ptr) { }
};

Picture frame(const Picture &pic)
{
    return new Frame_Pic(pic.p);
}

Picture frame(const Picture &pic, const char corner_val, const char top_bottom_val, const char side_val)
{
    return new Frame_Pic(pic.p, corner_val, top_bottom_val, side_val);
}

Picture hcat(const Picture &l, const Picture &r)
{
    return new HCat_Pic(l.p, r.p);
}

Picture vcat(const Picture &t, const Picture &b)
{
    return new VCat_Pic(t.p, b.p);
}

Picture::Picture(const vector<string> &v) : p(new String_Pic(v)) { }

ostream &operator<<(ostream &os, const Picture &picture)
{
    const Pic_base::ht_sz ht = picture.p->height();
    for (Pic_base::ht_sz i = 0; i != ht; ++i)
    {
        picture.p->display(os, i, false);
        os << endl;
    }
    return os;
};

Pic_base::wd_sz String_Pic::width() const
{
    Pic_base::wd_sz n = 0;
    for (Pic_base::ht_sz i = 0; i != data.size(); ++i)
    {
        n = max(n, data[i].size());
    }
    return n;
}

void String_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz start = 0;
    if (row < height())
    {
        os << data[row];
        start = data[row].size();
    }
    if (do_pad)
    {
        pad(os, start, width());
    }
}

void VCat_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz w = 0;
    if (row < top->height())
    {
        top->display(os, row, do_pad);
        w = top->width();
    }
    else if (row < height())
    {
        bottom->display(os, row - top->height(), do_pad);
        w = bottom->width();
    }
    if (do_pad)
    {
        pad(os, w, width());
    }
}

void HCat_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    ht_sz left_row = row;
    ht_sz right_row = row;

    if (left->height() > right->height())
    {
        ht_sz index = ((left->height() - right->height()) / 2);

        if (row >= index)
        {
            right_row = row - index;
        }
        else
        {
            right_row = right->height();
        }
    }
    else
    {
        ht_sz index = ((right->height() - left->height()) / 2);

        if (row >= index)
        {
            left_row = row - index;
        }
        else
        {
            left_row = left->height();
        }
    }

    left->display(os, left_row, do_pad || right_row < right->height());
    right->display(os, right_row, do_pad);
}

void Frame_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    if (row >= height())
    {
        if (do_pad)
        {
            pad(os, 0, width());
        }
    }
    else
    {
        if (row == 0 || row == height() - 1)
        {
            os << corner << string(width() - 2, top_bottom) << corner;
        }
        else if (row == 1 || row == height() - 2)
        {
            os << side;
            pad(os, 1, width() - 1);
            os << side;
        }
        else
        {
            os << side << ' ';
            p->display(os, row - 2, true);
            os << ' ' << side;
        }
    }
}

void Pic_base::pad(ostream &os, wd_sz beg, wd_sz end)
{
    while (beg != end)
    {
        os << " ";
        ++beg;
    }
}

class Picture_v;

class Pic_base_v
{
    friend class Frame_Pic_v;
    friend class HCat_Pic_v;
    friend class VCat_Pic_v;
    friend class String_Pic_v;
    friend class Picture_v;
    friend ostream &operator<<(ostream &, const Picture_v &);

    typedef Vec<Str>::size_type ht_sz;
    typedef Str::size_type wd_sz;

    virtual wd_sz width() const = 0;
    virtual ht_sz height() const = 0;
    virtual void display(ostream &, ht_sz, bool) const = 0;

protected:
    static void pad(ostream &os, wd_sz beg, wd_sz end);
};

class Frame_Pic_v : public Pic_base_v
{
    friend Picture_v frame(const Picture_v &);

    Ptr<Pic_base_v> p;

    Frame_Pic_v(const Ptr<Pic_base_v> &pic) : p(pic) { }

    wd_sz width() const
    {
        return p->width() + 4;
    }
    ht_sz height() const
    {
        return p->height() + 4;
    }

    void display(ostream &, ht_sz, bool) const;
};

class VCat_Pic_v : public Pic_base_v
{
    friend Picture_v vcat(const Picture_v &, const Picture_v &);

    Ptr<Pic_base_v> top, bottom;

    VCat_Pic_v(const Ptr<Pic_base_v> &t, const Ptr<Pic_base_v> &b) : top(t), bottom(b) { }

    wd_sz width() const
    {
        return max(top->width(), bottom->width());
    }

    ht_sz height() const
    {
        return top->height() + bottom->height();
    }

    void display(ostream &, ht_sz, bool) const;
};

class HCat_Pic_v : public Pic_base_v
{
    friend Picture_v hcat(const Picture_v &, const Picture_v &);

    Ptr<Pic_base_v> left, right;

    HCat_Pic_v(const Ptr<Pic_base_v> &l, const Ptr<Pic_base_v> &r) : left(l), right(r) { }

    wd_sz width() const
    {
        return left->width() + right->width();
    }

    ht_sz height() const
    {
        return max(left->height(), right->height());
    }

    void display(ostream &, ht_sz, bool) const;
};

class String_Pic_v : public Pic_base_v
{
    friend class Picture_v;

    Vec<Str> data;
    String_Pic_v(const Vec<Str> &v) : data(v) { }

    wd_sz width() const;
    ht_sz height() const
    {
        return data.size();
    };
    void display(ostream &, ht_sz, bool) const;
};

class Picture_v
{
    friend Picture_v frame(const Picture_v &);
    friend Picture_v hcat(const Picture_v &, const Picture_v &);
    friend Picture_v vcat(const Picture_v &, const Picture_v &);
    friend ostream &operator<<(ostream &, const Picture_v &);

public:
    Picture_v(const Vec<Str> & = Vec<Str>());

private:
    Ptr<Pic_base_v> p;
    Picture_v(Pic_base_v *ptr) : p(ptr) { }
};

Picture_v frame(const Picture_v &pic)
{
    return new Frame_Pic_v(pic.p);
}

Picture_v hcat(const Picture_v &l, const Picture_v &r)
{
    return new HCat_Pic_v(l.p, r.p);
}

Picture_v vcat(const Picture_v &t, const Picture_v &b)
{
    return new VCat_Pic_v(t.p, b.p);
}

Picture_v::Picture_v(const Vec<Str> &v) : p(new String_Pic_v(v)) { }

ostream &operator<<(ostream &os, const Picture_v &picture_v)
{
    const Pic_base_v::ht_sz ht = picture_v.p->height();
    for (Pic_base_v::ht_sz i = 0; i != ht; ++i)
    {
        picture_v.p->display(os, i, false);
        os << endl;
    }
    return os;
};

Pic_base_v::wd_sz String_Pic_v::width() const
{
    Pic_base_v::wd_sz n = 0;
    for (Pic_base_v::ht_sz i = 0; i != data.size(); ++i)
    {
        n = max(n, data[i].size());
    }
    return n;
}

void String_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz start = 0;
    if (row < height())
    {
        os << data[row];
        start = data[row].size();
    }
    if (do_pad)
    {
        pad(os, start, width());
    }
}

void VCat_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz w = 0;
    if (row < top->height())
    {
        top->display(os, row, do_pad);
        w = top->width();
    }
    else if (row < height())
    {
        bottom->display(os, row - top->height(), do_pad);
        w = bottom->width();
    }
    if (do_pad)
    {
        pad(os, w, width());
    }
}

void HCat_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    left->display(os, row, do_pad || row < right->height());
    right->display(os, row, do_pad);
}

void Frame_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    if (row >= height())
    {
        if (do_pad)
        {
            pad(os, 0, width());
        }
    }
    else
    {
        if (row == 0 || row == height() - 1)
        {
            os << Str(width(), '*');
        }
        else if (row == 1 || row == height() - 2)
        {
            os << '*';
            pad(os, 1, width() - 1);
            os << '*';
        }
        else
        {
            os << "* ";
            p->display(os, row - 2, true);
            os << " *";
        }
    }
}

void Pic_base_v::pad(ostream &os, wd_sz beg, wd_sz end)
{
    while (beg != end)
    {
        os << " ";
        ++beg;
    }
}

int main()
{
    vector<string> v1 = { "one test", "two test", "aye caramba" };
    Picture p = v1;
    Picture q = frame(p, '+', '*', '*');
    Picture r = hcat(p, q);
    Picture s = vcat(q, r);
    cout << frame(hcat(s, vcat(r, q))) << endl;

    return 0;
}
显示结果如下
+------------------------------------------------------+
|                                                      |
| +*************+                      +*************+ |
| *             *                      *             * |
| * one test    *           one test   * one test    * |
| * two test    *           two test   * two test    * |
| * aye caramba *           aye caramba* aye caramba * |
| *             *                      *             * |
| +*************+                      +*************+ |
|            +*************++*************+            |
|            *             **             *            |
| one test   * one test    ** one test    *            |
| two test   * two test    ** two test    *            |
| aye caramba* aye caramba ** aye caramba *            |
|            *             **             *            |
|            +*************++*************+            |
|                                                      |
+------------------------------------------------------+

15-4 加入一个操作函数，用来为一个图形重加边框，它可以改变边线的字符。这个函数要求改变内部图形的所有边框。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Handle
{
public:
    Handle() : p(nullptr) { }
    Handle(T *t) : p(t) { }
    Handle(const Handle<T> &s) : p(nullptr)
    {
        if (s.p != nullptr)
        {
            p = s.p->clone();
        }
    }

    Handle<T> &operator=(const Handle<T> &);
    ~Handle()
    {
        delete p;
    }

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const;
    T *operator->() const;

private:
    T *p;
};

template<typename T>
Handle<T> &Handle<T>::operator=(const Handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    delete p;
    p = rhs.p != nullptr ? rhs.p->clone() : nullptr;
    return *this;
}

template <typename T>
T &Handle<T>::operator*() const
{
    if (p != nullptr)
    {
        return *p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
T *Handle<T>::operator->() const
{
    if (p != nullptr)
    {
        return p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
class Ref_handle
{
public:
    Ref_handle() : refptr(new size_t(1)), p(nullptr) { }
    Ref_handle(T *t) : refptr(new size_t(1)), p(t) { }

    Ref_handle(const Ref_handle<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ref_handle<T> &operator=(const Ref_handle<T> &);

    ~Ref_handle();

    operator bool() const
    {
        return p != nullptr;
    }
    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ref_handle");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ref_handle");
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ref_handle<T> &Ref_handle<T>::operator=(const Ref_handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;

    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }

    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ref_handle<T>::~Ref_handle()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

class Ref_counter
{
public:
    Ref_counter() : counter(new size_t(1)) { };
    Ref_counter(size_t s) : counter(new size_t(s)) { };
    Ref_counter(const Ref_counter &r) : counter(r.counter) { };

    Ref_counter &operator=(const Ref_counter &rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        if (*counter <= 0)
        {
            delete counter;
        }
        counter = rhs.counter;
        return *this;
    };

    Ref_counter &operator++()
    {
        (*counter)++;
        return *this;
    };

    Ref_counter &operator--()
    {
        (*counter)--;
        return *this;
    };

    Ref_counter operator++(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)++;
        return ret;
    };

    Ref_counter operator--(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)--;
        return ret;
    };

    ~Ref_counter()
    {
        if (*counter <= 0)
        {
            delete counter;
        }
    };

    size_t count()
    {
        return *counter;
    };

private:
    size_t *counter;
};


template<typename T>
T *clone(const T *tp)
{
    return tp->clone();
}

template<typename T>
class Ptr
{
public:
    Ptr() : refptr(new size_t(1)), p(nullptr) { }
    Ptr(T *t) : refptr(new size_t(1)), p(t) { }
    Ptr(const Ptr<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ptr<T> &operator=(const Ptr<T> &);
    ~Ptr();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr");
    }

    void make_unique()
    {
        if (*refptr > 1)
        {
            --*refptr;
            refptr = new size_t(1);
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ptr<T> &Ptr<T>::operator=(const Ptr<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ptr<T>::~Ptr()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

template<typename T>
class Ptr_r
{
public:
    Ptr_r() : p(nullptr) { }
    Ptr_r(T *t) : p(t) { }
    Ptr_r(const Ptr_r<T> &h) : ref_c(h.ref_c), p(h.p)
    {
        ++ref_c;
    }

    Ptr_r<T> &operator=(const Ptr_r<T> &);
    ~Ptr_r();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    void make_unique()
    {
        if (ref_c.count() > 1)
        {
            --ref_c;
            ref_c = Ref_counter();
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    Ref_counter ref_c;
};

template<typename T>
Ptr_r<T> &Ptr_r<T>::operator=(const Ptr_r<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
    ref_c = rhs.ref_c;
    p = rhs.p;
    ++ref_c;
    return *this;
}

template<typename T>
Ptr_r<T>::~Ptr_r()
{
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
}

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

template<>
inline Vec<char> *clone< Vec<char> >(const Vec<char> *vp)
{
    return new Vec<char>(*vp);
}

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() : data(new Vec<char>) { }
    Str(size_type n, char c) : data(new Vec<char>(n, c)) { }
    Str(const char *cp) : data(new Vec<char>)
    {
        copy(cp, cp + strlen(cp), back_inserter(*data));
    }
    template<class In>
    Str(In b, In e) : data(new Vec<char>(b, e)) { }

    size_type size() const
    {
        return data->size();
    }

    char &operator[](size_type i)
    {
        data.make_unique();
        return (*data)[i];
    }

    const char &operator[](size_type i) const
    {
        return (*data)[i];
    }

    Str &operator+=(const Str &s)
    {
        data.make_unique();
        copy(s.data->begin(), s.data->end(), back_inserter(*data));
        return *this;
    }

    iterator begin()
    {
        return data->begin();
    };
    const_iterator begin() const
    {
        return data->begin();
    };
    iterator end()
    {
        return data->end();
    };
    const_iterator end() const
    {
        return data->end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data->clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data->push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }

    friend ostream &operator<< (ostream &os, const Str &s)
    {
        for (Str::size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }

    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Ptr< Vec<char> > data;
};

class Picture;

class Pic_base
{
    friend class Frame_Pic;
    friend class HCat_Pic;
    friend class VCat_Pic;
    friend class String_Pic;
    friend class Picture;
    friend ostream &operator<<(ostream &, const Picture &);

    typedef vector<string>::size_type ht_sz;
    typedef string::size_type wd_sz;

    virtual wd_sz width() const = 0;
    virtual ht_sz height() const = 0;
    virtual void display(ostream &, ht_sz, bool) const = 0;
    virtual void reframe(const char, const char, const char) = 0;

protected:
    static void pad(ostream &os, wd_sz beg, wd_sz end);
};

class Frame_Pic : public Pic_base
{
    friend Picture frame(const Picture &);
    friend Picture frame(const Picture &, const char, const char, const char);

    Ptr<Pic_base> p;
    char corner;
    char top_bottom;
    char side;

    Frame_Pic(const Ptr<Pic_base> &pic, const char corner_val = '+',
              const char top_bottom_val = '-', const char side_val = '|')
        : p(pic), corner(corner_val), top_bottom(top_bottom_val), side(side_val) { }

    wd_sz width() const
    {
        return p->width() + 4;
    }
    ht_sz height() const
    {
        return p->height() + 4;
    }

    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char);
};

class VCat_Pic : public Pic_base
{
    friend Picture vcat(const Picture &, const Picture &);

    Ptr<Pic_base> top, bottom;

    VCat_Pic(const Ptr<Pic_base> &t, const Ptr<Pic_base> &b) : top(t), bottom(b) { }

    wd_sz width() const
    {
        return max(top->width(), bottom->width());
    }

    ht_sz height() const
    {
        return top->height() + bottom->height();
    }

    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char);
};

class HCat_Pic : public Pic_base
{
    friend Picture hcat(const Picture &, const Picture &);

    Ptr<Pic_base> left, right;

    HCat_Pic(const Ptr<Pic_base> &l, const Ptr<Pic_base> &r) : left(l), right(r) { }

    wd_sz width() const
    {
        return left->width() + right->width();
    }

    ht_sz height() const
    {
        return max(left->height(), right->height());
    }

    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char);
};

class String_Pic : public Pic_base
{
    friend class Picture;

    vector<string> data;
    String_Pic(const vector<string> &v) : data(v) { }

    wd_sz width() const;
    ht_sz height() const
    {
        return data.size();
    };
    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char) {}
};

class Picture
{
    friend Picture frame(const Picture &);
    friend Picture frame(const Picture &, const char, const char, const char);
    friend Picture hcat(const Picture &, const Picture &);
    friend Picture vcat(const Picture &, const Picture &);
    friend ostream &operator<<(ostream &, const Picture &);

public:
    Picture(const vector<string> & = vector<string>());
    void reframe(const char corner, const char top_bottom, const char side);

private:
    Ptr<Pic_base> p;

    Picture(Pic_base *ptr) : p(ptr) { }
};

Picture frame(const Picture &pic)
{
    return new Frame_Pic(pic.p);
}

Picture frame(const Picture &pic, const char corner_val, const char top_bottom_val, const char side_val)
{
    return new Frame_Pic(pic.p, corner_val, top_bottom_val, side_val);
}

Picture hcat(const Picture &l, const Picture &r)
{
    return new HCat_Pic(l.p, r.p);
}

Picture vcat(const Picture &t, const Picture &b)
{
    return new VCat_Pic(t.p, b.p);
}

Picture::Picture(const vector<string> &v) : p(new String_Pic(v)) { }

ostream &operator<<(ostream &os, const Picture &picture)
{
    const Pic_base::ht_sz ht = picture.p->height();
    for (Pic_base::ht_sz i = 0; i != ht; ++i)
    {
        picture.p->display(os, i, false);
        os << endl;
    }
    return os;
};

Pic_base::wd_sz String_Pic::width() const
{
    Pic_base::wd_sz n = 0;
    for (Pic_base::ht_sz i = 0; i != data.size(); ++i)
    {
        n = max(n, data[i].size());
    }
    return n;
}

void String_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz start = 0;
    if (row < height())
    {
        os << data[row];
        start = data[row].size();
    }
    if (do_pad)
    {
        pad(os, start, width());
    }
}

void VCat_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz w = 0;
    if (row < top->height())
    {
        top->display(os, row, do_pad);
        w = top->width();
    }
    else if (row < height())
    {
        bottom->display(os, row - top->height(), do_pad);
        w = bottom->width();
    }
    if (do_pad)
    {
        pad(os, w, width());
    }
}

void HCat_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    ht_sz left_row = row;
    ht_sz right_row = row;

    if (left->height() > right->height())
    {
        ht_sz index = ((left->height() - right->height()) / 2);

        if (row >= index)
        {
            right_row = row - index;
        }
        else
        {
            right_row = right->height();
        }
    }
    else
    {
        ht_sz index = ((right->height() - left->height()) / 2);

        if (row >= index)
        {
            left_row = row - index;
        }
        else
        {
            left_row = left->height();
        }
    }

    left->display(os, left_row, do_pad || right_row < right->height());
    right->display(os, right_row, do_pad);
}

void Frame_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    if (row >= height())
    {
        if (do_pad)
        {
            pad(os, 0, width());
        }
    }
    else
    {
        if (row == 0 || row == height() - 1)
        {
            os << corner << string(width() - 2, top_bottom) << corner;
        }
        else if (row == 1 || row == height() - 2)
        {
            os << side;
            pad(os, 1, width() - 1);
            os << side;
        }
        else
        {
            os << side << ' ';
            p->display(os, row - 2, true);
            os << ' ' << side;
        }
    }
}

void Pic_base::pad(ostream &os, wd_sz beg, wd_sz end)
{
    while (beg != end)
    {
        os << " ";
        ++beg;
    }
}

class Picture_v;

class Pic_base_v
{
    friend class Frame_Pic_v;
    friend class HCat_Pic_v;
    friend class VCat_Pic_v;
    friend class String_Pic_v;
    friend class Picture_v;
    friend ostream &operator<<(ostream &, const Picture_v &);

    typedef Vec<Str>::size_type ht_sz;
    typedef Str::size_type wd_sz;

    virtual wd_sz width() const = 0;
    virtual ht_sz height() const = 0;
    virtual void display(ostream &, ht_sz, bool) const = 0;

protected:
    static void pad(ostream &os, wd_sz beg, wd_sz end);
};

class Frame_Pic_v : public Pic_base_v
{
    friend Picture_v frame(const Picture_v &);

    Ptr<Pic_base_v> p;

    Frame_Pic_v(const Ptr<Pic_base_v> &pic) : p(pic) { }

    wd_sz width() const
    {
        return p->width() + 4;
    }
    ht_sz height() const
    {
        return p->height() + 4;
    }

    void display(ostream &, ht_sz, bool) const;
};

class VCat_Pic_v : public Pic_base_v
{
    friend Picture_v vcat(const Picture_v &, const Picture_v &);

    Ptr<Pic_base_v> top, bottom;

    VCat_Pic_v(const Ptr<Pic_base_v> &t, const Ptr<Pic_base_v> &b) : top(t), bottom(b) { }

    wd_sz width() const
    {
        return max(top->width(), bottom->width());
    }

    ht_sz height() const
    {
        return top->height() + bottom->height();
    }

    void display(ostream &, ht_sz, bool) const;
};

class HCat_Pic_v : public Pic_base_v
{
    friend Picture_v hcat(const Picture_v &, const Picture_v &);

    Ptr<Pic_base_v> left, right;

    HCat_Pic_v(const Ptr<Pic_base_v> &l, const Ptr<Pic_base_v> &r) : left(l), right(r) { }

    wd_sz width() const
    {
        return left->width() + right->width();
    }

    ht_sz height() const
    {
        return max(left->height(), right->height());
    }

    void display(ostream &, ht_sz, bool) const;
};

class String_Pic_v : public Pic_base_v
{
    friend class Picture_v;

    Vec<Str> data;
    String_Pic_v(const Vec<Str> &v) : data(v) { }

    wd_sz width() const;
    ht_sz height() const
    {
        return data.size();
    };
    void display(ostream &, ht_sz, bool) const;
};

class Picture_v
{
    friend Picture_v frame(const Picture_v &);
    friend Picture_v hcat(const Picture_v &, const Picture_v &);
    friend Picture_v vcat(const Picture_v &, const Picture_v &);
    friend ostream &operator<<(ostream &, const Picture_v &);

public:
    Picture_v(const Vec<Str> & = Vec<Str>());

private:
    Ptr<Pic_base_v> p;
    Picture_v(Pic_base_v *ptr) : p(ptr) { }
};

Picture_v frame(const Picture_v &pic)
{
    return new Frame_Pic_v(pic.p);
}

Picture_v hcat(const Picture_v &l, const Picture_v &r)
{
    return new HCat_Pic_v(l.p, r.p);
}

Picture_v vcat(const Picture_v &t, const Picture_v &b)
{
    return new VCat_Pic_v(t.p, b.p);
}

Picture_v::Picture_v(const Vec<Str> &v) : p(new String_Pic_v(v)) { }

ostream &operator<<(ostream &os, const Picture_v &picture_v)
{
    const Pic_base_v::ht_sz ht = picture_v.p->height();
    for (Pic_base_v::ht_sz i = 0; i != ht; ++i)
    {
        picture_v.p->display(os, i, false);
        os << endl;
    }
    return os;
};

Pic_base_v::wd_sz String_Pic_v::width() const
{
    Pic_base_v::wd_sz n = 0;
    for (Pic_base_v::ht_sz i = 0; i != data.size(); ++i)
    {
        n = max(n, data[i].size());
    }
    return n;
}

void String_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz start = 0;
    if (row < height())
    {
        os << data[row];
        start = data[row].size();
    }
    if (do_pad)
    {
        pad(os, start, width());
    }
}

void VCat_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz w = 0;
    if (row < top->height())
    {
        top->display(os, row, do_pad);
        w = top->width();
    }
    else if (row < height())
    {
        bottom->display(os, row - top->height(), do_pad);
        w = bottom->width();
    }
    if (do_pad)
    {
        pad(os, w, width());
    }
}

void HCat_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    left->display(os, row, do_pad || row < right->height());
    right->display(os, row, do_pad);
}

void Frame_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    if (row >= height())
    {
        if (do_pad)
        {
            pad(os, 0, width());
        }
    }
    else
    {
        if (row == 0 || row == height() - 1)
        {
            os << Str(width(), '*');
        }
        else if (row == 1 || row == height() - 2)
        {
            os << '*';
            pad(os, 1, width() - 1);
            os << '*';
        }
        else
        {
            os << "* ";
            p->display(os, row - 2, true);
            os << " *";
        }
    }
}

void Pic_base_v::pad(ostream &os, wd_sz beg, wd_sz end)
{
    while (beg != end)
    {
        os << " ";
        ++beg;
    }
}

void Frame_Pic::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    this->corner = corner_val;
    this->top_bottom = top_bottom_val;
    this->side = side_val;

    p->reframe(corner_val, top_bottom_val, side_val);
}

void VCat_Pic::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    top->reframe(corner_val, top_bottom_val, side_val);
    bottom->reframe(corner_val, top_bottom_val, side_val);
}

void HCat_Pic::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    left->reframe(corner_val, top_bottom_val, side_val);
    right->reframe(corner_val, top_bottom_val, side_val);
}

void Picture::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    p->reframe(corner_val, top_bottom_val, side_val);
}

int main()
{
    vector<string> v1 = { "one test", "two test", "aye caramba" };
    Picture p = v1;
    Picture q = frame(p);
    Picture r = hcat(p, q);
    Picture s = vcat(q, r);
    Picture t = frame(hcat(s, vcat(r, q)));
    cout << t << endl;

    t.reframe('*', '*', '*');
    cout << t << endl;

    return 0;
}
显示结果如下
+------------------------------------------------------+
|                                                      |
| +-------------+                      +-------------+ |
| |             |                      |             | |
| | one test    |           one test   | one test    | |
| | two test    |           two test   | two test    | |
| | aye caramba |           aye caramba| aye caramba | |
| |             |                      |             | |
| +-------------+                      +-------------+ |
|            +-------------++-------------+            |
|            |             ||             |            |
| one test   | one test    || one test    |            |
| two test   | two test    || two test    |            |
| aye caramba| aye caramba || aye caramba |            |
|            |             ||             |            |
|            +-------------++-------------+            |
|                                                      |
+------------------------------------------------------+

********************************************************
*                                                      *
* ***************                      *************** *
* *             *                      *             * *
* * one test    *           one test   * one test    * *
* * two test    *           two test   * two test    * *
* * aye caramba *           aye caramba* aye caramba * *
* *             *                      *             * *
* ***************                      *************** *
*            ******************************            *
*            *             **             *            *
* one test   * one test    ** one test    *            *
* two test   * two test    ** two test    *            *
* aye caramba* aye caramba ** aye caramba *            *
*            *             **             *            *
*            ******************************            *
*                                                      *
********************************************************

15-5重写HCat_Pic类，要求不同大小的子图形在连接的时候，小的那个子图形必须在大图形的中间位置与大图形连接。
也就是说，如果我们水平地连接两个子图形，并且其中一个子图形有四行，而另一个子图形有两行，
那么在输出这个小图形的时候，要在它的顶上与底下各多输出一行空格。
请注意这时候某行内容在子图形中的相对行号与以前的版本不同。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Handle
{
public:
    Handle() : p(nullptr) { }
    Handle(T *t) : p(t) { }
    Handle(const Handle<T> &s) : p(nullptr)
    {
        if (s.p != nullptr)
        {
            p = s.p->clone();
        }
    }

    Handle<T> &operator=(const Handle<T> &);
    ~Handle()
    {
        delete p;
    }

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const;
    T *operator->() const;

private:
    T *p;
};

template<typename T>
Handle<T> &Handle<T>::operator=(const Handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    delete p;
    p = rhs.p != nullptr ? rhs.p->clone() : nullptr;
    return *this;
}

template <typename T>
T &Handle<T>::operator*() const
{
    if (p != nullptr)
    {
        return *p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
T *Handle<T>::operator->() const
{
    if (p != nullptr)
    {
        return p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
class Ref_handle
{
public:
    Ref_handle() : refptr(new size_t(1)), p(nullptr) { }
    Ref_handle(T *t) : refptr(new size_t(1)), p(t) { }

    Ref_handle(const Ref_handle<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ref_handle<T> &operator=(const Ref_handle<T> &);

    ~Ref_handle();

    operator bool() const
    {
        return p != nullptr;
    }
    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ref_handle");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ref_handle");
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ref_handle<T> &Ref_handle<T>::operator=(const Ref_handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;

    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }

    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ref_handle<T>::~Ref_handle()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

class Ref_counter
{
public:
    Ref_counter() : counter(new size_t(1)) { };
    Ref_counter(size_t s) : counter(new size_t(s)) { };
    Ref_counter(const Ref_counter &r) : counter(r.counter) { };

    Ref_counter &operator=(const Ref_counter &rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        if (*counter <= 0)
        {
            delete counter;
        }
        counter = rhs.counter;
        return *this;
    };

    Ref_counter &operator++()
    {
        (*counter)++;
        return *this;
    };

    Ref_counter &operator--()
    {
        (*counter)--;
        return *this;
    };

    Ref_counter operator++(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)++;
        return ret;
    };

    Ref_counter operator--(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)--;
        return ret;
    };

    ~Ref_counter()
    {
        if (*counter <= 0)
        {
            delete counter;
        }
    };

    size_t count()
    {
        return *counter;
    };

private:
    size_t *counter;
};


template<typename T>
T *clone(const T *tp)
{
    return tp->clone();
}

template<typename T>
class Ptr
{
public:
    Ptr() : refptr(new size_t(1)), p(nullptr) { }
    Ptr(T *t) : refptr(new size_t(1)), p(t) { }
    Ptr(const Ptr<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ptr<T> &operator=(const Ptr<T> &);
    ~Ptr();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr");
    }

    void make_unique()
    {
        if (*refptr > 1)
        {
            --*refptr;
            refptr = new size_t(1);
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ptr<T> &Ptr<T>::operator=(const Ptr<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ptr<T>::~Ptr()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

template<typename T>
class Ptr_r
{
public:
    Ptr_r() : p(nullptr) { }
    Ptr_r(T *t) : p(t) { }
    Ptr_r(const Ptr_r<T> &h) : ref_c(h.ref_c), p(h.p)
    {
        ++ref_c;
    }

    Ptr_r<T> &operator=(const Ptr_r<T> &);
    ~Ptr_r();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    void make_unique()
    {
        if (ref_c.count() > 1)
        {
            --ref_c;
            ref_c = Ref_counter();
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    Ref_counter ref_c;
};

template<typename T>
Ptr_r<T> &Ptr_r<T>::operator=(const Ptr_r<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
    ref_c = rhs.ref_c;
    p = rhs.p;
    ++ref_c;
    return *this;
}

template<typename T>
Ptr_r<T>::~Ptr_r()
{
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
}

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

template<>
inline Vec<char> *clone< Vec<char> >(const Vec<char> *vp)
{
    return new Vec<char>(*vp);
}

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() : data(new Vec<char>) { }
    Str(size_type n, char c) : data(new Vec<char>(n, c)) { }
    Str(const char *cp) : data(new Vec<char>)
    {
        copy(cp, cp + strlen(cp), back_inserter(*data));
    }
    template<class In>
    Str(In b, In e) : data(new Vec<char>(b, e)) { }

    size_type size() const
    {
        return data->size();
    }

    char &operator[](size_type i)
    {
        data.make_unique();
        return (*data)[i];
    }

    const char &operator[](size_type i) const
    {
        return (*data)[i];
    }

    Str &operator+=(const Str &s)
    {
        data.make_unique();
        copy(s.data->begin(), s.data->end(), back_inserter(*data));
        return *this;
    }

    iterator begin()
    {
        return data->begin();
    };
    const_iterator begin() const
    {
        return data->begin();
    };
    iterator end()
    {
        return data->end();
    };
    const_iterator end() const
    {
        return data->end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data->clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data->push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }

    friend ostream &operator<< (ostream &os, const Str &s)
    {
        for (Str::size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }

    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Ptr< Vec<char> > data;
};

class Picture;

class Pic_base
{
    friend class Frame_Pic;
    friend class HCat_Pic;
    friend class VCat_Pic;
    friend class String_Pic;
    friend class Picture;
    friend ostream &operator<<(ostream &, const Picture &);

    typedef vector<string>::size_type ht_sz;
    typedef string::size_type wd_sz;

    virtual wd_sz width() const = 0;
    virtual ht_sz height() const = 0;
    virtual void display(ostream &, ht_sz, bool) const = 0;
    virtual void reframe(const char, const char, const char) = 0;

protected:
    static void pad(ostream &os, wd_sz beg, wd_sz end);
};

class Frame_Pic : public Pic_base
{
    friend Picture frame(const Picture &);
    friend Picture frame(const Picture &, const char, const char, const char);

    Ptr<Pic_base> p;
    char corner;
    char top_bottom;
    char side;

    Frame_Pic(const Ptr<Pic_base> &pic, const char corner_val = '+',
              const char top_bottom_val = '-', const char side_val = '|')
        : p(pic), corner(corner_val), top_bottom(top_bottom_val), side(side_val) { }

    wd_sz width() const
    {
        return p->width() + 4;
    }
    ht_sz height() const
    {
        return p->height() + 4;
    }

    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char);
};

class VCat_Pic : public Pic_base
{
    friend Picture vcat(const Picture &, const Picture &);

    Ptr<Pic_base> top, bottom;

    VCat_Pic(const Ptr<Pic_base> &t, const Ptr<Pic_base> &b) : top(t), bottom(b) { }

    wd_sz width() const
    {
        return max(top->width(), bottom->width());
    }

    ht_sz height() const
    {
        return top->height() + bottom->height();
    }

    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char);
};

class HCat_Pic : public Pic_base
{
    friend Picture hcat(const Picture &, const Picture &);

    Ptr<Pic_base> left, right;

    HCat_Pic(const Ptr<Pic_base> &l, const Ptr<Pic_base> &r) : left(l), right(r) { }

    wd_sz width() const
    {
        return left->width() + right->width();
    }

    ht_sz height() const
    {
        return max(left->height(), right->height());
    }

    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char);
};

class String_Pic : public Pic_base
{
    friend class Picture;

    vector<string> data;
    String_Pic(const vector<string> &v) : data(v) { }

    wd_sz width() const;
    ht_sz height() const
    {
        return data.size();
    };
    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char) {}
};

class Picture
{
    friend Picture frame(const Picture &);
    friend Picture frame(const Picture &, const char, const char, const char);
    friend Picture hcat(const Picture &, const Picture &);
    friend Picture vcat(const Picture &, const Picture &);
    friend ostream &operator<<(ostream &, const Picture &);

public:
    Picture(const vector<string> & = vector<string>());
    void reframe(const char corner, const char top_bottom, const char side);

private:
    Ptr<Pic_base> p;

    Picture(Pic_base *ptr) : p(ptr) { }
};

Picture frame(const Picture &pic)
{
    return new Frame_Pic(pic.p);
}

Picture frame(const Picture &pic, const char corner_val, const char top_bottom_val, const char side_val)
{
    return new Frame_Pic(pic.p, corner_val, top_bottom_val, side_val);
}

Picture hcat(const Picture &l, const Picture &r)
{
    return new HCat_Pic(l.p, r.p);
}

Picture vcat(const Picture &t, const Picture &b)
{
    return new VCat_Pic(t.p, b.p);
}

Picture::Picture(const vector<string> &v) : p(new String_Pic(v)) { }

ostream &operator<<(ostream &os, const Picture &picture)
{
    const Pic_base::ht_sz ht = picture.p->height();
    for (Pic_base::ht_sz i = 0; i != ht; ++i)
    {
        picture.p->display(os, i, false);
        os << endl;
    }
    return os;
};

Pic_base::wd_sz String_Pic::width() const
{
    Pic_base::wd_sz n = 0;
    for (Pic_base::ht_sz i = 0; i != data.size(); ++i)
    {
        n = max(n, data[i].size());
    }
    return n;
}

void String_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz start = 0;
    if (row < height())
    {
        os << data[row];
        start = data[row].size();
    }
    if (do_pad)
    {
        pad(os, start, width());
    }
}

void VCat_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz w = 0;
    if (row < top->height())
    {
        top->display(os, row, do_pad);
        w = top->width();
    }
    else if (row < height())
    {
        bottom->display(os, row - top->height(), do_pad);
        w = bottom->width();
    }
    if (do_pad)
    {
        pad(os, w, width());
    }
}

void HCat_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    ht_sz left_row = row;
    ht_sz right_row = row;

    if (left->height() > right->height())
    {
        ht_sz index = ((left->height() - right->height()) / 2);

        if (row >= index)
        {
            right_row = row - index;
        }
        else
        {
            right_row = right->height();
        }
    }
    else
    {
        ht_sz index = ((right->height() - left->height()) / 2);

        if (row >= index)
        {
            left_row = row - index;
        }
        else
        {
            left_row = left->height();
        }
    }

    left->display(os, left_row, do_pad || right_row < right->height());
    right->display(os, right_row, do_pad);
}

void Frame_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    if (row >= height())
    {
        if (do_pad)
        {
            pad(os, 0, width());
        }
    }
    else
    {
        if (row == 0 || row == height() - 1)
        {
            os << corner << string(width() - 2, top_bottom) << corner;
        }
        else if (row == 1 || row == height() - 2)
        {
            os << side;
            pad(os, 1, width() - 1);
            os << side;
        }
        else
        {
            os << side << ' ';
            p->display(os, row - 2, true);
            os << ' ' << side;
        }
    }
}

void Pic_base::pad(ostream &os, wd_sz beg, wd_sz end)
{
    while (beg != end)
    {
        os << " ";
        ++beg;
    }
}

class Picture_v;

class Pic_base_v
{
    friend class Frame_Pic_v;
    friend class HCat_Pic_v;
    friend class VCat_Pic_v;
    friend class String_Pic_v;
    friend class Picture_v;
    friend ostream &operator<<(ostream &, const Picture_v &);

    typedef Vec<Str>::size_type ht_sz;
    typedef Str::size_type wd_sz;

    virtual wd_sz width() const = 0;
    virtual ht_sz height() const = 0;
    virtual void display(ostream &, ht_sz, bool) const = 0;

protected:
    static void pad(ostream &os, wd_sz beg, wd_sz end);
};

class Frame_Pic_v : public Pic_base_v
{
    friend Picture_v frame(const Picture_v &);

    Ptr<Pic_base_v> p;

    Frame_Pic_v(const Ptr<Pic_base_v> &pic) : p(pic) { }

    wd_sz width() const
    {
        return p->width() + 4;
    }
    ht_sz height() const
    {
        return p->height() + 4;
    }

    void display(ostream &, ht_sz, bool) const;
};

class VCat_Pic_v : public Pic_base_v
{
    friend Picture_v vcat(const Picture_v &, const Picture_v &);

    Ptr<Pic_base_v> top, bottom;

    VCat_Pic_v(const Ptr<Pic_base_v> &t, const Ptr<Pic_base_v> &b) : top(t), bottom(b) { }

    wd_sz width() const
    {
        return max(top->width(), bottom->width());
    }

    ht_sz height() const
    {
        return top->height() + bottom->height();
    }

    void display(ostream &, ht_sz, bool) const;
};

class HCat_Pic_v : public Pic_base_v
{
    friend Picture_v hcat(const Picture_v &, const Picture_v &);

    Ptr<Pic_base_v> left, right;

    HCat_Pic_v(const Ptr<Pic_base_v> &l, const Ptr<Pic_base_v> &r) : left(l), right(r) { }

    wd_sz width() const
    {
        return left->width() + right->width();
    }

    ht_sz height() const
    {
        return max(left->height(), right->height());
    }

    void display(ostream &, ht_sz, bool) const;
};

class String_Pic_v : public Pic_base_v
{
    friend class Picture_v;

    Vec<Str> data;
    String_Pic_v(const Vec<Str> &v) : data(v) { }

    wd_sz width() const;
    ht_sz height() const
    {
        return data.size();
    };
    void display(ostream &, ht_sz, bool) const;
};

class Picture_v
{
    friend Picture_v frame(const Picture_v &);
    friend Picture_v hcat(const Picture_v &, const Picture_v &);
    friend Picture_v vcat(const Picture_v &, const Picture_v &);
    friend ostream &operator<<(ostream &, const Picture_v &);

public:
    Picture_v(const Vec<Str> & = Vec<Str>());

private:
    Ptr<Pic_base_v> p;
    Picture_v(Pic_base_v *ptr) : p(ptr) { }
};

Picture_v frame(const Picture_v &pic)
{
    return new Frame_Pic_v(pic.p);
}

Picture_v hcat(const Picture_v &l, const Picture_v &r)
{
    return new HCat_Pic_v(l.p, r.p);
}

Picture_v vcat(const Picture_v &t, const Picture_v &b)
{
    return new VCat_Pic_v(t.p, b.p);
}

Picture_v::Picture_v(const Vec<Str> &v) : p(new String_Pic_v(v)) { }

ostream &operator<<(ostream &os, const Picture_v &picture_v)
{
    const Pic_base_v::ht_sz ht = picture_v.p->height();
    for (Pic_base_v::ht_sz i = 0; i != ht; ++i)
    {
        picture_v.p->display(os, i, false);
        os << endl;
    }
    return os;
};

Pic_base_v::wd_sz String_Pic_v::width() const
{
    Pic_base_v::wd_sz n = 0;
    for (Pic_base_v::ht_sz i = 0; i != data.size(); ++i)
    {
        n = max(n, data[i].size());
    }
    return n;
}

void String_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz start = 0;
    if (row < height())
    {
        os << data[row];
        start = data[row].size();
    }
    if (do_pad)
    {
        pad(os, start, width());
    }
}

void VCat_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz w = 0;
    if (row < top->height())
    {
        top->display(os, row, do_pad);
        w = top->width();
    }
    else if (row < height())
    {
        bottom->display(os, row - top->height(), do_pad);
        w = bottom->width();
    }
    if (do_pad)
    {
        pad(os, w, width());
    }
}

void HCat_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    left->display(os, row, do_pad || row < right->height());
    right->display(os, row, do_pad);
}

void Frame_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    if (row >= height())
    {
        if (do_pad)
        {
            pad(os, 0, width());
        }
    }
    else
    {
        if (row == 0 || row == height() - 1)
        {
            os << Str(width(), '*');
        }
        else if (row == 1 || row == height() - 2)
        {
            os << '*';
            pad(os, 1, width() - 1);
            os << '*';
        }
        else
        {
            os << "* ";
            p->display(os, row - 2, true);
            os << " *";
        }
    }
}

void Pic_base_v::pad(ostream &os, wd_sz beg, wd_sz end)
{
    while (beg != end)
    {
        os << " ";
        ++beg;
    }
}

void Frame_Pic::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    this->corner = corner_val;
    this->top_bottom = top_bottom_val;
    this->side = side_val;

    p->reframe(corner_val, top_bottom_val, side_val);
}

void VCat_Pic::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    top->reframe(corner_val, top_bottom_val, side_val);
    bottom->reframe(corner_val, top_bottom_val, side_val);
}

void HCat_Pic::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    left->reframe(corner_val, top_bottom_val, side_val);
    right->reframe(corner_val, top_bottom_val, side_val);
}

void Picture::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    p->reframe(corner_val, top_bottom_val, side_val);
}

int main()
{
    vector<string> v1 = { "one test", "aye caramba" };
    vector<string> v2 = { "one direction", "mama mia", "mamo testo", "lake district mall" };

    cout << frame(hcat(v1, v2)) << endl;
    cout << hcat(v2, v1) << endl;
    cout << hcat(frame(v1), v2) << endl;

    return 0;
}
显示结果如下
+-------------------------------+
|                               |
|            one direction      |
| one test   mama mia           |
| aye carambamamo testo         |
|            lake district mall |
|                               |
+-------------------------------+

one direction
mama mia          one test
mamo testo        aye caramba
lake district mall

+-------------+
|             |one direction
| one test    |mama mia
| aye caramba |mamo testo
|             |lake district mall
+-------------+

15-6我们在第11章与12章中写的Vec类与Str类也可以用来实现Picture类。在本章写的类中用Vec<Str>类来代替vector<string>类，并编程对你写的类进行测试。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Handle
{
public:
    Handle() : p(nullptr) { }
    Handle(T *t) : p(t) { }
    Handle(const Handle<T> &s) : p(nullptr)
    {
        if (s.p != nullptr)
        {
            p = s.p->clone();
        }
    }

    Handle<T> &operator=(const Handle<T> &);
    ~Handle()
    {
        delete p;
    }

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const;
    T *operator->() const;

private:
    T *p;
};

template<typename T>
Handle<T> &Handle<T>::operator=(const Handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    delete p;
    p = rhs.p != nullptr ? rhs.p->clone() : nullptr;
    return *this;
}

template <typename T>
T &Handle<T>::operator*() const
{
    if (p != nullptr)
    {
        return *p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
T *Handle<T>::operator->() const
{
    if (p != nullptr)
    {
        return p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
class Ref_handle
{
public:
    Ref_handle() : refptr(new size_t(1)), p(nullptr) { }
    Ref_handle(T *t) : refptr(new size_t(1)), p(t) { }

    Ref_handle(const Ref_handle<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ref_handle<T> &operator=(const Ref_handle<T> &);

    ~Ref_handle();

    operator bool() const
    {
        return p != nullptr;
    }
    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ref_handle");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ref_handle");
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ref_handle<T> &Ref_handle<T>::operator=(const Ref_handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;

    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }

    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ref_handle<T>::~Ref_handle()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

class Ref_counter
{
public:
    Ref_counter() : counter(new size_t(1)) { };
    Ref_counter(size_t s) : counter(new size_t(s)) { };
    Ref_counter(const Ref_counter &r) : counter(r.counter) { };

    Ref_counter &operator=(const Ref_counter &rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        if (*counter <= 0)
        {
            delete counter;
        }
        counter = rhs.counter;
        return *this;
    };

    Ref_counter &operator++()
    {
        (*counter)++;
        return *this;
    };

    Ref_counter &operator--()
    {
        (*counter)--;
        return *this;
    };

    Ref_counter operator++(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)++;
        return ret;
    };

    Ref_counter operator--(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)--;
        return ret;
    };

    ~Ref_counter()
    {
        if (*counter <= 0)
        {
            delete counter;
        }
    };

    size_t count()
    {
        return *counter;
    };

private:
    size_t *counter;
};


template<typename T>
T *clone(const T *tp)
{
    return tp->clone();
}

template<typename T>
class Ptr
{
public:
    Ptr() : refptr(new size_t(1)), p(nullptr) { }
    Ptr(T *t) : refptr(new size_t(1)), p(t) { }
    Ptr(const Ptr<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ptr<T> &operator=(const Ptr<T> &);
    ~Ptr();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr");
    }

    void make_unique()
    {
        if (*refptr > 1)
        {
            --*refptr;
            refptr = new size_t(1);
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ptr<T> &Ptr<T>::operator=(const Ptr<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ptr<T>::~Ptr()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

template<typename T>
class Ptr_r
{
public:
    Ptr_r() : p(nullptr) { }
    Ptr_r(T *t) : p(t) { }
    Ptr_r(const Ptr_r<T> &h) : ref_c(h.ref_c), p(h.p)
    {
        ++ref_c;
    }

    Ptr_r<T> &operator=(const Ptr_r<T> &);
    ~Ptr_r();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    void make_unique()
    {
        if (ref_c.count() > 1)
        {
            --ref_c;
            ref_c = Ref_counter();
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    Ref_counter ref_c;
};

template<typename T>
Ptr_r<T> &Ptr_r<T>::operator=(const Ptr_r<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
    ref_c = rhs.ref_c;
    p = rhs.p;
    ++ref_c;
    return *this;
}

template<typename T>
Ptr_r<T>::~Ptr_r()
{
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
}

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

template<>
inline Vec<char> *clone< Vec<char> >(const Vec<char> *vp)
{
    return new Vec<char>(*vp);
}

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() : data(new Vec<char>) { }
    Str(size_type n, char c) : data(new Vec<char>(n, c)) { }
    Str(const char *cp) : data(new Vec<char>)
    {
        copy(cp, cp + strlen(cp), back_inserter(*data));
    }
    template<class In>
    Str(In b, In e) : data(new Vec<char>(b, e)) { }

    size_type size() const
    {
        return data->size();
    }

    char &operator[](size_type i)
    {
        data.make_unique();
        return (*data)[i];
    }

    const char &operator[](size_type i) const
    {
        return (*data)[i];
    }

    Str &operator+=(const Str &s)
    {
        data.make_unique();
        copy(s.data->begin(), s.data->end(), back_inserter(*data));
        return *this;
    }

    iterator begin()
    {
        return data->begin();
    };
    const_iterator begin() const
    {
        return data->begin();
    };
    iterator end()
    {
        return data->end();
    };
    const_iterator end() const
    {
        return data->end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data->clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data->push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }

    friend ostream &operator<< (ostream &os, const Str &s)
    {
        for (Str::size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }

    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Ptr< Vec<char> > data;
};

class Picture;

class Pic_base
{
    friend class Frame_Pic;
    friend class HCat_Pic;
    friend class VCat_Pic;
    friend class String_Pic;
    friend class Picture;
    friend ostream &operator<<(ostream &, const Picture &);

    typedef vector<string>::size_type ht_sz;
    typedef string::size_type wd_sz;

    virtual wd_sz width() const = 0;
    virtual ht_sz height() const = 0;
    virtual void display(ostream &, ht_sz, bool) const = 0;
    virtual void reframe(const char, const char, const char) = 0;

protected:
    static void pad(ostream &os, wd_sz beg, wd_sz end);
};

class Frame_Pic : public Pic_base
{
    friend Picture frame(const Picture &);
    friend Picture frame(const Picture &, const char, const char, const char);

    Ptr<Pic_base> p;
    char corner;
    char top_bottom;
    char side;

    Frame_Pic(const Ptr<Pic_base> &pic, const char corner_val = '+',
              const char top_bottom_val = '-', const char side_val = '|')
        : p(pic), corner(corner_val), top_bottom(top_bottom_val), side(side_val) { }

    wd_sz width() const
    {
        return p->width() + 4;
    }
    ht_sz height() const
    {
        return p->height() + 4;
    }

    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char);
};

class VCat_Pic : public Pic_base
{
    friend Picture vcat(const Picture &, const Picture &);

    Ptr<Pic_base> top, bottom;

    VCat_Pic(const Ptr<Pic_base> &t, const Ptr<Pic_base> &b) : top(t), bottom(b) { }

    wd_sz width() const
    {
        return max(top->width(), bottom->width());
    }

    ht_sz height() const
    {
        return top->height() + bottom->height();
    }

    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char);
};

class HCat_Pic : public Pic_base
{
    friend Picture hcat(const Picture &, const Picture &);

    Ptr<Pic_base> left, right;

    HCat_Pic(const Ptr<Pic_base> &l, const Ptr<Pic_base> &r) : left(l), right(r) { }

    wd_sz width() const
    {
        return left->width() + right->width();
    }

    ht_sz height() const
    {
        return max(left->height(), right->height());
    }

    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char);
};

class String_Pic : public Pic_base
{
    friend class Picture;

    vector<string> data;
    String_Pic(const vector<string> &v) : data(v) { }

    wd_sz width() const;
    ht_sz height() const
    {
        return data.size();
    };
    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char) {}
};

class Picture
{
    friend Picture frame(const Picture &);
    friend Picture frame(const Picture &, const char, const char, const char);
    friend Picture hcat(const Picture &, const Picture &);
    friend Picture vcat(const Picture &, const Picture &);
    friend ostream &operator<<(ostream &, const Picture &);

public:
    Picture(const vector<string> & = vector<string>());
    void reframe(const char corner, const char top_bottom, const char side);

private:
    Ptr<Pic_base> p;

    Picture(Pic_base *ptr) : p(ptr) { }
};

Picture frame(const Picture &pic)
{
    return new Frame_Pic(pic.p);
}

Picture frame(const Picture &pic, const char corner_val, const char top_bottom_val, const char side_val)
{
    return new Frame_Pic(pic.p, corner_val, top_bottom_val, side_val);
}

Picture hcat(const Picture &l, const Picture &r)
{
    return new HCat_Pic(l.p, r.p);
}

Picture vcat(const Picture &t, const Picture &b)
{
    return new VCat_Pic(t.p, b.p);
}

Picture::Picture(const vector<string> &v) : p(new String_Pic(v)) { }

ostream &operator<<(ostream &os, const Picture &picture)
{
    const Pic_base::ht_sz ht = picture.p->height();
    for (Pic_base::ht_sz i = 0; i != ht; ++i)
    {
        picture.p->display(os, i, false);
        os << endl;
    }
    return os;
};

Pic_base::wd_sz String_Pic::width() const
{
    Pic_base::wd_sz n = 0;
    for (Pic_base::ht_sz i = 0; i != data.size(); ++i)
    {
        n = max(n, data[i].size());
    }
    return n;
}

void String_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz start = 0;
    if (row < height())
    {
        os << data[row];
        start = data[row].size();
    }
    if (do_pad)
    {
        pad(os, start, width());
    }
}

void VCat_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz w = 0;
    if (row < top->height())
    {
        top->display(os, row, do_pad);
        w = top->width();
    }
    else if (row < height())
    {
        bottom->display(os, row - top->height(), do_pad);
        w = bottom->width();
    }
    if (do_pad)
    {
        pad(os, w, width());
    }
}

void HCat_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    ht_sz left_row = row;
    ht_sz right_row = row;

    if (left->height() > right->height())
    {
        ht_sz index = ((left->height() - right->height()) / 2);

        if (row >= index)
        {
            right_row = row - index;
        }
        else
        {
            right_row = right->height();
        }
    }
    else
    {
        ht_sz index = ((right->height() - left->height()) / 2);

        if (row >= index)
        {
            left_row = row - index;
        }
        else
        {
            left_row = left->height();
        }
    }

    left->display(os, left_row, do_pad || right_row < right->height());
    right->display(os, right_row, do_pad);
}

void Frame_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    if (row >= height())
    {
        if (do_pad)
        {
            pad(os, 0, width());
        }
    }
    else
    {
        if (row == 0 || row == height() - 1)
        {
            os << corner << string(width() - 2, top_bottom) << corner;
        }
        else if (row == 1 || row == height() - 2)
        {
            os << side;
            pad(os, 1, width() - 1);
            os << side;
        }
        else
        {
            os << side << ' ';
            p->display(os, row - 2, true);
            os << ' ' << side;
        }
    }
}

void Pic_base::pad(ostream &os, wd_sz beg, wd_sz end)
{
    while (beg != end)
    {
        os << " ";
        ++beg;
    }
}

class Picture_v;

class Pic_base_v
{
    friend class Frame_Pic_v;
    friend class HCat_Pic_v;
    friend class VCat_Pic_v;
    friend class String_Pic_v;
    friend class Picture_v;
    friend ostream &operator<<(ostream &, const Picture_v &);

    typedef Vec<Str>::size_type ht_sz;
    typedef Str::size_type wd_sz;

    virtual wd_sz width() const = 0;
    virtual ht_sz height() const = 0;
    virtual void display(ostream &, ht_sz, bool) const = 0;

protected:
    static void pad(ostream &os, wd_sz beg, wd_sz end);
};

class Frame_Pic_v : public Pic_base_v
{
    friend Picture_v frame(const Picture_v &);

    Ptr<Pic_base_v> p;

    Frame_Pic_v(const Ptr<Pic_base_v> &pic) : p(pic) { }

    wd_sz width() const
    {
        return p->width() + 4;
    }
    ht_sz height() const
    {
        return p->height() + 4;
    }

    void display(ostream &, ht_sz, bool) const;
};

class VCat_Pic_v : public Pic_base_v
{
    friend Picture_v vcat(const Picture_v &, const Picture_v &);

    Ptr<Pic_base_v> top, bottom;

    VCat_Pic_v(const Ptr<Pic_base_v> &t, const Ptr<Pic_base_v> &b) : top(t), bottom(b) { }

    wd_sz width() const
    {
        return max(top->width(), bottom->width());
    }

    ht_sz height() const
    {
        return top->height() + bottom->height();
    }

    void display(ostream &, ht_sz, bool) const;
};

class HCat_Pic_v : public Pic_base_v
{
    friend Picture_v hcat(const Picture_v &, const Picture_v &);

    Ptr<Pic_base_v> left, right;

    HCat_Pic_v(const Ptr<Pic_base_v> &l, const Ptr<Pic_base_v> &r) : left(l), right(r) { }

    wd_sz width() const
    {
        return left->width() + right->width();
    }

    ht_sz height() const
    {
        return max(left->height(), right->height());
    }

    void display(ostream &, ht_sz, bool) const;
};

class String_Pic_v : public Pic_base_v
{
    friend class Picture_v;

    Vec<Str> data;
    String_Pic_v(const Vec<Str> &v) : data(v) { }

    wd_sz width() const;
    ht_sz height() const
    {
        return data.size();
    };
    void display(ostream &, ht_sz, bool) const;
};

class Picture_v
{
    friend Picture_v frame(const Picture_v &);
    friend Picture_v hcat(const Picture_v &, const Picture_v &);
    friend Picture_v vcat(const Picture_v &, const Picture_v &);
    friend ostream &operator<<(ostream &, const Picture_v &);

public:
    Picture_v(const Vec<Str> & = Vec<Str>());

private:
    Ptr<Pic_base_v> p;
    Picture_v(Pic_base_v *ptr) : p(ptr) { }
};

Picture_v frame(const Picture_v &pic)
{
    return new Frame_Pic_v(pic.p);
}

Picture_v hcat(const Picture_v &l, const Picture_v &r)
{
    return new HCat_Pic_v(l.p, r.p);
}

Picture_v vcat(const Picture_v &t, const Picture_v &b)
{
    return new VCat_Pic_v(t.p, b.p);
}

Picture_v::Picture_v(const Vec<Str> &v) : p(new String_Pic_v(v)) { }

ostream &operator<<(ostream &os, const Picture_v &picture_v)
{
    const Pic_base_v::ht_sz ht = picture_v.p->height();
    for (Pic_base_v::ht_sz i = 0; i != ht; ++i)
    {
        picture_v.p->display(os, i, false);
        os << endl;
    }
    return os;
};

Pic_base_v::wd_sz String_Pic_v::width() const
{
    Pic_base_v::wd_sz n = 0;
    for (Pic_base_v::ht_sz i = 0; i != data.size(); ++i)
    {
        n = max(n, data[i].size());
    }
    return n;
}

void String_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz start = 0;
    if (row < height())
    {
        os << data[row];
        start = data[row].size();
    }
    if (do_pad)
    {
        pad(os, start, width());
    }
}

void VCat_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz w = 0;
    if (row < top->height())
    {
        top->display(os, row, do_pad);
        w = top->width();
    }
    else if (row < height())
    {
        bottom->display(os, row - top->height(), do_pad);
        w = bottom->width();
    }
    if (do_pad)
    {
        pad(os, w, width());
    }
}

void HCat_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    left->display(os, row, do_pad || row < right->height());
    right->display(os, row, do_pad);
}

void Frame_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    if (row >= height())
    {
        if (do_pad)
        {
            pad(os, 0, width());
        }
    }
    else
    {
        if (row == 0 || row == height() - 1)
        {
            os << Str(width(), '*');
        }
        else if (row == 1 || row == height() - 2)
        {
            os << '*';
            pad(os, 1, width() - 1);
            os << '*';
        }
        else
        {
            os << "* ";
            p->display(os, row - 2, true);
            os << " *";
        }
    }
}

void Pic_base_v::pad(ostream &os, wd_sz beg, wd_sz end)
{
    while (beg != end)
    {
        os << " ";
        ++beg;
    }
}

void Frame_Pic::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    this->corner = corner_val;
    this->top_bottom = top_bottom_val;
    this->side = side_val;

    p->reframe(corner_val, top_bottom_val, side_val);
}

void VCat_Pic::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    top->reframe(corner_val, top_bottom_val, side_val);
    bottom->reframe(corner_val, top_bottom_val, side_val);
}

void HCat_Pic::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    left->reframe(corner_val, top_bottom_val, side_val);
    right->reframe(corner_val, top_bottom_val, side_val);
}

void Picture::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    p->reframe(corner_val, top_bottom_val, side_val);
}

int main()
{
    Vec<Str> v1;
    v1.push_back("one test");
    v1.push_back("greeting");
    v1.push_back("how are you?");

    Picture_v p = v1;
    Picture_v q = frame(p);
    Picture_v r = hcat(p, q);
    Picture_v s = vcat(q, r);
    cout << frame(hcat(s, vcat(r, q))) << endl;

    return 0;
}
显示结果如下
************************************************************
*                                                          *
* ****************            one test    **************** *
* *              *            greeting    *              * *
* * one test     *            how are you?* one test     * *
* * greeting     *                        * greeting     * *
* * how are you? *                        * how are you? * *
* *              *                        *              * *
* ****************                        **************** *
* one test    ********************************             *
* greeting    *              **              *             *
* how are you?* one test     ** one test     *             *
*             * greeting     ** greeting     *             *
*             * how are you? ** how are you? *             *
*             *              **              *             *
*             ********************************             *
*                                                          *
************************************************************

第16章 今后如何学习C++
16.1 好好地利用你已经掌握的知识
16.2 学习更多的东西
习题
16-0编译、运行并测试本章的例程。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

template <typename T>
class Handle
{
public:
    Handle() : p(nullptr) { }
    Handle(T *t) : p(t) { }
    Handle(const Handle<T> &s) : p(nullptr)
    {
        if (s.p != nullptr)
        {
            p = s.p->clone();
        }
    }

    Handle<T> &operator=(const Handle<T> &);
    ~Handle()
    {
        delete p;
    }

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const;
    T *operator->() const;

private:
    T *p;
};

template<typename T>
Handle<T> &Handle<T>::operator=(const Handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    delete p;
    p = rhs.p != nullptr ? rhs.p->clone() : nullptr;
    return *this;
}

template <typename T>
T &Handle<T>::operator*() const
{
    if (p != nullptr)
    {
        return *p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
T *Handle<T>::operator->() const
{
    if (p != nullptr)
    {
        return p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
class Ref_handle
{
public:
    Ref_handle() : refptr(new size_t(1)), p(nullptr) { }
    Ref_handle(T *t) : refptr(new size_t(1)), p(t) { }

    Ref_handle(const Ref_handle<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ref_handle<T> &operator=(const Ref_handle<T> &);

    ~Ref_handle();

    operator bool() const
    {
        return p != nullptr;
    }
    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ref_handle");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ref_handle");
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ref_handle<T> &Ref_handle<T>::operator=(const Ref_handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;

    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }

    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ref_handle<T>::~Ref_handle()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

class Ref_counter
{
public:
    Ref_counter() : counter(new size_t(1)) { };
    Ref_counter(size_t s) : counter(new size_t(s)) { };
    Ref_counter(const Ref_counter &r) : counter(r.counter) { };

    Ref_counter &operator=(const Ref_counter &rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        if (*counter <= 0)
        {
            delete counter;
        }
        counter = rhs.counter;
        return *this;
    };

    Ref_counter &operator++()
    {
        (*counter)++;
        return *this;
    };

    Ref_counter &operator--()
    {
        (*counter)--;
        return *this;
    };

    Ref_counter operator++(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)++;
        return ret;
    };

    Ref_counter operator--(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)--;
        return ret;
    };

    ~Ref_counter()
    {
        if (*counter <= 0)
        {
            delete counter;
        }
    };

    size_t count()
    {
        return *counter;
    };

private:
    size_t *counter;
};


template<typename T>
T *clone(const T *tp)
{
    return tp->clone();
}

template<typename T>
class Ptr
{
public:
    Ptr() : refptr(new size_t(1)), p(nullptr) { }
    Ptr(T *t) : refptr(new size_t(1)), p(t) { }
    Ptr(const Ptr<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ptr<T> &operator=(const Ptr<T> &);
    ~Ptr();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr");
    }

    void make_unique()
    {
        if (*refptr > 1)
        {
            --*refptr;
            refptr = new size_t(1);
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ptr<T> &Ptr<T>::operator=(const Ptr<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ptr<T>::~Ptr()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

template<typename T>
class Ptr_r
{
public:
    Ptr_r() : p(nullptr) { }
    Ptr_r(T *t) : p(t) { }
    Ptr_r(const Ptr_r<T> &h) : ref_c(h.ref_c), p(h.p)
    {
        ++ref_c;
    }

    Ptr_r<T> &operator=(const Ptr_r<T> &);
    ~Ptr_r();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    void make_unique()
    {
        if (ref_c.count() > 1)
        {
            --ref_c;
            ref_c = Ref_counter();
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    Ref_counter ref_c;
};

template<typename T>
Ptr_r<T> &Ptr_r<T>::operator=(const Ptr_r<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
    ref_c = rhs.ref_c;
    p = rhs.p;
    ++ref_c;
    return *this;
}

template<typename T>
Ptr_r<T>::~Ptr_r()
{
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
}

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

template<>
inline Vec<char> *clone< Vec<char> >(const Vec<char> *vp)
{
    return new Vec<char>(*vp);
}

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() : data(new Vec<char>) { }
    Str(size_type n, char c) : data(new Vec<char>(n, c)) { }
    Str(const char *cp) : data(new Vec<char>)
    {
        copy(cp, cp + strlen(cp), back_inserter(*data));
    }
    template<class In>
    Str(In b, In e) : data(new Vec<char>(b, e)) { }

    size_type size() const
    {
        return data->size();
    }

    char &operator[](size_type i)
    {
        data.make_unique();
        return (*data)[i];
    }

    const char &operator[](size_type i) const
    {
        return (*data)[i];
    }

    Str &operator+=(const Str &s)
    {
        data.make_unique();
        copy(s.data->begin(), s.data->end(), back_inserter(*data));
        return *this;
    }

    iterator begin()
    {
        return data->begin();
    };
    const_iterator begin() const
    {
        return data->begin();
    };
    iterator end()
    {
        return data->end();
    };
    const_iterator end() const
    {
        return data->end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data->clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data->push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }

    friend ostream &operator<< (ostream &os, const Str &s)
    {
        for (Str::size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }

    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Ptr< Vec<char> > data;
};

class Picture;

class Pic_base
{
    friend class Frame_Pic;
    friend class HCat_Pic;
    friend class VCat_Pic;
    friend class String_Pic;
    friend class Picture;
    friend ostream &operator<<(ostream &, const Picture &);

    typedef vector<string>::size_type ht_sz;
    typedef string::size_type wd_sz;

    virtual wd_sz width() const = 0;
    virtual ht_sz height() const = 0;
    virtual void display(ostream &, ht_sz, bool) const = 0;
    virtual void reframe(const char, const char, const char) = 0;

protected:
    static void pad(ostream &os, wd_sz beg, wd_sz end);
};

class Frame_Pic : public Pic_base
{
    friend Picture frame(const Picture &);
    friend Picture frame(const Picture &, const char, const char, const char);

    Ptr<Pic_base> p;
    char corner;
    char top_bottom;
    char side;

    Frame_Pic(const Ptr<Pic_base> &pic, const char corner_val = '+',
              const char top_bottom_val = '-', const char side_val = '|')
        : p(pic), corner(corner_val), top_bottom(top_bottom_val), side(side_val) { }

    wd_sz width() const
    {
        return p->width() + 4;
    }
    ht_sz height() const
    {
        return p->height() + 4;
    }

    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char);
};

class VCat_Pic : public Pic_base
{
    friend Picture vcat(const Picture &, const Picture &);

    Ptr<Pic_base> top, bottom;

    VCat_Pic(const Ptr<Pic_base> &t, const Ptr<Pic_base> &b) : top(t), bottom(b) { }

    wd_sz width() const
    {
        return max(top->width(), bottom->width());
    }

    ht_sz height() const
    {
        return top->height() + bottom->height();
    }

    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char);
};

class HCat_Pic : public Pic_base
{
    friend Picture hcat(const Picture &, const Picture &);

    Ptr<Pic_base> left, right;

    HCat_Pic(const Ptr<Pic_base> &l, const Ptr<Pic_base> &r) : left(l), right(r) { }

    wd_sz width() const
    {
        return left->width() + right->width();
    }

    ht_sz height() const
    {
        return max(left->height(), right->height());
    }

    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char);
};

class String_Pic : public Pic_base
{
    friend class Picture;

    vector<string> data;
    String_Pic(const vector<string> &v) : data(v) { }

    wd_sz width() const;
    ht_sz height() const
    {
        return data.size();
    };
    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char) {}
};

class Picture
{
    friend Picture frame(const Picture &);
    friend Picture frame(const Picture &, const char, const char, const char);
    friend Picture hcat(const Picture &, const Picture &);
    friend Picture vcat(const Picture &, const Picture &);
    friend ostream &operator<<(ostream &, const Picture &);

public:
    Picture(const vector<string> & = vector<string>());
    void reframe(const char corner, const char top_bottom, const char side);

private:
    Ptr<Pic_base> p;

    Picture(Pic_base *ptr) : p(ptr) { }
};

Picture frame(const Picture &pic)
{
    return new Frame_Pic(pic.p);
}

Picture frame(const Picture &pic, const char corner_val, const char top_bottom_val, const char side_val)
{
    return new Frame_Pic(pic.p, corner_val, top_bottom_val, side_val);
}

Picture hcat(const Picture &l, const Picture &r)
{
    return new HCat_Pic(l.p, r.p);
}

Picture vcat(const Picture &t, const Picture &b)
{
    return new VCat_Pic(t.p, b.p);
}

Picture::Picture(const vector<string> &v) : p(new String_Pic(v)) { }

ostream &operator<<(ostream &os, const Picture &picture)
{
    const Pic_base::ht_sz ht = picture.p->height();
    for (Pic_base::ht_sz i = 0; i != ht; ++i)
    {
        picture.p->display(os, i, false);
        os << endl;
    }
    return os;
};

Pic_base::wd_sz String_Pic::width() const
{
    Pic_base::wd_sz n = 0;
    for (Pic_base::ht_sz i = 0; i != data.size(); ++i)
    {
        n = max(n, data[i].size());
    }
    return n;
}

void String_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz start = 0;
    if (row < height())
    {
        os << data[row];
        start = data[row].size();
    }
    if (do_pad)
    {
        pad(os, start, width());
    }
}

void VCat_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz w = 0;
    if (row < top->height())
    {
        top->display(os, row, do_pad);
        w = top->width();
    }
    else if (row < height())
    {
        bottom->display(os, row - top->height(), do_pad);
        w = bottom->width();
    }
    if (do_pad)
    {
        pad(os, w, width());
    }
}

void HCat_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    ht_sz left_row = row;
    ht_sz right_row = row;

    if (left->height() > right->height())
    {
        ht_sz index = ((left->height() - right->height()) / 2);

        if (row >= index)
        {
            right_row = row - index;
        }
        else
        {
            right_row = right->height();
        }
    }
    else
    {
        ht_sz index = ((right->height() - left->height()) / 2);

        if (row >= index)
        {
            left_row = row - index;
        }
        else
        {
            left_row = left->height();
        }
    }

    left->display(os, left_row, do_pad || right_row < right->height());
    right->display(os, right_row, do_pad);
}

void Frame_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    if (row >= height())
    {
        if (do_pad)
        {
            pad(os, 0, width());
        }
    }
    else
    {
        if (row == 0 || row == height() - 1)
        {
            os << corner << string(width() - 2, top_bottom) << corner;
        }
        else if (row == 1 || row == height() - 2)
        {
            os << side;
            pad(os, 1, width() - 1);
            os << side;
        }
        else
        {
            os << side << ' ';
            p->display(os, row - 2, true);
            os << ' ' << side;
        }
    }
}

void Pic_base::pad(ostream &os, wd_sz beg, wd_sz end)
{
    while (beg != end)
    {
        os << " ";
        ++beg;
    }
}

class Picture_v;

class Pic_base_v
{
    friend class Frame_Pic_v;
    friend class HCat_Pic_v;
    friend class VCat_Pic_v;
    friend class String_Pic_v;
    friend class Picture_v;
    friend ostream &operator<<(ostream &, const Picture_v &);

    typedef Vec<Str>::size_type ht_sz;
    typedef Str::size_type wd_sz;

    virtual wd_sz width() const = 0;
    virtual ht_sz height() const = 0;
    virtual void display(ostream &, ht_sz, bool) const = 0;

protected:
    static void pad(ostream &os, wd_sz beg, wd_sz end);
};

class Frame_Pic_v : public Pic_base_v
{
    friend Picture_v frame(const Picture_v &);

    Ptr<Pic_base_v> p;

    Frame_Pic_v(const Ptr<Pic_base_v> &pic) : p(pic) { }

    wd_sz width() const
    {
        return p->width() + 4;
    }
    ht_sz height() const
    {
        return p->height() + 4;
    }

    void display(ostream &, ht_sz, bool) const;
};

class VCat_Pic_v : public Pic_base_v
{
    friend Picture_v vcat(const Picture_v &, const Picture_v &);

    Ptr<Pic_base_v> top, bottom;

    VCat_Pic_v(const Ptr<Pic_base_v> &t, const Ptr<Pic_base_v> &b) : top(t), bottom(b) { }

    wd_sz width() const
    {
        return max(top->width(), bottom->width());
    }

    ht_sz height() const
    {
        return top->height() + bottom->height();
    }

    void display(ostream &, ht_sz, bool) const;
};

class HCat_Pic_v : public Pic_base_v
{
    friend Picture_v hcat(const Picture_v &, const Picture_v &);

    Ptr<Pic_base_v> left, right;

    HCat_Pic_v(const Ptr<Pic_base_v> &l, const Ptr<Pic_base_v> &r) : left(l), right(r) { }

    wd_sz width() const
    {
        return left->width() + right->width();
    }

    ht_sz height() const
    {
        return max(left->height(), right->height());
    }

    void display(ostream &, ht_sz, bool) const;
};

class String_Pic_v : public Pic_base_v
{
    friend class Picture_v;

    Vec<Str> data;
    String_Pic_v(const Vec<Str> &v) : data(v) { }

    wd_sz width() const;
    ht_sz height() const
    {
        return data.size();
    };
    void display(ostream &, ht_sz, bool) const;
};

class Picture_v
{
    friend Picture_v frame(const Picture_v &);
    friend Picture_v hcat(const Picture_v &, const Picture_v &);
    friend Picture_v vcat(const Picture_v &, const Picture_v &);
    friend ostream &operator<<(ostream &, const Picture_v &);

public:
    Picture_v(const Vec<Str> & = Vec<Str>());

private:
    Ptr<Pic_base_v> p;
    Picture_v(Pic_base_v *ptr) : p(ptr) { }
};

Picture_v frame(const Picture_v &pic)
{
    return new Frame_Pic_v(pic.p);
}

Picture_v hcat(const Picture_v &l, const Picture_v &r)
{
    return new HCat_Pic_v(l.p, r.p);
}

Picture_v vcat(const Picture_v &t, const Picture_v &b)
{
    return new VCat_Pic_v(t.p, b.p);
}

Picture_v::Picture_v(const Vec<Str> &v) : p(new String_Pic_v(v)) { }

ostream &operator<<(ostream &os, const Picture_v &picture_v)
{
    const Pic_base_v::ht_sz ht = picture_v.p->height();
    for (Pic_base_v::ht_sz i = 0; i != ht; ++i)
    {
        picture_v.p->display(os, i, false);
        os << endl;
    }
    return os;
};

Pic_base_v::wd_sz String_Pic_v::width() const
{
    Pic_base_v::wd_sz n = 0;
    for (Pic_base_v::ht_sz i = 0; i != data.size(); ++i)
    {
        n = max(n, data[i].size());
    }
    return n;
}

void String_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz start = 0;
    if (row < height())
    {
        os << data[row];
        start = data[row].size();
    }
    if (do_pad)
    {
        pad(os, start, width());
    }
}

void VCat_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz w = 0;
    if (row < top->height())
    {
        top->display(os, row, do_pad);
        w = top->width();
    }
    else if (row < height())
    {
        bottom->display(os, row - top->height(), do_pad);
        w = bottom->width();
    }
    if (do_pad)
    {
        pad(os, w, width());
    }
}

void HCat_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    left->display(os, row, do_pad || row < right->height());
    right->display(os, row, do_pad);
}

void Frame_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    if (row >= height())
    {
        if (do_pad)
        {
            pad(os, 0, width());
        }
    }
    else
    {
        if (row == 0 || row == height() - 1)
        {
            os << Str(width(), '*');
        }
        else if (row == 1 || row == height() - 2)
        {
            os << '*';
            pad(os, 1, width() - 1);
            os << '*';
        }
        else
        {
            os << "* ";
            p->display(os, row - 2, true);
            os << " *";
        }
    }
}

void Pic_base_v::pad(ostream &os, wd_sz beg, wd_sz end)
{
    while (beg != end)
    {
        os << " ";
        ++beg;
    }
}

void Frame_Pic::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    this->corner = corner_val;
    this->top_bottom = top_bottom_val;
    this->side = side_val;

    p->reframe(corner_val, top_bottom_val, side_val);
}

void VCat_Pic::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    top->reframe(corner_val, top_bottom_val, side_val);
    bottom->reframe(corner_val, top_bottom_val, side_val);
}

void HCat_Pic::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    left->reframe(corner_val, top_bottom_val, side_val);
    right->reframe(corner_val, top_bottom_val, side_val);
}

void Picture::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    p->reframe(corner_val, top_bottom_val, side_val);
}

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

class Core
{
public:
    friend class Student_info;
    friend class Audit;
    Core() : midterm(0), final(0)
    {
        cerr << "constructor Core()" << endl;
    }
    Core(istream &is)
    {
        cerr << "constructor Core(istream &is)" << endl;
        read(is);
    }

    virtual ~Core()
    {
        cerr << "destructor ~Core()" << endl;
    }

    const string &name() const
    {
        return _name;
    }
    virtual double grade() const
    {
        return ::grade(midterm, final, homework);
    }
    string letter_grade() const;
    virtual istream &read(istream &);

    bool valid() const
    {
        return !homework.empty();
    }
    virtual bool requirements_met() const
    {
        return find(homework.begin(), homework.end(), 0.0) == homework.end();
    }
    virtual Core *clone() const
    {
        return new Core(*this);
    }

protected:
    istream &read_common(istream &in)
    {
        in >> _name >> midterm >> final;
        return in;
    }
    double midterm, final;
    vector<double> homework;

private:
    string _name;
};

istream &Core::read(istream &in)
{
    read_common(in);
    read_hw(in, homework);
    return in;
}

string Core::letter_grade() const
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };

    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };

    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);

    double result = grade();

    for (size_t i = 0; i < ngrades; ++i)
    {
        if (result >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

inline bool compare(const Core &c1, const Core &c2)
{
    return c1.name() < c2.name();
}

inline bool compare_Core_ptrs(const Core *cp1, const Core *cp2)
{
    return compare(*cp1, *cp2);
}

class Grad : public Core
{
public:
    Grad() : thesis(0.0)
    {
        cerr << "constructor Grad()" << endl;
    }
    Grad(istream &is)
    {
        cerr << "constructor Grad(istream &is)" << endl;
        read(is);
    }

    ~Grad()
    {
        cerr << "destructor ~Grad()" << endl;
    }
    double grade() const;
    istream &read(istream &);

    bool requirements_met() const
    {
        return Core::requirements_met() && thesis != 0.0;
    }
    Grad *clone() const
    {
        return new Grad(*this);
    }

protected:

private:
    double thesis;
};

istream &Grad::read(istream &in)
{
    Core::read_common(in);
    in >> Grad::thesis;
    read_hw(in, Core::homework);
    return in;
}

double Grad::grade() const
{
    return min(Core::grade(), Grad::thesis);
}

class Credit : public Core
{
public:
    Credit() {}
    Credit(istream &is) : Core(is) {}

    double grade() const;
    bool passed() const
    {
        return grade() >= 60;
    }

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }
    Credit *clone() const
    {
        return new Credit(*this);
    }

protected:
};

double Credit::grade() const
{
    if (Core::homework.empty())
    {
        return (midterm + final) / 2.0;
    }
    else
    {
        return Core::grade();
    }
}

class Audit : public Core
{
public:
    Audit() {}
    Audit(istream &is)
    {
        read(is);
    }

    istream &read(istream &in)
    {
        in >> _name;
        return in;
    }

    double grade() const
    {
        return 0.0;
    };

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }
    Audit *clone() const
    {
        return new Audit(*this);
    }

protected:
};

class Student_info
{
public:
    Student_info() { }
    Student_info(istream &is)
    {
        read(is);
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Handle<Core> cp;
};

istream &Student_info::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

inline bool compare_info(const Student_info &s1, const Student_info &s2)
{
    return s1.name() < s2.name();
}

class Student_info_p
{
public:
    Student_info_p() { }
    Student_info_p(istream &is)
    {
        read(is);
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Ptr<Core> cp;
};

istream &Student_info_p::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

inline bool compare_info_p(const Student_info_p &s1, const Student_info_p &s2)
{
    return s1.name() < s2.name();
}

inline bool compare_Core_handles(const Handle<Core> hc1, const Handle<Core> hc2)
{
    return compare(*hc1, *hc2);
}

inline bool compare_Core_Ptr(const Ptr<Core> hc1, const Ptr<Core> hc2)
{
    return compare(*hc1, *hc2);
}

inline bool compare_Core_Ptr_r(const Ptr_r<Core> hc1, const Ptr_r<Core> hc2)
{
    return compare(*hc1, *hc2);
}

Picture histogram(const vector<Student_info> &students)
{
    Picture names;
    Picture grades;
    for (vector<Student_info>::const_iterator it = students.begin(); it != students.end(); ++it)
    {
        names = vcat(names, vector<string>(1, it->name()));
        grades = vcat(grades, vector<string>(1, " " + string((int)it->grade() / 5, '=')));
    }
    return hcat(names, grades);
}

int main()
{
    vector<Student_info> students;
    Student_info record;
    while (record.read(cin))
    {
        students.push_back(record);
    }
    sort(students.begin(), students.end(), compare_info);
    cout << frame(histogram(students)) << endl;

    return 0;
}
显示结果如下
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
U
new Core
constructor Core(istream &is)
Geert 50 80 90 45 30 80 end
destructor ~Core()
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
G
new Grad
constructor Core()
constructor Grad(istream &is)
Joris 80 90 62 60 70 60 70 60 end
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
U
new Core
constructor Core(istream &is)
Pieter 40 50 30 40 50 50 40 end
destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
G
new Grad
constructor Core()
constructor Grad(istream &is)
Lotte 40 80 62 90 45 60 70 end
destructor ~Core()
destructor ~Grad()
destructor ~Core()
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
destructor ~Grad()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
+----------------------+
|                      |
| Geert  ============= |
| Joris  ============  |
| Lotte  ============  |
| Pieter ========      |
|                      |
+----------------------+

destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()

16-1 写一个自我复制的程序，这个程序没有输入，它在运行的时候复制一份自己的源代码，并把代码写入cout输出流里。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

int main()
{
    vector<string> v =
    {
        "/**",
        "Accelerated C++, Exercise 16-1, 16_1.cpp",
        "",
        "Write a self-reproducing program. Such a program is one",
        "that does no input, and that, when run, writes a copy of",
        "its own source text on the standard output stream.",
        "*/",
        "",
        {35, 105, 110, 99, 108, 117, 100, 101, 32, 34, 115, 116, 100, 97, 102, 120, 46, 104, 34},
        {35, 105, 110, 99, 108, 117, 100, 101, 32, 34, 49, 54, 95, 49, 46, 104, 34},
        "",
        "#include <vector>",
        "#include <string>",
        "#include <iostream>",
        "",
        "int ex16_1()",
        "{",
        "std::vector<std::string> v = { ",
        "};",
        "",
        "for (size_t i = 0; i < 18; i++)",
        "std::cout << v[i] << std::endl;",
        "",
        "for (size_t i = 0; i < v.size(); i++)",
        "if (i == 8 || i == 9)",
        "{",
        "std::cout << (char)9 << (char)123 << (int)v[i][0];",
        "for (size_t j = 1; j < v[i].size(); j++)",
        "std::cout << (char)44 << (int)v[i][j];",
        "std::cout << (char)125 << (char)44 << std::endl;",
        "}",
        "else",
        "std::cout << (char)9 << (char)34 << v[i]",
        "<< (char)34 << (char)44 << std::endl;",
        "",
        "for (size_t i = 18; i < v.size(); i++)",
        "std::cout << v[i] << std::endl;",
        "",
        "return 0;",
        "}"
    };

    for (size_t i = 0; i < 18; i++)
        std::cout << v[i] << std::endl;

    for (size_t i = 0; i < v.size(); i++)
        if (i == 8 || i == 9)
        {
            std::cout << (char)9 << (char)123 << (int)v[i][0];
            for (size_t j = 1; j < v[i].size(); j++)
                std::cout << (char)44 << (int)v[i][j];
            std::cout << (char)125 << (char)44 << std::endl;
        }
        else
            std::cout << (char)9 << (char)34 << v[i]
                      << (char)34 << (char)44 << std::endl;

    for (size_t i = 18; i < v.size(); i++)
        std::cout << v[i] << std::endl;

    return 0;
}
显示结果如下
/**
Accelerated C++, Exercise 16-1, 16_1.cpp

Write a self-reproducing program. Such a program is one
that does no input, and that, when run, writes a copy of
its own source text on the standard output stream.
*/

#include "stdafx.h"
#include "16_1.h"

#include <vector>
#include <string>
#include <iostream>

int ex16_1()
{
std::vector<std::string> v = {
        "/**",
        "Accelerated C++, Exercise 16-1, 16_1.cpp",
        "",
        "Write a self-reproducing program. Such a program is one",
        "that does no input, and that, when run, writes a copy of",
        "its own source text on the standard output stream.",
        "*/",
        "",
        {35,105,110,99,108,117,100,101,32,34,115,116,100,97,102,120,46,104,34},
        {35,105,110,99,108,117,100,101,32,34,49,54,95,49,46,104,34},
        "",
        "#include <vector>",
        "#include <string>",
        "#include <iostream>",
        "",
        "int ex16_1()",
        "{",
        "std::vector<std::string> v = { ",
        "};",
        "",
        "for (size_t i = 0; i < 18; i++)",
        "std::cout << v[i] << std::endl;",
        "",
        "for (size_t i = 0; i < v.size(); i++)",
        "if (i == 8 || i == 9)",
        "{",
        "std::cout << (char)9 << (char)123 << (int)v[i][0];",
        "for (size_t j = 1; j < v[i].size(); j++)",
        "std::cout << (char)44 << (int)v[i][j];",
        "std::cout << (char)125 << (char)44 << std::endl;",
        "}",
        "else",
        "std::cout << (char)9 << (char)34 << v[i]",
        "<< (char)34 << (char)44 << std::endl;",
        "",
        "for (size_t i = 18; i < v.size(); i++)",
        "std::cout << v[i] << std::endl;",
        "",
        "return 0;",
        "}",
};

for (size_t i = 0; i < 18; i++)
std::cout << v[i] << std::endl;

for (size_t i = 0; i < v.size(); i++)
if (i == 8 || i == 9)
{
std::cout << (char)9 << (char)123 << (int)v[i][0];
for (size_t j = 1; j < v[i].size(); j++)
std::cout << (char)44 << (int)v[i][j];
std::cout << (char)125 << (char)44 << std::endl;
}
else
std::cout << (char)9 << (char)34 << v[i]
<< (char)34 << (char)44 << std::endl;

for (size_t i = 18; i < v.size(); i++)
std::cout << v[i] << std::endl;

return 0;
}

C++程序设计原理与实践 第一版 Programming Principles and Practice Using C++
第一部分基本知识
第2章 Hello, World!
2.1 程序
2.2 经典的第一个程序
2.3 编译
2.4 链接
2.5 编程环境
ch02_b01.cpp
#include <iostream>

using std::cout;

int main()
{
    cout << "Hello, World!\n";
    return 0;
}
显示结果如下
Hello, World!

第3章 对象、类型和值
3.1 输入
3.2 变量
3.3 输入和类型
3.4 运算和运算符
3.5 赋值和初始化
3.5.1 实例：删除重复单词
3.6 组合赋值运算符
3.6.1 实例：重复单词统计
3.7 命名
3.8 类型和对象
3.9 类型安全
3.9.1 安全类型转换
3.9.2 不安全类型转换
ch03_b01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    cout << "Please enter your first name (followed by 'enter'):\n";
    string first_name;
    cin >> first_name;
    cout << "Hello, " << first_name << "!\n";
    cout << "first_name" << " is " << first_name << endl;
}
显示结果如下
Please enter your first name (followed by 'enter'):
Peter
Hello, Peter!
first_name is Peter

ch03_b02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    int number_of_steps = 39;
    double flying_time = 3.5;
    char decimal_point = '.';
    string name = "Annemarie";
    bool tap_on = true;

    cout << number_of_steps << ", "
         << flying_time << ", "
         << decimal_point << ", "
         << name << ", "
         << tap_on << endl;
}
显示结果如下
39, 3.5, ., Annemarie, 1

ch03_b03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    cout << "please enter your first_name and age\n";
    string first_name = "?\?\?";
    int age = -1;
    cin >> first_name >> age;
    cout << "Hello, " << first_name << " (age " << age << ")\n";

    cout << "please enter your first and second names\n";
    string first;
    string second;
    cin >> first >> second;
    cout << "Hello, " << first << ' ' << second << '\n';
}
显示结果如下
please enter your first_name and age
Peter 23
Hello, Peter (age 23)
please enter your first and second names
Peter Smith
Hello, Peter Smith

ch03_b04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    int count;
    cin >> count;
    string name;
    cin >> name;

    int c2 = count + 2;
    string s2 = name + " Jr. ";

    int c3 = count - 2;
    int age = -100;

    cout << count << ", "
         << name << ", "
         << c2 << ", "
         << s2 << ", "
         << c3 << ", "
         << age << endl;

    cout << "please enter a floating-point value: ";
    double n;
    cin >> n;
    cout << "n == " << n
         << "\nn+1 == " << n + 1
         << "\nthree times n == " << 3 * n
         << "\ntwice n == " << n + n
         << "\nn squared == " << n *n
         << "\nhalf of n == " << n / 2
         << "\nsquare root of n == " << sqrt(n)
         << endl;

    cout << "please enter your first and second names\n";
    string first;
    string second;
    cin >> first >> second;
    name = first + ' ' + second;
    cout << "Hello, " << name << '\n';

    if (first == second)
    {
        cout << "that's the same name twice\n";
    }
    else if (first < second)
    {
        cout << first << " is alphabetically before " << second << '\n';
    }
    else
    {
        cout << first << " is alphabetically after " << second << '\n';
    }
}
显示结果如下
23 Peter
23, Peter, 25, Peter Jr. , 21, -100
please enter a floating-point value: 3.5
n == 3.5
n+1 == 4.5
three times n == 10.5
twice n == 7
n squared == 12.25
half of n == 1.75
square root of n == 1.87083
please enter your first and second names
Peter Smith
Hello, Peter Smith
Peter is alphabetically before Smith

ch03_b05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    {
        int a = 3;
        a = 4;
        int b = a;
        b = a + 5;
        a = a + 7;
        cout << a << ", " << b << endl;
    }

    {
        string a = "alpha";
        a = "beta";
        string b = a;
        b = a + "gamma";
        a = a + "delta";
        cout << a << ", " << b << endl;
    }

    {
        int y = 8;
        int x;

        x = 9;
        cout << x << ", " << y << endl;

        string t = "howdy!";
        string s;

        s = "G'day";
        cout << s << ", " << t << endl;
    }

    string previous = " ";
    string current;
    while (cin >> current)
    {
        if (previous == current)
        {
            cout << "repeated word: " << current << '\n';
        }
        previous = current;
    }
}
显示结果如下
11, 9
betadelta, betagamma
9, 8
G'day, howdy!
Peter Smith Smith Peter Peter Smith
repeated word: Smith
repeated word: Peter

ch03_b06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    int number_of_words = 0;
    string previous = " ";
    string current;
    while (cin >> current)
    {
        ++number_of_words;
        if (previous == current)
        {
            cout << "word number " << number_of_words << " repeated: " << current << '\n';
        }
        previous = current;
    }
}
显示结果如下
Peter Smith Smith Peter Peter Smith
word number 3 repeated: Smith
word number 5 repeated: Peter

ch03_b07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    string s = "Goodbye, cruel world! ";
    cout << s << '\n';
}
显示结果如下
Goodbye, cruel world!
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    int a = 7;
    int b = 9;
    char c = 'a';
    double x = 1.2;
    string s1 = "Hello, world";
    string s2 = "1.2";
    cout << a << ", " << b << ", " << c << ", " << x << endl;
    cout << s1 << ", " << s2 << endl;
}
显示结果如下
7, 9, a, 1.2
Hello, world, 1.2

ch03_b09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    double x = 1.5;
    double y = x;
    double z = 2.0 + x;

    cout << x << ", " << y << ", " << z << endl;

    char c1 = 'x';
    int i1 = c1;
    int i2 = 'x';
    char c2 = i1;

    cout << c1 << ", " << i1 << ", " << i2 << ", " << c2 << endl;

    double d1 = 2.3;
    double d2 = d1 + 2;

    cout << d1 << ", " << d2 << endl;

    if (d1 < 0)
    {
        error("d1 is negative");
    }

    int a = 20000;
    char c = a;
    int b = c;

    cout << a << ", " << b << ", " << c << endl;

    if (a != b)
    {
        cout << "oops!: " << a << "!=" << b << '\n';
    }
    else
    {
        cout << "Wow! We have large characters\n";
    }

    {
        double d = 0;
        while (cin >> d)
        {
            int i = d;
            char c = i;
            int i2 = c;
            cout << d << ", " << i << ", " << c << ", " << i2 << endl;
        }

        double x = 2.7;
        int y = x;
        int a = 1000;
        char b = a;
        cout << x << ", " << y << ", " << a << ", " << int(b) << endl;
    }

}
显示结果如下
1.5, 1.5, 3.5
x, 120, 120, x
2.3, 4.3
20000, 32,
oops!: 20000!=32
120.5
120.5, 120, x, 120
2.7, 2, 1000, -24

习题
7. 编写一个程序，提示用户输入三个字符串，然后按次序输出这些值并以逗号隔开。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    vector<string> v1;
    string word;
    while (getline(cin, word, '\n') && word != "")
    {
        v1.push_back(word);
    }
    sort(v1.begin(), v1.end());
    for(auto it = v1.begin(); it != v1.end(); ++it)
    {
        if (it != v1.begin())
        {
            cout << ", ";
        }
        cout << *it;
    }
    cout << endl;
}
显示结果如下
Steinbeck
Hemingway
Fitzgerald

Fitzgerald, Hemingway, Steinbeck

8・编写一个程序，测试一个整数值是奇数还是偶数。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    vector<int> v1;
    int num;
    while (cin >> num)
    {
        v1.push_back(num);
    }
    for(auto it = v1.begin(); it != v1.end(); ++it)
    {
        if (*it % 2 == 0)
        {
            cout << *it << " is an even number.\n";
        }
        else
        {
            cout << *it << " is an odd number.\n";
        }
    }
}
显示结果如下
1 2 3 4 5 6 7 8 9 end
1 is an odd number.
2 is an even number.
3 is an odd number.
4 is an even number.
5 is an odd number.
6 is an even number.
7 is an odd number.
8 is an even number.
9 is an odd number.

9. 编写一个程序，将数字的英文单词转换成数字。
当用户输入一个数字的英文拼写，程序将打印出对应的数字。如果用户输入无法对应的值，程序输出"not a number I know"。
参考之前学习的Jumping Into C++中出现的习题
如何将英文文本转换成数字。
ch03_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

bool isNegative(string number);

string wordsToNumbers(string word);
bool isTens(string word);
string getTens(string numberAsWord);
bool isHundreds(string word);
string getHundreds(string numberAsWord);
int getMagnitudeBalance(string currentWord, string numberAsString);
string getPaddedForMagnitude(string numberAsString,	int magnitudeBalance);

bool isNumberDemarcator(char character);
bool isFirstLetter(string numberInEnglish,	int numberIndexFromEnd);
int wordsToMagnitude(string word);

string addZeroPadding(int numberOfZeroes);
string addCommasMagnitude(string numberAsWord);

char const space = ' ';
char const comma = ',';
char const hyphen = '-';

int main()
{
    string numberInEnglish = "";
    cout << "Please write in any number you wish to see written out in digits: " << '\n';
    while (getline(cin, numberInEnglish, '\n') && numberInEnglish != "")
    {
        string numberAsString = "";
        string currentWord = "";
        for (size_t i = 0; i < numberInEnglish.length(); i++)
        {
            char currentLetter = tolower(numberInEnglish[numberInEnglish.length() - 1 - i]);

            if (!isNumberDemarcator(currentLetter))
            {
                currentWord = currentLetter + currentWord;
            }

            if ( !(currentWord == "") && ( isNumberDemarcator(currentLetter) || isFirstLetter(numberInEnglish, i) ) )
            {
                int magnitudeBalance;

                if (isTens(currentWord))
                {
                    numberAsString = getTens(numberAsString);
                }
                else if (isHundreds(currentWord))
                {
                    numberAsString = getHundreds(numberAsString);
                }
                else if ( ( magnitudeBalance = getMagnitudeBalance(currentWord, numberAsString) ) > 0 )
                {
                    numberAsString = getPaddedForMagnitude(numberAsString, magnitudeBalance);
                }
                string currentNumber = wordsToNumbers(currentWord);

                if (!(currentNumber == ""))
                {
                    numberAsString = currentNumber + numberAsString;
                }

                currentWord = "";
            }
        }
        if (numberAsString == "")
        {
            cout << "The number you entered was not a number I know\n";
        }
        else
        {
            numberAsString = addCommasMagnitude(numberAsString);

            if (isNegative(numberInEnglish))
            {
                numberAsString = "-" + numberAsString;
            }
            cout << "The number you entered was " << numberAsString << '\n';
        }
        cout << "Please write in any number you wish to see written out in digits: " << '\n';
    }
}

bool isNumberDemarcator(char character)
{
    return ( (character == hyphen) ||
             (character == comma) ||
             (character == space) );
}

bool isFirstLetter(string numberInEnglish,
                   int numberIndexFromEnd)
{
    return ( numberIndexFromEnd == numberInEnglish.length() - 1 );
}

bool isNegative(string number)
{
    string negative = "negative";
    if (number.length() > negative.length())
    {
        for (size_t i = 0; i < negative.length(); i++)
        {
            if (!(tolower(number[i]) == negative[i]))
            {
                return false;
            }
        }
        return true;
    }
    return false;
}

string wordsToNumbers(string word)
{
    if (word == "zero")
        return "0";
    if (word == "one")
        return "1";
    if (word == "two")
        return "2";
    if (word == "three")
        return "3";
    if (word == "four")
        return "4";
    if (word == "five")
        return "5";
    if (word == "six")
        return "6";
    if (word == "seven")
        return "7";
    if (word == "eight")
        return "8";
    if (word == "nine")
        return "9";
    if (word == "ten")
        return "10";
    if (word == "eleven")
        return "11";
    if (word == "twelve")
        return "12";
    if (word == "thirteen")
        return "13";
    if (word == "fourteen")
        return "14";
    if (word == "fifteen")
        return "15";
    if (word == "sixteen")
        return "16";
    if (word == "seventeen")
        return "17";
    if (word == "eighteen")
        return "18";
    if (word == "nineteen")
        return "19";
    if (word == "twenty")
        return "2";
    if (word == "thirty")
        return "3";
    if (word == "forty")
        return "4";
    if (word == "fifty")
        return "5";
    if (word == "sixty")
        return "6";
    if (word == "seventy")
        return "7";
    if (word == "eighty")
        return "8";
    if (word == "ninety")
        return "9";
    return "";
}

bool isTens(string word)
{
    return ((word == "twenty") ||
            (word == "thirty") ||
            (word == "forty") ||
            (word == "fifty") ||
            (word == "sixty") ||
            (word == "seventy") ||
            (word == "eighty") ||
            (word == "ninety"));
}

string getTens(string numberAsWord)
{
    int numberLength = numberAsWord.length();
    if (numberLength < 2)
    {
        numberAsWord = addZeroPadding(1 - numberLength) + numberAsWord;
    }
    else
    {
        int offset = 1;
        while (offset - numberLength < 0)
        {
            offset += 3;
        }
        numberAsWord = addZeroPadding(offset - numberLength) + numberAsWord;
    }
    return numberAsWord;
}

bool isHundreds(string word)
{
    return (word == "hundred");
}

string getHundreds(string numberAsWord)
{
    int numberLength = numberAsWord.length();

    int offset = 2;
    while (offset - numberLength < 0)
    {
        offset += 3;
    }
    numberAsWord = addZeroPadding(offset - numberLength) + numberAsWord;

    return numberAsWord;
}

int getMagnitudeBalance(string currentWord,
                        string numberAsString)
{
    int currentMagnitude = wordsToMagnitude(currentWord);
    int numberLength = numberAsString.length();
    return (currentMagnitude - numberLength);
}


string getPaddedForMagnitude(string numberAsString,
                             int magnitudeBalance)
{
    return (addZeroPadding(magnitudeBalance) + numberAsString);
}


int wordsToMagnitude(string word)
{
    if (word == "thousand")
    {
        return 3;
    }
    if (word == "million")
    {
        return 6;
    }
    if (word == "billion")
    {
        return 9;
    }
    if (word == "trillion")
    {
        return 12;
    }
    return 0;
}

string addZeroPadding(int numberOfZeroes)
{
    string currentPadding = "";
    for (size_t j = 0; j < numberOfZeroes; j++)
    {
        currentPadding += "0";
    }
    return currentPadding;
}

string addCommasMagnitude(string numberAsWord)
{
    string numberAsWordWithCommas = "";
    int subcount = 0;
    int originalLength = numberAsWord.length();
    for (size_t i = 0; i < originalLength; i++)
    {
        numberAsWordWithCommas = numberAsWord[originalLength - 1 - i] + numberAsWordWithCommas;
        subcount++;
        if ((subcount == 3) && !(i == originalLength - 1))
        {
            subcount = 0;
            numberAsWordWithCommas = "," + numberAsWordWithCommas;
        }
    }
    return numberAsWordWithCommas;
}
显示结果如下
Please write in any number you wish to see written out in digits:
one billion, two
The number you entered was 1,000,000,002
Please write in any number you wish to see written out in digits:
one hundred thousand, twenty three
The number you entered was 100,023
Please write in any number you wish to see written out in digits:

10. 编写一个程序，执行一个包括两个运算的操作，然后输出结果。例如：
+100 3.14
* 4 5
将操作读入一个字符串称为operation，用一个if语句判断哪个操作是用户希望的。
将运算读入double类型的变量。实现这些称为+、-、*、/的操作，加、减、乘、除都有各自明显的意义。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    string operation;
    double d1 = 0;
    double d2 = 0;
    double res = 0;
    cout << "Please enter an operation (+, -, *, /, plus, minus, mul, div) followed by two operands\n";
    while (cin >> operation && cin >> d1 && cin >> d2)
    {
        if (operation == "+" || operation == "plus")
        {
            res = d1 + d2;
        }
        else if (operation == "-" || operation == "minus")
        {
            res = d1 - d2;
        }
        else if (operation == "*" || operation == "mul")
        {
            res = d1 * d2;
        }
        else if (operation == "/" || operation == "div")
        {
            if (d2 == 0)
            {
                operation = "divzero";
            }
            else
            {
                res = d1 / d2;
            }
        }
        else
        {
            operation = "unknown";
        }
        if (operation == "unknown")
        {
            cout << "I don't know this operator!\n";
        }
        else if (operation == "divzero")
        {
            cout << "No division by zero!\n";
        }
        else
        {
            cout << d1 << ' ' << operation << ' ' << d2 << " = " << res << '\n';
        }
        cout << "Please enter an operation (+, -, *, /, plus, minus, mul, div) followed by two operands\n";
    }
    return 0;
}
显示结果如下
Please enter an operation (+, -, *, /, plus, minus, mul, div) followed by two operands
+ 100 3.14
100 + 3.14 = 103.14
Please enter an operation (+, -, *, /, plus, minus, mul, div) followed by two operands
* 4 5
4 * 5 = 20
Please enter an operation (+, -, *, /, plus, minus, mul, div) followed by two operands
+ q q

11. 编写一个程序，提示用户输入一美分（1美分硬币）、五美分（5美分硬币）、十美分（10美分硬币）、二十五美分（25美分硬币）、
半美元（50美分硬币）和一美元（100美分硬币）的数量。对每种面值的硬币，分别提示用户输入其数量。然后，程序将输出类似下面的内容：
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    int pennies = 0;
    int nickels = 0;
    int dimes = 0;
    int quarters = 0;
    int half_dollars = 0;
    int dollars = 0;
    cout << "How many pennies do you have?\n";
    cin >> pennies;
    cout << "How many nickels do you have?\n";
    cin >> nickels;
    cout << "How many dimes do you have?\n";
    cin >> dimes;
    cout << "How many quarters do you have?\n";
    cin >> quarters;
    cout << "How many half dollars do you have?\n";
    cin >> half_dollars;
    cout << "How many dollar coins do you have?\n";
    cin >> dollars;
    if (pennies > 0)
    {
        cout << "You have " << pennies;
        if (pennies == 1)
        {
            cout << " penny.\n";
        }
        else
        {
            cout << " pennies.\n";
        }
    }
    if (nickels > 0)
    {
        cout << "You have " << nickels;
        if (nickels == 1)
        {
            cout << " nickel.\n";
        }
        else
        {
            cout << " nickels.\n";
        }
    }
    if (dimes > 0)
    {
        cout << "You have " << dimes;
        if (dimes == 1)
        {
            cout << " dime.\n";
        }
        else
        {
            cout << " dimes.\n";
        }
    }
    if (quarters > 0)
    {
        cout << "You have " << quarters;
        if (quarters == 1)
        {
            cout << " quarter.\n";
        }
        else
        {
            cout << " quarters.\n";
        }
    }
    if (half_dollars > 0)
    {
        cout << "You have " << half_dollars;
        if (half_dollars == 1)
        {
            cout << " half dollar.\n";
        }
        else
        {
            cout << " half dollars.\n";
        }
    }
    if (dollars > 0)
    {
        cout << "You have " << dollars;
        if (dollars == 1)
        {
            cout << " dollar.\n";
        }
        else
        {
            cout << " dollars.\n";
        }
    }
    double val = pennies + 5 * nickels + 10 * dimes + 25 * quarters + 50 * half_dollars + 100 * dollars;
    cout << std::fixed;
    streamsize prec = cout.precision();
    cout << "The value of all your coins is "  << setprecision(0) << val << " cents ($" << setprecision(2) << val / 100 << setprecision(prec) << ").\n";
    return 0;
}
显示结果如下
How many pennies do you have?
23
How many nickels do you have?
17
How many dimes do you have?
14
How many quarters do you have?
7
How many half dollars do you have?
3
How many dollar coins do you have?
5
You have 23 pennies.
You have 17 nickels.
You have 14 dimes.
You have 7 quarters.
You have 3 half dollars.
You have 5 dollars.
The value of all your coins is 1073 cents ($10.73).

以下为之前学习的Jumping Into C++中出现的习题
12.完成将从-999 999~999 999的数字转换成英文文本的源代码。
ch03_p12.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

string getOneDigitNumber(char number);
string getTeensNumber(char number);
string getTensNumber(char number);
string getTwoDigitNumber(char ten, char one);
string getThreeDigitNumber(char hundred, char ten, char one);
string getMagnitude(int divisionsOfThree);

int main()
{
    int i;

    cout << "Please enter an integer number: ";
    cin >> i;
    string numberAsString = to_string(i);

    string sign = "";
    bool isNegative = (numberAsString.at(0) == '-');
    if (isNegative)
    {
        sign = "Negative ";
    }

    int signOffset = 0;
    if (isNegative)
    {
        signOffset = 1;
    }

    int numberCount = numberAsString.length() - signOffset;

    string numberInEnglish = "";
    int tens = numberCount % 3;
    int divisionsOfThree = (numberCount - 1) / 3;

    if ( numberCount <= 3 )
    {
        switch (numberCount)
        {
        case 1:
            if ( numberAsString.at(signOffset) == '0' )
            {
                numberInEnglish = "zero";
            }
            else
            {
                numberInEnglish = getOneDigitNumber(numberAsString.at(signOffset));
            }
            break;
        case 2:
            numberInEnglish = getTwoDigitNumber(numberAsString.at(signOffset), numberAsString.at(signOffset + 1));
            break;
        case 3:
            numberInEnglish = getThreeDigitNumber(numberAsString.at(signOffset), numberAsString.at(signOffset + 1), numberAsString.at(signOffset + 2));
            break;
        default:
            break;
        }
        cout << numberAsString << ": " << sign << numberInEnglish << '\n';
        return 0;
    }

    if ( tens > 0 )
    {
        switch (tens)
        {
        case 1:
            numberInEnglish = getOneDigitNumber(numberAsString.at(signOffset));
            break;
        case 2:
            numberInEnglish = getTwoDigitNumber(numberAsString.at(signOffset), numberAsString.at(signOffset + 1));
            break;
        default:
            break;
        }
        numberInEnglish += " " + getMagnitude(divisionsOfThree);
        divisionsOfThree--;
    }

    for (size_t j = tens + signOffset; j < numberAsString.length(); j += 3)
    {
        string threeDigits = numberAsString.substr(j, 3);
        if (threeDigits != "000")
        {
            if(numberInEnglish.length() > 0)
            {
                numberInEnglish += ", ";
            }
            if (divisionsOfThree == 0)
            {
                numberInEnglish +=
                    getThreeDigitNumber(threeDigits.at(0), threeDigits.at(1), threeDigits.at(2));
            }
            else
            {
                numberInEnglish +=
                    getThreeDigitNumber(threeDigits.at(0), threeDigits.at(1), threeDigits.at(2)) + " " + getMagnitude(divisionsOfThree);
            }
        }

        divisionsOfThree--;
    }
    cout << numberAsString << ": " << sign << numberInEnglish << '\n';

}

string getOneDigitNumber(char number)
{
    switch(number)
    {
    case '1':
        return "one";
    case '2':
        return "two";
    case '3':
        return "three";
    case '4':
        return "four";
    case '5':
        return "five";
    case '6':
        return "six";
    case '7':
        return "seven";
    case '8':
        return "eight";
    case '9':
        return "nine";
    default:
        return "";
    }
}

string getTeensNumber(char number)
{
    switch (number)
    {
    case '0':
        return "ten";
    case '1':
        return "eleven";
    case '2':
        return "twelve";
    case '3':
        return "thirteen";
    case '4':
        return "fourteen";
    case '5':
        return "fifteen";
    case '6':
        return "sixteen";
    case '7':
        return "seventeen";
    case '8':
        return "eighteen";
    case '9':
        return "nineteen";
    default:
        return "";
    }
}

string getTensNumber(char number)
{
    switch (number)
    {
    case '2':
        return "twenty";
    case '3':
        return "thirty";
    case '4':
        return "fourty";
    case '5':
        return "fifty";
    case '6':
        return "sixty";
    case '7':
        return "seventy";
    case '8':
        return "eighty";
    case '9':
        return "ninety";
    default:
        return "";
    }
}

string getTwoDigitNumber(char ten, char one)
{
    if (ten == '0')
    {
        return  getOneDigitNumber(one);
    }
    else if (ten == '1')
    {
        return getTeensNumber(one);
    }
    else
    {
        if (one == '0')
        {
            return getTensNumber(ten);
        }
        else
        {
            return (getTensNumber(ten) + " " + getOneDigitNumber(one));
        }
    }
}

string getThreeDigitNumber(char hundred, char ten, char one)
{
    if (hundred == '0')
    {
        return  getTwoDigitNumber(ten, one);
    }
    else
    {
        if (ten == '0' && one == '0')
        {
            return (getOneDigitNumber(hundred) + " hundred");
        }
        else
        {
            return (getOneDigitNumber(hundred) + " hundred " + getTwoDigitNumber(ten, one));
        }
    }
}

string getMagnitude(int divisionsOfThree)
{
    switch (divisionsOfThree)
    {
    case 1:
        return "thousand";
    case 2:
        return "million";
    case 3:
        return "billion";
    case 4:
        return "trillion";
    default:
        return "";
    }
}
显示结果如下
Please enter an integer number: 0
0: zero

Please enter an integer number: 100023
100023: one hundred thousand, twenty three

Please enter an integer number: 1000000002
1000000002: one billion, two

13.如何将英文文本转换成数字。
ch03_p13.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

bool isNegative(string number);

string wordsToNumbers(string word);
bool isTens(string word);
string getTens(string numberAsWord);
bool isHundreds(string word);
string getHundreds(string numberAsWord);
int getMagnitudeBalance(string currentWord, string numberAsString);
string getPaddedForMagnitude(string numberAsString,	int magnitudeBalance);

bool isNumberDemarcator(char character);
bool isFirstLetter(string numberInEnglish,	int numberIndexFromEnd);
int wordsToMagnitude(string word);

string addZeroPadding(int numberOfZeroes);
string addCommasMagnitude(string numberAsWord);

char const space = ' ';
char const comma = ',';
char const hyphen = '-';

int main()
{
    string numberInEnglish = "";
    cout << "Please write in any number you wish to see written out in digits: " << '\n';
    getline(cin, numberInEnglish, '\n');

    string numberAsString = "";
    string currentWord = "";
    for (size_t i = 0; i < numberInEnglish.length(); i++)
    {
        char currentLetter = tolower(numberInEnglish[numberInEnglish.length() - 1 - i]);

        if (!isNumberDemarcator(currentLetter))
        {
            currentWord = currentLetter + currentWord;
        }

        if ( !(currentWord == "") && ( isNumberDemarcator(currentLetter) || isFirstLetter(numberInEnglish, i) ) )
        {
            int magnitudeBalance;

            if (isTens(currentWord))
            {
                numberAsString = getTens(numberAsString);
            }
            else if (isHundreds(currentWord))
            {
                numberAsString = getHundreds(numberAsString);
            }
            else if ( ( magnitudeBalance = getMagnitudeBalance(currentWord, numberAsString) ) > 0 )
            {
                numberAsString = getPaddedForMagnitude(numberAsString, magnitudeBalance);
            }
            string currentNumber = wordsToNumbers(currentWord);

            if (!(currentNumber == ""))
            {
                numberAsString = currentNumber + numberAsString;
            }

            currentWord = "";
        }
    }

    numberAsString = addCommasMagnitude(numberAsString);

    if (isNegative(numberInEnglish))
    {
        numberAsString = "-" + numberAsString;
    }
    cout << "The number you entered was " << numberAsString << '\n';
}

bool isNumberDemarcator(char character)
{
    return ( (character == hyphen) ||
             (character == comma) ||
             (character == space) );
}

bool isFirstLetter(string numberInEnglish,
                   int numberIndexFromEnd)
{
    return ( numberIndexFromEnd == numberInEnglish.length() - 1 );
}

bool isNegative(string number)
{
    string negative = "negative";
    if (number.length() > negative.length())
    {
        for (size_t i = 0; i < negative.length(); i++)
        {
            if (!(tolower(number[i]) == negative[i]))
            {
                return false;
            }
        }
        return true;
    }
    return false;
}

string wordsToNumbers(string word)
{
    if (word == "zero")
        return "0";
    if (word == "one")
        return "1";
    if (word == "two")
        return "2";
    if (word == "three")
        return "3";
    if (word == "four")
        return "4";
    if (word == "five")
        return "5";
    if (word == "six")
        return "6";
    if (word == "seven")
        return "7";
    if (word == "eight")
        return "8";
    if (word == "nine")
        return "9";
    if (word == "ten")
        return "10";
    if (word == "eleven")
        return "11";
    if (word == "twelve")
        return "12";
    if (word == "thirteen")
        return "13";
    if (word == "fourteen")
        return "14";
    if (word == "fifteen")
        return "15";
    if (word == "sixteen")
        return "16";
    if (word == "seventeen")
        return "17";
    if (word == "eighteen")
        return "18";
    if (word == "nineteen")
        return "19";
    if (word == "twenty")
        return "2";
    if (word == "thirty")
        return "3";
    if (word == "forty")
        return "4";
    if (word == "fifty")
        return "5";
    if (word == "sixty")
        return "6";
    if (word == "seventy")
        return "7";
    if (word == "eighty")
        return "8";
    if (word == "ninety")
        return "9";
    return "";
}

bool isTens(string word)
{
    return ((word == "twenty") ||
            (word == "thirty") ||
            (word == "forty") ||
            (word == "fifty") ||
            (word == "sixty") ||
            (word == "seventy") ||
            (word == "eighty") ||
            (word == "ninety"));
}

string getTens(string numberAsWord)
{
    int numberLength = numberAsWord.length();
    if (numberLength < 2)
    {
        numberAsWord = addZeroPadding(1 - numberLength) + numberAsWord;
    }
    else
    {
        int offset = 1;
        while (offset - numberLength < 0)
        {
            offset += 3;
        }
        numberAsWord = addZeroPadding(offset - numberLength) + numberAsWord;
    }
    return numberAsWord;
}

bool isHundreds(string word)
{
    return (word == "hundred");
}

string getHundreds(string numberAsWord)
{
    int numberLength = numberAsWord.length();

    int offset = 2;
    while (offset - numberLength < 0)
    {
        offset += 3;
    }
    numberAsWord = addZeroPadding(offset - numberLength) + numberAsWord;

    return numberAsWord;
}

int getMagnitudeBalance(string currentWord,
                        string numberAsString)
{
    int currentMagnitude = wordsToMagnitude(currentWord);
    int numberLength = numberAsString.length();
    return (currentMagnitude - numberLength);
}


string getPaddedForMagnitude(string numberAsString,
                             int magnitudeBalance)
{
    return (addZeroPadding(magnitudeBalance) + numberAsString);
}


int wordsToMagnitude(string word)
{
    if (word == "thousand")
    {
        return 3;
    }
    if (word == "million")
    {
        return 6;
    }
    if (word == "billion")
    {
        return 9;
    }
    if (word == "trillion")
    {
        return 12;
    }
    return 0;
}

string addZeroPadding(int numberOfZeroes)
{
    string currentPadding = "";
    for (size_t j = 0; j < numberOfZeroes; j++)
    {
        currentPadding += "0";
    }
    return currentPadding;
}

string addCommasMagnitude(string numberAsWord)
{
    string numberAsWordWithCommas = "";
    int subcount = 0;
    int originalLength = numberAsWord.length();
    for (size_t i = 0; i < originalLength; i++)
    {
        numberAsWordWithCommas = numberAsWord[originalLength - 1 - i] + numberAsWordWithCommas;
        subcount++;
        if ((subcount == 3) && !(i == originalLength - 1))
        {
            subcount = 0;
            numberAsWordWithCommas = "," + numberAsWordWithCommas;
        }
    }
    return numberAsWordWithCommas;
}
显示结果如下
Please write in any number you wish to see written out in digits:
zero
The number you entered was 0

Please write in any number you wish to see written out in digits:
one
The number you entered was 1

Please write in any number you wish to see written out in digits:
two
The number you entered was 2

Please write in any number you wish to see written out in digits:
three
The number you entered was 3

Please write in any number you wish to see written out in digits:
four
The number you entered was 4

Please write in any number you wish to see written out in digits:
one billion two
The number you entered was 1,000,000,002

Please write in any number you wish to see written out in digits:
one hundred thousand twenty three
The number you entered was 100,023


第4章 计算
4.1 计算
4.2 目标和工具
4.3 表达式
4.3.1 常量表达式
4.3.2 运算符
4.3.3 类型转换
4.4 语句
4.4.1 选择语句
4.4.2 循环语句
4.5 函数
4.5.1 使用函数的原因
4.5.2 函数声明
4.6 向量
4.6.1 向量空间增长
4.6.2 一个数值计算的例子
4.6.3 一个文本处理的例子
4.7 语言特性
ch04_b01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}


int main()
{
    int length = 20;
    int width = 40;
    int area = length * width;

    cout << length << ", " << width << ", " << area << endl;

    length = 99;

    {
        int perimeter = (length + width) * 2;
        cout << length << ", " << width << ", " << perimeter << endl;
    }

    {
        int perimeter = length * 2 + width * 2;
        cout << length << ", " << width << ", " << perimeter << endl;
    }

    {
        int perimeter = length + width / 2;
        cout << length << ", " << width << ", " << perimeter << endl;
    }

    const double pi = 3.14159265359;
    int r = 7;
    int v = 2 * pi / r;
    cout << pi << ", " << r << ", " << v << endl;

    const int max = 17;
    int val = 19;

    cout << max << ", " << val << endl;
    cout << max + 2 << ", " << val + 2 << endl;

    int a = 0;

    ++a;
    a += 1;
    a = a + 1;
    cout << a << endl;

    double d = 2.5;
    int i = 2;

    double d2 = d / i;
    int i2 = d / i;
    cout << d2 << ", " << i2 << endl;

    d2 = d / i + 1;
    i2 = d / i + 1;
    cout << d2 << ", " << i2 << endl;

    {
        double dc;
        cin >> dc;
        double df = 9 / 5 * dc + 32;
        cout << dc << ", " << df << endl;
    }

    {
        double dc;
        cin >> dc;
        double df = 9.0 / 5 * dc + 32;
        cout << dc << ", " << df << endl;
    }
}
显示结果如下
20, 40, 800
99, 40, 278
99, 40, 278
99, 40, 119
3.14159, 7, 0
17, 19
19, 21
3
1.25, 1
2.25, 2
3.5
3.5, 35.5
3.5
3.5, 38.3

ch04_b02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    {
        int a = 0;
        int b = 0;
        cout << "Please enter two integers\n";
        cin >> a >> b;

        if (a < b)
        {
            cout << "max(" << a << "," << b << ") is " << b << "\n";
        }
        else
        {
            cout << "max(" << a << "," << b << ") is " << a << "\n";
        }
    }

    {
        const double cm_per_inch = 2.54;
        int length = 1;
        char unit = ' ';
        cout << "Please enter a length followed by a unit (c or i):\n";
        cin >> length >> unit;

        cout << std::fixed;
        if (unit == 'i')
        {
            streamsize prec = cout.precision();
            cout << length << "in == " << setprecision(2) << cm_per_inch *length << setprecision(prec) << "cm\n";
        }
        else if (unit == 'c')
        {
            streamsize prec = cout.precision();
            cout << length << "cm == " << setprecision(2) << length / cm_per_inch << setprecision(prec) << "in\n";
        }
        else
        {
            cout << "Sorry, I don't know a unit called '" << unit << "'\n";
        }
    }

    {
        const double cm_per_inch = 2.54;
        int length = 1;
        char unit = 'a';
        cout << "Please enter a length followed by a unit (c or i):\n";
        cin >> length >> unit;
        cout << std::fixed;
        streamsize prec;
        switch (unit)
        {
        case 'i':
            prec = cout.precision();
            cout << length << "in == " << setprecision(2) << cm_per_inch *length << setprecision(prec) << "cm\n";
            break;
        case 'c':
            prec = cout.precision();
            cout << length << "cm == " << setprecision(2) << length / cm_per_inch << setprecision(prec) << "in\n";
            break;
        default:
            cout << "Sorry, I don't know a unit called '" << unit << "'\n";
            break;
        }
    }

    {
        cout << "Please enter a digit\n";
        char a;
        cin >> a;

        switch (a)
        {
        case '0':
        case '2':
        case '4':
        case '6':
        case '8':
            cout << a << " is even\n";
            break;
        case '1':
        case '3':
        case '5':
        case '7':
        case '9':
            cout << a << " is odd\n";
            break;
        default:
            cout << a << " is not a digit\n";
            break;
        }
    }

    {
        int a = 7;
        int b = 4;

        if (a <= b) { }
        else
        {
            int t = a;
            a = b;
            b = t;
        }
        cout << a << ", " << b << endl;
    }

    {
        for (int i = 0; i < 10; ++i)
        {
            cout << i << '\t' << (i * i) << '\n';
        }
        cout << endl;
        for (int i = 0; i < 10; i += 2)
        {
            cout << i << '\t' << (i * i) << '\n';
        }
    }
}
显示结果如下
Please enter two integers
3 5
max(3,5) is 5
Please enter a length followed by a unit (c or i):
5c
5cm == 1.97in
Please enter a length followed by a unit (c or i):
5i
5in == 12.70cm
Please enter a digit
5
5 is odd
4, 7
0       0
1       1
2       4
3       9
4       16
5       25
6       36
7       49
8       64
9       81

0       0
2       4
4       16
6       36
8       64

ch04_b03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}


inline int square(int x)
{
    return x * x;
}

void print_square(int v)
{
    cout << v << '\t' << v *v << '\n';
}

void write_sorry()
{
    cout << "Sorry\n";
}

int main()
{
    cout << square(2) << '\n';
    cout << square(10) << '\n';
    int x = square(44);
    cout << x << endl;
    write_sorry();
    cout << endl;
    for (int i = 0; i < 10; ++i)
    {
        print_square(i);
    }
}
显示结果如下
4
100
1936
Sorry

0       0
1       1
2       4
3       9
4       16
5       25
6       36
7       49
8       64
9       81

ch04_b04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}


inline int square(int x)
{
    return x * x;
}

void print_square(int v)
{
    cout << v << '\t' << v *v << '\n';
}

void write_sorry()
{
    cout << "Sorry\n";
}

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

int main()
{
    {
        int i = 0;
        while (i < 10)
        {
            cout << i << '\t' << square(i) << '\n';
            ++i ;
        }
    }

    {
        vector<int> v(6);

        v[0] = 5;
        v[1] = 7;
        v[2] = 9;
        v[3] = 4;
        v[4] = 6;
        v[5] = 8;

        copy(v.begin(), v.end(), ostream_iterator<int>(cout, " "));
        cout << endl;

        vector<string> philosopher(4);

        philosopher [0] = "Kant";
        philosopher [1] = "Plato";
        philosopher [2] = "Hume";
        philosopher [3] = "Kierkegaard";

        copy(philosopher.begin(), philosopher.end(), ostream_iterator<string>(cout, " "));
        cout << endl;

        vector<double> vd(10, -1.2);

        copy(vd.begin(), vd.end(), ostream_iterator<double>(cout, " "));
        cout << endl;
    }

    {
        vector<double> v;

        v.push_back(2.7);
        v.push_back(5.6);
        v.push_back(7.9);

        for(int i = 0; i < v.size(); ++i)
        {
            cout << "v[" << i << "] = " << v[i] << '\n';
        }
    }

    {
        vector<double> temps;
        double temp;
        while (cin >> temp)
        {
            temps.push_back(temp);
        }
        cin.clear();
        while (cin.get() != '\n')
        {
            continue;
        }
        cout << "Average temperature: " << accumulate(temps.begin(), temps.end(), 0.0) / temps.size() << endl;
        try
        {
            cout << "Median temperature: " << median(temps) << endl;
        }
        catch (domain_error &e1)
        {
            cout << e1.what() << endl;
        }
    }

    {
        vector<string> words;
        string temp;
        while (cin >> temp)
        {
            words.push_back(temp);
        }

        cout << "Number of words: " << words.size() << endl;

        sort(words.begin(), words.end());

        for (int i = 0; i < words.size(); ++i)
        {
            if (i == 0 || words[i - 1] != words[i])
            {
                cout << words[i] << "\n";
            }
        }
    }

}
显示结果如下

0       0
1       1
2       4
3       9
4       16
5       25
6       36
7       49
8       64
9       81
5 7 9 4 6 8
Kant Plato Hume Kierkegaard
-1.2 -1.2 -1.2 -1.2 -1.2 -1.2 -1.2 -1.2 -1.2 -1.2
v[0] = 2.7
v[1] = 5.6
v[2] = 7.9
1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8 9.9 end
Average temperature: 5.5
Median temperature: 5.5
Peter Smith Mike Pence Peter Mike Water Mike Smith Peter Flower
Number of words: 11
Flower
Mike
Pence
Peter
Smith
Water

ch04_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    double d = 0;
    double d_conv = 0;
    double smallest = 0;
    double largest = 0;
    double sum = 0;
    vector<double> vals;
    int ctr = 0;
    string unit;
    bool is_first = true;
    bool is_valid = true;
    while (cin >> d && cin >> unit)
    {
        if (unit == "cm")
        {
            d_conv = d / 100;
        }
        else if (unit == "m")
        {
            d_conv = d;
        }
        else if (unit == "in")
        {
            d_conv = d * 0.0254;
        }
        else if (unit == "ft")
        {
            d_conv = d * 0.0254 * 12;
        }
        else
        {
            is_valid = false;
        }
        if (is_valid)
        {
            cout << d << ' ' << unit;
            if (d_conv < smallest || is_first)
            {
                smallest = d_conv;
                cout << " the smallest so far";
            }
            if (d_conv > largest || is_first)
            {
                largest = d_conv;
                cout << " the largest so far";
            }
            vals.push_back(d_conv);
            sum += d_conv;
            ++ctr;
            is_first = false;
        }
        else
        {
            cout << "invalid unit";
        }
        cout << endl;
        is_valid = true;
    }
    cout << "smallest value: " << smallest << " m\n";
    cout << "largest value: " << largest << " m\n";
    cout << "number of values: " << ctr << endl;
    cout << "sum of values: " << sum << " m\n";
    sort(vals.begin(), vals.end());
    cout << "values:" << endl;
    for (int i = 0; i < vals.size(); ++i)
    {
        cout << vals[i] << " m\n";
    }
    return 0;
}
显示结果如下
10cm
10 cm the smallest so far the largest so far
2.5in
2.5 in the smallest so far
5ft
5 ft the largest so far
3.33m
3.33 m the largest so far
smallest value: 0.0635 m
largest value: 3.33 m
number of values: 4
sum of values: 5.0175 m
values:
0.0635 m
0.1 m
1.524 m
3.33 m

ch04_p01a.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    const double dollars_per_yen = 0.01;
    const double dollars_per_euro = 1.35;
    const double dollars_per_pound = 1.61;
    const double dollars_per_yuan = 0.16;
    const double dollars_per_kroner = 0.18;
    double amount = 0;
    char currency = ' ';
    cout << "Please enter an amount followed by a currency (Y, U, p, y or k):\n";
    cin >> amount >> currency;

    switch (currency)
    {
    case 'Y':
        cout << amount << " yen is " << dollars_per_yen *amount << " dollars\n";
        break;
    case 'U':
        cout << amount << " euro is " << dollars_per_euro *amount << " dollars\n";
        break;
    case 'p':
        cout << amount << " pound is " << dollars_per_pound *amount << " dollars\n";
        break;
    case 'y':
        cout << amount << " yuan is " << dollars_per_yuan *amount << " dollars\n";
        break;
    case 'k':
        cout << amount << " kroner is " << dollars_per_kroner *amount << " dollars\n";
        break;
    default:
        cout << "Sorry, I don't know the currency '" << currency << "'\n";
        break;
    }
    return 0;
}
显示结果如下
Please enter an amount followed by a currency (Y, U, p, y or k):
100U
100 euro is 135 dollars

Please enter an amount followed by a currency (Y, U, p, y or k):
100y
100 yuan is 16 dollars

Please enter an amount followed by a currency (Y, U, p, y or k):
100p
100 pound is 161 dollars

ch04_p01b.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    vector<string> words;
    string temp;
    while (cin >> temp)
    {
        words.push_back(temp);
    }
    vector<string> dislikeds;
    dislikeds.push_back("Broccoli");
    dislikeds.push_back("Chewbacca");
    dislikeds.push_back("Eggplant");
    for (int i = 0; i < words.size(); ++i)
    {
        bool is_disliked = false;
        for (int j = 0; j < dislikeds.size(); ++j)
        {
            if (dislikeds[j] == words[i])
            {
                is_disliked = true;
            }
        }
        if (is_disliked)
        {
            cout << "BLEEP ";
        }
        else
        {
            cout << words[i] << ' ';
        }
    }
    cout << endl;
    return 0;
}
显示结果如下
Peter Smith Broccoli Mike Pence Chewbacca Hello World Eggplant Flower
Peter Smith BLEEP Mike Pence BLEEP Hello World BLEEP Flower

ch04_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

int main()
{
    vector<double> temps;
    double temp;
    while (cin >> temp)
    {
        temps.push_back(temp);
    }
    cout << "Average temperature: " << accumulate(temps.begin(), temps.end(), 0.0) / temps.size() << endl;
    try
    {
        cout << "Median temperature: " << median(temps) << endl;
    }
    catch (domain_error &e1)
    {
        cout << e1.what() << endl;
    }

    return 0;
}
显示结果如下
1.2 2.6 3.8 4.5 5.6 6.7
Average temperature: 4.06667
Median temperature: 4.15

ch04_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    vector<double> distances;
    double distance;
    double total = 0;
    double smallest = 0;
    double greatest = 0;
    double mean = 0;
    while (cin >> distance)
    {
        if (distance > 0)
        {
            distances.push_back(distance);
        }
    }
    if (distances.size() == 0)
    {
        error("No valid values entered");
    }
    smallest = distances[0];
    greatest = distances[0];
    for (int i = 0; i < distances.size(); ++i)
    {
        total += distances[i];
        if (distances[i] < smallest)
        {
            smallest = distances[i];
        }
        if (distances[i] > greatest)
        {
            greatest = distances[i];
        }
    }
    mean = total / distances.size();
    cout << "Total distance: " << total << endl;
    cout << "Smallest distance: " << smallest << endl;
    cout << "Greatest distance: " << greatest << endl;
    cout << "Mean distance: " << mean << endl;
    return 0;
}
显示结果如下
1.2 2.6 3.8 4.5 5.6 6.7
Total distance: 24.4
Smallest distance: 1.2
Greatest distance: 6.7
Mean distance: 4.06667

ch04_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    cout << "Think of a number between 1 and 100.\n";
    cout << "For every guess, enter if your number is\n";
    cout << "(l)arger or (s)maller than the one shown.\n";
    cout << "Enter 'c' (for 'correct') if the number shown is yours.\n";

    int guess = 50;
    vector<int> differences(6);
    differences[0] = 25;
    differences[1] = 13;
    differences[2] = 6;
    differences[3] = 3;
    differences[4] = 2;
    differences[5] = 1;
    int counter = 0;
    char answer = ' ';

    while (answer != 'c')
    {
        cout << "My guess: " << guess << endl;
        ++counter;
        cout << "Correct, larger or smaller (c, l, s)? ";
        cin >> answer;
        switch (answer)
        {
        case 'c':
            break;
        case 'l':
            if (counter <= differences.size())
            {
                guess += differences[counter - 1];
            }
            else
            {
                ++guess;
            }
            break;
        case 's':
            if (counter <= differences.size())
            {
                guess -= differences[counter - 1];
            }
            else
            {
                --guess;
            }
            break;
        default:
            cout << "This is not a valid answer, use 'c', 'l' or 's'\n";
            --counter;
            break;
        }
        if (guess > 100 || guess < 1)
        {
            cout << "Your number must be between 1 and 100!\n";
            return 0;
        }
        if (counter == 7 && answer != 'c')
        {
            cout << "Super fishy, dude. I should have your number by now.\n";
            return 0;
        }
    }

    string s_try;
    if (counter == 1)
    {
        s_try = " try ";
    }
    else
    {
        s_try = " tries ";
    }
    cout << "It took me " << counter << s_try << "to find your number, " << guess << ".\n";
}
显示结果如下
Think of a number between 1 and 100.
For every guess, enter if your number is
(l)arger or (s)maller than the one shown.
Enter 'c' (for 'correct') if the number shown is yours.
My guess: 50
Correct, larger or smaller (c, l, s)? l
My guess: 75
Correct, larger or smaller (c, l, s)? s
My guess: 62
Correct, larger or smaller (c, l, s)? l
My guess: 68
Correct, larger or smaller (c, l, s)? l
My guess: 71
Correct, larger or smaller (c, l, s)? s
My guess: 69
Correct, larger or smaller (c, l, s)? l
My guess: 70
Correct, larger or smaller (c, l, s)? c
It took me 7 tries to find your number, 70.

ch04_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    cout << "Enter two double values and character (+, -, * or /)\n";
    double val1 = 0;
    double val2 = 0;
    char op = ' ';
    while (cin >> val1 && cin >> val2 && cin >> op)
    {
        switch (op)
        {
        case '+':
            cout << "The sum of " << val1 << " and " << val2 << " is " << val1 + val2 << ".\n";
            break;
        case '-':
            cout << "The difference of " << val1 << " and " << val2 << " is " << val1 - val2 << ".\n";
            break;
        case '*':
            cout << "The product of " << val1 << " and " << val2 << " is " << val1 *val2 << ".\n";
            break;
        case '/':
            cout << "The ratio of " << val1 << " and " << val2 << " is " << val1 / val2 << ".\n";
            break;
        default:
            cout << "This is not a valid operation (use +, -, * or /)\n";
            break;
        }
    }
}
显示结果如下
Enter two double values and character (+, -, * or /)
2 3 +
The sum of 2 and 3 is 5.
2 3 -
The difference of 2 and 3 is -1.
2 3 *
The product of 2 and 3 is 6.
2 3 /
The ratio of 2 and 3 is 0.666667.

ch04_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}


int main()
{
    vector<string> s_digits;
    s_digits.push_back("zero");
    s_digits.push_back("one");
    s_digits.push_back("two");
    s_digits.push_back("three");
    s_digits.push_back("four");
    s_digits.push_back("five");
    s_digits.push_back("six");
    s_digits.push_back("seven");
    s_digits.push_back("eight");
    s_digits.push_back("nine");
    vector<string> i_digits;
    i_digits.push_back("0");
    i_digits.push_back("1");
    i_digits.push_back("2");
    i_digits.push_back("3");
    i_digits.push_back("4");
    i_digits.push_back("5");
    i_digits.push_back("6");
    i_digits.push_back("7");
    i_digits.push_back("8");
    i_digits.push_back("9");
    string inp = "";
    while (cin >> inp)
    {
        bool was_found = false;
        for (int i = 0; i < s_digits.size(); ++i)
        {
            if (s_digits[i] == inp)
            {
                cout << i << endl;
                was_found = true;
            }
            if (i_digits[i] == inp)
            {
                cout << s_digits[i] << endl;
                was_found = true;
            }
        }
        if (!was_found)
        {
            cout << "Input must be zero, one, ..., nine or 0-9\n";
        }
    }
}
显示结果如下
1
one
2
two
3
three
seven
7
six
6
five
5

ch04_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

vector<string> s_digits;

void init_vector()
{
    s_digits.push_back("zero");
    s_digits.push_back("one");
    s_digits.push_back("two");
    s_digits.push_back("three");
    s_digits.push_back("four");
    s_digits.push_back("five");
    s_digits.push_back("six");
    s_digits.push_back("seven");
    s_digits.push_back("eight");
    s_digits.push_back("nine");
}

int get_number()
{
    int inp = 0;
    if (cin>>inp)
    {
        return inp;
    }
    cin.clear();
    string inp_s;
    cin >> inp_s;
    for (int i = 0; i<s_digits.size(); ++i)
    {
        if (s_digits[i]==inp_s)
        {
            return i;
        }
    }
    return (-1);
}

int main()
{
    init_vector();
    cout << "Enter two values (number or single digit spelled out) separated by\n"
        << "a character (+, -, * or /). Enter 'q' as operator to exit.\n";
    while (true)
    {
        int val1 = 0;
        int val2 = 0;
        char op = 0;
        val1 = get_number();
        cin >> op;
        val2 = get_number();
        if (val1==-1 || val2==-1)
        {
            cout << "Numbers must be int or, when spelled out, single digit\n";
        }
        else
        {
            switch (op)
            {
            case '+':
                cout << "The sum of " << val1 << " and " << val2 << " is " << val1+val2 << ".\n";
                break;
            case '-':
                cout << "The difference of " << val1 << " and " << val2 << " is " << val1-val2 << ".\n";
                break;
            case '*':
                cout << "The product of " << val1 << " and " << val2 << " is " << val1*val2 << ".\n";
                break;
            case '/':
                if (val2==0)
                {
                    cout << "No division by zero!\n";
                }
                else
                {
                    cout << "The ratio of " << val1 << " and " << val2 << " is " << double(val1)/val2 << ".\n";
                }
                break;
            case 'q':
                return 0;
            default:
                cout << "This is not a valid operation (use +, -, * or /)\n";
                break;
            }
        }
    }
}
显示结果如下
Enter two values (number or single digit spelled out) separated by
a character (+, -, * or /). Enter 'q' as operator to exit.
3 + 9
The sum of 3 and 9 is 12.
3 - nine
The difference of 3 and 9 is -6.
3 * nine
The product of 3 and 9 is 27.
3 / nine
The ratio of 3 and 9 is 0.333333.
3 q nine

ch04_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    double on_square = 1;
    double total = 0;
    cout << "Square" << '\t' << "Grains" << '\t' << "Total\n";
    for (int square = 1; square <= 64; ++square)
    {
        total += on_square;
        cout << square << '\t' << on_square << '\t' << total << endl;
        on_square *= 2;
    }
    return 0;
}
显示结果如下
Square  Grains  Total
1       1       1
2       2       3
3       4       7
4       8       15
5       16      31
6       32      63
7       64      127
8       128     255
9       256     511
10      512     1023
11      1024    2047
12      2048    4095
13      4096    8191
14      8192    16383
15      16384   32767
16      32768   65535
17      65536   131071
18      131072  262143
19      262144  524287
20      524288  1.04858e+06
21      1.04858e+06     2.09715e+06
22      2.09715e+06     4.1943e+06
23      4.1943e+06      8.38861e+06
24      8.38861e+06     1.67772e+07
25      1.67772e+07     3.35544e+07
26      3.35544e+07     6.71089e+07
27      6.71089e+07     1.34218e+08
28      1.34218e+08     2.68435e+08
29      2.68435e+08     5.36871e+08
30      5.36871e+08     1.07374e+09
31      1.07374e+09     2.14748e+09
32      2.14748e+09     4.29497e+09
33      4.29497e+09     8.58993e+09
34      8.58993e+09     1.71799e+10
35      1.71799e+10     3.43597e+10
36      3.43597e+10     6.87195e+10
37      6.87195e+10     1.37439e+11
38      1.37439e+11     2.74878e+11
39      2.74878e+11     5.49756e+11
40      5.49756e+11     1.09951e+12
41      1.09951e+12     2.19902e+12
42      2.19902e+12     4.39805e+12
43      4.39805e+12     8.79609e+12
44      8.79609e+12     1.75922e+13
45      1.75922e+13     3.51844e+13
46      3.51844e+13     7.03687e+13
47      7.03687e+13     1.40737e+14
48      1.40737e+14     2.81475e+14
49      2.81475e+14     5.6295e+14
50      5.6295e+14      1.1259e+15
51      1.1259e+15      2.2518e+15
52      2.2518e+15      4.5036e+15
53      4.5036e+15      9.0072e+15
54      9.0072e+15      1.80144e+16
55      1.80144e+16     3.60288e+16
56      3.60288e+16     7.20576e+16
57      7.20576e+16     1.44115e+17
58      1.44115e+17     2.8823e+17
59      2.8823e+17      5.76461e+17
60      5.76461e+17     1.15292e+18
61      1.15292e+18     2.30584e+18
62      2.30584e+18     4.61169e+18
63      4.61169e+18     9.22337e+18
64      9.22337e+18     1.84467e+19

ch04_p10.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    cout << "How many different moves (at least one) should the computer have?\n";
    int num_moves = 0;
    cin >> num_moves;
    if (num_moves < 1)
    {
        error("Number of moves must be at least 1");
    }
    vector<char> comp_moves;
    cout << "Enter the computer moves as 'r', 'p' or 's'\n";
    for (int i = 0; i < num_moves; ++i)
    {
        char next_move = 0;
        cin >> next_move;
        if (next_move == 'r' || next_move == 'p' || next_move == 's')
        {
            comp_moves.push_back(next_move);
        }
        else
        {
            cout << "Invalid move, use 'r', 'p' or 's'\n";
            --i;
        }
    }

    cout << "***Starting game***\n";
    cout << "Enter r, p or s to play, q to quit\n";
    char player_move = 0;
    int comp_move = 0;
    int p_score = 0;
    int c_score = 0;
    int ties = 0;
    while (true)
    {
        cin >> player_move;
        cout << "Player: " << player_move << " Computer: " << comp_moves[comp_move] << endl;
        switch (player_move)
        {
        case 'r':
            switch (comp_moves[comp_move])
            {
            case 'r':
                ++ties;
                cout << "Tie!\n";
                break;
            case 'p':
                ++c_score;
                cout << "I win!\n";
                break;
            case 's':
                ++p_score;
                cout << "You win!\n";
                break;
            }
            break;
        case 'p':
            switch (comp_moves[comp_move])
            {
            case 'r':
                ++p_score;
                cout << "You win!\n";
                break;
            case 'p':
                ++ties;
                cout << "Tie!\n";
                break;
            case 's':
                ++c_score;
                cout << "I win!\n";
                break;
            }
            break;
        case 's':
            switch (comp_moves[comp_move])
            {
            case 'r':
                ++c_score;
                cout << "I win!\n";
                break;
            case 'p':
                ++p_score;
                cout << "You win!\n";
                break;
            case 's':
                ++ties;
                cout << "Tie!\n";
                break;
            }
            break;
        case 'q':
            return 0;
        default:
            cout << "Invalid move, use 'r', 'p' or 's' to play, 'q' to quit\n";
            break;
        }
        cout << "Score: Player " << p_score << " Computer " << c_score << " Ties " << ties << endl;
        ++comp_move;
        if (comp_move == comp_moves.size())
        {
            comp_move = 0;
        }
    }
    return 0;
}
显示结果如下
How many different moves (at least one) should the computer have?
5
Enter the computer moves as 'r', 'p' or 's'
r s p p r
***Starting game***
Enter r, p or s to play, q to quit
s
Player: s Computer: r
I win!
Score: Player 0 Computer 1 Ties 0
s
Player: s Computer: s
Tie!
Score: Player 0 Computer 1 Ties 1
s
Player: s Computer: p
You win!
Score: Player 1 Computer 1 Ties 1
p
Player: p Computer: p
Tie!
Score: Player 1 Computer 1 Ties 2
p
Player: p Computer: r
You win!
Score: Player 2 Computer 1 Ties 2
r
Player: r Computer: r
Tie!
Score: Player 2 Computer 1 Ties 3
q
Player: q Computer: s

ch04_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

vector<int> primes_norm;

bool is_prime(int n)
{
    for (int i = 0; i < primes_norm.size() && primes_norm[i]<=sqrt(n); ++i)
    {
        if (n % primes_norm[i] == 0)
        {
            return false;
        }
    }
    return true;
}

int main()
{
    cout << "How many primes should I find?\n";
    int n_primes = 0;
    cin >> n_primes;
    primes_norm.push_back(2);
    int i = 3;
    while (primes_norm.size() < n_primes)
    {
        if (is_prime(i))
        {
            primes_norm.push_back(i);
        }
        i+=2;
    }

    cout << endl;

    for (int i = 0; i < primes_norm.size(); ++i)
    {
        cout << primes_norm[i] << endl;
    }
}
显示结果如下
How many primes should I find?
30

2
3
5
7
11
13
17
19
23
29
31
37
41
43
47
53
59
61
67
71
73
79
83
89
97
101
103
107
109
113

复习之前学习的Jumping Into C++中的习题
12.设计算法找出从1到1000中质因子相加是质数的数（例如，12有质因子2、2和3，相加得7，是质数）。完成代码。
ch04_p12.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

vector<int> primes_norm;

bool is_prime(int n)
{
    for (int i = 0; i < primes_norm.size() && primes_norm[i] <= sqrt(n); ++i)
    {
        if (n % primes_norm[i] == 0)
        {
            return false;
        }
    }
    return true;
}

int getPrimeFactor(int n)
{
    if (n <= 1)
    {
        return 0;
    }

    for (int i = 0; i < primes_norm.size() && primes_norm[i] <= sqrt(n); ++i)
    {
        if (n % primes_norm[i] == 0)
        {
            return primes_norm[i];
        }
    }

    return 0;
}

string numberHasPrimeFactorsWhichSumToPrime(int n)
{
    if (n <= 1)
    {
        return "";
    }
    if (is_prime(n))
    {
        return to_string(n) + " is prime number.\n";
    }

    int remainder = n;
    int currentSum = 0;
    string message = to_string(n) + " has prime factors: ";
    bool isFirstTerm = true;
    while (true)
    {
        int primeFactor = getPrimeFactor(remainder);
        if (primeFactor == 0)
        {
            return "An error has occurred with number " + to_string(n) + "\n";
        }
        if (!isFirstTerm)
        {
            message += ", ";
        }
        message += to_string(primeFactor);

        currentSum += primeFactor;
        remainder = (remainder / primeFactor);

        if (is_prime(remainder))
        {
            if (is_prime(remainder + currentSum))
            {
                message += ", " + to_string(remainder);
                message += " Which sum to: " + to_string(remainder + currentSum) + "\n";
                return message;
            }
            return "";
        }
        isFirstTerm = false;
    }
    return "";
}

int main()
{
    int n_primes = 200;
    primes_norm.push_back(2);
    int i = 3;
    while (primes_norm.size() < n_primes)
    {
        if (is_prime(i))
        {
            primes_norm.push_back(i);
        }
        i += 2;
    }

    for (int i = 1; i <= 1000; i++)
    {
        string message = numberHasPrimeFactorsWhichSumToPrime(i);
        if (!(message == ""))
        {
            cout << message;
        }
    }
}
显示结果如下
2 is prime number.
3 is prime number.
5 is prime number.
6 has prime factors: 2, 3 Which sum to: 5
7 is prime number.
10 has prime factors: 2, 5 Which sum to: 7
11 is prime number.
12 has prime factors: 2, 2, 3 Which sum to: 7
13 is prime number.
17 is prime number.
19 is prime number.
22 has prime factors: 2, 11 Which sum to: 13
23 is prime number.
28 has prime factors: 2, 2, 7 Which sum to: 11
29 is prime number.
31 is prime number.
34 has prime factors: 2, 17 Which sum to: 19
37 is prime number.
40 has prime factors: 2, 2, 2, 5 Which sum to: 11
41 is prime number.
43 is prime number.
45 has prime factors: 3, 3, 5 Which sum to: 11
47 is prime number.
48 has prime factors: 2, 2, 2, 2, 3 Which sum to: 11
52 has prime factors: 2, 2, 13 Which sum to: 17
53 is prime number.
54 has prime factors: 2, 3, 3, 3 Which sum to: 11
56 has prime factors: 2, 2, 2, 7 Which sum to: 13
58 has prime factors: 2, 29 Which sum to: 31
59 is prime number.
61 is prime number.
63 has prime factors: 3, 3, 7 Which sum to: 13
67 is prime number.
71 is prime number.
73 is prime number.
75 has prime factors: 3, 5, 5 Which sum to: 13
76 has prime factors: 2, 2, 19 Which sum to: 23
79 is prime number.
80 has prime factors: 2, 2, 2, 2, 5 Which sum to: 13
82 has prime factors: 2, 41 Which sum to: 43
83 is prime number.
88 has prime factors: 2, 2, 2, 11 Which sum to: 17
89 is prime number.
90 has prime factors: 2, 3, 3, 5 Which sum to: 13
96 has prime factors: 2, 2, 2, 2, 2, 3 Which sum to: 13
97 is prime number.
99 has prime factors: 3, 3, 11 Which sum to: 17
101 is prime number.
103 is prime number.
104 has prime factors: 2, 2, 2, 13 Which sum to: 19
107 is prime number.
108 has prime factors: 2, 2, 3, 3, 3 Which sum to: 13
109 is prime number.
113 is prime number.
117 has prime factors: 3, 3, 13 Which sum to: 19
118 has prime factors: 2, 59 Which sum to: 61
127 is prime number.
131 is prime number.
136 has prime factors: 2, 2, 2, 17 Which sum to: 23
137 is prime number.
139 is prime number.
142 has prime factors: 2, 71 Which sum to: 73
147 has prime factors: 3, 7, 7 Which sum to: 17
148 has prime factors: 2, 2, 37 Which sum to: 41
149 is prime number.
151 is prime number.
153 has prime factors: 3, 3, 17 Which sum to: 23
157 is prime number.
163 is prime number.
165 has prime factors: 3, 5, 11 Which sum to: 19
167 is prime number.
172 has prime factors: 2, 2, 43 Which sum to: 47
173 is prime number.
175 has prime factors: 5, 5, 7 Which sum to: 17
176 has prime factors: 2, 2, 2, 2, 11 Which sum to: 19
179 is prime number.
181 is prime number.
184 has prime factors: 2, 2, 2, 23 Which sum to: 29
191 is prime number.
193 is prime number.
197 is prime number.
198 has prime factors: 2, 3, 3, 11 Which sum to: 19
199 is prime number.
202 has prime factors: 2, 101 Which sum to: 103
207 has prime factors: 3, 3, 23 Which sum to: 29
210 has prime factors: 2, 3, 5, 7 Which sum to: 17
211 is prime number.
214 has prime factors: 2, 107 Which sum to: 109
223 is prime number.
224 has prime factors: 2, 2, 2, 2, 2, 7 Which sum to: 17
227 is prime number.
229 is prime number.
233 is prime number.
239 is prime number.
241 is prime number.
245 has prime factors: 5, 7, 7 Which sum to: 19
248 has prime factors: 2, 2, 2, 31 Which sum to: 37
250 has prime factors: 2, 5, 5, 5 Which sum to: 17
251 is prime number.
252 has prime factors: 2, 2, 3, 3, 7 Which sum to: 17
257 is prime number.
263 is prime number.
268 has prime factors: 2, 2, 67 Which sum to: 71
269 is prime number.
271 is prime number.
273 has prime factors: 3, 7, 13 Which sum to: 23
274 has prime factors: 2, 137 Which sum to: 139
277 is prime number.
279 has prime factors: 3, 3, 31 Which sum to: 37
281 is prime number.
283 is prime number.
293 is prime number.
294 has prime factors: 2, 3, 7, 7 Which sum to: 19
296 has prime factors: 2, 2, 2, 37 Which sum to: 43
298 has prime factors: 2, 149 Which sum to: 151
300 has prime factors: 2, 2, 3, 5, 5 Which sum to: 17
307 is prime number.
311 is prime number.
313 is prime number.
316 has prime factors: 2, 2, 79 Which sum to: 83
317 is prime number.
320 has prime factors: 2, 2, 2, 2, 2, 2, 5 Which sum to: 17
325 has prime factors: 5, 5, 13 Which sum to: 23
328 has prime factors: 2, 2, 2, 41 Which sum to: 47
331 is prime number.
333 has prime factors: 3, 3, 37 Which sum to: 43
337 is prime number.
345 has prime factors: 3, 5, 23 Which sum to: 31
347 is prime number.
349 is prime number.
350 has prime factors: 2, 5, 5, 7 Which sum to: 19
353 is prime number.
358 has prime factors: 2, 179 Which sum to: 181
359 is prime number.
360 has prime factors: 2, 2, 2, 3, 3, 5 Which sum to: 17
367 is prime number.
368 has prime factors: 2, 2, 2, 2, 23 Which sum to: 31
369 has prime factors: 3, 3, 41 Which sum to: 47
373 is prime number.
376 has prime factors: 2, 2, 2, 47 Which sum to: 53
379 is prime number.
382 has prime factors: 2, 191 Which sum to: 193
383 is prime number.
384 has prime factors: 2, 2, 2, 2, 2, 2, 2, 3 Which sum to: 17
385 has prime factors: 5, 7, 11 Which sum to: 23
388 has prime factors: 2, 2, 97 Which sum to: 101
389 is prime number.
390 has prime factors: 2, 3, 5, 13 Which sum to: 23
394 has prime factors: 2, 197 Which sum to: 199
397 is prime number.
399 has prime factors: 3, 7, 19 Which sum to: 29
401 is prime number.
405 has prime factors: 3, 3, 3, 3, 5 Which sum to: 17
409 is prime number.
412 has prime factors: 2, 2, 103 Which sum to: 107
414 has prime factors: 2, 3, 3, 23 Which sum to: 31
416 has prime factors: 2, 2, 2, 2, 2, 13 Which sum to: 23
419 is prime number.
420 has prime factors: 2, 2, 3, 5, 7 Which sum to: 19
421 is prime number.
423 has prime factors: 3, 3, 47 Which sum to: 53
424 has prime factors: 2, 2, 2, 53 Which sum to: 59
431 is prime number.
432 has prime factors: 2, 2, 2, 2, 3, 3, 3 Which sum to: 17
433 is prime number.
435 has prime factors: 3, 5, 29 Which sum to: 37
436 has prime factors: 2, 2, 109 Which sum to: 113
439 is prime number.
443 is prime number.
448 has prime factors: 2, 2, 2, 2, 2, 2, 7 Which sum to: 19
449 is prime number.
454 has prime factors: 2, 227 Which sum to: 229
457 is prime number.
461 is prime number.
462 has prime factors: 2, 3, 7, 11 Which sum to: 23
463 is prime number.
464 has prime factors: 2, 2, 2, 2, 29 Which sum to: 37
467 is prime number.
468 has prime factors: 2, 2, 3, 3, 13 Which sum to: 23
475 has prime factors: 5, 5, 19 Which sum to: 29
477 has prime factors: 3, 3, 53 Which sum to: 59
478 has prime factors: 2, 239 Which sum to: 241
479 is prime number.
486 has prime factors: 2, 3, 3, 3, 3, 3 Which sum to: 17
487 is prime number.
488 has prime factors: 2, 2, 2, 61 Which sum to: 67
491 is prime number.
499 is prime number.
500 has prime factors: 2, 2, 5, 5, 5 Which sum to: 19
503 is prime number.
504 has prime factors: 2, 2, 2, 3, 3, 7 Which sum to: 19
507 has prime factors: 3, 13, 13 Which sum to: 29
508 has prime factors: 2, 2, 127 Which sum to: 131
509 is prime number.
521 is prime number.
522 has prime factors: 2, 3, 3, 29 Which sum to: 37
523 is prime number.
536 has prime factors: 2, 2, 2, 67 Which sum to: 73
538 has prime factors: 2, 269 Which sum to: 271
541 is prime number.
547 is prime number.
549 has prime factors: 3, 3, 61 Which sum to: 67
550 has prime factors: 2, 5, 5, 11 Which sum to: 23
557 is prime number.
561 has prime factors: 3, 11, 17 Which sum to: 31
562 has prime factors: 2, 281 Which sum to: 283
563 is prime number.
567 has prime factors: 3, 3, 3, 3, 7 Which sum to: 19
569 is prime number.
570 has prime factors: 2, 3, 5, 19 Which sum to: 29
571 is prime number.
577 is prime number.
584 has prime factors: 2, 2, 2, 73 Which sum to: 79
587 is prime number.
593 is prime number.
595 has prime factors: 5, 7, 17 Which sum to: 29
599 is prime number.
600 has prime factors: 2, 2, 2, 3, 5, 5 Which sum to: 19
601 is prime number.
603 has prime factors: 3, 3, 67 Which sum to: 73
607 is prime number.
608 has prime factors: 2, 2, 2, 2, 2, 19 Which sum to: 29
613 is prime number.
617 is prime number.
619 is prime number.
622 has prime factors: 2, 311 Which sum to: 313
631 is prime number.
640 has prime factors: 2, 2, 2, 2, 2, 2, 2, 5 Which sum to: 19
641 is prime number.
643 is prime number.
647 is prime number.
651 has prime factors: 3, 7, 31 Which sum to: 41
652 has prime factors: 2, 2, 163 Which sum to: 167
653 is prime number.
657 has prime factors: 3, 3, 73 Which sum to: 79
659 is prime number.
660 has prime factors: 2, 2, 3, 5, 11 Which sum to: 23
661 is prime number.
664 has prime factors: 2, 2, 2, 83 Which sum to: 89
665 has prime factors: 5, 7, 19 Which sum to: 31
673 is prime number.
675 has prime factors: 3, 3, 3, 5, 5 Which sum to: 19
677 is prime number.
683 is prime number.
684 has prime factors: 2, 2, 3, 3, 19 Which sum to: 29
686 has prime factors: 2, 7, 7, 7 Which sum to: 23
691 is prime number.
694 has prime factors: 2, 347 Which sum to: 349
701 is prime number.
704 has prime factors: 2, 2, 2, 2, 2, 2, 11 Which sum to: 23
709 is prime number.
714 has prime factors: 2, 3, 7, 17 Which sum to: 29
715 has prime factors: 5, 11, 13 Which sum to: 29
719 is prime number.
720 has prime factors: 2, 2, 2, 2, 3, 3, 5 Which sum to: 19
727 is prime number.
733 is prime number.
739 is prime number.
743 is prime number.
747 has prime factors: 3, 3, 83 Which sum to: 89
751 is prime number.
757 is prime number.
759 has prime factors: 3, 11, 23 Which sum to: 37
761 is prime number.
768 has prime factors: 2, 2, 2, 2, 2, 2, 2, 2, 3 Which sum to: 19
769 is prime number.
772 has prime factors: 2, 2, 193 Which sum to: 197
773 is prime number.
775 has prime factors: 5, 5, 31 Which sum to: 41
776 has prime factors: 2, 2, 2, 97 Which sum to: 103
777 has prime factors: 3, 7, 37 Which sum to: 47
787 is prime number.
792 has prime factors: 2, 2, 2, 3, 3, 11 Which sum to: 23
795 has prime factors: 3, 5, 53 Which sum to: 61
797 is prime number.
798 has prime factors: 2, 3, 7, 19 Which sum to: 31
808 has prime factors: 2, 2, 2, 101 Which sum to: 107
809 is prime number.
810 has prime factors: 2, 3, 3, 3, 3, 5 Which sum to: 19
811 is prime number.
821 is prime number.
823 is prime number.
824 has prime factors: 2, 2, 2, 103 Which sum to: 109
827 is prime number.
829 is prime number.
833 has prime factors: 7, 7, 17 Which sum to: 31
838 has prime factors: 2, 419 Which sum to: 421
839 is prime number.
845 has prime factors: 5, 13, 13 Which sum to: 31
847 has prime factors: 7, 11, 11 Which sum to: 29
848 has prime factors: 2, 2, 2, 2, 53 Which sum to: 61
850 has prime factors: 2, 5, 5, 17 Which sum to: 29
853 is prime number.
856 has prime factors: 2, 2, 2, 107 Which sum to: 113
857 is prime number.
858 has prime factors: 2, 3, 11, 13 Which sum to: 29
859 is prime number.
862 has prime factors: 2, 431 Which sum to: 433
863 is prime number.
864 has prime factors: 2, 2, 2, 2, 2, 3, 3, 3 Which sum to: 19
867 has prime factors: 3, 17, 17 Which sum to: 37
873 has prime factors: 3, 3, 97 Which sum to: 103
877 is prime number.
881 is prime number.
883 is prime number.
885 has prime factors: 3, 5, 59 Which sum to: 67
887 is prime number.
891 has prime factors: 3, 3, 3, 3, 11 Which sum to: 23
892 has prime factors: 2, 2, 223 Which sum to: 227
903 has prime factors: 3, 7, 43 Which sum to: 53
907 is prime number.
909 has prime factors: 3, 3, 101 Which sum to: 107
911 is prime number.
916 has prime factors: 2, 2, 229 Which sum to: 233
919 is prime number.
922 has prime factors: 2, 461 Which sum to: 463
925 has prime factors: 5, 5, 37 Which sum to: 47
927 has prime factors: 3, 3, 103 Which sum to: 109
929 is prime number.
930 has prime factors: 2, 3, 5, 31 Which sum to: 41
937 is prime number.
941 is prime number.
944 has prime factors: 2, 2, 2, 2, 59 Which sum to: 67
947 is prime number.
950 has prime factors: 2, 5, 5, 19 Which sum to: 31
953 is prime number.
954 has prime factors: 2, 3, 3, 53 Which sum to: 61
957 has prime factors: 3, 11, 29 Which sum to: 43
963 has prime factors: 3, 3, 107 Which sum to: 113
967 is prime number.
971 is prime number.
972 has prime factors: 2, 2, 3, 3, 3, 3, 3 Which sum to: 19
977 is prime number.
980 has prime factors: 2, 2, 5, 7, 7 Which sum to: 23
983 is prime number.
991 is prime number.
992 has prime factors: 2, 2, 2, 2, 2, 31 Which sum to: 41
997 is prime number.

复习之前学习的直接计算素数表的程序
ch04_p13.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

vector<int> primes_norm;

bool is_prime(int n)
{
    for (int i = 0; i < primes_norm.size() && primes_norm[i] <= sqrt(n); ++i)
    {
        if (n % primes_norm[i] == 0)
        {
            return false;
        }
    }
    return true;
}

void init_prime(int n)
{
    if (n < 100)
    {
        return ;
    }
    primes_norm.clear();
    int i, j;
    char *buffer = new char[n + 1];
    for(i = 1; i <= n; i++)
    {
        buffer[i] = 0;
    }
    for(i = 2; i <= n; i++)
    {
        if(buffer[i] == 0)
        {
            primes_norm.push_back(i);
        }
        if( i <= ( (n / 2) + 1) )
        {
            for(j = 0; j < primes_norm.size() && primes_norm[j] * i <= n; j++)
            {
                buffer[primes_norm[j]*i] = 1;
                if(i % primes_norm[j] == 0)
                {
                    break;
                }
            }
        }
    }
    delete [] buffer;
}

int main()
{
    init_prime(100);
    for (int i = 0; i < primes_norm.size(); ++i)
    {
        cout << primes_norm[i] << endl;
    }
}
显示结果如下
2
3
5
7
11
13
17
19
23
29
31
37
41
43
47
53
59
61
67
71
73
79
83
89
97

ch04_p16.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int get_mode(vector<int> v)
{
    if (v.size() == 0)
    {
        throw domain_error("call get_mode for empty vector");
    }

    sort(v.begin(),v.end());
    int mode_cdt = v[0];
    int mode_cdt_ctr = 1;
    int mode = v[0];
    int mode_ctr = 1;
    for (int i = 1; i<v.size(); ++i)
    {
        if (v[i]==mode_cdt)
        {
            ++mode_cdt_ctr;
            if (mode_cdt_ctr>mode_ctr)
            {
                mode = mode_cdt;
                mode_ctr = mode_cdt_ctr;
            }
        }
        else
        {
            mode_cdt = v[i];
            mode_cdt_ctr = 1;
        }
    }
    cout << mode << " appears " << mode_ctr << " times.\n";
    return mode;
}

int main()
{
    int n = 0;
    int smallest = 0;
    int largest = 0;
    int mode = 0;
    vector<int> vals;
    bool is_first = true;

    cout << "Enter sequence of integers:\n";

    while (cin >> n)
    {
        if (n < smallest || is_first)
        {
            smallest = n;
        }
        if (n > largest || is_first)
        {
            largest = n;
        }
        vals.push_back(n);
        is_first = false;
    }

    mode = get_mode(vals);
    cout << "smallest value: " << smallest << endl;
    cout << "largest value: " << largest << endl;
    cout << "mode: " << mode << endl;

    cout << "values:" << endl;
    for (int i = 0; i<vals.size(); ++i)
    {
        cout << vals[i] << endl;
    }
    return 0;
}
显示结果如下
Enter sequence of integers:
1 3 5 7 5 3 6 9 3 2
3 appears 3 times.
smallest value: 1
largest value: 9
mode: 3
values:
1
3
5
7
5
3
6
9
3
2

ch04_p17.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

string get_mode(vector<string> v)
{
    if (v.size() == 0)
    {
        throw domain_error("call get_mode for empty vector");
    }

    sort(v.begin(), v.end());
    string mode_cdt = v[0];
    int mode_cdt_ctr = 1;
    string mode = v[0];
    int mode_ctr = 1;
    for (int i = 1; i < v.size(); ++i)
    {
        if (v[i] == mode_cdt)
        {
            ++mode_cdt_ctr;
            if (mode_cdt_ctr > mode_ctr)
            {
                mode = mode_cdt;
                mode_ctr = mode_cdt_ctr;
            }
        }
        else
        {
            mode_cdt = v[i];
            mode_cdt_ctr = 1;
        }
    }
    cout << mode << " appears " << mode_ctr << (mode_ctr > 1 ? " times.\n" : " time.\n");
    return mode;
}

int main()
{
    string n = "";
    string smallest = "";
    string largest = "";
    string mode = "";
    vector<string> vals;
    bool is_first = true;

    cout << "Enter sequence of strings:\n";

    while (cin >> n)
    {
        if (n < smallest || is_first)
        {
            smallest = n;
        }
        if (n > largest || is_first)
        {
            largest = n;
        }
        vals.push_back(n);
        is_first = false;
    }

    mode = get_mode(vals);
    cout << "smallest value: " << smallest << endl;
    cout << "largest value: " << largest << endl;
    cout << "mode: " << mode << endl;

    cout << "values:" << endl;
    for (int i = 0; i < vals.size(); ++i)
    {
        cout << vals[i] << endl;
    }
    return 0;
}
显示结果如下
Enter sequence of strings:
Peter Smith Mike Peter Hello Peter World Water Flower
Peter appears 3 times.
smallest value: Flower
largest value: World
mode: Peter
values:
Peter
Smith
Mike
Peter
Hello
Peter
World
Water
Flower

ch04_p18.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    cout << "Enter coefficients a, b and c of ax^2 + bx + c = 0:\n";
    double a = 0;
    double b = 0;
    double c = 0;
    while (cin >> a && cin >> b && cin >> c)
    {
        double delta = b * b - 4 * a * c;
        if (delta < 0)
        {
            cout << "Sorry, no complex math here - can't solve that! Try again:\n";
        }
        else if (delta == 0)
        {
            double x = -b / (2 * a);
            cout << "Just one solution: x = " << x << endl;
        }
        else
        {
            double x1 = (-b + sqrt(delta)) / (2 * a);
            double x2 = (-b - sqrt(delta)) / (2 * a);
            cout << "Two solutions: x1 = " << x1 << ", x2 = " << x2 << endl;
        }
    }
}
显示结果如下
Enter coefficients a, b and c of ax^2 + bx + c = 0:
1 3 2
Two solutions: x1 = -1, x2 = -2

ch04_p19.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

vector<string> names;
vector<int> scores;

void list_score(string s)
{
    int i = 0;
    while (i < names.size())
    {
        if (names[i] == s)
        {
            cout << '(' << s << ',' << scores[i] << ")\n";
            return;
        }
        ++i;
    }
    cout << "Name not found\n";
}

void list_names(int n)
{
    bool exists = false;
    for (int i = 0; i < scores.size(); ++i)
    {
        if (scores[i] == n)
        {
            cout << '(' << names[i] << ',' << n << ")\n";
            exists = true;
        }
    }
    if (!exists)
    {
        cout << "Score not found\n";
    }
}

int main()
{
    string name = " ";
    int score = 0;
    cout << "Enter name-and-value pairs such as 'Joe 17':\n";
    while (cin >> name && cin >> score)
    {
        names.push_back(name);
        scores.push_back(score);
    }

    for (int i = 0; i < names.size(); ++i)
    {
        for (int j = i + 1; j < names.size(); ++j)
        {
            if (names[i] == names[j])
            {
                error("Name appears twice!");
            }
        }
    }

    for (int i = 0; i < names.size(); ++i)
    {
        cout << '(' << names[i] << ',' << scores[i] << ")\n";
    }

    cin.clear();
    while (cin.get() != '\n')
    {
        continue;
    }
    int sc = 0;
    cout << "Enter name or score ('NoName' to exit):\n";
    while (true)
    {
        if (cin >> sc)
        {
            list_names(sc);
        }
        else
        {
            cin.clear();
            string na;
            cin >> na;
            if (na == "NoName")
            {
                return 0;
            }
            list_score(na);
        }
        cout << "Enter name or score ('NoName' to exit):\n";
    }
}
显示结果如下
Enter name-and-value pairs such as 'Joe 17':
Peter 35
Smith 53
Mike 68
Pence 96
Hello 86
World 65
Water 99
q q
(Peter,35)
(Smith,53)
(Mike,68)
(Pence,96)
(Hello,86)
(World,65)
(Water,99)
Enter name or score ('NoName' to exit):
96
(Pence,96)
Enter name or score ('NoName' to exit):
99
(Water,99)
Enter name or score ('NoName' to exit):
Smith
(Smith,53)
Enter name or score ('NoName' to exit):
Mike
(Mike,68)
Enter name or score ('NoName' to exit):
World
(World,65)
Enter name or score ('NoName' to exit):
NoName

第5章 错误
5.1 介绍
5.2 错误的来源
5.3 编译时错误
5.3.1 语法错误
5.3.2 类型错误
5.3.3 警告
5.4 连接时错误
5.5 运行时错误
5.5.1 调用者处理错误
5.5.2 被调用者处理错误
5.5.3 报告错误
5.6 异常
5.6.1 错误参数
5.6.2 范围错误
5.6.3 输入错误
5.6.4 截断错误
5.7 逻辑错误
5.8 估计
5.9 调试
5.9.1 实用调试技术
5.10 前置条件和后置条件
5.10.1 后置条件
5.11 测试
ch05_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

double ctok(double c)
{
    if (c < -273.15)
    {
        error("Temperature below absolute zero!");
    }
    double k = c + 273.15;
    return k;
}

double ktoc(double k)
{
    if (k < 0)
    {
        error("Temperature below absolute zero!");
    }
    double c = k - 273.15;
    return c;
}

int main()
{
    try
    {
        double temp = 0;
        char unit = 0;
        double t_conv = 0;
        char unit_conv = 0;

        cout << "Enter temperature to be converted and unit (C or K):\n";
        cin >> temp >> unit;
        if (unit == 'c' || unit == 'C')
        {
            t_conv = ctok(temp);
            unit_conv = 'K';
        }
        else if (unit == 'k' || unit == 'K')
        {
            t_conv = ktoc(temp);
            unit_conv = 'C';
        }
        else
        {
            error("Illegal unit, must be C or K");
        }
        cout << t_conv << ' ' << unit_conv << endl;
        return 0;
    }
    catch (exception &e)
    {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    catch (...)
    {
        cerr << "Unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter temperature to be converted and unit (C or K):
32C
305.15 K

Enter temperature to be converted and unit (C or K):
273K
-0.15 C

Enter temperature to be converted and unit (C or K):
-3K
Temperature below absolute zero!
Error: Temperature below absolute zero!

Enter temperature to be converted and unit (C or K):
-275C
Temperature below absolute zero!
Error: Temperature below absolute zero!

Enter temperature to be converted and unit (C or K):
23U
Illegal unit, must be C or K
Error: Illegal unit, must be C or K

ch05_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

double ctok(double c)
{
    if (c < -273.15)
    {
        error("Temperature below absolute zero!");
    }
    double k = c + 273.15;
    return k;
}

double ktoc(double k)
{
    if (k < 0)
    {
        error("Temperature below absolute zero!");
    }
    double c = k - 273.15;
    return c;
}

double ctof(double c)
{
    if (c < -273.15)
    {
        error("Temperature below absolute zero!");
    }
    double f = c * 9.0 / 5.0 + 32;
    return f;
}

double ftoc(double f)
{
    if (f < -459.67)
    {
        error("Temperature below absolute zero!");
    }
    double c = (f - 32) * 5.0 / 9.0;
    return c;
}

int main()
{
    try
    {
        double temp = 0;
        char unit = 0;
        double t_conv = 0;
        char unit_conv = 0;

        cout << "Enter temperature to be converted and unit (C or F):\n";
        cin >> temp >> unit;
        if (unit == 'c' || unit == 'C')
        {
            t_conv = ctof(temp);
            unit_conv = 'F';
        }
        else if (unit == 'f' || unit == 'F')
        {
            t_conv = ftoc(temp);
            unit_conv = 'C';
        }
        else
        {
            error("Illegal unit, must be C or F");
        }
        cout << t_conv << ' ' << unit_conv << endl;
        return 0;
    }
    catch (exception &e)
    {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    catch (...)
    {
        cerr << "Unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter temperature to be converted and unit (C or F):
32C
89.6 F

Enter temperature to be converted and unit (C or F):
123F
50.5556 C

Enter temperature to be converted and unit (C or F):
-275C
Temperature below absolute zero!
Error: Temperature below absolute zero!

Enter temperature to be converted and unit (C or F):
-499F
Temperature below absolute zero!
Error: Temperature below absolute zero!

Enter temperature to be converted and unit (C or F):
23K
Illegal unit, must be C or F
Error: Illegal unit, must be C or F

ch05_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

double a, b, c;
bool do_check;

double found(double x)
{
    if (!do_check)
    {
        return x;
    }
    else
    {
        const double epsilon = 1e-7;
        double e = a * x * x + b * x + c;
        if (e == 0)
        {
            return x;
        }
        if (epsilon < e)
        {
            cout << "poor root; off by " << e << endl;
        }
        else if (e < -epsilon)
        {
            cout << "poor root; off by " << e << endl;
        }
        return x;
    }
}

void quad_solver()
{
    while (cin >> a && cin >> b && cin >> c)
    {
        if (a == 0)
        {
            if (b == 0)
            {
                cout << "no root (x isn't used)\n";
            }
            else
            {
                cout << "x = " << found(-c / b) << endl;
            }
        }
        else if (b == 0)
        {
            double ca = -c / a;
            if (ca == 0)
            {
                cout << "x = 0\n";
            }
            else if (ca < 0)
            {
                cout << "no real roots\n";
            }
            else
            {
                cout << "two real roots: x = " << found(sqrt(ca)) << " and " << found(-sqrt(ca)) << endl;
            }
        }
        else
        {
            double delta = b * b - 4 * a * c;
            if (delta == 0)
            {
                cout << "one real root: " << found(-b / (2 * a)) << endl;
            }
            else if (delta < 0)
            {
                cout << "no real roots\n";
            }
            else
            {
                cout << "two real roots: " << found((-b + sqrt(delta)) / (2 * a)) << " and " << found((-b - sqrt(delta)) / (2 * a)) << endl;
            }
        }
        cout << "Enter coefficients for quadratic equation a*x^2 + b*x + c = 0\n";
    }
}

int main()
{
    try
    {
        cout << "Should your solutions be checked?\n";
        char check = 0;
        cin >> check;
        if (check == 'y' || check == 'Y')
        {
            do_check = true;
        }
        else if (check == 'n' || check == 'N')
        {
            do_check = false;
        }
        else
        {
            error("answer not recognised (try 'y' or 'n')");
        }
        cout << "Enter coefficients for quadratic equation a*x^2 + b*x + c = 0\n";
        quad_solver();
        return 0;
    }
    catch (exception &e)
    {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    catch (...)
    {
        cerr << "Unknown exception!\n";
        return 2;
    }
}
显示结果如下
Should your solutions be checked?
y
Enter coefficients for quadratic equation a*x^2 + b*x + c = 0
1 2 3
no real roots
Enter coefficients for quadratic equation a*x^2 + b*x + c = 0
1 3 2
two real roots: -1 and -2
Enter coefficients for quadratic equation a*x^2 + b*x + c = 0
1 0 3
no real roots
Enter coefficients for quadratic equation a*x^2 + b*x + c = 0
1 0 -2
two real roots: x = 1.41421 and -1.41421
Enter coefficients for quadratic equation a*x^2 + b*x + c = 0
0 2 3
x = -1.5
Enter coefficients for quadratic equation a*x^2 + b*x + c = 0
q q q

ch05_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    try
    {
        vector<int> vals;
        int val = 0;
        int n = 0;

        cout << "Please enter the number of values you want to sum:\n";
        cin >> n;
        if (n < 1)
        {
            error("You have to sum at least one value!");
        }
        cout << "Please enter some integers (press end to stop)\n";
        while (cin >> val)
        {
            vals.push_back(val);
        }

        if (vals.size() < n)
        {
            error("You wanted to sum more values than you entered");
        }

        int sum = 0;
        cout << "The sum of the first ";
        if (n > 1)
        {
            cout << n << " numbers";
        }
        else
        {
            cout << "number";
        }
        cout << " ( ";
        for (int i = 0; i < n; ++i)
        {
            sum += vals[i];
            cout << vals[i] << ' ';
        }
        cout << ") is " << sum << ".\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    catch (...)
    {
        cerr << "Unknown exception!\n";
        return 2;
    }
}
显示结果如下
Please enter the number of values you want to sum:
6
Please enter some integers (press end to stop)
1 3 5 6 8 9 15 end
The sum of the first 6 numbers ( 1 3 5 6 8 9 ) is 32.

ch05_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

double ctok(double c)
{
    if (c < -273.15)
    {
        error("Temperature below absolute zero!");
    }
    double k = c + 273.15;
    return k;
}

double ktoc(double k)
{
    if (k < 0)
    {
        error("Temperature below absolute zero!");
    }
    double c = k - 273.15;
    return c;
}

double ctof(double c)
{
    if (c < -273.15)
    {
        error("Temperature below absolute zero!");
    }
    double f_exact = c * 9.0/5.0 + 32;
    int f = int(f_exact);
    if (f != f_exact) { error("Result cannot be represented as an int!"); }
    return f;
}

double ftoc(double f)
{
    if (f < -459.67)
    {
        error("Temperature below absolute zero!");
    }
    double c_exact = (f - 32) * 5.0/9.0;
    int c =  int(c_exact);
    if (c != c_exact) { error("Result cannot be represented as an int!"); }
    return c;
}

int main()
{
    try
    {
        double temp = 0;
        char unit = 0;
        double t_conv = 0;
        char unit_conv = 0;

        cout << "Enter temperature to be converted and unit (C or F):\n";
        cin >> temp >> unit;
        if (unit == 'c' || unit == 'C')
        {
            t_conv = ctof(temp);
            unit_conv = 'F';
        }
        else if (unit == 'f' || unit == 'F')
        {
            t_conv = ftoc(temp);
            unit_conv = 'C';
        }
        else
        {
            error("Illegal unit, must be C or F");
        }
        cout << t_conv << ' ' << unit_conv << endl;
        return 0;
    }
    catch (exception &e)
    {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    catch (...)
    {
        cerr << "Unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter temperature to be converted and unit (C or F):
32C
Result cannot be represented as an int!
Error: Result cannot be represented as an int!

Enter temperature to be converted and unit (C or F):
32F
0 C

Enter temperature to be converted and unit (C or F):
30C
86 F

ch05_p10.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    try
    {
        vector<double> vals;
        vector<double> diffs;
        double val = 0;
        int n = 0;

        cout << "Please enter the number of values you want to sum:\n";
        cin >> n;
        if (n < 1)
        {
            error("You have to sum at least one value!");
        }
        cout << "Please enter some doubles (press quit to stop)\n";
        while (cin >> val)
        {
            if (vals.size() >= 1)
            {
                diffs.push_back(val - vals[vals.size() - 1]);
            }
            vals.push_back(val);
        }

        if (vals.size() < 2)
        {
            cout << "You need at least two values to get a vector of differences\n";
        }
        else
        {
            cout << "Vector of differences:\n";
            for (int i = 0; i < diffs.size(); ++i)
            {
                cout << diffs[i] << endl;
            }
        }

        if (vals.size() < n)
        {
            error("You wanted to sum more values than you entered");
        }

        double sum = 0;
        cout << "The sum of the first ";
        if (n > 1)
        {
            cout << n << " numbers";
        }
        else
        {
            cout << "number";
        }
        cout << " ( ";
        for (int i = 0; i < n; ++i)
        {
            sum += vals[i];
            cout << vals[i] << ' ';
        }
        cout << ") is " << sum << ".\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    catch (...)
    {
        cerr << "Unknown exception!\n";
        return 2;
    }
}
显示结果如下
Please enter the number of values you want to sum:
6
Please enter some doubles (press quit to stop)
1.1 2.5 3.8 5.3 6.9 7.6 9.5 quit
Vector of differences:
1.4
1.3
1.5
1.6
0.7
1.9
The sum of the first 6 numbers ( 1.1 2.5 3.8 5.3 6.9 7.6 ) is 27.2.

ch05_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    try
    {
        char largest = 0;
        cout << "Do you just want to find the largest Fibonacci number (y/n)?\n";
        cin >> largest;
        if (!(largest == 'y' || largest == 'n' || largest == 'Y' || largest == 'N'))
        {
            error("Please enter either 'y' or 'n'");
        }
        vector<int> fib;
        fib.push_back(1);
        fib.push_back(1);
        if (largest == 'n' || largest == 'N')
        {
            int n = 0;
            cout << "How many Fibonacci numbers do you want to see?\n";
            cin >> n;
            if (n < 10)
            {
                error("Please enter a number >= 10");
            }
            for (int i = 2; i < n; ++i)
            {
                fib.push_back(fib[i - 1] + fib[i - 2]);
            }

            cout << "Fibonacci numbers:\n";
            for (int i = 0; i < n; ++i)
            {
                cout << fib[i] << endl;
            }
        }
        else
        {
            while (fib[fib.size() - 1] + fib[fib.size() - 2] > fib[fib.size() - 1])
            {
                fib.push_back(fib[fib.size() - 1] + fib[fib.size() - 2]);
            }
            cout << "The biggest Fibonacci number to fit in an int is " << fib[fib.size() - 1] << endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    catch (...)
    {
        cerr << "Unknown exception!\n";
        return 2;
    }
}
显示结果如下
Do you just want to find the largest Fibonacci number (y/n)?
y
The biggest Fibonacci number to fit in an int is 1836311903

Do you just want to find the largest Fibonacci number (y/n)?
n
How many Fibonacci numbers do you want to see?
30
Fibonacci numbers:
1
1
2
3
5
8
13
21
34
55
89
144
233
377
610
987
1597
2584
4181
6765
10946
17711
28657
46368
75025
121393
196418
317811
514229
832040

ch05_p12.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_improved(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

template<class T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int bulls = 0;
int cows = 0;

vector<int> get_new_solution(mt19937 &e)
{
    vector<int> solution(4);
    solution[0] = nrand_improved(10, e);
    solution[1] = nrand_improved(10, e);
    solution[2] = nrand_improved(10, e);
    solution[3] = nrand_improved(10, e);
    return solution;
}

vector<int> int_to_vector(int n)
{
    if (n > 9999 || n < 0)
    {
        error("int_to_vector called with wrong number");
    }
    vector<int> v(4);
    v[0] = n / 1000 % 10;
    v[1] = n / 100 % 10;
    v[2] = n / 10 % 10;
    v[3] = n % 10;
    return v;
}

void check_guess(const vector<int> &guess, const vector<int> &solution)
{
    bulls = 0;
    cows = 0;
    vector<char> is_bull(4, 'n');
    vector<char> is_cow(4, 'n');
    for (int i = 0; i < solution.size(); ++i)
    {
        if (guess[i] == solution[i])
        {
            ++bulls;
            is_bull[i] = 'y';
        }
    }
    for (int i = 0; i < solution.size(); ++i)
    {
        if (is_bull[i] == 'n')
        {
            for (int j = 0; j < guess.size(); ++j)
            {
                if (is_bull[j] == 'n' && is_cow[j] == 'n')
                {
                    if (solution[i] == guess[j])
                    {
                        ++cows;
                        is_cow[j] = 'y';
                    }
                }
            }
        }
    }
}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);

    try
    {
        int guess = 0;
        cout << "Guess my four digit number! Numbers with less digits will be padded with zeros.\n";
        vector<int> solution = get_new_solution(engine);
        print_vector(solution, cout);
        cout << "Enter guess ('q' to exit): ";
        while (cin >> guess)
        {
            if (guess > 9999 || guess < 0)
            {
                cout << "Number must be between 0000 and 9999!\n";
            }
            else
            {
                vector<int> v_guess = int_to_vector(guess);
                check_guess(v_guess, solution);
                if (bulls == 4)
                {
                    cout << "You have guessed the number! Setting new solution...\n";
                    solution = get_new_solution(engine);
                    print_vector(solution, cout);
                }
                if (bulls < 4)
                {
                    cout << "Number of bulls: " << bulls << endl;
                    cout << "Number of cows: " << cows << endl;
                }
            }
            cout << "Enter guess ('q' to exit): ";
        }
        cout << "You gave up!\n";
        return 0;
    }
    catch (exception &e)
    {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    catch (...)
    {
        cerr << "Unknown exception!\n";
        return 2;
    }
}
显示结果如下
Guess my four digit number! Numbers with less digits will be padded with zeros.
3, 1, 6, 2
Enter guess ('q' to exit): 3256
Number of bulls: 1
Number of cows: 2
Enter guess ('q' to exit): 3165
Number of bulls: 3
Number of cows: 0
Enter guess ('q' to exit): 3162
You have guessed the number! Setting new solution...
6, 0, 6, 5
Enter guess ('q' to exit): 6163
Number of bulls: 2
Number of cows: 0
Enter guess ('q' to exit): 6136
Number of bulls: 1
Number of cows: 1
Enter guess ('q' to exit): q
You gave up!

ch05_p14.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

vector<int> mondays;
vector<int> tuesdays;
vector<int> wednesdays;
vector<int> thursdays;
vector<int> fridays;
vector<int> saturdays;
vector<int> sundays;
int rejected = 0;

int handle_input(string day, int val)
{
    int cont = 0;
    if (day == "Monday" || day == "monday" || day == "Mon" || day == "mon")
    {
        mondays.push_back(val);
    }
    else if (day == "Tuesday" || day == "tuesday" || day == "Tue" || day == "tue")
    {
        tuesdays.push_back(val);
    }
    else if (day == "Wednesday" || day == "wednesday" || day == "Wed" || day == "wed")
    {
        wednesdays.push_back(val);
    }
    else if (day == "Thursday" || day == "thursday" || day == "Thu" || day == "thu")
    {
        thursdays.push_back(val);
    }
    else if (day == "Friday" || day == "friday" || day == "Fri" || day == "fri")
    {
        fridays.push_back(val);
    }
    else if (day == "Saturday" || day == "saturday" || day == "Sat" || day == "sat")
    {
        saturdays.push_back(val);
    }
    else if (day == "Sunday" || day == "sunday" || day == "Sun" || day == "sun")
    {
        sundays.push_back(val);
    }
    else if (day == "q" && val == 0)
    {
        cont = -1;
    }
    else
    {
        ++rejected;
    }
    return cont;
}

int get_sum(const vector<int> &v)
{
    int sum = 0;
    for (int i = 0; i < v.size(); ++i)
    {
        sum += v[i];
    }
    return sum;
}

void print_day(string day, const vector<int> &v)
{
    cout << day << " (sum: " << get_sum(v) << ")\n";
    cout << "Values:";
    for (int i = 0; i < v.size(); ++i)
    {
        cout << ' ' << v[i];
    }
    cout << endl;
}

void print_results()
{
    print_day("Monday", mondays);
    print_day("Tuesday", tuesdays);
    print_day("Wednesday", wednesdays);
    print_day("Thursday", thursdays);
    print_day("Friday", fridays);
    print_day("Saturday", saturdays);
    print_day("Sunday", sundays);
    cout << rejected << " values rejected\n";
}

int main()
{
    try
    {
        string day = " ";
        int val = 0;
        cout << "Enter weekday/value pairs, exit with 'q 0'\n";
        while (cin >> day && cin >> val)
        {
            int cont = handle_input(day, val);
            if (cont == -1)
            {
                print_results();
                return 0;
            }
        }
        error("Invalid input");
    }
    catch (exception &e)
    {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    catch (...)
    {
        cerr << "Unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter weekday/value pairs, exit with 'q 0'
Mon 12
Tue 32
Wed 33
Thu 56
Fri 67
Sat 25
Sun 99
Mon 77
Tue 56
Fri 86
q 0
Monday (sum: 89)
Values: 12 77
Tuesday (sum: 88)
Values: 32 56
Wednesday (sum: 33)
Values: 33
Thursday (sum: 56)
Values: 56
Friday (sum: 153)
Values: 67 86
Saturday (sum: 25)
Values: 25
Sunday (sum: 99)
Values: 99
0 values rejected

第6章 编写一个程序
6.1 一个问题
6.2 对问题的思考
6.2.1 程序设计的几个阶段.
6.2.2 策略
6.3 回到计算器问题
6.3.1 第一步尝试
6.3.2 单词
6.3.3 实现单词
6.3.4 使用单词
6.3.5 重新开始
6.4 文法
6.4.1 英文文法
6.4.2 设计一个文法
6.5 将文法转换为程序
6.5.1 实现文法规则
6.5.2 表达式
6.5.3 项
6.5.4 基本表达式
6.6 试验第一个版本
6.7 试验第二个版本
6.8 单词流
6.8.1 实现Token_stream
6.8.2 读单词
6.8.3 读数值
6.9 程序结构
ch06_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

class Token
{
public:
    char kind;
    double value;
    Token(char ch) : kind(ch), value(0) { }
    Token(char ch, double val) : kind(ch), value(val) { }
};

class Token_stream
{
public:
    Token_stream();
    Token get();
    void putback(Token t);
private:
    bool full;
    Token buffer;
};

Token_stream::Token_stream() : full(false), buffer(0) { }

void Token_stream::putback(Token t)
{
    if (full)
    {
        error("putback() into a full buffer");
    }
    buffer = t;
    full = true;
}

Token Token_stream::get()
{
    if (full)
    {
        full = false;
        return buffer;
    }

    char ch;
    cin >> ch;

    switch (ch)
    {
    case ';':
    case 'q':
    case '(':
    case ')':
    case '+':
    case '-':
    case '*':
    case '/':
        return Token(ch);
    case '.':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    {
        cin.putback(ch);
        double val;
        cin >> val;
        return Token('8', val);
    }
    default:
        error("Bad token");
    }
}

Token_stream ts;

double expression();

double primary()
{
    Token t = ts.get();
    switch (t.kind)
    {
    case '(':
    {
        double d = expression();
        t = ts.get();
        if (t.kind != ')')
        {
            error("')' expected");
        }
        return d;
    }
    case '8':
        return t.value;
    default:
        error("primary expected");
    }
}

double term()
{
    double left = primary();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '*':
            left *= primary();
            t = ts.get();
            break;
        case '/':
        {
            double d = primary();
            if (d == 0)
            {
                error("divide by zero");
            }
            left /= d;
            t = ts.get();
            break;
        }
        default:
            ts.putback(t);
            return left;
        }
    }
}

double expression()
{
    double left = term();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '+':
            left += term();
            t = ts.get();
            break;
        case '-':
            left -= term();
            t = ts.get();
            break;
        default:
            ts.putback(t);
            return left;
        }
    }
}

int main()
{
    try
    {
        cout << "Welcome to our simple calculator.\n";
        cout << "Please enter expressions using floating-point numbers.\n";
        cout << "Operators available: +, -, *, /, ().\n";
        cout << "To print the result, enter ';' and to quit, enter 'q'.\n";
        while (cin)
        {
            cout << "> ";
            Token t = ts.get();
            while (t.kind == ';')
            {
                t = ts.get();
            }
            if (t.kind == 'q')
            {
                return 0;
            }
            ts.putback(t);
            cout << "= " << expression() << endl;
        }
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Welcome to our simple calculator.
Please enter expressions using floating-point numbers.
Operators available: +, -, *, /, ().
To print the result, enter ';' and to quit, enter 'q'.
> 2;
= 2
> 2+3*7;
= 23
> 2+3*7+5;
= 28
> 3-(9/2);
= -1.5
> 33.33+22.22*7*2;
= 344.41
> 7-8/2;
= 3
> q

ch06_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

const char number = '8';
const char quit = 'q';
const char print = ';';
const string prompt = "> ";
const string result = "= ";

class Token
{
public:
    char kind;
    double value;
    Token(char ch) : kind(ch), value(0) { }
    Token(char ch, double val) : kind(ch), value(val) { }
};

class Token_stream
{
public:
    Token_stream();
    Token get();
    void putback(Token t);
private:
    bool full;
    Token buffer;
};

Token_stream::Token_stream() : full(false), buffer(0) { }

void Token_stream::putback(Token t)
{
    if (full)
    {
        error("putback() into a full buffer");
    }
    buffer = t;
    full = true;
}

Token Token_stream::get()
{
    if (full)
    {
        full = false;
        return buffer;
    }

    char ch;
    cin >> ch;

    switch (ch)
    {
    case print:
    case quit:
    case '!':
    case '{':
    case '}':
    case '(':
    case ')':
    case '+':
    case '-':
    case '*':
    case '/':
    case '%':
        return Token(ch);
    case '.':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    {
        cin.putback(ch);
        double val;
        cin >> val;
        return Token(number, val);
    }
    default:
        error("Bad token");
    }
}

Token_stream ts;

double expression();

double factorial(double d)
{
    int p = d;
    if (double(p) != d)
    {
        error("factorial not defined for non-integers");
    }
    if (p < 0)
    {
        error("factorial not defined for negative values");
    }
    else if (p > 12)
    {
        error("factorial too large");
    }
    else if (p == 0)
    {
        return 1;
    }
    else
    {
        int res = p;
        for (int i = p - 1; i > 0; --i)
        {
            res *= i;
        }
        return res;
    }
}

double primary()
{
    Token t = ts.get();
    double d = 0;
    switch (t.kind)
    {
    case '(':
        d = expression();
        t = ts.get();
        if (t.kind != ')')
        {
            error("')' expected");
        }
        break;
    case '{':
        d = expression();
        t = ts.get();
        if (t.kind != '}')
        {
            error("'}' expected");
        }
        break;
    case number:
        d = t.value;
        break;
    case '-':
        d = -primary();
        break;
    case '+':
        d = primary();
        break;
    default:
        error("primary expected");
    }

    t = ts.get();
    if (t.kind != '!')
    {
        ts.putback(t);
        return d;
    }
    return factorial(d);
}

double term()
{
    double left = primary();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '*':
            left *= primary();
            t = ts.get();
            break;
        case '/':
        {
            double d = primary();
            if (d == 0)
            {
                error("divide by zero");
            }
            left /= d;
            t = ts.get();
            break;
        }
        case '%':
        {
            double d = primary();
            int i1 = int(left);
            if (i1 != left)
            {
                error("left-hand operand of % not int");
            }
            int i2 = int(d);
            if (i2 != d)
            {
                error("right-hand operand of % not int");
            }
            if (i2 == 0)
            {
                error("%: divide by zero");
            }
            left = i1 % i2;
            t = ts.get();
            break;
        }
        default:
            ts.putback(t);
            return left;
        }
    }
}

double expression()
{
    double left = term();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '+':
            left += term();
            t = ts.get();
            break;
        case '-':
            left -= term();
            t = ts.get();
            break;
        default:
            ts.putback(t);
            return left;
        }
    }
}

void calculate()
{
    while (cin)
    {
        cout << prompt;
        Token t = ts.get();
        while (t.kind == print)
        {
            t = ts.get();
        }
        if (t.kind == quit)
        {
            return;
        }
        ts.putback(t);
        cout << result << expression() << endl;
    }
}

int main()
{
    try
    {
        cout << "Welcome to our simple calculator.\n";
        cout << "Please enter expressions using floating-point numbers.\n";
        cout << "Operators available: +, -, *, /, %, !, (), {}.\n";
        cout << "Enter '" << print << "' to print the result; enter '" << quit << "' to quit.\n";
        calculate();
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Welcome to our simple calculator.
Please enter expressions using floating-point numbers.
Operators available: +, -, *, /, %, !, (), {}.
Enter ';' to print the result; enter 'q' to quit.
> 7+5%3;
= 9
> 7+-2;
= 5
> 7++2;
= 9
> 7*8!;
= 282240
> {(4+5)*6}/(3+4);
= 7.71429
> q

ch06_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

class Name_value
{
public:
    string name;
    int value;
    Name_value(string str, int val) : name(str), value(val) { }
};

void list_score(string s, const vector<Name_value> &vec)
{
    int i = 0;
    while (i < vec.size())
    {
        if (vec[i].name == s)
        {
            cout << '(' << s << ',' << vec[i].value << ")\n";
            return;
        }
        ++i;
    }
    cout << "Name not found\n";
}

void list_names(int n, const vector<Name_value> &vec)
{
    bool exists = false;
    for (int i = 0; i < vec.size(); ++i)
    {
        if (vec[i].value == n)
        {
            cout << '(' << vec[i].name << ',' << n << ")\n";
            exists = true;
        }
    }
    if (!exists)
    {
        cout << "Score not found\n";
    }
}

int main()
{
    try
    {
        cout << "Enter name-and-value pairs such as 'Joe 17':\n";
        string name = "";
        int value = -1;
        vector<Name_value> nv_vec;
        while (cin >> name && cin >> value)
        {
            for (int i = 0; i < nv_vec.size(); ++i)
            {
                if (name == nv_vec[i].name)
                {
                    error("name occurs twice: " + name);
                }
            }
            nv_vec.push_back(Name_value(name, value));
        }

        for (int i = 0; i < nv_vec.size(); ++i)
        {
            cout << "(" << nv_vec[i].name << ',' << nv_vec[i].value << ")\n";
        }

        cin.clear();
        while (cin.get() != '\n')
        {
            continue;
        }
        int sc = 0;
        cout << "Enter name or score ('NoName' to exit):\n";
        while (true)
        {
            if (cin >> sc)
            {
                list_names(sc, nv_vec);
            }
            else
            {
                cin.clear();
                string na;
                cin >> na;
                if (na == "NoName")
                {
                    return 0;
                }
                list_score(na, nv_vec);
            }
            cout << "Enter name or score ('NoName' to exit):\n";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter name-and-value pairs such as 'Joe 17':
Peter 33
Smith 66
Mike 68
Pence 66
Hello 96
World 89
Water 78
end end
(Peter,33)
(Smith,66)
(Mike,68)
(Pence,66)
(Hello,96)
(World,89)
(Water,78)
Enter name or score ('NoName' to exit):
66
(Smith,66)
(Pence,66)
Enter name or score ('NoName' to exit):
96
(Hello,96)
Enter name or score ('NoName' to exit):
Water
(Water,78)
Enter name or score ('NoName' to exit):
Peter
(Peter,33)
Enter name or score ('NoName' to exit):
NoName

ch06_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

class String_stream
{
public:
    String_stream();
    string get();
    void putback(string s);
private:
    bool full;
    string buffer;
};

String_stream::String_stream() : full(false), buffer("") { }

void String_stream::putback(string s)
{
    if (full)
    {
        error("putback() into a full buffer");
    }
    buffer = s;
    full = true;
}

string String_stream::get()
{
    if (full)
    {
        full = false;
        return buffer;
    }

    string s = "";
    cin >> s;
    return s;
}

String_stream sstr;

bool conjunction()
{
    string s = sstr.get();
    if (s == "and" || s == "or" || s == "but")
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool noun()
{
    string s = sstr.get();
    if (s == "birds" || s == "fish" || s == "C++")
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool verb()
{
    string s = sstr.get();
    if (s == "rules" || s == "fly" || s == "swim")
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool subject()
{
    string s = sstr.get();
    if (s == "the")
    {
        return noun();
    }
    else
    {
        sstr.putback(s);
        return noun();
    }
}

bool sentence()
{
    return (subject() && verb());
}

int main()
{
    try
    {
        bool is_ok = false;
        while (true)
        {
            is_ok = sentence();
            if (!is_ok)
            {
                cout << "Not OK\n";
                return 0;
            }
            string s = sstr.get();
            if (s == ".")
            {
                cout << "OK\n";
                return 0;
            }
            else
            {
                sstr.putback(s);
                is_ok = conjunction();
                if (!is_ok)
                {
                    cout << "Not OK\n";
                    return 0;
                }
            }
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
the birds fly but the fish swim .
OK

ch06_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_improved(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

template<class T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int bulls = 0;
int cows = 0;

vector<char> get_new_solution(mt19937 &e)
{
    vector<char> solution(4);
    solution[0] = 'a' + nrand_improved(26, e);
    solution[1] = 'a' + nrand_improved(26, e);
    solution[2] = 'a' + nrand_improved(26, e);
    solution[3] = 'a' + nrand_improved(26, e);
    return solution;
}

void check_guess(const vector<char> &guess, const vector<char> &solution)
{
    bulls = 0;
    cows = 0;
    vector<char> is_bull(4, 'n');
    vector<char> is_cow(4, 'n');
    for (int i = 0; i < solution.size(); ++i)
    {
        if (guess[i] == solution[i])
        {
            ++bulls;
            is_bull[i] = 'y';
        }
    }
    for (int i = 0; i < solution.size(); ++i)
    {
        if (is_bull[i] == 'n')
        {
            for (int j = 0; j < guess.size(); ++j)
            {
                if (is_bull[j] == 'n' && is_cow[j] == 'n')
                {
                    if (solution[i] == guess[j])
                    {
                        ++cows;
                        is_cow[j] = 'y';
                    }
                }
            }
        }
    }

}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);

    try
    {
        char c0 = 0;
        char c1 = 0;
        char c2 = 0;
        char c3 = 0;
        vector<char> guess(4);
        cout << "Guess four character!\n";
        vector<char> solution = get_new_solution(engine);
        print_vector(solution, cout);

        cout << "Enter your guess:\n";
        while (cin >> c0 && cin >> c1 && cin >> c2 && cin >> c3)
        {
            while (cin.get() != '\n') { continue; }
            guess[0] = c0;
            guess[1] = c1;
            guess[2] = c2;
            guess[3] = c3;

            check_guess(guess, solution);
            if (bulls == 4)
            {
                cout << "You have guessed the four character! Setting new solution...\n";
                solution = get_new_solution(engine);
                print_vector(solution, cout);
            }
            if (bulls < 4)
            {
                cout << "Number of bulls: " << bulls << endl;
                cout << "Number of cows: " << cows << endl;
            }
            cout << "Enter your guess:\n";
        }
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Guess four character!
x, x, f, o
Enter your guess:
xvfd
Number of bulls: 2
Number of cows: 0
Enter your guess:
xxfj
Number of bulls: 3
Number of cows: 0
Enter your guess:
xvxo
Number of bulls: 2
Number of cows: 1
Enter your guess:
xxfo
You have guessed the four character! Setting new solution...
z, o, p, q
Enter your guess:
zjqp
Number of bulls: 1
Number of cows: 2
Enter your guess:

ch06_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

vector<string> num_words;

void init()
{
    num_words.push_back("thousand");
    num_words.push_back("hundred");
    num_words.push_back("ten");
    num_words.push_back("one");
}

int char_to_int(vector<int> v)
{
    if (v.size() == 0)
    {
        error("empty vector handed to char_to_int()");
    }
    if (v.size() > 4)
    {
        error("char_to_int can handle only up to four digits");
    }
    int num = 0;
    for (int i = 0; i < v.size(); ++i)
    {
        num = 10 * num + v[i];
    }
    return num;
}

void plural_s(int n)
{
    if (n == 0 || n > 1)
    {
        cout << 's';
    }
    if (n == 1)
    {
        return;
    }
    if (n < 0)
    {
        error("plural_s can handle only non-negative numbers");
    }
}

void print_number(const vector<int> &v, int num)
{
    if (num > 9999 || v.size() > 4)
    {
        error("print_number can only handle numbers with four digits");
    }
    if (v.size() == 0)
    {
        error("print_number was handed an empty vector");
    }
    cout << num << " is ";
    for (int i = 0; i < v.size(); ++i)
    {
        cout << v[i] << ' ' << num_words[i + 4 - v.size()];
        plural_s(v[i]);
        if (i < v.size() - 1)
        {
            cout << " and ";
        }
    }
    cout << endl;
}

int main()
{
    try
    {
        init();

        cout << "Enter number with up to four digits, followed by a ';' and a newline.\n";
        cout << "Enter 'q' to quit.\n";
        while (true)
        {
            vector<int> ch_vec;
            char ch;
            while (cin >> ch)
            {
                if (ch == 'q')
                {
                    return 0;
                }
                if (ch < '0' || ch > '9')
                {
                    while (cin.get() != '\n')
                    {
                        continue;
                    }
                    break;
                }
                ch_vec.push_back(ch - '0');
            }

            int as_int = char_to_int(ch_vec);

            print_number(ch_vec, as_int);

            cout << "Enter number with up to four digits, followed by a ';' and a newline.\n";
            cout << "Enter 'q' to quit.\n";
        }
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter number with up to four digits, followed by a ';' and a newline.
Enter 'q' to quit.
1234;
1234 is 1 thousand and 2 hundreds and 3 tens and 4 ones
Enter number with up to four digits, followed by a ';' and a newline.
Enter 'q' to quit.
123;
123 is 1 hundred and 2 tens and 3 ones
Enter number with up to four digits, followed by a ';' and a newline.
Enter 'q' to quit.
q

ch06_p10.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

double factorial(int n)
{
    if (n < 0)
    {
        error("factorial of a negative number is not defined");
    }
    if (n == 0)
    {
        return 1;
    }
    double prod = 1;
    for (int i = 1; i <= n; ++i)
    {
        prod *= i;
        if (prod > 1.0e+16)
        {
            error("factorial got too large");
        }
    }
    return prod;
}

double permutations(int a, int b)
{
    if (a < b)
    {
        error("for P(a,b), a cannot be smaller than b");
    }
    double prod = 1;
    for (int i = a - b + 1; i <= a; ++i)
    {
        prod *= i;
        if (prod > 1.0e+16)
        {
            error("number too large for permutation function");
        }
    }
    return prod;
}

double combinations(int a, int b)
{
    return permutations(a, b) / factorial(b);
}

int main()
{
    cout << std::fixed << std::noshowpoint << setprecision(0);
    try
    {
        int a = 0;
        int b = 0;
        cout << "Enter two integers to get permutations or combinations from:\n";
        while (cin >> a && cin >> b)
        {
            char ch = 0;
            cout << "(P)ermutations or (c)ombinations or (q)uit?\n";
            while (cin >> ch)
            {
                while (cin.get() != '\n')
                {
                    continue;
                }
                if (ch == 'q')
                {
                    break;
                }
                double res = 0;
                switch (ch)
                {
                case 'p':
                case 'P':
                    res = permutations(a, b);
                    cout << "P(" << a << ',' << b << ") = " << res << endl;
                    break;
                case 'c':
                case 'C':
                    res = combinations(a, b);
                    cout << "C(" << a << ',' << b << ") = " << res << endl;
                    break;
                default:
                    cout << "please enter 'p' or 'c' or 'q'\n";
                    break;
                }
                cout << "(P)ermutations or (c)ombinations or (q)uit?\n";
            }
            cout << "Enter two integers to get permutations or combinations from:\n";
        }
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter two integers to get permutations or combinations from:
52 5
(P)ermutations or (c)ombinations or (q)uit?
p
P(52,5) = 311875200
(P)ermutations or (c)ombinations or (q)uit?
c
C(52,5) = 2598960
(P)ermutations or (c)ombinations or (q)uit?
q
Enter two integers to get permutations or combinations from:

第7章 完成一个程序
7.1 介绍
7.2 输入和输出
7.3 错误处理
7.4 处理负数
7.5 模运算: %
7.6 清理代码
7.6.1 符号常量
7.6.2 使用函数
7.6.3 代码格式
7.6.4 注释
7.7 错误恢复
7.8 变量
7.8.1 变量和定义
7.8.2 引入单词name
7.8.3 预定义名字
7.8.4 我们到达目的地了吗
ch07_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

const char let = 'L';
const char con = 'C';
const char quit = 'q';
const char help = 'h';
const char print = ';';
const char number = '8';
const char name = 'a';
const char square_root = 's';
const char power = 'p';
const string declkey = "let";
const string conkey = "const";
const string sqrtkey = "sqrt";
const string powkey = "pow";
const string quitkey = "quit";
const string helpkey = "help";
const string prompt = "> ";
const string result = "= ";

class Token
{
public:
    char kind;
    double value;
    string name;
    Token(char ch) : kind(ch), value(0) { }
    Token(char ch, double val) : kind(ch), value(val) { }
    Token(char ch, string n) : kind(ch), value(0), name(n) { }
};

class Token_stream
{
public:
    Token_stream();
    Token get();
    void putback(Token t);
    void ignore(char c);
private:
    bool full;
    Token buffer;
};

Token_stream::Token_stream() : full(false), buffer(0) { }

void Token_stream::putback(Token t)
{
    if (full)
    {
        error("putback() into a full buffer");
    }
    buffer = t;
    full = true;
}

Token Token_stream::get()
{
    if (full)
    {
        full = false;
        return buffer;
    }

    char ch;
    cin.get(ch);
    while (isspace(ch))
    {
        if (ch == '\n')
        {
            return Token(print);
        }
        cin.get(ch);
    }

    switch (ch)
    {
    case print:
    case '!':
    case '{':
    case '}':
    case '(':
    case ')':
    case '+':
    case '-':
    case '*':
    case '/':
    case '%':
    case '=':
    case ',':
        return Token(ch);
    case '.':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    {
        cin.putback(ch);
        double val;
        cin >> val;
        return Token(number, val);
    }
    default:
        if (isalpha(ch))
        {
            string s;
            s += ch;
            while (cin.get(ch) && (isalpha(ch) || isdigit(ch) || ch == '_'))
            {
                s += ch;
            }
            cin.putback(ch);
            if (s == declkey)
            {
                return Token(let);
            }
            if (s == conkey)
            {
                return Token(con);
            }
            if (s == sqrtkey)
            {
                return Token(square_root);
            }
            if (s == powkey)
            {
                return Token(power);
            }
            if (s == helpkey)
            {
                return Token(help);
            }
            if (s == quitkey)
            {
                return Token(quit);
            }
            return Token(name, s);
        }
        error("Bad token");
    }
}

void Token_stream::ignore(char c)
{
    if (full && c == buffer.kind)
    {
        full = false;
        return;
    }
    full = false;

    char ch = 0;
    while (cin >> ch)
    {
        if (ch == c)
        {
            return;
        }
    }
}

class Variable
{
public:
    string name;
    double value;
    bool is_const;
    Variable(string n, double v, bool b) : name(n), value(v), is_const(b) { }
};

class Symbol_table
{
public:
    double get(string s);
    void set(string s, double d);
    bool is_declared(string var);
    double declare(string var, double val, bool b);
private:
    vector<Variable> var_table;
};

double Symbol_table::get(string s)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            return var_table[i].value;
        }
    }
    error("get: undefined variable " + s);
}

void Symbol_table::set(string s, double d)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            if (var_table[i].is_const)
            {
                error(s + " is a constant");
            }
            var_table[i].value = d;
            return;
        }
    }
    error("set: undefined variable " + s);
}

bool Symbol_table::is_declared(string var)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == var)
        {
            return true;
        }
    }
    return false;
}

double Symbol_table::declare(string var, double val, bool b)
{
    if (is_declared(var))
    {
        error(var + " declared twice");
    }
    var_table.push_back(Variable(var, val, b));
    return val;
}

Token_stream ts;
Symbol_table st;
double expression();

double factorial(double d)
{
    int p = d;
    if (double(p) != d)
    {
        error("factorial not defined for non-integers");
    }
    if (p < 0)
    {
        error("factorial not defined for negative values");
    }
    else if (p == 0)
    {
        return 1;
    }
    else
    {
        double res = p;
        for (int i = p - 1; i > 0; --i)
        {
            res *= i;
            if (res > 1.0e+16)
            {
                error("factorial too large");
            }
        }
        return res;
    }
}

double my_pow(double base, int expo)
{
    if (expo < 0)
    {
        error("my_pow not defined for negative expo");
    }
    if (expo == 0)
    {
        if (base == 0)
        {
            return 0;
        }
        return 1;
    }
    double res = base;
    for (int i = 2; i <= expo; ++i)
    {
        res *= base;
    }
    return res;
}

double primary()
{
    Token t = ts.get();
    double d = 0;
    switch (t.kind)
    {
    case '(':
        d = expression();
        t = ts.get();
        if (t.kind != ')')
        {
            error("')' expected");
        }
        break;
    case '{':
        d = expression();
        t = ts.get();
        if (t.kind != '}')
        {
            error("'}' expected");
        }
        break;
    case number:
        d = t.value;
        break;
    case '-':
        d = -primary();
        break;
    case '+':
        d = primary();
        break;
    case name:
    {
        Token t2 = ts.get();
        if (t2.kind == '=')
        {
            d = expression();
            st.set(t.name, d);
        }
        else
        {
            ts.putback(t2);
            d = st.get(t.name);
        }
    }
    break;
    case square_root:
    {
        Token t2 = ts.get();
        if (t2.kind != '(')
        {
            error("'(' expected");
        }
        double d2 = expression();
        if (d2 < 0)
        {
            error("Square roots of negative numbers... nope!");
        }
        t2 = ts.get();
        if (t2.kind != ')')
        {
            error("')' expected");
        }
        d = sqrt(d2);
    }
    break;
    case power:
    {
        Token t2 = ts.get();
        if (t2.kind != '(')
        {
            error("'(' expected");
        }
        double d2 = expression();
        t2 = ts.get();
        if (t2.kind != ',')
        {
            error("',' expected");
        }
        t2 = ts.get();
        if (t2.kind != number)
        {
            error("second argument of 'pow' is not a number");
        }
        int i2 = int(t2.value);
        if (i2 != t2.value)
        {
            error("second argument of 'pow' is not an integer");
        }
        t2 = ts.get();
        if (t2.kind != ')')
        {
            error("')' expected");
        }
        d = my_pow(d2, i2);
    }
    break;
    default:
        error("primary expected");
    }

    t = ts.get();
    if (t.kind != '!')
    {
        ts.putback(t);
        return d;
    }
    return factorial(d);
}

double term()
{
    double left = primary();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '*':
            left *= primary();
            t = ts.get();
            break;
        case '/':
        {
            double d = primary();
            if (d == 0)
            {
                error("divide by zero");
            }
            left /= d;
            t = ts.get();
            break;
        }
        case '%':
        {
            double d = primary();
            int i1 = int(left);
            if (i1 != left)
            {
                error("left-hand operand of % not int");
            }
            int i2 = int(d);
            if (i2 != d)
            {
                error("right-hand operand of % not int");
            }
            if (i2 == 0)
            {
                error("%: divide by zero");
            }
            left = i1 % i2;
            t = ts.get();
            break;
        }
        default:
            ts.putback(t);
            return left;
        }
    }
}

double expression()
{
    double left = term();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '+':
            left += term();
            t = ts.get();
            break;
        case '-':
            left -= term();
            t = ts.get();
            break;
        case '=':
            error("use of '=' outside of a declaration");
        default:
            ts.putback(t);
            return left;
        }
    }
}

double declaration(bool b)
{
    Token t = ts.get();
    if (t.kind != name)
    {
        error ("name expected in declaration");
    }
    string var_name = t.name;

    Token t2 = ts.get();
    if (t2.kind != '=')
    {
        error("= missing in declaration of " + var_name);
    }

    double d = expression();
    st.declare(var_name, d, b);
    return d;
}

double statement()
{
    Token t = ts.get();
    switch(t.kind)
    {
    case let:
        return declaration(false);
    case con:
        return declaration(true);
    default:
        ts.putback(t);
        return expression();
    }
}

void clean_up_mess()
{
    ts.ignore(print);
}

void print_help()
{
    cout << "Instructions: enter expressions, there are\n";
    cout << "a few functions, you can declare variables using\n";
    cout << "the 'let' keyword and constants with the 'const'\n";
    cout << "keyword.\n";
}

void calculate()
{
    while (cin)
    {
        try
        {
            cout << prompt;
            Token t = ts.get();
            while (t.kind == print)
            {
                t = ts.get();
            }
            if (t.kind == help)
            {
                print_help();
            }
            else if (t.kind == quit)
            {
                return;
            }
            else
            {
                ts.putback(t);
                cout << result << statement() << endl;
            }
        }
        catch(exception &e)
        {
            cerr << e.what() << endl;
            clean_up_mess();
        }
    }
}

int main()
{
    try
    {
        cout << "Welcome to our simple calculator.\n";
        cout << "Enter '" << helpkey << "' to get the help info; enter '" << quitkey << "' to quit.\n";
        st.declare("pi", 3.1415926535, true);
        st.declare("e", 2.7182818284, true);
        st.declare("k", 1000, true);

        calculate();
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Welcome to our simple calculator.
Enter 'help' to get the help info; enter 'quit' to quit.
> help
Instructions: enter expressions, there are
a few functions, you can declare variables using
the 'let' keyword and constants with the 'const'
keyword.
> sqrt(2+6.7)
= 2.94958
> pow(2.5,3)
= 15.625
> let x = 3.4
= 3.4
> let y = 2
= 2
> let z = (x+y*2)/pi
= 2.35549
> 2+3*z
= 9.06648
> quit

Welcome to our simple calculator.
Enter 'help' to get the help info; enter 'quit' to quit.
> 7*8!
= 282240
> let x = 5
= 5
> {(x+3)*2+5}
= 21
> x = x + 3
= 8
> x + 3
= 11
> x
= 8
> x + 7*8!
= 282248
> quit

第8章 函数相关的技术细节
8.1 技术细节
8.2 声明和定义
8.2.1 声明的类别
8.2.2 变量和常量声明
8.2.3 默认初始化
8.3 头文件
8.4 作用城
8.5 函数调用和返回
8.5.1 声明参数和返回类型
8.5.2 返回一个值
8.5.3 传值参数
8.5.4 传常量引用参数
8.5.5 传引用参数
8.5.6 传值与传引用的对比
8.5.7 参数检查和转换
8.5.8 实现函数调用
8.6 求值顺序
8.6.1 表达式求值
8.6.2 全局初始化
8.7 名字空间
8.7.1 using声明和using指令
ch08_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

namespace X
{
    int var;
    void print()
    {
        cout << var << endl;
    }
}

namespace Y
{
    int var;
    void print()
    {
        cout << var << endl;
    }
}

namespace Z
{
    int var;
    void print()
    {
        cout << var << endl;
    }
}

int main()
{
    X::var = 7;
    X::print();
    using namespace Y;
    var = 9;
    print();
    {
        using Z::var;
        using Z::print;
        var = 11;
        print();
    }
    print();
    X::print();
}
显示结果如下
7
9
11
9
7

ch08_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

const char let = 'L';
const char con = 'C';
const char quit = 'q';
const char help = 'h';
const char print = ';';
const char number = '8';
const char name = 'a';
const char square_root = 's';
const char power = 'p';
const string declkey = "let";
const string conkey = "const";
const string sqrtkey = "sqrt";
const string powkey = "pow";
const string quitkey = "quit";
const string helpkey = "help";
const string prompt = "> ";
const string result = "= ";

class Token
{
public:
    char kind;
    double value;
    string name;
    Token(char ch) : kind(ch), value(0) { }
    Token(char ch, double val) : kind(ch), value(val) { }
    Token(char ch, string n) : kind(ch), value(0), name(n) { }
};

class Token_stream
{
public:
    Token_stream();
    Token_stream(istream &is);
    Token get();
    void putback(Token t);
    void ignore(char c);
    istream & get_istream();
private:
    bool full;
    Token buffer;
    istream *is_ptr;
};

Token_stream::Token_stream() : full(false), buffer(0), is_ptr(&cin) { }
Token_stream::Token_stream(istream &is) : full(false), buffer(0), is_ptr(&is) { }
istream &  Token_stream::get_istream()
{
    return (*is_ptr);
}

void Token_stream::putback(Token t)
{
    if (full)
    {
        error("putback() into a full buffer");
    }
    buffer = t;
    full = true;
}

Token Token_stream::get()
{
    if (full)
    {
        full = false;
        return buffer;
    }

    char ch;
    (*is_ptr).get(ch);
    while (isspace(ch))
    {
        if (ch == '\n')
        {
            return Token(print);
        }
        (*is_ptr).get(ch);
    }

    switch (ch)
    {
    case print:
    case '!':
    case '{':
    case '}':
    case '(':
    case ')':
    case '+':
    case '-':
    case '*':
    case '/':
    case '%':
    case '=':
    case ',':
        return Token(ch);
    case '.':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    {
        (*is_ptr).putback(ch);
        double val;
        (*is_ptr) >> val;
        return Token(number, val);
    }
    default:
        if (isalpha(ch))
        {
            string s;
            s += ch;
            while ((*is_ptr).get(ch) && (isalpha(ch) || isdigit(ch) || ch == '_'))
            {
                s += ch;
            }
            (*is_ptr).putback(ch);
            if (s == declkey)
            {
                return Token(let);
            }
            if (s == conkey)
            {
                return Token(con);
            }
            if (s == sqrtkey)
            {
                return Token(square_root);
            }
            if (s == powkey)
            {
                return Token(power);
            }
            if (s == helpkey)
            {
                return Token(help);
            }
            if (s == quitkey)
            {
                return Token(quit);
            }
            return Token(name, s);
        }
        error("Bad token");
    }
}

void Token_stream::ignore(char c)
{
    if (full && c == buffer.kind)
    {
        full = false;
        return;
    }
    full = false;

    char ch = 0;
    while ((*is_ptr) >> ch)
    {
        if (ch == c)
        {
            return;
        }
    }
}

class Variable
{
public:
    string name;
    double value;
    bool is_const;
    Variable(string n, double v, bool b) : name(n), value(v), is_const(b) { }
};

class Symbol_table
{
public:
    double get(string s);
    void set(string s, double d);
    bool is_declared(string var);
    double declare(string var, double val, bool b);
private:
    vector<Variable> var_table;
};

double Symbol_table::get(string s)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            return var_table[i].value;
        }
    }
    error("get: undefined variable " + s);
}

void Symbol_table::set(string s, double d)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            if (var_table[i].is_const)
            {
                error(s + " is a constant");
            }
            var_table[i].value = d;
            return;
        }
    }
    error("set: undefined variable " + s);
}

bool Symbol_table::is_declared(string var)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == var)
        {
            return true;
        }
    }
    return false;
}

double Symbol_table::declare(string var, double val, bool b)
{
    if (is_declared(var))
    {
        error(var + " declared twice");
    }
    var_table.push_back(Variable(var, val, b));
    return val;
}

Token_stream ts;
Symbol_table st;
double expression();

double factorial(double d)
{
    int p = d;
    if (double(p) != d)
    {
        error("factorial not defined for non-integers");
    }
    if (p < 0)
    {
        error("factorial not defined for negative values");
    }
    else if (p == 0)
    {
        return 1;
    }
    else
    {
        double res = p;
        for (int i = p - 1; i > 0; --i)
        {
            res *= i;
            if (res > 1.0e+16)
            {
                error("factorial too large");
            }
        }
        return res;
    }
}

double my_pow(double base, int expo)
{
    if (expo < 0)
    {
        error("my_pow not defined for negative expo");
    }
    if (expo == 0)
    {
        if (base == 0)
        {
            return 0;
        }
        return 1;
    }
    double res = base;
    for (int i = 2; i <= expo; ++i)
    {
        res *= base;
    }
    return res;
}

double primary()
{
    Token t = ts.get();
    double d = 0;
    switch (t.kind)
    {
    case '(':
        d = expression();
        t = ts.get();
        if (t.kind != ')')
        {
            error("')' expected");
        }
        break;
    case '{':
        d = expression();
        t = ts.get();
        if (t.kind != '}')
        {
            error("'}' expected");
        }
        break;
    case number:
        d = t.value;
        break;
    case '-':
        d = -primary();
        break;
    case '+':
        d = primary();
        break;
    case name:
    {
        Token t2 = ts.get();
        if (t2.kind == '=')
        {
            d = expression();
            st.set(t.name, d);
        }
        else
        {
            ts.putback(t2);
            d = st.get(t.name);
        }
    }
    break;
    case square_root:
    {
        Token t2 = ts.get();
        if (t2.kind != '(')
        {
            error("'(' expected");
        }
        double d2 = expression();
        if (d2 < 0)
        {
            error("Square roots of negative numbers... nope!");
        }
        t2 = ts.get();
        if (t2.kind != ')')
        {
            error("')' expected");
        }
        d = sqrt(d2);
    }
    break;
    case power:
    {
        Token t2 = ts.get();
        if (t2.kind != '(')
        {
            error("'(' expected");
        }
        double d2 = expression();
        t2 = ts.get();
        if (t2.kind != ',')
        {
            error("',' expected");
        }
        t2 = ts.get();
        if (t2.kind != number)
        {
            error("second argument of 'pow' is not a number");
        }
        int i2 = int(t2.value);
        if (i2 != t2.value)
        {
            error("second argument of 'pow' is not an integer");
        }
        t2 = ts.get();
        if (t2.kind != ')')
        {
            error("')' expected");
        }
        d = my_pow(d2, i2);
    }
    break;
    default:
        error("primary expected");
    }

    t = ts.get();
    if (t.kind != '!')
    {
        ts.putback(t);
        return d;
    }
    return factorial(d);
}

double term()
{
    double left = primary();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '*':
            left *= primary();
            t = ts.get();
            break;
        case '/':
        {
            double d = primary();
            if (d == 0)
            {
                error("divide by zero");
            }
            left /= d;
            t = ts.get();
            break;
        }
        case '%':
        {
            double d = primary();
            int i1 = int(left);
            if (i1 != left)
            {
                error("left-hand operand of % not int");
            }
            int i2 = int(d);
            if (i2 != d)
            {
                error("right-hand operand of % not int");
            }
            if (i2 == 0)
            {
                error("%: divide by zero");
            }
            left = i1 % i2;
            t = ts.get();
            break;
        }
        default:
            ts.putback(t);
            return left;
        }
    }
}

double expression()
{
    double left = term();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '+':
            left += term();
            t = ts.get();
            break;
        case '-':
            left -= term();
            t = ts.get();
            break;
        case '=':
            error("use of '=' outside of a declaration");
        default:
            ts.putback(t);
            return left;
        }
    }
}

double declaration(bool b)
{
    Token t = ts.get();
    if (t.kind != name)
    {
        error ("name expected in declaration");
    }
    string var_name = t.name;

    Token t2 = ts.get();
    if (t2.kind != '=')
    {
        error("= missing in declaration of " + var_name);
    }

    double d = expression();
    st.declare(var_name, d, b);
    return d;
}

double statement()
{
    Token t = ts.get();
    switch(t.kind)
    {
    case let:
        return declaration(false);
    case con:
        return declaration(true);
    default:
        ts.putback(t);
        return expression();
    }
}

void clean_up_mess()
{
    ts.ignore(print);
}

void print_help()
{
    cout << "Instructions: enter expressions, there are\n";
    cout << "a few functions, you can declare variables using\n";
    cout << "the 'let' keyword and constants with the 'const'\n";
    cout << "keyword.\n";
}

void calculate()
{
    while (ts.get_istream())
    {
        try
        {
            cout << prompt;
            Token t = ts.get();
            while (t.kind == print)
            {
                t = ts.get();
            }
            if (t.kind == help)
            {
                print_help();
            }
            else if (t.kind == quit)
            {
                return;
            }
            else
            {
                ts.putback(t);
                cout << result << statement() << endl;
            }
        }
        catch(exception &e)
        {
            cerr << e.what() << endl;
            clean_up_mess();
        }
    }
}

int main()
{
    try
    {
        cout << "Welcome to our simple calculator.\n";
        cout << "Enter '" << helpkey << "' to get the help info; enter '" << quitkey << "' to quit.\n";
        st.declare("pi", 3.1415926535, true);
        st.declare("e", 2.7182818284, true);
        st.declare("k", 1000, true);

        calculate();
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Welcome to our simple calculator.
Enter 'help' to get the help info; enter 'quit' to quit.
> 7*8!
= 282240
> pi*pow(5,2)
= 78.5398
> quit

ch08_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

void print(const string &label, const vector<int> &v)
{
    cout << label << " (" << v.size() << "): {\n";
    int i;
    for (i = 0; i < v.size(); ++i)
    {
        cout << v[i];
        if (i < v.size() - 1)
        {
            cout << ", ";
        }
        if (i % 8 == 7)
        {
            cout << endl;
        }
    }
    if (i % 8 != 0)
    {
        cout << endl;
    }
    cout << "}\n";
}

void fibonacci(int x, int y, vector<int> &v, int n)
{
    if (n < 1)
    {
        error("there must be at least one number in the series");
    }
    v.push_back(x);
    if (n == 1) return;
    v.push_back(y);
    if (n == 2) return;
    for (int i = 2; i < n; ++i)
    {
        v.push_back(v[i - 2] + v[i - 1]);
    }
}

int main()
{
    try
    {
        int x = 0;
        int y = 0;
        vector<int> v;
        int n = 0;

        cout << "Enter first number in Fibonacci sequence: ";
        cin >> x;
        cout << "Enter second number in Fibonacci sequence: ";
        cin >> y;
        cout << "Enter number of elements in sequence: ";
        cin >> n;

        fibonacci(x, y, v, n);

        string s = "Your Fibonacci sequence";
        print(s, v);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter first number in Fibonacci sequence: 1
Enter second number in Fibonacci sequence: 1
Enter number of elements in sequence: 30
Your Fibonacci sequence (30): {
1, 1, 2, 3, 5, 8, 13, 21,
34, 55, 89, 144, 233, 377, 610, 987,
1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368,
75025, 121393, 196418, 317811, 514229, 832040
}

ch08_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

void print(const string &label, const vector<int> &v)
{
    cout << label << " (" << v.size() << "): {\n";
    int i;
    for (i = 0; i < v.size(); ++i)
    {
        cout << v[i];
        if (i < v.size() - 1)
        {
            cout << ", ";
        }
        if (i % 8 == 7)
        {
            cout << endl;
        }
    }
    if (i % 8 != 0)
    {
        cout << endl;
    }
    cout << "}\n";
}

vector<int> reverse1(const vector<int> &v)
{
    vector<int> v_rev(v.size());
    for (int i = 0; i < v.size(); ++i)
    {
        v_rev[i] = v[v.size() - 1 - i];
    }
    return v_rev;
}

void reverse2(vector<int> &v)
{
    for (int i = 0; i < v.size() / 2; ++i)
    {
        swap(v[i], v[v.size() - 1 - i]);
    }
}

int main()
{
    try
    {
        vector<int> v1;
        vector<int> v2;
        v1.push_back(1);
        v1.push_back(3);
        v1.push_back(5);
        v1.push_back(7);
        v1.push_back(9);
        v2.push_back(2);
        v2.push_back(4);
        v2.push_back(6);
        v2.push_back(8);
        print("v1_pre", v1);
        vector<int> v1_rev = reverse1(v1);
        print("v1_post_val", v1);
        print("v1_rev", v1_rev);
        reverse2(v1);
        print("v1_post_ref", v1);
        print("v2_pre", v2);
        vector<int> v2_rev = reverse1(v2);
        print("v2_post_val", v2);
        print("v2_rev", v2_rev);
        reverse2(v2);
        print("v2_post_ref", v2);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
v1_pre (5): {
1, 3, 5, 7, 9
}
v1_post_val (5): {
1, 3, 5, 7, 9
}
v1_rev (5): {
9, 7, 5, 3, 1
}
v1_post_ref (5): {
9, 7, 5, 3, 1
}
v2_pre (4): {
2, 4, 6, 8
}
v2_post_val (4): {
2, 4, 6, 8
}
v2_rev (4): {
8, 6, 4, 2
}
v2_post_ref (4): {
8, 6, 4, 2
}

ch08_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

void print(const string &label, const vector<string> &v)
{
    cout << label << " (" << v.size() << "): {\n";
    int i;
    for (i = 0; i < v.size(); ++i)
    {
        cout << setw(11) << v[i];
        if (i < v.size() - 1)
        {
            cout << " ";
        }
        if (i % 3 == 2)
        {
            cout << endl;
        }
    }
    if (i % 3 != 0)
    {
        cout << endl;
    }
    cout << "}\n";
}

vector<string> reverse1(const vector<string> &v)
{
    vector<string> v_rev(v.size());
    for (int i = 0; i < v.size(); ++i)
    {
        v_rev[i] = v[v.size() - 1 - i];
    }
    return v_rev;
}

void reverse2(vector<string> &v)
{
    for (int i = 0; i < v.size() / 2; ++i)
    {
        swap(v[i], v[v.size() - 1 - i]);
    }
}


int main()
{
    try
    {
        vector<string> v1;
        vector<string> v2;
        v1.push_back("one");
        v1.push_back("three");
        v1.push_back("five");
        v1.push_back("seven");
        v1.push_back("nine");
        v2.push_back("two");
        v2.push_back("four");
        v2.push_back("six");
        v2.push_back("eight");
        print("v1_pre", v1);
        vector<string> v1_rev = reverse1(v1);
        print("v1_post_val", v1);
        print("v1_rev", v1_rev);
        reverse2(v1);
        print("v1_post_ref", v1);
        print("v2_pre", v2);
        vector<string> v2_rev = reverse1(v2);
        print("v2_post_val", v2);
        print("v2_rev", v2_rev);
        reverse2(v2);
        print("v2_post_ref", v2);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
v1_pre (5): {
        one       three        five
      seven        nine
}
v1_post_val (5): {
        one       three        five
      seven        nine
}
v1_rev (5): {
       nine       seven        five
      three         one
}
v1_post_ref (5): {
       nine       seven        five
      three         one
}
v2_pre (4): {
        two        four         six
      eight
}
v2_post_val (4): {
        two        four         six
      eight
}
v2_rev (4): {
      eight         six        four
        two
}
v2_post_ref (4): {
      eight         six        four
        two
}

ch08_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

vector<string> name;
vector<double> age;

void enter_values()
{
    string s;
    cout << "Enter list of names, 'done' when done:\n";
    while (cin >> s && s != "done")
    {
        for (int i = 0; i < name.size(); ++i)
        {
            if (s == name[i]) { error("Duplicate name " + s); }
        }
        name.push_back(s);
    }

    for (int i = 0; i < name.size(); ++i)
    {
        cout << "Age of " << name[i] << ": ";
        double a;
        cin >> a;
        age.push_back(a);
    }
}

void print(const vector<string> &name, const vector<double> &age)
{
    if (name.size() != age.size()) { error("print: vectors must be same size"); }
    for (int i = 0; i < name.size(); ++i)
    {
        cout << '(' << name[i] << ',' << age[i] << ")\n";
    }
}

int find_index(const vector<string> &vec, const string &s)
{
    for (int i = 0; i < vec.size(); ++i)
    {
        if (vec[i] == s)
        {
            return i;
        }
    }
    error("name not found");
}

int main()
{
    try
    {
        enter_values();
        cout << "Entered like this:\n";
        print(name, age);

        vector<string> name_orig = name;
        vector<double> age_orig = age;
        sort(name.begin(), name.end());
        for (int i = 0; i < name.size(); ++i)
        {
            age[i] = age_orig[find_index(name_orig, name[i])];
        }

        cout << "\nAfter sorting:\n";
        print(name, age);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter list of names, 'done' when done:
Peter Smith Donald Mike Pence done
Age of Peter: 23
Age of Smith: 35
Age of Donald: 72
Age of Mike: 61
Age of Pence: 56
Entered like this:
(Peter,23)
(Smith,35)
(Donald,72)
(Mike,61)
(Pence,56)

After sorting:
(Donald,72)
(Mike,61)
(Pence,56)
(Peter,23)
(Smith,35)

ch08_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

template<class T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);
    try
    {
        for (int i = 0; i < 10; i++)
        {
            cout << nrand_one(100, engine) << endl;
        }
        cout << endl;
        for (int i = 0; i < 10; i++)
        {
            cout << nrand_two(100, 1000, engine) << endl;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
72
44
1
19
7
15
11
74
1
98

633
518
196
267
541
566
516
650
171
700

ch08_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
T maxv(const vector<T> &v)
{
    if (v.size() == 0)
    {
        error("maxv: argument vector is empty");
    }
    T v_max = v[0];
    if (v.size() == 1)
    {
        return v_max;
    }
    for (int i = 1; i < v.size(); ++i)
    {
        if (v[i] > v_max)
        {
            v_max = v[i];
        }
    }
    return v_max;
}

template<typename T>
T minv(const vector<T> &v)
{
    if (v.size() == 0)
    {
        error("minv: argument vector is empty");
    }
    T v_min = v[0];
    if (v.size() == 1)
    {
        return v_min;
    }
    for (int i = 1; i < v.size(); ++i)
    {
        if (v[i] < v_min)
        {
            v_min = v[i];
        }
    }
    return v_min;
}

template<typename T>
double meanv(const vector<T> &v)
{
    if (v.size() == 0)
    {
        error("meanv: argument vector is empty");
    }
    T v_sum = 0;
    for (int i = 0; i < v.size(); ++i)
    {
        v_sum += v[i];
    }
    return double(v_sum) / v.size();
}

template<typename T>
double medianv(vector<T> v)
{
    if (v.size() == 0)
    {
        error("medianv: argument vector is empty");
    }
    sort(v.begin(), v.end());
    auto size = v.size();
    auto mid = size / 2;
    return size % 2 == 0 ? double(v[mid] + v[mid - 1]) / 2 : v[mid];
}

template <typename T>
class Vector_properties
{
public:
    Vector_properties() : smallest(0), largest(0), mean(0), median(0) { }
    T smallest;
    T largest;
    double mean;
    double median;
};

template <typename T>
Vector_properties<T> get_props(const vector<T> &v)
{
    Vector_properties<T> vec_props;
    vec_props.largest = maxv<T>(v);
    vec_props.smallest = minv<T>(v);
    vec_props.mean = meanv<T>(v);
    vec_props.median = medianv<T>(v);
    return vec_props;
}

int main()
{
    try
    {
        vector<int> v;
        v.push_back(1);
        v.push_back(3);
        v.push_back(5);
        v.push_back(7);
        v.push_back(9);
        v.push_back(8);
        v.push_back(6);
        v.push_back(4);
        v.push_back(2);
        v.push_back(99);
        Vector_properties<int> vec_props = get_props<int>(v);

        cout << "Vector:\n";
        print_vector(v, cout);
        cout << endl;

        cout << "max: " << vec_props.largest << endl;
        cout << "min: " << vec_props.smallest << endl;
        cout << "mean: " << vec_props.mean << endl;
        cout << "median: " << vec_props.median << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Vector:
1, 3, 5, 7, 9, 8, 6, 4, 2, 99

max: 99
min: 1
mean: 14.4
median: 5.5

ch08_p13.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

void print_until_s(const vector<string> &v, const string &quit)
{
    for (int i = 0; i < v.size(); ++i)
    {
        if (v[i] == quit)
        {
            return;
        }
        cout << v[i] << endl;
    }
}

void print_until_ss(const vector<string> &v, const string &quit)
{
    int counter = 0;
    for (int i = 0; i < v.size(); ++i)
    {
        if (v[i] == quit)
        {
            if (counter == 1)
            {
                return;
            }
            else
            {
                ++counter;
            }
        }
        cout << v[i] << endl;
    }
}

int main()
{
    try
    {
        vector<string> v;
        v.push_back("one");
        v.push_back("word");
        v.push_back("and");
        v.push_back("then");
        v.push_back("another");
        v.push_back("word");
        cout << "print_until_s:\n";
        print_until_s(v, "word");
        cout << "print_until_ss:\n";
        print_until_ss(v, "word");
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
print_until_s:
one
print_until_ss:
one
word
and
then
another


ch08_p14.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

vector<int> string_lengths(const vector<string> &v)
{
    if (v.size() == 0)
    {
        error("string_lengths: argument is empty vector");
    }
    vector<int> lengths;
    for (int i = 0; i < v.size(); ++i)
    {
        lengths.push_back(v[i].size());
    }
    return lengths;
}

string longest_string(const vector<string> &v)
{
    if (v.size() == 0)
    {
        error("longest_string: argument is empty vector");
    }
    string ls;
    int maxl = 0;
    for (int i = 0; i < v.size(); ++i)
    {
        if (v[i].size() > maxl)
        {
            maxl = v[i].size();
            ls = v[i];
        }
    }
    return ls;
}

string shortest_string(const vector<string> &v)
{
    if (v.size() == 0)
    {
        error("shortest_string: argument is empty vector");
    }
    string ss = v[0];
    int minl = v[0].size();
    for (int i = 1; i < v.size(); ++i)
    {
        if (v[i].size() < minl)
        {
            minl = v[i].size();
            ss = v[i];
        }
    }
    return ss;
}

string alpha_first_string(const vector<string> &v)
{
    if (v.size() == 0)
    {
        error("alpha_first_string: argument is empty vector");
    }
    vector<string> v_cp = v;
    sort(v_cp.begin(), v_cp.end());
    return v_cp[0];
}

string alpha_last_string(const vector<string> &v)
{
    if (v.size() == 0)
    {
        error("alpha_last_string: argument is empty vector");
    }
    vector<string> v_cp = v;
    sort(v_cp.begin(), v_cp.end());
    return v_cp[v_cp.size() - 1];
}

int main()
{
    try
    {
        vector<string> string_v;
        string_v.push_back("first");
        string_v.push_back("second");
        string_v.push_back("third");
        string_v.push_back("fourth");
        string_v.push_back("fifth");
        string_v.push_back("sixth");
        string_v.push_back("seventh");
        cout << "Vector of strings:\n";
        print_vector(string_v, cout);
        vector<int> lengths = string_lengths(string_v);
        cout << "Vector of lengths:\n";
        print_vector(lengths, cout);
        cout << "Longest string: " << longest_string(string_v) << endl;
        cout << "Shortest string: " << shortest_string(string_v) << endl;
        cout << "Lexicographically first string: " << alpha_first_string(string_v) << endl;
        cout << "Lexicographically last string: " << alpha_last_string(string_v) << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Vector of strings:
first, second, third, fourth, fifth, sixth, seventh
Vector of lengths:
5, 6, 5, 6, 5, 5, 7
Longest string: seventh
Shortest string: first
Lexicographically first string: fifth
Lexicographically last string: third

ch08_p15.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

void f(const int n)
{
    cout << n << endl;
}

int main()
{
    try
    {
        int n = 10;
        f(n);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
10


第9章 类相关的技术细节
9.1 用户自定义类型
9.2 类和成员
9.3 接口和实现
9.4 演化一个类
9.4.1 结构和函数
9.4.2 成员函数和构造函数
9.4.3 保持细节私有性
9.4.4 定义成员函数
9.4.5 引用当前对象
9.4.6 报告错误
9.5 枚举类型
9.6 运算符重载
9.7 类接口
9.7.1 参数类型
9.7.2 拷贝
9.7.3 默认构造函数
9.7.4 const成员函数
9.7.5 类成员和"辅助函数"
9.8 Date类
ch09_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

namespace Chrono
{
    class Date
    {
    public:
        enum Month
        {
            jan = 1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
        };

        Date(int y, Month m, int d);
        Date();

        int day() const
        {
            return d;
        }
        Month month() const
        {
            return m;
        }
        int year() const
        {
            return y;
        }

        void add_day(int n);
        void add_month(int n);
        void add_year(int n);
    private:
        int y;
        Month m;
        int d;
    };

    bool is_date(int y, Date::Month m, int d);
    bool leapyear(int y);

    int day_in_year(const Date &d);
    void split_date(int day_of_year, int year, int *month, int *day);
    int n_leapyears(int y);
    long int days_linear(const Date &d);

    enum Day
    {
        sunday, monday, tuesday, wednesday, thursday, friday, saturday
    };
    Day day_of_week(const Date &d);
    ostream &operator<<(ostream &os, Day d);

    bool operator==(const Date &a, const Date &b);
    bool operator!=(const Date &a, const Date &b);

    ostream &operator<<(ostream &os, const Date &d);
    istream &operator>>(istream &is, Date &dd);
}

namespace Chrono
{
    Date::Date(int yy, Month mm, int dd) : y(yy), m(mm), d(dd)
    {
        if (!is_date(yy, mm, dd))
        {
            error("invalid date");
        }
    }

    const Date &default_date()
    {
        static const Date dd(2001, Date::jan, 1);
        return dd;
    }

    Date::Date() : y(default_date().year()), m(default_date().month()), d(default_date().day()) { }

    void Date::add_day(int n)
    {
        int day_of_year = day_in_year(*this);
        day_of_year += n;
        if (day_of_year >= 1 && day_of_year <= 366)
        {
            int res_month, res_day;
            split_date(day_of_year, y, &res_month, &res_day);
            m = Month(res_month);
            d = res_day;
        }
    }

    void Date::add_month(int n)
    {
        int month = m + n;
        if (leapyear(y))
        {
            if (d <= 29 && (month >= jan && month <= dec))
            {
                m = Month(month);
            }
        }
        else
        {
            if (d <= 28 && (month >= jan && month <= dec))
            {
                m = Month(month);
            }
        }
    }

    void Date::add_year(int n)
    {
        if (m == feb && d == 29 && !leapyear(y + n))
        {
            m = mar;
            d = 1;
        }
        y += n;
    }

    bool is_date(int y, Date::Month m, int d)
    {
        if (d <= 0)
        {
            return false;
        }

        int days_in_month = 31;

        switch (m)
        {
        case Date::feb:
            days_in_month = (leapyear(y)) ? 29 : 28;
            break;
        case Date::apr:
        case Date::jun:
        case Date::sep:
        case Date::nov:
            days_in_month = 30;
            break;
        }

        if (days_in_month < d)
        {
            return false;
        }

        return true;
    }

    bool leapyear(int y)
    {
        return (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;
    }

    bool operator==(const Date &a, const Date &b)
    {
        return a.year() == b.year() && a.month() == b.month() && a.day() == b.day();
    }

    bool operator!=(const Date &a, const Date &b)
    {
        return !(a == b);
    }

    ostream &operator<<(ostream &os, const Date &d)
    {
        return os << '(' << d.year() << ',' << d.month() << ',' << d.day() << ')';
    }

    istream &operator>>(istream &is, Date &dd)
    {
        int y, m, d;
        char ch1, ch2, ch3, ch4;
        is >> ch1 >> y >> ch2 >> m >> ch3 >> d >> ch4;
        if (!is)
        {
            return is;
        }
        if (ch1 != '(' || ch2 != ',' || ch3 != ',' || ch4 != ')')
        {
            is.clear(std::ios_base::failbit);
            return is;
        }
        dd = Date(y, Date::Month(m), d);
        return is;
    }

    ostream &operator<<(ostream &os, Day d)
    {
        switch (d)
        {
        case sunday:
            os << "Sunday";
            break;
        case monday:
            os << "Monday";
            break;
        case tuesday:
            os << "Tuesday";
            break;
        case wednesday:
            os << "Wednesday";
            break;
        case thursday:
            os << "Thursday";
            break;
        case friday:
            os << "Friday";
            break;
        case saturday:
            os << "Saturday";
            break;
        }
        return os;
    }

    const Date first_date = Date(1970, Date::jan, 1);
    const Day first_day = thursday;

    Day day_of_week(const Date &d)
    {
        if (d.year() < first_date.year())
        {
            error("day_of_week: works only for 1970 and later");
        }
        int dlin = days_linear(d);
        return Day((first_day + dlin) % 7);
    }

    Date next_Sunday(const Date &d)
    {
        Date nsd = d;
        Day day = day_of_week(d);
        nsd.add_day(7 - day);
        return nsd;
    }

    int nmonth(Date::Month m)
    {
        switch (m)
        {
        case Date::jan:
            return 0;
        case Date::feb:
            return 31;
        case Date::mar:
            return 31 + 28;
        case Date::apr:
            return 31 + 28 + 31;
        case Date::may:
            return 31 + 28 + 31 + 30;
        case Date::jun:
            return 31 + 28 + 31 + 30 + 31;
        case Date::jul:
            return 31 + 28 + 31 + 30 + 31 + 30;
        case Date::aug:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31;
        case Date::sep:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31;
        case Date::oct:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30;
        case Date::nov:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31;
        case Date::dec:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30;
        }
    }

    int day_in_year(const Date &d)
    {
        int diy = nmonth(d.month());
        diy += d.day();
        if (leapyear(d.year()) && d.month() > Date::feb)
        {
            ++diy;
        }
        return diy;
    }

    void split_date(int day_of_year, int year, int *month, int *day)
    {
        int i;
        bool found = false;

        for (i = 1; i <= 12 && !found; i++)
        {
            switch(i)
            {
            case 1:
            case 3:
            case 5:
            case 7:
            case 8:
            case 10:
            case 12:
                if (day_of_year <= 31)
                {
                    found = true;
                }
                else
                {
                    day_of_year -= 31;
                }
                break;
            case 4:
            case 6:
            case 9:
            case 11:
                if (day_of_year <= 30)
                {
                    found = true;
                }
                else
                {
                    day_of_year -= 30;
                }
                break;
            case 2:
                if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0))
                {
                    if (day_of_year <= 29)
                    {
                        found = true;
                    }
                    else
                    {
                        day_of_year -= 29;
                    }
                }
                else
                {
                    if (day_of_year <= 28)
                    {
                        found = true;
                    }
                    else
                    {
                        day_of_year -= 28;
                    }
                }
                break;
            default :
                break;
            }
        }
        *month = i - 1;
        *day = day_of_year;
    }

    int n_leapyears(int y)
    {
        int nl = 0;
        for (int i = 1970; i < y; ++i)
        {
            if (leapyear(i))
            {
                ++nl;
            }
        }
        return nl;
    }

    long int days_linear(const Date &d)
    {
        if (d.year() < first_date.year())
        {
            error("days_linear: year must be 1970 or later");
        }
        int y = d.year() - first_date.year();
        return y * 365 + n_leapyears(d.year()) + day_in_year(d) - 1;
    }

    Date next_weekday(const Date &d)
    {
        Date nwd = d;
        Day day = day_of_week(d);
        switch (day)
        {
        case sunday:
        case monday:
        case tuesday:
        case wednesday:
        case thursday:
            nwd.add_day(1);
            break;
        case saturday:
            nwd.add_day(2);
            break;
        case friday:
            nwd.add_day(3);
            break;
        }
        return nwd;
    }

}

int main()
{
    try
    {
        using namespace Chrono;
        Date default_d;
        cout << "Default date: " << default_d << endl;
        Date today(1978, Date::jun, 25);
        Date tomorrow = today;
        tomorrow.add_day(1);
        Date next_year = today;
        next_year.add_year(1);
        cout << "Today: " << today << endl;
        cout << "Tomorrow: " << tomorrow << endl;
        cout << "Next year: " << next_year << endl;
        Date invalid_date = Date(2004, Date::dec, -5);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Default date: (2001,1,1)
Today: (1978,6,25)
Tomorrow: (1978,6,26)
Next year: (1979,6,25)
invalid date
error: invalid date

ch09_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

class Name_pairs
{
public:
    void read_names();
    void read_ages();
    void print() const;
    void sort();
    const vector<string> &get_name() const
    {
        return name;
    }
    const vector<double> &get_age() const
    {
        return age;
    }
private:
    vector<string> name;
    vector<double> age;
};

void Name_pairs::read_names()
{
    cout << "Enter names, 'NoName' to finish: ";
    string s;
    while (cin >> s && s != "NoName")
    {
        for (int i = 0; i < name.size(); ++i)
        {
            if (name[i] == s)
            {
                error("Name exists already: " + s);
            }
        }
        name.push_back(s);
    }
}

void Name_pairs::read_ages()
{
    age = vector<double>();
    for (int i = 0; i < name.size(); ++i)
    {
        cout << "Age of " << name[i] << ": ";
        double a;
        cin >> a;
        age.push_back(a);
    }
}

void Name_pairs::print() const
{
    if (name.size() != age.size())
    {
        error("print(): name and age must be the same size");
    }
    for (int i = 0; i < name.size(); ++i)
    {
        cout << '(' << name[i] << ',' << age[i] << ')' << endl;
    }
}

void Name_pairs::sort()
{
    if (name.size() != age.size())
    {
        error("sort(): name and age must be the same size");
    }
    vector<string> name_presort = name;
    vector<double> age_cp = age;
    std::sort(name.begin(), name.end());
    for (int i = 0; i < name.size(); ++i)
    {
        for (int j = 0; j < name_presort.size(); ++j)
        {
            if (name[i] == name_presort[j])
            {
                age[i] = age_cp[j];
            }
        }
    }
}

ostream &operator<<(ostream &os, const Name_pairs &np)
{
    if (np.get_name().size() != np.get_age().size())
    {
        error("<<: name and age must be the same size");
    }
    for (int i = 0; i < np.get_name().size(); ++i)
    {
        os << '(' << np.get_name()[i] << ',' << np.get_age()[i] << ')' << endl;
    }
    return os;
}

bool operator==(const Name_pairs &a, const Name_pairs &b)
{
    if (a.get_name().size() != b.get_name().size() || a.get_age().size() != b.get_age().size())
    {
        return false;
    }
    for (int i = 0; i < a.get_name().size(); ++i)
    {
        if (a.get_name()[i] != b.get_name()[i])
        {
            return false;
        }
    }
    for (int i = 0; i < a.get_age().size(); ++i)
    {
        if (a.get_age()[i] != b.get_age()[i])
        {
            return false;
        }
    }
    return true;
}

bool operator!=(const Name_pairs &a, const Name_pairs &b)
{
    return !(a == b);
}

int main()
{
    try
    {
        Name_pairs np1;
        np1.read_names();
        np1.read_ages();
        Name_pairs np2;
        np2.read_names();
        np2.read_ages();
        cout << "np1:\n" << np1;
        cout << "np2:\n" << np2;
        if (np1 == np2)
        {
            cout << "Identical!\n";
        }
        else
        {
            cout << "Not identical!\n";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter names, 'NoName' to finish: Peter
Smith Mike Pence Donald NoName
Age of Peter: 23
Age of Smith: 33
Age of Mike: 62
Age of Pence: 56
Age of Donald: 72
Enter names, 'NoName' to finish: Peter
Smith Mike NoName
Age of Peter: 35
Age of Smith: 55
Age of Mike: 65
np1:
(Peter,23)
(Smith,33)
(Mike,62)
(Pence,56)
(Donald,72)
np2:
(Peter,35)
(Smith,55)
(Mike,65)
Not identical!

ch09_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

namespace Chrono
{
    class Date
    {
    public:
        enum Month
        {
            jan = 1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
        };

        Date(int y, Month m, int d);
        Date();

        int day() const
        {
            return d;
        }
        Month month() const
        {
            return m;
        }
        int year() const
        {
            return y;
        }

        void add_day(int n);
        void add_month(int n);
        void add_year(int n);
    private:
        int y;
        Month m;
        int d;
    };

    bool is_date(int y, Date::Month m, int d);
    bool leapyear(int y);

    int day_in_year(const Date &d);
    void split_date(int day_of_year, int year, int *month, int *day);
    int n_leapyears(int y);
    long int days_linear(const Date &d);

    enum Day
    {
        sunday, monday, tuesday, wednesday, thursday, friday, saturday
    };
    Day day_of_week(const Date &d);
    ostream &operator<<(ostream &os, Day d);

    bool operator==(const Date &a, const Date &b);
    bool operator!=(const Date &a, const Date &b);

    ostream &operator<<(ostream &os, const Date &d);
    istream &operator>>(istream &is, Date &dd);
}

namespace Chrono
{
    Date::Date(int yy, Month mm, int dd) : y(yy), m(mm), d(dd)
    {
        if (!is_date(yy, mm, dd))
        {
            error("invalid date");
        }
    }

    const Date &default_date()
    {
        static const Date dd(2001, Date::jan, 1);
        return dd;
    }

    Date::Date() : y(default_date().year()), m(default_date().month()), d(default_date().day()) { }

    void Date::add_day(int n)
    {
        int day_of_year = day_in_year(*this);
        day_of_year += n;
        if (day_of_year >= 1 && day_of_year <= 366)
        {
            int res_month, res_day;
            split_date(day_of_year, y, &res_month, &res_day);
            m = Month(res_month);
            d = res_day;
        }
    }

    void Date::add_month(int n)
    {
        int month = m + n;
        if (leapyear(y))
        {
            if (d <= 29 && (month >= jan && month <= dec))
            {
                m = Month(month);
            }
        }
        else
        {
            if (d <= 28 && (month >= jan && month <= dec))
            {
                m = Month(month);
            }
        }
    }

    void Date::add_year(int n)
    {
        if (m == feb && d == 29 && !leapyear(y + n))
        {
            m = mar;
            d = 1;
        }
        y += n;
    }

    bool is_date(int y, Date::Month m, int d)
    {
        if (d <= 0)
        {
            return false;
        }

        int days_in_month = 31;

        switch (m)
        {
        case Date::feb:
            days_in_month = (leapyear(y)) ? 29 : 28;
            break;
        case Date::apr:
        case Date::jun:
        case Date::sep:
        case Date::nov:
            days_in_month = 30;
            break;
        }

        if (days_in_month < d)
        {
            return false;
        }

        return true;
    }

    bool leapyear(int y)
    {
        return (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;
    }

    bool operator==(const Date &a, const Date &b)
    {
        return a.year() == b.year() && a.month() == b.month() && a.day() == b.day();
    }

    bool operator!=(const Date &a, const Date &b)
    {
        return !(a == b);
    }

    ostream &operator<<(ostream &os, const Date &d)
    {
        return os << '(' << d.year() << ',' << d.month() << ',' << d.day() << ')';
    }

    istream &operator>>(istream &is, Date &dd)
    {
        int y, m, d;
        char ch1, ch2, ch3, ch4;
        is >> ch1 >> y >> ch2 >> m >> ch3 >> d >> ch4;
        if (!is)
        {
            return is;
        }
        if (ch1 != '(' || ch2 != ',' || ch3 != ',' || ch4 != ')')
        {
            is.clear(std::ios_base::failbit);
            return is;
        }
        dd = Date(y, Date::Month(m), d);
        return is;
    }

    ostream &operator<<(ostream &os, Day d)
    {
        switch (d)
        {
        case sunday:
            os << "Sunday";
            break;
        case monday:
            os << "Monday";
            break;
        case tuesday:
            os << "Tuesday";
            break;
        case wednesday:
            os << "Wednesday";
            break;
        case thursday:
            os << "Thursday";
            break;
        case friday:
            os << "Friday";
            break;
        case saturday:
            os << "Saturday";
            break;
        }
        return os;
    }

    const Date first_date = Date(1970, Date::jan, 1);
    const Day first_day = thursday;

    Day day_of_week(const Date &d)
    {
        if (d.year() < first_date.year())
        {
            error("day_of_week: works only for 1970 and later");
        }
        int dlin = days_linear(d);
        return Day((first_day + dlin) % 7);
    }

    Date next_Sunday(const Date &d)
    {
        Date nsd = d;
        Day day = day_of_week(d);
        nsd.add_day(7 - day);
        return nsd;
    }

    int nmonth(Date::Month m)
    {
        switch (m)
        {
        case Date::jan:
            return 0;
        case Date::feb:
            return 31;
        case Date::mar:
            return 31 + 28;
        case Date::apr:
            return 31 + 28 + 31;
        case Date::may:
            return 31 + 28 + 31 + 30;
        case Date::jun:
            return 31 + 28 + 31 + 30 + 31;
        case Date::jul:
            return 31 + 28 + 31 + 30 + 31 + 30;
        case Date::aug:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31;
        case Date::sep:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31;
        case Date::oct:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30;
        case Date::nov:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31;
        case Date::dec:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30;
        }
    }

    int day_in_year(const Date &d)
    {
        int diy = nmonth(d.month());
        diy += d.day();
        if (leapyear(d.year()) && d.month() > Date::feb)
        {
            ++diy;
        }
        return diy;
    }

    void split_date(int day_of_year, int year, int *month, int *day)
    {
        int i;
        bool found = false;

        for (i = 1; i <= 12 && !found; i++)
        {
            switch(i)
            {
            case 1:
            case 3:
            case 5:
            case 7:
            case 8:
            case 10:
            case 12:
                if (day_of_year <= 31)
                {
                    found = true;
                }
                else
                {
                    day_of_year -= 31;
                }
                break;
            case 4:
            case 6:
            case 9:
            case 11:
                if (day_of_year <= 30)
                {
                    found = true;
                }
                else
                {
                    day_of_year -= 30;
                }
                break;
            case 2:
                if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0))
                {
                    if (day_of_year <= 29)
                    {
                        found = true;
                    }
                    else
                    {
                        day_of_year -= 29;
                    }
                }
                else
                {
                    if (day_of_year <= 28)
                    {
                        found = true;
                    }
                    else
                    {
                        day_of_year -= 28;
                    }
                }
                break;
            default :
                break;
            }
        }
        *month = i - 1;
        *day = day_of_year;
    }

    int n_leapyears(int y)
    {
        int nl = 0;
        for (int i = 1970; i < y; ++i)
        {
            if (leapyear(i))
            {
                ++nl;
            }
        }
        return nl;
    }

    long int days_linear(const Date &d)
    {
        if (d.year() < first_date.year())
        {
            error("days_linear: year must be 1970 or later");
        }
        int y = d.year() - first_date.year();
        return y * 365 + n_leapyears(d.year()) + day_in_year(d) - 1;
    }

    Date next_workday(const Date &d)
    {
        Date nwd = d;
        Day day = day_of_week(d);
        switch (day)
        {
        case sunday:
        case monday:
        case tuesday:
        case wednesday:
        case thursday:
            nwd.add_day(1);
            break;
        case saturday:
            nwd.add_day(2);
            break;
        case friday:
            nwd.add_day(3);
            break;
        }
        return nwd;
    }

}

namespace Liber
{
    class ISBN
    {
    public:
        int n1;
        int n2;
        int n3;
        int n4;
        char x;

        ISBN(int n1_val, int n2_val, int n3_val, int n4_val, char x_val);
        ISBN();
    };

    bool is_isbn(int, int, int, int, char);

    bool operator==(const ISBN &i1, const ISBN &i2);

    class Book
    {
    public:
        enum Genre
        {
            fiction = 0, nonfiction, periodical, biography, children
        };

        Book(const ISBN &isbn_num, const string &title, const string &author, int c_date, Genre gen, bool checked_out);
        Book();

        const ISBN &isbn() const
        {
            return in;
        }
        const string &title() const
        {
            return t;
        }
        const string &author() const
        {
            return a;
        }
        int c_date() const
        {
            return cd;
        }
        Genre genre() const
        {
            return g;
        }
        bool checked_out() const
        {
            return ch_out;
        }

        void check_out();
        void check_in();

    private:
        ISBN in;
        string t;
        string a;
        int cd;
        Genre g;
        bool ch_out;
    };

    bool operator==(const Book &b1, const Book &b2);
    bool operator!=(const Book &b1, const Book &b2);
    ostream &operator<<(ostream &os, const Book &b);


    class Patron
    {
    public:
        Patron(const string &name, int card_number, double fees);
        Patron();

        const string &get_name() const
        {
            return name;
        }
        int get_number() const
        {
            return card_number;
        }
        double get_fees() const
        {
            return fees;
        }

        void set_fee(double f);
    private:
        string name;
        int card_number;
        double fees;
    };

    bool owes_fee(const Patron &p);

    bool operator==(const Patron &p1, const Patron &p2);
    bool operator!=(const Patron &p1, const Patron &p2);

    class Library
    {
    public:
        class Transaction
        {
        public:
            Book b;
            Patron p;
            Chrono::Date d;

            Transaction(const Book &bb, const Patron &pp, const Chrono::Date &dd);
            Transaction();
        };

        Library(const vector<Book> &books, const vector<Patron> &patrons, const vector<Transaction> transactions);
        Library();

        void add_book(const Book &b);
        void add_patron(const Patron &p);
        void check_out(const Book &b, const Patron &p, const Chrono::Date &d);
        void set_fee(const Patron &p, double f);

        const vector<Book> &get_books() const
        {
            return books;
        }
        const vector<Patron> &get_patrons() const
        {
            return patrons;
        }
        const vector<Transaction> &get_transactions() const
        {
            return transactions;
        }
        vector<Patron> get_debtors() const;

    private:
        vector<Book> books;
        vector<Patron> patrons;
        vector<Transaction> transactions;
    };

}

namespace Liber
{
    ISBN::ISBN(int n1_val, int n2_val, int n3_val, int n4_val, char x_val)
        : n1(n1_val), n2(n2_val), n3(n3_val), n4(n4_val), x(x_val)
    {
        if (!is_isbn(n1, n2, n3, n4, x))
        {
            error("is_isbn(): invalid number");
        }
    }

    const ISBN &default_isbn()
    {
        static const ISBN in(0, 0, 0, 0, '0');
        return in;
    }

    ISBN::ISBN()
        : n1(default_isbn().n1),
          n2(default_isbn().n2),
          n3(default_isbn().n3),
          n4(default_isbn().n4),
          x(default_isbn().x)
    {
    }

    bool is_isbn(int, int, int, int, char x)
    {
        return (isalpha(x) || isdigit(x));
    }

    bool operator==(const ISBN &i1, const ISBN &i2)
    {
        return (i1.n1 == i2.n1 && i1.n2 == i2.n2 && i1.n3 == i2.n3 && i1.n4 == i2.n4 && i1.x == i2.x);
    }

    Book::Book(const ISBN &isbn_num, const string &title, const string &author, int c_date, Genre gen, bool checked_out)
        : in(isbn_num), t(title), a(author), cd(c_date), g(gen), ch_out(checked_out)
    {
    }

    const Book &default_book()
    {
        static const Book b(ISBN(), "", "", 0, Book::fiction, false);
        return b;
    }

    Book::Book()
        : in(default_book().isbn()),
          t(default_book().title()),
          a(default_book().author()),
          cd(default_book().c_date()),
          g(default_book().genre()),
          ch_out(default_book().checked_out())
    {
    }

    void Book::check_out()
    {
        if (checked_out())
        {
            error("already checked out");
        }
        ch_out = true;
    }

    void Book::check_in()
    {
        if (!checked_out())
        {
            error("already checked in");
        }
        ch_out = false;
    }

    bool operator==(const Book &b1, const Book &b2)
    {
        return (b1.isbn() == b2.isbn());
    }

    bool operator!=(const Book &b1, const Book &b2)
    {
        return !(b1 == b2);
    }

    ostream &operator<<(ostream &os, const Book &b)
    {
        return os << b.title() << endl
               << b.author() << endl
               << b.isbn().n1 << '-'
               << b.isbn().n2 << '-'
               << b.isbn().n3 << '-'
               << b.isbn().n4 << '-'
               << b.isbn().x << endl;
    }

    Patron::Patron(const string &n, int cn, double f)
        : name(n), card_number(cn), fees(f)
    {
    }

    const Patron &default_patron()
    {
        static const Patron p("", 0, 0);
        return p;
    }

    Patron::Patron()
        : name(default_patron().get_name()),
          card_number(default_patron().get_number()),
          fees(default_patron().get_fees())
    {
    }

    void Patron::set_fee(double f)
    {
        if (f < 0)
        {
            error("set_fee(): fee cannot be smaller than zero");
        }
        fees = f;
    }

    bool owes_fee(const Patron &p)
    {
        return p.get_fees() > 0;
    }

    bool operator==(const Patron &p1, const Patron &p2)
    {
        return p1.get_number() == p2.get_number();
    }

    bool operator!=(const Patron &p1, const Patron &p2)
    {
        return !(p1 == p2);
    }

    Library::Transaction::Transaction(const Book &bb, const Patron &pp, const Chrono::Date &dd)
        : b(bb), p(pp), d(dd)
    {
    }

    const Library::Transaction &default_transaction()
    {
        static const Library::Transaction tt = Library::Transaction(Book(), Patron(), Chrono::Date());
        return tt;
    }

    Library::Transaction::Transaction()
        : b(default_transaction().b),
          p(default_transaction().p),
          d(default_transaction().d)
    {
    }

    Library::Library(const vector<Book> &b, const vector<Patron> &p, const vector<Transaction> t)
        : books(b), patrons(p), transactions(t)
    {
    }

    const Library &default_library()
    {
        vector<Book> b;
        vector<Patron> p;
        vector<Library::Transaction> t;
        static const Library l(b, p, t);
        return l;
    }

    Library::Library()
        : books(default_library().get_books()),
          patrons(default_library().get_patrons()),
          transactions(default_library().get_transactions())
    {
    }

    void Library::add_book(const Book &b)
    {
        for (int i = 0; i < books.size(); ++i)
        {
            if (books[i] == b)
            {
                error("add_book(): book is already in library");
            }
        }
        books.push_back(b);
    }

    void Library::add_patron(const Patron &p)
    {
        for (int i = 0; i < patrons.size(); ++i)
        {
            if (patrons[i] == p)
            {
                error("add_patron(): patron is already registered");
            }
        }
        patrons.push_back(p);
    }

    void Library::check_out(const Book &b, const Patron &p, const Chrono::Date &d)
    {
        bool b_exists = false;
        int b_idx = 0;
        for (int i = 0; i < books.size(); ++i)
        {
            if (books[i] == b)
            {
                b_exists = true;
                b_idx = i;
                break;
            }
        }
        if (!b_exists)
        {
            error("check_out(): book is not in library");
        }

        if (books[b_idx].checked_out())
        {
            error("check_out(): book is already checked out");
        }

        bool p_exists = false;
        int p_idx = 0;
        for (int i = 0; i < patrons.size(); ++i)
        {
            if (patrons[i] == p)
            {
                p_exists = true;
                p_idx = i;
                break;
            }
        }
        if (!p_exists)
        {
            error("check_out(): patron is not registered");
        }

        if (patrons[p_idx].get_fees() > 0)
        {
            error("check_out(): patron owes library fees");
        }

        transactions.push_back(Transaction(books[b_idx], patrons[p_idx], d));
        books[b_idx].check_out();
    }

    void Library::set_fee(const Patron &p, double f)
    {
        int idx = 0;
        bool exists = false;
        for (int i = 0; i < patrons.size(); ++i)
        {
            if (patrons[i] == p)
            {
                exists = true;
                idx = i;
                break;
            }
        }
        if (!exists)
        {
            error("Library::set_fee(): patron does not exist");
        }
        patrons[idx].set_fee(f);
    }

    vector<Patron> Library::get_debtors() const
    {
        vector<Patron> debtors;
        for (int i = 0; i < patrons.size(); ++i)
        {
            if (patrons[i].get_fees() > 0)
            {
                debtors.push_back(patrons[i]);
            }
        }
        return debtors;
    }

}

using Liber::Library;
using Liber::Book;
using Liber::ISBN;
using Liber::Patron;
using Chrono::Date;
using Chrono::leapyear;
using Chrono::day_in_year;
using Chrono::n_leapyears;
using Chrono::days_linear;
using Chrono::day_of_week;

void test_liber()
{
    Library my_lib;

    Book my_book(ISBN(9780, 4390, 2348, 0, '1'),
                 "Hunger Games, The",
                 "Collins, Suzanne",
                 2008,
                 Book::fiction,
                 false);
    my_lib.add_book(my_book);

    Book my_book2(ISBN(9780, 4393, 5807, 0, '1'),
                  "Harry Potter and the Order of the Phoenix",
                  "Rowling, J.K.",
                  2003,
                  Book::children,
                  false);
    my_lib.add_book(my_book2);

    my_lib.add_book(Book(ISBN(9781, 4165, 3932, 0, '2'),
                         "Einstein: His Life and Universe",
                         "Isaacson, Walter",
                         2007,
                         Book::biography,
                         false));

    my_lib.add_book(Book(ISBN(9780, 3160, 6760, 0, '7'),
                         "Lone Survivor",
                         "Luttrell, Marcus",
                         2008,
                         Book::nonfiction,
                         false));

    my_lib.add_book(Book(ISBN(1234, 5678, 1234, 0, 'x'),
                         "Triathlete Issue 2/14",
                         "Competitor Group",
                         2014,
                         Book::periodical,
                         false));

    cout << "All my books:\n\n";
    const vector<Book> &books = my_lib.get_books();
    for (int i = 0; i < books.size(); ++i)
    {
        cout << books[i] << endl;
    }

    Patron my_patron1 = Patron("Forrest, Kara", 100, 0);
    my_lib.add_patron(my_patron1);
    Patron my_patron2 = Patron("Wuethrich, Benjamin", 101, 0);
    my_lib.add_patron(my_patron2);
    my_lib.add_patron(Patron("Buehler, Catriona", 102, 0));
    my_lib.add_patron(Patron("Schaerli, Tobias", 103, 0));
    my_lib.add_patron(Patron("Bieler, Ueli", 104, 0));

    cout << "List of patrons:\n\n";
    const vector<Patron> &patrons = my_lib.get_patrons();
    for (int i = 0; i < patrons.size(); ++i)
    {
        cout << patrons[i].get_name() << ", " << patrons[i].get_number() << ", " << patrons[i].get_fees() << endl;
    }

    my_lib.set_fee(my_patron1, 10);
    my_lib.set_fee(my_patron2, 15);

    cout << "\nList of debtors:\n\n";
    vector<Patron> debtors = my_lib.get_debtors();
    for (int i = 0; i < debtors.size(); ++i)
    {
        cout << debtors[i].get_name() << ", " << debtors[i].get_number() << ", " << debtors[i].get_fees() << endl;
    }

    my_lib.check_out(my_book, patrons[2], Date(2014, Date::jan, 31));
    my_lib.check_out(my_book2, patrons[3], Date());

    cout << "\nTransactions:\n";
    const vector<Library::Transaction> &transactions = my_lib.get_transactions();
    for (int i = 0; i < transactions.size(); ++i)
    {
        cout << transactions[i].b <<
             transactions[i].d << endl <<
             transactions[i].p.get_name() << endl;
    }
}

void test_leapyear()
{
    if (leapyear(2000))
    {
        cout << "2000 is a leap year\n";
    }
    if (leapyear(2004))
    {
        cout << "2004 is a leap year\n";
    }
    if (leapyear(2005))
    {
        cout << "2005 is a leap year\n";
    }
    if (leapyear(2100))
    {
        cout << "2100 is a leap year\n";
    }
}

void test_lineardate()
{
    cout << "Jan 1, 2000 is day #" <<
         day_in_year(Date(2000, Date::jan, 1)) <<
         " of the year.\n";
    cout << "Feb 29, 2000 is day #" <<
         day_in_year(Date(2000, Date::feb, 29)) <<
         " of the year.\n";
    cout << "Mar 1, 2000 is day #" <<
         day_in_year(Date(2000, Date::mar, 1)) <<
         " of the year.\n";

    cout << "Number of leap years since 1970:\n" <<
         "1971: " << n_leapyears(1971) << endl <<
         "1972: " << n_leapyears(1972) << endl <<
         "1973: " << n_leapyears(1973) << endl <<
         "1974: " << n_leapyears(1974) << endl <<
         "2000: " << n_leapyears(2000) << endl <<
         "2001: " << n_leapyears(2001) << endl <<
         "2101: " << n_leapyears(2101) << endl;

    cout << "Days since Jan 1, 1970:\n" <<
         "Jan 1, 1970: " << days_linear(Date(1970, Date::jan, 1)) << endl <<
         "Mar 1, 2001: " << days_linear(Date(2001, Date::mar, 1)) << endl <<
         "Jan 31, 2014: " << days_linear(Date(2014, Date::jan, 31)) << endl <<
         "Nov 30, 2111: " << days_linear(Date(2111, Date::nov, 30)) << endl;

    cout << "Day of week:\n" <<
         "Jan 1, 1970: " << day_of_week(Date(1970, Date::jan, 1)) << endl <<
         "Sep 11, 2001: " << day_of_week(Date(2001, Date::sep, 11)) << endl <<
         "Jan 31, 2014: " << day_of_week(Date(2014, Date::jan, 31)) << endl;
}


int main()
{
    try
    {
        test_liber();
        test_leapyear();
        test_lineardate();
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
All my books:

Hunger Games, The
Collins, Suzanne
9780-4390-2348-0-1

Harry Potter and the Order of the Phoenix
Rowling, J.K.
9780-4393-5807-0-1

Einstein: His Life and Universe
Isaacson, Walter
9781-4165-3932-0-2

Lone Survivor
Luttrell, Marcus
9780-3160-6760-0-7

Triathlete Issue 2/14
Competitor Group
1234-5678-1234-0-x

List of patrons:

Forrest, Kara, 100, 0
Wuethrich, Benjamin, 101, 0
Buehler, Catriona, 102, 0
Schaerli, Tobias, 103, 0
Bieler, Ueli, 104, 0

List of debtors:

Forrest, Kara, 100, 10
Wuethrich, Benjamin, 101, 15

Transactions:
Hunger Games, The
Collins, Suzanne
9780-4390-2348-0-1
(2014,1,31)
Buehler, Catriona
Harry Potter and the Order of the Phoenix
Rowling, J.K.
9780-4393-5807-0-1
(2001,1,1)
Schaerli, Tobias
2000 is a leap year
2004 is a leap year
Jan 1, 2000 is day #1 of the year.
Feb 29, 2000 is day #60 of the year.
Mar 1, 2000 is day #61 of the year.
Number of leap years since 1970:
1971: 0
1972: 0
1973: 1
1974: 1
2000: 7
2001: 8
2101: 32
Days since Jan 1, 1970:
Jan 1, 1970: 0
Mar 1, 2001: 11382
Jan 31, 2014: 16101
Nov 30, 2111: 51832
Day of week:
Jan 1, 1970: Thursday
Sep 11, 2001: Tuesday
Jan 31, 2014: Friday

ch09_p13.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int gcd(int a, int b)
{
    while (b != 0)
    {
        int t = b;
        b = a % b;
        a = t;
    }
    return a;
}

class Rational
{
public:
    Rational() : numer(0), denom(1) { }
    Rational(int n) : numer(n), denom(1) { }
    Rational(int n, int d) : numer(n), denom(d)
    {
        normalise();
    }

    int get_numer() const
    {
        return numer;
    }
    int get_denom() const
    {
        return denom;
    }
    double conv_double() const
    {
        return double(numer) / denom;
    }

    void normalise()
    {
        if (denom == 0)
        {
            error("denominator is zero");
        }
        if (denom < 0)
        {
            denom = -denom;
            numer = -numer;
        }
        int n = gcd(numer, denom);
        if (n > 1)
        {
            numer /= n;
            denom /= n;
        }
    }

private:
    int numer;
    int denom;
};

Rational operator+(const Rational &r1, const Rational &r2);
Rational operator-(const Rational &r1, const Rational &r2);
Rational operator*(const Rational &r1, const Rational &r2);
Rational operator/(const Rational &r1, const Rational &r2);
bool operator==(const Rational &r1, const Rational &r2);
bool operator!=(const Rational &r1, const Rational &r2);
ostream &operator<<(ostream &os, const Rational &r);

Rational operator+(const Rational &r1, const Rational &r2)
{
    Rational r(r1.get_numer()*r2.get_denom() + r1.get_denom()*r2.get_numer(),
               r1.get_denom()*r2.get_denom());
    r.normalise();
    return r;
}

Rational operator-(const Rational &r1, const Rational &r2)
{
    Rational r(r1.get_numer()*r2.get_denom() - r1.get_denom()*r2.get_numer(),
               r1.get_denom()*r2.get_denom());
    r.normalise();
    return r;
}

Rational operator*(const Rational &r1, const Rational &r2)
{
    Rational r(r1.get_numer()*r2.get_numer(), r1.get_denom()*r2.get_denom());
    r.normalise();
    return r;
}

Rational operator/(const Rational &r1, const Rational &r2)
{
    Rational r(r1.get_numer()*r2.get_denom(), r1.get_denom()*r2.get_numer());
    r.normalise();
    return r;
}

bool operator==(const Rational &r1, const Rational &r2)
{
    return r1.get_numer() * r2.get_denom() == r1.get_denom() * r2.get_numer();
}

bool operator!=(const Rational &r1, const Rational &r2)
{
    return !(r1 == r2);
}

ostream &operator<<(ostream &os, const Rational &r)
{
    return cout << '(' << r.get_numer() << '/' << r.get_denom() << ')';
}

int main()
{
    try
    {
        Rational r1;
        Rational r2(5);
        Rational r3(7, 3);
        cout << "r1: " << r1 << endl
             << "r2: " << r2 << endl
             << "r3: " << r3 << endl;

        cout << "5/3 + 7/2 = " << Rational(5, 3) + Rational(7, 2) <<
             " = " << (Rational(5, 3) + Rational(7, 2)).conv_double() << endl;
        cout << "8/5 - 40/7 = " << Rational(8, 5) - Rational(40, 7) <<
             " = " << (Rational(8, 5) - Rational(40, 7)).conv_double() << endl;
        cout << "10/11 * 17/18 = " << Rational(10, 11) * Rational(17, 18) <<
             " = " << (Rational(10, 11) * Rational(17, 18)).conv_double() << endl;
        cout << "(5/7) / (1/3) = " << Rational(5, 7) / Rational(1, 3) <<
             " = " << (Rational(5, 7) / Rational(1, 3)).conv_double() << endl;

        if (r1 == Rational(0, 1))
        {
            cout << "r1 == 0/1" << endl;
        }
        if (Rational(1, 2) == Rational(2, 4))
        {
            cout << "1/2 == 2/4" << endl;
        }
        if (r2 != r2)
        {
            cout << "r2 != r2" << endl;
        }

        cout << r3 << " = " << r3.conv_double() << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
r1: (0/1)
r2: (5/1)
r3: (7/3)
5/3 + 7/2 = (31/6) = 5.16667
8/5 - 40/7 = (-144/35) = -4.11429
10/11 * 17/18 = (85/99) = 0.858586
(5/7) / (1/3) = (15/7) = 2.14286
r1 == 0/1
1/2 == 2/4
(7/3) = 2.33333

ch09_p14.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

long int my_round(double d)
{
    return (d > 0.0) ? (d + 0.5) : (d - 0.5);
}

class Money
{
public:
    enum Currency
    {
        USD, CHF, KYD
    };
    Money() : cents(0), cur(USD) { }
    Money(long int c) : cents(c), cur(USD) { }
    Money(int d, int c) : cents(d * 100 + c), cur(USD)
    {
        if (c >= 100)
        {
            error("cents must be between 0 and 99");
        }
    }
    Money(long int c, Currency cur_val) : cents(c), cur(cur_val) { }
    Money(int d, int c, Currency cur_val) : cents(d * 100 + c), cur(cur_val)
    {
        if (c >= 100)
        {
            error("cents must be between 0 and 99");
        }
    }
    int get_dollars() const
    {
        return cents / 100;
    }
    int get_cents() const
    {
        return cents % 100;
    }
    long int cents;
    Currency cur;
};

double exch_rate(Money::Currency c1, Money::Currency c2)
{
    switch (c1)
    {
    case Money::USD:
        switch (c2)
        {
        case Money::CHF:
            return 1.11;
        case Money::KYD:
            return 1.22;
        default:
            error("exch_rate: illegal combination of currencies");
        }
    case Money::CHF:
        switch (c2)
        {
        case Money::USD:
            return 0.91;
        case Money::KYD:
            return 1.1;
        default:
            error("exch_rate: illegal combination of currencies");
        }
    case Money::KYD:
        switch (c2)
        {
        case Money::USD:
            return 0.82;
        case Money::CHF:
            return 0.91;
        default:
            error("exch_rate: illegal combination of currencies");
        }
    default:
        error("exch_rate: illegal combination of currencies");
    }
}

Money operator+(const Money &a, const Money &b)
{
    if (a.cur == b.cur)
    {
        return Money(a.cents + b.cents, a.cur);
    }

    double d = exch_rate(a.cur, b.cur);

    return Money(a.cents + my_round(d * double(b.cents)), a.cur);
}

Money operator-(const Money &a, const Money &b)
{
    if (a.cur == b.cur)
    {
        return Money(a.cents - b.cents, a.cur);
    }

    double d = exch_rate(a.cur, b.cur);

    return Money(a.cents - my_round(d * double(b.cents)), a.cur);
}

Money operator-(const Money &m)
{
    return Money(-m.cents, m.cur);
}

Money operator*(int n, const Money &m)
{
    return Money(n * m.cents, m.cur);
}

Money operator*(const Money &m, int n)
{
    return n * m;
}

Money operator/(const Money &m, int n)
{
    if (n == 0)
    {
        error("division by zero");
    }
    double d = double(m.cents) / n;
    long int c = my_round(d);
    return Money(c, m.cur);
}

ostream &operator<<(ostream &os, Money::Currency cur)
{
    switch (cur)
    {
    case Money::USD:
        return os << "USD";
    case Money::CHF:
        return os << "CHF";
    case Money::KYD:
        return os << "KYD";
    }
}

ostream &operator<<(ostream &os, const Money &m)
{
    os << m.cur << m.get_dollars() << '.';
    if (abs(m.get_cents()) < 10)
    {
        os << '0';
    }
    os << abs(m.get_cents());
    return os;
}

istream &operator>>(istream &is, Money &m)
{
    double d;
    string s;
    is >> s >> d;
    if (!is)
    {
        return is;
    }
    if (!(s == "USD" || s == "CHF" || s == "KYD"))
    {
        is.clear(std::ios_base::failbit);
        return is;
    }
    int i2 = int(d);
    double d2 = (d - i2) * 100.0;
    int i3 = int(d2);
    Money::Currency cur;
    if (s == "USD")
    {
        cur = Money::USD;
    }
    else if (s == "CHF")
    {
        cur = Money::CHF;
    }
    else if (s == "KYD")
    {
        cur = Money::KYD;
    }
    m = Money(i2, i3, cur);
    return is;
}

int main()
{
    try
    {
        Money m1;
        Money m2(105);
        Money m3(5, 12);

        cout << "m1: " << m1 << endl;
        cout << "m2(105): " << m2 << endl;
        cout << "m3(5, 12): " << m3 << endl;
        cout << "-m3: " << -m3 << endl;

        cout << m2 << " + " << m3 << " = " << m2 + m3 << endl;
        cout << m2 << " - " << m3 << " = " << m2 - m3 << endl;
        cout << "5 * " << m2 << " = " << 5 * m2 << endl;
        cout << m2 << " * 5 = " << m2 * 5 << endl;

        cout << m3 << " - " << m2 << " = " << m3 - m2 << endl;

        cout << Money(1, 0) << " / 7 = " << Money(1, 0) / 7 << endl;
        cout << Money(0, 9) << " / 6 = " << Money(0, 9) / 6 << endl << endl;

        m1 = Money(7, 12, Money::USD);
        m2 = Money(100, 5, Money::CHF);
        m3 = Money(55, 12, Money::KYD);
        cout << "m1 = " << m1 << endl;
        cout << "m2 = " << m2 << endl;
        cout << "m3 = " << m3 << endl << endl;
        cout << m1 << " + " << m2 << " = " << m1 + m2 << endl;
        cout << m1 << " + " << m3 << " = " << m1 + m3 << endl;
        cout << m2 << " + " << m1 << " = " << m2 + m1 << endl;
        cout << m2 << " + " << m3 << " = " << m2 + m3 << endl;
        cout << m3 << " + " << m1 << " = " << m3 + m1 << endl;
        cout << m3 << " + " << m2 << " = " << m3 + m2 << endl;
        cout << m3 << " - " << m2 << " = " << m3 - m2 << endl;
        cout << 3 << " * " << m2 << " = " << 3 * m2 << endl;
        cout << m3 << " / " << 17 << " = " << m3 / 17 << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
m1: USD0.00
m2(105): USD1.05
m3(5, 12): USD5.12
-m3: USD-5.12
USD1.05 + USD5.12 = USD6.17
USD1.05 - USD5.12 = USD-4.07
5 * USD1.05 = USD5.25
USD1.05 * 5 = USD5.25
USD5.12 - USD1.05 = USD4.07
USD1.00 / 7 = USD0.14
USD0.09 / 6 = USD0.02

m1 = USD7.12
m2 = CHF100.05
m3 = KYD55.12

USD7.12 + CHF100.05 = USD118.18
USD7.12 + KYD55.12 = USD74.37
CHF100.05 + USD7.12 = CHF106.53
CHF100.05 + KYD55.12 = CHF160.68
KYD55.12 + USD7.12 = KYD60.96
KYD55.12 + CHF100.05 = KYD146.17
KYD55.12 - CHF100.05 = KYD-35.93
3 * CHF100.05 = CHF300.15
KYD55.12 / 17 = KYD3.24

第二部分 输入和输出
第10章 输入/输出流
10.1 输人和输出
10.2 I/O流模型
10.3 文件
10.4 打开文件
10.5 读写文件
10.6 I/O错误处理
10.7 读取单个值
10.7.1 将程序分解为易管理的子模块
10.7.2 将人机对话从函数中分离
10.8 用户自定义输出操作符
10.9 用户自定义输入操作符
10.10 一个标准的输入循环
10.11 读取结构化的文件
10.11.1 内存表示
10.11.2 读取结构化的值
10.11.3 改变表示方法
ch10_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

struct Point
{
    int x;
    int y;
    Point() : x(0), y(0) { }
    Point(int xx, int yy) : x(xx), y(yy) { }
};

bool operator==(const Point &p1, const Point &p2)
{
    return p1.x == p2.x && p1.y == p2.y;
}

bool operator!=(const Point &p1, const Point &p2)
{
    return !(p1 == p2);
}

ostream &operator<<(ostream &os, const Point &p)
{
    return os << '(' << p.x << ',' << p.y << ')';
}

istream &operator>>(istream &is, Point &p)
{
    int x, y;
    char ch1, ch2, ch3;
    is >> ch1 >> x >> ch2 >> y >> ch3;
    if (!is)
    {
        return is;
    }
    if (ch1 != '(' || ch2 != ',' || ch3 != ')')
    {
        is.clear(std::ios_base::failbit);
        return is;
    }
    p = Point(x, y);
    return is;
}

void print_vector(const vector<Point> &points)
{
    for (int i = 0; i < points.size(); ++i)
    {
        cout << points[i] << endl;
    }
}

void write_to_file(const vector<Point> &points, const string &name)
{
    ofstream ost(name.c_str());
    if (!ost)
    {
        error("can't open output file " + name);
    }
    for (int i = 0; i < points.size(); ++i)
    {
        ost << points[i] << endl;
    }
}

void fill_from_file(vector<Point> &points, const string &name)
{
    ifstream ist(name.c_str());
    if (!ist)
    {
        error("can't open input file " + name);
    }
    Point pp;
    while (ist >> pp)
    {
        points.push_back(pp);
    }
}

bool compare_vectors(const vector<Point> &points1, const vector<Point> &points2)
{
    if (points1.size() != points2.size())
    {
        cerr << "compare_vectors: points1.size() != points2.size()" << endl;
        return false;
    }
    for (int i = 0; i < points1.size(); ++i)
    {
        if (points1[i] != points2[i])
        {
            cerr << "compare_vectors: points1[i] != points2[i]" << endl;
            return false;
        }
    }
    return true;
}

int main()
{
    try
    {
        vector<Point> original_points;
        cout << "Enter 7 (x,y) pairs:\n";
        for (int i = 0; i < 7; ++i)
        {
            Point p;
            cin >> p;
            original_points.push_back(p);
        }

        cout << "\nOriginal points:\n";
        print_vector(original_points);

        string filename = "ch10_d01.txt";
        write_to_file(original_points, filename);

        vector<Point> processed_points;
        fill_from_file(processed_points, filename);

        cout << "\nData from ifstream:\n";
        print_vector(processed_points);
        cout << "\nOriginal data:\n";
        print_vector(original_points);

        if ( compare_vectors(original_points, processed_points) )
        {
            cout << "original_points == processed_points" << endl;
        }
        else
        {
            cout << "original_points != processed_points" << endl;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter 7 (x,y) pairs:
(1,3)
(3,5)
(5,6)
(7,9)
(9,11)
(8,12)
(6,9)

Original points:
(1,3)
(3,5)
(5,6)
(7,9)
(9,11)
(8,12)
(6,9)

Data from ifstream:
(1,3)
(3,5)
(5,6)
(7,9)
(9,11)
(8,12)
(6,9)

Original data:
(1,3)
(3,5)
(5,6)
(7,9)
(9,11)
(8,12)
(6,9)
original_points == processed_points

cat ch10_d01.txt
(1,3)
(3,5)
(5,6)
(7,9)
(9,11)
(8,12)
(6,9)

ch10_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

void read_ints(vector<int> &ints, const string &name)
{
    ifstream ist(name.c_str());
    if (!ist) { error("can't open input file " + name); }
    int n;
    while (ist >> n) { ints.push_back(n); }
}

int get_sum(const vector<int> &v)
{
    int sum = 0;
    for (int i = 0; i < v.size(); ++i)
    {
        sum += v[i];
    }
    return sum;
}

int main()
{
    try
    {
        cout << "Enter file name: ";
        string iname;
        cin >> iname;
        vector<int> ints;
        read_ints(ints, iname);
        int sum = get_sum(ints);
        cout << "Sum of integers in " << iname << " is " << sum << ".\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter file name: ch10_p01.txt
Sum of integers in ch10_p01.txt is 91.

cat ch10_p01.txt
1
3
5
7
9
2
4
6
8
10
11
12
13

ch10_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

struct Reading
{
    int hour;
    double temperature;
    Reading(int h, double t) : hour(h), temperature(t) { }
};

ostream &operator<<(ostream &os, const Reading &r)
{
    return os << '(' << r.hour << ',' << r.temperature << ')';
}

const int max_temp = 107;
const int min_temp = -43;

Reading create_reading(mt19937 &e)
{
    int h = nrand_two(0, 24, e);
    double t = nrand_two(min_temp, max_temp+1, e) + nrand_two(-10, 11, e) / double(10);
    return Reading(h, t);
}

void write_to_file(const vector<Reading> &r, const string &name)
{
    ofstream ost(name.c_str());
    if (!ost) { error("can't open output file " + name); }
    for (int i = 0; i < r.size(); ++i)
    {
        ost << r[i] << endl;
    }
}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);
    try
    {
        vector<Reading> readings;
        for (int i = 0; i < 10; ++i)
        {
            readings.push_back(create_reading(engine));
        }

        write_to_file(readings, "ch10_p02.txt");
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
cat ch10_p02.txt
(0,92.3)
(21,-22)
(1,13.8)
(20,-10.8)
(5,90.5)
(21,54.2)
(3,47)
(23,99.4)
(5,67.7)
(1,62.5)

ch10_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

struct Reading
{
    int hour;
    double temperature;
    Reading() : hour(0), temperature(0) { }
    Reading(int h, double t) : hour(h), temperature(t) { }
};

bool operator<(const Reading &r1, const Reading &r2)
{
    return r1.temperature < r2.temperature;
}

ostream &operator<<(ostream &os, const Reading &r)
{
    return os << '(' << r.hour << ',' << r.temperature << ')';
}

istream &operator>>(istream &is, Reading &r)
{
    int hour;
    char c1, c2, c3;
    double temperature;
    is >> c1 >> hour >> c2 >> temperature >> c3;
    if (!is)
    {
        return is;
    }
    if (c1 != '(' || c2 != ',' || c3 != ')')
    {
        is.clear(std::ios_base::failbit);
        return is;
    }
    r = Reading(hour, temperature);
    return is;
}

const int max_temp = 108;
const int min_temp = -44;

void fill_from_file(vector<Reading> &readings, const string &name)
{
    ifstream ist(name.c_str());
    if (!ist)
    {
        error("can't open input file " + name);
    }
    Reading r;
    while (ist >> r)
    {
        if (r.hour < 0 || r.hour > 23)
        {
            error("hour out of range");
        }
        if (r.temperature < min_temp || r.temperature > max_temp)
        {
            error("temperature out of range");
        }
        readings.push_back(r);
    }
}

void print_vector(const vector<Reading> &r)
{
    for (int i = 0; i < r.size(); ++i)
    {
        cout << r[i] << endl;
    }
}

int main()
{
    try
    {
        vector<Reading> readings;
        fill_from_file(readings, "ch10_p02.txt");

        sort(readings.begin(), readings.end());
        print_vector(readings);
        auto size = readings.size();
        auto mid = size / 2;
        double median;
        if (size % 2 == 0)
        {
            median = (readings[mid].temperature + readings[mid - 1].temperature) / 2;
        }
        else
        {
            median = readings[mid].temperature;
        }
        double sum = 0;
        for (int i = 0; i < readings.size(); ++i)
        {
            sum += readings[i].temperature;
        }
        double avg = sum / readings.size();

        cout << "median temperature: " << median << " F" << endl;
        cout << "average temperature: " << avg << " F" << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
(21,-22)
(20,-10.8)
(1,13.8)
(3,47)
(21,54.2)
(1,62.5)
(5,67.7)
(5,90.5)
(0,92.3)
(23,99.4)
median temperature: 58.35 F
average temperature: 49.46 F

ch10_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

const char fahr = 'f';
const char cels = 'c';

const int max_temp = 108;
const int min_temp = -44;

struct Reading
{
    int hour;
    double temperature;
    char temp_scale;
    Reading() : hour(0), temperature(0), temp_scale(fahr) { }
    Reading(int h, double t, char ts) : hour(h), temperature(t), temp_scale(ts) { }
};

bool operator<(const Reading &r1, const Reading &r2)
{
    return r1.temperature < r2.temperature;
}

ostream &operator<<(ostream &os, const Reading &r)
{
    return os << r.hour << ' ' << r.temperature << r.temp_scale;
}

istream &operator>>(istream &is, Reading &r)
{
    int hour;
    double temperature;
    char temp_scale;

    is >> hour >> temperature >> temp_scale;
    if (!is)
    {
        return is;
    }
    r = Reading(hour, temperature, temp_scale);
    return is;
}

double c_to_f(double t)
{
    return (t * 1.8 + 32.0);
}

Reading create_reading(mt19937 &e)
{
    int h = nrand_two(0, 24, e);
    double t = nrand_two(min_temp, max_temp + 1, e) + nrand_two(-10, 11, e) / double(10);
    char ts;
    nrand_two(0, 10, e) > 4 ? ts = fahr : ts = cels;
    return Reading(h, t, ts);
}

void write_to_file(const vector<Reading> &r, const string &name)
{
    ofstream ost(name.c_str());
    if (!ost)
    {
        error("can't open output file " + name);
    }
    for (int i = 0; i < r.size(); ++i)
    {
        ost << r[i] << endl;
    }
}

void fill_from_file(vector<Reading> &readings, const string &name)
{
    ifstream ist(name.c_str());
    if (!ist)
    {
        error("can't open input file " + name);
    }
    Reading r;
    char ch;
    while (ist >> r)
    {
        if (r.hour < 0 || r.hour > 23)
        {
            error("hour out of range");
        }
        if (r.temperature < min_temp || r.temperature > max_temp)
        {
            error("temperature out of range");
        }
        ch = r.temp_scale;
        switch (ch)
        {
        case cels:
            r.temperature = c_to_f(r.temperature);
            r.temp_scale = fahr;
            break;
        case fahr:
            break;
        default:
            error("illegal temperature scale " + string(1, ch));
        }
        readings.push_back(r);
    }
}

void print_vector(const vector<Reading> &r)
{
    for (int i = 0; i < r.size(); ++i)
    {
        cout << r[i] << endl;
    }
}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);
    try
    {
        vector<Reading> readings;
        for (int i = 0; i < 10; ++i)
        {
            readings.push_back(create_reading(engine));
        }
        write_to_file(readings, "ch10_p04.txt");

        vector<Reading> processed_readings;
        fill_from_file(processed_readings, "ch10_p04.txt");

        sort(processed_readings.begin(), processed_readings.end());
        print_vector(processed_readings);
        auto size = processed_readings.size();
        auto mid = size / 2;
        double median;
        if (size % 2 == 0)
        {
            median = (processed_readings[mid].temperature + processed_readings[mid - 1].temperature) / 2;
        }
        else
        {
            median = processed_readings[mid].temperature;
        }
        double sum = 0;
        for (int i = 0; i < processed_readings.size(); ++i)
        {
            sum += processed_readings[i].temperature;
        }
        double avg = sum / processed_readings.size();

        cout << "median temperature: " << median << " F" << endl;
        cout << "average temperature: " << avg << " F" << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
22 -43.8f
13 16.16f
20 24.5f
5 41.72f
21 59.18f
0 65f
6 70.34f
22 92.4f
8 106.2f
21 207.5f
median temperature: 62.09 F
average temperature: 63.92 F

cat ch10_p04.txt
22 -43.8f
6 21.3c
20 24.5f
8 106.2f
21 15.1c
13 -8.8c
0 65f
21 97.5c
5 5.4c
22 92.4f

ch10_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

const int not_a_reading = -7777;
const int not_a_month = -1;

class Day
{
public:
    vector<double> hour;
    Day();
};

Day::Day() : hour(24)
{
    for (int i = 0; i < hour.size(); ++i) { hour[i] = not_a_reading; }
}

class Month
{
public:
    int month;
    vector<Day> day;
    Month() : month(not_a_month), day(32) { }
};

class Year
{
public:
    int year;
    vector<Month> month;
    Year() : month(12) { }
};

class Reading
{
public:
    int day;
    int hour;
    double temperature;
    Reading() : day(0), hour(0), temperature(0) { }
};

int month_to_int(string s);
bool is_valid(const Reading &r);
void end_of_loop(istream &ist, char term, const string &message);

istream &operator>>(istream &is, Reading &r)
{
    char ch1;
    if (is >> ch1 && ch1 != '(')
    {
        is.unget();
        is.clear(std::ios_base::failbit);
        return is;
    }

    char ch2;
    int d;
    int h;
    double t;
    is >> d >> h >> t >> ch2;
    if (!is || ch2 != ')') { error("bad reading"); }
    r.day = d;
    r.hour = h;
    r.temperature = t;
    return is;
}

istream &operator>>(istream &is, Month &m)
{
    char ch = 0;
    if (is >> ch && ch != '{')
    {
        is.unget();
        is.clear(std::ios_base::failbit);
        return is;
    }

    string month_marker;
    string mm;
    is >> month_marker >> mm;
    if (!is || month_marker != "month") { error("bad start of month"); }
    m.month = month_to_int(mm);

    Reading r;
    int no_of_duplicate_readings = 0;
    int no_invalid_readings = 0;

    while (is >> r)
    {
        if (is_valid(r))
        {
            if (m.day[r.day].hour[r.hour] != not_a_reading)
            {
                ++no_of_duplicate_readings;
            }
            m.day[r.day].hour[r.hour] = r.temperature;
        }
        else
        {
            ++no_invalid_readings;
        }
    }
    end_of_loop(is, '}', "bad end of month");
    return is;
}

const int implausible_min = -200;
const int implausible_max = 200;

bool is_valid(const Reading &r)
{
    if (r.day < 1 || 31 < r.day) { return false; }
    if (r.hour < 0 || 23 < r.hour) { return false; }
    if (r.temperature < implausible_min || implausible_max < r.temperature)
    {
        return false;
    }
    return true;
}

istream &operator>>(istream &is, Year &y)
{
    char ch;
    is >> ch;
    if (ch != '{')
    {
        is.unget();
        is.clear(std::ios::failbit);
        return is;
    }

    string year_marker;
    int yy;
    is >> year_marker >> yy;
    if (!is || year_marker != "year") { error("bad start of year"); }
    y.year = yy;

    while (true)
    {
        Month m;
        if (!(is >> m)) { break; }
        y.month[m.month] = m;
    }

    end_of_loop(is, '}', "bad end of year");
    return is;
}

void end_of_loop(istream &ist, char term, const string &message)
{
    if (ist.fail())
    {
        ist.clear();
        char ch;
        if (ist >> ch && ch == term) { return; }
        error(message);
    }
}

vector<string> month_input_tbl;

void init_input_tbl(vector<string> &tbl)
{
    tbl.push_back("jan");
    tbl.push_back("feb");
    tbl.push_back("mar");
    tbl.push_back("apr");
    tbl.push_back("may");
    tbl.push_back("jun");
    tbl.push_back("jul");
    tbl.push_back("aug");
    tbl.push_back("sep");
    tbl.push_back("oct");
    tbl.push_back("nov");
    tbl.push_back("dec");
}

int month_to_int(string s)
{
    for (int i = 0; i < 12; ++i) { if (month_input_tbl[i] == s) { return i; } }
    return -1;
}

vector<string> month_print_tbl;

void init_print_tbl(vector<string> &tbl)
{
    tbl.push_back("January");
    tbl.push_back("February");
    tbl.push_back("March");
    tbl.push_back("April");
    tbl.push_back("May");
    tbl.push_back("June");
    tbl.push_back("July");
    tbl.push_back("August");
    tbl.push_back("September");
    tbl.push_back("October");
    tbl.push_back("November");
    tbl.push_back("December");
}

string int_to_month(int i)
{
    if (i < 0 || 12 <= i) { error("bad month index"); }
    return month_print_tbl[i];
}

void print_day(ostream &ost, const Day &d, int daynum)
{
    bool is_empty = true;
    for (int i = 0; i < 24; ++i)
    {
        if (d.hour[i] != not_a_reading)
        {
            is_empty = false;
            break;
        }
    }
    if (is_empty) { return; }
    ost << "\n        " << daynum;
    for (int i = 0; i < 24; ++i)
    {
        if (d.hour[i] != not_a_reading)
        {
            ost << "\n            " << i << ":00 - " << d.hour[i] << " F";
        }
    }
}

void print_month(ostream &ost, const Month &m)
{
    if (m.month == not_a_month) { return; }
    ost << "\n    " << int_to_month(m.month);
    for (int i = 1; i < 32; ++i)
    {
        print_day(ost, m.day[i], i);
    }
}

void print_year(ostream &ost, const Year &y)
{
    ost << y.year << ' ';
    for (int i = 0; i < 12; ++i)
    {
        print_month(ost, y.month[i]);
    }
}

int main()
{
    try
    {
        init_print_tbl(month_print_tbl);
        init_input_tbl(month_input_tbl);

        cout << "Please enter input file name\n";
        string name;
        cin >> name;
        ifstream ifs(name.c_str());
        if (!ifs) { error("can't open input file " + name); }

        ifs.exceptions(ifs.exceptions() | std::ios_base::badbit);

        cout << "Please enter output file name\n";
        cin >> name;
        ofstream ofs(name.c_str());
        if (!ofs) { error("can't open output file " + name); }

        vector<Year> ys;
        while (true)
        {
            Year y;
            if (!(ifs >> y)) { break; }
            ys.push_back(y);
        }
        cout << "read " << ys.size() << " years of readings\n";

        for (int i = 0; i < ys.size(); ++i)
        {
            print_year(ofs, ys[i]);
            ofs  << endl;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Please enter input file name
ch10_p05.txt
Please enter output file name
ch10_p05_out.txt
read 4 years of readings

{ year 1990 }
{ year 1991 { month jun } }
{ year 1992 { month jan (1 0 61.5) } { month feb (1 1 64) (2 2 65.2) } }
{ year 2000 { month feb (1 1 68) (2 3 66.66) (1 0 67.2) } { month dec (15 15 -9.2) (15 14 -8.8) (14 0 -2) } }

1990
1991
    June
1992
    January
        1
            0:00 - 61.5 F
    February
        1
            1:00 - 64 F
        2
            2:00 - 65.2 F
2000
    February
        1
            0:00 - 67.2 F
            1:00 - 68 F
        2
            3:00 - 66.66 F
    December
        14
            0:00 - -2 F
        15
            14:00 - -8.8 F
            15:00 - -9.2 F

ch10_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

class Roman_int
{
public:
    Roman_int();
    Roman_int(int n);
    int as_int() const;
    void set_val(int v);
private:
    int val;
};

// N = 0 I = 1 V = 5 X= 10 L= 50 C = 100 D = 500 M = 1000
const char N = 'N';
const char I = 'I';
const char V = 'V';
const char X = 'X';
const char L = 'L';
const char C = 'C';
const char D = 'D';
const char M = 'M';

bool is_valid_char(char ch);
int get_value(char ch);
bool counter_illegal(int counter, char ch);
int roman_int_to_int(const string &s);


Roman_int::Roman_int() : val(0) { }

Roman_int::Roman_int(int n) : val(n) { }

int Roman_int::as_int() const
{
    return val;
}

void Roman_int::set_val(int v)
{
    val = v;
}

Roman_int operator+(const Roman_int &r1, const Roman_int &r2)
{
    return Roman_int(r1.as_int() + r2.as_int());
}

Roman_int operator-(const Roman_int &r1, const Roman_int &r2)
{
    return Roman_int(r1.as_int() - r2.as_int());
}

Roman_int operator-(const Roman_int &r)
{
    return Roman_int(-r.as_int());
}

Roman_int operator*(const Roman_int &r1, const Roman_int &r2)
{
    return Roman_int(r1.as_int() * r2.as_int());
}

Roman_int operator/(const Roman_int &r1, const Roman_int &r2)
{
    if (r2.as_int() == 0)
    {
        error("division / by zero");
    }
    return Roman_int(r1.as_int() / r2.as_int());
}

Roman_int operator%(const Roman_int &r1, const Roman_int &r2)
{
    if (r2.as_int() == 0)
    {
        error("division % by zero");
    }
    return Roman_int(r1.as_int() % r2.as_int());
}

bool operator==(const Roman_int &r1, const Roman_int &r2)
{
    return r1.as_int() == r2.as_int();
}

bool operator!=(const Roman_int &r1, const Roman_int &r2)
{
    return !(r1 == r2);
}

bool operator<(const Roman_int &r1, const Roman_int &r2)
{
    return r1.as_int() < r2.as_int();
}

bool operator>(const Roman_int &r1, const Roman_int &r2)
{
    return r2 < r1;
}

bool operator<=(const Roman_int &r1, const Roman_int &r2)
{
    return !(r2 < r1);
}

bool operator>=(const Roman_int &r1, const Roman_int &r2)
{
    return !(r1 < r2);
}

bool is_valid_char(char ch)
{
    return ch == N || ch == I || ch == V || ch == X || ch == L || ch == C || ch == D || ch == M;
}

ostream &operator<<(ostream &os, const Roman_int &r)
{
    int val = r.as_int();
    if (val == 0)
    {
        return os << N;
    }
    if (val < 0)
    {
        os << '-';
        val = -val;
    }

    while (val >= 1000)
    {
        os << M;
        val -= 1000;
    }
    if (val >= 900)
    {
        os << C << M;
        val -= 900;
    }
    else if (val >= 500)
    {
        os << D;
        val -= 500;
    }
    else if (val >= 400)
    {
        os << C << D;
        val -= 400;
    }
    while (val >= 100)
    {
        os << C;
        val -= 100;
    }
    if (val >= 90)
    {
        os << X << C;
        val -= 90;
    }
    else if (val >= 50)
    {
        os << L;
        val -= 50;
    }
    else if (val >= 40)
    {
        os << X << L;
        val -= 40;
    }
    while (val >= 10)
    {
        os << X;
        val -= 10;
    }
    if (val == 9)
    {
        os << I << X;
        val -= 9;
    }
    else if (val >= 5)
    {
        os << V;
        val -= 5;
    }
    else if (val == 4)
    {
        os << I << V;
        val -= 4;
    }
    while (val >= 1)
    {
        os << I;
        --val;
    }
    return os;
}

int get_value(char ch)
{
    switch (ch)
    {
    case N:
        return 0;
    case I:
        return 1;
    case V:
        return 5;
    case X:
        return 10;
    case L:
        return 50;
    case C:
        return 100;
    case D:
        return 500;
    case M:
        return 1000;
    default:
        error("illegal letter used: " + string(1, ch));
    }
}

bool counter_illegal(int counter, char ch)
{
    switch (ch)
    {
    case N:
    case V:
    case L:
    case D:
        return counter > 1;
    case I:
    case X:
    case C:
    case M:
        return counter > 3;
    default:
        error("counter_illegal: invalid character " + string(1, ch));
    }
}

int roman_int_to_int(const string &s)
{
    if (s.size() == 0)
    {
        error("roman_to_int: empty string");
    }
    if (s.size() == 1)
    {
        return get_value(s[0]);
    }

    int counter = 1;
    int val = get_value(s[s.size() - 1]);

    for (int i = s.size() - 2; i >= 0; --i)
    {
        if (s[i] == s[i + 1])
        {
            ++counter;
            if (counter_illegal(counter, s[i]))
            {
                error("illegal repetition of letter: " + string(1, s[i]));
            }
        }
        else
        {
            counter = 1;
        }

        if (get_value(s[i]) < get_value(s[i + 1]))
        {
            if ((s[i] == I || s[i] == X || s[i] == C) && get_value(s[i + 1]) <= 10 * get_value(s[i]))
            {
                val -= get_value(s[i]);
            }
            else
            {
                error("illegal use of " + string(1, s[i]));
            }
        }
        else
        {
            val += get_value(s[i]);
        }
    }
    return val;
}

istream &operator>>(istream &is, Roman_int &r)
{
    is.exceptions(is.exceptions() | std::ios_base::badbit);

    string s;
    char ch;

    while (is.get(ch))
    {
        if (is_valid_char(ch))
        {
            s += ch;
        }
        else
        {
            is.putback(ch);
            break;
        }
    }

    int val = roman_int_to_int(s);
    r.set_val(val);
    return is;
}

void test_output()
{
    cout << Roman_int(0) << " equals " << Roman_int(0).as_int() << endl;
    cout << Roman_int(1) << " equals " << Roman_int(1).as_int() << endl;
    cout << Roman_int(4) << " equals " << Roman_int(4).as_int() << endl;
    cout << Roman_int(5) << " equals " << Roman_int(5).as_int() << endl;
    cout << Roman_int(8) << " equals " << Roman_int(8).as_int() << endl;
    cout << Roman_int(9) << " equals " << Roman_int(9).as_int() << endl;
    cout << Roman_int(10) << " equals " << Roman_int(10).as_int() << endl;
    cout << Roman_int(48) << " equals " << Roman_int(48).as_int() << endl;
    cout << Roman_int(81) << " equals " << Roman_int(81).as_int() << endl;
    cout << Roman_int(99) << " equals " << Roman_int(99).as_int() << endl;
    cout << Roman_int(105) << " equals " << Roman_int(105).as_int() << endl;
    cout << Roman_int(2014) << " equals " << Roman_int(2014).as_int() << endl;
    cout << Roman_int(-2014) << " equals " << Roman_int(-2014).as_int() << endl;
    cout << Roman_int(1499) << " equals " << Roman_int(1499).as_int() << endl << endl;
    cout << Roman_int(1) << " + " << Roman_int(3) << " = " << Roman_int(1) + Roman_int(3) << endl;
    cout << Roman_int(15) << " * " << Roman_int(37) << " = " << Roman_int(15)*Roman_int(37) << endl;
    cout << Roman_int(105) << " - " << Roman_int(207) << " = " << Roman_int(105) - Roman_int(207) << endl;
    cout << -Roman_int(7) << " * " << Roman_int(5) << " = " << -Roman_int(7)*Roman_int(5) << endl;
    cout << Roman_int(15) << " / " << Roman_int(5) << " = " << Roman_int(15) / Roman_int(5) << endl;
}


int main()
{
    try
    {
        test_output();
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
N equals 0
I equals 1
IV equals 4
V equals 5
VIII equals 8
IX equals 9
X equals 10
XLVIII equals 48
LXXXI equals 81
XCIX equals 99
CV equals 105
MMXIV equals 2014
-MMXIV equals -2014
MCDXCIX equals 1499

I + III = IV
XV * XXXVII = DLV
CV - CCVII = -CII
-VII * V = -XXXV
XV / V = III

ch10_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

class Roman_int
{
public:
    Roman_int();
    Roman_int(int n);
    int as_int() const;
    void set_val(int v);
private:
    int val;
};

// N = 0 I = 1 V = 5 X= 10 L= 50 C = 100 D = 500 M = 1000
const char N = 'N';
const char I = 'I';
const char V = 'V';
const char X = 'X';
const char L = 'L';
const char C = 'C';
const char D = 'D';
const char M = 'M';

bool is_valid_char(char ch);
int get_value(char ch);
bool counter_illegal(int counter, char ch);
int roman_int_to_int(const string &s);


Roman_int::Roman_int() : val(0) { }

Roman_int::Roman_int(int n) : val(n) { }

int Roman_int::as_int() const
{
    return val;
}

void Roman_int::set_val(int v)
{
    val = v;
}

Roman_int operator+(const Roman_int &r1, const Roman_int &r2)
{
    return Roman_int(r1.as_int() + r2.as_int());
}

Roman_int operator-(const Roman_int &r1, const Roman_int &r2)
{
    return Roman_int(r1.as_int() - r2.as_int());
}

Roman_int operator-(const Roman_int &r)
{
    return Roman_int(-r.as_int());
}

Roman_int operator*(const Roman_int &r1, const Roman_int &r2)
{
    return Roman_int(r1.as_int() * r2.as_int());
}

Roman_int operator/(const Roman_int &r1, const Roman_int &r2)
{
    if (r2.as_int() == 0)
    {
        error("division / by zero");
    }
    return Roman_int(r1.as_int() / r2.as_int());
}

Roman_int operator%(const Roman_int &r1, const Roman_int &r2)
{
    if (r2.as_int() == 0)
    {
        error("division % by zero");
    }
    return Roman_int(r1.as_int() % r2.as_int());
}

bool operator==(const Roman_int &r1, const Roman_int &r2)
{
    return r1.as_int() == r2.as_int();
}

bool operator!=(const Roman_int &r1, const Roman_int &r2)
{
    return !(r1 == r2);
}

bool operator<(const Roman_int &r1, const Roman_int &r2)
{
    return r1.as_int() < r2.as_int();
}

bool operator>(const Roman_int &r1, const Roman_int &r2)
{
    return r2 < r1;
}

bool operator<=(const Roman_int &r1, const Roman_int &r2)
{
    return !(r2 < r1);
}

bool operator>=(const Roman_int &r1, const Roman_int &r2)
{
    return !(r1 < r2);
}

bool is_valid_char(char ch)
{
    return ch == N || ch == I || ch == V || ch == X || ch == L || ch == C || ch == D || ch == M;
}

ostream &operator<<(ostream &os, const Roman_int &r)
{
    int val = r.as_int();
    if (val == 0)
    {
        return os << N;
    }
    if (val < 0)
    {
        os << '-';
        val = -val;
    }

    while (val >= 1000)
    {
        os << M;
        val -= 1000;
    }
    if (val >= 900)
    {
        os << C << M;
        val -= 900;
    }
    else if (val >= 500)
    {
        os << D;
        val -= 500;
    }
    else if (val >= 400)
    {
        os << C << D;
        val -= 400;
    }
    while (val >= 100)
    {
        os << C;
        val -= 100;
    }
    if (val >= 90)
    {
        os << X << C;
        val -= 90;
    }
    else if (val >= 50)
    {
        os << L;
        val -= 50;
    }
    else if (val >= 40)
    {
        os << X << L;
        val -= 40;
    }
    while (val >= 10)
    {
        os << X;
        val -= 10;
    }
    if (val == 9)
    {
        os << I << X;
        val -= 9;
    }
    else if (val >= 5)
    {
        os << V;
        val -= 5;
    }
    else if (val == 4)
    {
        os << I << V;
        val -= 4;
    }
    while (val >= 1)
    {
        os << I;
        --val;
    }
    return os;
}

int get_value(char ch)
{
    switch (ch)
    {
    case N:
        return 0;
    case I:
        return 1;
    case V:
        return 5;
    case X:
        return 10;
    case L:
        return 50;
    case C:
        return 100;
    case D:
        return 500;
    case M:
        return 1000;
    default:
        error("illegal letter used: " + string(1, ch));
    }
}

bool counter_illegal(int counter, char ch)
{
    switch (ch)
    {
    case N:
    case V:
    case L:
    case D:
        return counter > 1;
    case I:
    case X:
    case C:
    case M:
        return counter > 3;
    default:
        error("counter_illegal: invalid character " + string(1, ch));
    }
}

int roman_int_to_int(const string &s)
{
    if (s.size() == 0)
    {
        error("roman_to_int: empty string");
    }
    if (s.size() == 1)
    {
        return get_value(s[0]);
    }

    int counter = 1;
    int val = get_value(s[s.size() - 1]);

    for (int i = s.size() - 2; i >= 0; --i)
    {
        if (s[i] == s[i + 1])
        {
            ++counter;
            if (counter_illegal(counter, s[i]))
            {
                error("illegal repetition of letter: " + string(1, s[i]));
            }
        }
        else
        {
            counter = 1;
        }

        if (get_value(s[i]) < get_value(s[i + 1]))
        {
            if ((s[i] == I || s[i] == X || s[i] == C) && get_value(s[i + 1]) <= 10 * get_value(s[i]))
            {
                val -= get_value(s[i]);
            }
            else
            {
                error("illegal use of " + string(1, s[i]));
            }
        }
        else
        {
            val += get_value(s[i]);
        }
    }
    return val;
}

istream &operator>>(istream &is, Roman_int &r)
{
    is.exceptions(is.exceptions() | std::ios_base::badbit);

    string s;
    char ch;

    while (is.get(ch))
    {
        if (is_valid_char(ch))
        {
            s += ch;
        }
        else
        {
            is.putback(ch);
            break;
        }
    }

    int val = roman_int_to_int(s);
    r.set_val(val);
    return is;
}

const char let = 'L';
const char con = 'C';
const char quit = 'q';
const char help = 'h';
const char print = ';';
const char number = '8';
const char name = 'a';
const string declkey = "let";
const string conkey = "const";
const string quitkey = "quit";
const string helpkey = "help";
const string prompt = "> ";
const string result = "= ";

class Token
{
public:
    char kind;
    Roman_int value;
    string name;
    Token(char ch) : kind(ch), value(0) { }
    Token(char ch, const Roman_int & val) : kind(ch), value(val) { }
    Token(char ch, const string & n) : kind(ch), value(0), name(n) { }
};

class Token_stream
{
public:
    Token_stream();
    Token_stream(istream &is);
    Token get();
    void putback(const Token &t);
    void ignore(char c);
    istream & get_istream();
private:
    bool full;
    Token buffer;
    istream *is_ptr;
};

Token_stream::Token_stream() : full(false), buffer(0), is_ptr(&cin) { }
Token_stream::Token_stream(istream &is) : full(false), buffer(0), is_ptr(&is) { }
istream &  Token_stream::get_istream()
{
    return (*is_ptr);
}

void Token_stream::putback(const Token &t)
{
    if (full)
    {
        error("putback() into a full buffer");
    }
    buffer = t;
    full = true;
}

Token Token_stream::get()
{
    if (full)
    {
        full = false;
        return buffer;
    }

    char ch;
    (*is_ptr).get(ch);
    while (isspace(ch))
    {
        if (ch == '\n')
        {
            return Token(print);
        }
        (*is_ptr).get(ch);
    }

    switch (ch)
    {
    case print:
    case '{':
    case '}':
    case '(':
    case ')':
    case '+':
    case '-':
    case '*':
    case '/':
    case '%':
    case '=':
        return Token(ch);
    case N: case I: case V: case X:
    case L: case C: case D: case M:
    {
        (*is_ptr).putback(ch);
        Roman_int val;
        (*is_ptr) >> val;
        return Token(number, val);
    }
    default:
        if (isalpha(ch))
        {
            string s;
            s += ch;
            while ((*is_ptr).get(ch) && (isalpha(ch) || isdigit(ch) || ch == '_'))
            {
                s += ch;
            }
            (*is_ptr).putback(ch);
            if (s == declkey)
            {
                return Token(let);
            }
            if (s == conkey)
            {
                return Token(con);
            }
            if (s == helpkey)
            {
                return Token(help);
            }
            if (s == quitkey)
            {
                return Token(quit);
            }
            return Token(name, s);
        }
        error("Bad token");
    }
}

void Token_stream::ignore(char c)
{
    if (full && c == buffer.kind)
    {
        full = false;
        return;
    }
    full = false;

    char ch = 0;
    while ((*is_ptr) >> ch)
    {
        if (ch == c)
        {
            return;
        }
    }
}

class Variable
{
public:
    string name;
    Roman_int value;
    bool is_const;
    Variable(const string &n, const Roman_int &v, bool b) : name(n), value(v), is_const(b) { }
};

class Symbol_table
{
public:
    Roman_int get(const string &s);
    void set(const string & s, const Roman_int & d);
    bool is_declared(const string & var);
    Roman_int declare(const string & var, const Roman_int & val, bool b);
private:
    vector<Variable> var_table;
};

Roman_int Symbol_table::get(const string &s)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            return var_table[i].value;
        }
    }
    error("get: undefined variable " + s);
}

void Symbol_table::set(const string & s, const Roman_int & d)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            if (var_table[i].is_const)
            {
                error(s + " is a constant");
            }
            var_table[i].value = d;
            return;
        }
    }
    error("set: undefined variable " + s);
}

bool Symbol_table::is_declared(const string & var)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == var)
        {
            return true;
        }
    }
    return false;
}

Roman_int Symbol_table::declare(const string & var, const Roman_int & val, bool b)
{
    if (is_declared(var))
    {
        error(var + " declared twice");
    }
    var_table.push_back(Variable(var, val, b));
    return Roman_int(val);
}

Token_stream ts;
Symbol_table st;
Roman_int expression();

Roman_int primary()
{
    Token t = ts.get();
    Roman_int d(0);
    switch (t.kind)
    {
    case '(':
        d = expression();
        t = ts.get();
        if (t.kind != ')')
        {
            error("')' expected");
        }
        break;
    case '{':
        d = expression();
        t = ts.get();
        if (t.kind != '}')
        {
            error("'}' expected");
        }
        break;
    case number:
        d = t.value;
        break;
    case '-':
        d = -primary();
        break;
    case '+':
        d = primary();
        break;
    case name:
    {
        Token t2 = ts.get();
        if (t2.kind == '=')
        {
            d = expression();
            st.set(t.name, d);
        }
        else
        {
            ts.putback(t2);
            d = st.get(t.name);
        }
    }
    break;
    default:
        error("primary expected");
    }

    return d;
}

Roman_int term()
{
    Roman_int left = primary();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '*':
            left = left * primary();
            t = ts.get();
            break;
        case '/':
        {
            Roman_int d = primary();
            if (d == Roman_int(0))
            {
                error("divide by zero");
            }
            left = left / d;
            t = ts.get();
            break;
        }
        case '%':
        {
            Roman_int d = primary();
            if (d == Roman_int(0))
            {
                error("%: divide by zero");
            }
            left = left % d;
            t = ts.get();
            break;
        }
        default:
            ts.putback(t);
            return left;
        }
    }
}

Roman_int expression()
{
    Roman_int left = term();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '+':
           left = left + term();
            t = ts.get();
            break;
        case '-':
            left = left - term();
            t = ts.get();
            break;
        default:
            ts.putback(t);
            return left;
        }
    }
}

Roman_int declaration(bool b)
{
    Token t = ts.get();
    if (t.kind != name)
    {
        error ("name expected in declaration");
    }
    string var_name = t.name;

    Token t2 = ts.get();
    if (t2.kind != '=')
    {
        error("= missing in declaration of " + var_name);
    }

    Roman_int d = expression();
    st.declare(var_name, d, b);
    return d;
}

Roman_int statement()
{
    Token t = ts.get();
    switch(t.kind)
    {
    case let:
        return declaration(false);
    case con:
        return declaration(true);
    default:
        ts.putback(t);
        return expression();
    }
}

void clean_up_mess()
{
    ts.ignore(print);
}

void print_help()
{
    cout << "Instructions: enter expressions, you can declare variables using\n";
    cout << "the 'let' keyword and constants with the 'const' keyword.\n";
}

void calculate()
{
    while (ts.get_istream())
    {
        try
        {
            cout << prompt;
            Token t = ts.get();
            while (t.kind == print)
            {
                t = ts.get();
            }
            if (t.kind == help)
            {
                print_help();
            }
            else if (t.kind == quit)
            {
                return;
            }
            else
            {
                ts.putback(t);
                cout << result << statement() << endl;
            }
        }
        catch(exception &e)
        {
            cerr << e.what() << endl;
            clean_up_mess();
        }
    }
}

int main()
{
    try
    {
        cout << "Welcome to our simple calculator.\n";
        cout << "Enter '" << helpkey << "' to get the help info; enter '" << quitkey << "' to quit.\n";

        calculate();
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Welcome to our simple calculator.
Enter 'help' to get the help info; enter 'quit' to quit.
> V+VII
= XII
> V-VII
= -II
> V*VII
= XXXV
> V/VII
= N
> XXXV/VII
= V
> quit

ch10_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}


int main()
{
    try
    {
        string s1;
        string s2;
        string s3;
        cout << "Enter first file name: ";
        cin >> s1;
        cout << "Enter second file name: ";
        cin >> s2;
        cout << "Enter output file name: ";
        cin >> s3;

        ifstream ifs1(s1.c_str());
        if (!ifs1) { error("can't open input file " + s1); }
        ifstream ifs2(s2.c_str());
        if (!ifs2) { error("can't open input file " + s2); }
        ofstream ofs(s3.c_str());
        if (!ofs) { error("can't open output file " + s3); }

        char ch;
        while (ifs1.get(ch)) { ofs << ch; }
        while (ifs2.get(ch)) { ofs << ch; }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter first file name: ch10_p07.cpp
Enter second file name: ch10_p08.cpp
Enter output file name: ch10_p08.txt

ls -l ch10_p07.cpp ch10_p08.*
-rw-r--r-- 1 weiyayun weiyayun 16604 Nov 30 12:06 ch10_p07.cpp
-rw-r--r-- 1 weiyayun weiyayun  2769 Nov 30 12:18 ch10_p08.cpp
-rw-r--r-- 1 weiyayun weiyayun 19373 Nov 30 12:18 ch10_p08.txt

ch10_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}


int main()
{
    try
    {
        string s1;
        string s2;
        string s3;
        cout << "Enter first file name: ";
        cin >> s1;
        cout << "Enter second file name: ";
        cin >> s2;
        cout << "Enter output file name: ";
        cin >> s3;

        ifstream ifs1(s1.c_str());
        if (!ifs1) { error("can't open input file " + s1); }
        ifstream ifs2(s2.c_str());
        if (!ifs2) { error("can't open input file " + s2); }
        ofstream ofs(s3.c_str());
        if (!ofs) { error("can't open output file " + s3); }

        string sf1;
        string sf2;
        ifs1 >> sf1;
        ifs2 >> sf2;
        if (sf1 == "" || sf2 == "") { error("at least one input file is empty"); }

        while (true)
        {
            if (sf1 <= sf2)
            {
                ofs << sf1 << endl;
                if ( !(ifs1 >> sf1) ) { break; }
            }
            else
            {
                ofs << sf2 << endl;
                if ( !(ifs2 >> sf2) ) { break; }
            }
        }

        if (ifs1.eof())
        {
            ofs << sf2 << endl;
            while (ifs2 >> sf2) { ofs << sf2 << endl; }
        }
        else
        {
            ofs << sf1 << endl;
            while (ifs1 >> sf1) { ofs << sf1 << endl; }
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter first file name: ch10_p09a.txt
Enter second file name: ch10_p09b.txt
Enter output file name: ch10_p09_out.txt

ls -l ch10_p09*.txt
-rw-r--r-- 1 weiyayun weiyayun 16 Nov 30 12:30 ch10_p09a.txt
-rw-r--r-- 1 weiyayun weiyayun 10 Nov 30 12:30 ch10_p09b.txt
-rw-r--r-- 1 weiyayun weiyayun 26 Nov 30 12:32 ch10_p09_out.txt

cat ch10_p09a.txt
1
2
3
8
9
e
f
g

cat ch10_p09b.txt
5
6
l
m
n

cat ch10_p09_out.txt
1
2
3
5
6
8
9
e
f
g
l
m
n

ch10_p10.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

const char let = 'L';
const char con = 'C';
const char quit = 'q';
const char help = 'h';
const char print = ';';
const char number = '8';
const char name = 'a';
const char square_root = 's';
const char power = 'p';
const string declkey = "let";
const string conkey = "const";
const string sqrtkey = "sqrt";
const string powkey = "pow";
const string quitkey = "quit";
const string helpkey = "help";
const string prompt = "> ";
const string result = "= ";

class Token
{
public:
    char kind;
    double value;
    string name;
    Token(char ch) : kind(ch), value(0) { }
    Token(char ch, double val) : kind(ch), value(val) { }
    Token(char ch, string n) : kind(ch), value(0), name(n) { }
};

class Token_stream
{
public:
    Token_stream();
    Token_stream(istream &is);
    Token_stream(istream &is, ostream &os);
    Token get();
    void putback(Token t);
    void ignore(char c);
    istream & get_istream();
    void set_istream(istream &is);
    ostream & get_ostream();
    void set_ostream(ostream &os);
private:
    bool full;
    Token buffer;
    istream *is_ptr;
    ostream *os_ptr;
};

Token_stream::Token_stream() : full(false), buffer(0), is_ptr(&cin), os_ptr(&cout) { }
Token_stream::Token_stream(istream &is) : full(false), buffer(0), is_ptr(&is), os_ptr(&cout) { }
Token_stream::Token_stream(istream &is, ostream &os) : full(false), buffer(0), is_ptr(&is), os_ptr(&os) { }
istream &  Token_stream::get_istream()
{
    return (*is_ptr);
}
void   Token_stream::set_istream(istream &is)
{
    is_ptr = &is;
}
ostream &  Token_stream::get_ostream()
{
    return (*os_ptr);
}
void   Token_stream::set_ostream(ostream &os)
{
    os_ptr = &os;
}
void Token_stream::putback(Token t)
{
    if (full)
    {
        error("putback() into a full buffer");
    }
    buffer = t;
    full = true;
}

Token Token_stream::get()
{
    if (full)
    {
        full = false;
        return buffer;
    }

    char ch;
    (*is_ptr).get(ch);
    while (isspace(ch))
    {
        if (ch == '\n')
        {
            return Token(print);
        }
        (*is_ptr).get(ch);
    }

    switch (ch)
    {
    case print:
    case '!':
    case '{':
    case '}':
    case '(':
    case ')':
    case '+':
    case '-':
    case '*':
    case '/':
    case '%':
    case '=':
    case ',':
        return Token(ch);
    case '.':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    {
        (*is_ptr).putback(ch);
        double val;
        (*is_ptr) >> val;
        return Token(number, val);
    }
    default:
        if (isalpha(ch))
        {
            string s;
            s += ch;
            while ((*is_ptr).get(ch) && (isalpha(ch) || isdigit(ch) || ch == '_'))
            {
                s += ch;
            }
            (*is_ptr).putback(ch);
            if (s == declkey)
            {
                return Token(let);
            }
            if (s == conkey)
            {
                return Token(con);
            }
            if (s == sqrtkey)
            {
                return Token(square_root);
            }
            if (s == powkey)
            {
                return Token(power);
            }
            if (s == helpkey)
            {
                return Token(help);
            }
            if (s == quitkey)
            {
                return Token(quit);
            }
            return Token(name, s);
        }
        error("Bad token");
    }
}

void Token_stream::ignore(char c)
{
    if (full && c == buffer.kind)
    {
        full = false;
        return;
    }
    full = false;

    char ch = 0;
    while ((*is_ptr) >> ch)
    {
        if (ch == c)
        {
            return;
        }
    }
}

class Variable
{
public:
    string name;
    double value;
    bool is_const;
    Variable(string n, double v, bool b) : name(n), value(v), is_const(b) { }
};

class Symbol_table
{
public:
    double get(string s);
    void set(string s, double d);
    bool is_declared(string var);
    double declare(string var, double val, bool b);
private:
    vector<Variable> var_table;
};

double Symbol_table::get(string s)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            return var_table[i].value;
        }
    }
    error("get: undefined variable " + s);
}

void Symbol_table::set(string s, double d)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            if (var_table[i].is_const)
            {
                error(s + " is a constant");
            }
            var_table[i].value = d;
            return;
        }
    }
    error("set: undefined variable " + s);
}

bool Symbol_table::is_declared(string var)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == var)
        {
            return true;
        }
    }
    return false;
}

double Symbol_table::declare(string var, double val, bool b)
{
    if (is_declared(var))
    {
        error(var + " declared twice");
    }
    var_table.push_back(Variable(var, val, b));
    return val;
}

Token_stream ts;
Symbol_table st;
double expression();

double factorial(double d)
{
    int p = d;
    if (double(p) != d)
    {
        error("factorial not defined for non-integers");
    }
    if (p < 0)
    {
        error("factorial not defined for negative values");
    }
    else if (p == 0)
    {
        return 1;
    }
    else
    {
        double res = p;
        for (int i = p - 1; i > 0; --i)
        {
            res *= i;
            if (res > 1.0e+16)
            {
                error("factorial too large");
            }
        }
        return res;
    }
}

double my_pow(double base, int expo)
{
    if (expo < 0)
    {
        error("my_pow not defined for negative expo");
    }
    if (expo == 0)
    {
        if (base == 0)
        {
            return 0;
        }
        return 1;
    }
    double res = base;
    for (int i = 2; i <= expo; ++i)
    {
        res *= base;
    }
    return res;
}

double primary()
{
    Token t = ts.get();
    double d = 0;
    switch (t.kind)
    {
    case '(':
        d = expression();
        t = ts.get();
        if (t.kind != ')')
        {
            error("')' expected");
        }
        break;
    case '{':
        d = expression();
        t = ts.get();
        if (t.kind != '}')
        {
            error("'}' expected");
        }
        break;
    case number:
        d = t.value;
        break;
    case '-':
        d = -primary();
        break;
    case '+':
        d = primary();
        break;
    case name:
    {
        Token t2 = ts.get();
        if (t2.kind == '=')
        {
            d = expression();
            st.set(t.name, d);
        }
        else
        {
            ts.putback(t2);
            d = st.get(t.name);
        }
    }
    break;
    case square_root:
    {
        Token t2 = ts.get();
        if (t2.kind != '(')
        {
            error("'(' expected");
        }
        double d2 = expression();
        if (d2 < 0)
        {
            error("Square roots of negative numbers... nope!");
        }
        t2 = ts.get();
        if (t2.kind != ')')
        {
            error("')' expected");
        }
        d = sqrt(d2);
    }
    break;
    case power:
    {
        Token t2 = ts.get();
        if (t2.kind != '(')
        {
            error("'(' expected");
        }
        double d2 = expression();
        t2 = ts.get();
        if (t2.kind != ',')
        {
            error("',' expected");
        }
        t2 = ts.get();
        if (t2.kind != number)
        {
            error("second argument of 'pow' is not a number");
        }
        int i2 = int(t2.value);
        if (i2 != t2.value)
        {
            error("second argument of 'pow' is not an integer");
        }
        t2 = ts.get();
        if (t2.kind != ')')
        {
            error("')' expected");
        }
        d = my_pow(d2, i2);
    }
    break;
    default:
        error("primary expected");
    }

    t = ts.get();
    if (t.kind != '!')
    {
        ts.putback(t);
        return d;
    }
    return factorial(d);
}

double term()
{
    double left = primary();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '*':
            left *= primary();
            t = ts.get();
            break;
        case '/':
        {
            double d = primary();
            if (d == 0)
            {
                error("divide by zero");
            }
            left /= d;
            t = ts.get();
            break;
        }
        case '%':
        {
            double d = primary();
            int i1 = int(left);
            if (i1 != left)
            {
                error("left-hand operand of % not int");
            }
            int i2 = int(d);
            if (i2 != d)
            {
                error("right-hand operand of % not int");
            }
            if (i2 == 0)
            {
                error("%: divide by zero");
            }
            left = i1 % i2;
            t = ts.get();
            break;
        }
        default:
            ts.putback(t);
            return left;
        }
    }
}

double expression()
{
    double left = term();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '+':
            left += term();
            t = ts.get();
            break;
        case '-':
            left -= term();
            t = ts.get();
            break;
        case '=':
            error("use of '=' outside of a declaration");
        default:
            ts.putback(t);
            return left;
        }
    }
}

double declaration(bool b)
{
    Token t = ts.get();
    if (t.kind != name)
    {
        error ("name expected in declaration");
    }
    string var_name = t.name;

    Token t2 = ts.get();
    if (t2.kind != '=')
    {
        error("= missing in declaration of " + var_name);
    }

    double d = expression();
    st.declare(var_name, d, b);
    return d;
}

double statement()
{
    Token t = ts.get();
    switch(t.kind)
    {
    case let:
        return declaration(false);
    case con:
        return declaration(true);
    default:
        ts.putback(t);
        return expression();
    }
}

void clean_up_mess()
{
    ts.ignore(print);
}

void print_help()
{
    cout << "Instructions: enter expressions, there are\n";
    cout << "a few functions, you can declare variables using\n";
    cout << "the 'let' keyword and constants with the 'const'\n";
    cout << "keyword.\n";
}

void calculate()
{
    while (ts.get_istream())
    {
        try
        {
            Token t = ts.get();
            while (t.kind == print)
            {
                t = ts.get();
            }
            if (t.kind == help)
            {
                print_help();
            }
            else if (t.kind == quit)
            {
                return;
            }
            else
            {
                ts.putback(t);
                ostream & file_out = ts.get_ostream();
                file_out << result << statement() << endl;
            }
        }
        catch(exception &e)
        {
            cerr << e.what() << endl;
            clean_up_mess();
        }
    }
}

int main()
{
    try
    {
        st.declare("pi", 3.1415926535, true);
        st.declare("e", 2.7182818284, true);
        st.declare("k", 1000, true);

        string s1, s2;
        cout << "Enter input file name: ";
        cin >> s1;
        cout << "Enter output file name: ";
        cin >> s2;

        ifstream ifs(s1.c_str());
        if (!ifs) { error("can't open input file " + s1); }
        ofstream ofs(s2.c_str());
        if (!ofs) { error("can't open output file " + s2); }
        ts.set_istream(ifs);
        ts.set_ostream(ofs);

        calculate();
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
cat ch10_p10_in.txt
7*8!
sqrt(2+6.7)
pow(2.5,3)
let x = 3.4
let y = 2
let z = (x+y*2)/pi
2+3*z
quit

ch10_p10
Enter input file name: ch10_p10_in.txt
Enter output file name: ch10_p10_out.txt

cat ch10_p10_out.txt
= 282240
= 2.94958
= 15.625
= 3.4
= 2
= 2.35549
= 9.06648

ch10_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        string ifname;
        cout << "Enter input file name: ";
        cin >> ifname;
        ifstream ifs(ifname.c_str());
        if (!ifs) { error("can't open input file " + ifname); }

        int count = 0;
        int sum = 0;
        char ch = 0;
        int i = 0;
        string s;
        while (ifs >> ch)
        {
            if (isdigit(ch))
            {
                ifs.unget();
                if (ifs >> i)
                {
                    ++count;
                    sum += i;
                    cout << i << endl;
                }
                else { error("can't read integer"); }
            }
            else
            {
                ifs.unget();
                ifs >> s;
            }
        }
        cout << "Sum of " << count << " whitespace-separated integers in file: " << sum << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch10_p11_in.txt
123
789
456
Sum of 3 whitespace-separated integers in file: 1368

cat ch10_p11_in.txt
123abc   hello 789world 456 efg

ch10_p12.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}


int main()
{
    try
    {
        string ifname;
        cout << "Enter input file name: ";
        cin >> ifname;
        ifstream ifs(ifname.c_str());
        if (!ifs) { error("can't open input file " + ifname); }
        string word;
        cout << "Enter word to look for: ";
        cin >> word;

        int counter = 0;
        string current_line;
        while (getline(ifs, current_line, '\n'))
        {
            ++counter;
            for (int i = 0; i < current_line.size(); ++i)
            {
                if (current_line[i] == word[0] && current_line.size() > i + word.size() - 1)
                {
                    bool identical = true;
                    for (int j = 1; j < word.size(); ++j)
                    {
                        if (word[j] != current_line[i + j])
                        {
                            identical = false;
                        }
                    }
                    if (identical)
                    {
                        cout << counter << ": " << current_line << endl;
                        break;
                    }
                }
            }
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch10_p12.cpp
Enter word to look for: cout
25: using std::cout;
99:         cout << "Enter input file name: ";
104:         cout << "Enter word to look for: ";
126:                         cout << counter << ": " << current_line << endl;

第11章 定制入/输出
11.1 有规律的和无规律的输入和输出
11.2 格式化输出
11.2.1 输出整数
11.2.2 输人整数
11.2.3 输出浮点数
11.2.4 精度
11.2.5 域
11.3 文件打开和定位
11.3.1 文件打开模式
11.3.2 二进制文件
11.3.3 在文件中定位
11.4 字符串流
11.5 面向行的输入
11.6 字符分类
11.7 使用非标准分隔符
11.8 还有很多未讨论的内容
ch11_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

void int_output()
{
    cout << showbase << "Birth year:" << endl
         << 1980 << "\t(decimal)" << endl
         << hex << 1980 << "\t(hexadecimal)" << endl
         << oct << 1980 << "\t(octal)" << endl;

    cout << dec << endl << "Age:" << endl
         << 33 << "\t(decimal)" << endl
         << hex << 33 << "\t(hexadecimal)" << endl
         << oct << 33 << "\t(octal)" << endl;
    cout << dec << endl;
}

void int_input()
{
    int a;
    int b;
    int c;
    int d;
    cin >> a >> hex >> b >> oct >> c >> d;
    cout << a << '\t' << b << '\t' << c << '\t' << d << endl;
}

void float_output()
{
    cout << 1234567.89 << "\t(general)\n"
         << fixed << 1234567.89 << "\t(fixed)\n"
         << scientific << 1234567.89 << "\t(scientific)\n";
}

int main()
{
    try
    {
        int_output();
        int_input();
        float_output();
        cout << setw(10) << "Wuethrich" << " | " << "Benjamin" << " | "
             << setw(16) << "+1345 326 5181" << " | " << setw(29) << "benjamin.wuethrich@gmail.com" << endl
             << setw(10) << "Forrest" << " | " << setw(8) << "Kara" << " | "
             << setw(16) << "+1345 516 1920" << " | " << setw(29) << "kara_forrest@hotmail.com" << endl
             << setw(10) << "Aarnau" << " | " << setw(8) << "Mayra" << " | "
             << "+34 66 696 55 63" << " | " << setw(29) << "mayraaachen@hotmail.com" << endl
             << setw(10) << "Michel" << " | " << setw(8) << "Tanael" << " | "
             << "+41 79 374 48 62" << " | " << setw(29) << "tanael@gmail.com" << endl
             << setw(10) << "Widler" << " | " << setw(8) << "Andrea" << " | "
             << "+41 79 293 29 38" << " | " << setw(29) << "andreawidler@bluewin.ch" << endl
             << "Amanatidou" << " | " << "Elisabet" << " | "
             << "+41 76 701 61 28" << " | " << "elisabet.amanatidou@gmail.com" << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Birth year:
1980    (decimal)
0x7bc   (hexadecimal)
03674   (octal)

Age:
33      (decimal)
0x21    (hexadecimal)
041     (octal)

1980 7bc 3674 41
1980    1980    1980    33
1.23457e+06     (general)
1234567.890000  (fixed)
1.234568e+06    (scientific)
 Wuethrich | Benjamin |   +1345 326 5181 |  benjamin.wuethrich@gmail.com
   Forrest |     Kara |   +1345 516 1920 |      kara_forrest@hotmail.com
    Aarnau |    Mayra | +34 66 696 55 63 |       mayraaachen@hotmail.com
    Michel |   Tanael | +41 79 374 48 62 |              tanael@gmail.com
    Widler |   Andrea | +41 79 293 29 38 |       andreawidler@bluewin.ch
Amanatidou | Elisabet | +41 76 701 61 28 | elisabet.amanatidou@gmail.com

ch11_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        ifstream ifs(iname.c_str());
        if (!ifs) { error("can't open input file " + iname); }

        cout << "Enter output file name: ";
        string oname;
        cin >> oname;
        ofstream ofs(oname.c_str());
        if (!ofs) { error("can't open output file " + oname); }

        char ch;
        while (ifs.get(ch))
        {
            if (isalpha(ch)) { ch = tolower(ch); }
            ofs << ch;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p01_in.txt
Enter output file name: ch11_p01_out.txt

ls -l ch11_p01*.txt
-rw-r--r-- 1 weiyayun weiyayun 14 Dec  1 07:03 ch11_p01_in.txt
-rw-r--r-- 1 weiyayun weiyayun 14 Dec  1 07:03 ch11_p01_out.txt

cat ch11_p01_in.txt
HELLO, World!

cat ch11_p01_out.txt
hello, world!

ch11_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

bool isvowel(char ch)
{
    ch = tolower(ch);
    return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u';
}

bool allvowels(const string &s)
{
    for (int i = 0; i < s.size(); ++i)
    {
        if (!isvowel(s[i]))
        {
            return false;
        }
    }
    return true;
}

void disemvowel(string &s)
{
    string s_novow;
    for (int i = 0; i < s.size(); ++i)
    {
        if (!isvowel(s[i]))
        {
            s_novow.push_back(s[i]);
        }
    }
    s = s_novow;
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        ifstream ifs(iname.c_str());
        if (!ifs)
        {
            error("can't open input file " + iname);
        }

        cout << "Enter output file name: ";
        string oname;
        cin >> oname;
        ofstream ofs(oname.c_str());
        if (!ofs)
        {
            error("can't open output file " + oname);
        }

        char ch;
        string s;
        while (ifs.get(ch))
        {
            if (isgraph(ch))
            {
                ifs.unget();
                ifs >> s;
                if (allvowels(s))
                {
                    if ( !( ifs.get(ch) ) )
                    {
                        break;
                    }
                }
                else
                {
                    disemvowel(s);
                    ofs << s;
                }
            }
            else
            {
                ofs << ch;
            }
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p02_in.txt
Enter output file name: ch11_p02_out.txt

cat ch11_p02_in.txt
Once upon a time!

cat ch11_p02_out.txt
nc pn tm!

ch11_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

enum num_format
{
    decimal, octal, hexadecimal
};

ostream &operator<<(ostream &os, num_format nf)
{
    switch (nf)
    {
    case decimal:
        return os << "decimal\t";
    case octal:
        return os << "octal\t";
    case hexadecimal:
        return os << "hexadecimal";
    default:
        error("illegal value of number_format");
    }
}

void printnum(int n, num_format nf)
{
    cout << showbase;
    switch (nf)
    {
    case decimal:
        cout << dec << setw(12) << n;
        break;
    case octal:
        cout << oct << setw(12) << n;
        break;
    case hexadecimal:
        cout << hex << setw(12) << n;
        break;
    }
    cout << ' ' << nf << "\tconverts to " << dec << setw(12) << n << ' ' << decimal << endl;
}

int main()
{
    try
    {
        cout << "Enter space-separated integers in decimal, octal or hexadecimal notation" << endl
             << "(using 0 and 0x prefixes), any letter to finish:" << endl;
        int n = 0;
        char ch;
        while (cin >> ch)
        {
            if (ch == '0')
            {
                if (cin.get(ch))
                {
                    if (ch == 'x')
                    {
                        cin >> hex >> n;
                        printnum(n, hexadecimal);
                    }
                    else if (isdigit(ch))
                    {
                        cin.unget();
                        cin >> oct >> n;
                        printnum(n, octal);
                    }
                    else
                    {
                        cin.unget();
                        printnum(0, octal);
                    }
                }
                else
                {
                    printnum(0, octal);
                    break;
                }
            }
            else if (isdigit(ch))
            {
                cin.unget();
                cin >> dec >> n;
                printnum(n, decimal);
            }
            else
            {
                break;
            }
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter space-separated integers in decimal, octal or hexadecimal notation
(using 0 and 0x prefixes), any letter to finish:
0x43 0123 65 q
        0x43 hexadecimal        converts to           67 decimal
        0123 octal              converts to           83 decimal
          65 decimal            converts to           65 decimal

ch11_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

void char_class(const string &s)
{
    for (int i = 0; i < s.size(); ++i)
    {
        cout << s[i];
        if (isspace(s[i])) cout << " isspace";
        if (isalpha(s[i])) cout << " isalpha";
        if (isdigit(s[i])) cout << " isdigit";
        if (isxdigit(s[i])) cout << " isxdigit";
        if (isupper(s[i])) cout << " isupper";
        if (islower(s[i])) cout << " islower";
        if (isalnum(s[i])) cout << " isalnum";
        if (iscntrl(s[i])) cout << " iscntrl";
        if (ispunct(s[i])) cout << " ispunct";
        if (isprint(s[i])) cout << " isprint";
        if (isgraph(s[i])) cout << " isgraph";
        cout << endl;
    }
}

int main()
{
    try
    {
        cout << "Enter strings:\n";
        string s;
        while (cin >> s)
        {
            char_class(s);
            cout << endl;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter strings:
Hello, World! 123abc
H isalpha isupper isalnum isprint isgraph
e isalpha isxdigit islower isalnum isprint isgraph
l isalpha islower isalnum isprint isgraph
l isalpha islower isalnum isprint isgraph
o isalpha islower isalnum isprint isgraph
, ispunct isprint isgraph

W isalpha isupper isalnum isprint isgraph
o isalpha islower isalnum isprint isgraph
r isalpha islower isalnum isprint isgraph
l isalpha islower isalnum isprint isgraph
d isalpha isxdigit islower isalnum isprint isgraph
! ispunct isprint isgraph

1 isdigit isxdigit isalnum isprint isgraph
2 isdigit isxdigit isalnum isprint isgraph
3 isdigit isxdigit isalnum isprint isgraph
a isalpha isxdigit islower isalnum isprint isgraph
b isalpha isxdigit islower isalnum isprint isgraph
c isalpha isxdigit islower isalnum isprint isgraph

ch11_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        ifstream ifs(iname.c_str());
        if (!ifs) { error("can't open input file " + iname); }

        cout << "Enter output file name: ";
        string oname;
        cin >> oname;
        ofstream ofs(oname.c_str());
        if (!ofs) { error("can't open output file " + oname); }

        char ch;
        while (ifs.get(ch))
        {
            if (ispunct(ch)) { ch = ' '; }
            ofs << ch;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p05_in.txt
Enter output file name: ch11_p05_out.txt

cat ch11_p05_in.txt
Hello, World! 123;abc

cat ch11_p05_out.txt
Hello  World  123 abc

ch11_p06a.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}


class Punct_stream
{
public:
    Punct_stream(istream &is) : source(is), sensitive(true) { }

    void whitespace(const string &s)
    {
        white = s;
    }
    void add_white(char c)
    {
        white += c;
    }
    bool is_whitespace(char c);
    void case_sensitive(bool b)
    {
        sensitive = b;
    }
    bool is_case_sensitive()
    {
        return sensitive;
    }

    Punct_stream &operator>>(string &s);
    operator bool();
private:
    istream &source;
    istringstream buffer;
    string white;
    bool sensitive;
};

bool Punct_stream::is_whitespace(char c)
{
    for (int i = 0; i < white.size(); ++i)
    {
        if (c == white[i])
        {
            return true;
        }
    }
    return false;
}

Punct_stream::operator bool()
{
    return ( (buffer) || (source) );
}

Punct_stream &Punct_stream::operator>>(string &s)
{
    while (!(buffer >> s))
    {
        string line;

        if ( !( getline(source, line, '\n') ) )
        {
            return *this;
        }
        buffer.clear();

        for (int i = 0; i < line.size(); ++i)
        {
            if (is_whitespace(line[i]))
            {
                line[i] = ' ';
            }
            else if (!sensitive)
            {
                line[i] = tolower(line[i]);
            }
        }
        buffer.str(line);
    }
    return *this;
}

int main()
{
    try
    {
        Punct_stream ps(cin);
        ps.whitespace(";:,.?!()\"{}<>/&$@#%^*|~");
        ps.case_sensitive(false);

        cout << "please enter words\n";
        vector<string> vs;
        string word;
        while (ps >> word)
        {
            vs.push_back(word);
        }

        sort(vs.begin(), vs.end());
        for (int i = 0; i < vs.size(); ++i)
        {
            if (i == 0 || vs[i] != vs[i - 1])
            {
                cout << vs[i] << endl;
            }
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
please enter words
Peter Smith Mike Pence Hello World
Water Flower Sun Apple Orange
apple
flower
hello
mike
orange
pence
peter
smith
sun
water
world

ch11_p06b.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

void to_lowercase(string &s)
{
    if (s.size() == 0) { return; }
    for (int i = 0; i < s.size(); ++i)
    {
        s[i] = tolower(s[i]);
    }
}

void remove_punct(string &s)
{
    if (s.size() == 0) { return; }
    for (int i = 0; i < s.size(); ++i)
    {
        if (ispunct(s[i]) && s[i] != '\'' && s[i] != '-') { s[i] = ' '; }
    }
}

void remove_hyphen(string &s)
{
    if (s.size() == 0) { return; }
    if (s.size() >= 2 && s[0] == '-' && s[1] == ' ') { s[0] = ' '; }
    if (s.size() >= 2 && s[s.size() - 1] == '-' && s[s.size() - 2] == ' ') { s[s.size() - 1] = ' '; }
    for (int i = 1; i < s.size() - 1; ++i)
    {
        if (s[i] == '-' && s[i - 1] == ' ' && s[i + 1] == ' ') { s[i] = ' '; }
        if (s[i] == '-' && s[i + 1] == '-')
        {
            s[i] = ' ';
            s[i + 1] = ' ';
            ++i;
        }
    }
}

void expand_aux(string &s)
{
    if (s.size() == 0) { return; }
    istringstream is(s);
    string word;
    string s_exp;
    ostringstream os(s_exp);
    while (is >> word)
    {
        if (word.size() >= 5
                 && word[word.size() - 3] == 'n'
                 && word[word.size() - 2] == '\''
                 && word[word.size() - 1] == 't')
        {
            for (int i = 0; i < word.size() - 3; ++i)
            {
                os << word[i];
            }
            os << " not";
        }
        else { os << word; }
        os << ' ';
    }
    s = os.str();
}

void convert_file(const string &iname, const string &oname)
{
    ifstream ifs(iname.c_str());
    if (!ifs) { error("can't open input file " + iname); }
    ofstream ofs(oname.c_str());
    if (!ofs) { error("can't open output file " + oname); }

    string s;
    while (getline(ifs, s, '\n'))
    {
        to_lowercase(s);
        remove_punct(s);
        remove_hyphen(s);
        expand_aux(s);
        ofs << s << endl;
    }
}

void build_dict(const string &iname, const string &oname)
{
    ifstream ifs(iname.c_str());
    if (!ifs) { error("can't open input file " + iname); }
    ofstream ofs(oname.c_str());
    if (!ofs) { error("can't open output file " + oname); }

    vector<string> vs;
    string word;
    while (ifs >> word)
    {
        vs.push_back(word);
    }

    sort(vs.begin(), vs.end());
    for (int i = 0; i < vs.size(); ++i)
    {
        if (i == 0 || vs[i] != vs[i - 1]) { ofs << vs[i] << endl; }
    }
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        cout << "Enter output file name: ";
        string oname;
        cin >> oname;
        convert_file(iname, oname);
        cout << "Enter name for dictionary file: ";
        string dname;
        cin >> dname;
        build_dict(oname, dname);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p06b_in.txt
Enter output file name: ch11_p06b_out.txt
Enter name for dictionary file: ch11_p06b_dict.txt

cat ch11_p06b_in.txt
Hello, World!
Peter - don't use the as-if rule.

cat ch11_p06b_out.txt
hello world
peter do not use the as-if rule

cat ch11_p06b_dict.txt
as-if
do
hello
not
peter
rule
the
use
world

ch11_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

string bin_file = "ch11_p08.bin";

void to_binary(const string &s)
{
    ifstream ifs(s.c_str());
    if (!ifs) { error("can't open input file " + s); }
    ofstream ofs(bin_file.c_str(), std::ios_base::binary);
    if (!ofs) { error("can't open output file " + bin_file); }

    char ch;
    while (ifs.get(ch))
    {
        ofs.write(&ch, sizeof(char));
    }
}

void from_binary(const string &s)
{
    ifstream ifs(bin_file.c_str(), std::ios_base::binary);
    if (!ifs) { error("can't open input file " + bin_file); }
    ofstream ofs(s.c_str());
    if (!ofs) { error("can't open output file " + s); }

    char ch;
    while (ifs.read(&ch, sizeof(char)))
    {
        ofs << ch;
    }
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        to_binary(iname);

        cout << "Enter output file name: ";
        string oname;
        cin >> oname;
        from_binary(oname);

        cout << "Done!\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p08.cpp
Enter output file name: ch11_p08.txt
Done!

ls -l ch11_p08.???
-rw-r--r-- 1 weiyayun weiyayun 3381 Dec  1 12:40 ch11_p08.bin
-rw-r--r-- 1 weiyayun weiyayun 3381 Dec  1 12:39 ch11_p08.cpp
-rw-r--r-- 1 weiyayun weiyayun 3381 Dec  1 12:40 ch11_p08.txt

ch11_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

vector<string> split(const string &s)
{
    istringstream is(s);
    string ss;
    vector<string> substrings;
    while (is >> ss) { substrings.push_back(ss); }
    return substrings;
}

void print_vector(const vector<string> & vs)
{
    for (int i = 0; i < vs.size(); ++i)
    {
        cout << vs[i] << endl;
    }
}

int main()
{
    try
    {
        cout << "Enter a few words: ";
        string s;
        while (getline(cin, s, '\n') && s != "")
        {
            vector<string> substrings = split(s);
            cout << "\nYou entered:\n";
            print_vector(substrings);
            cout << "\nEnter a few words: ";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter a few words: Hello World Peter Smith Mike Pence Water Flower

You entered:
Hello
World
Peter
Smith
Mike
Pence
Water
Flower

Enter a few words:

ch11_p10.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

vector<string> split(const string &s)
{
    istringstream is(s);
    string ss;
    vector<string> substrings;
    while (is >> ss) { substrings.push_back(ss); }
    return substrings;
}

bool contains(const string &s, char ch)
{
    for (int i = 0; i < s.size(); ++i)
    {
        if (s[i] == ch) { return true; }
    }
    return false;
}

vector<string> split(const string &s, const string &w)
{
    string ss = s;
    for (int i = 0; i < ss.size(); ++i)
    {
        if (contains(w, ss[i])) { ss[i] = ' '; }
    }
    return split(ss);
}

void print_vector(const vector<string> &vs)
{
    for (int i = 0; i < vs.size(); ++i)
    {
        cout << vs[i] << endl;
    }
}

int main()
{
    try
    {
        cout << "Enter string with separation characters: ";
        string w;
        getline(cin, w, '\n');
        cout << "Enter a few words: ";
        string s;
        while (getline(cin, s, '\n') && s != "")
        {
            vector<string> substrings = split(s, w);
            cout << "\nYou entered:\n";
            print_vector(substrings);
            cout << "\nEnter a few words: ";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter string with separation characters: ,;.!?
Enter a few words: Hello,World!abc;123.efg?hij

You entered:
Hello
World
abc
123
efg
hij

Enter a few words:

ch11_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        ifstream ifs(iname.c_str());
        if (!ifs) { error("can't open input file " + iname); }
        cout << "Enter output file name: ";
        string oname;
        cin >> oname;
        ofstream ofs(oname.c_str());
        if (!ofs) { error("can't open output file " + oname); }

        string contents;
        char ch;
        while (ifs.get(ch))
        {
            contents.push_back(ch);
        }

        for (int i = contents.size() - 1; i >= 0; --i)
        {
            ofs << contents[i];
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p11_in.txt
Enter output file name: ch11_p11_out.txt

cat ch11_p11_in.txt
Hello,World!

cat ch11_p11_out.txt

!dlroW,olleH

ch11_p12.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        ifstream ifs(iname.c_str());
        if (!ifs) { error("can't open input file " + iname); }
        cout << "Enter output file name: ";
        string oname;
        cin >> oname;
        ofstream ofs(oname.c_str());
        if (!ofs) { error("can't open output file " + oname); }

        vector<string> contents;
        string s;
        while (ifs >> s)
        {
            contents.push_back(s);
        }

        for (int i = contents.size() - 1; i >= 0; --i)
        {
            ofs << contents[i] << endl;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p06b_dict.txt
Enter output file name: ch11_p12_out.txt

cat ch11_p06b_dict.txt
as-if
do
hello
not
peter
rule
the
use
world

cat ch11_p12_out.txt
world
use
the
rule
peter
not
hello
do
as-if

ch11_p13.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        ifstream ifs(iname.c_str());
        if (!ifs) { error("can't open input file " + iname); }

        char ch;
        int space = 0;
        int alpha = 0;
        int digit = 0;
        int xdigit = 0;
        int upper = 0;
        int lower = 0;
        int alnum = 0;
        int cntrl = 0;
        int punct = 0;
        int print = 0;
        int graph = 0;

        while (ifs.get(ch))
        {
            if (isspace(ch)) ++space;
            if (isalpha(ch)) ++alpha;
            if (isdigit(ch)) ++digit;
            if (isxdigit(ch)) ++xdigit;
            if (isupper(ch)) ++upper;
            if (islower(ch)) ++lower;
            if (isalnum(ch)) ++alnum;
            if (iscntrl(ch)) ++cntrl;
            if (ispunct(ch)) ++punct;
            if (isprint(ch)) ++print;
            if (isgraph(ch)) ++graph;
        }

        cout << "Analysis:\n";
        cout << "isspace:\t" << space << endl;
        cout << "isalpha:\t" << alpha << endl;
        cout << "isdigit:\t" << digit << endl;
        cout << "isxdigit:\t" << xdigit << endl;
        cout << "isupper:\t" << upper << endl;
        cout << "islower:\t" << lower << endl;
        cout << "isalnum:\t" << alnum << endl;
        cout << "iscntrl:\t" << cntrl << endl;
        cout << "ispunct:\t" << punct << endl;
        cout << "isprint:\t" << print << endl;
        cout << "isgraph:\t" << graph << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p13_in.txt
Analysis:
isspace:        4
isalpha:        16
isdigit:        3
isxdigit:       10
isupper:        2
islower:        14
isalnum:        19
iscntrl:        1
ispunct:        3
isprint:        25
isgraph:        22

cat ch11_p13_in.txt
Hello, World! 123abc efg?

ch11_p14.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        ifstream ifs(iname.c_str());
        if (!ifs) { error("can't open input file " + iname); }

        double d;
        vector<double> nums;
        while (ifs >> d)
        {
            nums.push_back(d);
        }

        cout << scientific << setprecision(8);
        int i;
        for (i = 0; i < nums.size(); ++i)
        {
            cout << setw(20) << nums[i];
            if (i % 4 == 3) { cout << endl; }
        }
        if (i % 4 != 0) { cout << endl; }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p14_in.txt
      1.23000000e+00      1.23400000e+00      1.23456000e+01      1.23456780e+02
      1.23456789e+04

cat ch11_p14_in.txt
1.23
1.234
12.3456
123.45678
12345.6789

ch11_p15.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        ifstream ifs(iname.c_str());
        if (!ifs)
        {
            error("can't open input file " + iname);
        }

        int n;
        vector<int> numbers;
        while (ifs >> n)
        {
            numbers.push_back(n);
        }

        sort(numbers.begin(), numbers.end());
        int counter = 1;
        int i = 0;
        for (i = 0; i < numbers.size(); ++i)
        {
            if (i == 0 || numbers[i] != numbers[i - 1])
            {
                if (counter > 1)
                {
                    cout << "\t" << counter << endl;
                }
                else if (i > 0)
                {
                    cout << endl;
                }
                counter = 1;
                cout << numbers[i];
            }
            else
            {
                ++counter;
            }
        }
        if (counter > 1)
        {
            cout << "\t" << counter << endl;
        }
        else if (i > 0)
        {
            cout << endl;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p15_in.txt
123     3
345
456
567
789     2

cat ch11_p15_in.txt
123
456
789
567
123
789
123
345

第三部分 数据Y构和算法
第17章 向量和自由空间
17.1 介绍
17.2 向量的基本知识.
17.3 内存、地址和指针
17.3.1 运算符sizeof
17.4 自由空间和指针
17.4.1 自由空间分配
17.4.2 通过指针访问数据
17.4.3 指针范围
17.4.4 初始化
17.4.5 空指针
17.4.6 自由空间释放
17.5 析构函数
17.5.1 生成的析构函数
17.5.2 析构函数和自由空间
17.6 访问向量元素
17.7 指向类对象的指针
17.8 类型混用：无类型指针和指针类型转换
17.9 指针和引用
17.9.1 指针参数和引用参数
17.9.2 指针、引用和继承
17.9.3 实例：列表
17.9.4 列表的操作
17.9.5 列表的使用
17.10 this指针
17.10.1 关于Link使用的更多讨论
ch17_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

void print_array(ostream &os, int *a, int n)
{
    for (int i = 0; i < n; ++i)
    {
        os << a[i] << "\n";
    }
}

void print_vector(ostream &os, const vector<int> &v)
{
    for (int i = 0; i < v.size(); ++i)
    {
        os << v[i] << "\n";
    }
}

int main()
{
    try
    {
        int *ip = new int[10];

        cout << "*** 2 ***\n";
        for (int i = 0; i < 10; ++i)
        {
            cout << ip[i] << "\n";
        }

        delete[] ip;

        cout << "*** 5 ***\n";
        int *ip2 = new int[10];

        for (int i = 0; i < 10; ++i)
        {
            ip2[i] = 100 + i;
        }
        print_array(cout, ip2, 10);

        delete[] ip2;

        cout << "*** 6 ***\n";
        int *ip3 = new int[11];

        for (int i = 0; i < 11; ++i)
        {
            ip3[i] = 100 + i;
        }
        print_array(cout, ip3, 11);

        delete[] ip3;

        cout << "*** 8 ***\n";
        int *ip4 = new int[20];

        for (int i = 0; i < 20; ++i)
        {
            ip4[i] = 100 + i;
        }
        print_array(cout, ip4, 20);

        delete[] ip4;

        cout << "*** 10 ***\n";
        vector<int> v;
        for (int i = 0; i < 10; ++i)
        {
            v.push_back(100 + i);
        }
        print_vector(cout, v);

        cout << "\n";
        vector<int> v2;
        for (int i = 0; i < 11; ++i)
        {
            v2.push_back(100 + i);
        }
        print_vector(cout, v2);

        cout << "\n";
        vector<int> v3;
        for (int i = 0; i < 20; ++i)
        {
            v3.push_back(100 + i);
        }
        print_vector(cout, v3);


        int i1 = 7;
        int *p1 = &i1;

        cout << "*** 2 ***\n";
        cout << "p1: " << p1 << "\n";
        cout << "*p1: " << *p1 << "\n";

        int *p2 = new int[7];
        for (int i = 0; i < 7; ++i)
        {
            p2[i] = pow(2, i);
        }

        cout << "*** 4 ***\n";
        cout << "p2: " << p2 << "\n";
        cout << "print_array(cout, p2, 7):\n";
        print_array(cout, p2, 7);

        int *p3 = p2;

        p2 = p1;

        p2 = p3;

        cout << "*** 8 ***\n";
        cout << "p1: " << p1 << "\n";
        cout << "*p1: " << *p1 << "\n";
        cout << "p2: " << p2 << "\n";
        cout << "*p2: " << *p2 << "\n";

        delete[] p2;
        p3 = nullptr;

        p1 = new int[10];
        for (int i = 0; i < 10; ++i)
        {
            p1[i] = pow(2, i);
         }

        p2 = new int[10];

        cout << "*** 12 ***\n";
        for (int i = 0; i < 10; ++i)
        {
            p2[i] = p1[i];
        }
        print_array(cout, p2, 10);
       
       delete [] p1;
       delete [] p2;

        cout << "*** 13 ***\n";
        vector<int> vec1;
        for (int i = 0; i < 10; ++i)
        {
            vec1.push_back(pow(2, i));
        }
        vector<int> vec2;
        for (int i = 0; i < vec1.size(); ++i)
        {
            vec2.push_back(vec1[i]);
        }
        print_vector(cout, vec2);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
*** 2 ***
0
0
0
0
0
0
0
0
0
0
*** 5 ***
100
101
102
103
104
105
106
107
108
109
*** 6 ***
100
101
102
103
104
105
106
107
108
109
110
*** 8 ***
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
*** 10 ***
100
101
102
103
104
105
106
107
108
109

100
101
102
103
104
105
106
107
108
109
110

100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
*** 2 ***
p1: 0x7ffd6af48e5c
*p1: 7
*** 4 ***
p2: 0x55d63553feb0
print_array(cout, p2, 7):
1
2
4
8
16
32
64
*** 8 ***
p1: 0x7ffd6af48e5c
*p1: 7
p2: 0x55d63553feb0
*p2: 1
*** 12 ***
1
2
4
8
16
32
64
128
256
512
*** 13 ***
1
2
4
8
16
32
64
128
256
512

ch17_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

long ptr_to_long(void *ptr)
{
    ostringstream oss;
    oss << ptr;
    istringstream iss(oss.str());
    long address;
    iss >> hex >> address;
    if (!iss) { error("problem reading address"); }
    return address;
}

struct X
{
    int a, b, c;
};

struct V
{
    int a, b, c;
    virtual void f() { }
};

int main()
{
    try
    {
        cout << "Output format of a pointer:\n";
        int *pi = new int(0);
        cout << "pi = " << pi << "\n";
        cout << "*pi = " << *pi << "\n";
        cout << "&pi[1] = " << &pi[1] << "\n";
        delete pi;

        cout << "\nNumber of bytes of different types:\n";
        pi = new int[2];
        pi[0] = 0;
        pi[1] = 0;
        int var_size = ptr_to_long(&pi[1]) - ptr_to_long(pi);
        cout << "int: " << &pi[1] << " - " << pi << " = " << var_size << " bytes.\n";
        cout << "sizeof(int): " << sizeof(int) << "\n";
        delete[] pi;

        char *pc = new char[2];
        pc[0] = 0;
        pc[1] = 0;
        var_size = ptr_to_long(&pc[1]) - ptr_to_long(pc);
        cout << "char: " << (void *)&pc[1] << " - " << (void *)pc << " = " << var_size << " bytes.\n";
        cout << "sizeof(char): " << sizeof(char) << "\n";
        delete[] pc;

        double *pd = new double[2];
        pd[0] = 0;
        pd[1] = 0;
        var_size = ptr_to_long(&pd[1]) - ptr_to_long(pd);
        cout << "double: " << &pd[1] << " - " << pd << " = " << var_size << " bytes.\n";
        cout << "sizeof(double): " << sizeof(double) << "\n";
        delete[] pd;

        bool *pb = new bool[2];
        pb[0] = 0;
        pb[1] = 0;
        var_size = ptr_to_long(&pb[1]) - ptr_to_long(pb);
        cout << "bool: " << &pb[1] << " - " << pb << " = " << var_size << " bytes.\n";
        cout << "sizeof(bool): " << sizeof(bool) << "\n";
        delete[] pb;

        X *pX = new X[2];
        var_size = ptr_to_long(&pX[1]) - ptr_to_long(pX);
        cout << "struct X: " << &pX[1] << " - " << pX << " = " << var_size << " bytes.\n";
        cout << "sizeof(X): " << sizeof(X) << "\n";

        V *pV = new V[2];
        var_size = ptr_to_long(&pV[1]) - ptr_to_long(pV);
        cout << "struct V: " << &pV[1] << " - " << pV << " = " << var_size << " bytes.\n";
        cout << "sizeof(V): " << sizeof(V) << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Output format of a pointer:
pi = 0x560b284162c0
*pi = 0
&pi[1] = 0x560b284162c4

Number of bytes of different types:
int: 0x560b284162c4 - 0x560b284162c0 = 4 bytes.
sizeof(int): 4
char: 0x560b284162c1 - 0x560b284162c0 = 1 bytes.
sizeof(char): 1
double: 0x560b284162c8 - 0x560b284162c0 = 8 bytes.
sizeof(double): 8
bool: 0x560b284162c1 - 0x560b284162c0 = 1 bytes.
sizeof(bool): 1
struct X: 0x560b284162cc - 0x560b284162c0 = 12 bytes.
sizeof(X): 12
struct V: 0x560b284162f8 - 0x560b284162e0 = 24 bytes.
sizeof(V): 24

ch17_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

void to_lower(char *s)
{
    for (int i = 0; s[i] != '\0'; ++i)
    {
        if (s[i] >= 'A' && s[i] <= 'Z')
        {
            s[i] += ('a' - 'A');
        }
    }
}

void print_array(char *s)
{
    for (int i = 0; s[i] != '\0'; ++i)
    {
        cout << s[i];
    }
}

void test(string &s)
{
    to_lower(&s[0]);
    print_array(&s[0]);
    cout << "\n";
}

int main()
{
    try
    {
        string s;
        while (getline(cin, s, '\n') && s != "")
        {
            test(s);
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Hello, World!
hello, world!
Abc123 Efg
abc123 efg

ch17_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

char *strcopy(const char *s)
{
    if (s == nullptr) { return nullptr; }

    int n = 0;
    while (s[n] != '\0')
    {
        ++n;
    }

    char *pc = new char[n + 1];

    for (int i = 0; i < n; ++i)
    {
        pc[i] = s[i];
    }
    pc[n] = '\0';

    return pc;
}

int main()
{
    try
    {
        string s;
        char *cstr;
        while (getline(cin, s, '\n') && s != "")
        {
            cstr = strcopy(s.c_str());
            cout << cstr << "\n";
            delete[] cstr;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Hello, World! Abc123; Water
Hello, World! Abc123; Water

ch17_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

const char *findx(const char *s, const char *x)
{
    if (x == nullptr) { return nullptr; }
    if (s == nullptr) { return nullptr; }
    for (int i = 0; s[i] != '\0'; ++i)
    {
        if (s[i] == x[0])
        {
            int j = 1;
            for (; x[j] != '\0'; ++j)
            {
                if (s[i + j] == '\0') { return nullptr; }
                if (s[i + j] != x[j]) { break; }
            }
            if (x[j] == '\0') { return &s[i]; }
        }
    }
    return nullptr;
}

int main()
{
    try
    {
        const char *ss = "Does this work with whitespace, too?";
        const char *xx = "work with";
        const char *sub = findx(ss, xx);
        if (!sub) { cout << "Not found!\n"; }
        else { cout << sub << "\n"; }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
work with whitespace, too?

ch17_p06a.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        int i = 0;
        char *pc = new char[8589934592];
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
error: std::bad_alloc

ch17_p06b.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        int i = 0;
        char *pc = new  (std::nothrow) char[8589934592];
        if (pc == nullptr)
        {
            cout << "allocate memory fail.\n";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
allocate memory fail.

ch17_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char ch)
    {
        append(ch);
        return *this;
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

int main()
{
    try
    {
        char ch;
        Str_c s;
        while (cin.get(ch) && ch != '!')
        {
            s += ch;
        }

        cout << s << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Hello, World!123abc Water
Hello, World

ch17_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        char ch;
        string s;
        while (cin.get(ch) && ch != '!')
        {
            s.push_back(ch);
        }
        cout << s << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Hello, World!+?abc123
Hello, World

ch17_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

void f2()
{
    int i3;
    int *ip3 = new int(0);
    cout << &i3  << ", " << ip3 << "\n";
    delete ip3;
}
void f1()
{
    int i2;
    int *ip2 = new int(0);
    cout << &i2  << ", " << ip2 << "\n";
    f2();
    delete ip2;
}
void f()
{
    int i1;
    int *ip1 = new int(0);
    cout << &i1 << ", " << ip1 << "\n";
    f1();
    delete ip1;
}

int main()
{
    try
    {
        cout << "Addresses on stack, Addresses on heap:\n";
        f();
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Addresses on stack, Addresses on heap:
0x7ffdda9ecadc, 0x55c8a52142c0
0x7ffdda9ecaac, 0x55c8a52142e0
0x7ffdda9eca7c, 0x55c8a5214300

ch17_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

class Link
{
public:
    string value;

    Link(const string &v, Link *p = nullptr, Link *s = nullptr) : value(v), prev(p), succ(s) { }

    Link *insert(Link *n);
    Link *add(Link *n);
    Link *erase();
    Link *find(const string &s);
    const Link *find(const string &s) const;

    Link *advance(int n) const;

    Link *next() const
    {
        return succ;
    }
    Link *previous() const
    {
        return prev;
    }
private:
    Link *prev;
    Link *succ;
};

Link *Link::insert(Link *n)
{
    if (n == nullptr) { return n; }
    n->succ = this;
    if (prev != nullptr) { prev->succ = n; }
    n->prev = prev;
    prev = n;
    return n;
}

Link *Link::add(Link *n)
{
    if (n == nullptr) { return n; }
    n->prev = this;
    if (succ != nullptr) { succ->prev = n; }
    n->succ = succ;
    succ = n;
    return n;
}

Link *Link::erase()
{
    if (succ != nullptr) { succ->prev = prev; }
    if (prev != nullptr) { prev->succ = succ; }
    return succ;
}

Link *Link::find(const string &s)
{
    Link *p = this;
    while (p != nullptr)
    {
        if (p->value == s) { return p; }
        p = p->succ;
    }
    return nullptr;
}

const Link *Link::find(const string &s) const
{
    const Link *p = this;
    while (p != nullptr)
    {
        if (p->value == s) { return p; }
        p = p->succ;
    }
    return nullptr;
}

Link *Link::advance(int n) const
{
    Link *p = const_cast<Link *>(this);
    if (0 < n)
    {
        while (n--)
        {
            if (p->succ == nullptr) { return nullptr; }
            p = p->succ;
        }
    }
    else if (n < 0)
    {
        while (n++)
        {
            if (p->prev == nullptr) { return nullptr; }
            p = p->prev;
        }
    }
    return p;
}

void print_all(Link *p)
{
    cout << "{ ";
    while (p != nullptr)
    {
        cout << p->value;
        p = p->next();
        if (p != nullptr) { cout << ", "; }
    }
    cout << " }";
}

void delete_all(Link *p)
{
    while (p != nullptr)
    {
        Link *temp = p->next();
        delete p;
        p = temp;
    }
}


int main()
{
    try
    {
        Link *norse_gods = new Link("Thor");
        norse_gods = norse_gods->insert(new Link("Odin"));
        norse_gods = norse_gods->insert(new Link("Zeus"));
        norse_gods = norse_gods->insert(new Link("Freia"));

        Link *greek_gods = new Link("Hera");
        greek_gods = greek_gods->insert(new Link("Athena"));
        greek_gods = greek_gods->insert(new Link("Mars"));
        greek_gods = greek_gods->insert(new Link("Poseidon"));

        print_all(norse_gods);
        cout << "\n";

        print_all(greek_gods);
        cout << "\n";

        Link *p = greek_gods->find("Mars");
        if (p != nullptr) { p->value = "Ares"; }

        Link *p2 = norse_gods->find("Zeus");
        if (p2 != nullptr)
        {
            if (p2 == norse_gods) { norse_gods = p2->next(); }
            p2->erase();
            greek_gods = greek_gods->add(p2)->advance(-1);
        }

        print_all(norse_gods);
        cout << "\n";

        print_all(greek_gods);
        cout << "\n";

        delete_all(norse_gods);
        delete_all(greek_gods);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
{ Freia, Zeus, Odin, Thor }
{ Poseidon, Mars, Athena, Hera }
{ Freia, Odin, Thor }
{ Poseidon, Zeus, Ares, Athena, Hera }

ch17_p13.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

class God
{
public:
    God(const string &n = "", const string &m = "", const string &v = "", const string &w = "")
        : name(n), mythology(m), vehicle(v), weapon(w) { }
    string name;
    string mythology;
    string vehicle;
    string weapon;
};

ostream &operator<<(ostream &os, const God &g)
{
    os << g.name << ", " << g.mythology << ", ";
    os << g.vehicle << ", " << g.weapon;
    return os;
}

class Link
{
public:
    God value;

    Link(const string &n = "", const string &m = "", const string &v = "",
         const string &w = "", Link *p = nullptr, Link *s = nullptr)
        : value(n, m, v, w), prev(p), succ(s) { }

    Link *insert(Link *n);
    Link *add(Link *n);
    Link *add_ordered(Link *n);
    Link *erase();
    Link *find(const string &s);
    const Link *find(const string &s) const;

    Link *advance(int n);

    Link *next() const
    {
        return succ;
    }
    Link *previous() const
    {
        return prev;
    }
private:
    Link *prev;
    Link *succ;
};

Link *Link::insert(Link *n)
{
    if (n == nullptr)
    {
        return n;
    }
    n->succ = this;
    if (prev != nullptr)
    {
        prev->succ = n;
    }
    n->prev = prev;
    prev = n;
    return n;
}

Link *Link::add(Link *n)
{
    if (n == nullptr)
    {
        return n;
    }
    n->prev = this;
    if (succ != nullptr)
    {
        succ->prev = n;
    }
    n->succ = succ;
    succ = n;
    return n;
}

Link *Link::add_ordered(Link *n)
{
    if (n == nullptr)
    {
        return n;
    }
    if (n->value.name < value.name)
    {
        Link *p = insert(n);
        return p;
    }
    Link *p = this;
    while (n->value.name >= p->value.name)
    {
        if (p->succ == nullptr)
        {
            p->add(n);
            return this;
        }
        p = p->succ;
    }
    p->insert(n);
    return this;
}

Link *Link::erase()
{
    if (succ != nullptr)
    {
        succ->prev = prev;
    }
    if (prev != nullptr)
    {
        prev->succ = succ;
    }
    Link *ret = succ;
    succ = nullptr;
    prev = nullptr;
    return ret;
}

Link *Link::find(const string &s)
{
    Link *p = this;
    while (p != nullptr)
    {
        if (p->value.name == s)
        {
            return p;
        }
        p = p->succ;
    }
    return nullptr;
}

const Link *Link::find(const string &s) const
{
    const Link *p = this;
    while (p != nullptr)
    {
        if (p->value.name == s)
        {
            return p;
        }
        p = p->succ;
    }
    return nullptr;
}

Link *Link::advance(int n)
{
    Link *p = this;
    if (0 < n)
    {
        while (n--)
        {
            if (p->succ == nullptr)
            {
                return nullptr;
            }
            p = p->succ;
        }
    }
    else if (n < 0)
    {
        while (n++)
        {
            if (p->prev == nullptr)
            {
                return nullptr;
            }
            p = p->prev;
        }
    }
    return p;
}

void print_all(Link *p)
{
    while (p != nullptr)
    {
        cout << p->value << endl;
        p = p->next();
    }
}

void delete_all(Link *p)
{
    while (p != nullptr)
    {
        Link *temp = p->next();
        delete p;
        p = temp;
    }
}

Link *extract(Link **l, const string &s)
{
    if ( (*l) == nullptr )
    {
        return nullptr;
    }
    Link *p = (*l)->find(s);
    if (p != nullptr)
    {
        if (p == (*l))
        {
            (*l) = p->next();
        }
        p->erase();
        return p;
    }
    return nullptr;
}

int main()
{
    try
    {
        Link *all_gods = new Link("Thor", "Norse", "Pinzgauer", "Hammer");
        all_gods = all_gods->insert(new Link("Odin", "Norse", "Eight-legged horse", ""));
        all_gods = all_gods->insert(new Link("Zeus", "Greek", "", "Lightning"));
        all_gods = all_gods->insert(new Link("Freia", "Norse", "F-transport", "F-weapon"));
        all_gods = all_gods->insert(new Link("Hera", "Greek", "H-transport", "Spear"));
        all_gods = all_gods->insert(new Link("Athena", "Greek", "A-transport", "A-weapon"));
        all_gods = all_gods->insert(new Link("Mars", "Roman", "M-transport", "M-weapon"));
        all_gods = all_gods->insert(new Link("Poseidon", "Greek", "Seahorse", "Trident"));
        all_gods = all_gods->insert(new Link("Ares", "Greek", "A-transport", "A-weapon"));
        all_gods = all_gods->insert(new Link("Vesuvius", "Roman", "V-transport", "Volcano"));
        all_gods = all_gods->insert(new Link("Bacchus", "Roman", "Stretcher", "Wine goblet"));

        print_all(all_gods);
        cout << endl;

        Link *norse_gods = extract(&all_gods, "Odin");
        norse_gods = norse_gods->add_ordered(extract(&all_gods, "Thor"));
        norse_gods = norse_gods->add_ordered(extract(&all_gods, "Freia"));
        cout << "Norse gods:\n";
        print_all(norse_gods);
        cout << endl;

        Link *greek_gods = extract(&all_gods, "Hera");
        greek_gods = greek_gods->add_ordered(extract(&all_gods, "Athena"));
        greek_gods = greek_gods->add_ordered(extract(&all_gods, "Poseidon"));
        greek_gods = greek_gods->add_ordered(extract(&all_gods, "Zeus"));
        greek_gods = greek_gods->add_ordered(extract(&all_gods, "Ares"));
        cout << "Greek gods:\n";
        print_all(greek_gods);
        cout << endl;

        Link *roman_gods = extract(&all_gods, "Mars");
        roman_gods = roman_gods->add_ordered(extract(&all_gods, "Vesuvius"));
        roman_gods = roman_gods->add_ordered(extract(&all_gods, "Bacchus"));
        cout << "Roman gods:\n";
        print_all(roman_gods);
        cout << endl;

        delete_all(norse_gods);
        delete_all(greek_gods);
        delete_all(roman_gods);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Bacchus, Roman, Stretcher, Wine goblet
Vesuvius, Roman, V-transport, Volcano
Ares, Greek, A-transport, A-weapon
Poseidon, Greek, Seahorse, Trident
Mars, Roman, M-transport, M-weapon
Athena, Greek, A-transport, A-weapon
Hera, Greek, H-transport, Spear
Freia, Norse, F-transport, F-weapon
Zeus, Greek, , Lightning
Odin, Norse, Eight-legged horse,
Thor, Norse, Pinzgauer, Hammer

Norse gods:
Freia, Norse, F-transport, F-weapon
Odin, Norse, Eight-legged horse,
Thor, Norse, Pinzgauer, Hammer

Greek gods:
Ares, Greek, A-transport, A-weapon
Athena, Greek, A-transport, A-weapon
Hera, Greek, H-transport, Spear
Poseidon, Greek, Seahorse, Trident
Zeus, Greek, , Lightning

Roman gods:
Bacchus, Roman, Stretcher, Wine goblet
Mars, Roman, M-transport, M-weapon
Vesuvius, Roman, V-transport, Volcano

ch17_p14.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

class List;

class Link
{
public:
    string value;

    Link(const string &v = "", Link *s = nullptr) : value(v), succ(s) { }

    Link *insert(List &l, Link *n);
    Link *add(List &l, Link *n);
    Link *erase(List &l);
    Link *find(const List &l, const string &s);
    const Link *find(const List &l, const string &s) const;

    Link *advance(int n);

    Link *next() const
    {
        return succ;
    }
private:
    Link *succ;
};

class List
{
public:
    List() : first_link(nullptr) { }
    List(Link *l) : first_link(l) { }
    Link *first_link;
};

Link *Link::insert(List &l, Link *n)
{
    if (n == nullptr)
    {
        return n;
    }
    n->succ = this;
    if (l.first_link == this)
    {
        l.first_link = n;
        return n;
    }
    Link *p = l.first_link;
    while (p->succ != this)
    {
        p = p->succ;
    }
    p->succ = n;
    return n;
}

Link *Link::add(List &l, Link *n)
{
    if (n == nullptr)
    {
        return n;
    }
    n->succ = succ;
    succ = n;
    return n;
}

Link *Link::erase(List &l)
{
    if (l.first_link == this)
    {
        l.first_link = succ;
    }
    else
    {
        Link *p = l.first_link;
        while (p->succ != this)
        {
            p = p->succ;
        }
        p->succ = succ;
    }
    Link *ret = succ;
    succ = nullptr;
    return ret;
}

Link *Link::find(const List &l, const string &s)
{
    Link *p = l.first_link;
    while (p != nullptr)
    {
        if (p->value == s)
        {
            return p;
        }
        p = p->succ;
    }
    return nullptr;
}

const Link *Link::find(const List &l, const string &s) const
{
    const Link *p = l.first_link;
    while (p != nullptr)
    {
        if (p->value == s)
        {
            return p;
        }
        p = p->succ;
    }
    return nullptr;
}

Link *Link::advance(int n)
{
    Link *p = this;
    if (0 <= n)
    {
        while (n--)
        {
            if (p->succ == nullptr)
            {
                return nullptr;
            }
            p = p->succ;
        }
    }
    else
    {
        error("must advance by a number >= 0");
    }
    return p;
}

void print_all(const List &l)
{
    cout << "{ ";
    Link *p = l.first_link;
    while (p != nullptr)
    {
        cout << p->value;
        p = p->next();
        if (p != nullptr)
        {
            cout << ", ";
        }
    }
    cout << " }";
}

void delete_all(List &l)
{
    Link *p = l.first_link;
    while (p != nullptr)
    {
        Link *temp = p->next();
        delete p;
        p = temp;
    }
    l.first_link = nullptr;
}

int main()
{
    try
    {
        Link *norse_gods = new Link("Thor");
        List n_gods(norse_gods);
        norse_gods = norse_gods->insert(n_gods, new Link("Odin"));
        norse_gods = norse_gods->insert(n_gods, new Link("Zeus"));
        norse_gods = norse_gods->insert(n_gods, new Link("Freia"));

        Link *greek_gods = new Link("Hera");
        List g_gods(greek_gods);
        greek_gods = greek_gods->insert(g_gods, new Link("Athena"));
        greek_gods = greek_gods->insert(g_gods, new Link("Mars"));
        greek_gods = greek_gods->insert(g_gods, new Link("Poseidon"));

        print_all(n_gods);
        cout << "\n";

        print_all(g_gods);
        cout << "\n";

        Link *p = greek_gods->find(g_gods, "Mars");
        if (p != nullptr)
        {
            p->value = "Ares";
        }

        Link *p2 = norse_gods->find(n_gods, "Zeus");
        if (p2 != nullptr)
        {
            if (p2 == norse_gods)
            {
                norse_gods = p2->next();
            }
            p2->erase(n_gods);
            greek_gods->add(g_gods, p2);
            greek_gods = g_gods.first_link;
        }

        print_all(n_gods);
        cout << "\n";

        print_all(g_gods);
        cout << "\n";

        delete_all(n_gods);
        delete_all(g_gods);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
{ Freia, Zeus, Odin, Thor }
{ Poseidon, Mars, Athena, Hera }
{ Freia, Odin, Thor }
{ Poseidon, Zeus, Ares, Athena, Hera }

第18章 向量和数组
18.1 介绍
18.2 拷贝
18.2.1 拷贝构造函数
18.2.2 拷贝赋值
18.2.3 拷贝术语
18.3 必要的操作
18.3.1 显示构造函数
18.3.2 调试构造函数与析构函数
18.4 访问向量元素
18.4.1 对const对象重载运算符
18.5 数组
18.5.1 指向数组元素的指针
18.5.2 指针和数组
18.5.3 数组初始化
18.5.4 指针问题
18.6 实例：回文
18.6.1 使用string实现回文
18.6.2 使用数组实现回文
18.6.3 使用指针实现回文
ch18_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

const int gas = 10;
int ga[gas] = { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 };

void print_array(const int array[], int n)
{
    for (int i = 0; i < n; ++i)
    {
        cout << array[i] << " ";
    }
}

void f(int array[], int n)
{
    const int las = 10;
    int la[las];
    for (int i = 0; i < las; ++i)
    {
        la[i] = ga[i];
    }
    print_array(la, las);
    cout << "\n";
    int *p = new int[n];
    for (int i = 0; i < n; ++i)
    {
        p[i] = array[i];
    }
    print_array(p, n);
    cout << "\n";
    delete[] p;
}

int main()
{
    try
    {
        f(ga, gas);
        const int las = 10;
        int aa[las] = { 1 };
        for (int i = 1; i < las; ++i)
        {
            aa[i] = aa[i - 1] * (i + 1);
        }
        f(aa, las);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
1 2 4 8 16 32 64 128 256 512
1 2 4 8 16 32 64 128 256 512
1 2 4 8 16 32 64 128 256 512
1 2 6 24 120 720 5040 40320 362880 3628800

ch18_d02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

vector<int> gv = { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 };

void f(const vector<int> &v)
{
    vector<int> lv(gv);
    print_vector(lv, cout);
    vector<int> lv2(v);
    print_vector(lv2, cout);
}

int main()
{
    try
    {
        f(gv);
        vector<int> vv;
        vv.push_back(1);
        for (int i = 1; i < 10; ++i)
        {
            vv.push_back((i + 1)*vv[i - 1]);
        }
        f(vv);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
1, 2, 4, 8, 16, 32, 64, 128, 256, 512
1, 2, 4, 8, 16, 32, 64, 128, 256, 512
1, 2, 4, 8, 16, 32, 64, 128, 256, 512
1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800

ch18_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

char *strdupl(const char *s)
{
    if (s == nullptr)
    {
        return nullptr;
    }

    int n = 0;
    const char *p = s;
    while (*p != '\0')
    {
        ++n;
        p++;
    }

    char *s_cpy = new char[n + 1];

    char *s_cpy_ptr = s_cpy;
    while (*s != '\0')
    {
        *s_cpy_ptr++ = *s++;
    }
    *s_cpy_ptr = '\0';
    return s_cpy;
}


const char *findx(const char *s, const char *x)
{
    if (x == nullptr || *x == '\0')
    {
        return nullptr;
    }
    if (s == nullptr || *s == '\0')
    {
        return nullptr;
    }
    for (int i = 0; * (s + i) != '\0'; ++i)
    {
        if (*(s + i) == *x)
        {
            int j = 1;
            for (; * (x + j) != '\0'; ++j)
            {
                if (*(s + i + j) == '\0')
                {
                    return nullptr;
                }
                if (*(s + i + j) != *(x + j))
                {
                    break;
                }
            }
            if (*(x + j) == '\0')
            {
                return (s + i);
            }
        }
    }
    return nullptr;
}

int strcomp(const char *s1, const char *s2)
{
    if (s1 == nullptr || s2 == nullptr)
    {
        error("Null pointer sent to strcomp()");
    }
    for (int i = 0; ; ++i)
    {
        if (*(s1 + i) == '\0' && *(s2 + i) != '\0')
        {
            return -1;
        }
        else if (*(s1 + i) == '\0' && *(s2 + i) == '\0')
        {
            return 0;
        }
        else if (*(s1 + i) != '\0' && *(s2 + i) == '\0')
        {
            return 1;
        }
        else
        {
            if (*(s1 + i) < * (s2 + i))
            {
                return -1;
            }
            else if (*(s1 + i) > *(s2 + i))
            {
                return 1;
            }
        }
    }

    return 0;
}

void print_str(const char *s)
{
    if (s == nullptr)
    {
        error("Cannot print from null pointer");
    }
    while (*s != '\0')
    {
        cout << *s++;
    }
}

int main()
{
    try
    {
        char s[] = "Test";
        char *s_cpy = strdupl(s);
        print_str(s_cpy);
        cout << "\n";
        delete[] s_cpy;

        char s2[] = "This is a test phrase";
        char x[] = "test";
        cout << "s: " << s2 << "\n";
        cout << "x: " << x << "\n";
        print_str(findx(s2, x));
        cout << "\n";

        string a;
        string b;
        while (cin >> a && cin >> b)
        {
            int comp = strcomp(a.c_str(), b.c_str());
            switch (comp)
            {
            case -1:
                cout << a << " < " << b << "\n";
                break;
            case 0:
                cout << a << " == " << b << "\n";
                break;
            case 1:
                cout << a << " > " << b << "\n";
                break;
            default:
                error("invalid result returned by strcmp");
                break;
            }
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Test
s: This is a test phrase
x: test
test phrase
Hello World
Hello < World
hello World
hello > World
hello hello
hello == hello

ch18_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

char *strdupl(const char *s, int num_max)
{
    if (s == nullptr || num_max <= 0)
    {
        return nullptr;
    }

    int n = 0;
    const char *p = s;
    while (n < num_max && *p != '\0')
    {
        ++n;
        p++;
    }

    char *s_cpy = new char[n + 1];

    char *s_cpy_ptr = s_cpy;
    int i = 0;
    while (i < n && *s != '\0')
    {
        *s_cpy_ptr++ = *s++;
        ++i;
    }
    *s_cpy_ptr = '\0';
    return s_cpy;
}

const char *findx(const char *s, const char *x, int num_max_s, int num_max_x)
{
    if (x == nullptr || *x == '\0' || num_max_x <= 0)
    {
        return nullptr;
    }
    if (s == nullptr || *s == '\0' || num_max_s <= 0)
    {
        return nullptr;
    }
    for (int i = 0; i < num_max_s && * (s + i) != '\0'; ++i)
    {
        if (*(s + i) == *x)
        {
            int j = 1;
            for (; j < num_max_x && * (x + j) != '\0'; ++j)
            {
                if ( (i + j) >= num_max_s || *(s + i + j) == '\0')
                {
                    return nullptr;
                }
                if (*(s + i + j) != *(x + j))
                {
                    break;
                }
            }
            if (j >= num_max_x || *(x + j) == '\0')
            {
                return (s + i);
            }
        }
    }
    return nullptr;
}

int strcomp(const char *s1, const char *s2, int num_max_s1, int num_max_s2)
{
    if (s1 == nullptr || s2 == nullptr)
    {
        error("Null pointer sent to strcomp()");
    }
    if (num_max_s1 <= 0 || num_max_s2 <= 0)
    {
        error("num_max <= 0 sent to strcomp()");
    }
    int n = (num_max_s1 < num_max_s2 ? num_max_s1 : num_max_s2) + 1;
    for (int i = 0; i < n; ++i)
    {
        if ( ( i >= num_max_s1 || *(s1 + i) == '\0' ) && ( i < num_max_s2 && *(s2 + i) != '\0' ) )
        {
            return -1;
        }
        else if ( ( i >= num_max_s1 || *(s1 + i) == '\0' )  && ( i >= num_max_s2 || *(s2 + i) == '\0' ) )
        {
            return 0;
        }
        else if ( ( i < num_max_s1 && *(s1 + i) != '\0' )  && ( i >= num_max_s2 || *(s2 + i) == '\0' ) )
        {
            return 1;
        }
        else
        {
            if (*(s1 + i) < * (s2 + i))
            {
                return -1;
            }
            else if (*(s1 + i) > *(s2 + i))
            {
                return 1;
            }
        }
    }

    return 0;
}

void print_str(const char *s, int num_max)
{
    if (s == nullptr)
    {
        error("Cannot print from null pointer");
    }
    int i = 0;
    while (i < num_max && *s != '\0')
    {
        cout << *s++;
        ++i;
    }
}

int main()
{
    try
    {
        char a[] = "test";
        char *a_dpl = strdupl(a, 5);
        print_str(a_dpl, 5);
        cout << "\n";
        char b[] = { 't', 'e', 's', 't' };
        char *b_dpl = strdupl(b, 4);
        print_str(b_dpl, 4);
        cout << "\n";
        delete[] b_dpl;
        delete[] a_dpl;

        char s[] = "xxxtestxxx";
        char x[] = "test";
        const char *sub = findx(s, x, 11, 5);
        print_str(sub, 11);
        cout << "\n";
        char s2[] = { 'x', 'x', 't', 'e', 's', 't', 'x', 'x' };
        char x2[] = { 't', 'e', 's', 't' };
        const char *sub2 = findx(s2, x2, 8, 4);
        print_str(sub2, 6);
        cout << "\n";

        char str1[] = "atest";
        char str2[] = "btest";
        cout << str1 << " strcomp " << str2 << " is " << strcomp(str1, str2, 6, 6) << "\n";
        char str3[] = { 't', 'e', 's', 't', '1' };
        char str4[] = { 't', 'e', 's', 't', '1', 'a' };
        print_str(str3, 5);
        cout << " strcomp ";
        print_str(str4, 6);
        cout << " is " << strcomp(str3, str4, 5, 6) << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
test
test
testxxx
testxx
atest strcomp btest is -1
test1 strcomp test1a is -1

ch18_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

string cat_dot(const string &s1, const string &s2, const string &s3 = ".")
{
    return s1 + s3 + s2;
}

int main()
{
    try
    {
        cout << cat_dot("Niels", "Bohr") << "\n";
        cout << cat_dot("Niels", "Bohr", "dot") << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Niels.Bohr
NielsdotBohr

ch18_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

char *cat_dot(const char *s1, const char *s2)
{
    const char *p = s1;
    int ctr = 0;
    while (*p != '\0')
    {
        ++ctr;
        ++p;
    }
    p = s2;
    while (*p != '\0')
    {
        ++ctr;
        ++p;
    }

    char *res = new char[ctr + 2];

    p = s1;
    char *res_ptr = res;
    while (*p != '\0') { *res_ptr++ = *p++; }
    *res_ptr++ = '.';
    p = s2;
    while (*p != '\0') { *res_ptr++ = *p++; }
    *res_ptr = '\0';

    return res;
}

char *cat_dot2(const char *s1, const char *s2, const char *s3)
{
    const char *p = s1;
    int ctr = 0;
    while (*p != '\0')
    {
        ++ctr;
        ++p;
    }
    p = s2;
    while (*p != '\0')
    {
        ++ctr;
        ++p;
    }
    p = s3;
    while (*p != '\0')
    {
        ++ctr;
        ++p;
    }

    char *res = new char[ctr + 1];

    p = s1;
    char *res_ptr = res;
    while (*p != '\0') { *res_ptr++ = *p++; }
    p = s3;
    while (*p != '\0') { *res_ptr++ = *p++; }
    p = s2;
    while (*p != '\0') { *res_ptr++ = *p++; }
    *res_ptr = '\0';

    return res;
}

int main()
{
    try
    {
        char *res = cat_dot("Niels", "Bohr");
        cout << res << "\n";
        delete[] res;

        res = cat_dot2("Niels", "Bohr", " dot ");
        cout << res << "\n";
        delete[] res;

        char a[] = "Niels";
        char b[] = "Bohr";
        res = cat_dot(a, b);
        cout << res << "\n";
        delete[] res;

        const char *ap = "Niels";
        const char *bp = "Bohr";
        res = cat_dot(a, b);
        cout << res << "\n";
        delete[] res;

        char *as = new char[6];
        for (int i = 0; i < 6; ++i) { as[i] = ap[i]; }
        char *bs = new char[5];
        for (int i = 0; i < 5; ++i) { bs[i] = bp[i]; }
        res = cat_dot(as, bs);
        cout << res << "\n";
        delete[] res;
        delete[] bs;
        delete[] as;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Niels.Bohr
Niels dot Bohr
Niels.Bohr
Niels.Bohr
Niels.Bohr

ch18_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

bool is_palindrome(const string &s)
{
    string s_cp;
    for (int i = s.size() - 1; i >= 0; --i)
    {
        s_cp.push_back(s[i]);
    }
    if (s == s_cp)
    {
        return true;
    }
    return false;
}

bool is_palindrome(const char s[], int n)
{
    char *s_cp = new char[n + 1];
    s_cp[n] = 0;
    for (int i = 0; i < n; ++i)
    {
        s_cp[n - 1 - i] = s[i];
    }

    if (strcmp(s, s_cp))
    {
        delete[] s_cp;
        return false;
    }

    delete[] s_cp;
    return true;
}

bool is_palindrome(const char *first, const char *last)
{
    char *s_cp = new char[last - first + 2];
    char *s_cp_ptr = s_cp;
    while (last >= first)
    {
        *s_cp_ptr = *last;
        ++s_cp_ptr;
        --last;
    }
    *s_cp_ptr = '\0';

    if (strcmp(first, s_cp))
    {
        delete[] s_cp;
        return false;
    }

    delete[] s_cp;
    return true;
}

istream &read_word(istream &is, char *buffer, int max)
{
    is.getline(buffer, max);
    return is;
}

int main()
{
    try
    {
        string s;
        while (getline(cin, s, '\n') && s != "")
        {
            cout << s << " is";
            if (!is_palindrome(s))
            {
                cout << " not";
            }
            cout << " a palindrome\n";
        }

        const int max = 128;
        char s2[max];
        while (read_word(cin, s2, max) && strlen(s2) > 0)
        {
            cout << s2 <<  " is";
            if (!is_palindrome(s2, strlen(s2)))
            {
                cout << " not";
            }
            cout << " a palindrome\n";
        }

        while (read_word(cin, s2, max) && strlen(s2) > 0)
        {
            cout << s2 << " is";
            if (!is_palindrome(&s2[0], &s2[strlen(s2) - 1]))
            {
                cout << " not";
            }
            cout << " a palindrome\n";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
dffa
dffa is not a palindrome
dffaaffd
dffaaffd is a palindrome
EggE
EggE is a palindrome

Hello
Hello is not a palindrome

appa
appa is a palindrome

ch18_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int a = 0;
int b = 0;
int c = 0;
int d = 0;
int e = 0;

int main()
{
    try
    {
        int *pa = &a;
        int *pb = &b;
        int *pc = &c;
        int *pd = &d;
        int *pe = &e;
        cout << pa << "\n" << pb << "\n" << pc << "\n" << pd << "\n" << pe << "\n";

        int sa = 0;
        int sb = 0;
        int sc = 0;
        int *psa = &sa;
        int *psb = &sb;
        int *psc = &sc;
        cout << "\n" << psa << "\n" << psb << "\n" << psc << "\n";

        int *ha = new int(0);
        int *hb = new int(0);
        int *hc = new int(0);
        cout << "\n" << ha << "\n" << hb << "\n" << hc << "\n";

        int *harr = new int[5];
        cout << "\n";
        for (int i = 0; i < 5; ++i)
        {
            cout << &harr[i] << "\n";
        }
        delete[] harr;
        delete hc;
        delete hb;
        delete ha;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
0x564fdf2032f4
0x564fdf2032f8
0x564fdf2032fc
0x564fdf203300
0x564fdf203304

0x7ffe4c343160
0x7ffe4c343164
0x7ffe4c343168

0x564fe0d3e2c0
0x564fe0d3e2e0
0x564fe0d3e300

0x564fe0d3e320
0x564fe0d3e324
0x564fe0d3e328
0x564fe0d3e32c
0x564fe0d3e330

ch18_p10.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

bool is_palindrome(const char s[], int n)
{
    int first = 0;
    int last = n - 1;
    while (first < last)
    {
        if (s[first] != s[last])
        {
            return false;
        }
        ++first;
        --last;
    }
    return true;
}

istream &read_word(istream &is, char *buffer, int max)
{
    char ch;
    is.get(buffer, max);
    is.clear();
    is.get(ch);
    if (ch != '\n')
    {
        if (strlen(buffer) > 0)
        {
            cout << "Input cut off after " << strlen(buffer) << " characters!\n";
        }
        while (is.get(ch) && ch != '\n')
        {
            continue;
        }
    }
    return is;
}

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char ch)
    {
        append(ch);
        return *this;
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

int main()
{
    try
    {
        const int max = 8;
        char s[max];
        while (read_word(cin, s, max) && strlen(s) > 0)
        {
            cout << s <<  " is";
            if (!is_palindrome(s, strlen(s)))
            {
                cout << " not";
            }
            cout << " a palindrome\n";
        }

        Str_c s2;
        while (getline(cin, s2) && s2.size() > 0)
        {
            cout << s2 <<  " is";
            if (!is_palindrome(s2.c_str(), s2.size()))
            {
                cout << " not";
            }
            cout << " a palindrome\n";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Hello,World!
Input cut off after 7 characters!
Hello,W is not a palindrome

12345678987654321
12345678987654321 is a palindrome

ch18_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

class element
{
public:
    element(int k, int new_height) : key(k), next(new_height + 1) { }
    int key;
    vector<element *> next;
};

class skip_list
{
public:
    skip_list();
    element *find(int x);
    void insert(int x);
    void remove(int x);
    void print();
    void debug_print();
    int get_height()
    {
        return height;
    }
private:
    const int max_height = 128;
    const int infty = numeric_limits<int>::max();
    element head;
    element tail;
    int height;
    mt19937 engine;
};

skip_list::skip_list()
    : head(infty, max_height), tail(infty, max_height), height(0), engine( unsigned ( std::chrono::system_clock::now().time_since_epoch().count() ) )
{
    for (int i = 0; i < head.next.size(); ++i)
    {
        head.next[i] = &tail;
    }
}

element *skip_list::find(int x)
{
    element *p = &head;

    for (int i = height; i >= 0; --i)
    {
        while (p->next[i]->key < x)
        {
            p = p->next[i];
        }
    }

    p = p->next[0];
    if (p->key == x) { return p; }
    else { return nullptr; }
}

void skip_list::insert(int x)
{
    vector<element *> update(max_height + 1);
    element *p = &head;

    for (int i = height; i >= 0; --i)
    {
        while (p->next[i]->key < x)
        {
            p = p->next[i];
        }
        update[i] = p;
    }
    p = p->next[0];

    if (p->key == x) { return; }

    int new_height = nrand_two(0, max_height + 1, engine);
    if (new_height > height)
    {
        for (int i = height + 1; i <= new_height; ++i)
        {
            update[i] = &head;
        }
        height = new_height;
    }

    p = new element(x, new_height);

    for (int i = 0; i <= new_height; ++i)
    {
        p->next[i] = update[i]->next[i];
        update[i]->next[i] = p;
    }
}

void skip_list::remove(int x)
{
    vector<element *> update(max_height + 1);
    element *p = &head;
    for (int i = height; i >= 0; --i)
    {
        while (p->next[i]->key < x)
        {
            p = p->next[i];
        }
        update[i] = p;
    }
    p = p->next[0];

    if (p->key == x)
    {
        for (int i = 0; i < p->next.size(); ++i)
        {
            update[i]->next[i] = p->next[i];
        }
        while (height >= 1 && head.next[height] == &tail)
        {
            --height;
        }
        delete p;
    }
}

void skip_list::print()
{
    element *p = head.next[0];
    while (p != &tail)
    {
        cout << setw(5) << p->key;
        p = p->next[0];
    }
    cout << endl;
}

void skip_list::debug_print()
{
    for (int i = 0; i <= height; ++i)
    {
        element *p = head.next[i];
        cout << setw(3) << i << ": ";
        while (p != &tail)
        {
            cout << setw(3) << p->key << " ";
            p = p->next[i];
        }
        cout << endl;
    }
}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);
    try
    {
            skip_list sl;
            for (int i = 0; i < 30; ++i)
            {
                sl.insert(nrand_two(0, 100, engine));
            }
            sl.debug_print();
            cout << "Enter value to remove: ";
            int x;
            cin >> x;
            element *p = sl.find(x);
            if (p != nullptr)
            {
                cout << "p->key = " << p->key << endl;
                sl.remove(x);
                sl.debug_print();
            }
            else
            {
                cout << x << " is not found\n";
            }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
  0:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
  1:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
  2:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
  3:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
  4:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
  5:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
  6:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
  7:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
  8:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
  9:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
 10:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
 11:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
 12:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
 13:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
 14:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  80  85  92  94
 15:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  80  85  92  94
 16:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  80  85  92  94
 17:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  80  85  92  94
 18:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  80  85  92  94
 19:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  80  85  92  94
 20:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  80  85  92  94
 21:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  80  85  92  94
 22:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 23:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 24:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 25:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 26:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 27:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 28:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 29:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 30:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 31:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 32:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 33:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 34:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 35:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 36:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 37:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 38:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 39:  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 40:  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 41:  14  15  24  25  26  35  38  40  43  44  48  51  53  59  65  76  78  85  94
 42:  14  15  24  25  26  35  38  40  43  44  48  51  53  59  65  76  78  85  94
 43:  14  15  24  25  26  35  38  40  43  44  48  51  53  59  65  76  78  85  94
 44:  14  15  24  25  26  35  38  40  43  44  48  51  53  59  65  76  78  85  94
 45:  14  15  24  25  26  35  38  40  43  44  48  51  53  59  65  76  78  85  94
 46:  14  15  24  25  26  35  38  40  43  44  48  51  53  59  65  76  78  85  94
 47:  14  15  24  25  26  35  38  40  43  44  48  51  53  59  65  76  78  85  94
 48:  14  15  24  25  26  35  38  40  43  44  51  53  59  65  76  78  85  94
 49:  14  15  24  25  26  35  38  40  43  44  51  53  59  65  76  78  85  94
 50:  14  15  24  25  26  35  38  40  43  44  51  53  59  65  76  78  85  94
 51:  14  15  24  25  26  35  38  40  43  44  51  53  59  65  76  78  85  94
 52:  14  15  24  25  26  35  38  40  43  44  51  53  59  65  76  78  85  94
 53:  14  15  24  25  26  35  38  40  43  51  53  59  65  76  78  85  94
 54:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85  94
 55:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85  94
 56:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85  94
 57:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 58:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 59:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 60:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 61:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 62:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 63:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 64:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 65:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 66:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 67:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 68:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 69:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 70:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 71:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 72:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 73:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 74:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 75:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 76:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 77:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 78:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 79:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 80:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 81:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 82:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 83:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 84:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 85:  15  24  25  26  35  38  43  51  53  65  76  78  85
 86:  15  24  25  26  35  38  43  51  53  65  76  78  85
 87:  15  24  25  26  35  38  43  51  53  65  76  78  85
 88:  15  24  25  26  35  38  43  51  53  65  76  78  85
 89:  15  24  25  35  38  43  51  65  76  78  85
 90:  15  24  25  35  38  43  51  65  76  85
 91:  15  24  25  35  38  43  51  65  76  85
 92:  15  24  25  35  38  43  51  65  76  85
 93:  15  24  25  35  38  43  51  65  76  85
 94:  15  24  25  35  38  43  65  76  85
 95:  15  24  25  35  38  43  65  76  85
 96:  15  24  25  35  38  43  65  76  85
 97:  15  24  25  35  38  43  65  76  85
 98:  15  24  25  35  38  43  65  76  85
 99:  15  24  25  35  38  43  65  85
100:  15  24  25  35  38  43  65  85
101:  15  24  25  35  38  43  65  85
102:  15  24  35  38  43  65  85
103:  15  24  35  38  43  65  85
104:  24  35  38  65  85
105:  24  35  38  65  85
106:  24  35  38  65  85
107:  24  35  38  65  85
108:  24  35  38  65  85
109:  24  35  38  65  85
110:  24  35  38  65  85
111:  24  35  38  65
112:  24  35  38  65
113:  24  35  38  65
114:  24  38  65
115:  38  65
116:  38
117:  38
118:  38
119:  38
120:  38
121:  38
122:  38
Enter value to remove: 59
p->key = 59
  0:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
  1:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
  2:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
  3:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
  4:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
  5:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
  6:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
  7:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
  8:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
  9:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
 10:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
 11:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
 12:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
 13:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
 14:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  80  85  92  94
 15:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  80  85  92  94
 16:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  80  85  92  94
 17:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  80  85  92  94
 18:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  80  85  92  94
 19:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  80  85  92  94
 20:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  80  85  92  94
 21:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  80  85  92  94
 22:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 23:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 24:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 25:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 26:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 27:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 28:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 29:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 30:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 31:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 32:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 33:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 34:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 35:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 36:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 37:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 38:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 39:  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 40:  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 41:  14  15  24  25  26  35  38  40  43  44  48  51  53  65  76  78  85  94
 42:  14  15  24  25  26  35  38  40  43  44  48  51  53  65  76  78  85  94
 43:  14  15  24  25  26  35  38  40  43  44  48  51  53  65  76  78  85  94
 44:  14  15  24  25  26  35  38  40  43  44  48  51  53  65  76  78  85  94
 45:  14  15  24  25  26  35  38  40  43  44  48  51  53  65  76  78  85  94
 46:  14  15  24  25  26  35  38  40  43  44  48  51  53  65  76  78  85  94
 47:  14  15  24  25  26  35  38  40  43  44  48  51  53  65  76  78  85  94
 48:  14  15  24  25  26  35  38  40  43  44  51  53  65  76  78  85  94
 49:  14  15  24  25  26  35  38  40  43  44  51  53  65  76  78  85  94
 50:  14  15  24  25  26  35  38  40  43  44  51  53  65  76  78  85  94
 51:  14  15  24  25  26  35  38  40  43  44  51  53  65  76  78  85  94
 52:  14  15  24  25  26  35  38  40  43  44  51  53  65  76  78  85  94
 53:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85  94
 54:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85  94
 55:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85  94
 56:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85  94
 57:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 58:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 59:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 60:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 61:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 62:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 63:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 64:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 65:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 66:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 67:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 68:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 69:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 70:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 71:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 72:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 73:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 74:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 75:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 76:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 77:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 78:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 79:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 80:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 81:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 82:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 83:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 84:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 85:  15  24  25  26  35  38  43  51  53  65  76  78  85
 86:  15  24  25  26  35  38  43  51  53  65  76  78  85
 87:  15  24  25  26  35  38  43  51  53  65  76  78  85
 88:  15  24  25  26  35  38  43  51  53  65  76  78  85
 89:  15  24  25  35  38  43  51  65  76  78  85
 90:  15  24  25  35  38  43  51  65  76  85
 91:  15  24  25  35  38  43  51  65  76  85
 92:  15  24  25  35  38  43  51  65  76  85
 93:  15  24  25  35  38  43  51  65  76  85
 94:  15  24  25  35  38  43  65  76  85
 95:  15  24  25  35  38  43  65  76  85
 96:  15  24  25  35  38  43  65  76  85
 97:  15  24  25  35  38  43  65  76  85
 98:  15  24  25  35  38  43  65  76  85
 99:  15  24  25  35  38  43  65  85
100:  15  24  25  35  38  43  65  85
101:  15  24  25  35  38  43  65  85
102:  15  24  35  38  43  65  85
103:  15  24  35  38  43  65  85
104:  24  35  38  65  85
105:  24  35  38  65  85
106:  24  35  38  65  85
107:  24  35  38  65  85
108:  24  35  38  65  85
109:  24  35  38  65  85
110:  24  35  38  65  85
111:  24  35  38  65
112:  24  35  38  65
113:  24  35  38  65
114:  24  38  65
115:  38  65
116:  38
117:  38
118:  38
119:  38
120:  38
121:  38
122:  38

第19章向量、模板和异常
19.1 问题
19.2 改变向量大小
19.2.1 方法描述
19.2.2 reserve和capacity
19.2.3 resize
19.2.4 puah_back
19.2.5 赋值
19.2.6 到现在为止我们设计的vector类
19.3 模板
19.3.1 类型作为模板参数
19.3.2 泛型编程
19.3.3 容器和继承
19.3.4 整底魑模板⑹
19.3.5 模板参数推导
19.3.6 ―般化vector类
19.4 范围检查和异常
19.4.1 附加讨论：设计上的考虑
19.4.2 使用宏
19.5 资源和异常
19.5.1 潜在的资源管理问题
19.5.2 资源获取即初始化
19.5.3 保证
19.5.4 auto_ptr
19.5.5 vector类的RAII
ch19_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
class S
{
public:
    S() : val(T()) { }
    S(const T &d) : val(d) { }
    T &operator=(const T &d)
    {
        val = d;
        return val;
    }
    T &get()
    {
        return val;
    }
    const T &get() const
    {
        return val;
    }
    void set(const T &d)
    {
        val = d;
    }
private:
    T val;
};

template<typename T>
istream &operator>>(istream &is, S<T> &ss)
{
    T v;
    cin >> v;
    if (!is)
    {
        return is;
    }
    ss.set(v);
    return is;
}

template<typename T>
void read_val(T &v)
{
    cin >> v;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &d)
{
    os << "{ ";
    for (int i = 0; i < d.size(); ++i)
    {
        os << d[i];
        if (i < d.size() - 1)
        {
            os << ", ";
        }
    }
    os << " }";
    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (cin >> temp && cin >> ch2 && ch2 == ',')
    {
        v_temp.push_back(temp);
    }
    if (ch2 != '}')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    v_temp.push_back(temp);

    d = v_temp;
    return is;
}

int main()
{
    try
    {
        S<int> s_int(5);
        S<char> s_char('x');
        S<double> s_dbl(3.14);
        S<string> s_strg("Hello,World!");
        vector<int> vec;
        vec.push_back(1);
        vec.push_back(2);
        vec.push_back(3);
        S< vector<int> > s_vec_int(vec);

        cout << "s_int: " << s_int.get() << "\n";
        cout << "s_char: " << s_char.get() << "\n";
        cout << "s_dbl: " << s_dbl.get() << "\n";
        cout << "s_strg: " << s_strg.get() << "\n";
        for (int i = 0; i < s_vec_int.get().size(); ++i)
        {
            cout << "s_vec_int[" << i << "]: " << s_vec_int.get()[i] << "\n";
        }
        cout << s_vec_int.get() << "\n";

        s_int.set(55);
        s_char.set('y');
        s_dbl.set(4.14);
        s_strg.set("Peter Smith");
        vec[1] = 22;
        s_vec_int.set(vec);
        cout << "\ns_int: " << s_int.get() << "\n";
        cout << "s_char: " << s_char.get() << "\n";
        cout << "s_dbl: " << s_dbl.get() << "\n";
        cout << "s_strg: " << s_strg.get() << "\n";
        for (int i = 0; i < s_vec_int.get().size(); ++i)
        {
            cout << "s_vec_int[" << i << "]: " << s_vec_int.get()[i] << "\n";
        }
        cout << s_vec_int.get() << "\n";

        s_int = 66;
        s_char = 'z';
        s_dbl = 5.14;
        s_strg = "Mike Pence";
        vec[1] = 33;
        s_vec_int = vec;
        cout << "\ns_int: " << s_int.get() << "\n";
        cout << "s_char: " << s_char.get() << "\n";
        cout << "s_dbl: " << s_dbl.get() << "\n";
        cout << "s_strg: " << s_strg.get() << "\n";
        for (int i = 0; i < s_vec_int.get().size(); ++i)
        {
            cout << "s_vec_int[" << i << "]: " << s_vec_int.get()[i] << "\n";
        }
        cout << s_vec_int.get() << "\n";

        const S<int> c_s_int(5);
        cout << "\nc_s_int: " << c_s_int.get() << "\n";

        cout << "\ns_int: ";
        read_val(s_int);
        cout << "s_char: ";
        read_val(s_char);
        cout << "s_dbl: ";
        read_val(s_dbl);
        cout << "s_strg: ";
        read_val(s_strg);
        cout << "\ns_int: " << s_int.get() << "\n";
        cout << "s_char: " << s_char.get() << "\n";
        cout << "s_dbl: " << s_dbl.get() << "\n";
        cout << "s_strg: " << s_strg.get() << "\n\n";

        cout << "\ns_vec_int: ";
        read_val(s_vec_int);
        cout << "\ns_vec_int: " << s_vec_int.get() << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
s_int: 5
s_char: x
s_dbl: 3.14
s_strg: Hello,World!
s_vec_int[0]: 1
s_vec_int[1]: 2
s_vec_int[2]: 3
{ 1, 2, 3 }

s_int: 55
s_char: y
s_dbl: 4.14
s_strg: Peter Smith
s_vec_int[0]: 1
s_vec_int[1]: 22
s_vec_int[2]: 3
{ 1, 22, 3 }

s_int: 66
s_char: z
s_dbl: 5.14
s_strg: Mike Pence
s_vec_int[0]: 1
s_vec_int[1]: 33
s_vec_int[2]: 3
{ 1, 33, 3 }

c_s_int: 5

s_int: 9
s_char: j
s_dbl: 9.99
s_strg: Water

s_int: 9
s_char: j
s_dbl: 9.99
s_strg: Water


s_vec_int: { 1, 2, 3, 4, 5, 6 }

s_vec_int: { 1, 2, 3, 4, 5, 6 }

ch19_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
void f(vector<T> &v1, const vector<T> &v2)
{
    for (int i = 0; i < v1.size(); ++i)
    {
        if (i == v2.size())
        {
            break;
        }
        v1[i] += v2[i];
    }
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

int main()
{
    try
    {
        vector<int> v1;
        for (int i = 0; i < 10; ++i)
        {
            v1.push_back(i);
        }
        cout << "v1: " << v1 << "\n";
        vector<int> v2;
        for (int i = 0; i < 8; ++i)
        {
            v2.push_back(i);
        }
        cout << "v2: " << v2 << "\n";
        f(v1, v2);
        cout << "After: " << v1 << "\n\n";

        v2.push_back(15);
        v2.push_back(16);
        v2.push_back(17);
        cout << "New v2: " << v2 << "\n";
        f(v1, v2);
        cout << "After: " << v1 << "\n\n";

        vector<string> vs1;
        vs1.push_back("one");
        vs1.push_back("two");
        vs1.push_back("three");
        vs1.push_back("four");
        cout << "vs1: " << vs1 << "\n";
        vector<string> vs2;
        vs2.push_back(" ONE");
        vs2.push_back(" TWO");
        vs2.push_back(" THREE");
        cout << "vs2: " << vs2 << "\n";
        f(vs1, vs2);
        cout << "After: " << vs1 << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
v1: { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
v2: { 0, 1, 2, 3, 4, 5, 6, 7 }
After: { 0, 2, 4, 6, 8, 10, 12, 14, 8, 9 }

New v2: { 0, 1, 2, 3, 4, 5, 6, 7, 15, 16, 17 }
After: { 0, 3, 6, 9, 12, 15, 18, 21, 23, 25 }

vs1: { one, two, three, four }
vs2: {  ONE,  TWO,  THREE }
After: { one ONE, two TWO, three THREE, four }

ch19_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T, typename U>
typename common_type<T, U>::type f(const vector<T> &vt, const vector<U> &vu)
{
    typename common_type<T, U>::type sum = 0;
    int min_size = vt.size() <= vu.size() ? vt.size() : vu.size();
    for (int i = 0; i < min_size; ++i)
    {
        sum += vt[i] * vu[i];
    }
    return sum;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

int main()
{
    try
    {
        vector<int> v1;
        for (int i = 0; i < 10; ++i)
        {
            v1.push_back(i);
        }
        cout << "v1: " << v1 << "\n";
        vector<double> v2;
        for (int i = 0; i < 8; ++i)
        {
            v2.push_back(i * 1.6);
        }
        cout << "v2: " << v2 << "\n";
        cout << "f(v1,v2): " << f(v1, v2) << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
v1: { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
v2: { 0, 1.6, 3.2, 4.8, 6.4, 8, 9.6, 11.2 }
f(v1,v2): 224

ch19_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T, typename U>
class Pair
{
public:
    Pair(const T &vt, const U &vu) : val1(vt), val2(vu) { }
    T val1;
    U val2;
};

class Symbol_table
{
public:
    double get(const string &s);
    void set(const string &s, double d);
    bool is_declared(const string &s);
    double declare(const string &s, double val);
    void print();
private:
    vector< Pair<string, double> > var_table;
};

double Symbol_table::get(const string &s)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].val1 == s) { return var_table[i].val2; }
    }
    error("Variable not found: " + s);
}

void Symbol_table::set(const string &s, double d)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].val1 == s)
        {
            var_table[i].val2 = d;
            return;
        }
    }
    error("Variable not found: " + s);
}

bool Symbol_table::is_declared(const string &s)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].val1 == s) { return true; }
    }
    return false;
}

double Symbol_table::declare(const string &s, double d)
{
    if (is_declared(s)) { error("Variable exists already: " + s); }
    var_table.push_back(Pair<string, double>(s, d));
    return d;
}

void Symbol_table::print()
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        cout << var_table[i].val1 << ": " << var_table[i].val2 << "\n";
    }
}

int main()
{
    try
    {
        Symbol_table st;
        st.declare("Pi", 3.14);
        st.declare("e", 2.72);
        st.print();
        cout << "Pi is " << st.get("Pi") << "\n";
        if (st.is_declared("Pi"))
        {
            cout << "Pi is declared\n";
        }
        else
        {
            cout << "Pi is not declared\n";
        }
        if (st.is_declared("nd"))
        {
            cout << "nd is declared\n";
        }
        else
        {
            cout << "nd is not declared\n";
        }
        st.set("Pi", 4.14);
        cout << "Pi is now " << st.get("Pi") << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Pi: 3.14
e: 2.72
Pi is 3.14
Pi is declared
nd is not declared
Pi is now 4.14

ch19_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

class God
{
public:
    God(const string &n = "", const string &m = "", const string &v = "", const string &w = "")
        : name(n), mythology(m), vehicle(v), weapon(w) { }
    string name;
    string mythology;
    string vehicle;
    string weapon;
};

ostream &operator<<(ostream &os, const God &g)
{
    os << g.name << ": " << g.mythology << ", "
       << g.vehicle << ", " << g.weapon;
    return os;
}

bool operator==(const God &g1, const God &g2)
{
    return (g1.name == g2.name && g1.mythology == g2.mythology
            && g1.vehicle == g2.vehicle && g1.weapon == g2.weapon);
}

bool operator!=(const God &g1, const God &g2)
{
    return !(g1 == g2);
}

bool operator<(const God &g1, const God &g2)
{
    return g1.name < g2.name;
}

bool operator>(const God &g1, const God &g2)
{
    return g2 < g1;
}

bool operator<=(const God &g1, const God &g2)
{
    return !(g1 > g2);
}

bool operator>=(const God &g1, const God &g2)
{
    return !(g1 < g2);
}

template<typename T>
class Link
{
private:
    Link<T> *prev;
    Link<T> *succ;
public:
    T value;
    Link(const T &v = T(), Link<T> *p = nullptr, Link<T> *s = nullptr) : value(v), prev(p), succ(s) { }

    Link<T> *insert(Link<T> *n);
    Link<T> *add(Link<T> *n);
    Link<T> *add_ordered(Link<T> *n);
    Link<T> *erase();
    Link<T> *find(const T &v);

    Link<T> *advance(int n);

    Link<T> *next() const
    {
        return succ;
    }
    Link<T> *previous() const
    {
        return prev;
    }
    void print_all();
};

template<typename T>
Link<T> *Link<T>::insert(Link<T> *n)
{
    if (n == nullptr)
    {
        return n;
    }
    n->succ = this;
    if (prev != nullptr)
    {
        prev->succ = n;
    }
    n->prev = prev;
    prev = n;
    return n;
}

template<typename T>
Link<T> *Link<T>::add(Link<T> *n)
{
    if (n == nullptr)
    {
        return n;
    }
    n->prev = this;
    if (succ != nullptr)
    {
        succ->prev = n;
    }
    n->succ = succ;
    succ = n;
    return n;
}

template<typename T>
Link<T> *Link<T>::add_ordered(Link<T> *n)
{
    if (n == nullptr)
    {
        return n;
    }
    if (n->value < value)
    {
        Link<T> *p = insert(n);
        return p;
    }
    Link<T> *p = this;
    while (n->value >= p->value)
    {
        if (p->succ == nullptr)
        {
            p->add(n);
            return this;
        }
        p = p->succ;
    }
    p->insert(n);
    return this;
}

template<typename T>
Link<T> *Link<T>::erase()
{
    if (succ != nullptr)
    {
        succ->prev = prev;
    }
    if (prev != nullptr)
    {
        prev->succ = succ;
    }
    Link<T> *ret = succ;
    succ = nullptr;
    prev = nullptr;
    return ret;
}

template<typename T>
Link<T> *Link<T>::find(const T &v)
{
    Link<T> *p = this;
    while (p != nullptr)
    {
        if (p->value == v)
        {
            return p;
        }
        p = p->succ;
    }
    return nullptr;
}

template<typename T>
Link<T> *Link<T>::advance(int n)
{
    Link<T> *p = this;
    if (0 < n)
    {
        while (n--)
        {
            if (p->succ == nullptr)
            {
                return nullptr;
            }
            p = p->succ;
        }
    }
    else if (n < 0)
    {
        while (n++)
        {
            if (p->prev == nullptr)
            {
                return nullptr;
            }
            p = p->prev;
        }
    }
    return p;
}

template<typename T>
void Link<T>::print_all()
{
    Link<T> *p = this;
    while (p != nullptr)
    {
        cout << p->value << "\n";
        p = p->succ;
    }
}

template<typename T>
void delete_all(Link<T> *p)
{
    while (p != nullptr)
    {
        Link<T> *temp = p->next();
        delete p;
        p = temp;
    }
}

template<typename T>
Link<T> *extract(Link<T> **l, const T &v)
{
    if ( (*l) == nullptr )
    {
        return nullptr;
    }
    Link<T> *p = (*l)->find(v);
    if (p != nullptr)
    {
        if (p == (*l))
        {
            (*l) = p->next();
        }
        p->erase();
        return p;
    }
    return nullptr;
}

template<typename T>
void move(Link<T>*&from, Link<T>*&to, const T &v)
{
    Link<T> *temp = extract<T>(&from, v);
    if (temp != nullptr)
    {
        to = to->add_ordered(temp);
    }
}

int main()
{
    try
    {
        Link<God> *all_gods = new Link<God>(God("Thor", "Norse", "Pinzgauer", "Hammer"));
        all_gods = all_gods->insert(new Link<God>(God("Odin", "Norse", "Eight-legged horse", "")));
        all_gods = all_gods->insert(new Link<God>(God("Zeus", "Greek", "", "Lightning")));
        all_gods = all_gods->insert(new Link<God>(God("Freia", "Norse", "F-transport", "F-weapon")));
        all_gods = all_gods->insert(new Link<God>(God("Hera", "Greek", "H-transport", "Spear")));
        all_gods = all_gods->insert(new Link<God>(God("Athena", "Greek", "A-transport", "A-weapon")));
        all_gods = all_gods->insert(new Link<God>(God("Mars", "Roman", "M-transport", "M-weapon")));
        all_gods = all_gods->insert(new Link<God>(God("Poseidon", "Greek", "Seahorse", "Trident")));
        all_gods = all_gods->insert(new Link<God>(God("Ares", "Greek", "A-transport", "A-weapon")));
        all_gods = all_gods->insert(new Link<God>(God("Vesuvius", "Roman", "V-transport", "Volcano")));
        all_gods = all_gods->insert(new Link<God>(God("Bacchus", "Roman", "Stretcher", "Wine goblet")));

        all_gods->print_all();

        Link<God> *norse_gods = extract<God>(&all_gods, God("Odin", "Norse", "Eight-legged horse", ""));
        move<God>(all_gods, norse_gods, God("Thor", "Norse", "Pinzgauer", "Hammer"));
        move<God>(all_gods, norse_gods, God("Freia", "Norse", "F-transport", "F-weapon"));

        Link<God> *greek_gods = extract<God>(&all_gods, God("Hera", "Greek", "H-transport", "Spear"));
        move<God>(all_gods, greek_gods, God("Athena", "Greek", "A-transport", "A-weapon"));
        move<God>(all_gods, greek_gods, God("Poseidon", "Greek", "Seahorse", "Trident"));
        move<God>(all_gods, greek_gods, God("Zeus", "Greek", "", "Lightning"));
        move<God>(all_gods, greek_gods, God("Ares", "Greek", "A-transport", "A-weapon"));

        Link<God> *roman_gods = extract<God>(&all_gods, God("Mars", "Roman", "M-transport", "M-weapon"));
        move<God>(all_gods, roman_gods, God("Vesuvius", "Roman", "V-transport", "Volcano"));
        move<God>(all_gods, roman_gods, God("Bacchus", "Roman", "Stretcher", "Wine goblet"));

        cout << "\nNorse gods:\n";
        norse_gods->print_all();
        cout << "\nGreek gods:\n";
        greek_gods->print_all();
        cout << "\nRoman gods:\n";
        roman_gods->print_all();

        delete_all<God>(norse_gods);
        delete_all<God>(greek_gods);
        delete_all<God>(roman_gods);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Bacchus: Roman, Stretcher, Wine goblet
Vesuvius: Roman, V-transport, Volcano
Ares: Greek, A-transport, A-weapon
Poseidon: Greek, Seahorse, Trident
Mars: Roman, M-transport, M-weapon
Athena: Greek, A-transport, A-weapon
Hera: Greek, H-transport, Spear
Freia: Norse, F-transport, F-weapon
Zeus: Greek, , Lightning
Odin: Norse, Eight-legged horse,
Thor: Norse, Pinzgauer, Hammer

Norse gods:
Freia: Norse, F-transport, F-weapon
Odin: Norse, Eight-legged horse,
Thor: Norse, Pinzgauer, Hammer

Greek gods:
Ares: Greek, A-transport, A-weapon
Athena: Greek, A-transport, A-weapon
Hera: Greek, H-transport, Spear
Poseidon: Greek, Seahorse, Trident
Zeus: Greek, , Lightning

Roman gods:
Bacchus: Roman, Stretcher, Wine goblet
Mars: Roman, M-transport, M-weapon
Vesuvius: Roman, V-transport, Volcano

ch19_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

class Int
{
private:
    int val;
public:
    Int() : val(0) { }
    Int(int v) : val(v) { }
    Int(const Int &arg) : val(arg.val) { }
    Int &operator=(const Int &arg)
    {
        val = arg.val;
        return *this;
    }
    int get() const
    {
        return val;
    }
};

Int operator+(const Int &v1, const Int &v2)
{
    return Int(v1.get() + v2.get());
}

Int operator-(const Int &v1, const Int &v2)
{
    return Int(v1.get() - v2.get());
}

Int operator*(const Int &v1, const Int &v2)
{
    return Int(v1.get() * v2.get());
}

Int operator/(const Int &v1, const Int &v2)
{
    return Int(v1.get() / v2.get());
}

ostream &operator<<(ostream &os, const Int &v)
{
    os << v.get();
    return os;
}

int main()
{
    try
    {
        Int i1;
        Int i2 = 2;
        Int i3(i2);
        Int i4;
        i4 = i2;
        Int i5 = 6;
        cout << "i1 (default constructed): " << i1 << "\n";
        cout << "i2 (constructed with argument): " << i2 << "\n";
        cout << "i3 (copy constructed from i2): " << i3 << "\n";
        cout << "i4 (copy assigned  from i2): " << i4 << "\n";
        cout << "i5 (constructed with argument): " << i5 << "\n";
        cout << "i2 + i5 = " << i2 + i5 << "\n";
        cout << "i5 - i2 = " << i5 - i2 << "\n";
        cout << "i2 * i5 = " << i2 *i5 << "\n";
        cout << "i5 / i2 = " << i5 / i2 << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
i1 (default constructed): 0
i2 (constructed with argument): 2
i3 (copy constructed from i2): 2
i4 (copy assigned  from i2): 2
i5 (constructed with argument): 6
i2 + i5 = 8
i5 - i2 = 4
i2 * i5 = 12
i5 / i2 = 3

ch19_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
class Number
{
private:
    T val;
public:
    Number() : val(T()) { }
    Number(const T &v) : val(v) { }
    Number(const Number<T> &arg) : val(arg.val) { }
    Number &operator=(const Number<T> &arg)
    {
        if (this == &arg) { return *this; }
        val = arg.val;
        return *this;
    }
    T & get()
    {
        return val;
    }
    const T & get() const
    {
        return val;
    }
};

template<typename T>
Number<T> operator+(const Number<T> &v1, const Number<T> &v2)
{
    return Number<T>(v1.get() + v2.get());
}

template<typename T>
Number<T> operator-(const Number<T> &v1, const Number<T> &v2)
{
    return Number<T>(v1.get() - v2.get());
}

template<typename T>
Number<T> operator*(const Number<T> &v1, const Number<T> &v2)
{
    return Number<T>(v1.get() * v2.get());
}

template<typename T>
Number<T> operator/(const Number<T> &v1, const Number<T> &v2)
{
    return Number<T>(v1.get() / v2.get());
}

template<typename T>
Number<T> operator%(const Number<T> &v1, const Number<T> &v2)
{
    return Number<T>(v1.get() % v2.get());
}

template<class T>
ostream &operator<<(ostream &os, const Number<T> &v)
{
    os << v.get();
    return os;
}

int main()
{
    try
    {
        cout << "int:\n";
        Number<int> i1;
        Number<int> i2 = 2;
        Number<int> i3(i2);
        Number<int> i4;
        i4 = i2;
        Number<int> i5 = 5;
        cout << "i1 (default constructed): " << i1 << "\n";
        cout << "i2 (constructed with argument): " << i2 << "\n";
        cout << "i3 (copy constructed from i2): " << i3 << "\n";
        cout << "i4 (copy assigned  from i2): " << i4 << "\n";
        cout << "i5 (constructed with argument): " << i5 << "\n";
        cout << "i2 + i5 = " << i2 + i5 << "\n";
        cout << "i5 - i2 = " << i5 - i2 << "\n";
        cout << "i2 * i5 = " << i2 *i5 << "\n";
        cout << "i5 / i2 = " << i5 / i2 << "\n";
        cout << "i5 % i2 = " << i5 % i2 << "\n";

        cout << "\ndouble:\n";
        Number<double> d1;
        Number<double> d2 = 2.2;
        Number<double> d3(d2);
        Number<double> d4;
        d4 = d2;
        Number<double> d5 = 5.5;
        cout << "d1 (default constructed): " << d1 << "\n";
        cout << "d2 (constructed with argument): " << d2 << "\n";
        cout << "d3 (copy constructed from d2): " << d3 << "\n";
        cout << "d4 (copy assigned  from d2): " << d4 << "\n";
        cout << "d5 (constructed with argument): " << d5 << "\n";
        cout << "d2 + d5 = " << d2 + d5 << "\n";
        cout << "d5 - d2 = " << d5 - d2 << "\n";
        cout << "d2 * d5 = " << d2 *d5 << "\n";
        cout << "d5 / d2 = " << d5 / d2 << "\n";

        cout << "\nchar:\n";
        Number<char> c1;
        Number<char> c2 = 'x';
        Number<char> c3(c2);
        Number<char> c4;
        c4 = c2;
        Number<char> c5 = 'C';
        cout << "c1 (default constructed): " << c1 << "\n";
        cout << "c2 (constructed with argument): " << c2 << "\n";
        cout << "c3 (copy constructed from c2): " << c3 << "\n";
        cout << "c4 (copy assigned  from c2): " << c4 << "\n";
        cout << "c5 (constructed with argument): " << c5 << "\n";

        cout << "\nstring:\n";
        Number<string> s1;
        Number<string> s2("xxx");
        Number<string> s3(s2);
        Number<string> s4;
        s4 = s2;
        Number<string> s5("ABCD!");
        cout << "s1 (default constructed): " << s1 << "\n";
        cout << "s2 (constructed with argument): " << s2 << "\n";
        cout << "s3 (copy constructed from s2): " << s3 << "\n";
        cout << "s4 (copy assigned  from s2): " << s4 << "\n";
        cout << "s5 (constructed with argument): " << s5 << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
int:
i1 (default constructed): 0
i2 (constructed with argument): 2
i3 (copy constructed from i2): 2
i4 (copy assigned  from i2): 2
i5 (constructed with argument): 5
i2 + i5 = 7
i5 - i2 = 3
i2 * i5 = 10
i5 / i2 = 2
i5 % i2 = 1

double:
d1 (default constructed): 0
d2 (constructed with argument): 2.2
d3 (copy constructed from d2): 2.2
d4 (copy assigned  from d2): 2.2
d5 (constructed with argument): 5.5
d2 + d5 = 7.7
d5 - d2 = 3.3
d2 * d5 = 12.1
d5 / d2 = 2.5

char:
c1 (default constructed):
c2 (constructed with argument): x
c3 (copy constructed from c2): x
c4 (copy assigned  from c2): x
c5 (constructed with argument): C

string:
s1 (default constructed):
s2 (constructed with argument): xxx
s3 (copy constructed from s2): xxx
s4 (copy assigned  from s2): xxx
s5 (constructed with argument): ABCD!

ch19_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() { }
    Str(size_type n, char c) : data(n, c) { }
    Str(const char *cp)
    {
        copy(cp, cp + strlen(cp), back_inserter(data));
    }

    template<typename In>
    Str(In b, In e) : data(b, e) { }

    size_type size() const
    {
        return data.size();
    }

    char &operator[](size_type i)
    {
        return data[i];
    }
    const char &operator[](size_type i) const
    {
        return data[i];
    }

    Str &operator+=(const Str &s)
    {
        copy(s.data.begin(), s.data.end(), back_inserter(data));
        return *this;
    }

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        data.insert(position, first, last);
    };

    iterator begin()
    {
        return data.begin();
    };
    const_iterator begin() const
    {
        return data.begin();
    };
    iterator end()
    {
        return data.end();
    };
    const_iterator end() const
    {
        return data.end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data.clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data.push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }
    friend ostream &operator<<(ostream &os, const Str &s)
    {
        for (size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }
    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Vec<char> data;
};

int main()
{
    try
    {
        Str s = "A lonesome string.";

        Vec<char> v(s.begin(), s.end());

        for (size_t i = 0; i < v.size(); i++)
        {
            cout << v[i];
        }
        cout << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
A lonesome string.

ch19_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
T *clone(const T *tp)
{
    return tp->clone()
}

template<typename T>
class Ptr
{
public:
    Ptr() : refptr(new size_t(1)), p(nullptr) { }
    Ptr(T *t) : refptr(new size_t(1)), p(t) { }
    Ptr(const Ptr<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ptr<T> &operator=(const Ptr<T> &);
    ~Ptr();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr");
    }

    void make_unique()
    {
        if (*refptr > 1)
        {
            --*refptr;
            refptr = new size_t(1);
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

    void print()
    {
        cout << (void *)p << ": " << (void *)refptr << ", " << *refptr << endl;
    }
private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ptr<T> &Ptr<T>::operator=(const Ptr<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ptr<T>::~Ptr()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

class Tracer
{
private:
    int val;
public:
    Tracer() : val(0)
    {
        cout << "Tracer()\n";
    }
    Tracer(int n) : val(n)
    {
        cout << "Tracer(int n)\n";
    }
    Tracer(const Tracer &arg) : val(arg.val)
    {
        cout << "Tracer(const Tracer &arg)\n";
    }
    Tracer &operator=(const Tracer &arg)
    {
        cout << "operator=(const Tracer &arg)\n";
        if (this == &arg) { return *this; }
        val = arg.val;
        return *this;
    }
    ~Tracer()
    {
        cout << "~Tracer()\n";
    }
    int & get()
    {
        return val;
    }
    const int & get() const
    {
        return val;
    }
};

template<>
inline Tracer *clone<Tracer>(const Tracer *pt)
{
    return new Tracer(*pt);
}

void f1()
{
    Ptr<Tracer> p1(new Tracer());
    Ptr<Tracer> p2(new Tracer(5));
    Ptr<Tracer> p3(p2);
    p1.print();
    p2.print();
    p3.print();
    p1 = p3;
    p1.print();
    p2.print();
    p3.print();
    cout << (*p1).get() << ", " << p2->get() << ", " << (*p3).get() << endl;
}

void f2()
{
    Ptr<Tracer> p1(new Tracer());
    Ptr<Tracer> p2(new Tracer(5));
    Ptr<Tracer> p3(p2);
    error("Exception!");
}

int main()
{
    try
    {
        f1();
        f2();
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Tracer()
Tracer(int n)
0x5627e0710eb0: 0x5627e07112e0, 1
0x5627e0711300: 0x5627e0711320, 2
0x5627e0711300: 0x5627e0711320, 2
~Tracer()
0x5627e0711300: 0x5627e0711320, 3
0x5627e0711300: 0x5627e0711320, 3
0x5627e0711300: 0x5627e0711320, 3
5, 5, 5
~Tracer()
Tracer()
Tracer(int n)
Exception!
~Tracer()
~Tracer()
error: Exception!

第20章 容器和迭代器
20.1 存储和处理数据
20.1.1 处理数据
20.1.2 一般化代码
20.2 STL建议
20.3 序列和迭代器
20.3.1 回到实例
20.4 链表
20.4.1 列表操作
20.4.2 迭代
20.5 再次一般化vector
20.6 实例：一个简单的文本编器
20.6.1 处理行
20.6.2 迭代
20.7 vector、list和string
20.7.1 insert和erase
20.8 调整vector类达到STL版本的功能
20.9 调整内置数组达到STL版本的功能
20.10 容器概览
20.10.1 迭代器类别
ch20_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T, int N>
class array
{
public:
    typedef T value_type;
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;

    T elems[N];

    iterator begin()
    {
        return elems;
    }
    const_iterator begin() const
    {
        return elems;
    }
    iterator end()
    {
        return elems + N;
    }
    const_iterator end() const
    {
        return elems + N;
    }

    size_type size() const
    {
        return N;
    }

    T &operator[](int n)
    {
        return elems[n];
    }
    const T &operator[](int n) const
    {
        return elems[n];
    }

    T *data()
    {
        return elems;
    }
    const T *data() const
    {
        return elems;
    }
};

template<typename Iter>
void my_print(Iter f, Iter e, const string &s)
{
    if (f != e)
    {
        cout << s << ": { ";
        cout << *f++;
        while (f != e)
        {
            cout << ", " << *f++;
        }
        cout << " }\n";
    }
}

template<typename Iter1, typename Iter2>
Iter2 my_copy(Iter1 f1, Iter1 e1, Iter2 f2)
{
    while (f1 != e1)
    {
        *f2++ = *f1++;
    }
    return f2;
}

int main()
{
    try
    {
        const int arr_sz = 10;
        array<int, arr_sz> arr_int;
        for (int i = 0; i < arr_int.size(); ++i)
        {
            arr_int[i] = i;
        }
        my_print(arr_int.begin(), arr_int.end(), "arr_int");

        vector<int> vec_int;
        for (int i = 0; i < arr_sz; ++i)
        {
            vec_int.push_back(i);
        }
        my_print(vec_int.begin(), vec_int.end(), "vec_int");

        list<int> lst_int;
        for (int i = 0; i < arr_sz; ++i)
        {
            lst_int.push_back(i);
        }
        my_print(lst_int.begin(), lst_int.end(), "lst_int");

        array<int, arr_sz> arr_cp = arr_int;
        my_print(arr_cp.begin(), arr_cp.end(), "arr_cp");
        vector<int> vec_cp = vec_int;
        my_print(vec_cp.begin(), vec_cp.end(), "vec_cp");
        list<int> lst_cp = lst_int;
        my_print(lst_cp.begin(), lst_cp.end(), "lst_cp");

        for (array<int, arr_sz>::iterator p = arr_int.begin(); p != arr_int.end(); ++p)
        {
            *p += 2;
        }
        my_print(arr_int.begin(), arr_int.end(), "arr_int+=2");

        for (vector<int>::iterator p = vec_int.begin(); p != vec_int.end(); ++p)
        {
            *p += 3;
        }
        my_print(vec_int.begin(), vec_int.end(), "vec_int+=3");

        for (list<int>::iterator p = lst_int.begin(); p != lst_int.end(); ++p)
        {
            *p += 5;
        }
        my_print(lst_int.begin(), lst_int.end(), "lst_int+=5");

        vector<int>::iterator vec_iter = my_copy(arr_int.begin(), arr_int.end(), vec_int.begin());
        array<int, arr_sz>::iterator arr_iter = my_copy(lst_int.begin(), lst_int.end(), arr_int.begin());

        if (vec_iter != vec_int.begin() && arr_iter != arr_int.begin())
        {
            my_print(arr_int.begin(), arr_int.end(), "arr_int copied from lst_int");
            my_print(vec_int.begin(), vec_int.end(), "vec_int copied from arr_int");
            my_print(lst_int.begin(), lst_int.end(), "lst_int");
        }

        vec_iter = find(vec_int.begin(), vec_int.end(), 3);
        if (vec_iter != vec_int.end())
        {
            cout << "In vec_int, 3 has index " << vec_iter - vec_int.begin() << ".\n";
        }

        list<int>::iterator lst_iter = find(lst_int.begin(), lst_int.end(), 27);

        if (lst_iter != lst_int.end())
        {
            int idx = distance(lst_int.begin(), lst_iter);
            cout << "In lst_int, 27 has index " << idx << ".\n";
        }
        else
        {
            cout << "27 is not in lst_int.\n";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
arr_int: { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
vec_int: { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
lst_int: { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
arr_cp: { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
vec_cp: { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
lst_cp: { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
arr_int+=2: { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }
vec_int+=3: { 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 }
lst_int+=5: { 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 }
arr_int copied from lst_int: { 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 }
vec_int copied from arr_int: { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }
lst_int: { 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 }
In vec_int, 3 has index 1.
27 is not in lst_int.

ch20_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

double *get_from_jack(int *count)
{
    string ifname = "ch20_p02_in1.txt";
    ifstream ifs(ifname.c_str());
    if (!ifs)
    {
        error("Can't open input file " + ifname);
    }

    vector<double> v;
    double d;
    while (ifs >> d)
    {
        v.push_back(d);
    }

    *count = v.size();
    double *data = new double[*count];
    for (int i = 0; i < v.size(); ++i)
    {
        data[i] = v[i];
    }

    return data;
}

vector<double> *get_from_jill()
{
    string ifname = "ch20_p02_in2.txt";
    ifstream ifs(ifname.c_str());
    if (!ifs)
    {
        error ("Can't open input file " + ifname);
    }

    vector<double> *v = new vector<double>;
    double d;
    while (ifs >> d)
    {
        (*v).push_back(d);
    }

    return v;
}

double *high(double *first, double *last)
{
    double h = numeric_limits<double>::min();
    double *high = nullptr;
    for(double *p = first; p != last; ++p)
    {
        if (h < *p)
        {
            high = p;
            h = *p;
        }
    }
    return high;
}

int main()
{
    try
    {
        int jack_count = 0;
        double *jack_data = get_from_jack(&jack_count);
        vector<double> *jill_data = get_from_jill();

        double *jack_high = high(jack_data, jack_data + jack_count);
        vector<double> &v = *jill_data;
        double *jill_high = high(&v[0], &v[0] + v.size());

        cout << "Jill's max: " << *jill_high << "; Jack's max: " << *jack_high;

        delete[] jack_data;
        delete jill_data;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Jill's max: 66.6; Jack's max: 9.9

cat ch20_p02_in1.txt
1.1 5.5 9.9 7.7 3.3 6.6

cat ch20_p02_in2.txt
11.1 15.5 29.9 66.6 33.3 22.2

ch20_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

double *get_from_jack(int *count)
{
    string ifname = "ch20_p02_in1.txt";
    ifstream ifs(ifname.c_str());
    if (!ifs)
    {
        error("Can't open input file " + ifname);
    }

    vector<double> v;
    double d;
    while (ifs >> d)
    {
        v.push_back(d);
    }

    *count = v.size();
    double *data = new double[*count];
    for (int i = 0; i < v.size(); ++i)
    {
        data[i] = v[i];
    }

    return data;
}

vector<double> *get_from_jill()
{
    string ifname = "ch20_p02_in2.txt";
    ifstream ifs(ifname.c_str());
    if (!ifs)
    {
        error ("Can't open input file " + ifname);
    }

    vector<double> *v = new vector<double>;
    double d;
    while (ifs >> d)
    {
        (*v).push_back(d);
    }

    return v;
}

double *high_vec(vector<double> &v)
{
    if (v.size() == 0)
    {
        return nullptr;
    }
    double *highest = &v[0];
    for (int i = 1; i < v.size(); ++i)
    {
        if (v[i] > *highest)
        {
            highest = &v[i];
        }
    }
    return highest;
}

double *high_arr(double arg[], int n)
{
    if (n == 0)
    {
        return nullptr;
    }
    double *highest = &arg[0];
    for (int i = 1; i < n; ++i)
    {
        if (arg[i] > *highest)
        {
            highest = &arg[i];
        }
    }
    return highest;
}

double *high_ptr(double *first, double *last)
{
    double h = numeric_limits<double>::min();
    double *high = nullptr;
    for(double *p = first; p != last; ++p)
    {
        if (h < *p)
        {
            high = p;
            h = *p;
        }
    }
    return high;
}

int main()
{
    try
    {
        int jack_count = 0;
        double *jack_data = get_from_jack(&jack_count);
        vector<double> *jill_data = get_from_jill();

        vector<double> jack_vec;
        for (int i = 0; i < jack_count; ++i)
        {
            jack_vec.push_back(jack_data[i]);
        }
        double *jack_high_vec = high_vec(jack_vec);
        double *jill_high_vec = high_vec(*jill_data);
        cout << "Vector: Jill's max: " << *jill_high_vec << "; Jack's max: " << *jack_high_vec << "\n";

        double *jill_arr = new double[(*jill_data).size()];
        for (int i = 0; i < (*jill_data).size(); ++i)
        {
            jill_arr[i] = (*jill_data)[i];
        }
        double *jack_high_arr = high_arr(jack_data, jack_count);
        double *jill_high_arr = high_arr(jill_arr, (*jill_data).size());
        cout << "Array: Jill's max: " << *jill_high_arr << "; Jack's max: " << *jack_high_arr << "\n";
        delete[] jill_arr;

        double *jack_high_ptr = high_ptr(jack_data, jack_data + jack_count);
        vector<double> &v = *jill_data;
        double *jill_high_ptr = high_ptr(&v[0], &v[0] + v.size());

        cout << "Pointer: Jill's max: " << *jill_high_ptr << "; Jack's max: " << *jack_high_ptr << "\n";

        delete[] jack_data;
        delete jill_data;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Vector: Jill's max: 66.6; Jack's max: 9.9
Array: Jill's max: 66.6; Jack's max: 9.9
Pointer: Jill's max: 66.6; Jack's max: 9.9

cat ch20_p02_in1.txt
1.1 5.5 9.9 7.7 3.3 6.6

cat ch20_p02_in2.txt
11.1 15.5 29.9 66.6 33.3 22.2

ch20_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}


double *get_from_jack(int *count)
{
    string ifname = "ch20_p02_in1.txt";
    ifstream ifs(ifname.c_str());
    if (!ifs)
    {
        error("Can't open input file " + ifname);
    }

    vector<double> v;
    double d;
    while (ifs >> d)
    {
        v.push_back(d);
    }

    *count = v.size();
    double *data = new double[*count];
    for (int i = 0; i < v.size(); ++i)
    {
        data[i] = v[i];
    }

    return data;
}

vector<double> *get_from_jill()
{
    string ifname = "ch20_p02_in2.txt";
    ifstream ifs(ifname.c_str());
    if (!ifs)
    {
        error ("Can't open input file " + ifname);
    }

    vector<double> *v = new vector<double>;
    double d;
    while (ifs >> d)
    {
        (*v).push_back(d);
    }

    return v;
}

double *high_ptr(double *first, double *last)
{
    double h = numeric_limits<double>::min();
    double *high = nullptr;
    for(double *p = first; p != last; ++p)
    {
        if (h < *p)
        {
            high = p;
            h = *p;
        }
    }
    return high;
}

template<typename In>
In high(In first, In last)
{
    if (first == last)
    {
        return In(nullptr);
    }
    In high = first;
    In p = first;
    ++p;
    for (; p != last; ++p)
    {
        if (*high < *p)
        {
            high = p;
        }
    }
    return high;
}

int main()
{
    try
    {
        int jack_count = 0;
        double *jack_data = get_from_jack(&jack_count);
        vector<double> *jill_data = get_from_jill();

        double *jack_high = high(jack_data, jack_data + jack_count);
        vector<double> &v = *jill_data;
        double *jill_high = high(&v[0], &v[0] + v.size());
        cout << "Jill's high " << *jill_high << "; Jack's high " << *jack_high << endl;

        delete[] jack_data;
        delete jill_data;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Jill's high 66.6; Jack's high 9.9

ch20_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int main()
{
    try
    {
        vector<double> vd;
        vector<int> vi;
        vector<string> vs;
        cout << "Enter vector of doubles: ";
        cin >> vd;
        cout << "Enter vector of integers: ";
        cin >> vi;
        cout << "Enter vector of strings: ";
        cin >> vs;

        cout << vd << "\n" << vi << "\n" << vs << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter vector of doubles: { 1.1 , 2.2 , 3.3 }
Enter vector of integers: { 1 , 2 , 3 }
Enter vector of strings: { aaa , bbb , ccc }
{ 1.1, 2.2, 3.3 }
{ 1, 2, 3 }
{ aaa, bbb, ccc }

ch20_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

typedef vector<char> Line;

class Text_iterator;

class Document
{
public:
    list<Line> line;

    Document();

    Text_iterator begin();
    Text_iterator end();

    Text_iterator erase(Text_iterator pos);
    Text_iterator insert(Text_iterator pos, char ch);
    void concat(Text_iterator &pos);
    void break_ln(Text_iterator pos);
    void find_replace(const string &find_str, const string &repl_str);
};

class Text_iterator
{
private:
    Document &doc;
    list<Line>::iterator ln;
    Line::iterator pos;
public:
    Text_iterator(Document &d, list<Line>::iterator l, Line::iterator p) : doc(d), ln(l), pos(p) { }
    Text_iterator(const Text_iterator &other) : doc(other.doc), ln(other.ln), pos(other.pos) { }
    Text_iterator &operator=(const Text_iterator &rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        doc = rhs.doc;
        ln = rhs.ln;
        pos = rhs.pos;
        return *this;
    }

    list<Line>::iterator get_line()
    {
        return ln;
    }
    Line::iterator get_pos()
    {
        return pos;
    }

    char &operator*()
    {
        return *pos;
    }
    Text_iterator &operator++();

    bool operator==(const Text_iterator &other) const
    {
        return ln == other.ln && pos == other.pos;
    }
    bool operator!=(const Text_iterator &other) const
    {
        return !(*this == other);
    }
};

Text_iterator &Text_iterator::operator++()
{
    if (ln == doc.line.end())
    {
        return *this;
    }
    list<Line>::iterator last = doc.line.end();
    --last;
    if (ln == last && pos == (*ln).begin())
    {
        return *this;
    }
    if (pos != (*ln).end())
    {
        ++pos;
    }
    if (pos == (*ln).end())
    {
        if (ln != last)
        {
            ++ln;
            pos = (*ln).begin();
        }
    }
    return *this;
}

template<typename Iter>
bool my_match(Iter first, Iter last, const string &s)
{
    if (first == last)
    {
        return false;
    }
    if (s.size() == 0)
    {
        return false;
    }
    string::const_iterator s_itr = s.begin();
    while (first != last && s_itr != s.end())
    {
        if (*first != *s_itr)
        {
            return false;
        }
        ++first;
        ++s_itr;
    }
    if (first == last && s_itr != s.end())
    {
        return false;
    }
    return true;
}

template<typename Iter, typename T>
Iter my_find(Iter first, Iter last, const T &val)
{
    Iter p = first;
    while (p != last)
    {
        if (*p == val)
        {
            return p;
        }
        ++p;
    }
    return p;
}

Text_iterator find_txt(Text_iterator first, Text_iterator last, const string &s)
{
    if (first == last)
    {
        return last;
    }
    if (s.size() == 0)
    {
        return last;
    }
    char first_char = s[0];
    while (true)
    {
        Text_iterator p = my_find<Text_iterator, char>(first, last, first_char);
        if (p == last)
        {
            return last;
        }
        if (my_match<Text_iterator>(p, last, s))
        {
            return p;
        }
        first = ++p;
    }
}

Document::Document()
{
    line.push_back(Line());
}
Text_iterator Document::begin()
{
    return Text_iterator(*this, line.begin(), (* ( line.begin() ) ).begin());
}
Text_iterator Document::end()
{
    list<Line>::iterator last = line.end();
    --last;
    return Text_iterator(*this, last, (*last).begin());
}

Text_iterator Document::erase(Text_iterator pos)
{
    list<Line>::iterator list_it = pos.get_line();
    Line::iterator line_it = pos.get_pos();
    line_it = (*list_it).erase(line_it);
    return Text_iterator(*this, list_it, line_it);
}

Text_iterator Document::insert(Text_iterator pos, char ch)
{
    list<Line>::iterator list_it = pos.get_line();
    Line::iterator line_it = pos.get_pos();
    line_it = (*list_it).insert(line_it, ch);
    return Text_iterator(*this, list_it, line_it);
}

void Document::concat(Text_iterator &pos)
{
    list<Line>::iterator cur_line = pos.get_line();
    Line::iterator line_pos = pos.get_pos();
    Line::size_type index = line_pos - (*cur_line).begin();
    list<Line>::iterator nxt_line = cur_line;
    ++nxt_line;
    list<Line>::iterator last = line.end();
    --last;
    if (nxt_line != last && (*nxt_line).begin() != (*nxt_line).end())
    {
        (*cur_line).insert((*cur_line).end(), (*nxt_line).begin(), (*nxt_line).end());
        pos = Text_iterator(*this, cur_line, (*cur_line).begin() + index);
        line.erase(nxt_line);
    }
}

void Document::break_ln(Text_iterator pos)
{
    list<Line>::iterator cur_line = pos.get_line();
    list<Line>::iterator nxt_line = cur_line;
    ++nxt_line;
    list<Line>::iterator last = line.end();
    --last;
    if (pos.get_pos() + 1 != (*cur_line).end())
    {
        if (nxt_line == last)
        {
            line.push_back(Line());
        }
        (*nxt_line).insert((*nxt_line).begin(), pos.get_pos() + 1, (*cur_line).end());
        (*cur_line).erase(pos.get_pos() + 1, (*cur_line).end());
    }
}

void Document::find_replace(const string &find_str, const string &repl_str)
{
    if (begin() == end())
    {
        return ;
    }
    if (find_str.size() == 0)
    {
        return ;
    }
    Text_iterator pos = find_txt(begin(), end(), find_str);
    while (pos != end())
    {
        string::const_iterator find_it = find_str.begin();
        string::const_iterator repl_it = repl_str.begin();
        while (find_it != find_str.end() && repl_it != repl_str.end())
        {
            if (*find_it != *repl_it)
            {
                *pos = *repl_it;
                if (*find_it == '\n')
                {
                    concat(pos);
                }
                if (*repl_it == '\n')
                {
                    break_ln(pos);
                }
            }
            ++pos;
            ++find_it;
            ++repl_it;
        }

        while (find_it != find_str.end())
        {
            list<Line>::iterator cur_line = pos.get_line();
            if (*pos == '\n')
            {
                concat(pos);
            }
            else if (*pos != '\n' && (*cur_line).size() == 1)
            {
                concat(pos);
            }
            pos = erase(pos);
            cur_line = pos.get_line();
            if ((*cur_line).size() == 0)
            {
                line.erase(cur_line);
                pos = end();
                break;
            }
            ++find_it;
        }

        while (repl_it != repl_str.end())
        {
            list<Line>::iterator cur_line = pos.get_line();
            list<Line>::iterator last = line.end();
            --last;
            if (cur_line == last)
            {
                line.push_back(Line());
            }
            pos = insert(pos, *repl_it);
            if (*repl_it == '\n')
            {
                break_ln(pos);
            }
            ++pos;
            ++repl_it;
        }

        pos = find_txt(pos, end(), find_str);
    }
}

istream &operator>>(istream &is, Document &d)
{
    char ch;
    while (is.get(ch))
    {
        d.line.back().push_back(ch);
        if (ch == '\n')
        {
            d.line.push_back(Line());
        }
    }
    if (d.line.back().size() > 0)
    {
        d.line.push_back(Line());
    }
    return is;
}

void print(Document &d, Text_iterator p)
{
    for ( ; p != d.end(); ++p)
    {
        cout << *p;
    }
    cout << "\n";
}

int char_count(Document &d)
{
    Text_iterator iter = d.begin();
    int ctr = 0;
    while (iter != d.end())
    {
        ++iter;
        ++ctr;
    }
    return ctr;
}

int file_word_count(const string &fname)
{
    ifstream ifs(fname.c_str());
    if (!ifs)
    {
        error("can't open file " + fname);
    }
    string s;
    int ctr = 0;
    while (ifs >> s)
    {
        ++ctr;
    }
    return ctr;
}

int word_count1(Document &d)
{
    Text_iterator p = d.begin();
    string fname = "ch20_p06_tmp1.txt";
    ofstream ofs(fname.c_str());
    if (!ofs)
    {
        error("can't open file " + fname);
    }
    while (p != d.end())
    {
        ofs << *p;
        ++p;
    }
    ofs.close();

    int ctr = file_word_count(fname);
    return ctr;
}

int word_count2(Document &d)
{
    Text_iterator p = d.begin();
    string fname = "ch20_p06_tmp2.txt";
    ofstream ofs(fname.c_str());
    if (!ofs)
    {
        error("can't open file " + fname);
    }
    while (p != d.end())
    {
        if (isalpha(*p))
        {
            ofs << *p;
        }
        else
        {
            ofs << ' ';
        }
        ++p;
    }
    ofs.close();

    int ctr = file_word_count(fname);
    return ctr;
}

bool is_whitespace(char c, const string &white)
{
    for (int i = 0; i < white.size(); ++i)
    {
        if (white[i] == c)
        {
            return true;
        }
    }
    return false;
}

int word_count3(Document &d, const string &white)
{
    Text_iterator p = d.begin();
    string fname = "ch20_p06_tmp3.txt";
    ofstream ofs(fname.c_str());
    if (!ofs)
    {
        error("can't open file " + fname);
    }
    while (p != d.end())
    {
        if (is_whitespace(*p, white))
        {
            ofs << ' ';
        }
        else
        {
            ofs << *p;
        }
        ++p;
    }
    ofs.close();

    int ctr = file_word_count(fname);
    return ctr;
}

int main()
{
    try
    {
        string ifname = "ch20_p06_in.txt";
        ifstream ifs(ifname.c_str());
        if (!ifs)
        {
            error("can't open file " + ifname);
        }
        Document my_doc;
        ifs >> my_doc;
        print(my_doc, my_doc.begin());

        cout << "\nSearching for string 'wrong':\n";
        string f_str = "wrong";
        Text_iterator p = find_txt(my_doc.begin(), my_doc.end(), f_str);
        if (p == my_doc.end())
        {
            cout << "not found";
        }
        else
        {
            print(my_doc, p);
        }

        cout << "\nReplace 'wrong' with 'HelloWorld':\n";
        f_str = "wrong";
        string r_str = "HelloWorld";
        my_doc.find_replace(f_str, r_str);
        print(my_doc, my_doc.begin());


        cout << "\nNumber of characters in this document: "
             << char_count(my_doc) << "\n";

        cout << "Number of words (whitespace-separated) in this document: "
             << word_count1(my_doc) << "\n";

        cout << "Number of words (sequences of alphabetic characters) in this "
             << "document: " << word_count2(my_doc) << "\n";

        cout << "Number of words separated by whitespace or \".!'\" in this "
             << "document: " << word_count3(my_doc, ".!'") << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
cat ch20_p06_in.txt
Peter Smith Mike Pence Water Flower
123abc wrong 56789 How are You?
Orange Egg Smile wrong
Internet

ch20_p06
Peter Smith Mike Pence Water Flower
123abc wrong 56789 How are You?
Orange Egg Smile wrong
Internet


Searching for string 'wrong':
wrong 56789 How are You?
Orange Egg Smile wrong
Internet


Replace 'wrong' with 'HelloWorld':
Peter Smith Mike Pence Water Flower
123abc HelloWorld 56789 How are You?
Orange Egg Smile HelloWorld
Internet


Number of characters in this document: 110
Number of words (whitespace-separated) in this document: 17
Number of words (sequences of alphabetic characters) in this document: 16
Number of words separated by whitespace or ".!'" in this document: 17

cat ch20_p06_tmp1.txt
Peter Smith Mike Pence Water Flower
123abc HelloWorld 56789 How are You?
Orange Egg Smile HelloWorld
Internet

cat ch20_p06_tmp2.txt
Peter Smith Mike Pence Water Flower    abc HelloWorld       How are You  Orange Egg Smile HelloWorld Internet 

cat ch20_p06_tmp3.txt
Peter Smith Mike Pence Water Flower
123abc HelloWorld 56789 How are You?
Orange Egg Smile HelloWorld
Internet

ch20_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


template<typename Iterator>
Iterator biggest_element(Iterator first, Iterator last)
{
    Iterator high = first;
    while (first != last)
    {
        if (*first > *high)
        {
            high = first;
        }
        ++first;
    }
    return high;
}

int main()
{
    try
    {
        vector<string> vs;
        string s;
        cout << "Enter a few words:\n";
        while (cin >> s )
        {
            vs.push_back(s);
        }

        vector<string>::iterator last = biggest_element(vs.begin(), vs.end());
        if (last != vs.end())
        {
            cout << "The lexicographically last string in the vector is \""<< *last << "\".\n";
        }
        else
        {
            cout << "vector is empty.\n";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter a few words:
Mike Pence Hello World Water Flower
The lexicographically last string in the vector is "World".

ch20_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template<typename Iter>
void print_ctr(Iter first, Iter last)
{
    if (first != last)
    {
        cout << "{ ";

        cout << *first++;

        while (first != last)
        {
            cout << ", " << *first++;
        }
        cout << " }\n";
    }
}

void list_cpy(const list<int> &li)
{
    vector<double> vd;
    list<int>::const_iterator li_it = li.begin();
    while (li_it != li.end())
    {
        vd.push_back(*li_it);
        ++li_it;
    }

    cout << "Length of list:   " << li.size() << "\n";
    cout << "Length of vector: " << vd.size() << "\n";
    cout << "List:   ";
    print_ctr(li.begin(), li.end());
    cout << "Vector: ";
    print_ctr(vd.begin(), vd.end());
    vector<double> vd_sorted = vd;
    sort(vd_sorted.begin(), vd_sorted.end());
    cout << "Sorted: ";
    print_ctr(vd_sorted.begin(), vd_sorted.end());
}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);
    try
    {
        list<int> li;
        for (int i = 0; i < 10; ++i)
        {
            li.push_back(nrand_two(0, 100, engine));
        }
        list_cpy(li);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Length of list:   10
Length of vector: 10
List:   { 40, 29, 84, 68, 87, 22, 72, 97, 46, 72 }
Vector: { 40, 29, 84, 68, 87, 22, 72, 97, 46, 72 }
Sorted: { 22, 29, 40, 46, 68, 72, 72, 84, 87, 97 }

ch20_p12.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template<typename T>
class Link
{
private:
    Link<T> *prev;
    Link<T> *succ;
public:
    T value;
    Link(const T &v = T(), Link<T> *p = nullptr, Link<T> *s = nullptr) : value(v), prev(p), succ(s) { }

    Link<T> *insert(Link<T> *n);
    Link<T> *add(Link<T> *n);
    Link<T> *add_ordered(Link<T> *n);
    Link<T> *erase();
    Link<T> *find(const T &v);

    Link<T> *advance(int n);

    Link<T> *next() const
    {
        return succ;
    }
    Link<T> *previous() const
    {
        return prev;
    }
    void print_all();
};

template<typename T>
Link<T> *Link<T>::insert(Link<T> *n)
{
    if (n == nullptr)
    {
        return n;
    }
    n->succ = this;
    if (prev != nullptr)
    {
        prev->succ = n;
    }
    n->prev = prev;
    prev = n;
    return n;
}

template<typename T>
Link<T> *Link<T>::add(Link<T> *n)
{
    if (n == nullptr)
    {
        return n;
    }
    n->prev = this;
    if (succ != nullptr)
    {
        succ->prev = n;
    }
    n->succ = succ;
    succ = n;
    return n;
}

template<typename T>
Link<T> *Link<T>::add_ordered(Link<T> *n)
{
    if (n == nullptr)
    {
        return n;
    }
    if (n->value < value)
    {
        Link<T> *p = insert(n);
        return p;
    }
    Link<T> *p = this;
    while (n->value >= p->value)
    {
        if (p->succ == nullptr)
        {
            p->add(n);
            return this;
        }
        p = p->succ;
    }
    p->insert(n);
    return this;
}

template<typename T>
Link<T> *Link<T>::erase()
{
    if (succ != nullptr)
    {
        succ->prev = prev;
    }
    if (prev != nullptr)
    {
        prev->succ = succ;
    }
    Link<T> *ret = succ;
    succ = nullptr;
    prev = nullptr;
    return ret;
}

template<typename T>
Link<T> *Link<T>::find(const T &v)
{
    Link<T> *p = this;
    while (p != nullptr)
    {
        if (p->value == v)
        {
            return p;
        }
        p = p->succ;
    }
    return nullptr;
}

template<typename T>
Link<T> *Link<T>::advance(int n)
{
    Link<T> *p = this;
    if (0 < n)
    {
        while (n--)
        {
            if (p->succ == nullptr)
            {
                return nullptr;
            }
            p = p->succ;
        }
    }
    else if (n < 0)
    {
        while (n++)
        {
            if (p->prev == nullptr)
            {
                return nullptr;
            }
            p = p->prev;
        }
    }
    return p;
}

template<typename T>
void Link<T>::print_all()
{
    Link<T> *p = this;
    while (p != nullptr)
    {
        cout << p->value << "\n";
        p = p->succ;
    }
}

template<typename T>
void delete_all(Link<T> *p)
{
    while (p != nullptr)
    {
        Link<T> *temp = p->next();
        delete p;
        p = temp;
    }
}

template<typename T>
Link<T> *extract(Link<T> **l, const T &v)
{
    if ( (*l) == nullptr )
    {
        return nullptr;
    }
    Link<T> *p = (*l)->find(v);
    if (p != nullptr)
    {
        if (p == (*l))
        {
            (*l) = p->next();
        }
        p->erase();
        return p;
    }
    return nullptr;
}

template<typename T>
void move(Link<T> *&from, Link<T> *&to, const T &v)
{
    Link<T> *temp = extract<T>(&from, v);
    if (temp != nullptr)
    {
        to = to->add_ordered(temp);
    }
}

template<typename T>
class my_list
{
private:
    Link<T> *first;
    Link<T> *last;
public:
    my_list() : first(new Link<T>()), last(first) { }
    ~my_list()
    {
        delete_all(first);
    }

    void print()
    {
        Link<T> *p = first;
        while (p != last)
        {
            cout << p->value << "\n";
            p = p->next();
        }
    }

    class iterator
    {
    private:
        Link<T> *curr;
    public:
        friend class my_list<T>;
        iterator(Link<T> *p) : curr(p) { }

        iterator &operator++()
        {
            curr = curr->next();
            return *this;
        }
        iterator &operator--()
        {
            curr = curr->previous();
            return *this;
        }
        T &operator*()
        {
            return curr->value;
        }

        bool operator==(const iterator &b) const
        {
            return curr == b.curr;
        }
        bool operator!=(const iterator &b) const
        {
            return curr != b.curr;
        }
    };

    iterator begin();
    iterator end();

    iterator insert(iterator p, const T &v);
    iterator erase(iterator p);

    void push_front(const T &v);
    void push_back(const T &v);
    void pop_front();
    void pop_back();

    T &front();
    T &back();
};

template<typename T>
typename my_list<T>::iterator my_list<T>::begin()
{
    return iterator(first);
}

template<typename T>
typename my_list<T>::iterator my_list<T>::end()
{
    return iterator(last);
}

template<typename T>
typename my_list<T>::iterator my_list<T>::insert(iterator p, const T &v)
{
    Link<T> *n = new Link<T>(v);
    Link<T> *p_link = p.curr;
    Link<T> *p_ret = p_link->insert(n);
    if (first == p_link)
    {
        first = p_ret;
    }
    return iterator(p_ret);
}

template<typename T>
typename my_list<T>::iterator my_list<T>::erase(iterator p)
{
    Link<T> *p_link = p.curr;
    Link<T> *p_ret = p_link->erase();
    if (first == p_link)
    {
        first = p_ret;
    }
    delete p_link;
    return iterator(p_ret);
}

template<typename T>
void my_list<T>::push_front(const T &v)
{
    Link<T> *n = new Link<T>(v);
    Link<T> *p_link = first;
    Link<T> *p_ret = p_link->insert(n);
    first = p_ret;
}

template<typename T>
void my_list<T>::push_back(const T &v)
{
    Link<T> *n = new Link<T>(v);
    Link<T> *p_link = last;
    Link<T> *p_ret = p_link->insert(n);
    if (first == p_link)
    {
        first = p_ret;
    }
}

template<typename T>
void my_list<T>::pop_front()
{
    Link<T> *p_link = first;
    Link<T> *p_ret = p_link->erase();
    first = p_ret;
    delete p_link;
}

template<typename T>
void my_list<T>::pop_back()
{
    Link<T> *p_link = last->previous();
    Link<T> *p_ret = p_link->erase();
    if (first == p_link)
    {
        first = p_ret;
    }
    delete p_link;
}

template<typename T>
T &my_list<T>::front()
{
    Link<T> *p_link = first;
    return p_link->value;
}

template<typename T>
T &my_list<T>::back()
{
    Link<T> *p_link = last->previous();
    return p_link->value;
}

template<typename Iterator>
Iterator high(Iterator first, Iterator last)
{
    Iterator high = first;
    for (Iterator p = first; p != last; ++p)
    {
        if (*high < *p)
        {
            high = p;
        }
    }
    return high;
}

int main()
{
    try
    {
        my_list<int> lst;
        int x;
        while (cin >> x)
        {
            lst.push_front(x);
        }
        lst.print();
        my_list<int>::iterator p = high(lst.begin(), lst.end());
        cout << "The highest value was " << *p << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
1 3 5 9 6 18 23 7 2
2
7
23
18
6
9
5
3
1
The highest value was 23


第21章 算法和映射
21.1 标准库中的算法
21.2 最简单的算法: find
21.2.1 一些一般的应用
21.3 通用搜索算法: find_if
21.4 函数对象
21.4.1 函数对象的抽象视图
21.4.2 类成员上的谓词
21.5 数值算法
21.5.1 累积
21.5.2 一般化accumulate
21.5.3 内积
21.5.4一般化inner-product
21.6 关联容器
21.6.1 映射
21.6.2 map概览
21.6.3 另一个map实例
21.6.4 unordered_map
21.6.5 集合
21.7 拷贝操作
21.7.1 拷贝
21.7.2 流迭代器
21.7.3 使用集合保持顺序
21.7.4 copy_if
21.8 排序和搜索
ch21_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Item
{
public:
    string name;
    int iid;
    double value;
    Item() : name(), iid(0), value(0) { }
    Item(const string &n, int i, double v) : name(n), iid(i), value(v) { }
};

istream &operator>>(istream &is, Item &it)
{
    string name;
    int iid;
    double value;
    is >> name;
    if (!is)
    {
        return is;
    }
    is >> iid;
    if (!is)
    {
        return is;
    }
    is >> value;
    if (!is)
    {
        return is;
    }
    it = Item(name, iid, value);
    return is;
}

ostream &operator<<(ostream &os, const Item &it)
{
    return os << it.name << '\t' << it.iid << '\t' << it.value;
}

class  Comp_by_name
{
public:
    bool operator()(const Item &a, const Item &b) const
    {
        return a.name < b.name;
    }
};

class Comp_by_iid
{
public:
    bool operator()(const Item &a, const Item &b) const
    {
        return a.iid < b.iid;
    }
};

bool comp_by_value(const Item &a, const Item &b)
{
    return a.value < b.value;
}

class Find_by_name
{
private:
    string name;
public:
    Find_by_name(const string &s) : name(s) { }
    bool operator()(const Item &it) const
    {
        return it.name == name;
    }
};

class Find_by_iid
{
private:
    int iid;
public:
    Find_by_iid(int i) : iid(i) { }
    bool operator()(const Item &it) const
    {
        return it.iid == iid;
    }
};

template<typename iter>
void print(iter first, iter last)
{
    while (first != last)
    {
        cout << *first << '\n';
        ++first;
    }
}

void f1()
{
    cout << "First round: vector\n";
    vector<Item> vi;
    const string ifname = "ch21_d01_in1.txt";

    cout << "fill with ten items from file\n";
    ifstream ifs(ifname.c_str());
    if (!ifs)
    {
        error("can't open " + ifname);
    }
    Item i;
    while (ifs >> i)
    {
        vi.insert(vi.end(), i);
    }
    print(vi.begin(), vi.end());

    cout << "\nsort by name\n";
    sort(vi.begin(), vi.end(), Comp_by_name());
    print(vi.begin(), vi.end());

    cout << "\nsort by iid\n";
    sort(vi.begin(), vi.end(), Comp_by_iid());
    print(vi.begin(), vi.end());

    cout << "\nsort by value, print in decreasing order\n";
    sort(vi.begin(), vi.end(), comp_by_value);
    reverse(vi.begin(), vi.end());
    print(vi.begin(), vi.end());

    cout << "\ninsert two items, sort by value, print in decreasing order\n";
    vi.insert(vi.end(), Item("Horsesh", 99, 12.34));
    vi.insert(vi.end(), Item("C S400", 9988, 499.95));
    sort(vi.begin(), vi.end(), comp_by_value);
    reverse(vi.begin(), vi.end());
    print(vi.begin(), vi.end());

    cout << "\nremove two items identified by name\n";
    vector<Item>::iterator vi_it = find_if(vi.begin(), vi.end(), Find_by_name("GoPro"));
    vi.erase(vi_it);
    vi_it = find_if(vi.begin(), vi.end(), Find_by_name("Xbox"));
    vi.erase(vi_it);
    print(vi.begin(), vi.end());

    cout << "\nremove two tems identified by iid\n";
    vi_it = find_if(vi.begin(), vi.end(), Find_by_iid(14910));
    vi.erase(vi_it);
    vi_it = find_if(vi.begin(), vi.end(), Find_by_iid(754));
    vi.erase(vi_it);
    print(vi.begin(), vi.end());
}

void f2()
{
    cout << "\nSecond round: list\n";
    list<Item> li;
    const string ifname = "ch21_d01_in1.txt";

    cout << "fill with ten items from file\n";
    ifstream ifs(ifname.c_str());
    if (!ifs)
    {
        error("can't open " + ifname);
    }
    Item i;
    while (ifs >> i)
    {
        li.insert(li.end(), i);
    }
    print(li.begin(), li.end());

    cout << "\nsort by name\n";
    li.sort(Comp_by_name());
    print(li.begin(), li.end());

    cout << "\nsort by iid\n";
    li.sort(Comp_by_iid());
    print(li.begin(), li.end());

    cout << "\nsort by value, print in decreasing order\n";
    li.sort(comp_by_value);
    reverse(li.begin(), li.end());
    print(li.begin(), li.end());

    cout << "\ninsert two items, sort by value, print in decreasing order\n";
    li.insert(li.end(), Item("Horsesh", 99, 12.34));
    li.insert(li.end(), Item("C S400", 9988, 499.95));
    li.sort(comp_by_value);
    reverse(li.begin(), li.end());
    print(li.begin(), li.end());

    cout << "\nremove two items identified by name\n";
    list<Item>::iterator li_it = find_if(li.begin(), li.end(), Find_by_name("GoPro"));
    li.erase(li_it);
    li_it = find_if(li.begin(), li.end(), Find_by_name("Xbox"));
    li.erase(li_it);
    print(li.begin(), li.end());

    cout << "\nremove two tems identified by iid\n";
    li_it = find_if(li.begin(), li.end(), Find_by_iid(14910));
    li.erase(li_it);
    li_it = find_if(li.begin(), li.end(), Find_by_iid(754));
    li.erase(li_it);
    print(li.begin(), li.end());
}

void read_pair(map<string, int> &msi)
{
    string s;
    int i;
    cin >> s;
    if (!cin)
    {
        error("Problem reading from cin");
    }
    cin >> i;
    if (!cin)
    {
        error("Problem reading from cin");
    }
    msi[s] = i;
}

template<typename T, typename U>
ostream &operator<<(ostream &os, const pair<T, U> &p)
{
    os << setw(12) << left << p.first << '\t' << p.second;
    return os;
}

template<typename T>
class Map_add
{
public:
    T operator()(const T &v, const pair<string, T> &p)
    {
        return v + p.second;
    }
};

void f3()
{
    map<string, int> msi;

    msi["lecture"] = 21;
    msi["university"] = 35;
    msi["education"] = 15;
    msi["school"] = 99;
    msi["kindergarten"] = 105;
    msi["river"] = 5;
    msi["city"] = 10;
    msi["capital"] = 70;
    msi["software"] = 88;
    msi["hardware"] = 43;

    print(msi.begin(), msi.end());

    typedef map<string, int>::const_iterator MI;
    MI p = msi.begin();
    while (p != msi.end())
    {
        p = msi.erase(p);
    }
    cout << "Size of map after deleting: " << msi.size() << '\n';

    cout << "Enter 10 (string,int) pairs, separated by space:\n";
    for (int i = 0; i < 10; ++i)
    {
        read_pair(msi);
    }

    cout << '\n';
    print(msi.begin(), msi.end());

    int msi_sum = 0;
    msi_sum = accumulate(msi.begin(), msi.end(), msi_sum, Map_add<int>());
    cout << "\nSum of all ints in msi: " << msi_sum << '\n';

    map<int, string> mis;

    for (p = msi.begin(); p != msi.end(); ++p)
    {
        mis[p->second] = p->first;
    }

    cout << "\nContents of mis:\n";
    print(mis.begin(), mis.end());
}

template<typename T>
class Less_than
{
private:
    T v;
public:
    Less_than(const T &val) : v(val) { }
    bool operator()(const T &x) const
    {
        return x < v;
    }
};

void f4()
{
    const string fname = "ch21_d01_in2.txt";
    ifstream ifs(fname.c_str());
    if (!ifs)
    {
        error("can't open " + fname);
    }
    vector<double> vd;
    double d;
    while (ifs >> d)
    {
        vd.push_back(d);
    }

    cout << "vd:\n";
    print(vd.begin(), vd.end());

    vector<int> vi(vd.size());
    copy(vd.begin(), vd.end(), vi.begin());

    cout << "\n(vd,vi) pairs:\n";
    for (int i = 0; i < vd.size(); ++i)
    {
        cout << '(' << vd[i] << ',' << vi[i] << ")\n";
    }

    double sum_vd = 0;
    sum_vd = accumulate(vd.begin(), vd.end(), sum_vd);
    cout << "\nSum of the elements of vd: " << sum_vd << '\n';

    int sum_vi = 0;
    sum_vi = accumulate(vi.begin(), vi.end(), sum_vi);
    cout << "Difference of sum_vd and sum_vi: " << sum_vd - sum_vi << '\n';

    reverse(vd.begin(), vd.end());
    cout << "\nvd after reverse:\n";
    print(vd.begin(), vd.end());

    double vd_mean = sum_vd / vd.size();
    cout << "\nMean value of elements in vd: " << vd_mean << '\n';

    vector<double> vd2(count_if(vd.begin(), vd.end(), Less_than<double>(vd_mean)));
    copy_if(vd.begin(), vd.end(), vd2.begin(), Less_than<double>(vd_mean));
    cout << "\nvd2:\n";
    print(vd2.begin(), vd2.end());

    sort(vd.begin(), vd.end());
    cout << "\nAfter sort, vd:\n";
    print(vd.begin(), vd.end());
}

int main()
{
    try
    {
        f1();
        f2();
        f3();
        f4();
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Cards 14910 25.0
Fuji 3484 10.0
Call 2517 10.0
Lol 153 17.99
Hat 162 399.99
GoPro 667 49.95
Xbox 135 39.99
WhatIf 368 349.0
Fleece 223 39.99
Beanie 754 2.99

cat ch21_d01_in2.txt
25.0
10.0
10.0
17.99
399.99
49.95
39.99
349.0
39.99
2.99
3.14
2.17
64.2
55.1
91.1
32.1

ch21_d01
First round: vector
fill with ten items from file
Cards   14910   25
Fuji    3484    10
Call    2517    10
Lol     153     17.99
Hat     162     399.99
GoPro   667     49.95
Xbox    135     39.99
WhatIf  368     349
Fleece  223     39.99
Beanie  754     2.99

sort by name
Beanie  754     2.99
Call    2517    10
Cards   14910   25
Fleece  223     39.99
Fuji    3484    10
GoPro   667     49.95
Hat     162     399.99
Lol     153     17.99
WhatIf  368     349
Xbox    135     39.99

sort by iid
Xbox    135     39.99
Lol     153     17.99
Hat     162     399.99
Fleece  223     39.99
WhatIf  368     349
GoPro   667     49.95
Beanie  754     2.99
Call    2517    10
Fuji    3484    10
Cards   14910   25

sort by value, print in decreasing order
Hat     162     399.99
WhatIf  368     349
GoPro   667     49.95
Fleece  223     39.99
Xbox    135     39.99
Cards   14910   25
Lol     153     17.99
Fuji    3484    10
Call    2517    10
Beanie  754     2.99

insert two items, sort by value, print in decreasing order
C S400  9988    499.95
Hat     162     399.99
WhatIf  368     349
GoPro   667     49.95
Xbox    135     39.99
Fleece  223     39.99
Cards   14910   25
Lol     153     17.99
Horsesh 99      12.34
Call    2517    10
Fuji    3484    10
Beanie  754     2.99

remove two items identified by name
C S400  9988    499.95
Hat     162     399.99
WhatIf  368     349
Fleece  223     39.99
Cards   14910   25
Lol     153     17.99
Horsesh 99      12.34
Call    2517    10
Fuji    3484    10
Beanie  754     2.99

remove two tems identified by iid
C S400  9988    499.95
Hat     162     399.99
WhatIf  368     349
Fleece  223     39.99
Lol     153     17.99
Horsesh 99      12.34
Call    2517    10
Fuji    3484    10

Second round: list
fill with ten items from file
Cards   14910   25
Fuji    3484    10
Call    2517    10
Lol     153     17.99
Hat     162     399.99
GoPro   667     49.95
Xbox    135     39.99
WhatIf  368     349
Fleece  223     39.99
Beanie  754     2.99

sort by name
Beanie  754     2.99
Call    2517    10
Cards   14910   25
Fleece  223     39.99
Fuji    3484    10
GoPro   667     49.95
Hat     162     399.99
Lol     153     17.99
WhatIf  368     349
Xbox    135     39.99

sort by iid
Xbox    135     39.99
Lol     153     17.99
Hat     162     399.99
Fleece  223     39.99
WhatIf  368     349
GoPro   667     49.95
Beanie  754     2.99
Call    2517    10
Fuji    3484    10
Cards   14910   25

sort by value, print in decreasing order
Hat     162     399.99
WhatIf  368     349
GoPro   667     49.95
Fleece  223     39.99
Xbox    135     39.99
Cards   14910   25
Lol     153     17.99
Fuji    3484    10
Call    2517    10
Beanie  754     2.99

insert two items, sort by value, print in decreasing order
C S400  9988    499.95
Hat     162     399.99
WhatIf  368     349
GoPro   667     49.95
Xbox    135     39.99
Fleece  223     39.99
Cards   14910   25
Lol     153     17.99
Horsesh 99      12.34
Call    2517    10
Fuji    3484    10
Beanie  754     2.99

remove two items identified by name
C S400  9988    499.95
Hat     162     399.99
WhatIf  368     349
Fleece  223     39.99
Cards   14910   25
Lol     153     17.99
Horsesh 99      12.34
Call    2517    10
Fuji    3484    10
Beanie  754     2.99

remove two tems identified by iid
C S400  9988    499.95
Hat     162     399.99
WhatIf  368     349
Fleece  223     39.99
Lol     153     17.99
Horsesh 99      12.34
Call    2517    10
Fuji    3484    10
capital         70
city            10
education       15
hardware        43
kindergarten    105
lecture         21
river           5
school          99
software        88
university      35
Size of map after deleting: 0
Enter 10 (string,int) pairs, separated by space:
Mike 23 Pence 55 Peter 66 Smith 35 Hello 87 World 99 Water 101 Flower 32 Apple 123 Orange 36

Apple           123
Flower          32
Hello           87
Mike            23
Orange          36
Pence           55
Peter           66
Smith           35
Water           101
World           99

Sum of all ints in msi: 657

Contents of mis:
23              Mike
32              Flower
35              Smith
36              Orange
55              Pence
66              Peter
87              Hello
99              World
101             Water
123             Apple
vd:
25
10
10
17.99
399.99
49.95
39.99
349
39.99
2.99
3.14
2.17
64.2
55.1
91.1
32.1

(vd,vi) pairs:
(25,25)
(10,10)
(10,10)
(17.99,17)
(399.99,399)
(49.95,49)
(39.99,39)
(349,349)
(39.99,39)
(2.99,2)
(3.14,3)
(2.17,2)
(64.2,64)
(55.1,55)
(91.1,91)
(32.1,32)

Sum of the elements of vd: 1192.71
Difference of sum_vd and sum_vi: 6.71

vd after reverse:
32.1
91.1
55.1
64.2
2.17
3.14
2.99
39.99
349
39.99
49.95
399.99
17.99
10
10
25

Mean value of elements in vd: 74.5444

vd2:
32.1
55.1
64.2
2.17
3.14
2.99
39.99
39.99
49.95
17.99
10
10
25

After sort, vd:
2.17
2.99
3.14
10
10
17.99
25
32.1
39.99
39.99
49.95
55.1
64.2
91.1
349
399.99

ch21_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template<typename In, typename T>
int my_count(In first, In last, const T &val)
{
    int ctr = 0;
    while (first != last)
    {
        if (*first == val)
        {
            ++ctr;
        }
        ++first;
    }
    return ctr;
}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);

    try
    {
        vector<int> vi;
        for (int i = 0; i < 30; ++i)
        {
            vi.push_back(nrand_two(0, 100, engine));
        }
        cout << "vi:\n";
        cout << vi << endl;
        cout << "Enter value for which you want to know the count, -1 to exit: ";
        int val;
        while (cin >> val)
        {
            if (val == -1)
            {
                break;
            }
            int ctr = my_count(vi.begin(), vi.end(), val);
            cout << val << " is " << ctr << " time" << (ctr != 1 ? "s " : " ") << "in vi.\n";
            cout << "Enter value for which you want to know the count, -1 to exit: ";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
vi:
{ 66, 68, 94, 15, 41, 13, 90, 46, 6, 14, 75, 74, 5, 11, 49, 3, 70, 67, 13, 94, 89, 33, 84, 33, 8, 66, 25, 40, 64, 40 }
Enter value for which you want to know the count, -1 to exit: 94
94 is 2 times in vi.
Enter value for which you want to know the count, -1 to exit: 33
33 is 2 times in vi.
Enter value for which you want to know the count, -1 to exit: 25
25 is 1 time in vi.
Enter value for which you want to know the count, -1 to exit: -1

ch21_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template<typename In, typename T>
int my_count(In first, In last, const T &val)
{
    int ctr = 0;
    while (first != last)
    {
        if (*first == val)
        {
            ++ctr;
        }
        ++first;
    }
    return ctr;
}


template<typename In, typename Pred>
int my_count_if(In first, In last, const Pred &p)
{
    int ctr = 0;
    while (first != last)
    {
        if (p(*first))
        {
            ++ctr;
        }
        ++first;
    }
    return ctr;
}

template<typename T>
class Less_than
{
private:
    T val;
public:
    Less_than(const T &v) : val(v) { }
    bool operator()(const T &x) const
    {
        return x < val;
    }
};

template<typename T>
class Greater_than
{
private:
    T val;
public:
    Greater_than(const T &v) : val(v) { }
    bool operator()(const T &x) const
    {
        return x > val;
    }
};

bool odd(int i)
{
    return i % 2 != 0;
}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);

    try
    {
        vector<int> vi;
        for (int i = 0; i < 30; ++i)
        {
            vi.push_back(nrand_two(0, 100, engine));
        }
        cout << "vi:\n";
        cout << vi << endl;
        cout << "Enter value for less than count, -1 to exit: ";
        int val;
        while (cin >> val)
        {
            if (val == -1)
            {
                break;
            }
            int ctr = my_count_if(vi.begin(), vi.end(), Less_than<int>(val));
            cout << "There " << (ctr == 1 ? "is " : "are ") << ctr << " value" << (ctr == 1 ? " " : "s ")
                 << "less than " << val << " in vi.\n";
            cout << "Enter value for less than count, -1 to exit: ";
        }

        cout << "Enter value for greater than count, -1 to exit: ";
        while (cin >> val)
        {
            if (val == -1)
            {
                break;
            }
            int ctr = my_count_if(vi.begin(), vi.end(), Greater_than<int>(val));
            cout << "There " << (ctr == 1 ? "is " : "are ") << ctr << " value" << (ctr == 1 ? " " : "s ")
                 << "greater than " << val << " in vi.\n";
             cout << "Enter value for greater than count, -1 to exit: ";
        }

        int ctr = my_count_if(vi.begin(), vi.end(), odd);
        cout << "There are " << ctr << " odd values in vi.\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
vi:
{ 47, 96, 40, 50, 31, 87, 46, 89, 38, 13, 2, 20, 28, 48, 22, 0, 89, 49, 69, 1, 82, 75, 6, 78, 70, 96, 80, 67, 89, 89 }
Enter value for less than count, -1 to exit: 80
There are 21 values less than 80 in vi.
Enter value for less than count, -1 to exit: -1
Enter value for greater than count, -1 to exit: 80
There are 8 values greater than 80 in vi.
Enter value for greater than count, -1 to exit: -1
There are 13 odd values in vi.

ch21_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template<typename In, typename T>
int my_count(In first, In last, const T &val)
{
    int ctr = 0;
    while (first != last)
    {
        if (*first == val)
        {
            ++ctr;
        }
        ++first;
    }
    return ctr;
}


template<typename In, typename Pred>
int my_count_if(In first, In last, const Pred &p)
{
    int ctr = 0;
    while (first != last)
    {
        if (p(*first))
        {
            ++ctr;
        }
        ++first;
    }
    return ctr;
}

template<typename T>
class Less_than
{
private:
    T val;
public:
    Less_than(const T &v) : val(v) { }
    bool operator()(const T &x) const
    {
        return x < val;
    }
};

template<typename T>
class Greater_than
{
private:
    T val;
public:
    Greater_than(const T &v) : val(v) { }
    bool operator()(const T &x) const
    {
        return x > val;
    }
};

bool odd(int i)
{
    return i % 2 != 0;
}

template<typename In, typename T>
In my_find2(In first, In last, const T &val)
{
    In p = first;
    while (p != last)
    {
        if (*p == val)
        {
            return p;
        }
        ++p;
    }

    if (*p == val)
    {
        return p;
    }

    return first;
}

template<typename In, typename T>
int my_count2(In first, In last, const T &val)
{
    int count = 0;
    while (first != last)
    {
        if (*first == val)
        {
            ++count;
        }
        ++first;
    }
    if (*first == val)
    {
        ++count;
    }
    return count;
}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);

    try
    {
        vector<int> vi;
        for (int i = 0; i < 30; ++i)
        {
            vi.push_back(nrand_two(0, 100, engine));
        }
        cout << "vi:\n";
        cout << vi << endl;
        typedef vector<int>::iterator vi_it;
        cout << "Enter int to search for and count (-1 to quit): ";
        int val;
        while (cin >> val)
        {
            if (val == -1)
            {
                break;
            }
            vi_it it = my_find2(vi.begin(), vi.end() - 1, val);
            int count = my_count2(vi.begin(), vi.end() - 1, val);
            if (*it != val)
            {
                cout << val << " is not in vi.\n";
            }
            else
            {
                cout << val << " is at index " << it - vi.begin()
                     << " (occurs " << count << " time" << (count == 1 ? "" : "s")
                     << ").\n";
            }
            cout << "Enter int to search for and count (-1 to quit): ";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
vi:
{ 80, 94, 92, 38, 58, 99, 90, 21, 53, 77, 89, 15, 4, 82, 36, 82, 16, 37, 92, 86, 20, 61, 97, 51, 64, 56, 8, 81, 86, 67 }
Enter int to search for and count (-1 to quit): 82
82 is at index 13 (occurs 2 times).
Enter int to search for and count (-1 to quit): -1

ch21_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


class Fruit
{
public:
    string name;
    int count;
    double unit_price;
    Fruit(const string &n, int c, double up = 0.0) : name(n), count(c), unit_price(up) { }
};

ostream &operator<<(ostream &os, const Fruit *f)
{
    os << setw(12) << left << f->name << '\t' << f->count << '\t' << f->unit_price;
    return os;
}

class Fruit_comparison
{
public:
    bool operator()(const Fruit *a, const Fruit *b) const
    {
        return a->name < b->name;
    }
};

int main()
{
    try
    {
        set<Fruit *, Fruit_comparison> inventory;
        inventory.insert(new Fruit("Quince", 5));
        inventory.insert(new Fruit("Apple", 200, 0.37));
        inventory.insert(new Fruit("Orange", 150, 0.45));
        inventory.insert(new Fruit("Grape", 13, 0.99));
        inventory.insert(new Fruit("Kiwi", 512, 1.15));
        inventory.insert(new Fruit("Plum", 750, 2.33));

        typedef set<Fruit *, Fruit_comparison>::const_iterator Si;
        for (Si p = inventory.begin(); p != inventory.end(); ++p)
        {
            cout << *p << '\n';
        }
        cout << "inventory.size() = " << inventory.size() << endl;
        for (Si p = inventory.begin(); p != inventory.end(); ++p)
        {
            delete *p;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Apple           200     0.37
Grape           13      0.99
Kiwi            512     1.15
Orange          150     0.45
Plum            750     2.33
Quince          5       0
inventory.size() = 6

ch21_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template<typename Ran, typename T>
bool my_binary_search(Ran first, Ran last, const T &val)
{
    if (first == last)
    {
        return false;
    }
    Ran p = first + (last - first) / 2;
    if (*p == val)
    {
        return true;
    }
    Ran p2 = p;
    ++p2;
    if (*p < val && p2 != last)
    {
        return my_binary_search(p2, last, val);
    }
    if (*p > val)
    {
        return my_binary_search(first, p, val);
    }
    return false;
}

template<typename Bid>
Bid middle(Bid first, Bid last)
{
    if (first == last)
    {
        error("first==last in middle");
    }

    int dist = 0;
    Bid p = first;
    while (p != last)
    {
        ++p;
        ++dist;
    }
    p = first;
    for (int i = 0; i < dist / 2; i++)
    {
        p++;
    }
    return p;
}

template<typename Bid, typename T>
bool my_binary_bid_search(Bid first, Bid last, const T &val)
{
    if (first == last)
    {
        return false;
    }
    Bid p = middle(first, last);
    if (*p == val)
    {
        return true;
    }
    Bid p2 = p;
    ++p2;
    if (*p < val && p2 != last)
    {
        return my_binary_bid_search(p2, last, val);
    }
    if (*p > val)
    {
        return my_binary_bid_search(first, p, val);
    }
    return false;
}

template<typename Iter>
void print(Iter first, Iter last)
{
    while (first != last)
    {
        cout << *first << '\n';
        ++first;
    }
}

int main()
{
    try
    {
        vector<int> vi;
        for (int i = 0; i < 20; ++i)
        {
            vi.push_back(2 * i);
        }
        cout << "Vector:\n";
        print(vi.begin(), vi.end());

        cout << "Enter int to find (-1 to exit): ";
        int i;
        while (cin >> i && i != -1)
        {
            cout << i << " is " << (my_binary_search(vi.begin(), vi.end(), i) ? "" : "not ") << "in vi.\n";
            cout << "Enter int to find (-1 to exit): ";
        }

        list<int> li(20);
        copy(vi.begin(), vi.end(), li.begin());
        cout << "\nList:\n";
        print(li.begin(), li.end());

        cout << "Enter int to find (-1 to exit): ";
        while (cin >> i && i != -1)
        {
            cout << i << " is " << (my_binary_bid_search(li.begin(), li.end(), i) ? "" : "not ") << "in li.\n";
            cout << "Enter int to find (-1 to exit): ";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Vector:
0
2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
Enter int to find (-1 to exit): 22
22 is in vi.
Enter int to find (-1 to exit): 23
23 is not in vi.
Enter int to find (-1 to exit): 25
25 is not in vi.
Enter int to find (-1 to exit): 26
26 is in vi.
Enter int to find (-1 to exit): 27
27 is not in vi.
Enter int to find (-1 to exit): 28
28 is in vi.
Enter int to find (-1 to exit): 29
29 is not in vi.
Enter int to find (-1 to exit): 30
30 is in vi.
Enter int to find (-1 to exit): -1

List:
0
2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
Enter int to find (-1 to exit): 32
32 is in li.
Enter int to find (-1 to exit): 33
33 is not in li.
Enter int to find (-1 to exit): 31
31 is not in li.
Enter int to find (-1 to exit): 36
36 is in li.
Enter int to find (-1 to exit): 35
35 is not in li.
Enter int to find (-1 to exit): 38
38 is in li.
Enter int to find (-1 to exit): 39
39 is not in li.
Enter int to find (-1 to exit): -1

ch21_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;
using std::make_pair;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main()
{
    try
    {
        map<string, int> words;

        const string ifname = "ch21_p08_in.txt";
        ifstream ifs(ifname.c_str());
        if (!ifs)
        {
            error("couldn't open " + ifname);
        }
        string s;
        while (ifs >> s)
        {
            ++words[s];
        }

        vector<pair<int, string> > v_words;

        typedef map<string, int>::const_iterator Iter;
        for (Iter p = words.begin(); p != words.end(); ++p)
        {
            v_words.push_back(make_pair(p->second, p->first));
        }
        sort(v_words.begin(), v_words.end());

        typedef vector<pair<int, string> >::const_iterator V_iter;
        for (V_iter p = v_words.begin(); p != v_words.end(); ++p)
        {
            cout << p->first << ": " << p->second << '\n';
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
1: C
1: C,
1: Except
1: In
1: addition
1: and
1: by
1: defining
1: designed
1: details,
1: efficient
1: enjoyable
1: flexible
1: general
1: language
1: language.
1: make
1: minor
1: more
1: new
1: of
1: programmer.
1: provided
1: provides
1: purpose
1: serious
1: superset
1: types.
2: a
2: facilities
2: is
2: to
3: C++
3: for
3: programming
3: the

cat ch21_p08_in.txt
C++ is a general purpose programming language designed to make
programming more enjoyable for the serious programmer. Except for minor
details, C++ is a superset of the C programming language. In addition to
the facilities provided by C, C++ provides flexible and efficient facilities
for defining new types.

ch21_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::merge;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;
using std::make_pair;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Day
{
public:
    explicit Day(int d) : val(d) { }
    int val;
};

ostream &operator<<(ostream &os, const Day &d)
{
    os << d.val;
    return os;
}

class Month
{
public:
    explicit Month(int m) : val(m) { }
    int val;
};

ostream &operator<<(ostream &os, const Month &m)
{
    os << m.val;
    return os;
}

class Year
{
public:
    explicit Year(int y) : val(y) { }
    int val;
};

ostream &operator<<(ostream &os, const Year &y)
{
    os << y.val;
    return os;
}

class Date
{
private:
    Day d;
    Month m;
    Year y;
public:
    Date() : d(1), m(1), y(1970) { }
    Date(const Day &day, const Month &month, const Year &year) : d(day), m(month), y(year) { }
    Date(const Date &r) : d(r.d), m(r.m), y(r.y) { }
    const Day &day() const
    {
        return d;
    }
    const Month &month() const
    {
        return m;
    }
    const Year &year() const
    {
        return y;
    }
};

ostream &operator<<(ostream &os, const Date &date)
{
    os << date.day() << '.' << date.month() << '.' << date.year();
    return os;
}

istream &operator>>(istream &is, Date &date)
{
    int d;
    int m;
    int y;
    char ch1;
    char ch2;
    is >> d;
    if (!is)
    {
        return is;
    }
    is >> ch1;
    if (!is)
    {
        return is;
    }
    is >> m;
    if (!is)
    {
        return is;
    }
    is >> ch2;
    if (!is)
    {
        return is;
    }
    is >> y;
    if (!is)
    {
        return is;
    }
    if (ch1 != '.' || ch2 != '.')
    {
        is.clear(std::ios_base::failbit);
        return is;
    }
    date = Date(Day(d), Month(m), Year(y));
    return is;
}

class Purchase
{
private:
    string n;
    double up;
    int c;
public:
    Purchase() : n(""), up(0.0), c(0) { }
    Purchase(const string &name, double unit_price, int count) : n(name), up(unit_price), c(count) { }
    const string &name() const
    {
        return n;
    }
    double unit_price() const
    {
        return up;
    }
    int count() const
    {
        return c;
    }
};

ostream &operator<<(ostream &os, const Purchase &p)
{
    os << p.name() << " | " << p.unit_price() << " | " << p.count();
    return os;
}

istream &operator>>(istream &is, Purchase &p)
{
    string name;
    getline(is, name, '|');
    if (!is)
    {
        return is;
    }
    if (name.size() == 0)
    {
        is.clear(std::ios_base::failbit);
        return is;
    }
    name.pop_back();
    double unit_price;
    char ch2;
    int count;
    is >> unit_price;
    if (!is)
    {
        return is;
    }
    is >> ch2;
    if (!is)
    {
        return is;
    }
    is >> count;
    if (!is)
    {
        return is;
    }
    if (ch2 != '|')
    {
        is.clear(std::ios_base::failbit);
        return is;
    }
    p = Purchase(name, unit_price, count);
    return is;
}

class Order
{
private:
    string n;
    string addr;
    Date d;
    vector<Purchase> vp;
public:
    Order() : n(), addr(), d(), vp() { }
    Order(const string &name, const string &address, const Date &date, const vector<Purchase> &vpurchases)
        : n(name), addr(address), d(date), vp(vpurchases) { }
    const string &name() const
    {
        return n;
    }
    const string &address() const
    {
        return addr;
    }
    const Date &date() const
    {
        return d;
    }
    int n_purchases() const
    {
        return vp.size();
    }
    const Purchase &purchase(int i) const
    {
        return vp[i];
    }
};

ostream &operator<<(ostream &os, const Order &o)
{
    os << o.name() << '\n' << o.address() << '\n' << o.date() << '\n';
    for (int i = 0; i < o.n_purchases(); ++i)
    {
        os << o.purchase(i) << '\n';
    }
    return os;
}

istream &operator>>(istream &is, Order &o)
{
    char ch;
    while (is >> ch)
    {
        if (ch != '\n')
        {
            is.unget();
            break;
        }
    }
    string name;
    getline(is, name, '\n');
    if (!is)
    {
        return is;
    }
    string address;
    getline(is, address, '\n');
    if (!is)
    {
        return is;
    }
    Date date;
    is >> date;
    if (!is)
    {
        return is;
    }
    is.ignore();
    string line;
    vector<Purchase> purchases;
    while (getline(is, line, '\n') && line != "")
    {
        Purchase purchase;
        istringstream iss(line);
        iss >> purchase;
        purchases.push_back(purchase);
    }
    o = Order(name, address, date, purchases);
    return is;
}

template<typename T>
class Sort_by_name
{
public:
    bool operator()(const T &a, const T &b) const
    {
        return a.name() < b.name();
    }
};

template<typename T>
class Sort_by_address
{
public:
    bool operator()(const T &a, const T &b) const
    {
        return a.address() < b.address();
    }
};

template<typename Cont>
void read_orders_from_file(Cont &c, const string &fname)
{
    ifstream ifs(fname.c_str());
    if (!ifs)
    {
        error("can't open file " + fname);
    }
    Order o;
    while (ifs >> o)
    {
        c.push_back(o);
    }
}

template<typename Iter>
void write_orders_to_file(Iter first, Iter last, const string &fname)
{
    ofstream ofs(fname.c_str());
    if (!ofs)
    {
        error("can't open file " + fname);
    }
    while (first != last)
    {
        ofs << *first << '\n';
        ++first;
    }
}

int main()
{
    try
    {
        const string ifname1 = "ch21_p09_in1.txt";
        vector<Order> vo;
        read_orders_from_file(vo, ifname1);

        sort(vo.begin(), vo.end(), Sort_by_name<Order>());
        for (int i = 0; i < vo.size(); ++i)
        {
            cout << vo[i] << '\n';
        }

        const string ofname1 = "ch21_p09_out1.txt";
        write_orders_to_file(vo.begin(), vo.end(), ofname1);

        const string ifname2 = "ch21_p09_in2.txt";
        list<Order> lo;
        read_orders_from_file(lo, ifname2);

        cout << "\n";
        lo.sort(Sort_by_address<Order>());
        typedef list<Order>::iterator Liter;
        for (Liter it = lo.begin(); it != lo.end(); ++it)
        {
            cout << *it << '\n';
        }

        const string ofname2 = "ch21_p09_out2.txt";
        write_orders_to_file(lo.begin(), lo.end(), ofname2);

        lo.sort(Sort_by_name<Order>());
        vector<Order> vo_merge(vo.size() + lo.size());
        merge(vo.begin(), vo.end(), lo.begin(), lo.end(), vo_merge.begin(), Sort_by_name<Order>());
        const string ofname3 = "ch21_p09_out3.txt";
        write_orders_to_file(vo_merge.begin(), vo_merge.end(), ofname3);

        set<Order, Sort_by_name<Order>> so;
        typedef vector<Order>::iterator Viter;
        for (Viter it = vo_merge.begin(); it != vo_merge.end(); ++it)
        {
            so.insert(*it);
        }

        cout << "\n";
        double val_t = 0;
        for (set<Order>::iterator it = so.begin(); it != so.end(); ++it)
        {
            cout << *it << '\n';
            for (int i = 0; i < (*it).n_purchases(); ++i)
            {
                val_t += (*it).purchase(i).count() * (*it).purchase(i).unit_price();
            }
            cout << "Running total so far: " << val_t << "\n\n";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Ardelia Allington
16 Warren Close, Ryton-on-Dunsmore, Coventry, Warwickshire CV8 3JZ, UK
20.11.2014
Frozen Little Golden Book | 2.17 | 3
Humans of New York | 17.99 | 3

Babette Brennan
4 Livera Street, Evanton, Dingwall, Highland IV16, UK
6.2.2014
Yes Please | 14.5 | 2
The Book with No Pictures | 10.79 | 5
Ultimate Sticker Book: Frozen | 4.19 | 5

Cliff Cantin
1 Bealings Road, Martlesham, Woodbridge, Suffolk IP12 4RW, UK
15.1.2014
Diary of a Wimpy Kid | 7.75 | 2

Emilee Eiler
29 Clayfield Road, Bretforton, Evesham, Worcestershire WR11 7HS, UK
26.9.2014
What If? | 14.4 | 5

Ha Hollowell
21 Heddon Place, Birmingham, West Midlands B7 4EX, UK
23.2.2014
Laugh-Out-Loud Jokes for Kids | 2.99 | 1
Unbroken: A World War II Story | 9.6 | 5

Lucius Legrand
16 Mundys Field, Ruan Minor, Helston, Cornwall TR12 7LF, UK
1.1.2013
Yes Please | 14.5 | 2
Minecraft: The Complete Handbook | 19.18 | 1

Matt Manahan
9 Haslam Crescent, Sheffield, South Yorkshire S8 7GT, UK
21.5.2013
Knock-Knock Jokes for Kids | 3.23 | 1
Killing Patton | 15.41 | 2
Thug Kitchen | 14.9 | 4

Nicolette New
9-11 Nevill Road, Brighton and Hove, Brighton, East Sussex BN2 7HH, UK
17.6.2013
The Day the Crayons Quit | 9.12 | 5

Tyler Tevis
New Road, Worcester, Worcestershire WR2, UK
6.4.2013
The Boys in the Boat | 10.2 | 2


Cliff Cantin
1 Bealings Road, Martlesham, Woodbridge, Suffolk IP12 4RW, UK
15.1.2014
Diary of a Wimpy Kid | 7.75 | 2

Augustus Amyx
17 Manner Street, Macduff, Aberdeenshire AB44 1SE, UK
28.4.2014
Ultra Pro 25.9 | 8.29 | 2

Bari Barnette
1A Orchard Castle, Cardiff, Cardiff CF14 9BA, UK
12.8.2013
FlipBelt | 27.19 | 1
Spalding NBA Street Basketball | 10.59 | 1

Ha Hollowell
21 Heddon Place, Birmingham, West Midlands B7 4EX, UK
23.2.2014
Laugh-Out-Loud Jokes for Kids | 2.99 | 1
Unbroken: A World War II Story | 9.6 | 5

Charolette Cusick
352-354 Birmingham Road, Sutton Coldfield, West Midlands B72 1YH, UK
4.7.2013
Lifestraw Personal Water Filter | 19.9 | 3
Zipp A-Frame Hand Warmer | 9.83 | 2
New Era On field Hat | 14.4 | 1

Logan Laino
4 Denmark Rise, North Cave, Brough, East Riding of Yorkshire HU15 2NB, UK
6.3.2013
Diary of a Wimpy Kid | 7.75 | 5
Killing Patton | 15.41 | 5

Miguelina Marinelli
5 Stevens Place, Gourock, Inverclyde PA19 1YY, UK
16.2.2014
Wrist Wraps + Lifting Straps | 16.95 | 3
Razor A Kick Scooter | 27.72 | 3
Tac Force TF-705 Series | 3.96 | 2
Victorinox Swiss Army Classic | 9.99 | 2

Bernita Biggerstaff
New Forest National Park, 1 Yewtree Cottages, Lyndhurst, Hampshire SO43 7AY, UK
25.4.2014
Nalgene Tritan Wide Mouth | 5.75 | 3
SoundAsleep Dream Series Mattress | 119.95 | 2
Replacement Wrist Band | 0.65 | 1

Clarine Chance
RAF Mildenhall, 139A Lancaster Road, Beck Row, Bury Saint Edmunds, Suffolk IP28 8HE, UK
26.10.2013
Zippo Lighter Fluid | 7.09 | 3
Polar FT4 HRM | 50.2 | 2
SKLZ Pro Mini Basketball Hoop | 19.99 | 1


Ardelia Allington
16 Warren Close, Ryton-on-Dunsmore, Coventry, Warwickshire CV8 3JZ, UK
20.11.2014
Frozen Little Golden Book | 2.17 | 3
Humans of New York | 17.99 | 3

Running total so far: 60.48

Augustus Amyx
17 Manner Street, Macduff, Aberdeenshire AB44 1SE, UK
28.4.2014
Ultra Pro 25.9 | 8.29 | 2

Running total so far: 77.06

Babette Brennan
4 Livera Street, Evanton, Dingwall, Highland IV16, UK
6.2.2014
Yes Please | 14.5 | 2
The Book with No Pictures | 10.79 | 5
Ultimate Sticker Book: Frozen | 4.19 | 5

Running total so far: 180.96

Bari Barnette
1A Orchard Castle, Cardiff, Cardiff CF14 9BA, UK
12.8.2013
FlipBelt | 27.19 | 1
Spalding NBA Street Basketball | 10.59 | 1

Running total so far: 218.74

Bernita Biggerstaff
New Forest National Park, 1 Yewtree Cottages, Lyndhurst, Hampshire SO43 7AY, UK
25.4.2014
Nalgene Tritan Wide Mouth | 5.75 | 3
SoundAsleep Dream Series Mattress | 119.95 | 2
Replacement Wrist Band | 0.65 | 1

Running total so far: 476.54

Charolette Cusick
352-354 Birmingham Road, Sutton Coldfield, West Midlands B72 1YH, UK
4.7.2013
Lifestraw Personal Water Filter | 19.9 | 3
Zipp A-Frame Hand Warmer | 9.83 | 2
New Era On field Hat | 14.4 | 1

Running total so far: 570.3

Clarine Chance
RAF Mildenhall, 139A Lancaster Road, Beck Row, Bury Saint Edmunds, Suffolk IP28 8HE, UK
26.10.2013
Zippo Lighter Fluid | 7.09 | 3
Polar FT4 HRM | 50.2 | 2
SKLZ Pro Mini Basketball Hoop | 19.99 | 1

Running total so far: 711.96

Cliff Cantin
1 Bealings Road, Martlesham, Woodbridge, Suffolk IP12 4RW, UK
15.1.2014
Diary of a Wimpy Kid | 7.75 | 2

Running total so far: 727.46

Emilee Eiler
29 Clayfield Road, Bretforton, Evesham, Worcestershire WR11 7HS, UK
26.9.2014
What If? | 14.4 | 5

Running total so far: 799.46

Ha Hollowell
21 Heddon Place, Birmingham, West Midlands B7 4EX, UK
23.2.2014
Laugh-Out-Loud Jokes for Kids | 2.99 | 1
Unbroken: A World War II Story | 9.6 | 5

Running total so far: 850.45

Logan Laino
4 Denmark Rise, North Cave, Brough, East Riding of Yorkshire HU15 2NB, UK
6.3.2013
Diary of a Wimpy Kid | 7.75 | 5
Killing Patton | 15.41 | 5

Running total so far: 966.25

Lucius Legrand
16 Mundys Field, Ruan Minor, Helston, Cornwall TR12 7LF, UK
1.1.2013
Yes Please | 14.5 | 2
Minecraft: The Complete Handbook | 19.18 | 1

Running total so far: 1014.43

Matt Manahan
9 Haslam Crescent, Sheffield, South Yorkshire S8 7GT, UK
21.5.2013
Knock-Knock Jokes for Kids | 3.23 | 1
Killing Patton | 15.41 | 2
Thug Kitchen | 14.9 | 4

Running total so far: 1108.08

Miguelina Marinelli
5 Stevens Place, Gourock, Inverclyde PA19 1YY, UK
16.2.2014
Wrist Wraps + Lifting Straps | 16.95 | 3
Razor A Kick Scooter | 27.72 | 3
Tac Force TF-705 Series | 3.96 | 2
Victorinox Swiss Army Classic | 9.99 | 2

Running total so far: 1269.99

Nicolette New
9-11 Nevill Road, Brighton and Hove, Brighton, East Sussex BN2 7HH, UK
17.6.2013
The Day the Crayons Quit | 9.12 | 5

Running total so far: 1315.59

Tyler Tevis
New Road, Worcester, Worcestershire WR2, UK
6.4.2013
The Boys in the Boat | 10.2 | 2

Running total so far: 1335.99

cat ch21_p09_in1.txt
Lucius Legrand
16 Mundys Field, Ruan Minor, Helston, Cornwall TR12 7LF, UK
01.01.2013
Yes Please | 14.50 | 2
Minecraft: The Complete Handbook | 19.18 | 1

Ha Hollowell
21 Heddon Place, Birmingham, West Midlands B7 4EX, UK
23.02.2014
Laugh-Out-Loud Jokes for Kids | 2.99 | 1
Unbroken: A World War II Story | 9.60 | 5

Emilee Eiler
29 Clayfield Road, Bretforton, Evesham, Worcestershire WR11 7HS, UK
26.09.2014
What If? | 14.40 | 5

Matt Manahan
9 Haslam Crescent, Sheffield, South Yorkshire S8 7GT, UK
21.05.2013
Knock-Knock Jokes for Kids | 3.23 | 1
Killing Patton | 15.41 | 2
Thug Kitchen | 14.90 | 4

Babette Brennan
4 Livera Street, Evanton, Dingwall, Highland IV16, UK
06.02.2014
Yes Please | 14.50 | 2
The Book with No Pictures | 10.79 | 5
Ultimate Sticker Book: Frozen | 4.19 | 5

Cliff Cantin
1 Bealings Road, Martlesham, Woodbridge, Suffolk IP12 4RW, UK
15.01.2014
Diary of a Wimpy Kid | 7.75 | 2

Ardelia Allington
16 Warren Close, Ryton-on-Dunsmore, Coventry, Warwickshire CV8 3JZ, UK
20.11.2014
Frozen Little Golden Book | 2.17 | 3
Humans of New York | 17.99 | 3

Nicolette New
9-11 Nevill Road, Brighton and Hove, Brighton, East Sussex BN2 7HH, UK
17.06.2013
The Day the Crayons Quit | 9.12 | 5

Tyler Tevis
New Road, Worcester, Worcestershire WR2, UK
06.04.2013
The Boys in the Boat | 10.20 | 2

Logan Laino
4 Denmark Rise, North Cave, Brough, East Riding of Yorkshire HU15 2NB, UK
06.03.2013
Diary of a Wimpy Kid | 7.75 | 5
Killing Patton | 15.41 | 5

cat ch21_p09_in2.txt
Ha Hollowell
21 Heddon Place, Birmingham, West Midlands B7 4EX, UK
23.02.2014
Laugh-Out-Loud Jokes for Kids | 2.99 | 1
Unbroken: A World War II Story | 9.60 | 5

Cliff Cantin
1 Bealings Road, Martlesham, Woodbridge, Suffolk IP12 4RW, UK
15.01.2014
Diary of a Wimpy Kid | 7.75 | 2

Logan Laino
4 Denmark Rise, North Cave, Brough, East Riding of Yorkshire HU15 2NB, UK
06.03.2013
Diary of a Wimpy Kid | 7.75 | 5
Killing Patton | 15.41 | 5

Charolette Cusick
352-354 Birmingham Road, Sutton Coldfield, West Midlands B72 1YH, UK
04.07.2013
Lifestraw Personal Water Filter | 19.90 | 3
Zipp A-Frame Hand Warmer | 9.83 | 2
New Era On field Hat | 14.40 | 1

Bari Barnette
1A Orchard Castle, Cardiff, Cardiff CF14 9BA, UK
12.08.2013
FlipBelt | 27.19 | 1
Spalding NBA Street Basketball | 10.59 | 1

Clarine Chance
RAF Mildenhall, 139A Lancaster Road, Beck Row, Bury Saint Edmunds, Suffolk IP28 8HE, UK
26.10.2013
Zippo Lighter Fluid | 7.09 | 3
Polar FT4 HRM | 50.20 | 2
SKLZ Pro Mini Basketball Hoop | 19.99 | 1

Miguelina Marinelli
5 Stevens Place, Gourock, Inverclyde PA19 1YY, UK
16.02.2014
Wrist Wraps + Lifting Straps | 16.95 | 3
Razor A Kick Scooter | 27.72 | 3
Tac Force TF-705 Series | 3.96 | 2
Victorinox Swiss Army Classic | 9.99 | 2

Bernita Biggerstaff
New Forest National Park, 1 Yewtree Cottages, Lyndhurst, Hampshire SO43 7AY, UK
25.04.2014
Nalgene Tritan Wide Mouth | 5.75 | 3
SoundAsleep Dream Series Mattress | 119.95 | 2
Replacement Wrist Band | 0.65 | 1

Augustus Amyx
17 Manner Street, Macduff, Aberdeenshire AB44 1SE, UK
28.04.2014
Ultra Pro 25.9 | 8.29 | 2

Roman Rierson
40 Anyards Road, Cobham, Surrey KT11 2LA, UK
22.11.2014
Black Mountain Resistance Bands | 29.99 | 2

ch21_p13.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

map<string, int> clean_txt(const string &fname)
{
    ifstream ifs(fname);
    if (!ifs)
    {
        error("Can not open file " + fname);
    }
    ostringstream oss;

    char ch;
    while (ifs.get(ch))
    {
        if (ispunct(ch) && ch != '\'')
        {
            ch = ' ';
        }
        oss << char(tolower(ch));
    }

    map<string, int> words;
    istringstream iss(oss.str());
    string w;
    while (iss >> w)
    {
        if (w == "can't")
        {
            ++words["cannot"];
        }
        else if (w == "shan't")
        {
            ++words["shall"];
            ++words["not"];
        }
        else if (w == "won't")
        {
            ++words["will"];
            ++words["not"];
        }
        else if (w == "let's")
        {
            ++words["let"];
            ++words["us"];
        }
        else if (w == "'" || w.size() == 2 && w[0] == '\'')
        {
            // do nothing, don't add word
        }
        else if (w.size() >= 3 && *(w.end() - 2) == '\'')
        {
            switch (w.back())
            {
            case 'd':
                ++words["would"];
                ++words[w.substr(0, w.size() - 2)];
                break;
            case 'm':
                ++words["am"];
                ++words[w.substr(0, w.size() - 2)];
                break;
            case 's':
                ++words["is"];
                ++words[w.substr(0, w.size() - 2)];
                break;
            case 't':
                ++words["not"];
                ++words[w.substr(0, w.size() - 3)];
                break;
            default:
                break;
            }
        }
        else if (w.size() >= 4 && *(w.end() - 3) == '\'')
        {
            switch (*(w.end() - 2))
            {
            case 'l':
                ++words["will"];
                ++words[w.substr(0, w.size() - 3)];
                break;
            case 'r':
                ++words["are"];
                ++words[w.substr(0, w.size() - 3)];
                break;
            case 'v':
                ++words["have"];
                ++words[w.substr(0, w.size() - 3)];
                break;
            default:
                break;
            }
        }
        else
        {
            ++words[w];
        }
    }

    typedef map<string, int>::iterator Iter;
    for (Iter p = words.begin(); p != words.end(); ++p)
    {
        Iter q = p;
        ++q;
        if (q != words.end() && q->first[0] == p->first[0]
                && q->first.size() == p->first.size() + 1
                && q->first == p->first + "s")
        {
            q = words.erase(q);
        }
    }

    return words;
}

int main()
{
    try
    {
        string ifname = "ch21_p13_in.txt";
        map<string, int> words = clean_txt(ifname);
        typedef map<string, int>::iterator Iter;
        for (Iter p = words.begin(); p != words.end(); ++p)
        {
            cout << setw(12) << left << p->first << '\t' << p->second << '\n';
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
cat ch21_p13_in.txt
I'm I'd aren't can't couldn't didn't doesn't don't hadn't hasn't haven't he'd he'll he's I'd I'll I'm I've
isn't it's let's mustn't shan't she'd she'll she's shouldn't that's there's they'd they'll they're
they've we'd we're we've weren't what'll what're what's what've where's who'd who'll who're
who's who've won't wouldn't you'd you'll you're you've

ch21_p13
am              2
are             6
cannot          1
could           1
did             1
do              1
does            1
had             1
has             1
have            7
he              3
i               6
it              1
let             1
must            1
not             15
shall           1
she             3
should          1
that            1
there           1
they            4
us              1
we              3
were            1
what            4
where           1
who             5
will            8
would           9
you             4

ch21_p14.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::copy_if;
using std::count_if;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


namespace Text_query
{
    map<string, int> clean_txt(const string &fname);
    int num_of_occurrences(const string &word, const map<string, int> &clean_txt);
    string most_frequent(const map<string, int> &clean_txt);
    string longest(const map<string, int> &clean_txt);
    string shortest(const map<string, int> &clean_txt);

    class First_char
    {
    private:
        char ch;
    public:
        First_char(char c) : ch(c) { }
        bool operator()(const pair<string, int> &p) const
        {
            return p.first[0] == ch;
        }
    };

    vector<string> start_with(char ch, const map<string, int> &clean_txt);

    class Length
    {
    private:
        int n;
    public:
        Length(int nn) : n(nn) { }
        bool operator()(const pair<string, int> &p) const
        {
            return p.first.size() == n;
        }
    };

    vector<string> has_length(int n, const map<string, int> &clean_txt);
}

namespace Text_query
{
    map<string, int> clean_txt(const string &fname)
    {
        ifstream ifs(fname);
        if (!ifs)
        {
            error("Can not open file " + fname);
        }
        ostringstream oss;

        char ch;
        while (ifs.get(ch))
        {
            if (ispunct(ch) && ch != '\'')
            {
                ch = ' ';
            }
            oss << char(tolower(ch));
        }

        map<string, int> words;
        istringstream iss(oss.str());
        string w;
        while (iss >> w)
        {
            if (w == "can't")
            {
                ++words["cannot"];
            }
            else if (w == "shan't")
            {
                ++words["shall"];
                ++words["not"];
            }
            else if (w == "won't")
            {
                ++words["will"];
                ++words["not"];
            }
            else if (w == "let's")
            {
                ++words["let"];
                ++words["us"];
            }
            else if (w == "'" || w.size() == 2 && w[0] == '\'')
            {
                // do nothing, don't add word
            }
            else if (w.size() >= 3 && *(w.end() - 2) == '\'')
            {
                switch (w.back())
                {
                case 'd':
                    ++words["would"];
                    ++words[w.substr(0, w.size() - 2)];
                    break;
                case 'm':
                    ++words["am"];
                    ++words[w.substr(0, w.size() - 2)];
                    break;
                case 's':
                    ++words["is"];
                    ++words[w.substr(0, w.size() - 2)];
                    break;
                case 't':
                    ++words["not"];
                    ++words[w.substr(0, w.size() - 3)];
                    break;
                default:
                    break;
                }
            }
            else if (w.size() >= 4 && *(w.end() - 3) == '\'')
            {
                switch (*(w.end() - 2))
                {
                case 'l':
                    ++words["will"];
                    ++words[w.substr(0, w.size() - 3)];
                    break;
                case 'r':
                    ++words["are"];
                    ++words[w.substr(0, w.size() - 3)];
                    break;
                case 'v':
                    ++words["have"];
                    ++words[w.substr(0, w.size() - 3)];
                    break;
                default:
                    break;
                }
            }
            else
            {
                ++words[w];
            }
        }

        typedef map<string, int>::iterator Iter;
        for (Iter p = words.begin(); p != words.end(); ++p)
        {
            Iter q = p;
            ++q;
            if (q != words.end() && q->first[0] == p->first[0]
                    && q->first.size() == p->first.size() + 1
                    && q->first == p->first + "s")
            {
                q = words.erase(q);
            }
        }

        return words;
    }

    int num_of_occurrences(const string &word, const map<string, int> &clean_txt)
    {
        if (clean_txt.find(word) != clean_txt.end())
        {
            return clean_txt.at(word);
        }
        else
        {
            return 0;
        }
    }

    string most_frequent(const map<string, int> &clean_txt)
    {
        string s;
        int max = 0;
        typedef map<string, int>::const_iterator Iter;
        for (Iter p = clean_txt.begin(); p != clean_txt.end(); ++p)
        {
            if (p->second > max)
            {
                max = p->second;
                s = p->first;
            }
        }
        return s;
    }

    string longest(const map<string, int> &clean_txt)
    {
        string s;
        int l_max = 0;
        typedef map<string, int>::const_iterator Iter;
        for (Iter p = clean_txt.begin(); p != clean_txt.end(); ++p)
        {
            if (p->first.length() > l_max)
            {
                l_max = p->first.length();
                s = p->first;
            }
        }
        return s;
    }

    string shortest(const map<string, int> &clean_txt)
    {
        string s;
        typedef map<string, int>::const_iterator Iter;
        Iter p = clean_txt.begin();
        s = p->first;
        int l_min = p->first.length();
        ++p;
        for (; p != clean_txt.end(); ++p)
        {
            if (p->first.length() < l_min)
            {
                l_min = p->first.length();
                s = p->first;
            }
        }
        return s;
    }

    vector<string> start_with(char ch, const map<string, int> &clean_txt)
    {
        int count = count_if(clean_txt.begin(), clean_txt.end(), First_char(ch));
        vector<pair<string, int>> vp(count);
        copy_if(clean_txt.begin(), clean_txt.end(), vp.begin(), First_char(ch));
        vector<string> vs;
        for (int i = 0; i < vp.size(); ++i)
        {
            vs.push_back(vp[i].first);
        }
        return vs;
    }

    vector<string> has_length(int n, const map<string, int> &clean_txt)
    {
        int count = count_if(clean_txt.begin(), clean_txt.end(), Length(n));
        vector<pair<string, int>> vp(count);
        copy_if(clean_txt.begin(), clean_txt.end(), vp.begin(), Length(n));
        vector<string> vs;
        for (int i = 0; i < vp.size(); ++i)
        {
            vs.push_back(vp[i].first);
        }
        return vs;
    }
}

void print_menu()
{
    cout << "What would you like to do?\n"
         << "1 - Enter input file name\n"
         << "2 - Get number of occurrences of a word\n"
         << "3 - Get most frequent word\n"
         << "4 - Get longest word\n"
         << "5 - Get shortest word\n"
         << "6 - Get words starting with a specific letter\n"
         << "7 - Get words of a specific length\n"
         << "0 - Exit\n";
}

string get_ifname()
{
    cout << "\nEnter input file name: ";
    string s;
    cin >> s;
    cout << '\n';
    return s;
}

bool file_check(const string &fname)
{
    if (fname == "")
    {
        cout << "\nFile name is empty!\n\n";
        return false;
    }

    ifstream ifs(fname.c_str());
    if (!ifs)
    {
        cout << "\nFile " << fname << " doesn't exist!\n\n";
        return false;
    }

    return true;
}

void get_n_occurrences(const map<string, int> &clean_txt)
{
    if (clean_txt.size() == 0)
    {
        cout << "\nNo text loaded!\n\n";
        return;
    }
    cout << "\nEnter word: ";
    string s;
    cin >> s;
    int n = Text_query::num_of_occurrences(s, clean_txt);
    cout << "\n\'" << s << "\' occurs " << n << " time" << (n == 1 ? "" : "s") << ".\n\n";
}

void get_most_frequent(const map<string, int> &clean_txt)
{
    if (clean_txt.size() == 0)
    {
        cout << "\nNo text loaded!\n\n";
        return;
    }
    string s = Text_query::most_frequent(clean_txt);
    cout << "\nThe most frequent word is \'" << s << "\'.\n\n";
}

void get_longest(const map<string, int> &clean_txt)
{
    if (clean_txt.size() == 0)
    {
        cout << "\nNo text loaded!\n\n";
        return;
    }
    string s = Text_query::longest(clean_txt);
    cout << "\nThe longest word is \'" << s << "\'.\n\n";
}

void get_shortest(const map<string, int> &clean_txt)
{
    if (clean_txt.size() == 0)
    {
        cout << "\nNo text loaded!\n\n";
        return;
    }
    string s = Text_query::shortest(clean_txt);
    cout << "\nThe shortest word is \'" << s << "\'.\n\n";
}

void get_start_with(const map<string, int> &clean_txt)
{
    if (clean_txt.size() == 0)
    {
        cout << "\nNo text loaded!\n\n";
        return;
    }
    cout << "\nEnter character: ";
    char ch;
    cin >> ch;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    vector<string> vs = Text_query::start_with(ch, clean_txt);
    cout << "\nWords starting with '" << ch << "':\n";
    for (int i = 0; i < vs.size(); ++i)
    {
        cout << vs[i] << '\n';
    }
    cout << '\n';
}

void get_has_length(const map<string, int> &clean_txt)
{
    if (clean_txt.size() == 0)
    {
        cout << "\nNo text loaded!\n\n";
        return;
    }
    cout << "\nEnter number of characters: ";
    int n;
    while (!( cin >> n))
    {
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
        cout << "\nPlease enter a number\n";
        cout << "\nEnter number of characters: ";
    }
    vector<string> vs = Text_query::has_length(n, clean_txt);
    cout << "\nWords with " << n << " characters:\n";
    for (int i = 0; i < vs.size(); ++i)
    {
        cout << vs[i] << '\n';
    }
    cout << '\n';
}

int main()
{
    try
    {
        string ifname;
        map<string, int> words;

        bool keep_running = true;
        while (keep_running)
        {
            print_menu();
            int n;
            while (!(cin >> n))
            {
                cin.clear();
                cin.ignore(numeric_limits<streamsize>::max(), '\n');
                cout << "\nPlease enter a number\n";
                print_menu();
            }
            switch (n)
            {
            case 0:
                keep_running = false;
                break;
            case 1:
                ifname = get_ifname();
                if (file_check(ifname))
                {
                    words = Text_query::clean_txt(ifname);
                }
                break;
            case 2:
                get_n_occurrences(words);
                break;
            case 3:
                get_most_frequent(words);
                break;
            case 4:
                get_longest(words);
                break;
            case 5:
                get_shortest(words);
                break;
            case 6:
                get_start_with(words);
                break;
            case 7:
                get_has_length(words);
                break;
            default:
                cout << "\nEnter a number between 0 and 7\n\n";
                break;
            }
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
1

Enter input file name: ch21_p13_in.txt

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
3

The most frequent word is 'not'.

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
2

Enter word: would

'would' occurs 9 times.

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
4

The longest word is 'cannot'.

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
5

The shortest word is 'i'.

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
6

Enter character: w

Words starting with 'w':
we
were
what
where
who
will
would

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
7

Enter number of characters: 5

Words with 5 characters:
could
shall
there
where
would

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
0












































