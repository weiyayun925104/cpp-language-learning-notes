C++程序设计原理与实践 第一版 Programming Principles and Practice Using C++
第一部分基本知识
第2章 Hello, World!
2.1 程序
2.2 经典的第一个程序
2.3 编译
2.4 链接
2.5 编程环境
ch02_b01.cpp
#include <iostream>

using std::cout;

int main()
{
    cout << "Hello, World!\n";
    return 0;
}
显示结果如下
Hello, World!

第3章 对象、类型和值
3.1 输入
3.2 变量
3.3 输入和类型
3.4 运算和运算符
3.5 赋值和初始化
3.5.1 实例：删除重复单词
3.6 组合赋值运算符
3.6.1 实例：重复单词统计
3.7 命名
3.8 类型和对象
3.9 类型安全
3.9.1 安全类型转换
3.9.2 不安全类型转换
ch03_b01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    cout << "Please enter your first name (followed by 'enter'):\n";
    string first_name;
    cin >> first_name;
    cout << "Hello, " << first_name << "!\n";
    cout << "first_name" << " is " << first_name << endl;
}
显示结果如下
Please enter your first name (followed by 'enter'):
Peter
Hello, Peter!
first_name is Peter

ch03_b02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    int number_of_steps = 39;
    double flying_time = 3.5;
    char decimal_point = '.';
    string name = "Annemarie";
    bool tap_on = true;

    cout << number_of_steps << ", "
         << flying_time << ", "
         << decimal_point << ", "
         << name << ", "
         << tap_on << endl;
}
显示结果如下
39, 3.5, ., Annemarie, 1

ch03_b03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    cout << "please enter your first_name and age\n";
    string first_name = "?\?\?";
    int age = -1;
    cin >> first_name >> age;
    cout << "Hello, " << first_name << " (age " << age << ")\n";

    cout << "please enter your first and second names\n";
    string first;
    string second;
    cin >> first >> second;
    cout << "Hello, " << first << ' ' << second << '\n';
}
显示结果如下
please enter your first_name and age
Peter 23
Hello, Peter (age 23)
please enter your first and second names
Peter Smith
Hello, Peter Smith

ch03_b04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    int count;
    cin >> count;
    string name;
    cin >> name;

    int c2 = count + 2;
    string s2 = name + " Jr. ";

    int c3 = count - 2;
    int age = -100;

    cout << count << ", "
         << name << ", "
         << c2 << ", "
         << s2 << ", "
         << c3 << ", "
         << age << endl;

    cout << "please enter a floating-point value: ";
    double n;
    cin >> n;
    cout << "n == " << n
         << "\nn+1 == " << n + 1
         << "\nthree times n == " << 3 * n
         << "\ntwice n == " << n + n
         << "\nn squared == " << n *n
         << "\nhalf of n == " << n / 2
         << "\nsquare root of n == " << sqrt(n)
         << endl;

    cout << "please enter your first and second names\n";
    string first;
    string second;
    cin >> first >> second;
    name = first + ' ' + second;
    cout << "Hello, " << name << '\n';

    if (first == second)
    {
        cout << "that's the same name twice\n";
    }
    else if (first < second)
    {
        cout << first << " is alphabetically before " << second << '\n';
    }
    else
    {
        cout << first << " is alphabetically after " << second << '\n';
    }
}
显示结果如下
23 Peter
23, Peter, 25, Peter Jr. , 21, -100
please enter a floating-point value: 3.5
n == 3.5
n+1 == 4.5
three times n == 10.5
twice n == 7
n squared == 12.25
half of n == 1.75
square root of n == 1.87083
please enter your first and second names
Peter Smith
Hello, Peter Smith
Peter is alphabetically before Smith

ch03_b05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    {
        int a = 3;
        a = 4;
        int b = a;
        b = a + 5;
        a = a + 7;
        cout << a << ", " << b << endl;
    }

    {
        string a = "alpha";
        a = "beta";
        string b = a;
        b = a + "gamma";
        a = a + "delta";
        cout << a << ", " << b << endl;
    }

    {
        int y = 8;
        int x;

        x = 9;
        cout << x << ", " << y << endl;

        string t = "howdy!";
        string s;

        s = "G'day";
        cout << s << ", " << t << endl;
    }

    string previous = " ";
    string current;
    while (cin >> current)
    {
        if (previous == current)
        {
            cout << "repeated word: " << current << '\n';
        }
        previous = current;
    }
}
显示结果如下
11, 9
betadelta, betagamma
9, 8
G'day, howdy!
Peter Smith Smith Peter Peter Smith
repeated word: Smith
repeated word: Peter

ch03_b06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    int number_of_words = 0;
    string previous = " ";
    string current;
    while (cin >> current)
    {
        ++number_of_words;
        if (previous == current)
        {
            cout << "word number " << number_of_words << " repeated: " << current << '\n';
        }
        previous = current;
    }
}
显示结果如下
Peter Smith Smith Peter Peter Smith
word number 3 repeated: Smith
word number 5 repeated: Peter

ch03_b07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    string s = "Goodbye, cruel world! ";
    cout << s << '\n';
}
显示结果如下
Goodbye, cruel world!
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    int a = 7;
    int b = 9;
    char c = 'a';
    double x = 1.2;
    string s1 = "Hello, world";
    string s2 = "1.2";
    cout << a << ", " << b << ", " << c << ", " << x << endl;
    cout << s1 << ", " << s2 << endl;
}
显示结果如下
7, 9, a, 1.2
Hello, world, 1.2

ch03_b09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    double x = 1.5;
    double y = x;
    double z = 2.0 + x;

    cout << x << ", " << y << ", " << z << endl;

    char c1 = 'x';
    int i1 = c1;
    int i2 = 'x';
    char c2 = i1;

    cout << c1 << ", " << i1 << ", " << i2 << ", " << c2 << endl;

    double d1 = 2.3;
    double d2 = d1 + 2;

    cout << d1 << ", " << d2 << endl;

    if (d1 < 0)
    {
        error("d1 is negative");
    }

    int a = 20000;
    char c = a;
    int b = c;

    cout << a << ", " << b << ", " << c << endl;

    if (a != b)
    {
        cout << "oops!: " << a << "!=" << b << '\n';
    }
    else
    {
        cout << "Wow! We have large characters\n";
    }

    {
        double d = 0;
        while (cin >> d)
        {
            int i = d;
            char c = i;
            int i2 = c;
            cout << d << ", " << i << ", " << c << ", " << i2 << endl;
        }

        double x = 2.7;
        int y = x;
        int a = 1000;
        char b = a;
        cout << x << ", " << y << ", " << a << ", " << int(b) << endl;
    }

}
显示结果如下
1.5, 1.5, 3.5
x, 120, 120, x
2.3, 4.3
20000, 32,
oops!: 20000!=32
120.5
120.5, 120, x, 120
2.7, 2, 1000, -24

习题
7. 编写一个程序，提示用户输入三个字符串，然后按次序输出这些值并以逗号隔开。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    vector<string> v1;
    string word;
    while (getline(cin, word, '\n') && word != "")
    {
        v1.push_back(word);
    }
    sort(v1.begin(), v1.end());
    for(auto it = v1.begin(); it != v1.end(); ++it)
    {
        if (it != v1.begin())
        {
            cout << ", ";
        }
        cout << *it;
    }
    cout << endl;
}
显示结果如下
Steinbeck
Hemingway
Fitzgerald

Fitzgerald, Hemingway, Steinbeck

8・编写一个程序，测试一个整数值是奇数还是偶数。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    vector<int> v1;
    int num;
    while (cin >> num)
    {
        v1.push_back(num);
    }
    for(auto it = v1.begin(); it != v1.end(); ++it)
    {
        if (*it % 2 == 0)
        {
            cout << *it << " is an even number.\n";
        }
        else
        {
            cout << *it << " is an odd number.\n";
        }
    }
}
显示结果如下
1 2 3 4 5 6 7 8 9 end
1 is an odd number.
2 is an even number.
3 is an odd number.
4 is an even number.
5 is an odd number.
6 is an even number.
7 is an odd number.
8 is an even number.
9 is an odd number.

9. 编写一个程序，将数字的英文单词转换成数字。
当用户输入一个数字的英文拼写，程序将打印出对应的数字。如果用户输入无法对应的值，程序输出"not a number I know"。
参考之前学习的Jumping Into C++中出现的习题
如何将英文文本转换成数字。
ch03_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

bool isNegative(string number);

string wordsToNumbers(string word);
bool isTens(string word);
string getTens(string numberAsWord);
bool isHundreds(string word);
string getHundreds(string numberAsWord);
int getMagnitudeBalance(string currentWord, string numberAsString);
string getPaddedForMagnitude(string numberAsString,	int magnitudeBalance);

bool isNumberDemarcator(char character);
bool isFirstLetter(string numberInEnglish,	int numberIndexFromEnd);
int wordsToMagnitude(string word);

string addZeroPadding(int numberOfZeroes);
string addCommasMagnitude(string numberAsWord);

char const space = ' ';
char const comma = ',';
char const hyphen = '-';

int main()
{
    string numberInEnglish = "";
    cout << "Please write in any number you wish to see written out in digits: " << '\n';
    while (getline(cin, numberInEnglish, '\n') && numberInEnglish != "")
    {
        string numberAsString = "";
        string currentWord = "";
        for (size_t i = 0; i < numberInEnglish.length(); i++)
        {
            char currentLetter = tolower(numberInEnglish[numberInEnglish.length() - 1 - i]);

            if (!isNumberDemarcator(currentLetter))
            {
                currentWord = currentLetter + currentWord;
            }

            if ( !(currentWord == "") && ( isNumberDemarcator(currentLetter) || isFirstLetter(numberInEnglish, i) ) )
            {
                int magnitudeBalance;

                if (isTens(currentWord))
                {
                    numberAsString = getTens(numberAsString);
                }
                else if (isHundreds(currentWord))
                {
                    numberAsString = getHundreds(numberAsString);
                }
                else if ( ( magnitudeBalance = getMagnitudeBalance(currentWord, numberAsString) ) > 0 )
                {
                    numberAsString = getPaddedForMagnitude(numberAsString, magnitudeBalance);
                }
                string currentNumber = wordsToNumbers(currentWord);

                if (!(currentNumber == ""))
                {
                    numberAsString = currentNumber + numberAsString;
                }

                currentWord = "";
            }
        }
        if (numberAsString == "")
        {
            cout << "The number you entered was not a number I know\n";
        }
        else
        {
            numberAsString = addCommasMagnitude(numberAsString);

            if (isNegative(numberInEnglish))
            {
                numberAsString = "-" + numberAsString;
            }
            cout << "The number you entered was " << numberAsString << '\n';
        }
        cout << "Please write in any number you wish to see written out in digits: " << '\n';
    }
}

bool isNumberDemarcator(char character)
{
    return ( (character == hyphen) ||
             (character == comma) ||
             (character == space) );
}

bool isFirstLetter(string numberInEnglish,
                   int numberIndexFromEnd)
{
    return ( numberIndexFromEnd == numberInEnglish.length() - 1 );
}

bool isNegative(string number)
{
    string negative = "negative";
    if (number.length() > negative.length())
    {
        for (size_t i = 0; i < negative.length(); i++)
        {
            if (!(tolower(number[i]) == negative[i]))
            {
                return false;
            }
        }
        return true;
    }
    return false;
}

string wordsToNumbers(string word)
{
    if (word == "zero")
        return "0";
    if (word == "one")
        return "1";
    if (word == "two")
        return "2";
    if (word == "three")
        return "3";
    if (word == "four")
        return "4";
    if (word == "five")
        return "5";
    if (word == "six")
        return "6";
    if (word == "seven")
        return "7";
    if (word == "eight")
        return "8";
    if (word == "nine")
        return "9";
    if (word == "ten")
        return "10";
    if (word == "eleven")
        return "11";
    if (word == "twelve")
        return "12";
    if (word == "thirteen")
        return "13";
    if (word == "fourteen")
        return "14";
    if (word == "fifteen")
        return "15";
    if (word == "sixteen")
        return "16";
    if (word == "seventeen")
        return "17";
    if (word == "eighteen")
        return "18";
    if (word == "nineteen")
        return "19";
    if (word == "twenty")
        return "2";
    if (word == "thirty")
        return "3";
    if (word == "forty")
        return "4";
    if (word == "fifty")
        return "5";
    if (word == "sixty")
        return "6";
    if (word == "seventy")
        return "7";
    if (word == "eighty")
        return "8";
    if (word == "ninety")
        return "9";
    return "";
}

bool isTens(string word)
{
    return ((word == "twenty") ||
            (word == "thirty") ||
            (word == "forty") ||
            (word == "fifty") ||
            (word == "sixty") ||
            (word == "seventy") ||
            (word == "eighty") ||
            (word == "ninety"));
}

string getTens(string numberAsWord)
{
    int numberLength = numberAsWord.length();
    if (numberLength < 2)
    {
        numberAsWord = addZeroPadding(1 - numberLength) + numberAsWord;
    }
    else
    {
        int offset = 1;
        while (offset - numberLength < 0)
        {
            offset += 3;
        }
        numberAsWord = addZeroPadding(offset - numberLength) + numberAsWord;
    }
    return numberAsWord;
}

bool isHundreds(string word)
{
    return (word == "hundred");
}

string getHundreds(string numberAsWord)
{
    int numberLength = numberAsWord.length();

    int offset = 2;
    while (offset - numberLength < 0)
    {
        offset += 3;
    }
    numberAsWord = addZeroPadding(offset - numberLength) + numberAsWord;

    return numberAsWord;
}

int getMagnitudeBalance(string currentWord,
                        string numberAsString)
{
    int currentMagnitude = wordsToMagnitude(currentWord);
    int numberLength = numberAsString.length();
    return (currentMagnitude - numberLength);
}


string getPaddedForMagnitude(string numberAsString,
                             int magnitudeBalance)
{
    return (addZeroPadding(magnitudeBalance) + numberAsString);
}


int wordsToMagnitude(string word)
{
    if (word == "thousand")
    {
        return 3;
    }
    if (word == "million")
    {
        return 6;
    }
    if (word == "billion")
    {
        return 9;
    }
    if (word == "trillion")
    {
        return 12;
    }
    return 0;
}

string addZeroPadding(int numberOfZeroes)
{
    string currentPadding = "";
    for (size_t j = 0; j < numberOfZeroes; j++)
    {
        currentPadding += "0";
    }
    return currentPadding;
}

string addCommasMagnitude(string numberAsWord)
{
    string numberAsWordWithCommas = "";
    int subcount = 0;
    int originalLength = numberAsWord.length();
    for (size_t i = 0; i < originalLength; i++)
    {
        numberAsWordWithCommas = numberAsWord[originalLength - 1 - i] + numberAsWordWithCommas;
        subcount++;
        if ((subcount == 3) && !(i == originalLength - 1))
        {
            subcount = 0;
            numberAsWordWithCommas = "," + numberAsWordWithCommas;
        }
    }
    return numberAsWordWithCommas;
}
显示结果如下
Please write in any number you wish to see written out in digits:
one billion, two
The number you entered was 1,000,000,002
Please write in any number you wish to see written out in digits:
one hundred thousand, twenty three
The number you entered was 100,023
Please write in any number you wish to see written out in digits:

10. 编写一个程序，执行一个包括两个运算的操作，然后输出结果。例如：
+100 3.14
* 4 5
将操作读入一个字符串称为operation，用一个if语句判断哪个操作是用户希望的。
将运算读入double类型的变量。实现这些称为+、-、*、/的操作，加、减、乘、除都有各自明显的意义。
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    string operation;
    double d1 = 0;
    double d2 = 0;
    double res = 0;
    cout << "Please enter an operation (+, -, *, /, plus, minus, mul, div) followed by two operands\n";
    while (cin >> operation && cin >> d1 && cin >> d2)
    {
        if (operation == "+" || operation == "plus")
        {
            res = d1 + d2;
        }
        else if (operation == "-" || operation == "minus")
        {
            res = d1 - d2;
        }
        else if (operation == "*" || operation == "mul")
        {
            res = d1 * d2;
        }
        else if (operation == "/" || operation == "div")
        {
            if (d2 == 0)
            {
                operation = "divzero";
            }
            else
            {
                res = d1 / d2;
            }
        }
        else
        {
            operation = "unknown";
        }
        if (operation == "unknown")
        {
            cout << "I don't know this operator!\n";
        }
        else if (operation == "divzero")
        {
            cout << "No division by zero!\n";
        }
        else
        {
            cout << d1 << ' ' << operation << ' ' << d2 << " = " << res << '\n';
        }
        cout << "Please enter an operation (+, -, *, /, plus, minus, mul, div) followed by two operands\n";
    }
    return 0;
}
显示结果如下
Please enter an operation (+, -, *, /, plus, minus, mul, div) followed by two operands
+ 100 3.14
100 + 3.14 = 103.14
Please enter an operation (+, -, *, /, plus, minus, mul, div) followed by two operands
* 4 5
4 * 5 = 20
Please enter an operation (+, -, *, /, plus, minus, mul, div) followed by two operands
+ q q

11. 编写一个程序，提示用户输入一美分（1美分硬币）、五美分（5美分硬币）、十美分（10美分硬币）、二十五美分（25美分硬币）、
半美元（50美分硬币）和一美元（100美分硬币）的数量。对每种面值的硬币，分别提示用户输入其数量。然后，程序将输出类似下面的内容：
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    int pennies = 0;
    int nickels = 0;
    int dimes = 0;
    int quarters = 0;
    int half_dollars = 0;
    int dollars = 0;
    cout << "How many pennies do you have?\n";
    cin >> pennies;
    cout << "How many nickels do you have?\n";
    cin >> nickels;
    cout << "How many dimes do you have?\n";
    cin >> dimes;
    cout << "How many quarters do you have?\n";
    cin >> quarters;
    cout << "How many half dollars do you have?\n";
    cin >> half_dollars;
    cout << "How many dollar coins do you have?\n";
    cin >> dollars;
    if (pennies > 0)
    {
        cout << "You have " << pennies;
        if (pennies == 1)
        {
            cout << " penny.\n";
        }
        else
        {
            cout << " pennies.\n";
        }
    }
    if (nickels > 0)
    {
        cout << "You have " << nickels;
        if (nickels == 1)
        {
            cout << " nickel.\n";
        }
        else
        {
            cout << " nickels.\n";
        }
    }
    if (dimes > 0)
    {
        cout << "You have " << dimes;
        if (dimes == 1)
        {
            cout << " dime.\n";
        }
        else
        {
            cout << " dimes.\n";
        }
    }
    if (quarters > 0)
    {
        cout << "You have " << quarters;
        if (quarters == 1)
        {
            cout << " quarter.\n";
        }
        else
        {
            cout << " quarters.\n";
        }
    }
    if (half_dollars > 0)
    {
        cout << "You have " << half_dollars;
        if (half_dollars == 1)
        {
            cout << " half dollar.\n";
        }
        else
        {
            cout << " half dollars.\n";
        }
    }
    if (dollars > 0)
    {
        cout << "You have " << dollars;
        if (dollars == 1)
        {
            cout << " dollar.\n";
        }
        else
        {
            cout << " dollars.\n";
        }
    }
    double val = pennies + 5 * nickels + 10 * dimes + 25 * quarters + 50 * half_dollars + 100 * dollars;
    cout << std::fixed;
    streamsize prec = cout.precision();
    cout << "The value of all your coins is "  << setprecision(0) << val << " cents ($" << setprecision(2) << val / 100 << setprecision(prec) << ").\n";
    return 0;
}
显示结果如下
How many pennies do you have?
23
How many nickels do you have?
17
How many dimes do you have?
14
How many quarters do you have?
7
How many half dollars do you have?
3
How many dollar coins do you have?
5
You have 23 pennies.
You have 17 nickels.
You have 14 dimes.
You have 7 quarters.
You have 3 half dollars.
You have 5 dollars.
The value of all your coins is 1073 cents ($10.73).

以下为之前学习的Jumping Into C++中出现的习题
12.完成将从-999 999~999 999的数字转换成英文文本的源代码。
ch03_p12.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

string getOneDigitNumber(char number);
string getTeensNumber(char number);
string getTensNumber(char number);
string getTwoDigitNumber(char ten, char one);
string getThreeDigitNumber(char hundred, char ten, char one);
string getMagnitude(int divisionsOfThree);

int main()
{
    int i;

    cout << "Please enter an integer number: ";
    cin >> i;
    string numberAsString = to_string(i);

    string sign = "";
    bool isNegative = (numberAsString.at(0) == '-');
    if (isNegative)
    {
        sign = "Negative ";
    }

    int signOffset = 0;
    if (isNegative)
    {
        signOffset = 1;
    }

    int numberCount = numberAsString.length() - signOffset;

    string numberInEnglish = "";
    int tens = numberCount % 3;
    int divisionsOfThree = (numberCount - 1) / 3;

    if ( numberCount <= 3 )
    {
        switch (numberCount)
        {
        case 1:
            if ( numberAsString.at(signOffset) == '0' )
            {
                numberInEnglish = "zero";
            }
            else
            {
                numberInEnglish = getOneDigitNumber(numberAsString.at(signOffset));
            }
            break;
        case 2:
            numberInEnglish = getTwoDigitNumber(numberAsString.at(signOffset), numberAsString.at(signOffset + 1));
            break;
        case 3:
            numberInEnglish = getThreeDigitNumber(numberAsString.at(signOffset), numberAsString.at(signOffset + 1), numberAsString.at(signOffset + 2));
            break;
        default:
            break;
        }
        cout << numberAsString << ": " << sign << numberInEnglish << '\n';
        return 0;
    }

    if ( tens > 0 )
    {
        switch (tens)
        {
        case 1:
            numberInEnglish = getOneDigitNumber(numberAsString.at(signOffset));
            break;
        case 2:
            numberInEnglish = getTwoDigitNumber(numberAsString.at(signOffset), numberAsString.at(signOffset + 1));
            break;
        default:
            break;
        }
        numberInEnglish += " " + getMagnitude(divisionsOfThree);
        divisionsOfThree--;
    }

    for (size_t j = tens + signOffset; j < numberAsString.length(); j += 3)
    {
        string threeDigits = numberAsString.substr(j, 3);
        if (threeDigits != "000")
        {
            if(numberInEnglish.length() > 0)
            {
                numberInEnglish += ", ";
            }
            if (divisionsOfThree == 0)
            {
                numberInEnglish +=
                    getThreeDigitNumber(threeDigits.at(0), threeDigits.at(1), threeDigits.at(2));
            }
            else
            {
                numberInEnglish +=
                    getThreeDigitNumber(threeDigits.at(0), threeDigits.at(1), threeDigits.at(2)) + " " + getMagnitude(divisionsOfThree);
            }
        }

        divisionsOfThree--;
    }
    cout << numberAsString << ": " << sign << numberInEnglish << '\n';

}

string getOneDigitNumber(char number)
{
    switch(number)
    {
    case '1':
        return "one";
    case '2':
        return "two";
    case '3':
        return "three";
    case '4':
        return "four";
    case '5':
        return "five";
    case '6':
        return "six";
    case '7':
        return "seven";
    case '8':
        return "eight";
    case '9':
        return "nine";
    default:
        return "";
    }
}

string getTeensNumber(char number)
{
    switch (number)
    {
    case '0':
        return "ten";
    case '1':
        return "eleven";
    case '2':
        return "twelve";
    case '3':
        return "thirteen";
    case '4':
        return "fourteen";
    case '5':
        return "fifteen";
    case '6':
        return "sixteen";
    case '7':
        return "seventeen";
    case '8':
        return "eighteen";
    case '9':
        return "nineteen";
    default:
        return "";
    }
}

string getTensNumber(char number)
{
    switch (number)
    {
    case '2':
        return "twenty";
    case '3':
        return "thirty";
    case '4':
        return "fourty";
    case '5':
        return "fifty";
    case '6':
        return "sixty";
    case '7':
        return "seventy";
    case '8':
        return "eighty";
    case '9':
        return "ninety";
    default:
        return "";
    }
}

string getTwoDigitNumber(char ten, char one)
{
    if (ten == '0')
    {
        return  getOneDigitNumber(one);
    }
    else if (ten == '1')
    {
        return getTeensNumber(one);
    }
    else
    {
        if (one == '0')
        {
            return getTensNumber(ten);
        }
        else
        {
            return (getTensNumber(ten) + " " + getOneDigitNumber(one));
        }
    }
}

string getThreeDigitNumber(char hundred, char ten, char one)
{
    if (hundred == '0')
    {
        return  getTwoDigitNumber(ten, one);
    }
    else
    {
        if (ten == '0' && one == '0')
        {
            return (getOneDigitNumber(hundred) + " hundred");
        }
        else
        {
            return (getOneDigitNumber(hundred) + " hundred " + getTwoDigitNumber(ten, one));
        }
    }
}

string getMagnitude(int divisionsOfThree)
{
    switch (divisionsOfThree)
    {
    case 1:
        return "thousand";
    case 2:
        return "million";
    case 3:
        return "billion";
    case 4:
        return "trillion";
    default:
        return "";
    }
}
显示结果如下
Please enter an integer number: 0
0: zero

Please enter an integer number: 100023
100023: one hundred thousand, twenty three

Please enter an integer number: 1000000002
1000000002: one billion, two

13.如何将英文文本转换成数字。
ch03_p13.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

bool isNegative(string number);

string wordsToNumbers(string word);
bool isTens(string word);
string getTens(string numberAsWord);
bool isHundreds(string word);
string getHundreds(string numberAsWord);
int getMagnitudeBalance(string currentWord, string numberAsString);
string getPaddedForMagnitude(string numberAsString,	int magnitudeBalance);

bool isNumberDemarcator(char character);
bool isFirstLetter(string numberInEnglish,	int numberIndexFromEnd);
int wordsToMagnitude(string word);

string addZeroPadding(int numberOfZeroes);
string addCommasMagnitude(string numberAsWord);

char const space = ' ';
char const comma = ',';
char const hyphen = '-';

int main()
{
    string numberInEnglish = "";
    cout << "Please write in any number you wish to see written out in digits: " << '\n';
    getline(cin, numberInEnglish, '\n');

    string numberAsString = "";
    string currentWord = "";
    for (size_t i = 0; i < numberInEnglish.length(); i++)
    {
        char currentLetter = tolower(numberInEnglish[numberInEnglish.length() - 1 - i]);

        if (!isNumberDemarcator(currentLetter))
        {
            currentWord = currentLetter + currentWord;
        }

        if ( !(currentWord == "") && ( isNumberDemarcator(currentLetter) || isFirstLetter(numberInEnglish, i) ) )
        {
            int magnitudeBalance;

            if (isTens(currentWord))
            {
                numberAsString = getTens(numberAsString);
            }
            else if (isHundreds(currentWord))
            {
                numberAsString = getHundreds(numberAsString);
            }
            else if ( ( magnitudeBalance = getMagnitudeBalance(currentWord, numberAsString) ) > 0 )
            {
                numberAsString = getPaddedForMagnitude(numberAsString, magnitudeBalance);
            }
            string currentNumber = wordsToNumbers(currentWord);

            if (!(currentNumber == ""))
            {
                numberAsString = currentNumber + numberAsString;
            }

            currentWord = "";
        }
    }

    numberAsString = addCommasMagnitude(numberAsString);

    if (isNegative(numberInEnglish))
    {
        numberAsString = "-" + numberAsString;
    }
    cout << "The number you entered was " << numberAsString << '\n';
}

bool isNumberDemarcator(char character)
{
    return ( (character == hyphen) ||
             (character == comma) ||
             (character == space) );
}

bool isFirstLetter(string numberInEnglish,
                   int numberIndexFromEnd)
{
    return ( numberIndexFromEnd == numberInEnglish.length() - 1 );
}

bool isNegative(string number)
{
    string negative = "negative";
    if (number.length() > negative.length())
    {
        for (size_t i = 0; i < negative.length(); i++)
        {
            if (!(tolower(number[i]) == negative[i]))
            {
                return false;
            }
        }
        return true;
    }
    return false;
}

string wordsToNumbers(string word)
{
    if (word == "zero")
        return "0";
    if (word == "one")
        return "1";
    if (word == "two")
        return "2";
    if (word == "three")
        return "3";
    if (word == "four")
        return "4";
    if (word == "five")
        return "5";
    if (word == "six")
        return "6";
    if (word == "seven")
        return "7";
    if (word == "eight")
        return "8";
    if (word == "nine")
        return "9";
    if (word == "ten")
        return "10";
    if (word == "eleven")
        return "11";
    if (word == "twelve")
        return "12";
    if (word == "thirteen")
        return "13";
    if (word == "fourteen")
        return "14";
    if (word == "fifteen")
        return "15";
    if (word == "sixteen")
        return "16";
    if (word == "seventeen")
        return "17";
    if (word == "eighteen")
        return "18";
    if (word == "nineteen")
        return "19";
    if (word == "twenty")
        return "2";
    if (word == "thirty")
        return "3";
    if (word == "forty")
        return "4";
    if (word == "fifty")
        return "5";
    if (word == "sixty")
        return "6";
    if (word == "seventy")
        return "7";
    if (word == "eighty")
        return "8";
    if (word == "ninety")
        return "9";
    return "";
}

bool isTens(string word)
{
    return ((word == "twenty") ||
            (word == "thirty") ||
            (word == "forty") ||
            (word == "fifty") ||
            (word == "sixty") ||
            (word == "seventy") ||
            (word == "eighty") ||
            (word == "ninety"));
}

string getTens(string numberAsWord)
{
    int numberLength = numberAsWord.length();
    if (numberLength < 2)
    {
        numberAsWord = addZeroPadding(1 - numberLength) + numberAsWord;
    }
    else
    {
        int offset = 1;
        while (offset - numberLength < 0)
        {
            offset += 3;
        }
        numberAsWord = addZeroPadding(offset - numberLength) + numberAsWord;
    }
    return numberAsWord;
}

bool isHundreds(string word)
{
    return (word == "hundred");
}

string getHundreds(string numberAsWord)
{
    int numberLength = numberAsWord.length();

    int offset = 2;
    while (offset - numberLength < 0)
    {
        offset += 3;
    }
    numberAsWord = addZeroPadding(offset - numberLength) + numberAsWord;

    return numberAsWord;
}

int getMagnitudeBalance(string currentWord,
                        string numberAsString)
{
    int currentMagnitude = wordsToMagnitude(currentWord);
    int numberLength = numberAsString.length();
    return (currentMagnitude - numberLength);
}


string getPaddedForMagnitude(string numberAsString,
                             int magnitudeBalance)
{
    return (addZeroPadding(magnitudeBalance) + numberAsString);
}


int wordsToMagnitude(string word)
{
    if (word == "thousand")
    {
        return 3;
    }
    if (word == "million")
    {
        return 6;
    }
    if (word == "billion")
    {
        return 9;
    }
    if (word == "trillion")
    {
        return 12;
    }
    return 0;
}

string addZeroPadding(int numberOfZeroes)
{
    string currentPadding = "";
    for (size_t j = 0; j < numberOfZeroes; j++)
    {
        currentPadding += "0";
    }
    return currentPadding;
}

string addCommasMagnitude(string numberAsWord)
{
    string numberAsWordWithCommas = "";
    int subcount = 0;
    int originalLength = numberAsWord.length();
    for (size_t i = 0; i < originalLength; i++)
    {
        numberAsWordWithCommas = numberAsWord[originalLength - 1 - i] + numberAsWordWithCommas;
        subcount++;
        if ((subcount == 3) && !(i == originalLength - 1))
        {
            subcount = 0;
            numberAsWordWithCommas = "," + numberAsWordWithCommas;
        }
    }
    return numberAsWordWithCommas;
}
显示结果如下
Please write in any number you wish to see written out in digits:
zero
The number you entered was 0

Please write in any number you wish to see written out in digits:
one
The number you entered was 1

Please write in any number you wish to see written out in digits:
two
The number you entered was 2

Please write in any number you wish to see written out in digits:
three
The number you entered was 3

Please write in any number you wish to see written out in digits:
four
The number you entered was 4

Please write in any number you wish to see written out in digits:
one billion two
The number you entered was 1,000,000,002

Please write in any number you wish to see written out in digits:
one hundred thousand twenty three
The number you entered was 100,023


第4章 计算
4.1 计算
4.2 目标和工具
4.3 表达式
4.3.1 常量表达式
4.3.2 运算符
4.3.3 类型转换
4.4 语句
4.4.1 选择语句
4.4.2 循环语句
4.5 函数
4.5.1 使用函数的原因
4.5.2 函数声明
4.6 向量
4.6.1 向量空间增长
4.6.2 一个数值计算的例子
4.6.3 一个文本处理的例子
4.7 语言特性
ch04_b01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}


int main()
{
    int length = 20;
    int width = 40;
    int area = length * width;

    cout << length << ", " << width << ", " << area << endl;

    length = 99;

    {
        int perimeter = (length + width) * 2;
        cout << length << ", " << width << ", " << perimeter << endl;
    }

    {
        int perimeter = length * 2 + width * 2;
        cout << length << ", " << width << ", " << perimeter << endl;
    }

    {
        int perimeter = length + width / 2;
        cout << length << ", " << width << ", " << perimeter << endl;
    }

    const double pi = 3.14159265359;
    int r = 7;
    int v = 2 * pi / r;
    cout << pi << ", " << r << ", " << v << endl;

    const int max = 17;
    int val = 19;

    cout << max << ", " << val << endl;
    cout << max + 2 << ", " << val + 2 << endl;

    int a = 0;

    ++a;
    a += 1;
    a = a + 1;
    cout << a << endl;

    double d = 2.5;
    int i = 2;

    double d2 = d / i;
    int i2 = d / i;
    cout << d2 << ", " << i2 << endl;

    d2 = d / i + 1;
    i2 = d / i + 1;
    cout << d2 << ", " << i2 << endl;

    {
        double dc;
        cin >> dc;
        double df = 9 / 5 * dc + 32;
        cout << dc << ", " << df << endl;
    }

    {
        double dc;
        cin >> dc;
        double df = 9.0 / 5 * dc + 32;
        cout << dc << ", " << df << endl;
    }
}
显示结果如下
20, 40, 800
99, 40, 278
99, 40, 278
99, 40, 119
3.14159, 7, 0
17, 19
19, 21
3
1.25, 1
2.25, 2
3.5
3.5, 35.5
3.5
3.5, 38.3

ch04_b02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    {
        int a = 0;
        int b = 0;
        cout << "Please enter two integers\n";
        cin >> a >> b;

        if (a < b)
        {
            cout << "max(" << a << "," << b << ") is " << b << "\n";
        }
        else
        {
            cout << "max(" << a << "," << b << ") is " << a << "\n";
        }
    }

    {
        const double cm_per_inch = 2.54;
        int length = 1;
        char unit = ' ';
        cout << "Please enter a length followed by a unit (c or i):\n";
        cin >> length >> unit;

        cout << std::fixed;
        if (unit == 'i')
        {
            streamsize prec = cout.precision();
            cout << length << "in == " << setprecision(2) << cm_per_inch *length << setprecision(prec) << "cm\n";
        }
        else if (unit == 'c')
        {
            streamsize prec = cout.precision();
            cout << length << "cm == " << setprecision(2) << length / cm_per_inch << setprecision(prec) << "in\n";
        }
        else
        {
            cout << "Sorry, I don't know a unit called '" << unit << "'\n";
        }
    }

    {
        const double cm_per_inch = 2.54;
        int length = 1;
        char unit = 'a';
        cout << "Please enter a length followed by a unit (c or i):\n";
        cin >> length >> unit;
        cout << std::fixed;
        streamsize prec;
        switch (unit)
        {
        case 'i':
            prec = cout.precision();
            cout << length << "in == " << setprecision(2) << cm_per_inch *length << setprecision(prec) << "cm\n";
            break;
        case 'c':
            prec = cout.precision();
            cout << length << "cm == " << setprecision(2) << length / cm_per_inch << setprecision(prec) << "in\n";
            break;
        default:
            cout << "Sorry, I don't know a unit called '" << unit << "'\n";
            break;
        }
    }

    {
        cout << "Please enter a digit\n";
        char a;
        cin >> a;

        switch (a)
        {
        case '0':
        case '2':
        case '4':
        case '6':
        case '8':
            cout << a << " is even\n";
            break;
        case '1':
        case '3':
        case '5':
        case '7':
        case '9':
            cout << a << " is odd\n";
            break;
        default:
            cout << a << " is not a digit\n";
            break;
        }
    }

    {
        int a = 7;
        int b = 4;

        if (a <= b) { }
        else
        {
            int t = a;
            a = b;
            b = t;
        }
        cout << a << ", " << b << endl;
    }

    {
        for (int i = 0; i < 10; ++i)
        {
            cout << i << '\t' << (i * i) << '\n';
        }
        cout << endl;
        for (int i = 0; i < 10; i += 2)
        {
            cout << i << '\t' << (i * i) << '\n';
        }
    }
}
显示结果如下
Please enter two integers
3 5
max(3,5) is 5
Please enter a length followed by a unit (c or i):
5c
5cm == 1.97in
Please enter a length followed by a unit (c or i):
5i
5in == 12.70cm
Please enter a digit
5
5 is odd
4, 7
0       0
1       1
2       4
3       9
4       16
5       25
6       36
7       49
8       64
9       81

0       0
2       4
4       16
6       36
8       64

ch04_b03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}


inline int square(int x)
{
    return x * x;
}

void print_square(int v)
{
    cout << v << '\t' << v *v << '\n';
}

void write_sorry()
{
    cout << "Sorry\n";
}

int main()
{
    cout << square(2) << '\n';
    cout << square(10) << '\n';
    int x = square(44);
    cout << x << endl;
    write_sorry();
    cout << endl;
    for (int i = 0; i < 10; ++i)
    {
        print_square(i);
    }
}
显示结果如下
4
100
1936
Sorry

0       0
1       1
2       4
3       9
4       16
5       25
6       36
7       49
8       64
9       81

ch04_b04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}


inline int square(int x)
{
    return x * x;
}

void print_square(int v)
{
    cout << v << '\t' << v *v << '\n';
}

void write_sorry()
{
    cout << "Sorry\n";
}

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

int main()
{
    {
        int i = 0;
        while (i < 10)
        {
            cout << i << '\t' << square(i) << '\n';
            ++i ;
        }
    }

    {
        vector<int> v(6);

        v[0] = 5;
        v[1] = 7;
        v[2] = 9;
        v[3] = 4;
        v[4] = 6;
        v[5] = 8;

        copy(v.begin(), v.end(), ostream_iterator<int>(cout, " "));
        cout << endl;

        vector<string> philosopher(4);

        philosopher [0] = "Kant";
        philosopher [1] = "Plato";
        philosopher [2] = "Hume";
        philosopher [3] = "Kierkegaard";

        copy(philosopher.begin(), philosopher.end(), ostream_iterator<string>(cout, " "));
        cout << endl;

        vector<double> vd(10, -1.2);

        copy(vd.begin(), vd.end(), ostream_iterator<double>(cout, " "));
        cout << endl;
    }

    {
        vector<double> v;

        v.push_back(2.7);
        v.push_back(5.6);
        v.push_back(7.9);

        for(int i = 0; i < v.size(); ++i)
        {
            cout << "v[" << i << "] = " << v[i] << '\n';
        }
    }

    {
        vector<double> temps;
        double temp;
        while (cin >> temp)
        {
            temps.push_back(temp);
        }
        cin.clear();
        while (cin.get() != '\n')
        {
            continue;
        }
        cout << "Average temperature: " << accumulate(temps.begin(), temps.end(), 0.0) / temps.size() << endl;
        try
        {
            cout << "Median temperature: " << median(temps) << endl;
        }
        catch (domain_error &e1)
        {
            cout << e1.what() << endl;
        }
    }

    {
        vector<string> words;
        string temp;
        while (cin >> temp)
        {
            words.push_back(temp);
        }

        cout << "Number of words: " << words.size() << endl;

        sort(words.begin(), words.end());

        for (int i = 0; i < words.size(); ++i)
        {
            if (i == 0 || words[i - 1] != words[i])
            {
                cout << words[i] << "\n";
            }
        }
    }

}
显示结果如下

0       0
1       1
2       4
3       9
4       16
5       25
6       36
7       49
8       64
9       81
5 7 9 4 6 8
Kant Plato Hume Kierkegaard
-1.2 -1.2 -1.2 -1.2 -1.2 -1.2 -1.2 -1.2 -1.2 -1.2
v[0] = 2.7
v[1] = 5.6
v[2] = 7.9
1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8 9.9 end
Average temperature: 5.5
Median temperature: 5.5
Peter Smith Mike Pence Peter Mike Water Mike Smith Peter Flower
Number of words: 11
Flower
Mike
Pence
Peter
Smith
Water

ch04_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    double d = 0;
    double d_conv = 0;
    double smallest = 0;
    double largest = 0;
    double sum = 0;
    vector<double> vals;
    int ctr = 0;
    string unit;
    bool is_first = true;
    bool is_valid = true;
    while (cin >> d && cin >> unit)
    {
        if (unit == "cm")
        {
            d_conv = d / 100;
        }
        else if (unit == "m")
        {
            d_conv = d;
        }
        else if (unit == "in")
        {
            d_conv = d * 0.0254;
        }
        else if (unit == "ft")
        {
            d_conv = d * 0.0254 * 12;
        }
        else
        {
            is_valid = false;
        }
        if (is_valid)
        {
            cout << d << ' ' << unit;
            if (d_conv < smallest || is_first)
            {
                smallest = d_conv;
                cout << " the smallest so far";
            }
            if (d_conv > largest || is_first)
            {
                largest = d_conv;
                cout << " the largest so far";
            }
            vals.push_back(d_conv);
            sum += d_conv;
            ++ctr;
            is_first = false;
        }
        else
        {
            cout << "invalid unit";
        }
        cout << endl;
        is_valid = true;
    }
    cout << "smallest value: " << smallest << " m\n";
    cout << "largest value: " << largest << " m\n";
    cout << "number of values: " << ctr << endl;
    cout << "sum of values: " << sum << " m\n";
    sort(vals.begin(), vals.end());
    cout << "values:" << endl;
    for (int i = 0; i < vals.size(); ++i)
    {
        cout << vals[i] << " m\n";
    }
    return 0;
}
显示结果如下
10cm
10 cm the smallest so far the largest so far
2.5in
2.5 in the smallest so far
5ft
5 ft the largest so far
3.33m
3.33 m the largest so far
smallest value: 0.0635 m
largest value: 3.33 m
number of values: 4
sum of values: 5.0175 m
values:
0.0635 m
0.1 m
1.524 m
3.33 m

ch04_p01a.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    const double dollars_per_yen = 0.01;
    const double dollars_per_euro = 1.35;
    const double dollars_per_pound = 1.61;
    const double dollars_per_yuan = 0.16;
    const double dollars_per_kroner = 0.18;
    double amount = 0;
    char currency = ' ';
    cout << "Please enter an amount followed by a currency (Y, U, p, y or k):\n";
    cin >> amount >> currency;

    switch (currency)
    {
    case 'Y':
        cout << amount << " yen is " << dollars_per_yen *amount << " dollars\n";
        break;
    case 'U':
        cout << amount << " euro is " << dollars_per_euro *amount << " dollars\n";
        break;
    case 'p':
        cout << amount << " pound is " << dollars_per_pound *amount << " dollars\n";
        break;
    case 'y':
        cout << amount << " yuan is " << dollars_per_yuan *amount << " dollars\n";
        break;
    case 'k':
        cout << amount << " kroner is " << dollars_per_kroner *amount << " dollars\n";
        break;
    default:
        cout << "Sorry, I don't know the currency '" << currency << "'\n";
        break;
    }
    return 0;
}
显示结果如下
Please enter an amount followed by a currency (Y, U, p, y or k):
100U
100 euro is 135 dollars

Please enter an amount followed by a currency (Y, U, p, y or k):
100y
100 yuan is 16 dollars

Please enter an amount followed by a currency (Y, U, p, y or k):
100p
100 pound is 161 dollars

ch04_p01b.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    vector<string> words;
    string temp;
    while (cin >> temp)
    {
        words.push_back(temp);
    }
    vector<string> dislikeds;
    dislikeds.push_back("Broccoli");
    dislikeds.push_back("Chewbacca");
    dislikeds.push_back("Eggplant");
    for (int i = 0; i < words.size(); ++i)
    {
        bool is_disliked = false;
        for (int j = 0; j < dislikeds.size(); ++j)
        {
            if (dislikeds[j] == words[i])
            {
                is_disliked = true;
            }
        }
        if (is_disliked)
        {
            cout << "BLEEP ";
        }
        else
        {
            cout << words[i] << ' ';
        }
    }
    cout << endl;
    return 0;
}
显示结果如下
Peter Smith Broccoli Mike Pence Chewbacca Hello World Eggplant Flower
Peter Smith BLEEP Mike Pence BLEEP Hello World BLEEP Flower

ch04_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

int main()
{
    vector<double> temps;
    double temp;
    while (cin >> temp)
    {
        temps.push_back(temp);
    }
    cout << "Average temperature: " << accumulate(temps.begin(), temps.end(), 0.0) / temps.size() << endl;
    try
    {
        cout << "Median temperature: " << median(temps) << endl;
    }
    catch (domain_error &e1)
    {
        cout << e1.what() << endl;
    }

    return 0;
}
显示结果如下
1.2 2.6 3.8 4.5 5.6 6.7
Average temperature: 4.06667
Median temperature: 4.15

ch04_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    vector<double> distances;
    double distance;
    double total = 0;
    double smallest = 0;
    double greatest = 0;
    double mean = 0;
    while (cin >> distance)
    {
        if (distance > 0)
        {
            distances.push_back(distance);
        }
    }
    if (distances.size() == 0)
    {
        error("No valid values entered");
    }
    smallest = distances[0];
    greatest = distances[0];
    for (int i = 0; i < distances.size(); ++i)
    {
        total += distances[i];
        if (distances[i] < smallest)
        {
            smallest = distances[i];
        }
        if (distances[i] > greatest)
        {
            greatest = distances[i];
        }
    }
    mean = total / distances.size();
    cout << "Total distance: " << total << endl;
    cout << "Smallest distance: " << smallest << endl;
    cout << "Greatest distance: " << greatest << endl;
    cout << "Mean distance: " << mean << endl;
    return 0;
}
显示结果如下
1.2 2.6 3.8 4.5 5.6 6.7
Total distance: 24.4
Smallest distance: 1.2
Greatest distance: 6.7
Mean distance: 4.06667

ch04_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    cout << "Think of a number between 1 and 100.\n";
    cout << "For every guess, enter if your number is\n";
    cout << "(l)arger or (s)maller than the one shown.\n";
    cout << "Enter 'c' (for 'correct') if the number shown is yours.\n";

    int guess = 50;
    vector<int> differences(6);
    differences[0] = 25;
    differences[1] = 13;
    differences[2] = 6;
    differences[3] = 3;
    differences[4] = 2;
    differences[5] = 1;
    int counter = 0;
    char answer = ' ';

    while (answer != 'c')
    {
        cout << "My guess: " << guess << endl;
        ++counter;
        cout << "Correct, larger or smaller (c, l, s)? ";
        cin >> answer;
        switch (answer)
        {
        case 'c':
            break;
        case 'l':
            if (counter <= differences.size())
            {
                guess += differences[counter - 1];
            }
            else
            {
                ++guess;
            }
            break;
        case 's':
            if (counter <= differences.size())
            {
                guess -= differences[counter - 1];
            }
            else
            {
                --guess;
            }
            break;
        default:
            cout << "This is not a valid answer, use 'c', 'l' or 's'\n";
            --counter;
            break;
        }
        if (guess > 100 || guess < 1)
        {
            cout << "Your number must be between 1 and 100!\n";
            return 0;
        }
        if (counter == 7 && answer != 'c')
        {
            cout << "Super fishy, dude. I should have your number by now.\n";
            return 0;
        }
    }

    string s_try;
    if (counter == 1)
    {
        s_try = " try ";
    }
    else
    {
        s_try = " tries ";
    }
    cout << "It took me " << counter << s_try << "to find your number, " << guess << ".\n";
}
显示结果如下
Think of a number between 1 and 100.
For every guess, enter if your number is
(l)arger or (s)maller than the one shown.
Enter 'c' (for 'correct') if the number shown is yours.
My guess: 50
Correct, larger or smaller (c, l, s)? l
My guess: 75
Correct, larger or smaller (c, l, s)? s
My guess: 62
Correct, larger or smaller (c, l, s)? l
My guess: 68
Correct, larger or smaller (c, l, s)? l
My guess: 71
Correct, larger or smaller (c, l, s)? s
My guess: 69
Correct, larger or smaller (c, l, s)? l
My guess: 70
Correct, larger or smaller (c, l, s)? c
It took me 7 tries to find your number, 70.

ch04_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    cout << "Enter two double values and character (+, -, * or /)\n";
    double val1 = 0;
    double val2 = 0;
    char op = ' ';
    while (cin >> val1 && cin >> val2 && cin >> op)
    {
        switch (op)
        {
        case '+':
            cout << "The sum of " << val1 << " and " << val2 << " is " << val1 + val2 << ".\n";
            break;
        case '-':
            cout << "The difference of " << val1 << " and " << val2 << " is " << val1 - val2 << ".\n";
            break;
        case '*':
            cout << "The product of " << val1 << " and " << val2 << " is " << val1 *val2 << ".\n";
            break;
        case '/':
            cout << "The ratio of " << val1 << " and " << val2 << " is " << val1 / val2 << ".\n";
            break;
        default:
            cout << "This is not a valid operation (use +, -, * or /)\n";
            break;
        }
    }
}
显示结果如下
Enter two double values and character (+, -, * or /)
2 3 +
The sum of 2 and 3 is 5.
2 3 -
The difference of 2 and 3 is -1.
2 3 *
The product of 2 and 3 is 6.
2 3 /
The ratio of 2 and 3 is 0.666667.

ch04_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}


int main()
{
    vector<string> s_digits;
    s_digits.push_back("zero");
    s_digits.push_back("one");
    s_digits.push_back("two");
    s_digits.push_back("three");
    s_digits.push_back("four");
    s_digits.push_back("five");
    s_digits.push_back("six");
    s_digits.push_back("seven");
    s_digits.push_back("eight");
    s_digits.push_back("nine");
    vector<string> i_digits;
    i_digits.push_back("0");
    i_digits.push_back("1");
    i_digits.push_back("2");
    i_digits.push_back("3");
    i_digits.push_back("4");
    i_digits.push_back("5");
    i_digits.push_back("6");
    i_digits.push_back("7");
    i_digits.push_back("8");
    i_digits.push_back("9");
    string inp = "";
    while (cin >> inp)
    {
        bool was_found = false;
        for (int i = 0; i < s_digits.size(); ++i)
        {
            if (s_digits[i] == inp)
            {
                cout << i << endl;
                was_found = true;
            }
            if (i_digits[i] == inp)
            {
                cout << s_digits[i] << endl;
                was_found = true;
            }
        }
        if (!was_found)
        {
            cout << "Input must be zero, one, ..., nine or 0-9\n";
        }
    }
}
显示结果如下
1
one
2
two
3
three
seven
7
six
6
five
5

ch04_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

vector<string> s_digits;

void init_vector()
{
    s_digits.push_back("zero");
    s_digits.push_back("one");
    s_digits.push_back("two");
    s_digits.push_back("three");
    s_digits.push_back("four");
    s_digits.push_back("five");
    s_digits.push_back("six");
    s_digits.push_back("seven");
    s_digits.push_back("eight");
    s_digits.push_back("nine");
}

int get_number()
{
    int inp = 0;
    if (cin>>inp)
    {
        return inp;
    }
    cin.clear();
    string inp_s;
    cin >> inp_s;
    for (int i = 0; i<s_digits.size(); ++i)
    {
        if (s_digits[i]==inp_s)
        {
            return i;
        }
    }
    return (-1);
}

int main()
{
    init_vector();
    cout << "Enter two values (number or single digit spelled out) separated by\n"
        << "a character (+, -, * or /). Enter 'q' as operator to exit.\n";
    while (true)
    {
        int val1 = 0;
        int val2 = 0;
        char op = 0;
        val1 = get_number();
        cin >> op;
        val2 = get_number();
        if (val1==-1 || val2==-1)
        {
            cout << "Numbers must be int or, when spelled out, single digit\n";
        }
        else
        {
            switch (op)
            {
            case '+':
                cout << "The sum of " << val1 << " and " << val2 << " is " << val1+val2 << ".\n";
                break;
            case '-':
                cout << "The difference of " << val1 << " and " << val2 << " is " << val1-val2 << ".\n";
                break;
            case '*':
                cout << "The product of " << val1 << " and " << val2 << " is " << val1*val2 << ".\n";
                break;
            case '/':
                if (val2==0)
                {
                    cout << "No division by zero!\n";
                }
                else
                {
                    cout << "The ratio of " << val1 << " and " << val2 << " is " << double(val1)/val2 << ".\n";
                }
                break;
            case 'q':
                return 0;
            default:
                cout << "This is not a valid operation (use +, -, * or /)\n";
                break;
            }
        }
    }
}
显示结果如下
Enter two values (number or single digit spelled out) separated by
a character (+, -, * or /). Enter 'q' as operator to exit.
3 + 9
The sum of 3 and 9 is 12.
3 - nine
The difference of 3 and 9 is -6.
3 * nine
The product of 3 and 9 is 27.
3 / nine
The ratio of 3 and 9 is 0.333333.
3 q nine

ch04_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    double on_square = 1;
    double total = 0;
    cout << "Square" << '\t' << "Grains" << '\t' << "Total\n";
    for (int square = 1; square <= 64; ++square)
    {
        total += on_square;
        cout << square << '\t' << on_square << '\t' << total << endl;
        on_square *= 2;
    }
    return 0;
}
显示结果如下
Square  Grains  Total
1       1       1
2       2       3
3       4       7
4       8       15
5       16      31
6       32      63
7       64      127
8       128     255
9       256     511
10      512     1023
11      1024    2047
12      2048    4095
13      4096    8191
14      8192    16383
15      16384   32767
16      32768   65535
17      65536   131071
18      131072  262143
19      262144  524287
20      524288  1.04858e+06
21      1.04858e+06     2.09715e+06
22      2.09715e+06     4.1943e+06
23      4.1943e+06      8.38861e+06
24      8.38861e+06     1.67772e+07
25      1.67772e+07     3.35544e+07
26      3.35544e+07     6.71089e+07
27      6.71089e+07     1.34218e+08
28      1.34218e+08     2.68435e+08
29      2.68435e+08     5.36871e+08
30      5.36871e+08     1.07374e+09
31      1.07374e+09     2.14748e+09
32      2.14748e+09     4.29497e+09
33      4.29497e+09     8.58993e+09
34      8.58993e+09     1.71799e+10
35      1.71799e+10     3.43597e+10
36      3.43597e+10     6.87195e+10
37      6.87195e+10     1.37439e+11
38      1.37439e+11     2.74878e+11
39      2.74878e+11     5.49756e+11
40      5.49756e+11     1.09951e+12
41      1.09951e+12     2.19902e+12
42      2.19902e+12     4.39805e+12
43      4.39805e+12     8.79609e+12
44      8.79609e+12     1.75922e+13
45      1.75922e+13     3.51844e+13
46      3.51844e+13     7.03687e+13
47      7.03687e+13     1.40737e+14
48      1.40737e+14     2.81475e+14
49      2.81475e+14     5.6295e+14
50      5.6295e+14      1.1259e+15
51      1.1259e+15      2.2518e+15
52      2.2518e+15      4.5036e+15
53      4.5036e+15      9.0072e+15
54      9.0072e+15      1.80144e+16
55      1.80144e+16     3.60288e+16
56      3.60288e+16     7.20576e+16
57      7.20576e+16     1.44115e+17
58      1.44115e+17     2.8823e+17
59      2.8823e+17      5.76461e+17
60      5.76461e+17     1.15292e+18
61      1.15292e+18     2.30584e+18
62      2.30584e+18     4.61169e+18
63      4.61169e+18     9.22337e+18
64      9.22337e+18     1.84467e+19

ch04_p10.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    cout << "How many different moves (at least one) should the computer have?\n";
    int num_moves = 0;
    cin >> num_moves;
    if (num_moves < 1)
    {
        error("Number of moves must be at least 1");
    }
    vector<char> comp_moves;
    cout << "Enter the computer moves as 'r', 'p' or 's'\n";
    for (int i = 0; i < num_moves; ++i)
    {
        char next_move = 0;
        cin >> next_move;
        if (next_move == 'r' || next_move == 'p' || next_move == 's')
        {
            comp_moves.push_back(next_move);
        }
        else
        {
            cout << "Invalid move, use 'r', 'p' or 's'\n";
            --i;
        }
    }

    cout << "***Starting game***\n";
    cout << "Enter r, p or s to play, q to quit\n";
    char player_move = 0;
    int comp_move = 0;
    int p_score = 0;
    int c_score = 0;
    int ties = 0;
    while (true)
    {
        cin >> player_move;
        cout << "Player: " << player_move << " Computer: " << comp_moves[comp_move] << endl;
        switch (player_move)
        {
        case 'r':
            switch (comp_moves[comp_move])
            {
            case 'r':
                ++ties;
                cout << "Tie!\n";
                break;
            case 'p':
                ++c_score;
                cout << "I win!\n";
                break;
            case 's':
                ++p_score;
                cout << "You win!\n";
                break;
            }
            break;
        case 'p':
            switch (comp_moves[comp_move])
            {
            case 'r':
                ++p_score;
                cout << "You win!\n";
                break;
            case 'p':
                ++ties;
                cout << "Tie!\n";
                break;
            case 's':
                ++c_score;
                cout << "I win!\n";
                break;
            }
            break;
        case 's':
            switch (comp_moves[comp_move])
            {
            case 'r':
                ++c_score;
                cout << "I win!\n";
                break;
            case 'p':
                ++p_score;
                cout << "You win!\n";
                break;
            case 's':
                ++ties;
                cout << "Tie!\n";
                break;
            }
            break;
        case 'q':
            return 0;
        default:
            cout << "Invalid move, use 'r', 'p' or 's' to play, 'q' to quit\n";
            break;
        }
        cout << "Score: Player " << p_score << " Computer " << c_score << " Ties " << ties << endl;
        ++comp_move;
        if (comp_move == comp_moves.size())
        {
            comp_move = 0;
        }
    }
    return 0;
}
显示结果如下
How many different moves (at least one) should the computer have?
5
Enter the computer moves as 'r', 'p' or 's'
r s p p r
***Starting game***
Enter r, p or s to play, q to quit
s
Player: s Computer: r
I win!
Score: Player 0 Computer 1 Ties 0
s
Player: s Computer: s
Tie!
Score: Player 0 Computer 1 Ties 1
s
Player: s Computer: p
You win!
Score: Player 1 Computer 1 Ties 1
p
Player: p Computer: p
Tie!
Score: Player 1 Computer 1 Ties 2
p
Player: p Computer: r
You win!
Score: Player 2 Computer 1 Ties 2
r
Player: r Computer: r
Tie!
Score: Player 2 Computer 1 Ties 3
q
Player: q Computer: s

ch04_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

vector<int> primes_norm;

bool is_prime(int n)
{
    for (int i = 0; i < primes_norm.size() && primes_norm[i]<=sqrt(n); ++i)
    {
        if (n % primes_norm[i] == 0)
        {
            return false;
        }
    }
    return true;
}

int main()
{
    cout << "How many primes should I find?\n";
    int n_primes = 0;
    cin >> n_primes;
    primes_norm.push_back(2);
    int i = 3;
    while (primes_norm.size() < n_primes)
    {
        if (is_prime(i))
        {
            primes_norm.push_back(i);
        }
        i+=2;
    }

    cout << endl;

    for (int i = 0; i < primes_norm.size(); ++i)
    {
        cout << primes_norm[i] << endl;
    }
}
显示结果如下
How many primes should I find?
30

2
3
5
7
11
13
17
19
23
29
31
37
41
43
47
53
59
61
67
71
73
79
83
89
97
101
103
107
109
113

复习之前学习的Jumping Into C++中的习题
12.设计算法找出从1到1000中质因子相加是质数的数（例如，12有质因子2、2和3，相加得7，是质数）。完成代码。
ch04_p12.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

vector<int> primes_norm;

bool is_prime(int n)
{
    for (int i = 0; i < primes_norm.size() && primes_norm[i] <= sqrt(n); ++i)
    {
        if (n % primes_norm[i] == 0)
        {
            return false;
        }
    }
    return true;
}

int getPrimeFactor(int n)
{
    if (n <= 1)
    {
        return 0;
    }

    for (int i = 0; i < primes_norm.size() && primes_norm[i] <= sqrt(n); ++i)
    {
        if (n % primes_norm[i] == 0)
        {
            return primes_norm[i];
        }
    }

    return 0;
}

string numberHasPrimeFactorsWhichSumToPrime(int n)
{
    if (n <= 1)
    {
        return "";
    }
    if (is_prime(n))
    {
        return to_string(n) + " is prime number.\n";
    }

    int remainder = n;
    int currentSum = 0;
    string message = to_string(n) + " has prime factors: ";
    bool isFirstTerm = true;
    while (true)
    {
        int primeFactor = getPrimeFactor(remainder);
        if (primeFactor == 0)
        {
            return "An error has occurred with number " + to_string(n) + "\n";
        }
        if (!isFirstTerm)
        {
            message += ", ";
        }
        message += to_string(primeFactor);

        currentSum += primeFactor;
        remainder = (remainder / primeFactor);

        if (is_prime(remainder))
        {
            if (is_prime(remainder + currentSum))
            {
                message += ", " + to_string(remainder);
                message += " Which sum to: " + to_string(remainder + currentSum) + "\n";
                return message;
            }
            return "";
        }
        isFirstTerm = false;
    }
    return "";
}

int main()
{
    int n_primes = 200;
    primes_norm.push_back(2);
    int i = 3;
    while (primes_norm.size() < n_primes)
    {
        if (is_prime(i))
        {
            primes_norm.push_back(i);
        }
        i += 2;
    }

    for (int i = 1; i <= 1000; i++)
    {
        string message = numberHasPrimeFactorsWhichSumToPrime(i);
        if (!(message == ""))
        {
            cout << message;
        }
    }
}
显示结果如下
2 is prime number.
3 is prime number.
5 is prime number.
6 has prime factors: 2, 3 Which sum to: 5
7 is prime number.
10 has prime factors: 2, 5 Which sum to: 7
11 is prime number.
12 has prime factors: 2, 2, 3 Which sum to: 7
13 is prime number.
17 is prime number.
19 is prime number.
22 has prime factors: 2, 11 Which sum to: 13
23 is prime number.
28 has prime factors: 2, 2, 7 Which sum to: 11
29 is prime number.
31 is prime number.
34 has prime factors: 2, 17 Which sum to: 19
37 is prime number.
40 has prime factors: 2, 2, 2, 5 Which sum to: 11
41 is prime number.
43 is prime number.
45 has prime factors: 3, 3, 5 Which sum to: 11
47 is prime number.
48 has prime factors: 2, 2, 2, 2, 3 Which sum to: 11
52 has prime factors: 2, 2, 13 Which sum to: 17
53 is prime number.
54 has prime factors: 2, 3, 3, 3 Which sum to: 11
56 has prime factors: 2, 2, 2, 7 Which sum to: 13
58 has prime factors: 2, 29 Which sum to: 31
59 is prime number.
61 is prime number.
63 has prime factors: 3, 3, 7 Which sum to: 13
67 is prime number.
71 is prime number.
73 is prime number.
75 has prime factors: 3, 5, 5 Which sum to: 13
76 has prime factors: 2, 2, 19 Which sum to: 23
79 is prime number.
80 has prime factors: 2, 2, 2, 2, 5 Which sum to: 13
82 has prime factors: 2, 41 Which sum to: 43
83 is prime number.
88 has prime factors: 2, 2, 2, 11 Which sum to: 17
89 is prime number.
90 has prime factors: 2, 3, 3, 5 Which sum to: 13
96 has prime factors: 2, 2, 2, 2, 2, 3 Which sum to: 13
97 is prime number.
99 has prime factors: 3, 3, 11 Which sum to: 17
101 is prime number.
103 is prime number.
104 has prime factors: 2, 2, 2, 13 Which sum to: 19
107 is prime number.
108 has prime factors: 2, 2, 3, 3, 3 Which sum to: 13
109 is prime number.
113 is prime number.
117 has prime factors: 3, 3, 13 Which sum to: 19
118 has prime factors: 2, 59 Which sum to: 61
127 is prime number.
131 is prime number.
136 has prime factors: 2, 2, 2, 17 Which sum to: 23
137 is prime number.
139 is prime number.
142 has prime factors: 2, 71 Which sum to: 73
147 has prime factors: 3, 7, 7 Which sum to: 17
148 has prime factors: 2, 2, 37 Which sum to: 41
149 is prime number.
151 is prime number.
153 has prime factors: 3, 3, 17 Which sum to: 23
157 is prime number.
163 is prime number.
165 has prime factors: 3, 5, 11 Which sum to: 19
167 is prime number.
172 has prime factors: 2, 2, 43 Which sum to: 47
173 is prime number.
175 has prime factors: 5, 5, 7 Which sum to: 17
176 has prime factors: 2, 2, 2, 2, 11 Which sum to: 19
179 is prime number.
181 is prime number.
184 has prime factors: 2, 2, 2, 23 Which sum to: 29
191 is prime number.
193 is prime number.
197 is prime number.
198 has prime factors: 2, 3, 3, 11 Which sum to: 19
199 is prime number.
202 has prime factors: 2, 101 Which sum to: 103
207 has prime factors: 3, 3, 23 Which sum to: 29
210 has prime factors: 2, 3, 5, 7 Which sum to: 17
211 is prime number.
214 has prime factors: 2, 107 Which sum to: 109
223 is prime number.
224 has prime factors: 2, 2, 2, 2, 2, 7 Which sum to: 17
227 is prime number.
229 is prime number.
233 is prime number.
239 is prime number.
241 is prime number.
245 has prime factors: 5, 7, 7 Which sum to: 19
248 has prime factors: 2, 2, 2, 31 Which sum to: 37
250 has prime factors: 2, 5, 5, 5 Which sum to: 17
251 is prime number.
252 has prime factors: 2, 2, 3, 3, 7 Which sum to: 17
257 is prime number.
263 is prime number.
268 has prime factors: 2, 2, 67 Which sum to: 71
269 is prime number.
271 is prime number.
273 has prime factors: 3, 7, 13 Which sum to: 23
274 has prime factors: 2, 137 Which sum to: 139
277 is prime number.
279 has prime factors: 3, 3, 31 Which sum to: 37
281 is prime number.
283 is prime number.
293 is prime number.
294 has prime factors: 2, 3, 7, 7 Which sum to: 19
296 has prime factors: 2, 2, 2, 37 Which sum to: 43
298 has prime factors: 2, 149 Which sum to: 151
300 has prime factors: 2, 2, 3, 5, 5 Which sum to: 17
307 is prime number.
311 is prime number.
313 is prime number.
316 has prime factors: 2, 2, 79 Which sum to: 83
317 is prime number.
320 has prime factors: 2, 2, 2, 2, 2, 2, 5 Which sum to: 17
325 has prime factors: 5, 5, 13 Which sum to: 23
328 has prime factors: 2, 2, 2, 41 Which sum to: 47
331 is prime number.
333 has prime factors: 3, 3, 37 Which sum to: 43
337 is prime number.
345 has prime factors: 3, 5, 23 Which sum to: 31
347 is prime number.
349 is prime number.
350 has prime factors: 2, 5, 5, 7 Which sum to: 19
353 is prime number.
358 has prime factors: 2, 179 Which sum to: 181
359 is prime number.
360 has prime factors: 2, 2, 2, 3, 3, 5 Which sum to: 17
367 is prime number.
368 has prime factors: 2, 2, 2, 2, 23 Which sum to: 31
369 has prime factors: 3, 3, 41 Which sum to: 47
373 is prime number.
376 has prime factors: 2, 2, 2, 47 Which sum to: 53
379 is prime number.
382 has prime factors: 2, 191 Which sum to: 193
383 is prime number.
384 has prime factors: 2, 2, 2, 2, 2, 2, 2, 3 Which sum to: 17
385 has prime factors: 5, 7, 11 Which sum to: 23
388 has prime factors: 2, 2, 97 Which sum to: 101
389 is prime number.
390 has prime factors: 2, 3, 5, 13 Which sum to: 23
394 has prime factors: 2, 197 Which sum to: 199
397 is prime number.
399 has prime factors: 3, 7, 19 Which sum to: 29
401 is prime number.
405 has prime factors: 3, 3, 3, 3, 5 Which sum to: 17
409 is prime number.
412 has prime factors: 2, 2, 103 Which sum to: 107
414 has prime factors: 2, 3, 3, 23 Which sum to: 31
416 has prime factors: 2, 2, 2, 2, 2, 13 Which sum to: 23
419 is prime number.
420 has prime factors: 2, 2, 3, 5, 7 Which sum to: 19
421 is prime number.
423 has prime factors: 3, 3, 47 Which sum to: 53
424 has prime factors: 2, 2, 2, 53 Which sum to: 59
431 is prime number.
432 has prime factors: 2, 2, 2, 2, 3, 3, 3 Which sum to: 17
433 is prime number.
435 has prime factors: 3, 5, 29 Which sum to: 37
436 has prime factors: 2, 2, 109 Which sum to: 113
439 is prime number.
443 is prime number.
448 has prime factors: 2, 2, 2, 2, 2, 2, 7 Which sum to: 19
449 is prime number.
454 has prime factors: 2, 227 Which sum to: 229
457 is prime number.
461 is prime number.
462 has prime factors: 2, 3, 7, 11 Which sum to: 23
463 is prime number.
464 has prime factors: 2, 2, 2, 2, 29 Which sum to: 37
467 is prime number.
468 has prime factors: 2, 2, 3, 3, 13 Which sum to: 23
475 has prime factors: 5, 5, 19 Which sum to: 29
477 has prime factors: 3, 3, 53 Which sum to: 59
478 has prime factors: 2, 239 Which sum to: 241
479 is prime number.
486 has prime factors: 2, 3, 3, 3, 3, 3 Which sum to: 17
487 is prime number.
488 has prime factors: 2, 2, 2, 61 Which sum to: 67
491 is prime number.
499 is prime number.
500 has prime factors: 2, 2, 5, 5, 5 Which sum to: 19
503 is prime number.
504 has prime factors: 2, 2, 2, 3, 3, 7 Which sum to: 19
507 has prime factors: 3, 13, 13 Which sum to: 29
508 has prime factors: 2, 2, 127 Which sum to: 131
509 is prime number.
521 is prime number.
522 has prime factors: 2, 3, 3, 29 Which sum to: 37
523 is prime number.
536 has prime factors: 2, 2, 2, 67 Which sum to: 73
538 has prime factors: 2, 269 Which sum to: 271
541 is prime number.
547 is prime number.
549 has prime factors: 3, 3, 61 Which sum to: 67
550 has prime factors: 2, 5, 5, 11 Which sum to: 23
557 is prime number.
561 has prime factors: 3, 11, 17 Which sum to: 31
562 has prime factors: 2, 281 Which sum to: 283
563 is prime number.
567 has prime factors: 3, 3, 3, 3, 7 Which sum to: 19
569 is prime number.
570 has prime factors: 2, 3, 5, 19 Which sum to: 29
571 is prime number.
577 is prime number.
584 has prime factors: 2, 2, 2, 73 Which sum to: 79
587 is prime number.
593 is prime number.
595 has prime factors: 5, 7, 17 Which sum to: 29
599 is prime number.
600 has prime factors: 2, 2, 2, 3, 5, 5 Which sum to: 19
601 is prime number.
603 has prime factors: 3, 3, 67 Which sum to: 73
607 is prime number.
608 has prime factors: 2, 2, 2, 2, 2, 19 Which sum to: 29
613 is prime number.
617 is prime number.
619 is prime number.
622 has prime factors: 2, 311 Which sum to: 313
631 is prime number.
640 has prime factors: 2, 2, 2, 2, 2, 2, 2, 5 Which sum to: 19
641 is prime number.
643 is prime number.
647 is prime number.
651 has prime factors: 3, 7, 31 Which sum to: 41
652 has prime factors: 2, 2, 163 Which sum to: 167
653 is prime number.
657 has prime factors: 3, 3, 73 Which sum to: 79
659 is prime number.
660 has prime factors: 2, 2, 3, 5, 11 Which sum to: 23
661 is prime number.
664 has prime factors: 2, 2, 2, 83 Which sum to: 89
665 has prime factors: 5, 7, 19 Which sum to: 31
673 is prime number.
675 has prime factors: 3, 3, 3, 5, 5 Which sum to: 19
677 is prime number.
683 is prime number.
684 has prime factors: 2, 2, 3, 3, 19 Which sum to: 29
686 has prime factors: 2, 7, 7, 7 Which sum to: 23
691 is prime number.
694 has prime factors: 2, 347 Which sum to: 349
701 is prime number.
704 has prime factors: 2, 2, 2, 2, 2, 2, 11 Which sum to: 23
709 is prime number.
714 has prime factors: 2, 3, 7, 17 Which sum to: 29
715 has prime factors: 5, 11, 13 Which sum to: 29
719 is prime number.
720 has prime factors: 2, 2, 2, 2, 3, 3, 5 Which sum to: 19
727 is prime number.
733 is prime number.
739 is prime number.
743 is prime number.
747 has prime factors: 3, 3, 83 Which sum to: 89
751 is prime number.
757 is prime number.
759 has prime factors: 3, 11, 23 Which sum to: 37
761 is prime number.
768 has prime factors: 2, 2, 2, 2, 2, 2, 2, 2, 3 Which sum to: 19
769 is prime number.
772 has prime factors: 2, 2, 193 Which sum to: 197
773 is prime number.
775 has prime factors: 5, 5, 31 Which sum to: 41
776 has prime factors: 2, 2, 2, 97 Which sum to: 103
777 has prime factors: 3, 7, 37 Which sum to: 47
787 is prime number.
792 has prime factors: 2, 2, 2, 3, 3, 11 Which sum to: 23
795 has prime factors: 3, 5, 53 Which sum to: 61
797 is prime number.
798 has prime factors: 2, 3, 7, 19 Which sum to: 31
808 has prime factors: 2, 2, 2, 101 Which sum to: 107
809 is prime number.
810 has prime factors: 2, 3, 3, 3, 3, 5 Which sum to: 19
811 is prime number.
821 is prime number.
823 is prime number.
824 has prime factors: 2, 2, 2, 103 Which sum to: 109
827 is prime number.
829 is prime number.
833 has prime factors: 7, 7, 17 Which sum to: 31
838 has prime factors: 2, 419 Which sum to: 421
839 is prime number.
845 has prime factors: 5, 13, 13 Which sum to: 31
847 has prime factors: 7, 11, 11 Which sum to: 29
848 has prime factors: 2, 2, 2, 2, 53 Which sum to: 61
850 has prime factors: 2, 5, 5, 17 Which sum to: 29
853 is prime number.
856 has prime factors: 2, 2, 2, 107 Which sum to: 113
857 is prime number.
858 has prime factors: 2, 3, 11, 13 Which sum to: 29
859 is prime number.
862 has prime factors: 2, 431 Which sum to: 433
863 is prime number.
864 has prime factors: 2, 2, 2, 2, 2, 3, 3, 3 Which sum to: 19
867 has prime factors: 3, 17, 17 Which sum to: 37
873 has prime factors: 3, 3, 97 Which sum to: 103
877 is prime number.
881 is prime number.
883 is prime number.
885 has prime factors: 3, 5, 59 Which sum to: 67
887 is prime number.
891 has prime factors: 3, 3, 3, 3, 11 Which sum to: 23
892 has prime factors: 2, 2, 223 Which sum to: 227
903 has prime factors: 3, 7, 43 Which sum to: 53
907 is prime number.
909 has prime factors: 3, 3, 101 Which sum to: 107
911 is prime number.
916 has prime factors: 2, 2, 229 Which sum to: 233
919 is prime number.
922 has prime factors: 2, 461 Which sum to: 463
925 has prime factors: 5, 5, 37 Which sum to: 47
927 has prime factors: 3, 3, 103 Which sum to: 109
929 is prime number.
930 has prime factors: 2, 3, 5, 31 Which sum to: 41
937 is prime number.
941 is prime number.
944 has prime factors: 2, 2, 2, 2, 59 Which sum to: 67
947 is prime number.
950 has prime factors: 2, 5, 5, 19 Which sum to: 31
953 is prime number.
954 has prime factors: 2, 3, 3, 53 Which sum to: 61
957 has prime factors: 3, 11, 29 Which sum to: 43
963 has prime factors: 3, 3, 107 Which sum to: 113
967 is prime number.
971 is prime number.
972 has prime factors: 2, 2, 3, 3, 3, 3, 3 Which sum to: 19
977 is prime number.
980 has prime factors: 2, 2, 5, 7, 7 Which sum to: 23
983 is prime number.
991 is prime number.
992 has prime factors: 2, 2, 2, 2, 2, 31 Which sum to: 41
997 is prime number.

复习之前学习的直接计算素数表的程序
ch04_p13.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

vector<int> primes_norm;

bool is_prime(int n)
{
    for (int i = 0; i < primes_norm.size() && primes_norm[i] <= sqrt(n); ++i)
    {
        if (n % primes_norm[i] == 0)
        {
            return false;
        }
    }
    return true;
}

void init_prime(int n)
{
    if (n < 100)
    {
        return ;
    }
    primes_norm.clear();
    int i, j;
    char *buffer = new char[n + 1];
    for(i = 1; i <= n; i++)
    {
        buffer[i] = 0;
    }
    for(i = 2; i <= n; i++)
    {
        if(buffer[i] == 0)
        {
            primes_norm.push_back(i);
        }
        if( i <= ( (n / 2) + 1) )
        {
            for(j = 0; j < primes_norm.size() && primes_norm[j] * i <= n; j++)
            {
                buffer[primes_norm[j]*i] = 1;
                if(i % primes_norm[j] == 0)
                {
                    break;
                }
            }
        }
    }
    delete [] buffer;
}

int main()
{
    init_prime(100);
    for (int i = 0; i < primes_norm.size(); ++i)
    {
        cout << primes_norm[i] << endl;
    }
}
显示结果如下
2
3
5
7
11
13
17
19
23
29
31
37
41
43
47
53
59
61
67
71
73
79
83
89
97

ch04_p16.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int get_mode(vector<int> v)
{
    if (v.size() == 0)
    {
        throw domain_error("call get_mode for empty vector");
    }

    sort(v.begin(),v.end());
    int mode_cdt = v[0];
    int mode_cdt_ctr = 1;
    int mode = v[0];
    int mode_ctr = 1;
    for (int i = 1; i<v.size(); ++i)
    {
        if (v[i]==mode_cdt)
        {
            ++mode_cdt_ctr;
            if (mode_cdt_ctr>mode_ctr)
            {
                mode = mode_cdt;
                mode_ctr = mode_cdt_ctr;
            }
        }
        else
        {
            mode_cdt = v[i];
            mode_cdt_ctr = 1;
        }
    }
    cout << mode << " appears " << mode_ctr << " times.\n";
    return mode;
}

int main()
{
    int n = 0;
    int smallest = 0;
    int largest = 0;
    int mode = 0;
    vector<int> vals;
    bool is_first = true;

    cout << "Enter sequence of integers:\n";

    while (cin >> n)
    {
        if (n < smallest || is_first)
        {
            smallest = n;
        }
        if (n > largest || is_first)
        {
            largest = n;
        }
        vals.push_back(n);
        is_first = false;
    }

    mode = get_mode(vals);
    cout << "smallest value: " << smallest << endl;
    cout << "largest value: " << largest << endl;
    cout << "mode: " << mode << endl;

    cout << "values:" << endl;
    for (int i = 0; i<vals.size(); ++i)
    {
        cout << vals[i] << endl;
    }
    return 0;
}
显示结果如下
Enter sequence of integers:
1 3 5 7 5 3 6 9 3 2
3 appears 3 times.
smallest value: 1
largest value: 9
mode: 3
values:
1
3
5
7
5
3
6
9
3
2

ch04_p17.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

string get_mode(vector<string> v)
{
    if (v.size() == 0)
    {
        throw domain_error("call get_mode for empty vector");
    }

    sort(v.begin(), v.end());
    string mode_cdt = v[0];
    int mode_cdt_ctr = 1;
    string mode = v[0];
    int mode_ctr = 1;
    for (int i = 1; i < v.size(); ++i)
    {
        if (v[i] == mode_cdt)
        {
            ++mode_cdt_ctr;
            if (mode_cdt_ctr > mode_ctr)
            {
                mode = mode_cdt;
                mode_ctr = mode_cdt_ctr;
            }
        }
        else
        {
            mode_cdt = v[i];
            mode_cdt_ctr = 1;
        }
    }
    cout << mode << " appears " << mode_ctr << (mode_ctr > 1 ? " times.\n" : " time.\n");
    return mode;
}

int main()
{
    string n = "";
    string smallest = "";
    string largest = "";
    string mode = "";
    vector<string> vals;
    bool is_first = true;

    cout << "Enter sequence of strings:\n";

    while (cin >> n)
    {
        if (n < smallest || is_first)
        {
            smallest = n;
        }
        if (n > largest || is_first)
        {
            largest = n;
        }
        vals.push_back(n);
        is_first = false;
    }

    mode = get_mode(vals);
    cout << "smallest value: " << smallest << endl;
    cout << "largest value: " << largest << endl;
    cout << "mode: " << mode << endl;

    cout << "values:" << endl;
    for (int i = 0; i < vals.size(); ++i)
    {
        cout << vals[i] << endl;
    }
    return 0;
}
显示结果如下
Enter sequence of strings:
Peter Smith Mike Peter Hello Peter World Water Flower
Peter appears 3 times.
smallest value: Flower
largest value: World
mode: Peter
values:
Peter
Smith
Mike
Peter
Hello
Peter
World
Water
Flower

ch04_p18.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    cout << "Enter coefficients a, b and c of ax^2 + bx + c = 0:\n";
    double a = 0;
    double b = 0;
    double c = 0;
    while (cin >> a && cin >> b && cin >> c)
    {
        double delta = b * b - 4 * a * c;
        if (delta < 0)
        {
            cout << "Sorry, no complex math here - can't solve that! Try again:\n";
        }
        else if (delta == 0)
        {
            double x = -b / (2 * a);
            cout << "Just one solution: x = " << x << endl;
        }
        else
        {
            double x1 = (-b + sqrt(delta)) / (2 * a);
            double x2 = (-b - sqrt(delta)) / (2 * a);
            cout << "Two solutions: x1 = " << x1 << ", x2 = " << x2 << endl;
        }
    }
}
显示结果如下
Enter coefficients a, b and c of ax^2 + bx + c = 0:
1 3 2
Two solutions: x1 = -1, x2 = -2

ch04_p19.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

vector<string> names;
vector<int> scores;

void list_score(string s)
{
    int i = 0;
    while (i < names.size())
    {
        if (names[i] == s)
        {
            cout << '(' << s << ',' << scores[i] << ")\n";
            return;
        }
        ++i;
    }
    cout << "Name not found\n";
}

void list_names(int n)
{
    bool exists = false;
    for (int i = 0; i < scores.size(); ++i)
    {
        if (scores[i] == n)
        {
            cout << '(' << names[i] << ',' << n << ")\n";
            exists = true;
        }
    }
    if (!exists)
    {
        cout << "Score not found\n";
    }
}

int main()
{
    string name = " ";
    int score = 0;
    cout << "Enter name-and-value pairs such as 'Joe 17':\n";
    while (cin >> name && cin >> score)
    {
        names.push_back(name);
        scores.push_back(score);
    }

    for (int i = 0; i < names.size(); ++i)
    {
        for (int j = i + 1; j < names.size(); ++j)
        {
            if (names[i] == names[j])
            {
                error("Name appears twice!");
            }
        }
    }

    for (int i = 0; i < names.size(); ++i)
    {
        cout << '(' << names[i] << ',' << scores[i] << ")\n";
    }

    cin.clear();
    while (cin.get() != '\n')
    {
        continue;
    }
    int sc = 0;
    cout << "Enter name or score ('NoName' to exit):\n";
    while (true)
    {
        if (cin >> sc)
        {
            list_names(sc);
        }
        else
        {
            cin.clear();
            string na;
            cin >> na;
            if (na == "NoName")
            {
                return 0;
            }
            list_score(na);
        }
        cout << "Enter name or score ('NoName' to exit):\n";
    }
}
显示结果如下
Enter name-and-value pairs such as 'Joe 17':
Peter 35
Smith 53
Mike 68
Pence 96
Hello 86
World 65
Water 99
q q
(Peter,35)
(Smith,53)
(Mike,68)
(Pence,96)
(Hello,86)
(World,65)
(Water,99)
Enter name or score ('NoName' to exit):
96
(Pence,96)
Enter name or score ('NoName' to exit):
99
(Water,99)
Enter name or score ('NoName' to exit):
Smith
(Smith,53)
Enter name or score ('NoName' to exit):
Mike
(Mike,68)
Enter name or score ('NoName' to exit):
World
(World,65)
Enter name or score ('NoName' to exit):
NoName

第5章 错误
5.1 介绍
5.2 错误的来源
5.3 编译时错误
5.3.1 语法错误
5.3.2 类型错误
5.3.3 警告
5.4 连接时错误
5.5 运行时错误
5.5.1 调用者处理错误
5.5.2 被调用者处理错误
5.5.3 报告错误
5.6 异常
5.6.1 错误参数
5.6.2 范围错误
5.6.3 输入错误
5.6.4 截断错误
5.7 逻辑错误
5.8 估计
5.9 调试
5.9.1 实用调试技术
5.10 前置条件和后置条件
5.10.1 后置条件
5.11 测试
ch05_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

double ctok(double c)
{
    if (c < -273.15)
    {
        error("Temperature below absolute zero!");
    }
    double k = c + 273.15;
    return k;
}

double ktoc(double k)
{
    if (k < 0)
    {
        error("Temperature below absolute zero!");
    }
    double c = k - 273.15;
    return c;
}

int main()
{
    try
    {
        double temp = 0;
        char unit = 0;
        double t_conv = 0;
        char unit_conv = 0;

        cout << "Enter temperature to be converted and unit (C or K):\n";
        cin >> temp >> unit;
        if (unit == 'c' || unit == 'C')
        {
            t_conv = ctok(temp);
            unit_conv = 'K';
        }
        else if (unit == 'k' || unit == 'K')
        {
            t_conv = ktoc(temp);
            unit_conv = 'C';
        }
        else
        {
            error("Illegal unit, must be C or K");
        }
        cout << t_conv << ' ' << unit_conv << endl;
        return 0;
    }
    catch (exception &e)
    {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    catch (...)
    {
        cerr << "Unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter temperature to be converted and unit (C or K):
32C
305.15 K

Enter temperature to be converted and unit (C or K):
273K
-0.15 C

Enter temperature to be converted and unit (C or K):
-3K
Temperature below absolute zero!
Error: Temperature below absolute zero!

Enter temperature to be converted and unit (C or K):
-275C
Temperature below absolute zero!
Error: Temperature below absolute zero!

Enter temperature to be converted and unit (C or K):
23U
Illegal unit, must be C or K
Error: Illegal unit, must be C or K

ch05_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

double ctok(double c)
{
    if (c < -273.15)
    {
        error("Temperature below absolute zero!");
    }
    double k = c + 273.15;
    return k;
}

double ktoc(double k)
{
    if (k < 0)
    {
        error("Temperature below absolute zero!");
    }
    double c = k - 273.15;
    return c;
}

double ctof(double c)
{
    if (c < -273.15)
    {
        error("Temperature below absolute zero!");
    }
    double f = c * 9.0 / 5.0 + 32;
    return f;
}

double ftoc(double f)
{
    if (f < -459.67)
    {
        error("Temperature below absolute zero!");
    }
    double c = (f - 32) * 5.0 / 9.0;
    return c;
}

int main()
{
    try
    {
        double temp = 0;
        char unit = 0;
        double t_conv = 0;
        char unit_conv = 0;

        cout << "Enter temperature to be converted and unit (C or F):\n";
        cin >> temp >> unit;
        if (unit == 'c' || unit == 'C')
        {
            t_conv = ctof(temp);
            unit_conv = 'F';
        }
        else if (unit == 'f' || unit == 'F')
        {
            t_conv = ftoc(temp);
            unit_conv = 'C';
        }
        else
        {
            error("Illegal unit, must be C or F");
        }
        cout << t_conv << ' ' << unit_conv << endl;
        return 0;
    }
    catch (exception &e)
    {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    catch (...)
    {
        cerr << "Unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter temperature to be converted and unit (C or F):
32C
89.6 F

Enter temperature to be converted and unit (C or F):
123F
50.5556 C

Enter temperature to be converted and unit (C or F):
-275C
Temperature below absolute zero!
Error: Temperature below absolute zero!

Enter temperature to be converted and unit (C or F):
-499F
Temperature below absolute zero!
Error: Temperature below absolute zero!

Enter temperature to be converted and unit (C or F):
23K
Illegal unit, must be C or F
Error: Illegal unit, must be C or F

ch05_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

double a, b, c;
bool do_check;

double found(double x)
{
    if (!do_check)
    {
        return x;
    }
    else
    {
        const double epsilon = 1e-7;
        double e = a * x * x + b * x + c;
        if (e == 0)
        {
            return x;
        }
        if (epsilon < e)
        {
            cout << "poor root; off by " << e << endl;
        }
        else if (e < -epsilon)
        {
            cout << "poor root; off by " << e << endl;
        }
        return x;
    }
}

void quad_solver()
{
    while (cin >> a && cin >> b && cin >> c)
    {
        if (a == 0)
        {
            if (b == 0)
            {
                cout << "no root (x isn't used)\n";
            }
            else
            {
                cout << "x = " << found(-c / b) << endl;
            }
        }
        else if (b == 0)
        {
            double ca = -c / a;
            if (ca == 0)
            {
                cout << "x = 0\n";
            }
            else if (ca < 0)
            {
                cout << "no real roots\n";
            }
            else
            {
                cout << "two real roots: x = " << found(sqrt(ca)) << " and " << found(-sqrt(ca)) << endl;
            }
        }
        else
        {
            double delta = b * b - 4 * a * c;
            if (delta == 0)
            {
                cout << "one real root: " << found(-b / (2 * a)) << endl;
            }
            else if (delta < 0)
            {
                cout << "no real roots\n";
            }
            else
            {
                cout << "two real roots: " << found((-b + sqrt(delta)) / (2 * a)) << " and " << found((-b - sqrt(delta)) / (2 * a)) << endl;
            }
        }
        cout << "Enter coefficients for quadratic equation a*x^2 + b*x + c = 0\n";
    }
}

int main()
{
    try
    {
        cout << "Should your solutions be checked?\n";
        char check = 0;
        cin >> check;
        if (check == 'y' || check == 'Y')
        {
            do_check = true;
        }
        else if (check == 'n' || check == 'N')
        {
            do_check = false;
        }
        else
        {
            error("answer not recognised (try 'y' or 'n')");
        }
        cout << "Enter coefficients for quadratic equation a*x^2 + b*x + c = 0\n";
        quad_solver();
        return 0;
    }
    catch (exception &e)
    {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    catch (...)
    {
        cerr << "Unknown exception!\n";
        return 2;
    }
}
显示结果如下
Should your solutions be checked?
y
Enter coefficients for quadratic equation a*x^2 + b*x + c = 0
1 2 3
no real roots
Enter coefficients for quadratic equation a*x^2 + b*x + c = 0
1 3 2
two real roots: -1 and -2
Enter coefficients for quadratic equation a*x^2 + b*x + c = 0
1 0 3
no real roots
Enter coefficients for quadratic equation a*x^2 + b*x + c = 0
1 0 -2
two real roots: x = 1.41421 and -1.41421
Enter coefficients for quadratic equation a*x^2 + b*x + c = 0
0 2 3
x = -1.5
Enter coefficients for quadratic equation a*x^2 + b*x + c = 0
q q q

ch05_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    try
    {
        vector<int> vals;
        int val = 0;
        int n = 0;

        cout << "Please enter the number of values you want to sum:\n";
        cin >> n;
        if (n < 1)
        {
            error("You have to sum at least one value!");
        }
        cout << "Please enter some integers (press end to stop)\n";
        while (cin >> val)
        {
            vals.push_back(val);
        }

        if (vals.size() < n)
        {
            error("You wanted to sum more values than you entered");
        }

        int sum = 0;
        cout << "The sum of the first ";
        if (n > 1)
        {
            cout << n << " numbers";
        }
        else
        {
            cout << "number";
        }
        cout << " ( ";
        for (int i = 0; i < n; ++i)
        {
            sum += vals[i];
            cout << vals[i] << ' ';
        }
        cout << ") is " << sum << ".\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    catch (...)
    {
        cerr << "Unknown exception!\n";
        return 2;
    }
}
显示结果如下
Please enter the number of values you want to sum:
6
Please enter some integers (press end to stop)
1 3 5 6 8 9 15 end
The sum of the first 6 numbers ( 1 3 5 6 8 9 ) is 32.

ch05_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

double ctok(double c)
{
    if (c < -273.15)
    {
        error("Temperature below absolute zero!");
    }
    double k = c + 273.15;
    return k;
}

double ktoc(double k)
{
    if (k < 0)
    {
        error("Temperature below absolute zero!");
    }
    double c = k - 273.15;
    return c;
}

double ctof(double c)
{
    if (c < -273.15)
    {
        error("Temperature below absolute zero!");
    }
    double f_exact = c * 9.0/5.0 + 32;
    int f = int(f_exact);
    if (f != f_exact) { error("Result cannot be represented as an int!"); }
    return f;
}

double ftoc(double f)
{
    if (f < -459.67)
    {
        error("Temperature below absolute zero!");
    }
    double c_exact = (f - 32) * 5.0/9.0;
    int c =  int(c_exact);
    if (c != c_exact) { error("Result cannot be represented as an int!"); }
    return c;
}

int main()
{
    try
    {
        double temp = 0;
        char unit = 0;
        double t_conv = 0;
        char unit_conv = 0;

        cout << "Enter temperature to be converted and unit (C or F):\n";
        cin >> temp >> unit;
        if (unit == 'c' || unit == 'C')
        {
            t_conv = ctof(temp);
            unit_conv = 'F';
        }
        else if (unit == 'f' || unit == 'F')
        {
            t_conv = ftoc(temp);
            unit_conv = 'C';
        }
        else
        {
            error("Illegal unit, must be C or F");
        }
        cout << t_conv << ' ' << unit_conv << endl;
        return 0;
    }
    catch (exception &e)
    {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    catch (...)
    {
        cerr << "Unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter temperature to be converted and unit (C or F):
32C
Result cannot be represented as an int!
Error: Result cannot be represented as an int!

Enter temperature to be converted and unit (C or F):
32F
0 C

Enter temperature to be converted and unit (C or F):
30C
86 F

ch05_p10.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    try
    {
        vector<double> vals;
        vector<double> diffs;
        double val = 0;
        int n = 0;

        cout << "Please enter the number of values you want to sum:\n";
        cin >> n;
        if (n < 1)
        {
            error("You have to sum at least one value!");
        }
        cout << "Please enter some doubles (press quit to stop)\n";
        while (cin >> val)
        {
            if (vals.size() >= 1)
            {
                diffs.push_back(val - vals[vals.size() - 1]);
            }
            vals.push_back(val);
        }

        if (vals.size() < 2)
        {
            cout << "You need at least two values to get a vector of differences\n";
        }
        else
        {
            cout << "Vector of differences:\n";
            for (int i = 0; i < diffs.size(); ++i)
            {
                cout << diffs[i] << endl;
            }
        }

        if (vals.size() < n)
        {
            error("You wanted to sum more values than you entered");
        }

        double sum = 0;
        cout << "The sum of the first ";
        if (n > 1)
        {
            cout << n << " numbers";
        }
        else
        {
            cout << "number";
        }
        cout << " ( ";
        for (int i = 0; i < n; ++i)
        {
            sum += vals[i];
            cout << vals[i] << ' ';
        }
        cout << ") is " << sum << ".\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    catch (...)
    {
        cerr << "Unknown exception!\n";
        return 2;
    }
}
显示结果如下
Please enter the number of values you want to sum:
6
Please enter some doubles (press quit to stop)
1.1 2.5 3.8 5.3 6.9 7.6 9.5 quit
Vector of differences:
1.4
1.3
1.5
1.6
0.7
1.9
The sum of the first 6 numbers ( 1.1 2.5 3.8 5.3 6.9 7.6 ) is 27.2.

ch05_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <cstring>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int main()
{
    try
    {
        char largest = 0;
        cout << "Do you just want to find the largest Fibonacci number (y/n)?\n";
        cin >> largest;
        if (!(largest == 'y' || largest == 'n' || largest == 'Y' || largest == 'N'))
        {
            error("Please enter either 'y' or 'n'");
        }
        vector<int> fib;
        fib.push_back(1);
        fib.push_back(1);
        if (largest == 'n' || largest == 'N')
        {
            int n = 0;
            cout << "How many Fibonacci numbers do you want to see?\n";
            cin >> n;
            if (n < 10)
            {
                error("Please enter a number >= 10");
            }
            for (int i = 2; i < n; ++i)
            {
                fib.push_back(fib[i - 1] + fib[i - 2]);
            }

            cout << "Fibonacci numbers:\n";
            for (int i = 0; i < n; ++i)
            {
                cout << fib[i] << endl;
            }
        }
        else
        {
            while (fib[fib.size() - 1] + fib[fib.size() - 2] > fib[fib.size() - 1])
            {
                fib.push_back(fib[fib.size() - 1] + fib[fib.size() - 2]);
            }
            cout << "The biggest Fibonacci number to fit in an int is " << fib[fib.size() - 1] << endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    catch (...)
    {
        cerr << "Unknown exception!\n";
        return 2;
    }
}
显示结果如下
Do you just want to find the largest Fibonacci number (y/n)?
y
The biggest Fibonacci number to fit in an int is 1836311903

Do you just want to find the largest Fibonacci number (y/n)?
n
How many Fibonacci numbers do you want to see?
30
Fibonacci numbers:
1
1
2
3
5
8
13
21
34
55
89
144
233
377
610
987
1597
2584
4181
6765
10946
17711
28657
46368
75025
121393
196418
317811
514229
832040

ch05_p12.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_improved(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

template<class T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int bulls = 0;
int cows = 0;

vector<int> get_new_solution(mt19937 &e)
{
    vector<int> solution(4);
    solution[0] = nrand_improved(10, e);
    solution[1] = nrand_improved(10, e);
    solution[2] = nrand_improved(10, e);
    solution[3] = nrand_improved(10, e);
    return solution;
}

vector<int> int_to_vector(int n)
{
    if (n > 9999 || n < 0)
    {
        error("int_to_vector called with wrong number");
    }
    vector<int> v(4);
    v[0] = n / 1000 % 10;
    v[1] = n / 100 % 10;
    v[2] = n / 10 % 10;
    v[3] = n % 10;
    return v;
}

void check_guess(const vector<int> &guess, const vector<int> &solution)
{
    bulls = 0;
    cows = 0;
    vector<char> is_bull(4, 'n');
    vector<char> is_cow(4, 'n');
    for (int i = 0; i < solution.size(); ++i)
    {
        if (guess[i] == solution[i])
        {
            ++bulls;
            is_bull[i] = 'y';
        }
    }
    for (int i = 0; i < solution.size(); ++i)
    {
        if (is_bull[i] == 'n')
        {
            for (int j = 0; j < guess.size(); ++j)
            {
                if (is_bull[j] == 'n' && is_cow[j] == 'n')
                {
                    if (solution[i] == guess[j])
                    {
                        ++cows;
                        is_cow[j] = 'y';
                    }
                }
            }
        }
    }
}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);

    try
    {
        int guess = 0;
        cout << "Guess my four digit number! Numbers with less digits will be padded with zeros.\n";
        vector<int> solution = get_new_solution(engine);
        print_vector(solution, cout);
        cout << "Enter guess ('q' to exit): ";
        while (cin >> guess)
        {
            if (guess > 9999 || guess < 0)
            {
                cout << "Number must be between 0000 and 9999!\n";
            }
            else
            {
                vector<int> v_guess = int_to_vector(guess);
                check_guess(v_guess, solution);
                if (bulls == 4)
                {
                    cout << "You have guessed the number! Setting new solution...\n";
                    solution = get_new_solution(engine);
                    print_vector(solution, cout);
                }
                if (bulls < 4)
                {
                    cout << "Number of bulls: " << bulls << endl;
                    cout << "Number of cows: " << cows << endl;
                }
            }
            cout << "Enter guess ('q' to exit): ";
        }
        cout << "You gave up!\n";
        return 0;
    }
    catch (exception &e)
    {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    catch (...)
    {
        cerr << "Unknown exception!\n";
        return 2;
    }
}
显示结果如下
Guess my four digit number! Numbers with less digits will be padded with zeros.
3, 1, 6, 2
Enter guess ('q' to exit): 3256
Number of bulls: 1
Number of cows: 2
Enter guess ('q' to exit): 3165
Number of bulls: 3
Number of cows: 0
Enter guess ('q' to exit): 3162
You have guessed the number! Setting new solution...
6, 0, 6, 5
Enter guess ('q' to exit): 6163
Number of bulls: 2
Number of cows: 0
Enter guess ('q' to exit): 6136
Number of bulls: 1
Number of cows: 1
Enter guess ('q' to exit): q
You gave up!

ch05_p14.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

vector<int> mondays;
vector<int> tuesdays;
vector<int> wednesdays;
vector<int> thursdays;
vector<int> fridays;
vector<int> saturdays;
vector<int> sundays;
int rejected = 0;

int handle_input(string day, int val)
{
    int cont = 0;
    if (day == "Monday" || day == "monday" || day == "Mon" || day == "mon")
    {
        mondays.push_back(val);
    }
    else if (day == "Tuesday" || day == "tuesday" || day == "Tue" || day == "tue")
    {
        tuesdays.push_back(val);
    }
    else if (day == "Wednesday" || day == "wednesday" || day == "Wed" || day == "wed")
    {
        wednesdays.push_back(val);
    }
    else if (day == "Thursday" || day == "thursday" || day == "Thu" || day == "thu")
    {
        thursdays.push_back(val);
    }
    else if (day == "Friday" || day == "friday" || day == "Fri" || day == "fri")
    {
        fridays.push_back(val);
    }
    else if (day == "Saturday" || day == "saturday" || day == "Sat" || day == "sat")
    {
        saturdays.push_back(val);
    }
    else if (day == "Sunday" || day == "sunday" || day == "Sun" || day == "sun")
    {
        sundays.push_back(val);
    }
    else if (day == "q" && val == 0)
    {
        cont = -1;
    }
    else
    {
        ++rejected;
    }
    return cont;
}

int get_sum(const vector<int> &v)
{
    int sum = 0;
    for (int i = 0; i < v.size(); ++i)
    {
        sum += v[i];
    }
    return sum;
}

void print_day(string day, const vector<int> &v)
{
    cout << day << " (sum: " << get_sum(v) << ")\n";
    cout << "Values:";
    for (int i = 0; i < v.size(); ++i)
    {
        cout << ' ' << v[i];
    }
    cout << endl;
}

void print_results()
{
    print_day("Monday", mondays);
    print_day("Tuesday", tuesdays);
    print_day("Wednesday", wednesdays);
    print_day("Thursday", thursdays);
    print_day("Friday", fridays);
    print_day("Saturday", saturdays);
    print_day("Sunday", sundays);
    cout << rejected << " values rejected\n";
}

int main()
{
    try
    {
        string day = " ";
        int val = 0;
        cout << "Enter weekday/value pairs, exit with 'q 0'\n";
        while (cin >> day && cin >> val)
        {
            int cont = handle_input(day, val);
            if (cont == -1)
            {
                print_results();
                return 0;
            }
        }
        error("Invalid input");
    }
    catch (exception &e)
    {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    catch (...)
    {
        cerr << "Unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter weekday/value pairs, exit with 'q 0'
Mon 12
Tue 32
Wed 33
Thu 56
Fri 67
Sat 25
Sun 99
Mon 77
Tue 56
Fri 86
q 0
Monday (sum: 89)
Values: 12 77
Tuesday (sum: 88)
Values: 32 56
Wednesday (sum: 33)
Values: 33
Thursday (sum: 56)
Values: 56
Friday (sum: 153)
Values: 67 86
Saturday (sum: 25)
Values: 25
Sunday (sum: 99)
Values: 99
0 values rejected

第6章 编写一个程序
6.1 一个问题
6.2 对问题的思考
6.2.1 程序设计的几个阶段.
6.2.2 策略
6.3 回到计算器问题
6.3.1 第一步尝试
6.3.2 单词
6.3.3 实现单词
6.3.4 使用单词
6.3.5 重新开始
6.4 文法
6.4.1 英文文法
6.4.2 设计一个文法
6.5 将文法转换为程序
6.5.1 实现文法规则
6.5.2 表达式
6.5.3 项
6.5.4 基本表达式
6.6 试验第一个版本
6.7 试验第二个版本
6.8 单词流
6.8.1 实现Token_stream
6.8.2 读单词
6.8.3 读数值
6.9 程序结构
ch06_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

class Token
{
public:
    char kind;
    double value;
    Token(char ch) : kind(ch), value(0) { }
    Token(char ch, double val) : kind(ch), value(val) { }
};

class Token_stream
{
public:
    Token_stream();
    Token get();
    void putback(Token t);
private:
    bool full;
    Token buffer;
};

Token_stream::Token_stream() : full(false), buffer(0) { }

void Token_stream::putback(Token t)
{
    if (full)
    {
        error("putback() into a full buffer");
    }
    buffer = t;
    full = true;
}

Token Token_stream::get()
{
    if (full)
    {
        full = false;
        return buffer;
    }

    char ch;
    cin >> ch;

    switch (ch)
    {
    case ';':
    case 'q':
    case '(':
    case ')':
    case '+':
    case '-':
    case '*':
    case '/':
        return Token(ch);
    case '.':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    {
        cin.putback(ch);
        double val;
        cin >> val;
        return Token('8', val);
    }
    default:
        error("Bad token");
    }
}

Token_stream ts;

double expression();

double primary()
{
    Token t = ts.get();
    switch (t.kind)
    {
    case '(':
    {
        double d = expression();
        t = ts.get();
        if (t.kind != ')')
        {
            error("')' expected");
        }
        return d;
    }
    case '8':
        return t.value;
    default:
        error("primary expected");
    }
}

double term()
{
    double left = primary();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '*':
            left *= primary();
            t = ts.get();
            break;
        case '/':
        {
            double d = primary();
            if (d == 0)
            {
                error("divide by zero");
            }
            left /= d;
            t = ts.get();
            break;
        }
        default:
            ts.putback(t);
            return left;
        }
    }
}

double expression()
{
    double left = term();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '+':
            left += term();
            t = ts.get();
            break;
        case '-':
            left -= term();
            t = ts.get();
            break;
        default:
            ts.putback(t);
            return left;
        }
    }
}

int main()
{
    try
    {
        cout << "Welcome to our simple calculator.\n";
        cout << "Please enter expressions using floating-point numbers.\n";
        cout << "Operators available: +, -, *, /, ().\n";
        cout << "To print the result, enter ';' and to quit, enter 'q'.\n";
        while (cin)
        {
            cout << "> ";
            Token t = ts.get();
            while (t.kind == ';')
            {
                t = ts.get();
            }
            if (t.kind == 'q')
            {
                return 0;
            }
            ts.putback(t);
            cout << "= " << expression() << endl;
        }
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Welcome to our simple calculator.
Please enter expressions using floating-point numbers.
Operators available: +, -, *, /, ().
To print the result, enter ';' and to quit, enter 'q'.
> 2;
= 2
> 2+3*7;
= 23
> 2+3*7+5;
= 28
> 3-(9/2);
= -1.5
> 33.33+22.22*7*2;
= 344.41
> 7-8/2;
= 3
> q

ch06_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

const char number = '8';
const char quit = 'q';
const char print = ';';
const string prompt = "> ";
const string result = "= ";

class Token
{
public:
    char kind;
    double value;
    Token(char ch) : kind(ch), value(0) { }
    Token(char ch, double val) : kind(ch), value(val) { }
};

class Token_stream
{
public:
    Token_stream();
    Token get();
    void putback(Token t);
private:
    bool full;
    Token buffer;
};

Token_stream::Token_stream() : full(false), buffer(0) { }

void Token_stream::putback(Token t)
{
    if (full)
    {
        error("putback() into a full buffer");
    }
    buffer = t;
    full = true;
}

Token Token_stream::get()
{
    if (full)
    {
        full = false;
        return buffer;
    }

    char ch;
    cin >> ch;

    switch (ch)
    {
    case print:
    case quit:
    case '!':
    case '{':
    case '}':
    case '(':
    case ')':
    case '+':
    case '-':
    case '*':
    case '/':
    case '%':
        return Token(ch);
    case '.':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    {
        cin.putback(ch);
        double val;
        cin >> val;
        return Token(number, val);
    }
    default:
        error("Bad token");
    }
}

Token_stream ts;

double expression();

double factorial(double d)
{
    int p = d;
    if (double(p) != d)
    {
        error("factorial not defined for non-integers");
    }
    if (p < 0)
    {
        error("factorial not defined for negative values");
    }
    else if (p > 12)
    {
        error("factorial too large");
    }
    else if (p == 0)
    {
        return 1;
    }
    else
    {
        int res = p;
        for (int i = p - 1; i > 0; --i)
        {
            res *= i;
        }
        return res;
    }
}

double primary()
{
    Token t = ts.get();
    double d = 0;
    switch (t.kind)
    {
    case '(':
        d = expression();
        t = ts.get();
        if (t.kind != ')')
        {
            error("')' expected");
        }
        break;
    case '{':
        d = expression();
        t = ts.get();
        if (t.kind != '}')
        {
            error("'}' expected");
        }
        break;
    case number:
        d = t.value;
        break;
    case '-':
        d = -primary();
        break;
    case '+':
        d = primary();
        break;
    default:
        error("primary expected");
    }

    t = ts.get();
    if (t.kind != '!')
    {
        ts.putback(t);
        return d;
    }
    return factorial(d);
}

double term()
{
    double left = primary();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '*':
            left *= primary();
            t = ts.get();
            break;
        case '/':
        {
            double d = primary();
            if (d == 0)
            {
                error("divide by zero");
            }
            left /= d;
            t = ts.get();
            break;
        }
        case '%':
        {
            double d = primary();
            int i1 = int(left);
            if (i1 != left)
            {
                error("left-hand operand of % not int");
            }
            int i2 = int(d);
            if (i2 != d)
            {
                error("right-hand operand of % not int");
            }
            if (i2 == 0)
            {
                error("%: divide by zero");
            }
            left = i1 % i2;
            t = ts.get();
            break;
        }
        default:
            ts.putback(t);
            return left;
        }
    }
}

double expression()
{
    double left = term();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '+':
            left += term();
            t = ts.get();
            break;
        case '-':
            left -= term();
            t = ts.get();
            break;
        default:
            ts.putback(t);
            return left;
        }
    }
}

void calculate()
{
    while (cin)
    {
        cout << prompt;
        Token t = ts.get();
        while (t.kind == print)
        {
            t = ts.get();
        }
        if (t.kind == quit)
        {
            return;
        }
        ts.putback(t);
        cout << result << expression() << endl;
    }
}

int main()
{
    try
    {
        cout << "Welcome to our simple calculator.\n";
        cout << "Please enter expressions using floating-point numbers.\n";
        cout << "Operators available: +, -, *, /, %, !, (), {}.\n";
        cout << "Enter '" << print << "' to print the result; enter '" << quit << "' to quit.\n";
        calculate();
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Welcome to our simple calculator.
Please enter expressions using floating-point numbers.
Operators available: +, -, *, /, %, !, (), {}.
Enter ';' to print the result; enter 'q' to quit.
> 7+5%3;
= 9
> 7+-2;
= 5
> 7++2;
= 9
> 7*8!;
= 282240
> {(4+5)*6}/(3+4);
= 7.71429
> q

ch06_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

class Name_value
{
public:
    string name;
    int value;
    Name_value(string str, int val) : name(str), value(val) { }
};

void list_score(string s, const vector<Name_value> &vec)
{
    int i = 0;
    while (i < vec.size())
    {
        if (vec[i].name == s)
        {
            cout << '(' << s << ',' << vec[i].value << ")\n";
            return;
        }
        ++i;
    }
    cout << "Name not found\n";
}

void list_names(int n, const vector<Name_value> &vec)
{
    bool exists = false;
    for (int i = 0; i < vec.size(); ++i)
    {
        if (vec[i].value == n)
        {
            cout << '(' << vec[i].name << ',' << n << ")\n";
            exists = true;
        }
    }
    if (!exists)
    {
        cout << "Score not found\n";
    }
}

int main()
{
    try
    {
        cout << "Enter name-and-value pairs such as 'Joe 17':\n";
        string name = "";
        int value = -1;
        vector<Name_value> nv_vec;
        while (cin >> name && cin >> value)
        {
            for (int i = 0; i < nv_vec.size(); ++i)
            {
                if (name == nv_vec[i].name)
                {
                    error("name occurs twice: " + name);
                }
            }
            nv_vec.push_back(Name_value(name, value));
        }

        for (int i = 0; i < nv_vec.size(); ++i)
        {
            cout << "(" << nv_vec[i].name << ',' << nv_vec[i].value << ")\n";
        }

        cin.clear();
        while (cin.get() != '\n')
        {
            continue;
        }
        int sc = 0;
        cout << "Enter name or score ('NoName' to exit):\n";
        while (true)
        {
            if (cin >> sc)
            {
                list_names(sc, nv_vec);
            }
            else
            {
                cin.clear();
                string na;
                cin >> na;
                if (na == "NoName")
                {
                    return 0;
                }
                list_score(na, nv_vec);
            }
            cout << "Enter name or score ('NoName' to exit):\n";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter name-and-value pairs such as 'Joe 17':
Peter 33
Smith 66
Mike 68
Pence 66
Hello 96
World 89
Water 78
end end
(Peter,33)
(Smith,66)
(Mike,68)
(Pence,66)
(Hello,96)
(World,89)
(Water,78)
Enter name or score ('NoName' to exit):
66
(Smith,66)
(Pence,66)
Enter name or score ('NoName' to exit):
96
(Hello,96)
Enter name or score ('NoName' to exit):
Water
(Water,78)
Enter name or score ('NoName' to exit):
Peter
(Peter,33)
Enter name or score ('NoName' to exit):
NoName

ch06_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

class String_stream
{
public:
    String_stream();
    string get();
    void putback(string s);
private:
    bool full;
    string buffer;
};

String_stream::String_stream() : full(false), buffer("") { }

void String_stream::putback(string s)
{
    if (full)
    {
        error("putback() into a full buffer");
    }
    buffer = s;
    full = true;
}

string String_stream::get()
{
    if (full)
    {
        full = false;
        return buffer;
    }

    string s = "";
    cin >> s;
    return s;
}

String_stream sstr;

bool conjunction()
{
    string s = sstr.get();
    if (s == "and" || s == "or" || s == "but")
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool noun()
{
    string s = sstr.get();
    if (s == "birds" || s == "fish" || s == "C++")
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool verb()
{
    string s = sstr.get();
    if (s == "rules" || s == "fly" || s == "swim")
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool subject()
{
    string s = sstr.get();
    if (s == "the")
    {
        return noun();
    }
    else
    {
        sstr.putback(s);
        return noun();
    }
}

bool sentence()
{
    return (subject() && verb());
}

int main()
{
    try
    {
        bool is_ok = false;
        while (true)
        {
            is_ok = sentence();
            if (!is_ok)
            {
                cout << "Not OK\n";
                return 0;
            }
            string s = sstr.get();
            if (s == ".")
            {
                cout << "OK\n";
                return 0;
            }
            else
            {
                sstr.putback(s);
                is_ok = conjunction();
                if (!is_ok)
                {
                    cout << "Not OK\n";
                    return 0;
                }
            }
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
the birds fly but the fish swim .
OK

ch06_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_improved(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

template<class T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int bulls = 0;
int cows = 0;

vector<char> get_new_solution(mt19937 &e)
{
    vector<char> solution(4);
    solution[0] = 'a' + nrand_improved(26, e);
    solution[1] = 'a' + nrand_improved(26, e);
    solution[2] = 'a' + nrand_improved(26, e);
    solution[3] = 'a' + nrand_improved(26, e);
    return solution;
}

void check_guess(const vector<char> &guess, const vector<char> &solution)
{
    bulls = 0;
    cows = 0;
    vector<char> is_bull(4, 'n');
    vector<char> is_cow(4, 'n');
    for (int i = 0; i < solution.size(); ++i)
    {
        if (guess[i] == solution[i])
        {
            ++bulls;
            is_bull[i] = 'y';
        }
    }
    for (int i = 0; i < solution.size(); ++i)
    {
        if (is_bull[i] == 'n')
        {
            for (int j = 0; j < guess.size(); ++j)
            {
                if (is_bull[j] == 'n' && is_cow[j] == 'n')
                {
                    if (solution[i] == guess[j])
                    {
                        ++cows;
                        is_cow[j] = 'y';
                    }
                }
            }
        }
    }

}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);

    try
    {
        char c0 = 0;
        char c1 = 0;
        char c2 = 0;
        char c3 = 0;
        vector<char> guess(4);
        cout << "Guess four character!\n";
        vector<char> solution = get_new_solution(engine);
        print_vector(solution, cout);

        cout << "Enter your guess:\n";
        while (cin >> c0 && cin >> c1 && cin >> c2 && cin >> c3)
        {
            while (cin.get() != '\n') { continue; }
            guess[0] = c0;
            guess[1] = c1;
            guess[2] = c2;
            guess[3] = c3;

            check_guess(guess, solution);
            if (bulls == 4)
            {
                cout << "You have guessed the four character! Setting new solution...\n";
                solution = get_new_solution(engine);
                print_vector(solution, cout);
            }
            if (bulls < 4)
            {
                cout << "Number of bulls: " << bulls << endl;
                cout << "Number of cows: " << cows << endl;
            }
            cout << "Enter your guess:\n";
        }
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Guess four character!
x, x, f, o
Enter your guess:
xvfd
Number of bulls: 2
Number of cows: 0
Enter your guess:
xxfj
Number of bulls: 3
Number of cows: 0
Enter your guess:
xvxo
Number of bulls: 2
Number of cows: 1
Enter your guess:
xxfo
You have guessed the four character! Setting new solution...
z, o, p, q
Enter your guess:
zjqp
Number of bulls: 1
Number of cows: 2
Enter your guess:

ch06_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

vector<string> num_words;

void init()
{
    num_words.push_back("thousand");
    num_words.push_back("hundred");
    num_words.push_back("ten");
    num_words.push_back("one");
}

int char_to_int(vector<int> v)
{
    if (v.size() == 0)
    {
        error("empty vector handed to char_to_int()");
    }
    if (v.size() > 4)
    {
        error("char_to_int can handle only up to four digits");
    }
    int num = 0;
    for (int i = 0; i < v.size(); ++i)
    {
        num = 10 * num + v[i];
    }
    return num;
}

void plural_s(int n)
{
    if (n == 0 || n > 1)
    {
        cout << 's';
    }
    if (n == 1)
    {
        return;
    }
    if (n < 0)
    {
        error("plural_s can handle only non-negative numbers");
    }
}

void print_number(const vector<int> &v, int num)
{
    if (num > 9999 || v.size() > 4)
    {
        error("print_number can only handle numbers with four digits");
    }
    if (v.size() == 0)
    {
        error("print_number was handed an empty vector");
    }
    cout << num << " is ";
    for (int i = 0; i < v.size(); ++i)
    {
        cout << v[i] << ' ' << num_words[i + 4 - v.size()];
        plural_s(v[i]);
        if (i < v.size() - 1)
        {
            cout << " and ";
        }
    }
    cout << endl;
}

int main()
{
    try
    {
        init();

        cout << "Enter number with up to four digits, followed by a ';' and a newline.\n";
        cout << "Enter 'q' to quit.\n";
        while (true)
        {
            vector<int> ch_vec;
            char ch;
            while (cin >> ch)
            {
                if (ch == 'q')
                {
                    return 0;
                }
                if (ch < '0' || ch > '9')
                {
                    while (cin.get() != '\n')
                    {
                        continue;
                    }
                    break;
                }
                ch_vec.push_back(ch - '0');
            }

            int as_int = char_to_int(ch_vec);

            print_number(ch_vec, as_int);

            cout << "Enter number with up to four digits, followed by a ';' and a newline.\n";
            cout << "Enter 'q' to quit.\n";
        }
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter number with up to four digits, followed by a ';' and a newline.
Enter 'q' to quit.
1234;
1234 is 1 thousand and 2 hundreds and 3 tens and 4 ones
Enter number with up to four digits, followed by a ';' and a newline.
Enter 'q' to quit.
123;
123 is 1 hundred and 2 tens and 3 ones
Enter number with up to four digits, followed by a ';' and a newline.
Enter 'q' to quit.
q

ch06_p10.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

double factorial(int n)
{
    if (n < 0)
    {
        error("factorial of a negative number is not defined");
    }
    if (n == 0)
    {
        return 1;
    }
    double prod = 1;
    for (int i = 1; i <= n; ++i)
    {
        prod *= i;
        if (prod > 1.0e+16)
        {
            error("factorial got too large");
        }
    }
    return prod;
}

double permutations(int a, int b)
{
    if (a < b)
    {
        error("for P(a,b), a cannot be smaller than b");
    }
    double prod = 1;
    for (int i = a - b + 1; i <= a; ++i)
    {
        prod *= i;
        if (prod > 1.0e+16)
        {
            error("number too large for permutation function");
        }
    }
    return prod;
}

double combinations(int a, int b)
{
    return permutations(a, b) / factorial(b);
}

int main()
{
    cout << std::fixed << std::noshowpoint << setprecision(0);
    try
    {
        int a = 0;
        int b = 0;
        cout << "Enter two integers to get permutations or combinations from:\n";
        while (cin >> a && cin >> b)
        {
            char ch = 0;
            cout << "(P)ermutations or (c)ombinations or (q)uit?\n";
            while (cin >> ch)
            {
                while (cin.get() != '\n')
                {
                    continue;
                }
                if (ch == 'q')
                {
                    break;
                }
                double res = 0;
                switch (ch)
                {
                case 'p':
                case 'P':
                    res = permutations(a, b);
                    cout << "P(" << a << ',' << b << ") = " << res << endl;
                    break;
                case 'c':
                case 'C':
                    res = combinations(a, b);
                    cout << "C(" << a << ',' << b << ") = " << res << endl;
                    break;
                default:
                    cout << "please enter 'p' or 'c' or 'q'\n";
                    break;
                }
                cout << "(P)ermutations or (c)ombinations or (q)uit?\n";
            }
            cout << "Enter two integers to get permutations or combinations from:\n";
        }
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter two integers to get permutations or combinations from:
52 5
(P)ermutations or (c)ombinations or (q)uit?
p
P(52,5) = 311875200
(P)ermutations or (c)ombinations or (q)uit?
c
C(52,5) = 2598960
(P)ermutations or (c)ombinations or (q)uit?
q
Enter two integers to get permutations or combinations from:

第7章 完成一个程序
7.1 介绍
7.2 输入和输出
7.3 错误处理
7.4 处理负数
7.5 模运算: %
7.6 清理代码
7.6.1 符号常量
7.6.2 使用函数
7.6.3 代码格式
7.6.4 注释
7.7 错误恢复
7.8 变量
7.8.1 变量和定义
7.8.2 引入单词name
7.8.3 预定义名字
7.8.4 我们到达目的地了吗
ch07_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

const char let = 'L';
const char con = 'C';
const char quit = 'q';
const char help = 'h';
const char print = ';';
const char number = '8';
const char name = 'a';
const char square_root = 's';
const char power = 'p';
const string declkey = "let";
const string conkey = "const";
const string sqrtkey = "sqrt";
const string powkey = "pow";
const string quitkey = "quit";
const string helpkey = "help";
const string prompt = "> ";
const string result = "= ";

class Token
{
public:
    char kind;
    double value;
    string name;
    Token(char ch) : kind(ch), value(0) { }
    Token(char ch, double val) : kind(ch), value(val) { }
    Token(char ch, string n) : kind(ch), value(0), name(n) { }
};

class Token_stream
{
public:
    Token_stream();
    Token get();
    void putback(Token t);
    void ignore(char c);
private:
    bool full;
    Token buffer;
};

Token_stream::Token_stream() : full(false), buffer(0) { }

void Token_stream::putback(Token t)
{
    if (full)
    {
        error("putback() into a full buffer");
    }
    buffer = t;
    full = true;
}

Token Token_stream::get()
{
    if (full)
    {
        full = false;
        return buffer;
    }

    char ch;
    cin.get(ch);
    while (isspace(ch))
    {
        if (ch == '\n')
        {
            return Token(print);
        }
        cin.get(ch);
    }

    switch (ch)
    {
    case print:
    case '!':
    case '{':
    case '}':
    case '(':
    case ')':
    case '+':
    case '-':
    case '*':
    case '/':
    case '%':
    case '=':
    case ',':
        return Token(ch);
    case '.':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    {
        cin.putback(ch);
        double val;
        cin >> val;
        return Token(number, val);
    }
    default:
        if (isalpha(ch))
        {
            string s;
            s += ch;
            while (cin.get(ch) && (isalpha(ch) || isdigit(ch) || ch == '_'))
            {
                s += ch;
            }
            cin.putback(ch);
            if (s == declkey)
            {
                return Token(let);
            }
            if (s == conkey)
            {
                return Token(con);
            }
            if (s == sqrtkey)
            {
                return Token(square_root);
            }
            if (s == powkey)
            {
                return Token(power);
            }
            if (s == helpkey)
            {
                return Token(help);
            }
            if (s == quitkey)
            {
                return Token(quit);
            }
            return Token(name, s);
        }
        error("Bad token");
    }
}

void Token_stream::ignore(char c)
{
    if (full && c == buffer.kind)
    {
        full = false;
        return;
    }
    full = false;

    char ch = 0;
    while (cin >> ch)
    {
        if (ch == c)
        {
            return;
        }
    }
}

class Variable
{
public:
    string name;
    double value;
    bool is_const;
    Variable(string n, double v, bool b) : name(n), value(v), is_const(b) { }
};

class Symbol_table
{
public:
    double get(string s);
    void set(string s, double d);
    bool is_declared(string var);
    double declare(string var, double val, bool b);
private:
    vector<Variable> var_table;
};

double Symbol_table::get(string s)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            return var_table[i].value;
        }
    }
    error("get: undefined variable " + s);
}

void Symbol_table::set(string s, double d)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            if (var_table[i].is_const)
            {
                error(s + " is a constant");
            }
            var_table[i].value = d;
            return;
        }
    }
    error("set: undefined variable " + s);
}

bool Symbol_table::is_declared(string var)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == var)
        {
            return true;
        }
    }
    return false;
}

double Symbol_table::declare(string var, double val, bool b)
{
    if (is_declared(var))
    {
        error(var + " declared twice");
    }
    var_table.push_back(Variable(var, val, b));
    return val;
}

Token_stream ts;
Symbol_table st;
double expression();

double factorial(double d)
{
    int p = d;
    if (double(p) != d)
    {
        error("factorial not defined for non-integers");
    }
    if (p < 0)
    {
        error("factorial not defined for negative values");
    }
    else if (p == 0)
    {
        return 1;
    }
    else
    {
        double res = p;
        for (int i = p - 1; i > 0; --i)
        {
            res *= i;
            if (res > 1.0e+16)
            {
                error("factorial too large");
            }
        }
        return res;
    }
}

double my_pow(double base, int expo)
{
    if (expo < 0)
    {
        error("my_pow not defined for negative expo");
    }
    if (expo == 0)
    {
        if (base == 0)
        {
            return 0;
        }
        return 1;
    }
    double res = base;
    for (int i = 2; i <= expo; ++i)
    {
        res *= base;
    }
    return res;
}

double primary()
{
    Token t = ts.get();
    double d = 0;
    switch (t.kind)
    {
    case '(':
        d = expression();
        t = ts.get();
        if (t.kind != ')')
        {
            error("')' expected");
        }
        break;
    case '{':
        d = expression();
        t = ts.get();
        if (t.kind != '}')
        {
            error("'}' expected");
        }
        break;
    case number:
        d = t.value;
        break;
    case '-':
        d = -primary();
        break;
    case '+':
        d = primary();
        break;
    case name:
    {
        Token t2 = ts.get();
        if (t2.kind == '=')
        {
            d = expression();
            st.set(t.name, d);
        }
        else
        {
            ts.putback(t2);
            d = st.get(t.name);
        }
    }
    break;
    case square_root:
    {
        Token t2 = ts.get();
        if (t2.kind != '(')
        {
            error("'(' expected");
        }
        double d2 = expression();
        if (d2 < 0)
        {
            error("Square roots of negative numbers... nope!");
        }
        t2 = ts.get();
        if (t2.kind != ')')
        {
            error("')' expected");
        }
        d = sqrt(d2);
    }
    break;
    case power:
    {
        Token t2 = ts.get();
        if (t2.kind != '(')
        {
            error("'(' expected");
        }
        double d2 = expression();
        t2 = ts.get();
        if (t2.kind != ',')
        {
            error("',' expected");
        }
        t2 = ts.get();
        if (t2.kind != number)
        {
            error("second argument of 'pow' is not a number");
        }
        int i2 = int(t2.value);
        if (i2 != t2.value)
        {
            error("second argument of 'pow' is not an integer");
        }
        t2 = ts.get();
        if (t2.kind != ')')
        {
            error("')' expected");
        }
        d = my_pow(d2, i2);
    }
    break;
    default:
        error("primary expected");
    }

    t = ts.get();
    if (t.kind != '!')
    {
        ts.putback(t);
        return d;
    }
    return factorial(d);
}

double term()
{
    double left = primary();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '*':
            left *= primary();
            t = ts.get();
            break;
        case '/':
        {
            double d = primary();
            if (d == 0)
            {
                error("divide by zero");
            }
            left /= d;
            t = ts.get();
            break;
        }
        case '%':
        {
            double d = primary();
            int i1 = int(left);
            if (i1 != left)
            {
                error("left-hand operand of % not int");
            }
            int i2 = int(d);
            if (i2 != d)
            {
                error("right-hand operand of % not int");
            }
            if (i2 == 0)
            {
                error("%: divide by zero");
            }
            left = i1 % i2;
            t = ts.get();
            break;
        }
        default:
            ts.putback(t);
            return left;
        }
    }
}

double expression()
{
    double left = term();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '+':
            left += term();
            t = ts.get();
            break;
        case '-':
            left -= term();
            t = ts.get();
            break;
        case '=':
            error("use of '=' outside of a declaration");
        default:
            ts.putback(t);
            return left;
        }
    }
}

double declaration(bool b)
{
    Token t = ts.get();
    if (t.kind != name)
    {
        error ("name expected in declaration");
    }
    string var_name = t.name;

    Token t2 = ts.get();
    if (t2.kind != '=')
    {
        error("= missing in declaration of " + var_name);
    }

    double d = expression();
    st.declare(var_name, d, b);
    return d;
}

double statement()
{
    Token t = ts.get();
    switch(t.kind)
    {
    case let:
        return declaration(false);
    case con:
        return declaration(true);
    default:
        ts.putback(t);
        return expression();
    }
}

void clean_up_mess()
{
    ts.ignore(print);
}

void print_help()
{
    cout << "Instructions: enter expressions, there are\n";
    cout << "a few functions, you can declare variables using\n";
    cout << "the 'let' keyword and constants with the 'const'\n";
    cout << "keyword.\n";
}

void calculate()
{
    while (cin)
    {
        try
        {
            cout << prompt;
            Token t = ts.get();
            while (t.kind == print)
            {
                t = ts.get();
            }
            if (t.kind == help)
            {
                print_help();
            }
            else if (t.kind == quit)
            {
                return;
            }
            else
            {
                ts.putback(t);
                cout << result << statement() << endl;
            }
        }
        catch(exception &e)
        {
            cerr << e.what() << endl;
            clean_up_mess();
        }
    }
}

int main()
{
    try
    {
        cout << "Welcome to our simple calculator.\n";
        cout << "Enter '" << helpkey << "' to get the help info; enter '" << quitkey << "' to quit.\n";
        st.declare("pi", 3.1415926535, true);
        st.declare("e", 2.7182818284, true);
        st.declare("k", 1000, true);

        calculate();
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Welcome to our simple calculator.
Enter 'help' to get the help info; enter 'quit' to quit.
> help
Instructions: enter expressions, there are
a few functions, you can declare variables using
the 'let' keyword and constants with the 'const'
keyword.
> sqrt(2+6.7)
= 2.94958
> pow(2.5,3)
= 15.625
> let x = 3.4
= 3.4
> let y = 2
= 2
> let z = (x+y*2)/pi
= 2.35549
> 2+3*z
= 9.06648
> quit

Welcome to our simple calculator.
Enter 'help' to get the help info; enter 'quit' to quit.
> 7*8!
= 282240
> let x = 5
= 5
> {(x+3)*2+5}
= 21
> x = x + 3
= 8
> x + 3
= 11
> x
= 8
> x + 7*8!
= 282248
> quit

第8章 函数相关的技术细节
8.1 技术细节
8.2 声明和定义
8.2.1 声明的类别
8.2.2 变量和常量声明
8.2.3 默认初始化
8.3 头文件
8.4 作用城
8.5 函数调用和返回
8.5.1 声明参数和返回类型
8.5.2 返回一个值
8.5.3 传值参数
8.5.4 传常量引用参数
8.5.5 传引用参数
8.5.6 传值与传引用的对比
8.5.7 参数检查和转换
8.5.8 实现函数调用
8.6 求值顺序
8.6.1 表达式求值
8.6.2 全局初始化
8.7 名字空间
8.7.1 using声明和using指令
ch08_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

namespace X
{
    int var;
    void print()
    {
        cout << var << endl;
    }
}

namespace Y
{
    int var;
    void print()
    {
        cout << var << endl;
    }
}

namespace Z
{
    int var;
    void print()
    {
        cout << var << endl;
    }
}

int main()
{
    X::var = 7;
    X::print();
    using namespace Y;
    var = 9;
    print();
    {
        using Z::var;
        using Z::print;
        var = 11;
        print();
    }
    print();
    X::print();
}
显示结果如下
7
9
11
9
7

ch08_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

const char let = 'L';
const char con = 'C';
const char quit = 'q';
const char help = 'h';
const char print = ';';
const char number = '8';
const char name = 'a';
const char square_root = 's';
const char power = 'p';
const string declkey = "let";
const string conkey = "const";
const string sqrtkey = "sqrt";
const string powkey = "pow";
const string quitkey = "quit";
const string helpkey = "help";
const string prompt = "> ";
const string result = "= ";

class Token
{
public:
    char kind;
    double value;
    string name;
    Token(char ch) : kind(ch), value(0) { }
    Token(char ch, double val) : kind(ch), value(val) { }
    Token(char ch, string n) : kind(ch), value(0), name(n) { }
};

class Token_stream
{
public:
    Token_stream();
    Token_stream(istream &is);
    Token get();
    void putback(Token t);
    void ignore(char c);
    istream & get_istream();
private:
    bool full;
    Token buffer;
    istream *is_ptr;
};

Token_stream::Token_stream() : full(false), buffer(0), is_ptr(&cin) { }
Token_stream::Token_stream(istream &is) : full(false), buffer(0), is_ptr(&is) { }
istream &  Token_stream::get_istream()
{
    return (*is_ptr);
}

void Token_stream::putback(Token t)
{
    if (full)
    {
        error("putback() into a full buffer");
    }
    buffer = t;
    full = true;
}

Token Token_stream::get()
{
    if (full)
    {
        full = false;
        return buffer;
    }

    char ch;
    (*is_ptr).get(ch);
    while (isspace(ch))
    {
        if (ch == '\n')
        {
            return Token(print);
        }
        (*is_ptr).get(ch);
    }

    switch (ch)
    {
    case print:
    case '!':
    case '{':
    case '}':
    case '(':
    case ')':
    case '+':
    case '-':
    case '*':
    case '/':
    case '%':
    case '=':
    case ',':
        return Token(ch);
    case '.':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    {
        (*is_ptr).putback(ch);
        double val;
        (*is_ptr) >> val;
        return Token(number, val);
    }
    default:
        if (isalpha(ch))
        {
            string s;
            s += ch;
            while ((*is_ptr).get(ch) && (isalpha(ch) || isdigit(ch) || ch == '_'))
            {
                s += ch;
            }
            (*is_ptr).putback(ch);
            if (s == declkey)
            {
                return Token(let);
            }
            if (s == conkey)
            {
                return Token(con);
            }
            if (s == sqrtkey)
            {
                return Token(square_root);
            }
            if (s == powkey)
            {
                return Token(power);
            }
            if (s == helpkey)
            {
                return Token(help);
            }
            if (s == quitkey)
            {
                return Token(quit);
            }
            return Token(name, s);
        }
        error("Bad token");
    }
}

void Token_stream::ignore(char c)
{
    if (full && c == buffer.kind)
    {
        full = false;
        return;
    }
    full = false;

    char ch = 0;
    while ((*is_ptr) >> ch)
    {
        if (ch == c)
        {
            return;
        }
    }
}

class Variable
{
public:
    string name;
    double value;
    bool is_const;
    Variable(string n, double v, bool b) : name(n), value(v), is_const(b) { }
};

class Symbol_table
{
public:
    double get(string s);
    void set(string s, double d);
    bool is_declared(string var);
    double declare(string var, double val, bool b);
private:
    vector<Variable> var_table;
};

double Symbol_table::get(string s)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            return var_table[i].value;
        }
    }
    error("get: undefined variable " + s);
}

void Symbol_table::set(string s, double d)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            if (var_table[i].is_const)
            {
                error(s + " is a constant");
            }
            var_table[i].value = d;
            return;
        }
    }
    error("set: undefined variable " + s);
}

bool Symbol_table::is_declared(string var)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == var)
        {
            return true;
        }
    }
    return false;
}

double Symbol_table::declare(string var, double val, bool b)
{
    if (is_declared(var))
    {
        error(var + " declared twice");
    }
    var_table.push_back(Variable(var, val, b));
    return val;
}

Token_stream ts;
Symbol_table st;
double expression();

double factorial(double d)
{
    int p = d;
    if (double(p) != d)
    {
        error("factorial not defined for non-integers");
    }
    if (p < 0)
    {
        error("factorial not defined for negative values");
    }
    else if (p == 0)
    {
        return 1;
    }
    else
    {
        double res = p;
        for (int i = p - 1; i > 0; --i)
        {
            res *= i;
            if (res > 1.0e+16)
            {
                error("factorial too large");
            }
        }
        return res;
    }
}

double my_pow(double base, int expo)
{
    if (expo < 0)
    {
        error("my_pow not defined for negative expo");
    }
    if (expo == 0)
    {
        if (base == 0)
        {
            return 0;
        }
        return 1;
    }
    double res = base;
    for (int i = 2; i <= expo; ++i)
    {
        res *= base;
    }
    return res;
}

double primary()
{
    Token t = ts.get();
    double d = 0;
    switch (t.kind)
    {
    case '(':
        d = expression();
        t = ts.get();
        if (t.kind != ')')
        {
            error("')' expected");
        }
        break;
    case '{':
        d = expression();
        t = ts.get();
        if (t.kind != '}')
        {
            error("'}' expected");
        }
        break;
    case number:
        d = t.value;
        break;
    case '-':
        d = -primary();
        break;
    case '+':
        d = primary();
        break;
    case name:
    {
        Token t2 = ts.get();
        if (t2.kind == '=')
        {
            d = expression();
            st.set(t.name, d);
        }
        else
        {
            ts.putback(t2);
            d = st.get(t.name);
        }
    }
    break;
    case square_root:
    {
        Token t2 = ts.get();
        if (t2.kind != '(')
        {
            error("'(' expected");
        }
        double d2 = expression();
        if (d2 < 0)
        {
            error("Square roots of negative numbers... nope!");
        }
        t2 = ts.get();
        if (t2.kind != ')')
        {
            error("')' expected");
        }
        d = sqrt(d2);
    }
    break;
    case power:
    {
        Token t2 = ts.get();
        if (t2.kind != '(')
        {
            error("'(' expected");
        }
        double d2 = expression();
        t2 = ts.get();
        if (t2.kind != ',')
        {
            error("',' expected");
        }
        t2 = ts.get();
        if (t2.kind != number)
        {
            error("second argument of 'pow' is not a number");
        }
        int i2 = int(t2.value);
        if (i2 != t2.value)
        {
            error("second argument of 'pow' is not an integer");
        }
        t2 = ts.get();
        if (t2.kind != ')')
        {
            error("')' expected");
        }
        d = my_pow(d2, i2);
    }
    break;
    default:
        error("primary expected");
    }

    t = ts.get();
    if (t.kind != '!')
    {
        ts.putback(t);
        return d;
    }
    return factorial(d);
}

double term()
{
    double left = primary();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '*':
            left *= primary();
            t = ts.get();
            break;
        case '/':
        {
            double d = primary();
            if (d == 0)
            {
                error("divide by zero");
            }
            left /= d;
            t = ts.get();
            break;
        }
        case '%':
        {
            double d = primary();
            int i1 = int(left);
            if (i1 != left)
            {
                error("left-hand operand of % not int");
            }
            int i2 = int(d);
            if (i2 != d)
            {
                error("right-hand operand of % not int");
            }
            if (i2 == 0)
            {
                error("%: divide by zero");
            }
            left = i1 % i2;
            t = ts.get();
            break;
        }
        default:
            ts.putback(t);
            return left;
        }
    }
}

double expression()
{
    double left = term();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '+':
            left += term();
            t = ts.get();
            break;
        case '-':
            left -= term();
            t = ts.get();
            break;
        case '=':
            error("use of '=' outside of a declaration");
        default:
            ts.putback(t);
            return left;
        }
    }
}

double declaration(bool b)
{
    Token t = ts.get();
    if (t.kind != name)
    {
        error ("name expected in declaration");
    }
    string var_name = t.name;

    Token t2 = ts.get();
    if (t2.kind != '=')
    {
        error("= missing in declaration of " + var_name);
    }

    double d = expression();
    st.declare(var_name, d, b);
    return d;
}

double statement()
{
    Token t = ts.get();
    switch(t.kind)
    {
    case let:
        return declaration(false);
    case con:
        return declaration(true);
    default:
        ts.putback(t);
        return expression();
    }
}

void clean_up_mess()
{
    ts.ignore(print);
}

void print_help()
{
    cout << "Instructions: enter expressions, there are\n";
    cout << "a few functions, you can declare variables using\n";
    cout << "the 'let' keyword and constants with the 'const'\n";
    cout << "keyword.\n";
}

void calculate()
{
    while (ts.get_istream())
    {
        try
        {
            cout << prompt;
            Token t = ts.get();
            while (t.kind == print)
            {
                t = ts.get();
            }
            if (t.kind == help)
            {
                print_help();
            }
            else if (t.kind == quit)
            {
                return;
            }
            else
            {
                ts.putback(t);
                cout << result << statement() << endl;
            }
        }
        catch(exception &e)
        {
            cerr << e.what() << endl;
            clean_up_mess();
        }
    }
}

int main()
{
    try
    {
        cout << "Welcome to our simple calculator.\n";
        cout << "Enter '" << helpkey << "' to get the help info; enter '" << quitkey << "' to quit.\n";
        st.declare("pi", 3.1415926535, true);
        st.declare("e", 2.7182818284, true);
        st.declare("k", 1000, true);

        calculate();
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Welcome to our simple calculator.
Enter 'help' to get the help info; enter 'quit' to quit.
> 7*8!
= 282240
> pi*pow(5,2)
= 78.5398
> quit

ch08_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

void print(const string &label, const vector<int> &v)
{
    cout << label << " (" << v.size() << "): {\n";
    int i;
    for (i = 0; i < v.size(); ++i)
    {
        cout << v[i];
        if (i < v.size() - 1)
        {
            cout << ", ";
        }
        if (i % 8 == 7)
        {
            cout << endl;
        }
    }
    if (i % 8 != 0)
    {
        cout << endl;
    }
    cout << "}\n";
}

void fibonacci(int x, int y, vector<int> &v, int n)
{
    if (n < 1)
    {
        error("there must be at least one number in the series");
    }
    v.push_back(x);
    if (n == 1) return;
    v.push_back(y);
    if (n == 2) return;
    for (int i = 2; i < n; ++i)
    {
        v.push_back(v[i - 2] + v[i - 1]);
    }
}

int main()
{
    try
    {
        int x = 0;
        int y = 0;
        vector<int> v;
        int n = 0;

        cout << "Enter first number in Fibonacci sequence: ";
        cin >> x;
        cout << "Enter second number in Fibonacci sequence: ";
        cin >> y;
        cout << "Enter number of elements in sequence: ";
        cin >> n;

        fibonacci(x, y, v, n);

        string s = "Your Fibonacci sequence";
        print(s, v);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter first number in Fibonacci sequence: 1
Enter second number in Fibonacci sequence: 1
Enter number of elements in sequence: 30
Your Fibonacci sequence (30): {
1, 1, 2, 3, 5, 8, 13, 21,
34, 55, 89, 144, 233, 377, 610, 987,
1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368,
75025, 121393, 196418, 317811, 514229, 832040
}

ch08_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

void print(const string &label, const vector<int> &v)
{
    cout << label << " (" << v.size() << "): {\n";
    int i;
    for (i = 0; i < v.size(); ++i)
    {
        cout << v[i];
        if (i < v.size() - 1)
        {
            cout << ", ";
        }
        if (i % 8 == 7)
        {
            cout << endl;
        }
    }
    if (i % 8 != 0)
    {
        cout << endl;
    }
    cout << "}\n";
}

vector<int> reverse1(const vector<int> &v)
{
    vector<int> v_rev(v.size());
    for (int i = 0; i < v.size(); ++i)
    {
        v_rev[i] = v[v.size() - 1 - i];
    }
    return v_rev;
}

void reverse2(vector<int> &v)
{
    for (int i = 0; i < v.size() / 2; ++i)
    {
        swap(v[i], v[v.size() - 1 - i]);
    }
}

int main()
{
    try
    {
        vector<int> v1;
        vector<int> v2;
        v1.push_back(1);
        v1.push_back(3);
        v1.push_back(5);
        v1.push_back(7);
        v1.push_back(9);
        v2.push_back(2);
        v2.push_back(4);
        v2.push_back(6);
        v2.push_back(8);
        print("v1_pre", v1);
        vector<int> v1_rev = reverse1(v1);
        print("v1_post_val", v1);
        print("v1_rev", v1_rev);
        reverse2(v1);
        print("v1_post_ref", v1);
        print("v2_pre", v2);
        vector<int> v2_rev = reverse1(v2);
        print("v2_post_val", v2);
        print("v2_rev", v2_rev);
        reverse2(v2);
        print("v2_post_ref", v2);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
v1_pre (5): {
1, 3, 5, 7, 9
}
v1_post_val (5): {
1, 3, 5, 7, 9
}
v1_rev (5): {
9, 7, 5, 3, 1
}
v1_post_ref (5): {
9, 7, 5, 3, 1
}
v2_pre (4): {
2, 4, 6, 8
}
v2_post_val (4): {
2, 4, 6, 8
}
v2_rev (4): {
8, 6, 4, 2
}
v2_post_ref (4): {
8, 6, 4, 2
}

ch08_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

void print(const string &label, const vector<string> &v)
{
    cout << label << " (" << v.size() << "): {\n";
    int i;
    for (i = 0; i < v.size(); ++i)
    {
        cout << setw(11) << v[i];
        if (i < v.size() - 1)
        {
            cout << " ";
        }
        if (i % 3 == 2)
        {
            cout << endl;
        }
    }
    if (i % 3 != 0)
    {
        cout << endl;
    }
    cout << "}\n";
}

vector<string> reverse1(const vector<string> &v)
{
    vector<string> v_rev(v.size());
    for (int i = 0; i < v.size(); ++i)
    {
        v_rev[i] = v[v.size() - 1 - i];
    }
    return v_rev;
}

void reverse2(vector<string> &v)
{
    for (int i = 0; i < v.size() / 2; ++i)
    {
        swap(v[i], v[v.size() - 1 - i]);
    }
}


int main()
{
    try
    {
        vector<string> v1;
        vector<string> v2;
        v1.push_back("one");
        v1.push_back("three");
        v1.push_back("five");
        v1.push_back("seven");
        v1.push_back("nine");
        v2.push_back("two");
        v2.push_back("four");
        v2.push_back("six");
        v2.push_back("eight");
        print("v1_pre", v1);
        vector<string> v1_rev = reverse1(v1);
        print("v1_post_val", v1);
        print("v1_rev", v1_rev);
        reverse2(v1);
        print("v1_post_ref", v1);
        print("v2_pre", v2);
        vector<string> v2_rev = reverse1(v2);
        print("v2_post_val", v2);
        print("v2_rev", v2_rev);
        reverse2(v2);
        print("v2_post_ref", v2);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
v1_pre (5): {
        one       three        five
      seven        nine
}
v1_post_val (5): {
        one       three        five
      seven        nine
}
v1_rev (5): {
       nine       seven        five
      three         one
}
v1_post_ref (5): {
       nine       seven        five
      three         one
}
v2_pre (4): {
        two        four         six
      eight
}
v2_post_val (4): {
        two        four         six
      eight
}
v2_rev (4): {
      eight         six        four
        two
}
v2_post_ref (4): {
      eight         six        four
        two
}

ch08_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

vector<string> name;
vector<double> age;

void enter_values()
{
    string s;
    cout << "Enter list of names, 'done' when done:\n";
    while (cin >> s && s != "done")
    {
        for (int i = 0; i < name.size(); ++i)
        {
            if (s == name[i]) { error("Duplicate name " + s); }
        }
        name.push_back(s);
    }

    for (int i = 0; i < name.size(); ++i)
    {
        cout << "Age of " << name[i] << ": ";
        double a;
        cin >> a;
        age.push_back(a);
    }
}

void print(const vector<string> &name, const vector<double> &age)
{
    if (name.size() != age.size()) { error("print: vectors must be same size"); }
    for (int i = 0; i < name.size(); ++i)
    {
        cout << '(' << name[i] << ',' << age[i] << ")\n";
    }
}

int find_index(const vector<string> &vec, const string &s)
{
    for (int i = 0; i < vec.size(); ++i)
    {
        if (vec[i] == s)
        {
            return i;
        }
    }
    error("name not found");
}

int main()
{
    try
    {
        enter_values();
        cout << "Entered like this:\n";
        print(name, age);

        vector<string> name_orig = name;
        vector<double> age_orig = age;
        sort(name.begin(), name.end());
        for (int i = 0; i < name.size(); ++i)
        {
            age[i] = age_orig[find_index(name_orig, name[i])];
        }

        cout << "\nAfter sorting:\n";
        print(name, age);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter list of names, 'done' when done:
Peter Smith Donald Mike Pence done
Age of Peter: 23
Age of Smith: 35
Age of Donald: 72
Age of Mike: 61
Age of Pence: 56
Entered like this:
(Peter,23)
(Smith,35)
(Donald,72)
(Mike,61)
(Pence,56)

After sorting:
(Donald,72)
(Mike,61)
(Pence,56)
(Peter,23)
(Smith,35)

ch08_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

template<class T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);
    try
    {
        for (int i = 0; i < 10; i++)
        {
            cout << nrand_one(100, engine) << endl;
        }
        cout << endl;
        for (int i = 0; i < 10; i++)
        {
            cout << nrand_two(100, 1000, engine) << endl;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
72
44
1
19
7
15
11
74
1
98

633
518
196
267
541
566
516
650
171
700

ch08_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
T maxv(const vector<T> &v)
{
    if (v.size() == 0)
    {
        error("maxv: argument vector is empty");
    }
    T v_max = v[0];
    if (v.size() == 1)
    {
        return v_max;
    }
    for (int i = 1; i < v.size(); ++i)
    {
        if (v[i] > v_max)
        {
            v_max = v[i];
        }
    }
    return v_max;
}

template<typename T>
T minv(const vector<T> &v)
{
    if (v.size() == 0)
    {
        error("minv: argument vector is empty");
    }
    T v_min = v[0];
    if (v.size() == 1)
    {
        return v_min;
    }
    for (int i = 1; i < v.size(); ++i)
    {
        if (v[i] < v_min)
        {
            v_min = v[i];
        }
    }
    return v_min;
}

template<typename T>
double meanv(const vector<T> &v)
{
    if (v.size() == 0)
    {
        error("meanv: argument vector is empty");
    }
    T v_sum = 0;
    for (int i = 0; i < v.size(); ++i)
    {
        v_sum += v[i];
    }
    return double(v_sum) / v.size();
}

template<typename T>
double medianv(vector<T> v)
{
    if (v.size() == 0)
    {
        error("medianv: argument vector is empty");
    }
    sort(v.begin(), v.end());
    auto size = v.size();
    auto mid = size / 2;
    return size % 2 == 0 ? double(v[mid] + v[mid - 1]) / 2 : v[mid];
}

template <typename T>
class Vector_properties
{
public:
    Vector_properties() : smallest(0), largest(0), mean(0), median(0) { }
    T smallest;
    T largest;
    double mean;
    double median;
};

template <typename T>
Vector_properties<T> get_props(const vector<T> &v)
{
    Vector_properties<T> vec_props;
    vec_props.largest = maxv<T>(v);
    vec_props.smallest = minv<T>(v);
    vec_props.mean = meanv<T>(v);
    vec_props.median = medianv<T>(v);
    return vec_props;
}

int main()
{
    try
    {
        vector<int> v;
        v.push_back(1);
        v.push_back(3);
        v.push_back(5);
        v.push_back(7);
        v.push_back(9);
        v.push_back(8);
        v.push_back(6);
        v.push_back(4);
        v.push_back(2);
        v.push_back(99);
        Vector_properties<int> vec_props = get_props<int>(v);

        cout << "Vector:\n";
        print_vector(v, cout);
        cout << endl;

        cout << "max: " << vec_props.largest << endl;
        cout << "min: " << vec_props.smallest << endl;
        cout << "mean: " << vec_props.mean << endl;
        cout << "median: " << vec_props.median << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Vector:
1, 3, 5, 7, 9, 8, 6, 4, 2, 99

max: 99
min: 1
mean: 14.4
median: 5.5

ch08_p13.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

void print_until_s(const vector<string> &v, const string &quit)
{
    for (int i = 0; i < v.size(); ++i)
    {
        if (v[i] == quit)
        {
            return;
        }
        cout << v[i] << endl;
    }
}

void print_until_ss(const vector<string> &v, const string &quit)
{
    int counter = 0;
    for (int i = 0; i < v.size(); ++i)
    {
        if (v[i] == quit)
        {
            if (counter == 1)
            {
                return;
            }
            else
            {
                ++counter;
            }
        }
        cout << v[i] << endl;
    }
}

int main()
{
    try
    {
        vector<string> v;
        v.push_back("one");
        v.push_back("word");
        v.push_back("and");
        v.push_back("then");
        v.push_back("another");
        v.push_back("word");
        cout << "print_until_s:\n";
        print_until_s(v, "word");
        cout << "print_until_ss:\n";
        print_until_ss(v, "word");
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
print_until_s:
one
print_until_ss:
one
word
and
then
another


ch08_p14.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

vector<int> string_lengths(const vector<string> &v)
{
    if (v.size() == 0)
    {
        error("string_lengths: argument is empty vector");
    }
    vector<int> lengths;
    for (int i = 0; i < v.size(); ++i)
    {
        lengths.push_back(v[i].size());
    }
    return lengths;
}

string longest_string(const vector<string> &v)
{
    if (v.size() == 0)
    {
        error("longest_string: argument is empty vector");
    }
    string ls;
    int maxl = 0;
    for (int i = 0; i < v.size(); ++i)
    {
        if (v[i].size() > maxl)
        {
            maxl = v[i].size();
            ls = v[i];
        }
    }
    return ls;
}

string shortest_string(const vector<string> &v)
{
    if (v.size() == 0)
    {
        error("shortest_string: argument is empty vector");
    }
    string ss = v[0];
    int minl = v[0].size();
    for (int i = 1; i < v.size(); ++i)
    {
        if (v[i].size() < minl)
        {
            minl = v[i].size();
            ss = v[i];
        }
    }
    return ss;
}

string alpha_first_string(const vector<string> &v)
{
    if (v.size() == 0)
    {
        error("alpha_first_string: argument is empty vector");
    }
    vector<string> v_cp = v;
    sort(v_cp.begin(), v_cp.end());
    return v_cp[0];
}

string alpha_last_string(const vector<string> &v)
{
    if (v.size() == 0)
    {
        error("alpha_last_string: argument is empty vector");
    }
    vector<string> v_cp = v;
    sort(v_cp.begin(), v_cp.end());
    return v_cp[v_cp.size() - 1];
}

int main()
{
    try
    {
        vector<string> string_v;
        string_v.push_back("first");
        string_v.push_back("second");
        string_v.push_back("third");
        string_v.push_back("fourth");
        string_v.push_back("fifth");
        string_v.push_back("sixth");
        string_v.push_back("seventh");
        cout << "Vector of strings:\n";
        print_vector(string_v, cout);
        vector<int> lengths = string_lengths(string_v);
        cout << "Vector of lengths:\n";
        print_vector(lengths, cout);
        cout << "Longest string: " << longest_string(string_v) << endl;
        cout << "Shortest string: " << shortest_string(string_v) << endl;
        cout << "Lexicographically first string: " << alpha_first_string(string_v) << endl;
        cout << "Lexicographically last string: " << alpha_last_string(string_v) << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Vector of strings:
first, second, third, fourth, fifth, sixth, seventh
Vector of lengths:
5, 6, 5, 6, 5, 5, 7
Longest string: seventh
Shortest string: first
Lexicographically first string: fifth
Lexicographically last string: third

ch08_p15.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

void f(const int n)
{
    cout << n << endl;
}

int main()
{
    try
    {
        int n = 10;
        f(n);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
10


第9章 类相关的技术细节
9.1 用户自定义类型
9.2 类和成员
9.3 接口和实现
9.4 演化一个类
9.4.1 结构和函数
9.4.2 成员函数和构造函数
9.4.3 保持细节私有性
9.4.4 定义成员函数
9.4.5 引用当前对象
9.4.6 报告错误
9.5 枚举类型
9.6 运算符重载
9.7 类接口
9.7.1 参数类型
9.7.2 拷贝
9.7.3 默认构造函数
9.7.4 const成员函数
9.7.5 类成员和"辅助函数"
9.8 Date类
ch09_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

namespace Chrono
{
    class Date
    {
    public:
        enum Month
        {
            jan = 1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
        };

        Date(int y, Month m, int d);
        Date();

        int day() const
        {
            return d;
        }
        Month month() const
        {
            return m;
        }
        int year() const
        {
            return y;
        }

        void add_day(int n);
        void add_month(int n);
        void add_year(int n);
    private:
        int y;
        Month m;
        int d;
    };

    bool is_date(int y, Date::Month m, int d);
    bool leapyear(int y);

    int day_in_year(const Date &d);
    void split_date(int day_of_year, int year, int *month, int *day);
    int n_leapyears(int y);
    long int days_linear(const Date &d);

    enum Day
    {
        sunday, monday, tuesday, wednesday, thursday, friday, saturday
    };
    Day day_of_week(const Date &d);
    ostream &operator<<(ostream &os, Day d);

    bool operator==(const Date &a, const Date &b);
    bool operator!=(const Date &a, const Date &b);

    ostream &operator<<(ostream &os, const Date &d);
    istream &operator>>(istream &is, Date &dd);
}

namespace Chrono
{
    Date::Date(int yy, Month mm, int dd) : y(yy), m(mm), d(dd)
    {
        if (!is_date(yy, mm, dd))
        {
            error("invalid date");
        }
    }

    const Date &default_date()
    {
        static const Date dd(2001, Date::jan, 1);
        return dd;
    }

    Date::Date() : y(default_date().year()), m(default_date().month()), d(default_date().day()) { }

    void Date::add_day(int n)
    {
        int day_of_year = day_in_year(*this);
        day_of_year += n;
        if (day_of_year >= 1 && day_of_year <= 366)
        {
            int res_month, res_day;
            split_date(day_of_year, y, &res_month, &res_day);
            m = Month(res_month);
            d = res_day;
        }
    }

    void Date::add_month(int n)
    {
        int month = m + n;
        if (leapyear(y))
        {
            if (d <= 29 && (month >= jan && month <= dec))
            {
                m = Month(month);
            }
        }
        else
        {
            if (d <= 28 && (month >= jan && month <= dec))
            {
                m = Month(month);
            }
        }
    }

    void Date::add_year(int n)
    {
        if (m == feb && d == 29 && !leapyear(y + n))
        {
            m = mar;
            d = 1;
        }
        y += n;
    }

    bool is_date(int y, Date::Month m, int d)
    {
        if (d <= 0)
        {
            return false;
        }

        int days_in_month = 31;

        switch (m)
        {
        case Date::feb:
            days_in_month = (leapyear(y)) ? 29 : 28;
            break;
        case Date::apr:
        case Date::jun:
        case Date::sep:
        case Date::nov:
            days_in_month = 30;
            break;
        }

        if (days_in_month < d)
        {
            return false;
        }

        return true;
    }

    bool leapyear(int y)
    {
        return (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;
    }

    bool operator==(const Date &a, const Date &b)
    {
        return a.year() == b.year() && a.month() == b.month() && a.day() == b.day();
    }

    bool operator!=(const Date &a, const Date &b)
    {
        return !(a == b);
    }

    ostream &operator<<(ostream &os, const Date &d)
    {
        return os << '(' << d.year() << ',' << d.month() << ',' << d.day() << ')';
    }

    istream &operator>>(istream &is, Date &dd)
    {
        int y, m, d;
        char ch1, ch2, ch3, ch4;
        is >> ch1 >> y >> ch2 >> m >> ch3 >> d >> ch4;
        if (!is)
        {
            return is;
        }
        if (ch1 != '(' || ch2 != ',' || ch3 != ',' || ch4 != ')')
        {
            is.clear(std::ios_base::failbit);
            return is;
        }
        dd = Date(y, Date::Month(m), d);
        return is;
    }

    ostream &operator<<(ostream &os, Day d)
    {
        switch (d)
        {
        case sunday:
            os << "Sunday";
            break;
        case monday:
            os << "Monday";
            break;
        case tuesday:
            os << "Tuesday";
            break;
        case wednesday:
            os << "Wednesday";
            break;
        case thursday:
            os << "Thursday";
            break;
        case friday:
            os << "Friday";
            break;
        case saturday:
            os << "Saturday";
            break;
        }
        return os;
    }

    const Date first_date = Date(1970, Date::jan, 1);
    const Day first_day = thursday;

    Day day_of_week(const Date &d)
    {
        if (d.year() < first_date.year())
        {
            error("day_of_week: works only for 1970 and later");
        }
        int dlin = days_linear(d);
        return Day((first_day + dlin) % 7);
    }

    Date next_Sunday(const Date &d)
    {
        Date nsd = d;
        Day day = day_of_week(d);
        nsd.add_day(7 - day);
        return nsd;
    }

    int nmonth(Date::Month m)
    {
        switch (m)
        {
        case Date::jan:
            return 0;
        case Date::feb:
            return 31;
        case Date::mar:
            return 31 + 28;
        case Date::apr:
            return 31 + 28 + 31;
        case Date::may:
            return 31 + 28 + 31 + 30;
        case Date::jun:
            return 31 + 28 + 31 + 30 + 31;
        case Date::jul:
            return 31 + 28 + 31 + 30 + 31 + 30;
        case Date::aug:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31;
        case Date::sep:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31;
        case Date::oct:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30;
        case Date::nov:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31;
        case Date::dec:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30;
        }
    }

    int day_in_year(const Date &d)
    {
        int diy = nmonth(d.month());
        diy += d.day();
        if (leapyear(d.year()) && d.month() > Date::feb)
        {
            ++diy;
        }
        return diy;
    }

    void split_date(int day_of_year, int year, int *month, int *day)
    {
        int i;
        bool found = false;

        for (i = 1; i <= 12 && !found; i++)
        {
            switch(i)
            {
            case 1:
            case 3:
            case 5:
            case 7:
            case 8:
            case 10:
            case 12:
                if (day_of_year <= 31)
                {
                    found = true;
                }
                else
                {
                    day_of_year -= 31;
                }
                break;
            case 4:
            case 6:
            case 9:
            case 11:
                if (day_of_year <= 30)
                {
                    found = true;
                }
                else
                {
                    day_of_year -= 30;
                }
                break;
            case 2:
                if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0))
                {
                    if (day_of_year <= 29)
                    {
                        found = true;
                    }
                    else
                    {
                        day_of_year -= 29;
                    }
                }
                else
                {
                    if (day_of_year <= 28)
                    {
                        found = true;
                    }
                    else
                    {
                        day_of_year -= 28;
                    }
                }
                break;
            default :
                break;
            }
        }
        *month = i - 1;
        *day = day_of_year;
    }

    int n_leapyears(int y)
    {
        int nl = 0;
        for (int i = 1970; i < y; ++i)
        {
            if (leapyear(i))
            {
                ++nl;
            }
        }
        return nl;
    }

    long int days_linear(const Date &d)
    {
        if (d.year() < first_date.year())
        {
            error("days_linear: year must be 1970 or later");
        }
        int y = d.year() - first_date.year();
        return y * 365 + n_leapyears(d.year()) + day_in_year(d) - 1;
    }

    Date next_weekday(const Date &d)
    {
        Date nwd = d;
        Day day = day_of_week(d);
        switch (day)
        {
        case sunday:
        case monday:
        case tuesday:
        case wednesday:
        case thursday:
            nwd.add_day(1);
            break;
        case saturday:
            nwd.add_day(2);
            break;
        case friday:
            nwd.add_day(3);
            break;
        }
        return nwd;
    }

}

int main()
{
    try
    {
        using namespace Chrono;
        Date default_d;
        cout << "Default date: " << default_d << endl;
        Date today(1978, Date::jun, 25);
        Date tomorrow = today;
        tomorrow.add_day(1);
        Date next_year = today;
        next_year.add_year(1);
        cout << "Today: " << today << endl;
        cout << "Tomorrow: " << tomorrow << endl;
        cout << "Next year: " << next_year << endl;
        Date invalid_date = Date(2004, Date::dec, -5);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Default date: (2001,1,1)
Today: (1978,6,25)
Tomorrow: (1978,6,26)
Next year: (1979,6,25)
invalid date
error: invalid date

ch09_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

class Name_pairs
{
public:
    void read_names();
    void read_ages();
    void print() const;
    void sort();
    const vector<string> &get_name() const
    {
        return name;
    }
    const vector<double> &get_age() const
    {
        return age;
    }
private:
    vector<string> name;
    vector<double> age;
};

void Name_pairs::read_names()
{
    cout << "Enter names, 'NoName' to finish: ";
    string s;
    while (cin >> s && s != "NoName")
    {
        for (int i = 0; i < name.size(); ++i)
        {
            if (name[i] == s)
            {
                error("Name exists already: " + s);
            }
        }
        name.push_back(s);
    }
}

void Name_pairs::read_ages()
{
    age = vector<double>();
    for (int i = 0; i < name.size(); ++i)
    {
        cout << "Age of " << name[i] << ": ";
        double a;
        cin >> a;
        age.push_back(a);
    }
}

void Name_pairs::print() const
{
    if (name.size() != age.size())
    {
        error("print(): name and age must be the same size");
    }
    for (int i = 0; i < name.size(); ++i)
    {
        cout << '(' << name[i] << ',' << age[i] << ')' << endl;
    }
}

void Name_pairs::sort()
{
    if (name.size() != age.size())
    {
        error("sort(): name and age must be the same size");
    }
    vector<string> name_presort = name;
    vector<double> age_cp = age;
    std::sort(name.begin(), name.end());
    for (int i = 0; i < name.size(); ++i)
    {
        for (int j = 0; j < name_presort.size(); ++j)
        {
            if (name[i] == name_presort[j])
            {
                age[i] = age_cp[j];
            }
        }
    }
}

ostream &operator<<(ostream &os, const Name_pairs &np)
{
    if (np.get_name().size() != np.get_age().size())
    {
        error("<<: name and age must be the same size");
    }
    for (int i = 0; i < np.get_name().size(); ++i)
    {
        os << '(' << np.get_name()[i] << ',' << np.get_age()[i] << ')' << endl;
    }
    return os;
}

bool operator==(const Name_pairs &a, const Name_pairs &b)
{
    if (a.get_name().size() != b.get_name().size() || a.get_age().size() != b.get_age().size())
    {
        return false;
    }
    for (int i = 0; i < a.get_name().size(); ++i)
    {
        if (a.get_name()[i] != b.get_name()[i])
        {
            return false;
        }
    }
    for (int i = 0; i < a.get_age().size(); ++i)
    {
        if (a.get_age()[i] != b.get_age()[i])
        {
            return false;
        }
    }
    return true;
}

bool operator!=(const Name_pairs &a, const Name_pairs &b)
{
    return !(a == b);
}

int main()
{
    try
    {
        Name_pairs np1;
        np1.read_names();
        np1.read_ages();
        Name_pairs np2;
        np2.read_names();
        np2.read_ages();
        cout << "np1:\n" << np1;
        cout << "np2:\n" << np2;
        if (np1 == np2)
        {
            cout << "Identical!\n";
        }
        else
        {
            cout << "Not identical!\n";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter names, 'NoName' to finish: Peter
Smith Mike Pence Donald NoName
Age of Peter: 23
Age of Smith: 33
Age of Mike: 62
Age of Pence: 56
Age of Donald: 72
Enter names, 'NoName' to finish: Peter
Smith Mike NoName
Age of Peter: 35
Age of Smith: 55
Age of Mike: 65
np1:
(Peter,23)
(Smith,33)
(Mike,62)
(Pence,56)
(Donald,72)
np2:
(Peter,35)
(Smith,55)
(Mike,65)
Not identical!

ch09_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

namespace Chrono
{
    class Date
    {
    public:
        enum Month
        {
            jan = 1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
        };

        Date(int y, Month m, int d);
        Date();

        int day() const
        {
            return d;
        }
        Month month() const
        {
            return m;
        }
        int year() const
        {
            return y;
        }

        void add_day(int n);
        void add_month(int n);
        void add_year(int n);
    private:
        int y;
        Month m;
        int d;
    };

    bool is_date(int y, Date::Month m, int d);
    bool leapyear(int y);

    int day_in_year(const Date &d);
    void split_date(int day_of_year, int year, int *month, int *day);
    int n_leapyears(int y);
    long int days_linear(const Date &d);

    enum Day
    {
        sunday, monday, tuesday, wednesday, thursday, friday, saturday
    };
    Day day_of_week(const Date &d);
    ostream &operator<<(ostream &os, Day d);

    bool operator==(const Date &a, const Date &b);
    bool operator!=(const Date &a, const Date &b);

    ostream &operator<<(ostream &os, const Date &d);
    istream &operator>>(istream &is, Date &dd);
}

namespace Chrono
{
    Date::Date(int yy, Month mm, int dd) : y(yy), m(mm), d(dd)
    {
        if (!is_date(yy, mm, dd))
        {
            error("invalid date");
        }
    }

    const Date &default_date()
    {
        static const Date dd(2001, Date::jan, 1);
        return dd;
    }

    Date::Date() : y(default_date().year()), m(default_date().month()), d(default_date().day()) { }

    void Date::add_day(int n)
    {
        int day_of_year = day_in_year(*this);
        day_of_year += n;
        if (day_of_year >= 1 && day_of_year <= 366)
        {
            int res_month, res_day;
            split_date(day_of_year, y, &res_month, &res_day);
            m = Month(res_month);
            d = res_day;
        }
    }

    void Date::add_month(int n)
    {
        int month = m + n;
        if (leapyear(y))
        {
            if (d <= 29 && (month >= jan && month <= dec))
            {
                m = Month(month);
            }
        }
        else
        {
            if (d <= 28 && (month >= jan && month <= dec))
            {
                m = Month(month);
            }
        }
    }

    void Date::add_year(int n)
    {
        if (m == feb && d == 29 && !leapyear(y + n))
        {
            m = mar;
            d = 1;
        }
        y += n;
    }

    bool is_date(int y, Date::Month m, int d)
    {
        if (d <= 0)
        {
            return false;
        }

        int days_in_month = 31;

        switch (m)
        {
        case Date::feb:
            days_in_month = (leapyear(y)) ? 29 : 28;
            break;
        case Date::apr:
        case Date::jun:
        case Date::sep:
        case Date::nov:
            days_in_month = 30;
            break;
        }

        if (days_in_month < d)
        {
            return false;
        }

        return true;
    }

    bool leapyear(int y)
    {
        return (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;
    }

    bool operator==(const Date &a, const Date &b)
    {
        return a.year() == b.year() && a.month() == b.month() && a.day() == b.day();
    }

    bool operator!=(const Date &a, const Date &b)
    {
        return !(a == b);
    }

    ostream &operator<<(ostream &os, const Date &d)
    {
        return os << '(' << d.year() << ',' << d.month() << ',' << d.day() << ')';
    }

    istream &operator>>(istream &is, Date &dd)
    {
        int y, m, d;
        char ch1, ch2, ch3, ch4;
        is >> ch1 >> y >> ch2 >> m >> ch3 >> d >> ch4;
        if (!is)
        {
            return is;
        }
        if (ch1 != '(' || ch2 != ',' || ch3 != ',' || ch4 != ')')
        {
            is.clear(std::ios_base::failbit);
            return is;
        }
        dd = Date(y, Date::Month(m), d);
        return is;
    }

    ostream &operator<<(ostream &os, Day d)
    {
        switch (d)
        {
        case sunday:
            os << "Sunday";
            break;
        case monday:
            os << "Monday";
            break;
        case tuesday:
            os << "Tuesday";
            break;
        case wednesday:
            os << "Wednesday";
            break;
        case thursday:
            os << "Thursday";
            break;
        case friday:
            os << "Friday";
            break;
        case saturday:
            os << "Saturday";
            break;
        }
        return os;
    }

    const Date first_date = Date(1970, Date::jan, 1);
    const Day first_day = thursday;

    Day day_of_week(const Date &d)
    {
        if (d.year() < first_date.year())
        {
            error("day_of_week: works only for 1970 and later");
        }
        int dlin = days_linear(d);
        return Day((first_day + dlin) % 7);
    }

    Date next_Sunday(const Date &d)
    {
        Date nsd = d;
        Day day = day_of_week(d);
        nsd.add_day(7 - day);
        return nsd;
    }

    int nmonth(Date::Month m)
    {
        switch (m)
        {
        case Date::jan:
            return 0;
        case Date::feb:
            return 31;
        case Date::mar:
            return 31 + 28;
        case Date::apr:
            return 31 + 28 + 31;
        case Date::may:
            return 31 + 28 + 31 + 30;
        case Date::jun:
            return 31 + 28 + 31 + 30 + 31;
        case Date::jul:
            return 31 + 28 + 31 + 30 + 31 + 30;
        case Date::aug:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31;
        case Date::sep:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31;
        case Date::oct:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30;
        case Date::nov:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31;
        case Date::dec:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30;
        }
    }

    int day_in_year(const Date &d)
    {
        int diy = nmonth(d.month());
        diy += d.day();
        if (leapyear(d.year()) && d.month() > Date::feb)
        {
            ++diy;
        }
        return diy;
    }

    void split_date(int day_of_year, int year, int *month, int *day)
    {
        int i;
        bool found = false;

        for (i = 1; i <= 12 && !found; i++)
        {
            switch(i)
            {
            case 1:
            case 3:
            case 5:
            case 7:
            case 8:
            case 10:
            case 12:
                if (day_of_year <= 31)
                {
                    found = true;
                }
                else
                {
                    day_of_year -= 31;
                }
                break;
            case 4:
            case 6:
            case 9:
            case 11:
                if (day_of_year <= 30)
                {
                    found = true;
                }
                else
                {
                    day_of_year -= 30;
                }
                break;
            case 2:
                if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0))
                {
                    if (day_of_year <= 29)
                    {
                        found = true;
                    }
                    else
                    {
                        day_of_year -= 29;
                    }
                }
                else
                {
                    if (day_of_year <= 28)
                    {
                        found = true;
                    }
                    else
                    {
                        day_of_year -= 28;
                    }
                }
                break;
            default :
                break;
            }
        }
        *month = i - 1;
        *day = day_of_year;
    }

    int n_leapyears(int y)
    {
        int nl = 0;
        for (int i = 1970; i < y; ++i)
        {
            if (leapyear(i))
            {
                ++nl;
            }
        }
        return nl;
    }

    long int days_linear(const Date &d)
    {
        if (d.year() < first_date.year())
        {
            error("days_linear: year must be 1970 or later");
        }
        int y = d.year() - first_date.year();
        return y * 365 + n_leapyears(d.year()) + day_in_year(d) - 1;
    }

    Date next_workday(const Date &d)
    {
        Date nwd = d;
        Day day = day_of_week(d);
        switch (day)
        {
        case sunday:
        case monday:
        case tuesday:
        case wednesday:
        case thursday:
            nwd.add_day(1);
            break;
        case saturday:
            nwd.add_day(2);
            break;
        case friday:
            nwd.add_day(3);
            break;
        }
        return nwd;
    }

}

namespace Liber
{
    class ISBN
    {
    public:
        int n1;
        int n2;
        int n3;
        int n4;
        char x;

        ISBN(int n1_val, int n2_val, int n3_val, int n4_val, char x_val);
        ISBN();
    };

    bool is_isbn(int, int, int, int, char);

    bool operator==(const ISBN &i1, const ISBN &i2);

    class Book
    {
    public:
        enum Genre
        {
            fiction = 0, nonfiction, periodical, biography, children
        };

        Book(const ISBN &isbn_num, const string &title, const string &author, int c_date, Genre gen, bool checked_out);
        Book();

        const ISBN &isbn() const
        {
            return in;
        }
        const string &title() const
        {
            return t;
        }
        const string &author() const
        {
            return a;
        }
        int c_date() const
        {
            return cd;
        }
        Genre genre() const
        {
            return g;
        }
        bool checked_out() const
        {
            return ch_out;
        }

        void check_out();
        void check_in();

    private:
        ISBN in;
        string t;
        string a;
        int cd;
        Genre g;
        bool ch_out;
    };

    bool operator==(const Book &b1, const Book &b2);
    bool operator!=(const Book &b1, const Book &b2);
    ostream &operator<<(ostream &os, const Book &b);


    class Patron
    {
    public:
        Patron(const string &name, int card_number, double fees);
        Patron();

        const string &get_name() const
        {
            return name;
        }
        int get_number() const
        {
            return card_number;
        }
        double get_fees() const
        {
            return fees;
        }

        void set_fee(double f);
    private:
        string name;
        int card_number;
        double fees;
    };

    bool owes_fee(const Patron &p);

    bool operator==(const Patron &p1, const Patron &p2);
    bool operator!=(const Patron &p1, const Patron &p2);

    class Library
    {
    public:
        class Transaction
        {
        public:
            Book b;
            Patron p;
            Chrono::Date d;

            Transaction(const Book &bb, const Patron &pp, const Chrono::Date &dd);
            Transaction();
        };

        Library(const vector<Book> &books, const vector<Patron> &patrons, const vector<Transaction> transactions);
        Library();

        void add_book(const Book &b);
        void add_patron(const Patron &p);
        void check_out(const Book &b, const Patron &p, const Chrono::Date &d);
        void set_fee(const Patron &p, double f);

        const vector<Book> &get_books() const
        {
            return books;
        }
        const vector<Patron> &get_patrons() const
        {
            return patrons;
        }
        const vector<Transaction> &get_transactions() const
        {
            return transactions;
        }
        vector<Patron> get_debtors() const;

    private:
        vector<Book> books;
        vector<Patron> patrons;
        vector<Transaction> transactions;
    };

}

namespace Liber
{
    ISBN::ISBN(int n1_val, int n2_val, int n3_val, int n4_val, char x_val)
        : n1(n1_val), n2(n2_val), n3(n3_val), n4(n4_val), x(x_val)
    {
        if (!is_isbn(n1, n2, n3, n4, x))
        {
            error("is_isbn(): invalid number");
        }
    }

    const ISBN &default_isbn()
    {
        static const ISBN in(0, 0, 0, 0, '0');
        return in;
    }

    ISBN::ISBN()
        : n1(default_isbn().n1),
          n2(default_isbn().n2),
          n3(default_isbn().n3),
          n4(default_isbn().n4),
          x(default_isbn().x)
    {
    }

    bool is_isbn(int, int, int, int, char x)
    {
        return (isalpha(x) || isdigit(x));
    }

    bool operator==(const ISBN &i1, const ISBN &i2)
    {
        return (i1.n1 == i2.n1 && i1.n2 == i2.n2 && i1.n3 == i2.n3 && i1.n4 == i2.n4 && i1.x == i2.x);
    }

    Book::Book(const ISBN &isbn_num, const string &title, const string &author, int c_date, Genre gen, bool checked_out)
        : in(isbn_num), t(title), a(author), cd(c_date), g(gen), ch_out(checked_out)
    {
    }

    const Book &default_book()
    {
        static const Book b(ISBN(), "", "", 0, Book::fiction, false);
        return b;
    }

    Book::Book()
        : in(default_book().isbn()),
          t(default_book().title()),
          a(default_book().author()),
          cd(default_book().c_date()),
          g(default_book().genre()),
          ch_out(default_book().checked_out())
    {
    }

    void Book::check_out()
    {
        if (checked_out())
        {
            error("already checked out");
        }
        ch_out = true;
    }

    void Book::check_in()
    {
        if (!checked_out())
        {
            error("already checked in");
        }
        ch_out = false;
    }

    bool operator==(const Book &b1, const Book &b2)
    {
        return (b1.isbn() == b2.isbn());
    }

    bool operator!=(const Book &b1, const Book &b2)
    {
        return !(b1 == b2);
    }

    ostream &operator<<(ostream &os, const Book &b)
    {
        return os << b.title() << endl
               << b.author() << endl
               << b.isbn().n1 << '-'
               << b.isbn().n2 << '-'
               << b.isbn().n3 << '-'
               << b.isbn().n4 << '-'
               << b.isbn().x << endl;
    }

    Patron::Patron(const string &n, int cn, double f)
        : name(n), card_number(cn), fees(f)
    {
    }

    const Patron &default_patron()
    {
        static const Patron p("", 0, 0);
        return p;
    }

    Patron::Patron()
        : name(default_patron().get_name()),
          card_number(default_patron().get_number()),
          fees(default_patron().get_fees())
    {
    }

    void Patron::set_fee(double f)
    {
        if (f < 0)
        {
            error("set_fee(): fee cannot be smaller than zero");
        }
        fees = f;
    }

    bool owes_fee(const Patron &p)
    {
        return p.get_fees() > 0;
    }

    bool operator==(const Patron &p1, const Patron &p2)
    {
        return p1.get_number() == p2.get_number();
    }

    bool operator!=(const Patron &p1, const Patron &p2)
    {
        return !(p1 == p2);
    }

    Library::Transaction::Transaction(const Book &bb, const Patron &pp, const Chrono::Date &dd)
        : b(bb), p(pp), d(dd)
    {
    }

    const Library::Transaction &default_transaction()
    {
        static const Library::Transaction tt = Library::Transaction(Book(), Patron(), Chrono::Date());
        return tt;
    }

    Library::Transaction::Transaction()
        : b(default_transaction().b),
          p(default_transaction().p),
          d(default_transaction().d)
    {
    }

    Library::Library(const vector<Book> &b, const vector<Patron> &p, const vector<Transaction> t)
        : books(b), patrons(p), transactions(t)
    {
    }

    const Library &default_library()
    {
        vector<Book> b;
        vector<Patron> p;
        vector<Library::Transaction> t;
        static const Library l(b, p, t);
        return l;
    }

    Library::Library()
        : books(default_library().get_books()),
          patrons(default_library().get_patrons()),
          transactions(default_library().get_transactions())
    {
    }

    void Library::add_book(const Book &b)
    {
        for (int i = 0; i < books.size(); ++i)
        {
            if (books[i] == b)
            {
                error("add_book(): book is already in library");
            }
        }
        books.push_back(b);
    }

    void Library::add_patron(const Patron &p)
    {
        for (int i = 0; i < patrons.size(); ++i)
        {
            if (patrons[i] == p)
            {
                error("add_patron(): patron is already registered");
            }
        }
        patrons.push_back(p);
    }

    void Library::check_out(const Book &b, const Patron &p, const Chrono::Date &d)
    {
        bool b_exists = false;
        int b_idx = 0;
        for (int i = 0; i < books.size(); ++i)
        {
            if (books[i] == b)
            {
                b_exists = true;
                b_idx = i;
                break;
            }
        }
        if (!b_exists)
        {
            error("check_out(): book is not in library");
        }

        if (books[b_idx].checked_out())
        {
            error("check_out(): book is already checked out");
        }

        bool p_exists = false;
        int p_idx = 0;
        for (int i = 0; i < patrons.size(); ++i)
        {
            if (patrons[i] == p)
            {
                p_exists = true;
                p_idx = i;
                break;
            }
        }
        if (!p_exists)
        {
            error("check_out(): patron is not registered");
        }

        if (patrons[p_idx].get_fees() > 0)
        {
            error("check_out(): patron owes library fees");
        }

        transactions.push_back(Transaction(books[b_idx], patrons[p_idx], d));
        books[b_idx].check_out();
    }

    void Library::set_fee(const Patron &p, double f)
    {
        int idx = 0;
        bool exists = false;
        for (int i = 0; i < patrons.size(); ++i)
        {
            if (patrons[i] == p)
            {
                exists = true;
                idx = i;
                break;
            }
        }
        if (!exists)
        {
            error("Library::set_fee(): patron does not exist");
        }
        patrons[idx].set_fee(f);
    }

    vector<Patron> Library::get_debtors() const
    {
        vector<Patron> debtors;
        for (int i = 0; i < patrons.size(); ++i)
        {
            if (patrons[i].get_fees() > 0)
            {
                debtors.push_back(patrons[i]);
            }
        }
        return debtors;
    }

}

using Liber::Library;
using Liber::Book;
using Liber::ISBN;
using Liber::Patron;
using Chrono::Date;
using Chrono::leapyear;
using Chrono::day_in_year;
using Chrono::n_leapyears;
using Chrono::days_linear;
using Chrono::day_of_week;

void test_liber()
{
    Library my_lib;

    Book my_book(ISBN(9780, 4390, 2348, 0, '1'),
                 "Hunger Games, The",
                 "Collins, Suzanne",
                 2008,
                 Book::fiction,
                 false);
    my_lib.add_book(my_book);

    Book my_book2(ISBN(9780, 4393, 5807, 0, '1'),
                  "Harry Potter and the Order of the Phoenix",
                  "Rowling, J.K.",
                  2003,
                  Book::children,
                  false);
    my_lib.add_book(my_book2);

    my_lib.add_book(Book(ISBN(9781, 4165, 3932, 0, '2'),
                         "Einstein: His Life and Universe",
                         "Isaacson, Walter",
                         2007,
                         Book::biography,
                         false));

    my_lib.add_book(Book(ISBN(9780, 3160, 6760, 0, '7'),
                         "Lone Survivor",
                         "Luttrell, Marcus",
                         2008,
                         Book::nonfiction,
                         false));

    my_lib.add_book(Book(ISBN(1234, 5678, 1234, 0, 'x'),
                         "Triathlete Issue 2/14",
                         "Competitor Group",
                         2014,
                         Book::periodical,
                         false));

    cout << "All my books:\n\n";
    const vector<Book> &books = my_lib.get_books();
    for (int i = 0; i < books.size(); ++i)
    {
        cout << books[i] << endl;
    }

    Patron my_patron1 = Patron("Forrest, Kara", 100, 0);
    my_lib.add_patron(my_patron1);
    Patron my_patron2 = Patron("Wuethrich, Benjamin", 101, 0);
    my_lib.add_patron(my_patron2);
    my_lib.add_patron(Patron("Buehler, Catriona", 102, 0));
    my_lib.add_patron(Patron("Schaerli, Tobias", 103, 0));
    my_lib.add_patron(Patron("Bieler, Ueli", 104, 0));

    cout << "List of patrons:\n\n";
    const vector<Patron> &patrons = my_lib.get_patrons();
    for (int i = 0; i < patrons.size(); ++i)
    {
        cout << patrons[i].get_name() << ", " << patrons[i].get_number() << ", " << patrons[i].get_fees() << endl;
    }

    my_lib.set_fee(my_patron1, 10);
    my_lib.set_fee(my_patron2, 15);

    cout << "\nList of debtors:\n\n";
    vector<Patron> debtors = my_lib.get_debtors();
    for (int i = 0; i < debtors.size(); ++i)
    {
        cout << debtors[i].get_name() << ", " << debtors[i].get_number() << ", " << debtors[i].get_fees() << endl;
    }

    my_lib.check_out(my_book, patrons[2], Date(2014, Date::jan, 31));
    my_lib.check_out(my_book2, patrons[3], Date());

    cout << "\nTransactions:\n";
    const vector<Library::Transaction> &transactions = my_lib.get_transactions();
    for (int i = 0; i < transactions.size(); ++i)
    {
        cout << transactions[i].b <<
             transactions[i].d << endl <<
             transactions[i].p.get_name() << endl;
    }
}

void test_leapyear()
{
    if (leapyear(2000))
    {
        cout << "2000 is a leap year\n";
    }
    if (leapyear(2004))
    {
        cout << "2004 is a leap year\n";
    }
    if (leapyear(2005))
    {
        cout << "2005 is a leap year\n";
    }
    if (leapyear(2100))
    {
        cout << "2100 is a leap year\n";
    }
}

void test_lineardate()
{
    cout << "Jan 1, 2000 is day #" <<
         day_in_year(Date(2000, Date::jan, 1)) <<
         " of the year.\n";
    cout << "Feb 29, 2000 is day #" <<
         day_in_year(Date(2000, Date::feb, 29)) <<
         " of the year.\n";
    cout << "Mar 1, 2000 is day #" <<
         day_in_year(Date(2000, Date::mar, 1)) <<
         " of the year.\n";

    cout << "Number of leap years since 1970:\n" <<
         "1971: " << n_leapyears(1971) << endl <<
         "1972: " << n_leapyears(1972) << endl <<
         "1973: " << n_leapyears(1973) << endl <<
         "1974: " << n_leapyears(1974) << endl <<
         "2000: " << n_leapyears(2000) << endl <<
         "2001: " << n_leapyears(2001) << endl <<
         "2101: " << n_leapyears(2101) << endl;

    cout << "Days since Jan 1, 1970:\n" <<
         "Jan 1, 1970: " << days_linear(Date(1970, Date::jan, 1)) << endl <<
         "Mar 1, 2001: " << days_linear(Date(2001, Date::mar, 1)) << endl <<
         "Jan 31, 2014: " << days_linear(Date(2014, Date::jan, 31)) << endl <<
         "Nov 30, 2111: " << days_linear(Date(2111, Date::nov, 30)) << endl;

    cout << "Day of week:\n" <<
         "Jan 1, 1970: " << day_of_week(Date(1970, Date::jan, 1)) << endl <<
         "Sep 11, 2001: " << day_of_week(Date(2001, Date::sep, 11)) << endl <<
         "Jan 31, 2014: " << day_of_week(Date(2014, Date::jan, 31)) << endl;
}


int main()
{
    try
    {
        test_liber();
        test_leapyear();
        test_lineardate();
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
All my books:

Hunger Games, The
Collins, Suzanne
9780-4390-2348-0-1

Harry Potter and the Order of the Phoenix
Rowling, J.K.
9780-4393-5807-0-1

Einstein: His Life and Universe
Isaacson, Walter
9781-4165-3932-0-2

Lone Survivor
Luttrell, Marcus
9780-3160-6760-0-7

Triathlete Issue 2/14
Competitor Group
1234-5678-1234-0-x

List of patrons:

Forrest, Kara, 100, 0
Wuethrich, Benjamin, 101, 0
Buehler, Catriona, 102, 0
Schaerli, Tobias, 103, 0
Bieler, Ueli, 104, 0

List of debtors:

Forrest, Kara, 100, 10
Wuethrich, Benjamin, 101, 15

Transactions:
Hunger Games, The
Collins, Suzanne
9780-4390-2348-0-1
(2014,1,31)
Buehler, Catriona
Harry Potter and the Order of the Phoenix
Rowling, J.K.
9780-4393-5807-0-1
(2001,1,1)
Schaerli, Tobias
2000 is a leap year
2004 is a leap year
Jan 1, 2000 is day #1 of the year.
Feb 29, 2000 is day #60 of the year.
Mar 1, 2000 is day #61 of the year.
Number of leap years since 1970:
1971: 0
1972: 0
1973: 1
1974: 1
2000: 7
2001: 8
2101: 32
Days since Jan 1, 1970:
Jan 1, 1970: 0
Mar 1, 2001: 11382
Jan 31, 2014: 16101
Nov 30, 2111: 51832
Day of week:
Jan 1, 1970: Thursday
Sep 11, 2001: Tuesday
Jan 31, 2014: Friday

ch09_p13.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int gcd(int a, int b)
{
    while (b != 0)
    {
        int t = b;
        b = a % b;
        a = t;
    }
    return a;
}

class Rational
{
public:
    Rational() : numer(0), denom(1) { }
    Rational(int n) : numer(n), denom(1) { }
    Rational(int n, int d) : numer(n), denom(d)
    {
        normalise();
    }

    int get_numer() const
    {
        return numer;
    }
    int get_denom() const
    {
        return denom;
    }
    double conv_double() const
    {
        return double(numer) / denom;
    }

    void normalise()
    {
        if (denom == 0)
        {
            error("denominator is zero");
        }
        if (denom < 0)
        {
            denom = -denom;
            numer = -numer;
        }
        int n = gcd(numer, denom);
        if (n > 1)
        {
            numer /= n;
            denom /= n;
        }
    }

private:
    int numer;
    int denom;
};

Rational operator+(const Rational &r1, const Rational &r2);
Rational operator-(const Rational &r1, const Rational &r2);
Rational operator*(const Rational &r1, const Rational &r2);
Rational operator/(const Rational &r1, const Rational &r2);
bool operator==(const Rational &r1, const Rational &r2);
bool operator!=(const Rational &r1, const Rational &r2);
ostream &operator<<(ostream &os, const Rational &r);

Rational operator+(const Rational &r1, const Rational &r2)
{
    Rational r(r1.get_numer()*r2.get_denom() + r1.get_denom()*r2.get_numer(),
               r1.get_denom()*r2.get_denom());
    r.normalise();
    return r;
}

Rational operator-(const Rational &r1, const Rational &r2)
{
    Rational r(r1.get_numer()*r2.get_denom() - r1.get_denom()*r2.get_numer(),
               r1.get_denom()*r2.get_denom());
    r.normalise();
    return r;
}

Rational operator*(const Rational &r1, const Rational &r2)
{
    Rational r(r1.get_numer()*r2.get_numer(), r1.get_denom()*r2.get_denom());
    r.normalise();
    return r;
}

Rational operator/(const Rational &r1, const Rational &r2)
{
    Rational r(r1.get_numer()*r2.get_denom(), r1.get_denom()*r2.get_numer());
    r.normalise();
    return r;
}

bool operator==(const Rational &r1, const Rational &r2)
{
    return r1.get_numer() * r2.get_denom() == r1.get_denom() * r2.get_numer();
}

bool operator!=(const Rational &r1, const Rational &r2)
{
    return !(r1 == r2);
}

ostream &operator<<(ostream &os, const Rational &r)
{
    return cout << '(' << r.get_numer() << '/' << r.get_denom() << ')';
}

int main()
{
    try
    {
        Rational r1;
        Rational r2(5);
        Rational r3(7, 3);
        cout << "r1: " << r1 << endl
             << "r2: " << r2 << endl
             << "r3: " << r3 << endl;

        cout << "5/3 + 7/2 = " << Rational(5, 3) + Rational(7, 2) <<
             " = " << (Rational(5, 3) + Rational(7, 2)).conv_double() << endl;
        cout << "8/5 - 40/7 = " << Rational(8, 5) - Rational(40, 7) <<
             " = " << (Rational(8, 5) - Rational(40, 7)).conv_double() << endl;
        cout << "10/11 * 17/18 = " << Rational(10, 11) * Rational(17, 18) <<
             " = " << (Rational(10, 11) * Rational(17, 18)).conv_double() << endl;
        cout << "(5/7) / (1/3) = " << Rational(5, 7) / Rational(1, 3) <<
             " = " << (Rational(5, 7) / Rational(1, 3)).conv_double() << endl;

        if (r1 == Rational(0, 1))
        {
            cout << "r1 == 0/1" << endl;
        }
        if (Rational(1, 2) == Rational(2, 4))
        {
            cout << "1/2 == 2/4" << endl;
        }
        if (r2 != r2)
        {
            cout << "r2 != r2" << endl;
        }

        cout << r3 << " = " << r3.conv_double() << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
r1: (0/1)
r2: (5/1)
r3: (7/3)
5/3 + 7/2 = (31/6) = 5.16667
8/5 - 40/7 = (-144/35) = -4.11429
10/11 * 17/18 = (85/99) = 0.858586
(5/7) / (1/3) = (15/7) = 2.14286
r1 == 0/1
1/2 == 2/4
(7/3) = 2.33333

ch09_p14.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

long int my_round(double d)
{
    return (d > 0.0) ? (d + 0.5) : (d - 0.5);
}

class Money
{
public:
    enum Currency
    {
        USD, CHF, KYD
    };
    Money() : cents(0), cur(USD) { }
    Money(long int c) : cents(c), cur(USD) { }
    Money(int d, int c) : cents(d * 100 + c), cur(USD)
    {
        if (c >= 100)
        {
            error("cents must be between 0 and 99");
        }
    }
    Money(long int c, Currency cur_val) : cents(c), cur(cur_val) { }
    Money(int d, int c, Currency cur_val) : cents(d * 100 + c), cur(cur_val)
    {
        if (c >= 100)
        {
            error("cents must be between 0 and 99");
        }
    }
    int get_dollars() const
    {
        return cents / 100;
    }
    int get_cents() const
    {
        return cents % 100;
    }
    long int cents;
    Currency cur;
};

double exch_rate(Money::Currency c1, Money::Currency c2)
{
    switch (c1)
    {
    case Money::USD:
        switch (c2)
        {
        case Money::CHF:
            return 1.11;
        case Money::KYD:
            return 1.22;
        default:
            error("exch_rate: illegal combination of currencies");
        }
    case Money::CHF:
        switch (c2)
        {
        case Money::USD:
            return 0.91;
        case Money::KYD:
            return 1.1;
        default:
            error("exch_rate: illegal combination of currencies");
        }
    case Money::KYD:
        switch (c2)
        {
        case Money::USD:
            return 0.82;
        case Money::CHF:
            return 0.91;
        default:
            error("exch_rate: illegal combination of currencies");
        }
    default:
        error("exch_rate: illegal combination of currencies");
    }
}

Money operator+(const Money &a, const Money &b)
{
    if (a.cur == b.cur)
    {
        return Money(a.cents + b.cents, a.cur);
    }

    double d = exch_rate(a.cur, b.cur);

    return Money(a.cents + my_round(d * double(b.cents)), a.cur);
}

Money operator-(const Money &a, const Money &b)
{
    if (a.cur == b.cur)
    {
        return Money(a.cents - b.cents, a.cur);
    }

    double d = exch_rate(a.cur, b.cur);

    return Money(a.cents - my_round(d * double(b.cents)), a.cur);
}

Money operator-(const Money &m)
{
    return Money(-m.cents, m.cur);
}

Money operator*(int n, const Money &m)
{
    return Money(n * m.cents, m.cur);
}

Money operator*(const Money &m, int n)
{
    return n * m;
}

Money operator/(const Money &m, int n)
{
    if (n == 0)
    {
        error("division by zero");
    }
    double d = double(m.cents) / n;
    long int c = my_round(d);
    return Money(c, m.cur);
}

ostream &operator<<(ostream &os, Money::Currency cur)
{
    switch (cur)
    {
    case Money::USD:
        return os << "USD";
    case Money::CHF:
        return os << "CHF";
    case Money::KYD:
        return os << "KYD";
    }
}

ostream &operator<<(ostream &os, const Money &m)
{
    os << m.cur << m.get_dollars() << '.';
    if (abs(m.get_cents()) < 10)
    {
        os << '0';
    }
    os << abs(m.get_cents());
    return os;
}

istream &operator>>(istream &is, Money &m)
{
    double d;
    string s;
    is >> s >> d;
    if (!is)
    {
        return is;
    }
    if (!(s == "USD" || s == "CHF" || s == "KYD"))
    {
        is.clear(std::ios_base::failbit);
        return is;
    }
    int i2 = int(d);
    double d2 = (d - i2) * 100.0;
    int i3 = int(d2);
    Money::Currency cur;
    if (s == "USD")
    {
        cur = Money::USD;
    }
    else if (s == "CHF")
    {
        cur = Money::CHF;
    }
    else if (s == "KYD")
    {
        cur = Money::KYD;
    }
    m = Money(i2, i3, cur);
    return is;
}

int main()
{
    try
    {
        Money m1;
        Money m2(105);
        Money m3(5, 12);

        cout << "m1: " << m1 << endl;
        cout << "m2(105): " << m2 << endl;
        cout << "m3(5, 12): " << m3 << endl;
        cout << "-m3: " << -m3 << endl;

        cout << m2 << " + " << m3 << " = " << m2 + m3 << endl;
        cout << m2 << " - " << m3 << " = " << m2 - m3 << endl;
        cout << "5 * " << m2 << " = " << 5 * m2 << endl;
        cout << m2 << " * 5 = " << m2 * 5 << endl;

        cout << m3 << " - " << m2 << " = " << m3 - m2 << endl;

        cout << Money(1, 0) << " / 7 = " << Money(1, 0) / 7 << endl;
        cout << Money(0, 9) << " / 6 = " << Money(0, 9) / 6 << endl << endl;

        m1 = Money(7, 12, Money::USD);
        m2 = Money(100, 5, Money::CHF);
        m3 = Money(55, 12, Money::KYD);
        cout << "m1 = " << m1 << endl;
        cout << "m2 = " << m2 << endl;
        cout << "m3 = " << m3 << endl << endl;
        cout << m1 << " + " << m2 << " = " << m1 + m2 << endl;
        cout << m1 << " + " << m3 << " = " << m1 + m3 << endl;
        cout << m2 << " + " << m1 << " = " << m2 + m1 << endl;
        cout << m2 << " + " << m3 << " = " << m2 + m3 << endl;
        cout << m3 << " + " << m1 << " = " << m3 + m1 << endl;
        cout << m3 << " + " << m2 << " = " << m3 + m2 << endl;
        cout << m3 << " - " << m2 << " = " << m3 - m2 << endl;
        cout << 3 << " * " << m2 << " = " << 3 * m2 << endl;
        cout << m3 << " / " << 17 << " = " << m3 / 17 << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
m1: USD0.00
m2(105): USD1.05
m3(5, 12): USD5.12
-m3: USD-5.12
USD1.05 + USD5.12 = USD6.17
USD1.05 - USD5.12 = USD-4.07
5 * USD1.05 = USD5.25
USD1.05 * 5 = USD5.25
USD5.12 - USD1.05 = USD4.07
USD1.00 / 7 = USD0.14
USD0.09 / 6 = USD0.02

m1 = USD7.12
m2 = CHF100.05
m3 = KYD55.12

USD7.12 + CHF100.05 = USD118.18
USD7.12 + KYD55.12 = USD74.37
CHF100.05 + USD7.12 = CHF106.53
CHF100.05 + KYD55.12 = CHF160.68
KYD55.12 + USD7.12 = KYD60.96
KYD55.12 + CHF100.05 = KYD146.17
KYD55.12 - CHF100.05 = KYD-35.93
3 * CHF100.05 = CHF300.15
KYD55.12 / 17 = KYD3.24

第二部分 输入和输出
第10章 输入/输出流
10.1 输人和输出
10.2 I/O流模型
10.3 文件
10.4 打开文件
10.5 读写文件
10.6 I/O错误处理
10.7 读取单个值
10.7.1 将程序分解为易管理的子模块
10.7.2 将人机对话从函数中分离
10.8 用户自定义输出操作符
10.9 用户自定义输入操作符
10.10 一个标准的输入循环
10.11 读取结构化的文件
10.11.1 内存表示
10.11.2 读取结构化的值
10.11.3 改变表示方法
ch10_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

struct Point
{
    int x;
    int y;
    Point() : x(0), y(0) { }
    Point(int xx, int yy) : x(xx), y(yy) { }
};

bool operator==(const Point &p1, const Point &p2)
{
    return p1.x == p2.x && p1.y == p2.y;
}

bool operator!=(const Point &p1, const Point &p2)
{
    return !(p1 == p2);
}

ostream &operator<<(ostream &os, const Point &p)
{
    return os << '(' << p.x << ',' << p.y << ')';
}

istream &operator>>(istream &is, Point &p)
{
    int x, y;
    char ch1, ch2, ch3;
    is >> ch1 >> x >> ch2 >> y >> ch3;
    if (!is)
    {
        return is;
    }
    if (ch1 != '(' || ch2 != ',' || ch3 != ')')
    {
        is.clear(std::ios_base::failbit);
        return is;
    }
    p = Point(x, y);
    return is;
}

void print_vector(const vector<Point> &points)
{
    for (int i = 0; i < points.size(); ++i)
    {
        cout << points[i] << endl;
    }
}

void write_to_file(const vector<Point> &points, const string &name)
{
    ofstream ost(name.c_str());
    if (!ost)
    {
        error("can't open output file " + name);
    }
    for (int i = 0; i < points.size(); ++i)
    {
        ost << points[i] << endl;
    }
}

void fill_from_file(vector<Point> &points, const string &name)
{
    ifstream ist(name.c_str());
    if (!ist)
    {
        error("can't open input file " + name);
    }
    Point pp;
    while (ist >> pp)
    {
        points.push_back(pp);
    }
}

bool compare_vectors(const vector<Point> &points1, const vector<Point> &points2)
{
    if (points1.size() != points2.size())
    {
        cerr << "compare_vectors: points1.size() != points2.size()" << endl;
        return false;
    }
    for (int i = 0; i < points1.size(); ++i)
    {
        if (points1[i] != points2[i])
        {
            cerr << "compare_vectors: points1[i] != points2[i]" << endl;
            return false;
        }
    }
    return true;
}

int main()
{
    try
    {
        vector<Point> original_points;
        cout << "Enter 7 (x,y) pairs:\n";
        for (int i = 0; i < 7; ++i)
        {
            Point p;
            cin >> p;
            original_points.push_back(p);
        }

        cout << "\nOriginal points:\n";
        print_vector(original_points);

        string filename = "ch10_d01.txt";
        write_to_file(original_points, filename);

        vector<Point> processed_points;
        fill_from_file(processed_points, filename);

        cout << "\nData from ifstream:\n";
        print_vector(processed_points);
        cout << "\nOriginal data:\n";
        print_vector(original_points);

        if ( compare_vectors(original_points, processed_points) )
        {
            cout << "original_points == processed_points" << endl;
        }
        else
        {
            cout << "original_points != processed_points" << endl;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter 7 (x,y) pairs:
(1,3)
(3,5)
(5,6)
(7,9)
(9,11)
(8,12)
(6,9)

Original points:
(1,3)
(3,5)
(5,6)
(7,9)
(9,11)
(8,12)
(6,9)

Data from ifstream:
(1,3)
(3,5)
(5,6)
(7,9)
(9,11)
(8,12)
(6,9)

Original data:
(1,3)
(3,5)
(5,6)
(7,9)
(9,11)
(8,12)
(6,9)
original_points == processed_points

cat ch10_d01.txt
(1,3)
(3,5)
(5,6)
(7,9)
(9,11)
(8,12)
(6,9)

ch10_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

void read_ints(vector<int> &ints, const string &name)
{
    ifstream ist(name.c_str());
    if (!ist) { error("can't open input file " + name); }
    int n;
    while (ist >> n) { ints.push_back(n); }
}

int get_sum(const vector<int> &v)
{
    int sum = 0;
    for (int i = 0; i < v.size(); ++i)
    {
        sum += v[i];
    }
    return sum;
}

int main()
{
    try
    {
        cout << "Enter file name: ";
        string iname;
        cin >> iname;
        vector<int> ints;
        read_ints(ints, iname);
        int sum = get_sum(ints);
        cout << "Sum of integers in " << iname << " is " << sum << ".\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter file name: ch10_p01.txt
Sum of integers in ch10_p01.txt is 91.

cat ch10_p01.txt
1
3
5
7
9
2
4
6
8
10
11
12
13

ch10_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

struct Reading
{
    int hour;
    double temperature;
    Reading(int h, double t) : hour(h), temperature(t) { }
};

ostream &operator<<(ostream &os, const Reading &r)
{
    return os << '(' << r.hour << ',' << r.temperature << ')';
}

const int max_temp = 107;
const int min_temp = -43;

Reading create_reading(mt19937 &e)
{
    int h = nrand_two(0, 24, e);
    double t = nrand_two(min_temp, max_temp+1, e) + nrand_two(-10, 11, e) / double(10);
    return Reading(h, t);
}

void write_to_file(const vector<Reading> &r, const string &name)
{
    ofstream ost(name.c_str());
    if (!ost) { error("can't open output file " + name); }
    for (int i = 0; i < r.size(); ++i)
    {
        ost << r[i] << endl;
    }
}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);
    try
    {
        vector<Reading> readings;
        for (int i = 0; i < 10; ++i)
        {
            readings.push_back(create_reading(engine));
        }

        write_to_file(readings, "ch10_p02.txt");
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
cat ch10_p02.txt
(0,92.3)
(21,-22)
(1,13.8)
(20,-10.8)
(5,90.5)
(21,54.2)
(3,47)
(23,99.4)
(5,67.7)
(1,62.5)

ch10_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

struct Reading
{
    int hour;
    double temperature;
    Reading() : hour(0), temperature(0) { }
    Reading(int h, double t) : hour(h), temperature(t) { }
};

bool operator<(const Reading &r1, const Reading &r2)
{
    return r1.temperature < r2.temperature;
}

ostream &operator<<(ostream &os, const Reading &r)
{
    return os << '(' << r.hour << ',' << r.temperature << ')';
}

istream &operator>>(istream &is, Reading &r)
{
    int hour;
    char c1, c2, c3;
    double temperature;
    is >> c1 >> hour >> c2 >> temperature >> c3;
    if (!is)
    {
        return is;
    }
    if (c1 != '(' || c2 != ',' || c3 != ')')
    {
        is.clear(std::ios_base::failbit);
        return is;
    }
    r = Reading(hour, temperature);
    return is;
}

const int max_temp = 108;
const int min_temp = -44;

void fill_from_file(vector<Reading> &readings, const string &name)
{
    ifstream ist(name.c_str());
    if (!ist)
    {
        error("can't open input file " + name);
    }
    Reading r;
    while (ist >> r)
    {
        if (r.hour < 0 || r.hour > 23)
        {
            error("hour out of range");
        }
        if (r.temperature < min_temp || r.temperature > max_temp)
        {
            error("temperature out of range");
        }
        readings.push_back(r);
    }
}

void print_vector(const vector<Reading> &r)
{
    for (int i = 0; i < r.size(); ++i)
    {
        cout << r[i] << endl;
    }
}

int main()
{
    try
    {
        vector<Reading> readings;
        fill_from_file(readings, "ch10_p02.txt");

        sort(readings.begin(), readings.end());
        print_vector(readings);
        auto size = readings.size();
        auto mid = size / 2;
        double median;
        if (size % 2 == 0)
        {
            median = (readings[mid].temperature + readings[mid - 1].temperature) / 2;
        }
        else
        {
            median = readings[mid].temperature;
        }
        double sum = 0;
        for (int i = 0; i < readings.size(); ++i)
        {
            sum += readings[i].temperature;
        }
        double avg = sum / readings.size();

        cout << "median temperature: " << median << " F" << endl;
        cout << "average temperature: " << avg << " F" << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
(21,-22)
(20,-10.8)
(1,13.8)
(3,47)
(21,54.2)
(1,62.5)
(5,67.7)
(5,90.5)
(0,92.3)
(23,99.4)
median temperature: 58.35 F
average temperature: 49.46 F

ch10_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

const char fahr = 'f';
const char cels = 'c';

const int max_temp = 108;
const int min_temp = -44;

struct Reading
{
    int hour;
    double temperature;
    char temp_scale;
    Reading() : hour(0), temperature(0), temp_scale(fahr) { }
    Reading(int h, double t, char ts) : hour(h), temperature(t), temp_scale(ts) { }
};

bool operator<(const Reading &r1, const Reading &r2)
{
    return r1.temperature < r2.temperature;
}

ostream &operator<<(ostream &os, const Reading &r)
{
    return os << r.hour << ' ' << r.temperature << r.temp_scale;
}

istream &operator>>(istream &is, Reading &r)
{
    int hour;
    double temperature;
    char temp_scale;

    is >> hour >> temperature >> temp_scale;
    if (!is)
    {
        return is;
    }
    r = Reading(hour, temperature, temp_scale);
    return is;
}

double c_to_f(double t)
{
    return (t * 1.8 + 32.0);
}

Reading create_reading(mt19937 &e)
{
    int h = nrand_two(0, 24, e);
    double t = nrand_two(min_temp, max_temp + 1, e) + nrand_two(-10, 11, e) / double(10);
    char ts;
    nrand_two(0, 10, e) > 4 ? ts = fahr : ts = cels;
    return Reading(h, t, ts);
}

void write_to_file(const vector<Reading> &r, const string &name)
{
    ofstream ost(name.c_str());
    if (!ost)
    {
        error("can't open output file " + name);
    }
    for (int i = 0; i < r.size(); ++i)
    {
        ost << r[i] << endl;
    }
}

void fill_from_file(vector<Reading> &readings, const string &name)
{
    ifstream ist(name.c_str());
    if (!ist)
    {
        error("can't open input file " + name);
    }
    Reading r;
    char ch;
    while (ist >> r)
    {
        if (r.hour < 0 || r.hour > 23)
        {
            error("hour out of range");
        }
        if (r.temperature < min_temp || r.temperature > max_temp)
        {
            error("temperature out of range");
        }
        ch = r.temp_scale;
        switch (ch)
        {
        case cels:
            r.temperature = c_to_f(r.temperature);
            r.temp_scale = fahr;
            break;
        case fahr:
            break;
        default:
            error("illegal temperature scale " + string(1, ch));
        }
        readings.push_back(r);
    }
}

void print_vector(const vector<Reading> &r)
{
    for (int i = 0; i < r.size(); ++i)
    {
        cout << r[i] << endl;
    }
}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);
    try
    {
        vector<Reading> readings;
        for (int i = 0; i < 10; ++i)
        {
            readings.push_back(create_reading(engine));
        }
        write_to_file(readings, "ch10_p04.txt");

        vector<Reading> processed_readings;
        fill_from_file(processed_readings, "ch10_p04.txt");

        sort(processed_readings.begin(), processed_readings.end());
        print_vector(processed_readings);
        auto size = processed_readings.size();
        auto mid = size / 2;
        double median;
        if (size % 2 == 0)
        {
            median = (processed_readings[mid].temperature + processed_readings[mid - 1].temperature) / 2;
        }
        else
        {
            median = processed_readings[mid].temperature;
        }
        double sum = 0;
        for (int i = 0; i < processed_readings.size(); ++i)
        {
            sum += processed_readings[i].temperature;
        }
        double avg = sum / processed_readings.size();

        cout << "median temperature: " << median << " F" << endl;
        cout << "average temperature: " << avg << " F" << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
22 -43.8f
13 16.16f
20 24.5f
5 41.72f
21 59.18f
0 65f
6 70.34f
22 92.4f
8 106.2f
21 207.5f
median temperature: 62.09 F
average temperature: 63.92 F

cat ch10_p04.txt
22 -43.8f
6 21.3c
20 24.5f
8 106.2f
21 15.1c
13 -8.8c
0 65f
21 97.5c
5 5.4c
22 92.4f

ch10_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

const int not_a_reading = -7777;
const int not_a_month = -1;

class Day
{
public:
    vector<double> hour;
    Day();
};

Day::Day() : hour(24)
{
    for (int i = 0; i < hour.size(); ++i) { hour[i] = not_a_reading; }
}

class Month
{
public:
    int month;
    vector<Day> day;
    Month() : month(not_a_month), day(32) { }
};

class Year
{
public:
    int year;
    vector<Month> month;
    Year() : month(12) { }
};

class Reading
{
public:
    int day;
    int hour;
    double temperature;
    Reading() : day(0), hour(0), temperature(0) { }
};

int month_to_int(string s);
bool is_valid(const Reading &r);
void end_of_loop(istream &ist, char term, const string &message);

istream &operator>>(istream &is, Reading &r)
{
    char ch1;
    if (is >> ch1 && ch1 != '(')
    {
        is.unget();
        is.clear(std::ios_base::failbit);
        return is;
    }

    char ch2;
    int d;
    int h;
    double t;
    is >> d >> h >> t >> ch2;
    if (!is || ch2 != ')') { error("bad reading"); }
    r.day = d;
    r.hour = h;
    r.temperature = t;
    return is;
}

istream &operator>>(istream &is, Month &m)
{
    char ch = 0;
    if (is >> ch && ch != '{')
    {
        is.unget();
        is.clear(std::ios_base::failbit);
        return is;
    }

    string month_marker;
    string mm;
    is >> month_marker >> mm;
    if (!is || month_marker != "month") { error("bad start of month"); }
    m.month = month_to_int(mm);

    Reading r;
    int no_of_duplicate_readings = 0;
    int no_invalid_readings = 0;

    while (is >> r)
    {
        if (is_valid(r))
        {
            if (m.day[r.day].hour[r.hour] != not_a_reading)
            {
                ++no_of_duplicate_readings;
            }
            m.day[r.day].hour[r.hour] = r.temperature;
        }
        else
        {
            ++no_invalid_readings;
        }
    }
    end_of_loop(is, '}', "bad end of month");
    return is;
}

const int implausible_min = -200;
const int implausible_max = 200;

bool is_valid(const Reading &r)
{
    if (r.day < 1 || 31 < r.day) { return false; }
    if (r.hour < 0 || 23 < r.hour) { return false; }
    if (r.temperature < implausible_min || implausible_max < r.temperature)
    {
        return false;
    }
    return true;
}

istream &operator>>(istream &is, Year &y)
{
    char ch;
    is >> ch;
    if (ch != '{')
    {
        is.unget();
        is.clear(std::ios::failbit);
        return is;
    }

    string year_marker;
    int yy;
    is >> year_marker >> yy;
    if (!is || year_marker != "year") { error("bad start of year"); }
    y.year = yy;

    while (true)
    {
        Month m;
        if (!(is >> m)) { break; }
        y.month[m.month] = m;
    }

    end_of_loop(is, '}', "bad end of year");
    return is;
}

void end_of_loop(istream &ist, char term, const string &message)
{
    if (ist.fail())
    {
        ist.clear();
        char ch;
        if (ist >> ch && ch == term) { return; }
        error(message);
    }
}

vector<string> month_input_tbl;

void init_input_tbl(vector<string> &tbl)
{
    tbl.push_back("jan");
    tbl.push_back("feb");
    tbl.push_back("mar");
    tbl.push_back("apr");
    tbl.push_back("may");
    tbl.push_back("jun");
    tbl.push_back("jul");
    tbl.push_back("aug");
    tbl.push_back("sep");
    tbl.push_back("oct");
    tbl.push_back("nov");
    tbl.push_back("dec");
}

int month_to_int(string s)
{
    for (int i = 0; i < 12; ++i) { if (month_input_tbl[i] == s) { return i; } }
    return -1;
}

vector<string> month_print_tbl;

void init_print_tbl(vector<string> &tbl)
{
    tbl.push_back("January");
    tbl.push_back("February");
    tbl.push_back("March");
    tbl.push_back("April");
    tbl.push_back("May");
    tbl.push_back("June");
    tbl.push_back("July");
    tbl.push_back("August");
    tbl.push_back("September");
    tbl.push_back("October");
    tbl.push_back("November");
    tbl.push_back("December");
}

string int_to_month(int i)
{
    if (i < 0 || 12 <= i) { error("bad month index"); }
    return month_print_tbl[i];
}

void print_day(ostream &ost, const Day &d, int daynum)
{
    bool is_empty = true;
    for (int i = 0; i < 24; ++i)
    {
        if (d.hour[i] != not_a_reading)
        {
            is_empty = false;
            break;
        }
    }
    if (is_empty) { return; }
    ost << "\n        " << daynum;
    for (int i = 0; i < 24; ++i)
    {
        if (d.hour[i] != not_a_reading)
        {
            ost << "\n            " << i << ":00 - " << d.hour[i] << " F";
        }
    }
}

void print_month(ostream &ost, const Month &m)
{
    if (m.month == not_a_month) { return; }
    ost << "\n    " << int_to_month(m.month);
    for (int i = 1; i < 32; ++i)
    {
        print_day(ost, m.day[i], i);
    }
}

void print_year(ostream &ost, const Year &y)
{
    ost << y.year << ' ';
    for (int i = 0; i < 12; ++i)
    {
        print_month(ost, y.month[i]);
    }
}

int main()
{
    try
    {
        init_print_tbl(month_print_tbl);
        init_input_tbl(month_input_tbl);

        cout << "Please enter input file name\n";
        string name;
        cin >> name;
        ifstream ifs(name.c_str());
        if (!ifs) { error("can't open input file " + name); }

        ifs.exceptions(ifs.exceptions() | std::ios_base::badbit);

        cout << "Please enter output file name\n";
        cin >> name;
        ofstream ofs(name.c_str());
        if (!ofs) { error("can't open output file " + name); }

        vector<Year> ys;
        while (true)
        {
            Year y;
            if (!(ifs >> y)) { break; }
            ys.push_back(y);
        }
        cout << "read " << ys.size() << " years of readings\n";

        for (int i = 0; i < ys.size(); ++i)
        {
            print_year(ofs, ys[i]);
            ofs  << endl;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Please enter input file name
ch10_p05.txt
Please enter output file name
ch10_p05_out.txt
read 4 years of readings

{ year 1990 }
{ year 1991 { month jun } }
{ year 1992 { month jan (1 0 61.5) } { month feb (1 1 64) (2 2 65.2) } }
{ year 2000 { month feb (1 1 68) (2 3 66.66) (1 0 67.2) } { month dec (15 15 -9.2) (15 14 -8.8) (14 0 -2) } }

1990
1991
    June
1992
    January
        1
            0:00 - 61.5 F
    February
        1
            1:00 - 64 F
        2
            2:00 - 65.2 F
2000
    February
        1
            0:00 - 67.2 F
            1:00 - 68 F
        2
            3:00 - 66.66 F
    December
        14
            0:00 - -2 F
        15
            14:00 - -8.8 F
            15:00 - -9.2 F

ch10_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

class Roman_int
{
public:
    Roman_int();
    Roman_int(int n);
    int as_int() const;
    void set_val(int v);
private:
    int val;
};

// N = 0 I = 1 V = 5 X= 10 L= 50 C = 100 D = 500 M = 1000
const char N = 'N';
const char I = 'I';
const char V = 'V';
const char X = 'X';
const char L = 'L';
const char C = 'C';
const char D = 'D';
const char M = 'M';

bool is_valid_char(char ch);
int get_value(char ch);
bool counter_illegal(int counter, char ch);
int roman_int_to_int(const string &s);


Roman_int::Roman_int() : val(0) { }

Roman_int::Roman_int(int n) : val(n) { }

int Roman_int::as_int() const
{
    return val;
}

void Roman_int::set_val(int v)
{
    val = v;
}

Roman_int operator+(const Roman_int &r1, const Roman_int &r2)
{
    return Roman_int(r1.as_int() + r2.as_int());
}

Roman_int operator-(const Roman_int &r1, const Roman_int &r2)
{
    return Roman_int(r1.as_int() - r2.as_int());
}

Roman_int operator-(const Roman_int &r)
{
    return Roman_int(-r.as_int());
}

Roman_int operator*(const Roman_int &r1, const Roman_int &r2)
{
    return Roman_int(r1.as_int() * r2.as_int());
}

Roman_int operator/(const Roman_int &r1, const Roman_int &r2)
{
    if (r2.as_int() == 0)
    {
        error("division / by zero");
    }
    return Roman_int(r1.as_int() / r2.as_int());
}

Roman_int operator%(const Roman_int &r1, const Roman_int &r2)
{
    if (r2.as_int() == 0)
    {
        error("division % by zero");
    }
    return Roman_int(r1.as_int() % r2.as_int());
}

bool operator==(const Roman_int &r1, const Roman_int &r2)
{
    return r1.as_int() == r2.as_int();
}

bool operator!=(const Roman_int &r1, const Roman_int &r2)
{
    return !(r1 == r2);
}

bool operator<(const Roman_int &r1, const Roman_int &r2)
{
    return r1.as_int() < r2.as_int();
}

bool operator>(const Roman_int &r1, const Roman_int &r2)
{
    return r2 < r1;
}

bool operator<=(const Roman_int &r1, const Roman_int &r2)
{
    return !(r2 < r1);
}

bool operator>=(const Roman_int &r1, const Roman_int &r2)
{
    return !(r1 < r2);
}

bool is_valid_char(char ch)
{
    return ch == N || ch == I || ch == V || ch == X || ch == L || ch == C || ch == D || ch == M;
}

ostream &operator<<(ostream &os, const Roman_int &r)
{
    int val = r.as_int();
    if (val == 0)
    {
        return os << N;
    }
    if (val < 0)
    {
        os << '-';
        val = -val;
    }

    while (val >= 1000)
    {
        os << M;
        val -= 1000;
    }
    if (val >= 900)
    {
        os << C << M;
        val -= 900;
    }
    else if (val >= 500)
    {
        os << D;
        val -= 500;
    }
    else if (val >= 400)
    {
        os << C << D;
        val -= 400;
    }
    while (val >= 100)
    {
        os << C;
        val -= 100;
    }
    if (val >= 90)
    {
        os << X << C;
        val -= 90;
    }
    else if (val >= 50)
    {
        os << L;
        val -= 50;
    }
    else if (val >= 40)
    {
        os << X << L;
        val -= 40;
    }
    while (val >= 10)
    {
        os << X;
        val -= 10;
    }
    if (val == 9)
    {
        os << I << X;
        val -= 9;
    }
    else if (val >= 5)
    {
        os << V;
        val -= 5;
    }
    else if (val == 4)
    {
        os << I << V;
        val -= 4;
    }
    while (val >= 1)
    {
        os << I;
        --val;
    }
    return os;
}

int get_value(char ch)
{
    switch (ch)
    {
    case N:
        return 0;
    case I:
        return 1;
    case V:
        return 5;
    case X:
        return 10;
    case L:
        return 50;
    case C:
        return 100;
    case D:
        return 500;
    case M:
        return 1000;
    default:
        error("illegal letter used: " + string(1, ch));
    }
}

bool counter_illegal(int counter, char ch)
{
    switch (ch)
    {
    case N:
    case V:
    case L:
    case D:
        return counter > 1;
    case I:
    case X:
    case C:
    case M:
        return counter > 3;
    default:
        error("counter_illegal: invalid character " + string(1, ch));
    }
}

int roman_int_to_int(const string &s)
{
    if (s.size() == 0)
    {
        error("roman_to_int: empty string");
    }
    if (s.size() == 1)
    {
        return get_value(s[0]);
    }

    int counter = 1;
    int val = get_value(s[s.size() - 1]);

    for (int i = s.size() - 2; i >= 0; --i)
    {
        if (s[i] == s[i + 1])
        {
            ++counter;
            if (counter_illegal(counter, s[i]))
            {
                error("illegal repetition of letter: " + string(1, s[i]));
            }
        }
        else
        {
            counter = 1;
        }

        if (get_value(s[i]) < get_value(s[i + 1]))
        {
            if ((s[i] == I || s[i] == X || s[i] == C) && get_value(s[i + 1]) <= 10 * get_value(s[i]))
            {
                val -= get_value(s[i]);
            }
            else
            {
                error("illegal use of " + string(1, s[i]));
            }
        }
        else
        {
            val += get_value(s[i]);
        }
    }
    return val;
}

istream &operator>>(istream &is, Roman_int &r)
{
    is.exceptions(is.exceptions() | std::ios_base::badbit);

    string s;
    char ch;

    while (is.get(ch))
    {
        if (is_valid_char(ch))
        {
            s += ch;
        }
        else
        {
            is.putback(ch);
            break;
        }
    }

    int val = roman_int_to_int(s);
    r.set_val(val);
    return is;
}

void test_output()
{
    cout << Roman_int(0) << " equals " << Roman_int(0).as_int() << endl;
    cout << Roman_int(1) << " equals " << Roman_int(1).as_int() << endl;
    cout << Roman_int(4) << " equals " << Roman_int(4).as_int() << endl;
    cout << Roman_int(5) << " equals " << Roman_int(5).as_int() << endl;
    cout << Roman_int(8) << " equals " << Roman_int(8).as_int() << endl;
    cout << Roman_int(9) << " equals " << Roman_int(9).as_int() << endl;
    cout << Roman_int(10) << " equals " << Roman_int(10).as_int() << endl;
    cout << Roman_int(48) << " equals " << Roman_int(48).as_int() << endl;
    cout << Roman_int(81) << " equals " << Roman_int(81).as_int() << endl;
    cout << Roman_int(99) << " equals " << Roman_int(99).as_int() << endl;
    cout << Roman_int(105) << " equals " << Roman_int(105).as_int() << endl;
    cout << Roman_int(2014) << " equals " << Roman_int(2014).as_int() << endl;
    cout << Roman_int(-2014) << " equals " << Roman_int(-2014).as_int() << endl;
    cout << Roman_int(1499) << " equals " << Roman_int(1499).as_int() << endl << endl;
    cout << Roman_int(1) << " + " << Roman_int(3) << " = " << Roman_int(1) + Roman_int(3) << endl;
    cout << Roman_int(15) << " * " << Roman_int(37) << " = " << Roman_int(15)*Roman_int(37) << endl;
    cout << Roman_int(105) << " - " << Roman_int(207) << " = " << Roman_int(105) - Roman_int(207) << endl;
    cout << -Roman_int(7) << " * " << Roman_int(5) << " = " << -Roman_int(7)*Roman_int(5) << endl;
    cout << Roman_int(15) << " / " << Roman_int(5) << " = " << Roman_int(15) / Roman_int(5) << endl;
}


int main()
{
    try
    {
        test_output();
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
N equals 0
I equals 1
IV equals 4
V equals 5
VIII equals 8
IX equals 9
X equals 10
XLVIII equals 48
LXXXI equals 81
XCIX equals 99
CV equals 105
MMXIV equals 2014
-MMXIV equals -2014
MCDXCIX equals 1499

I + III = IV
XV * XXXVII = DLV
CV - CCVII = -CII
-VII * V = -XXXV
XV / V = III

ch10_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

class Roman_int
{
public:
    Roman_int();
    Roman_int(int n);
    int as_int() const;
    void set_val(int v);
private:
    int val;
};

// N = 0 I = 1 V = 5 X= 10 L= 50 C = 100 D = 500 M = 1000
const char N = 'N';
const char I = 'I';
const char V = 'V';
const char X = 'X';
const char L = 'L';
const char C = 'C';
const char D = 'D';
const char M = 'M';

bool is_valid_char(char ch);
int get_value(char ch);
bool counter_illegal(int counter, char ch);
int roman_int_to_int(const string &s);


Roman_int::Roman_int() : val(0) { }

Roman_int::Roman_int(int n) : val(n) { }

int Roman_int::as_int() const
{
    return val;
}

void Roman_int::set_val(int v)
{
    val = v;
}

Roman_int operator+(const Roman_int &r1, const Roman_int &r2)
{
    return Roman_int(r1.as_int() + r2.as_int());
}

Roman_int operator-(const Roman_int &r1, const Roman_int &r2)
{
    return Roman_int(r1.as_int() - r2.as_int());
}

Roman_int operator-(const Roman_int &r)
{
    return Roman_int(-r.as_int());
}

Roman_int operator*(const Roman_int &r1, const Roman_int &r2)
{
    return Roman_int(r1.as_int() * r2.as_int());
}

Roman_int operator/(const Roman_int &r1, const Roman_int &r2)
{
    if (r2.as_int() == 0)
    {
        error("division / by zero");
    }
    return Roman_int(r1.as_int() / r2.as_int());
}

Roman_int operator%(const Roman_int &r1, const Roman_int &r2)
{
    if (r2.as_int() == 0)
    {
        error("division % by zero");
    }
    return Roman_int(r1.as_int() % r2.as_int());
}

bool operator==(const Roman_int &r1, const Roman_int &r2)
{
    return r1.as_int() == r2.as_int();
}

bool operator!=(const Roman_int &r1, const Roman_int &r2)
{
    return !(r1 == r2);
}

bool operator<(const Roman_int &r1, const Roman_int &r2)
{
    return r1.as_int() < r2.as_int();
}

bool operator>(const Roman_int &r1, const Roman_int &r2)
{
    return r2 < r1;
}

bool operator<=(const Roman_int &r1, const Roman_int &r2)
{
    return !(r2 < r1);
}

bool operator>=(const Roman_int &r1, const Roman_int &r2)
{
    return !(r1 < r2);
}

bool is_valid_char(char ch)
{
    return ch == N || ch == I || ch == V || ch == X || ch == L || ch == C || ch == D || ch == M;
}

ostream &operator<<(ostream &os, const Roman_int &r)
{
    int val = r.as_int();
    if (val == 0)
    {
        return os << N;
    }
    if (val < 0)
    {
        os << '-';
        val = -val;
    }

    while (val >= 1000)
    {
        os << M;
        val -= 1000;
    }
    if (val >= 900)
    {
        os << C << M;
        val -= 900;
    }
    else if (val >= 500)
    {
        os << D;
        val -= 500;
    }
    else if (val >= 400)
    {
        os << C << D;
        val -= 400;
    }
    while (val >= 100)
    {
        os << C;
        val -= 100;
    }
    if (val >= 90)
    {
        os << X << C;
        val -= 90;
    }
    else if (val >= 50)
    {
        os << L;
        val -= 50;
    }
    else if (val >= 40)
    {
        os << X << L;
        val -= 40;
    }
    while (val >= 10)
    {
        os << X;
        val -= 10;
    }
    if (val == 9)
    {
        os << I << X;
        val -= 9;
    }
    else if (val >= 5)
    {
        os << V;
        val -= 5;
    }
    else if (val == 4)
    {
        os << I << V;
        val -= 4;
    }
    while (val >= 1)
    {
        os << I;
        --val;
    }
    return os;
}

int get_value(char ch)
{
    switch (ch)
    {
    case N:
        return 0;
    case I:
        return 1;
    case V:
        return 5;
    case X:
        return 10;
    case L:
        return 50;
    case C:
        return 100;
    case D:
        return 500;
    case M:
        return 1000;
    default:
        error("illegal letter used: " + string(1, ch));
    }
}

bool counter_illegal(int counter, char ch)
{
    switch (ch)
    {
    case N:
    case V:
    case L:
    case D:
        return counter > 1;
    case I:
    case X:
    case C:
    case M:
        return counter > 3;
    default:
        error("counter_illegal: invalid character " + string(1, ch));
    }
}

int roman_int_to_int(const string &s)
{
    if (s.size() == 0)
    {
        error("roman_to_int: empty string");
    }
    if (s.size() == 1)
    {
        return get_value(s[0]);
    }

    int counter = 1;
    int val = get_value(s[s.size() - 1]);

    for (int i = s.size() - 2; i >= 0; --i)
    {
        if (s[i] == s[i + 1])
        {
            ++counter;
            if (counter_illegal(counter, s[i]))
            {
                error("illegal repetition of letter: " + string(1, s[i]));
            }
        }
        else
        {
            counter = 1;
        }

        if (get_value(s[i]) < get_value(s[i + 1]))
        {
            if ((s[i] == I || s[i] == X || s[i] == C) && get_value(s[i + 1]) <= 10 * get_value(s[i]))
            {
                val -= get_value(s[i]);
            }
            else
            {
                error("illegal use of " + string(1, s[i]));
            }
        }
        else
        {
            val += get_value(s[i]);
        }
    }
    return val;
}

istream &operator>>(istream &is, Roman_int &r)
{
    is.exceptions(is.exceptions() | std::ios_base::badbit);

    string s;
    char ch;

    while (is.get(ch))
    {
        if (is_valid_char(ch))
        {
            s += ch;
        }
        else
        {
            is.putback(ch);
            break;
        }
    }

    int val = roman_int_to_int(s);
    r.set_val(val);
    return is;
}

const char let = 'L';
const char con = 'C';
const char quit = 'q';
const char help = 'h';
const char print = ';';
const char number = '8';
const char name = 'a';
const string declkey = "let";
const string conkey = "const";
const string quitkey = "quit";
const string helpkey = "help";
const string prompt = "> ";
const string result = "= ";

class Token
{
public:
    char kind;
    Roman_int value;
    string name;
    Token(char ch) : kind(ch), value(0) { }
    Token(char ch, const Roman_int & val) : kind(ch), value(val) { }
    Token(char ch, const string & n) : kind(ch), value(0), name(n) { }
};

class Token_stream
{
public:
    Token_stream();
    Token_stream(istream &is);
    Token get();
    void putback(const Token &t);
    void ignore(char c);
    istream & get_istream();
private:
    bool full;
    Token buffer;
    istream *is_ptr;
};

Token_stream::Token_stream() : full(false), buffer(0), is_ptr(&cin) { }
Token_stream::Token_stream(istream &is) : full(false), buffer(0), is_ptr(&is) { }
istream &  Token_stream::get_istream()
{
    return (*is_ptr);
}

void Token_stream::putback(const Token &t)
{
    if (full)
    {
        error("putback() into a full buffer");
    }
    buffer = t;
    full = true;
}

Token Token_stream::get()
{
    if (full)
    {
        full = false;
        return buffer;
    }

    char ch;
    (*is_ptr).get(ch);
    while (isspace(ch))
    {
        if (ch == '\n')
        {
            return Token(print);
        }
        (*is_ptr).get(ch);
    }

    switch (ch)
    {
    case print:
    case '{':
    case '}':
    case '(':
    case ')':
    case '+':
    case '-':
    case '*':
    case '/':
    case '%':
    case '=':
        return Token(ch);
    case N: case I: case V: case X:
    case L: case C: case D: case M:
    {
        (*is_ptr).putback(ch);
        Roman_int val;
        (*is_ptr) >> val;
        return Token(number, val);
    }
    default:
        if (isalpha(ch))
        {
            string s;
            s += ch;
            while ((*is_ptr).get(ch) && (isalpha(ch) || isdigit(ch) || ch == '_'))
            {
                s += ch;
            }
            (*is_ptr).putback(ch);
            if (s == declkey)
            {
                return Token(let);
            }
            if (s == conkey)
            {
                return Token(con);
            }
            if (s == helpkey)
            {
                return Token(help);
            }
            if (s == quitkey)
            {
                return Token(quit);
            }
            return Token(name, s);
        }
        error("Bad token");
    }
}

void Token_stream::ignore(char c)
{
    if (full && c == buffer.kind)
    {
        full = false;
        return;
    }
    full = false;

    char ch = 0;
    while ((*is_ptr) >> ch)
    {
        if (ch == c)
        {
            return;
        }
    }
}

class Variable
{
public:
    string name;
    Roman_int value;
    bool is_const;
    Variable(const string &n, const Roman_int &v, bool b) : name(n), value(v), is_const(b) { }
};

class Symbol_table
{
public:
    Roman_int get(const string &s);
    void set(const string & s, const Roman_int & d);
    bool is_declared(const string & var);
    Roman_int declare(const string & var, const Roman_int & val, bool b);
private:
    vector<Variable> var_table;
};

Roman_int Symbol_table::get(const string &s)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            return var_table[i].value;
        }
    }
    error("get: undefined variable " + s);
}

void Symbol_table::set(const string & s, const Roman_int & d)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            if (var_table[i].is_const)
            {
                error(s + " is a constant");
            }
            var_table[i].value = d;
            return;
        }
    }
    error("set: undefined variable " + s);
}

bool Symbol_table::is_declared(const string & var)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == var)
        {
            return true;
        }
    }
    return false;
}

Roman_int Symbol_table::declare(const string & var, const Roman_int & val, bool b)
{
    if (is_declared(var))
    {
        error(var + " declared twice");
    }
    var_table.push_back(Variable(var, val, b));
    return Roman_int(val);
}

Token_stream ts;
Symbol_table st;
Roman_int expression();

Roman_int primary()
{
    Token t = ts.get();
    Roman_int d(0);
    switch (t.kind)
    {
    case '(':
        d = expression();
        t = ts.get();
        if (t.kind != ')')
        {
            error("')' expected");
        }
        break;
    case '{':
        d = expression();
        t = ts.get();
        if (t.kind != '}')
        {
            error("'}' expected");
        }
        break;
    case number:
        d = t.value;
        break;
    case '-':
        d = -primary();
        break;
    case '+':
        d = primary();
        break;
    case name:
    {
        Token t2 = ts.get();
        if (t2.kind == '=')
        {
            d = expression();
            st.set(t.name, d);
        }
        else
        {
            ts.putback(t2);
            d = st.get(t.name);
        }
    }
    break;
    default:
        error("primary expected");
    }

    return d;
}

Roman_int term()
{
    Roman_int left = primary();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '*':
            left = left * primary();
            t = ts.get();
            break;
        case '/':
        {
            Roman_int d = primary();
            if (d == Roman_int(0))
            {
                error("divide by zero");
            }
            left = left / d;
            t = ts.get();
            break;
        }
        case '%':
        {
            Roman_int d = primary();
            if (d == Roman_int(0))
            {
                error("%: divide by zero");
            }
            left = left % d;
            t = ts.get();
            break;
        }
        default:
            ts.putback(t);
            return left;
        }
    }
}

Roman_int expression()
{
    Roman_int left = term();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '+':
           left = left + term();
            t = ts.get();
            break;
        case '-':
            left = left - term();
            t = ts.get();
            break;
        default:
            ts.putback(t);
            return left;
        }
    }
}

Roman_int declaration(bool b)
{
    Token t = ts.get();
    if (t.kind != name)
    {
        error ("name expected in declaration");
    }
    string var_name = t.name;

    Token t2 = ts.get();
    if (t2.kind != '=')
    {
        error("= missing in declaration of " + var_name);
    }

    Roman_int d = expression();
    st.declare(var_name, d, b);
    return d;
}

Roman_int statement()
{
    Token t = ts.get();
    switch(t.kind)
    {
    case let:
        return declaration(false);
    case con:
        return declaration(true);
    default:
        ts.putback(t);
        return expression();
    }
}

void clean_up_mess()
{
    ts.ignore(print);
}

void print_help()
{
    cout << "Instructions: enter expressions, you can declare variables using\n";
    cout << "the 'let' keyword and constants with the 'const' keyword.\n";
}

void calculate()
{
    while (ts.get_istream())
    {
        try
        {
            cout << prompt;
            Token t = ts.get();
            while (t.kind == print)
            {
                t = ts.get();
            }
            if (t.kind == help)
            {
                print_help();
            }
            else if (t.kind == quit)
            {
                return;
            }
            else
            {
                ts.putback(t);
                cout << result << statement() << endl;
            }
        }
        catch(exception &e)
        {
            cerr << e.what() << endl;
            clean_up_mess();
        }
    }
}

int main()
{
    try
    {
        cout << "Welcome to our simple calculator.\n";
        cout << "Enter '" << helpkey << "' to get the help info; enter '" << quitkey << "' to quit.\n";

        calculate();
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Welcome to our simple calculator.
Enter 'help' to get the help info; enter 'quit' to quit.
> V+VII
= XII
> V-VII
= -II
> V*VII
= XXXV
> V/VII
= N
> XXXV/VII
= V
> quit

ch10_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}


int main()
{
    try
    {
        string s1;
        string s2;
        string s3;
        cout << "Enter first file name: ";
        cin >> s1;
        cout << "Enter second file name: ";
        cin >> s2;
        cout << "Enter output file name: ";
        cin >> s3;

        ifstream ifs1(s1.c_str());
        if (!ifs1) { error("can't open input file " + s1); }
        ifstream ifs2(s2.c_str());
        if (!ifs2) { error("can't open input file " + s2); }
        ofstream ofs(s3.c_str());
        if (!ofs) { error("can't open output file " + s3); }

        char ch;
        while (ifs1.get(ch)) { ofs << ch; }
        while (ifs2.get(ch)) { ofs << ch; }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter first file name: ch10_p07.cpp
Enter second file name: ch10_p08.cpp
Enter output file name: ch10_p08.txt

ls -l ch10_p07.cpp ch10_p08.*
-rw-r--r-- 1 weiyayun weiyayun 16604 Nov 30 12:06 ch10_p07.cpp
-rw-r--r-- 1 weiyayun weiyayun  2769 Nov 30 12:18 ch10_p08.cpp
-rw-r--r-- 1 weiyayun weiyayun 19373 Nov 30 12:18 ch10_p08.txt

ch10_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}


int main()
{
    try
    {
        string s1;
        string s2;
        string s3;
        cout << "Enter first file name: ";
        cin >> s1;
        cout << "Enter second file name: ";
        cin >> s2;
        cout << "Enter output file name: ";
        cin >> s3;

        ifstream ifs1(s1.c_str());
        if (!ifs1) { error("can't open input file " + s1); }
        ifstream ifs2(s2.c_str());
        if (!ifs2) { error("can't open input file " + s2); }
        ofstream ofs(s3.c_str());
        if (!ofs) { error("can't open output file " + s3); }

        string sf1;
        string sf2;
        ifs1 >> sf1;
        ifs2 >> sf2;
        if (sf1 == "" || sf2 == "") { error("at least one input file is empty"); }

        while (true)
        {
            if (sf1 <= sf2)
            {
                ofs << sf1 << endl;
                if ( !(ifs1 >> sf1) ) { break; }
            }
            else
            {
                ofs << sf2 << endl;
                if ( !(ifs2 >> sf2) ) { break; }
            }
        }

        if (ifs1.eof())
        {
            ofs << sf2 << endl;
            while (ifs2 >> sf2) { ofs << sf2 << endl; }
        }
        else
        {
            ofs << sf1 << endl;
            while (ifs1 >> sf1) { ofs << sf1 << endl; }
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter first file name: ch10_p09a.txt
Enter second file name: ch10_p09b.txt
Enter output file name: ch10_p09_out.txt

ls -l ch10_p09*.txt
-rw-r--r-- 1 weiyayun weiyayun 16 Nov 30 12:30 ch10_p09a.txt
-rw-r--r-- 1 weiyayun weiyayun 10 Nov 30 12:30 ch10_p09b.txt
-rw-r--r-- 1 weiyayun weiyayun 26 Nov 30 12:32 ch10_p09_out.txt

cat ch10_p09a.txt
1
2
3
8
9
e
f
g

cat ch10_p09b.txt
5
6
l
m
n

cat ch10_p09_out.txt
1
2
3
5
6
8
9
e
f
g
l
m
n

ch10_p10.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

const char let = 'L';
const char con = 'C';
const char quit = 'q';
const char help = 'h';
const char print = ';';
const char number = '8';
const char name = 'a';
const char square_root = 's';
const char power = 'p';
const string declkey = "let";
const string conkey = "const";
const string sqrtkey = "sqrt";
const string powkey = "pow";
const string quitkey = "quit";
const string helpkey = "help";
const string prompt = "> ";
const string result = "= ";

class Token
{
public:
    char kind;
    double value;
    string name;
    Token(char ch) : kind(ch), value(0) { }
    Token(char ch, double val) : kind(ch), value(val) { }
    Token(char ch, string n) : kind(ch), value(0), name(n) { }
};

class Token_stream
{
public:
    Token_stream();
    Token_stream(istream &is);
    Token_stream(istream &is, ostream &os);
    Token get();
    void putback(Token t);
    void ignore(char c);
    istream & get_istream();
    void set_istream(istream &is);
    ostream & get_ostream();
    void set_ostream(ostream &os);
private:
    bool full;
    Token buffer;
    istream *is_ptr;
    ostream *os_ptr;
};

Token_stream::Token_stream() : full(false), buffer(0), is_ptr(&cin), os_ptr(&cout) { }
Token_stream::Token_stream(istream &is) : full(false), buffer(0), is_ptr(&is), os_ptr(&cout) { }
Token_stream::Token_stream(istream &is, ostream &os) : full(false), buffer(0), is_ptr(&is), os_ptr(&os) { }
istream &  Token_stream::get_istream()
{
    return (*is_ptr);
}
void   Token_stream::set_istream(istream &is)
{
    is_ptr = &is;
}
ostream &  Token_stream::get_ostream()
{
    return (*os_ptr);
}
void   Token_stream::set_ostream(ostream &os)
{
    os_ptr = &os;
}
void Token_stream::putback(Token t)
{
    if (full)
    {
        error("putback() into a full buffer");
    }
    buffer = t;
    full = true;
}

Token Token_stream::get()
{
    if (full)
    {
        full = false;
        return buffer;
    }

    char ch;
    (*is_ptr).get(ch);
    while (isspace(ch))
    {
        if (ch == '\n')
        {
            return Token(print);
        }
        (*is_ptr).get(ch);
    }

    switch (ch)
    {
    case print:
    case '!':
    case '{':
    case '}':
    case '(':
    case ')':
    case '+':
    case '-':
    case '*':
    case '/':
    case '%':
    case '=':
    case ',':
        return Token(ch);
    case '.':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    {
        (*is_ptr).putback(ch);
        double val;
        (*is_ptr) >> val;
        return Token(number, val);
    }
    default:
        if (isalpha(ch))
        {
            string s;
            s += ch;
            while ((*is_ptr).get(ch) && (isalpha(ch) || isdigit(ch) || ch == '_'))
            {
                s += ch;
            }
            (*is_ptr).putback(ch);
            if (s == declkey)
            {
                return Token(let);
            }
            if (s == conkey)
            {
                return Token(con);
            }
            if (s == sqrtkey)
            {
                return Token(square_root);
            }
            if (s == powkey)
            {
                return Token(power);
            }
            if (s == helpkey)
            {
                return Token(help);
            }
            if (s == quitkey)
            {
                return Token(quit);
            }
            return Token(name, s);
        }
        error("Bad token");
    }
}

void Token_stream::ignore(char c)
{
    if (full && c == buffer.kind)
    {
        full = false;
        return;
    }
    full = false;

    char ch = 0;
    while ((*is_ptr) >> ch)
    {
        if (ch == c)
        {
            return;
        }
    }
}

class Variable
{
public:
    string name;
    double value;
    bool is_const;
    Variable(string n, double v, bool b) : name(n), value(v), is_const(b) { }
};

class Symbol_table
{
public:
    double get(string s);
    void set(string s, double d);
    bool is_declared(string var);
    double declare(string var, double val, bool b);
private:
    vector<Variable> var_table;
};

double Symbol_table::get(string s)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            return var_table[i].value;
        }
    }
    error("get: undefined variable " + s);
}

void Symbol_table::set(string s, double d)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            if (var_table[i].is_const)
            {
                error(s + " is a constant");
            }
            var_table[i].value = d;
            return;
        }
    }
    error("set: undefined variable " + s);
}

bool Symbol_table::is_declared(string var)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == var)
        {
            return true;
        }
    }
    return false;
}

double Symbol_table::declare(string var, double val, bool b)
{
    if (is_declared(var))
    {
        error(var + " declared twice");
    }
    var_table.push_back(Variable(var, val, b));
    return val;
}

Token_stream ts;
Symbol_table st;
double expression();

double factorial(double d)
{
    int p = d;
    if (double(p) != d)
    {
        error("factorial not defined for non-integers");
    }
    if (p < 0)
    {
        error("factorial not defined for negative values");
    }
    else if (p == 0)
    {
        return 1;
    }
    else
    {
        double res = p;
        for (int i = p - 1; i > 0; --i)
        {
            res *= i;
            if (res > 1.0e+16)
            {
                error("factorial too large");
            }
        }
        return res;
    }
}

double my_pow(double base, int expo)
{
    if (expo < 0)
    {
        error("my_pow not defined for negative expo");
    }
    if (expo == 0)
    {
        if (base == 0)
        {
            return 0;
        }
        return 1;
    }
    double res = base;
    for (int i = 2; i <= expo; ++i)
    {
        res *= base;
    }
    return res;
}

double primary()
{
    Token t = ts.get();
    double d = 0;
    switch (t.kind)
    {
    case '(':
        d = expression();
        t = ts.get();
        if (t.kind != ')')
        {
            error("')' expected");
        }
        break;
    case '{':
        d = expression();
        t = ts.get();
        if (t.kind != '}')
        {
            error("'}' expected");
        }
        break;
    case number:
        d = t.value;
        break;
    case '-':
        d = -primary();
        break;
    case '+':
        d = primary();
        break;
    case name:
    {
        Token t2 = ts.get();
        if (t2.kind == '=')
        {
            d = expression();
            st.set(t.name, d);
        }
        else
        {
            ts.putback(t2);
            d = st.get(t.name);
        }
    }
    break;
    case square_root:
    {
        Token t2 = ts.get();
        if (t2.kind != '(')
        {
            error("'(' expected");
        }
        double d2 = expression();
        if (d2 < 0)
        {
            error("Square roots of negative numbers... nope!");
        }
        t2 = ts.get();
        if (t2.kind != ')')
        {
            error("')' expected");
        }
        d = sqrt(d2);
    }
    break;
    case power:
    {
        Token t2 = ts.get();
        if (t2.kind != '(')
        {
            error("'(' expected");
        }
        double d2 = expression();
        t2 = ts.get();
        if (t2.kind != ',')
        {
            error("',' expected");
        }
        t2 = ts.get();
        if (t2.kind != number)
        {
            error("second argument of 'pow' is not a number");
        }
        int i2 = int(t2.value);
        if (i2 != t2.value)
        {
            error("second argument of 'pow' is not an integer");
        }
        t2 = ts.get();
        if (t2.kind != ')')
        {
            error("')' expected");
        }
        d = my_pow(d2, i2);
    }
    break;
    default:
        error("primary expected");
    }

    t = ts.get();
    if (t.kind != '!')
    {
        ts.putback(t);
        return d;
    }
    return factorial(d);
}

double term()
{
    double left = primary();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '*':
            left *= primary();
            t = ts.get();
            break;
        case '/':
        {
            double d = primary();
            if (d == 0)
            {
                error("divide by zero");
            }
            left /= d;
            t = ts.get();
            break;
        }
        case '%':
        {
            double d = primary();
            int i1 = int(left);
            if (i1 != left)
            {
                error("left-hand operand of % not int");
            }
            int i2 = int(d);
            if (i2 != d)
            {
                error("right-hand operand of % not int");
            }
            if (i2 == 0)
            {
                error("%: divide by zero");
            }
            left = i1 % i2;
            t = ts.get();
            break;
        }
        default:
            ts.putback(t);
            return left;
        }
    }
}

double expression()
{
    double left = term();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '+':
            left += term();
            t = ts.get();
            break;
        case '-':
            left -= term();
            t = ts.get();
            break;
        case '=':
            error("use of '=' outside of a declaration");
        default:
            ts.putback(t);
            return left;
        }
    }
}

double declaration(bool b)
{
    Token t = ts.get();
    if (t.kind != name)
    {
        error ("name expected in declaration");
    }
    string var_name = t.name;

    Token t2 = ts.get();
    if (t2.kind != '=')
    {
        error("= missing in declaration of " + var_name);
    }

    double d = expression();
    st.declare(var_name, d, b);
    return d;
}

double statement()
{
    Token t = ts.get();
    switch(t.kind)
    {
    case let:
        return declaration(false);
    case con:
        return declaration(true);
    default:
        ts.putback(t);
        return expression();
    }
}

void clean_up_mess()
{
    ts.ignore(print);
}

void print_help()
{
    cout << "Instructions: enter expressions, there are\n";
    cout << "a few functions, you can declare variables using\n";
    cout << "the 'let' keyword and constants with the 'const'\n";
    cout << "keyword.\n";
}

void calculate()
{
    while (ts.get_istream())
    {
        try
        {
            Token t = ts.get();
            while (t.kind == print)
            {
                t = ts.get();
            }
            if (t.kind == help)
            {
                print_help();
            }
            else if (t.kind == quit)
            {
                return;
            }
            else
            {
                ts.putback(t);
                ostream & file_out = ts.get_ostream();
                file_out << result << statement() << endl;
            }
        }
        catch(exception &e)
        {
            cerr << e.what() << endl;
            clean_up_mess();
        }
    }
}

int main()
{
    try
    {
        st.declare("pi", 3.1415926535, true);
        st.declare("e", 2.7182818284, true);
        st.declare("k", 1000, true);

        string s1, s2;
        cout << "Enter input file name: ";
        cin >> s1;
        cout << "Enter output file name: ";
        cin >> s2;

        ifstream ifs(s1.c_str());
        if (!ifs) { error("can't open input file " + s1); }
        ofstream ofs(s2.c_str());
        if (!ofs) { error("can't open output file " + s2); }
        ts.set_istream(ifs);
        ts.set_ostream(ofs);

        calculate();
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
cat ch10_p10_in.txt
7*8!
sqrt(2+6.7)
pow(2.5,3)
let x = 3.4
let y = 2
let z = (x+y*2)/pi
2+3*z
quit

ch10_p10
Enter input file name: ch10_p10_in.txt
Enter output file name: ch10_p10_out.txt

cat ch10_p10_out.txt
= 282240
= 2.94958
= 15.625
= 3.4
= 2
= 2.35549
= 9.06648

ch10_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        string ifname;
        cout << "Enter input file name: ";
        cin >> ifname;
        ifstream ifs(ifname.c_str());
        if (!ifs) { error("can't open input file " + ifname); }

        int count = 0;
        int sum = 0;
        char ch = 0;
        int i = 0;
        string s;
        while (ifs >> ch)
        {
            if (isdigit(ch))
            {
                ifs.unget();
                if (ifs >> i)
                {
                    ++count;
                    sum += i;
                    cout << i << endl;
                }
                else { error("can't read integer"); }
            }
            else
            {
                ifs.unget();
                ifs >> s;
            }
        }
        cout << "Sum of " << count << " whitespace-separated integers in file: " << sum << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch10_p11_in.txt
123
789
456
Sum of 3 whitespace-separated integers in file: 1368

cat ch10_p11_in.txt
123abc   hello 789world 456 efg

ch10_p12.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}


int main()
{
    try
    {
        string ifname;
        cout << "Enter input file name: ";
        cin >> ifname;
        ifstream ifs(ifname.c_str());
        if (!ifs) { error("can't open input file " + ifname); }
        string word;
        cout << "Enter word to look for: ";
        cin >> word;

        int counter = 0;
        string current_line;
        while (getline(ifs, current_line, '\n'))
        {
            ++counter;
            for (int i = 0; i < current_line.size(); ++i)
            {
                if (current_line[i] == word[0] && current_line.size() > i + word.size() - 1)
                {
                    bool identical = true;
                    for (int j = 1; j < word.size(); ++j)
                    {
                        if (word[j] != current_line[i + j])
                        {
                            identical = false;
                        }
                    }
                    if (identical)
                    {
                        cout << counter << ": " << current_line << endl;
                        break;
                    }
                }
            }
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch10_p12.cpp
Enter word to look for: cout
25: using std::cout;
99:         cout << "Enter input file name: ";
104:         cout << "Enter word to look for: ";
126:                         cout << counter << ": " << current_line << endl;

第11章 定制入/输出
11.1 有规律的和无规律的输入和输出
11.2 格式化输出
11.2.1 输出整数
11.2.2 输人整数
11.2.3 输出浮点数
11.2.4 精度
11.2.5 域
11.3 文件打开和定位
11.3.1 文件打开模式
11.3.2 二进制文件
11.3.3 在文件中定位
11.4 字符串流
11.5 面向行的输入
11.6 字符分类
11.7 使用非标准分隔符
11.8 还有很多未讨论的内容
ch11_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

void int_output()
{
    cout << showbase << "Birth year:" << endl
         << 1980 << "\t(decimal)" << endl
         << hex << 1980 << "\t(hexadecimal)" << endl
         << oct << 1980 << "\t(octal)" << endl;

    cout << dec << endl << "Age:" << endl
         << 33 << "\t(decimal)" << endl
         << hex << 33 << "\t(hexadecimal)" << endl
         << oct << 33 << "\t(octal)" << endl;
    cout << dec << endl;
}

void int_input()
{
    int a;
    int b;
    int c;
    int d;
    cin >> a >> hex >> b >> oct >> c >> d;
    cout << a << '\t' << b << '\t' << c << '\t' << d << endl;
}

void float_output()
{
    cout << 1234567.89 << "\t(general)\n"
         << fixed << 1234567.89 << "\t(fixed)\n"
         << scientific << 1234567.89 << "\t(scientific)\n";
}

int main()
{
    try
    {
        int_output();
        int_input();
        float_output();
        cout << setw(10) << "Wuethrich" << " | " << "Benjamin" << " | "
             << setw(16) << "+1345 326 5181" << " | " << setw(29) << "benjamin.wuethrich@gmail.com" << endl
             << setw(10) << "Forrest" << " | " << setw(8) << "Kara" << " | "
             << setw(16) << "+1345 516 1920" << " | " << setw(29) << "kara_forrest@hotmail.com" << endl
             << setw(10) << "Aarnau" << " | " << setw(8) << "Mayra" << " | "
             << "+34 66 696 55 63" << " | " << setw(29) << "mayraaachen@hotmail.com" << endl
             << setw(10) << "Michel" << " | " << setw(8) << "Tanael" << " | "
             << "+41 79 374 48 62" << " | " << setw(29) << "tanael@gmail.com" << endl
             << setw(10) << "Widler" << " | " << setw(8) << "Andrea" << " | "
             << "+41 79 293 29 38" << " | " << setw(29) << "andreawidler@bluewin.ch" << endl
             << "Amanatidou" << " | " << "Elisabet" << " | "
             << "+41 76 701 61 28" << " | " << "elisabet.amanatidou@gmail.com" << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Birth year:
1980    (decimal)
0x7bc   (hexadecimal)
03674   (octal)

Age:
33      (decimal)
0x21    (hexadecimal)
041     (octal)

1980 7bc 3674 41
1980    1980    1980    33
1.23457e+06     (general)
1234567.890000  (fixed)
1.234568e+06    (scientific)
 Wuethrich | Benjamin |   +1345 326 5181 |  benjamin.wuethrich@gmail.com
   Forrest |     Kara |   +1345 516 1920 |      kara_forrest@hotmail.com
    Aarnau |    Mayra | +34 66 696 55 63 |       mayraaachen@hotmail.com
    Michel |   Tanael | +41 79 374 48 62 |              tanael@gmail.com
    Widler |   Andrea | +41 79 293 29 38 |       andreawidler@bluewin.ch
Amanatidou | Elisabet | +41 76 701 61 28 | elisabet.amanatidou@gmail.com

ch11_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        ifstream ifs(iname.c_str());
        if (!ifs) { error("can't open input file " + iname); }

        cout << "Enter output file name: ";
        string oname;
        cin >> oname;
        ofstream ofs(oname.c_str());
        if (!ofs) { error("can't open output file " + oname); }

        char ch;
        while (ifs.get(ch))
        {
            if (isalpha(ch)) { ch = tolower(ch); }
            ofs << ch;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p01_in.txt
Enter output file name: ch11_p01_out.txt

ls -l ch11_p01*.txt
-rw-r--r-- 1 weiyayun weiyayun 14 Dec  1 07:03 ch11_p01_in.txt
-rw-r--r-- 1 weiyayun weiyayun 14 Dec  1 07:03 ch11_p01_out.txt

cat ch11_p01_in.txt
HELLO, World!

cat ch11_p01_out.txt
hello, world!

ch11_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

bool isvowel(char ch)
{
    ch = tolower(ch);
    return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u';
}

bool allvowels(const string &s)
{
    for (int i = 0; i < s.size(); ++i)
    {
        if (!isvowel(s[i]))
        {
            return false;
        }
    }
    return true;
}

void disemvowel(string &s)
{
    string s_novow;
    for (int i = 0; i < s.size(); ++i)
    {
        if (!isvowel(s[i]))
        {
            s_novow.push_back(s[i]);
        }
    }
    s = s_novow;
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        ifstream ifs(iname.c_str());
        if (!ifs)
        {
            error("can't open input file " + iname);
        }

        cout << "Enter output file name: ";
        string oname;
        cin >> oname;
        ofstream ofs(oname.c_str());
        if (!ofs)
        {
            error("can't open output file " + oname);
        }

        char ch;
        string s;
        while (ifs.get(ch))
        {
            if (isgraph(ch))
            {
                ifs.unget();
                ifs >> s;
                if (allvowels(s))
                {
                    if ( !( ifs.get(ch) ) )
                    {
                        break;
                    }
                }
                else
                {
                    disemvowel(s);
                    ofs << s;
                }
            }
            else
            {
                ofs << ch;
            }
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p02_in.txt
Enter output file name: ch11_p02_out.txt

cat ch11_p02_in.txt
Once upon a time!

cat ch11_p02_out.txt
nc pn tm!

ch11_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

enum num_format
{
    decimal, octal, hexadecimal
};

ostream &operator<<(ostream &os, num_format nf)
{
    switch (nf)
    {
    case decimal:
        return os << "decimal\t";
    case octal:
        return os << "octal\t";
    case hexadecimal:
        return os << "hexadecimal";
    default:
        error("illegal value of number_format");
    }
}

void printnum(int n, num_format nf)
{
    cout << showbase;
    switch (nf)
    {
    case decimal:
        cout << dec << setw(12) << n;
        break;
    case octal:
        cout << oct << setw(12) << n;
        break;
    case hexadecimal:
        cout << hex << setw(12) << n;
        break;
    }
    cout << ' ' << nf << "\tconverts to " << dec << setw(12) << n << ' ' << decimal << endl;
}

int main()
{
    try
    {
        cout << "Enter space-separated integers in decimal, octal or hexadecimal notation" << endl
             << "(using 0 and 0x prefixes), any letter to finish:" << endl;
        int n = 0;
        char ch;
        while (cin >> ch)
        {
            if (ch == '0')
            {
                if (cin.get(ch))
                {
                    if (ch == 'x')
                    {
                        cin >> hex >> n;
                        printnum(n, hexadecimal);
                    }
                    else if (isdigit(ch))
                    {
                        cin.unget();
                        cin >> oct >> n;
                        printnum(n, octal);
                    }
                    else
                    {
                        cin.unget();
                        printnum(0, octal);
                    }
                }
                else
                {
                    printnum(0, octal);
                    break;
                }
            }
            else if (isdigit(ch))
            {
                cin.unget();
                cin >> dec >> n;
                printnum(n, decimal);
            }
            else
            {
                break;
            }
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter space-separated integers in decimal, octal or hexadecimal notation
(using 0 and 0x prefixes), any letter to finish:
0x43 0123 65 q
        0x43 hexadecimal        converts to           67 decimal
        0123 octal              converts to           83 decimal
          65 decimal            converts to           65 decimal

ch11_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

void char_class(const string &s)
{
    for (int i = 0; i < s.size(); ++i)
    {
        cout << s[i];
        if (isspace(s[i])) cout << " isspace";
        if (isalpha(s[i])) cout << " isalpha";
        if (isdigit(s[i])) cout << " isdigit";
        if (isxdigit(s[i])) cout << " isxdigit";
        if (isupper(s[i])) cout << " isupper";
        if (islower(s[i])) cout << " islower";
        if (isalnum(s[i])) cout << " isalnum";
        if (iscntrl(s[i])) cout << " iscntrl";
        if (ispunct(s[i])) cout << " ispunct";
        if (isprint(s[i])) cout << " isprint";
        if (isgraph(s[i])) cout << " isgraph";
        cout << endl;
    }
}

int main()
{
    try
    {
        cout << "Enter strings:\n";
        string s;
        while (cin >> s)
        {
            char_class(s);
            cout << endl;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter strings:
Hello, World! 123abc
H isalpha isupper isalnum isprint isgraph
e isalpha isxdigit islower isalnum isprint isgraph
l isalpha islower isalnum isprint isgraph
l isalpha islower isalnum isprint isgraph
o isalpha islower isalnum isprint isgraph
, ispunct isprint isgraph

W isalpha isupper isalnum isprint isgraph
o isalpha islower isalnum isprint isgraph
r isalpha islower isalnum isprint isgraph
l isalpha islower isalnum isprint isgraph
d isalpha isxdigit islower isalnum isprint isgraph
! ispunct isprint isgraph

1 isdigit isxdigit isalnum isprint isgraph
2 isdigit isxdigit isalnum isprint isgraph
3 isdigit isxdigit isalnum isprint isgraph
a isalpha isxdigit islower isalnum isprint isgraph
b isalpha isxdigit islower isalnum isprint isgraph
c isalpha isxdigit islower isalnum isprint isgraph

ch11_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        ifstream ifs(iname.c_str());
        if (!ifs) { error("can't open input file " + iname); }

        cout << "Enter output file name: ";
        string oname;
        cin >> oname;
        ofstream ofs(oname.c_str());
        if (!ofs) { error("can't open output file " + oname); }

        char ch;
        while (ifs.get(ch))
        {
            if (ispunct(ch)) { ch = ' '; }
            ofs << ch;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p05_in.txt
Enter output file name: ch11_p05_out.txt

cat ch11_p05_in.txt
Hello, World! 123;abc

cat ch11_p05_out.txt
Hello  World  123 abc

ch11_p06a.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}


class Punct_stream
{
public:
    Punct_stream(istream &is) : source(is), sensitive(true) { }

    void whitespace(const string &s)
    {
        white = s;
    }
    void add_white(char c)
    {
        white += c;
    }
    bool is_whitespace(char c);
    void case_sensitive(bool b)
    {
        sensitive = b;
    }
    bool is_case_sensitive()
    {
        return sensitive;
    }

    Punct_stream &operator>>(string &s);
    operator bool();
private:
    istream &source;
    istringstream buffer;
    string white;
    bool sensitive;
};

bool Punct_stream::is_whitespace(char c)
{
    for (int i = 0; i < white.size(); ++i)
    {
        if (c == white[i])
        {
            return true;
        }
    }
    return false;
}

Punct_stream::operator bool()
{
    return ( (buffer) || (source) );
}

Punct_stream &Punct_stream::operator>>(string &s)
{
    while (!(buffer >> s))
    {
        string line;

        if ( !( getline(source, line, '\n') ) )
        {
            return *this;
        }
        buffer.clear();

        for (int i = 0; i < line.size(); ++i)
        {
            if (is_whitespace(line[i]))
            {
                line[i] = ' ';
            }
            else if (!sensitive)
            {
                line[i] = tolower(line[i]);
            }
        }
        buffer.str(line);
    }
    return *this;
}

int main()
{
    try
    {
        Punct_stream ps(cin);
        ps.whitespace(";:,.?!()\"{}<>/&$@#%^*|~");
        ps.case_sensitive(false);

        cout << "please enter words\n";
        vector<string> vs;
        string word;
        while (ps >> word)
        {
            vs.push_back(word);
        }

        sort(vs.begin(), vs.end());
        for (int i = 0; i < vs.size(); ++i)
        {
            if (i == 0 || vs[i] != vs[i - 1])
            {
                cout << vs[i] << endl;
            }
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
please enter words
Peter Smith Mike Pence Hello World
Water Flower Sun Apple Orange
apple
flower
hello
mike
orange
pence
peter
smith
sun
water
world

ch11_p06b.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

void to_lowercase(string &s)
{
    if (s.size() == 0) { return; }
    for (int i = 0; i < s.size(); ++i)
    {
        s[i] = tolower(s[i]);
    }
}

void remove_punct(string &s)
{
    if (s.size() == 0) { return; }
    for (int i = 0; i < s.size(); ++i)
    {
        if (ispunct(s[i]) && s[i] != '\'' && s[i] != '-') { s[i] = ' '; }
    }
}

void remove_hyphen(string &s)
{
    if (s.size() == 0) { return; }
    if (s.size() >= 2 && s[0] == '-' && s[1] == ' ') { s[0] = ' '; }
    if (s.size() >= 2 && s[s.size() - 1] == '-' && s[s.size() - 2] == ' ') { s[s.size() - 1] = ' '; }
    for (int i = 1; i < s.size() - 1; ++i)
    {
        if (s[i] == '-' && s[i - 1] == ' ' && s[i + 1] == ' ') { s[i] = ' '; }
        if (s[i] == '-' && s[i + 1] == '-')
        {
            s[i] = ' ';
            s[i + 1] = ' ';
            ++i;
        }
    }
}

void expand_aux(string &s)
{
    if (s.size() == 0) { return; }
    istringstream is(s);
    string word;
    string s_exp;
    ostringstream os(s_exp);
    while (is >> word)
    {
        if (word.size() >= 5
                 && word[word.size() - 3] == 'n'
                 && word[word.size() - 2] == '\''
                 && word[word.size() - 1] == 't')
        {
            for (int i = 0; i < word.size() - 3; ++i)
            {
                os << word[i];
            }
            os << " not";
        }
        else { os << word; }
        os << ' ';
    }
    s = os.str();
}

void convert_file(const string &iname, const string &oname)
{
    ifstream ifs(iname.c_str());
    if (!ifs) { error("can't open input file " + iname); }
    ofstream ofs(oname.c_str());
    if (!ofs) { error("can't open output file " + oname); }

    string s;
    while (getline(ifs, s, '\n'))
    {
        to_lowercase(s);
        remove_punct(s);
        remove_hyphen(s);
        expand_aux(s);
        ofs << s << endl;
    }
}

void build_dict(const string &iname, const string &oname)
{
    ifstream ifs(iname.c_str());
    if (!ifs) { error("can't open input file " + iname); }
    ofstream ofs(oname.c_str());
    if (!ofs) { error("can't open output file " + oname); }

    vector<string> vs;
    string word;
    while (ifs >> word)
    {
        vs.push_back(word);
    }

    sort(vs.begin(), vs.end());
    for (int i = 0; i < vs.size(); ++i)
    {
        if (i == 0 || vs[i] != vs[i - 1]) { ofs << vs[i] << endl; }
    }
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        cout << "Enter output file name: ";
        string oname;
        cin >> oname;
        convert_file(iname, oname);
        cout << "Enter name for dictionary file: ";
        string dname;
        cin >> dname;
        build_dict(oname, dname);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p06b_in.txt
Enter output file name: ch11_p06b_out.txt
Enter name for dictionary file: ch11_p06b_dict.txt

cat ch11_p06b_in.txt
Hello, World!
Peter - don't use the as-if rule.

cat ch11_p06b_out.txt
hello world
peter do not use the as-if rule

cat ch11_p06b_dict.txt
as-if
do
hello
not
peter
rule
the
use
world

ch11_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

string bin_file = "ch11_p08.bin";

void to_binary(const string &s)
{
    ifstream ifs(s.c_str());
    if (!ifs) { error("can't open input file " + s); }
    ofstream ofs(bin_file.c_str(), std::ios_base::binary);
    if (!ofs) { error("can't open output file " + bin_file); }

    char ch;
    while (ifs.get(ch))
    {
        ofs.write(&ch, sizeof(char));
    }
}

void from_binary(const string &s)
{
    ifstream ifs(bin_file.c_str(), std::ios_base::binary);
    if (!ifs) { error("can't open input file " + bin_file); }
    ofstream ofs(s.c_str());
    if (!ofs) { error("can't open output file " + s); }

    char ch;
    while (ifs.read(&ch, sizeof(char)))
    {
        ofs << ch;
    }
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        to_binary(iname);

        cout << "Enter output file name: ";
        string oname;
        cin >> oname;
        from_binary(oname);

        cout << "Done!\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p08.cpp
Enter output file name: ch11_p08.txt
Done!

ls -l ch11_p08.???
-rw-r--r-- 1 weiyayun weiyayun 3381 Dec  1 12:40 ch11_p08.bin
-rw-r--r-- 1 weiyayun weiyayun 3381 Dec  1 12:39 ch11_p08.cpp
-rw-r--r-- 1 weiyayun weiyayun 3381 Dec  1 12:40 ch11_p08.txt

ch11_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

vector<string> split(const string &s)
{
    istringstream is(s);
    string ss;
    vector<string> substrings;
    while (is >> ss) { substrings.push_back(ss); }
    return substrings;
}

void print_vector(const vector<string> & vs)
{
    for (int i = 0; i < vs.size(); ++i)
    {
        cout << vs[i] << endl;
    }
}

int main()
{
    try
    {
        cout << "Enter a few words: ";
        string s;
        while (getline(cin, s, '\n') && s != "")
        {
            vector<string> substrings = split(s);
            cout << "\nYou entered:\n";
            print_vector(substrings);
            cout << "\nEnter a few words: ";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter a few words: Hello World Peter Smith Mike Pence Water Flower

You entered:
Hello
World
Peter
Smith
Mike
Pence
Water
Flower

Enter a few words:

ch11_p10.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

vector<string> split(const string &s)
{
    istringstream is(s);
    string ss;
    vector<string> substrings;
    while (is >> ss) { substrings.push_back(ss); }
    return substrings;
}

bool contains(const string &s, char ch)
{
    for (int i = 0; i < s.size(); ++i)
    {
        if (s[i] == ch) { return true; }
    }
    return false;
}

vector<string> split(const string &s, const string &w)
{
    string ss = s;
    for (int i = 0; i < ss.size(); ++i)
    {
        if (contains(w, ss[i])) { ss[i] = ' '; }
    }
    return split(ss);
}

void print_vector(const vector<string> &vs)
{
    for (int i = 0; i < vs.size(); ++i)
    {
        cout << vs[i] << endl;
    }
}

int main()
{
    try
    {
        cout << "Enter string with separation characters: ";
        string w;
        getline(cin, w, '\n');
        cout << "Enter a few words: ";
        string s;
        while (getline(cin, s, '\n') && s != "")
        {
            vector<string> substrings = split(s, w);
            cout << "\nYou entered:\n";
            print_vector(substrings);
            cout << "\nEnter a few words: ";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter string with separation characters: ,;.!?
Enter a few words: Hello,World!abc;123.efg?hij

You entered:
Hello
World
abc
123
efg
hij

Enter a few words:

ch11_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        ifstream ifs(iname.c_str());
        if (!ifs) { error("can't open input file " + iname); }
        cout << "Enter output file name: ";
        string oname;
        cin >> oname;
        ofstream ofs(oname.c_str());
        if (!ofs) { error("can't open output file " + oname); }

        string contents;
        char ch;
        while (ifs.get(ch))
        {
            contents.push_back(ch);
        }

        for (int i = contents.size() - 1; i >= 0; --i)
        {
            ofs << contents[i];
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p11_in.txt
Enter output file name: ch11_p11_out.txt

cat ch11_p11_in.txt
Hello,World!

cat ch11_p11_out.txt

!dlroW,olleH

ch11_p12.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        ifstream ifs(iname.c_str());
        if (!ifs) { error("can't open input file " + iname); }
        cout << "Enter output file name: ";
        string oname;
        cin >> oname;
        ofstream ofs(oname.c_str());
        if (!ofs) { error("can't open output file " + oname); }

        vector<string> contents;
        string s;
        while (ifs >> s)
        {
            contents.push_back(s);
        }

        for (int i = contents.size() - 1; i >= 0; --i)
        {
            ofs << contents[i] << endl;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p06b_dict.txt
Enter output file name: ch11_p12_out.txt

cat ch11_p06b_dict.txt
as-if
do
hello
not
peter
rule
the
use
world

cat ch11_p12_out.txt
world
use
the
rule
peter
not
hello
do
as-if

ch11_p13.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        ifstream ifs(iname.c_str());
        if (!ifs) { error("can't open input file " + iname); }

        char ch;
        int space = 0;
        int alpha = 0;
        int digit = 0;
        int xdigit = 0;
        int upper = 0;
        int lower = 0;
        int alnum = 0;
        int cntrl = 0;
        int punct = 0;
        int print = 0;
        int graph = 0;

        while (ifs.get(ch))
        {
            if (isspace(ch)) ++space;
            if (isalpha(ch)) ++alpha;
            if (isdigit(ch)) ++digit;
            if (isxdigit(ch)) ++xdigit;
            if (isupper(ch)) ++upper;
            if (islower(ch)) ++lower;
            if (isalnum(ch)) ++alnum;
            if (iscntrl(ch)) ++cntrl;
            if (ispunct(ch)) ++punct;
            if (isprint(ch)) ++print;
            if (isgraph(ch)) ++graph;
        }

        cout << "Analysis:\n";
        cout << "isspace:\t" << space << endl;
        cout << "isalpha:\t" << alpha << endl;
        cout << "isdigit:\t" << digit << endl;
        cout << "isxdigit:\t" << xdigit << endl;
        cout << "isupper:\t" << upper << endl;
        cout << "islower:\t" << lower << endl;
        cout << "isalnum:\t" << alnum << endl;
        cout << "iscntrl:\t" << cntrl << endl;
        cout << "ispunct:\t" << punct << endl;
        cout << "isprint:\t" << print << endl;
        cout << "isgraph:\t" << graph << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p13_in.txt
Analysis:
isspace:        4
isalpha:        16
isdigit:        3
isxdigit:       10
isupper:        2
islower:        14
isalnum:        19
iscntrl:        1
ispunct:        3
isprint:        25
isgraph:        22

cat ch11_p13_in.txt
Hello, World! 123abc efg?

ch11_p14.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        ifstream ifs(iname.c_str());
        if (!ifs) { error("can't open input file " + iname); }

        double d;
        vector<double> nums;
        while (ifs >> d)
        {
            nums.push_back(d);
        }

        cout << scientific << setprecision(8);
        int i;
        for (i = 0; i < nums.size(); ++i)
        {
            cout << setw(20) << nums[i];
            if (i % 4 == 3) { cout << endl; }
        }
        if (i % 4 != 0) { cout << endl; }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p14_in.txt
      1.23000000e+00      1.23400000e+00      1.23456000e+01      1.23456780e+02
      1.23456789e+04

cat ch11_p14_in.txt
1.23
1.234
12.3456
123.45678
12345.6789

ch11_p15.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        cout << "Enter input file name: ";
        string iname;
        cin >> iname;
        ifstream ifs(iname.c_str());
        if (!ifs)
        {
            error("can't open input file " + iname);
        }

        int n;
        vector<int> numbers;
        while (ifs >> n)
        {
            numbers.push_back(n);
        }

        sort(numbers.begin(), numbers.end());
        int counter = 1;
        int i = 0;
        for (i = 0; i < numbers.size(); ++i)
        {
            if (i == 0 || numbers[i] != numbers[i - 1])
            {
                if (counter > 1)
                {
                    cout << "\t" << counter << endl;
                }
                else if (i > 0)
                {
                    cout << endl;
                }
                counter = 1;
                cout << numbers[i];
            }
            else
            {
                ++counter;
            }
        }
        if (counter > 1)
        {
            cout << "\t" << counter << endl;
        }
        else if (i > 0)
        {
            cout << endl;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter input file name: ch11_p15_in.txt
123     3
345
456
567
789     2

cat ch11_p15_in.txt
123
456
789
567
123
789
123
345

第三部分 数据Y构和算法
第17章 向量和自由空间
17.1 介绍
17.2 向量的基本知识.
17.3 内存、地址和指针
17.3.1 运算符sizeof
17.4 自由空间和指针
17.4.1 自由空间分配
17.4.2 通过指针访问数据
17.4.3 指针范围
17.4.4 初始化
17.4.5 空指针
17.4.6 自由空间释放
17.5 析构函数
17.5.1 生成的析构函数
17.5.2 析构函数和自由空间
17.6 访问向量元素
17.7 指向类对象的指针
17.8 类型混用：无类型指针和指针类型转换
17.9 指针和引用
17.9.1 指针参数和引用参数
17.9.2 指针、引用和继承
17.9.3 实例：列表
17.9.4 列表的操作
17.9.5 列表的使用
17.10 this指针
17.10.1 关于Link使用的更多讨论
ch17_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

void print_array(ostream &os, int *a, int n)
{
    for (int i = 0; i < n; ++i)
    {
        os << a[i] << "\n";
    }
}

void print_vector(ostream &os, const vector<int> &v)
{
    for (int i = 0; i < v.size(); ++i)
    {
        os << v[i] << "\n";
    }
}

int main()
{
    try
    {
        int *ip = new int[10];

        cout << "*** 2 ***\n";
        for (int i = 0; i < 10; ++i)
        {
            cout << ip[i] << "\n";
        }

        delete[] ip;

        cout << "*** 5 ***\n";
        int *ip2 = new int[10];

        for (int i = 0; i < 10; ++i)
        {
            ip2[i] = 100 + i;
        }
        print_array(cout, ip2, 10);

        delete[] ip2;

        cout << "*** 6 ***\n";
        int *ip3 = new int[11];

        for (int i = 0; i < 11; ++i)
        {
            ip3[i] = 100 + i;
        }
        print_array(cout, ip3, 11);

        delete[] ip3;

        cout << "*** 8 ***\n";
        int *ip4 = new int[20];

        for (int i = 0; i < 20; ++i)
        {
            ip4[i] = 100 + i;
        }
        print_array(cout, ip4, 20);

        delete[] ip4;

        cout << "*** 10 ***\n";
        vector<int> v;
        for (int i = 0; i < 10; ++i)
        {
            v.push_back(100 + i);
        }
        print_vector(cout, v);

        cout << "\n";
        vector<int> v2;
        for (int i = 0; i < 11; ++i)
        {
            v2.push_back(100 + i);
        }
        print_vector(cout, v2);

        cout << "\n";
        vector<int> v3;
        for (int i = 0; i < 20; ++i)
        {
            v3.push_back(100 + i);
        }
        print_vector(cout, v3);


        int i1 = 7;
        int *p1 = &i1;

        cout << "*** 2 ***\n";
        cout << "p1: " << p1 << "\n";
        cout << "*p1: " << *p1 << "\n";

        int *p2 = new int[7];
        for (int i = 0; i < 7; ++i)
        {
            p2[i] = pow(2, i);
        }

        cout << "*** 4 ***\n";
        cout << "p2: " << p2 << "\n";
        cout << "print_array(cout, p2, 7):\n";
        print_array(cout, p2, 7);

        int *p3 = p2;

        p2 = p1;

        p2 = p3;

        cout << "*** 8 ***\n";
        cout << "p1: " << p1 << "\n";
        cout << "*p1: " << *p1 << "\n";
        cout << "p2: " << p2 << "\n";
        cout << "*p2: " << *p2 << "\n";

        delete[] p2;
        p3 = nullptr;

        p1 = new int[10];
        for (int i = 0; i < 10; ++i)
        {
            p1[i] = pow(2, i);
         }

        p2 = new int[10];

        cout << "*** 12 ***\n";
        for (int i = 0; i < 10; ++i)
        {
            p2[i] = p1[i];
        }
        print_array(cout, p2, 10);
       
       delete [] p1;
       delete [] p2;

        cout << "*** 13 ***\n";
        vector<int> vec1;
        for (int i = 0; i < 10; ++i)
        {
            vec1.push_back(pow(2, i));
        }
        vector<int> vec2;
        for (int i = 0; i < vec1.size(); ++i)
        {
            vec2.push_back(vec1[i]);
        }
        print_vector(cout, vec2);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
*** 2 ***
0
0
0
0
0
0
0
0
0
0
*** 5 ***
100
101
102
103
104
105
106
107
108
109
*** 6 ***
100
101
102
103
104
105
106
107
108
109
110
*** 8 ***
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
*** 10 ***
100
101
102
103
104
105
106
107
108
109

100
101
102
103
104
105
106
107
108
109
110

100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
*** 2 ***
p1: 0x7ffd6af48e5c
*p1: 7
*** 4 ***
p2: 0x55d63553feb0
print_array(cout, p2, 7):
1
2
4
8
16
32
64
*** 8 ***
p1: 0x7ffd6af48e5c
*p1: 7
p2: 0x55d63553feb0
*p2: 1
*** 12 ***
1
2
4
8
16
32
64
128
256
512
*** 13 ***
1
2
4
8
16
32
64
128
256
512

ch17_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

long ptr_to_long(void *ptr)
{
    ostringstream oss;
    oss << ptr;
    istringstream iss(oss.str());
    long address;
    iss >> hex >> address;
    if (!iss) { error("problem reading address"); }
    return address;
}

struct X
{
    int a, b, c;
};

struct V
{
    int a, b, c;
    virtual void f() { }
};

int main()
{
    try
    {
        cout << "Output format of a pointer:\n";
        int *pi = new int(0);
        cout << "pi = " << pi << "\n";
        cout << "*pi = " << *pi << "\n";
        cout << "&pi[1] = " << &pi[1] << "\n";
        delete pi;

        cout << "\nNumber of bytes of different types:\n";
        pi = new int[2];
        pi[0] = 0;
        pi[1] = 0;
        int var_size = ptr_to_long(&pi[1]) - ptr_to_long(pi);
        cout << "int: " << &pi[1] << " - " << pi << " = " << var_size << " bytes.\n";
        cout << "sizeof(int): " << sizeof(int) << "\n";
        delete[] pi;

        char *pc = new char[2];
        pc[0] = 0;
        pc[1] = 0;
        var_size = ptr_to_long(&pc[1]) - ptr_to_long(pc);
        cout << "char: " << (void *)&pc[1] << " - " << (void *)pc << " = " << var_size << " bytes.\n";
        cout << "sizeof(char): " << sizeof(char) << "\n";
        delete[] pc;

        double *pd = new double[2];
        pd[0] = 0;
        pd[1] = 0;
        var_size = ptr_to_long(&pd[1]) - ptr_to_long(pd);
        cout << "double: " << &pd[1] << " - " << pd << " = " << var_size << " bytes.\n";
        cout << "sizeof(double): " << sizeof(double) << "\n";
        delete[] pd;

        bool *pb = new bool[2];
        pb[0] = 0;
        pb[1] = 0;
        var_size = ptr_to_long(&pb[1]) - ptr_to_long(pb);
        cout << "bool: " << &pb[1] << " - " << pb << " = " << var_size << " bytes.\n";
        cout << "sizeof(bool): " << sizeof(bool) << "\n";
        delete[] pb;

        X *pX = new X[2];
        var_size = ptr_to_long(&pX[1]) - ptr_to_long(pX);
        cout << "struct X: " << &pX[1] << " - " << pX << " = " << var_size << " bytes.\n";
        cout << "sizeof(X): " << sizeof(X) << "\n";

        V *pV = new V[2];
        var_size = ptr_to_long(&pV[1]) - ptr_to_long(pV);
        cout << "struct V: " << &pV[1] << " - " << pV << " = " << var_size << " bytes.\n";
        cout << "sizeof(V): " << sizeof(V) << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Output format of a pointer:
pi = 0x560b284162c0
*pi = 0
&pi[1] = 0x560b284162c4

Number of bytes of different types:
int: 0x560b284162c4 - 0x560b284162c0 = 4 bytes.
sizeof(int): 4
char: 0x560b284162c1 - 0x560b284162c0 = 1 bytes.
sizeof(char): 1
double: 0x560b284162c8 - 0x560b284162c0 = 8 bytes.
sizeof(double): 8
bool: 0x560b284162c1 - 0x560b284162c0 = 1 bytes.
sizeof(bool): 1
struct X: 0x560b284162cc - 0x560b284162c0 = 12 bytes.
sizeof(X): 12
struct V: 0x560b284162f8 - 0x560b284162e0 = 24 bytes.
sizeof(V): 24

ch17_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

void to_lower(char *s)
{
    for (int i = 0; s[i] != '\0'; ++i)
    {
        if (s[i] >= 'A' && s[i] <= 'Z')
        {
            s[i] += ('a' - 'A');
        }
    }
}

void print_array(char *s)
{
    for (int i = 0; s[i] != '\0'; ++i)
    {
        cout << s[i];
    }
}

void test(string &s)
{
    to_lower(&s[0]);
    print_array(&s[0]);
    cout << "\n";
}

int main()
{
    try
    {
        string s;
        while (getline(cin, s, '\n') && s != "")
        {
            test(s);
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Hello, World!
hello, world!
Abc123 Efg
abc123 efg

ch17_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

char *strcopy(const char *s)
{
    if (s == nullptr) { return nullptr; }

    int n = 0;
    while (s[n] != '\0')
    {
        ++n;
    }

    char *pc = new char[n + 1];

    for (int i = 0; i < n; ++i)
    {
        pc[i] = s[i];
    }
    pc[n] = '\0';

    return pc;
}

int main()
{
    try
    {
        string s;
        char *cstr;
        while (getline(cin, s, '\n') && s != "")
        {
            cstr = strcopy(s.c_str());
            cout << cstr << "\n";
            delete[] cstr;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Hello, World! Abc123; Water
Hello, World! Abc123; Water

ch17_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

const char *findx(const char *s, const char *x)
{
    if (x == nullptr) { return nullptr; }
    if (s == nullptr) { return nullptr; }
    for (int i = 0; s[i] != '\0'; ++i)
    {
        if (s[i] == x[0])
        {
            int j = 1;
            for (; x[j] != '\0'; ++j)
            {
                if (s[i + j] == '\0') { return nullptr; }
                if (s[i + j] != x[j]) { break; }
            }
            if (x[j] == '\0') { return &s[i]; }
        }
    }
    return nullptr;
}

int main()
{
    try
    {
        const char *ss = "Does this work with whitespace, too?";
        const char *xx = "work with";
        const char *sub = findx(ss, xx);
        if (!sub) { cout << "Not found!\n"; }
        else { cout << sub << "\n"; }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
work with whitespace, too?

ch17_p06a.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        int i = 0;
        char *pc = new char[8589934592];
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
error: std::bad_alloc

ch17_p06b.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        int i = 0;
        char *pc = new  (std::nothrow) char[8589934592];
        if (pc == nullptr)
        {
            cout << "allocate memory fail.\n";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
allocate memory fail.

ch17_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char ch)
    {
        append(ch);
        return *this;
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

int main()
{
    try
    {
        char ch;
        Str_c s;
        while (cin.get(ch) && ch != '!')
        {
            s += ch;
        }

        cout << s << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Hello, World!123abc Water
Hello, World

ch17_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int main()
{
    try
    {
        char ch;
        string s;
        while (cin.get(ch) && ch != '!')
        {
            s.push_back(ch);
        }
        cout << s << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Hello, World!+?abc123
Hello, World

ch17_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

void f2()
{
    int i3;
    int *ip3 = new int(0);
    cout << &i3  << ", " << ip3 << "\n";
    delete ip3;
}
void f1()
{
    int i2;
    int *ip2 = new int(0);
    cout << &i2  << ", " << ip2 << "\n";
    f2();
    delete ip2;
}
void f()
{
    int i1;
    int *ip1 = new int(0);
    cout << &i1 << ", " << ip1 << "\n";
    f1();
    delete ip1;
}

int main()
{
    try
    {
        cout << "Addresses on stack, Addresses on heap:\n";
        f();
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Addresses on stack, Addresses on heap:
0x7ffdda9ecadc, 0x55c8a52142c0
0x7ffdda9ecaac, 0x55c8a52142e0
0x7ffdda9eca7c, 0x55c8a5214300

ch17_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

class Link
{
public:
    string value;

    Link(const string &v, Link *p = nullptr, Link *s = nullptr) : value(v), prev(p), succ(s) { }

    Link *insert(Link *n);
    Link *add(Link *n);
    Link *erase();
    Link *find(const string &s);
    const Link *find(const string &s) const;

    Link *advance(int n) const;

    Link *next() const
    {
        return succ;
    }
    Link *previous() const
    {
        return prev;
    }
private:
    Link *prev;
    Link *succ;
};

Link *Link::insert(Link *n)
{
    if (n == nullptr) { return n; }
    n->succ = this;
    if (prev != nullptr) { prev->succ = n; }
    n->prev = prev;
    prev = n;
    return n;
}

Link *Link::add(Link *n)
{
    if (n == nullptr) { return n; }
    n->prev = this;
    if (succ != nullptr) { succ->prev = n; }
    n->succ = succ;
    succ = n;
    return n;
}

Link *Link::erase()
{
    if (succ != nullptr) { succ->prev = prev; }
    if (prev != nullptr) { prev->succ = succ; }
    return succ;
}

Link *Link::find(const string &s)
{
    Link *p = this;
    while (p != nullptr)
    {
        if (p->value == s) { return p; }
        p = p->succ;
    }
    return nullptr;
}

const Link *Link::find(const string &s) const
{
    const Link *p = this;
    while (p != nullptr)
    {
        if (p->value == s) { return p; }
        p = p->succ;
    }
    return nullptr;
}

Link *Link::advance(int n) const
{
    Link *p = const_cast<Link *>(this);
    if (0 < n)
    {
        while (n--)
        {
            if (p->succ == nullptr) { return nullptr; }
            p = p->succ;
        }
    }
    else if (n < 0)
    {
        while (n++)
        {
            if (p->prev == nullptr) { return nullptr; }
            p = p->prev;
        }
    }
    return p;
}

void print_all(Link *p)
{
    cout << "{ ";
    while (p != nullptr)
    {
        cout << p->value;
        p = p->next();
        if (p != nullptr) { cout << ", "; }
    }
    cout << " }";
}

void delete_all(Link *p)
{
    while (p != nullptr)
    {
        Link *temp = p->next();
        delete p;
        p = temp;
    }
}


int main()
{
    try
    {
        Link *norse_gods = new Link("Thor");
        norse_gods = norse_gods->insert(new Link("Odin"));
        norse_gods = norse_gods->insert(new Link("Zeus"));
        norse_gods = norse_gods->insert(new Link("Freia"));

        Link *greek_gods = new Link("Hera");
        greek_gods = greek_gods->insert(new Link("Athena"));
        greek_gods = greek_gods->insert(new Link("Mars"));
        greek_gods = greek_gods->insert(new Link("Poseidon"));

        print_all(norse_gods);
        cout << "\n";

        print_all(greek_gods);
        cout << "\n";

        Link *p = greek_gods->find("Mars");
        if (p != nullptr) { p->value = "Ares"; }

        Link *p2 = norse_gods->find("Zeus");
        if (p2 != nullptr)
        {
            if (p2 == norse_gods) { norse_gods = p2->next(); }
            p2->erase();
            greek_gods = greek_gods->add(p2)->advance(-1);
        }

        print_all(norse_gods);
        cout << "\n";

        print_all(greek_gods);
        cout << "\n";

        delete_all(norse_gods);
        delete_all(greek_gods);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
{ Freia, Zeus, Odin, Thor }
{ Poseidon, Mars, Athena, Hera }
{ Freia, Odin, Thor }
{ Poseidon, Zeus, Ares, Athena, Hera }

ch17_p13.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

class God
{
public:
    God(const string &n = "", const string &m = "", const string &v = "", const string &w = "")
        : name(n), mythology(m), vehicle(v), weapon(w) { }
    string name;
    string mythology;
    string vehicle;
    string weapon;
};

ostream &operator<<(ostream &os, const God &g)
{
    os << g.name << ", " << g.mythology << ", ";
    os << g.vehicle << ", " << g.weapon;
    return os;
}

class Link
{
public:
    God value;

    Link(const string &n = "", const string &m = "", const string &v = "",
         const string &w = "", Link *p = nullptr, Link *s = nullptr)
        : value(n, m, v, w), prev(p), succ(s) { }

    Link *insert(Link *n);
    Link *add(Link *n);
    Link *add_ordered(Link *n);
    Link *erase();
    Link *find(const string &s);
    const Link *find(const string &s) const;

    Link *advance(int n);

    Link *next() const
    {
        return succ;
    }
    Link *previous() const
    {
        return prev;
    }
private:
    Link *prev;
    Link *succ;
};

Link *Link::insert(Link *n)
{
    if (n == nullptr)
    {
        return n;
    }
    n->succ = this;
    if (prev != nullptr)
    {
        prev->succ = n;
    }
    n->prev = prev;
    prev = n;
    return n;
}

Link *Link::add(Link *n)
{
    if (n == nullptr)
    {
        return n;
    }
    n->prev = this;
    if (succ != nullptr)
    {
        succ->prev = n;
    }
    n->succ = succ;
    succ = n;
    return n;
}

Link *Link::add_ordered(Link *n)
{
    if (n == nullptr)
    {
        return n;
    }
    if (n->value.name < value.name)
    {
        Link *p = insert(n);
        return p;
    }
    Link *p = this;
    while (n->value.name >= p->value.name)
    {
        if (p->succ == nullptr)
        {
            p->add(n);
            return this;
        }
        p = p->succ;
    }
    p->insert(n);
    return this;
}

Link *Link::erase()
{
    if (succ != nullptr)
    {
        succ->prev = prev;
    }
    if (prev != nullptr)
    {
        prev->succ = succ;
    }
    Link *ret = succ;
    succ = nullptr;
    prev = nullptr;
    return ret;
}

Link *Link::find(const string &s)
{
    Link *p = this;
    while (p != nullptr)
    {
        if (p->value.name == s)
        {
            return p;
        }
        p = p->succ;
    }
    return nullptr;
}

const Link *Link::find(const string &s) const
{
    const Link *p = this;
    while (p != nullptr)
    {
        if (p->value.name == s)
        {
            return p;
        }
        p = p->succ;
    }
    return nullptr;
}

Link *Link::advance(int n)
{
    Link *p = this;
    if (0 < n)
    {
        while (n--)
        {
            if (p->succ == nullptr)
            {
                return nullptr;
            }
            p = p->succ;
        }
    }
    else if (n < 0)
    {
        while (n++)
        {
            if (p->prev == nullptr)
            {
                return nullptr;
            }
            p = p->prev;
        }
    }
    return p;
}

void print_all(Link *p)
{
    while (p != nullptr)
    {
        cout << p->value << endl;
        p = p->next();
    }
}

void delete_all(Link *p)
{
    while (p != nullptr)
    {
        Link *temp = p->next();
        delete p;
        p = temp;
    }
}

Link *extract(Link **l, const string &s)
{
    if ( (*l) == nullptr )
    {
        return nullptr;
    }
    Link *p = (*l)->find(s);
    if (p != nullptr)
    {
        if (p == (*l))
        {
            (*l) = p->next();
        }
        p->erase();
        return p;
    }
    return nullptr;
}

int main()
{
    try
    {
        Link *all_gods = new Link("Thor", "Norse", "Pinzgauer", "Hammer");
        all_gods = all_gods->insert(new Link("Odin", "Norse", "Eight-legged horse", ""));
        all_gods = all_gods->insert(new Link("Zeus", "Greek", "", "Lightning"));
        all_gods = all_gods->insert(new Link("Freia", "Norse", "F-transport", "F-weapon"));
        all_gods = all_gods->insert(new Link("Hera", "Greek", "H-transport", "Spear"));
        all_gods = all_gods->insert(new Link("Athena", "Greek", "A-transport", "A-weapon"));
        all_gods = all_gods->insert(new Link("Mars", "Roman", "M-transport", "M-weapon"));
        all_gods = all_gods->insert(new Link("Poseidon", "Greek", "Seahorse", "Trident"));
        all_gods = all_gods->insert(new Link("Ares", "Greek", "A-transport", "A-weapon"));
        all_gods = all_gods->insert(new Link("Vesuvius", "Roman", "V-transport", "Volcano"));
        all_gods = all_gods->insert(new Link("Bacchus", "Roman", "Stretcher", "Wine goblet"));

        print_all(all_gods);
        cout << endl;

        Link *norse_gods = extract(&all_gods, "Odin");
        norse_gods = norse_gods->add_ordered(extract(&all_gods, "Thor"));
        norse_gods = norse_gods->add_ordered(extract(&all_gods, "Freia"));
        cout << "Norse gods:\n";
        print_all(norse_gods);
        cout << endl;

        Link *greek_gods = extract(&all_gods, "Hera");
        greek_gods = greek_gods->add_ordered(extract(&all_gods, "Athena"));
        greek_gods = greek_gods->add_ordered(extract(&all_gods, "Poseidon"));
        greek_gods = greek_gods->add_ordered(extract(&all_gods, "Zeus"));
        greek_gods = greek_gods->add_ordered(extract(&all_gods, "Ares"));
        cout << "Greek gods:\n";
        print_all(greek_gods);
        cout << endl;

        Link *roman_gods = extract(&all_gods, "Mars");
        roman_gods = roman_gods->add_ordered(extract(&all_gods, "Vesuvius"));
        roman_gods = roman_gods->add_ordered(extract(&all_gods, "Bacchus"));
        cout << "Roman gods:\n";
        print_all(roman_gods);
        cout << endl;

        delete_all(norse_gods);
        delete_all(greek_gods);
        delete_all(roman_gods);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Bacchus, Roman, Stretcher, Wine goblet
Vesuvius, Roman, V-transport, Volcano
Ares, Greek, A-transport, A-weapon
Poseidon, Greek, Seahorse, Trident
Mars, Roman, M-transport, M-weapon
Athena, Greek, A-transport, A-weapon
Hera, Greek, H-transport, Spear
Freia, Norse, F-transport, F-weapon
Zeus, Greek, , Lightning
Odin, Norse, Eight-legged horse,
Thor, Norse, Pinzgauer, Hammer

Norse gods:
Freia, Norse, F-transport, F-weapon
Odin, Norse, Eight-legged horse,
Thor, Norse, Pinzgauer, Hammer

Greek gods:
Ares, Greek, A-transport, A-weapon
Athena, Greek, A-transport, A-weapon
Hera, Greek, H-transport, Spear
Poseidon, Greek, Seahorse, Trident
Zeus, Greek, , Lightning

Roman gods:
Bacchus, Roman, Stretcher, Wine goblet
Mars, Roman, M-transport, M-weapon
Vesuvius, Roman, V-transport, Volcano

ch17_p14.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

class List;

class Link
{
public:
    string value;

    Link(const string &v = "", Link *s = nullptr) : value(v), succ(s) { }

    Link *insert(List &l, Link *n);
    Link *add(List &l, Link *n);
    Link *erase(List &l);
    Link *find(const List &l, const string &s);
    const Link *find(const List &l, const string &s) const;

    Link *advance(int n);

    Link *next() const
    {
        return succ;
    }
private:
    Link *succ;
};

class List
{
public:
    List() : first_link(nullptr) { }
    List(Link *l) : first_link(l) { }
    Link *first_link;
};

Link *Link::insert(List &l, Link *n)
{
    if (n == nullptr)
    {
        return n;
    }
    n->succ = this;
    if (l.first_link == this)
    {
        l.first_link = n;
        return n;
    }
    Link *p = l.first_link;
    while (p->succ != this)
    {
        p = p->succ;
    }
    p->succ = n;
    return n;
}

Link *Link::add(List &l, Link *n)
{
    if (n == nullptr)
    {
        return n;
    }
    n->succ = succ;
    succ = n;
    return n;
}

Link *Link::erase(List &l)
{
    if (l.first_link == this)
    {
        l.first_link = succ;
    }
    else
    {
        Link *p = l.first_link;
        while (p->succ != this)
        {
            p = p->succ;
        }
        p->succ = succ;
    }
    Link *ret = succ;
    succ = nullptr;
    return ret;
}

Link *Link::find(const List &l, const string &s)
{
    Link *p = l.first_link;
    while (p != nullptr)
    {
        if (p->value == s)
        {
            return p;
        }
        p = p->succ;
    }
    return nullptr;
}

const Link *Link::find(const List &l, const string &s) const
{
    const Link *p = l.first_link;
    while (p != nullptr)
    {
        if (p->value == s)
        {
            return p;
        }
        p = p->succ;
    }
    return nullptr;
}

Link *Link::advance(int n)
{
    Link *p = this;
    if (0 <= n)
    {
        while (n--)
        {
            if (p->succ == nullptr)
            {
                return nullptr;
            }
            p = p->succ;
        }
    }
    else
    {
        error("must advance by a number >= 0");
    }
    return p;
}

void print_all(const List &l)
{
    cout << "{ ";
    Link *p = l.first_link;
    while (p != nullptr)
    {
        cout << p->value;
        p = p->next();
        if (p != nullptr)
        {
            cout << ", ";
        }
    }
    cout << " }";
}

void delete_all(List &l)
{
    Link *p = l.first_link;
    while (p != nullptr)
    {
        Link *temp = p->next();
        delete p;
        p = temp;
    }
    l.first_link = nullptr;
}

int main()
{
    try
    {
        Link *norse_gods = new Link("Thor");
        List n_gods(norse_gods);
        norse_gods = norse_gods->insert(n_gods, new Link("Odin"));
        norse_gods = norse_gods->insert(n_gods, new Link("Zeus"));
        norse_gods = norse_gods->insert(n_gods, new Link("Freia"));

        Link *greek_gods = new Link("Hera");
        List g_gods(greek_gods);
        greek_gods = greek_gods->insert(g_gods, new Link("Athena"));
        greek_gods = greek_gods->insert(g_gods, new Link("Mars"));
        greek_gods = greek_gods->insert(g_gods, new Link("Poseidon"));

        print_all(n_gods);
        cout << "\n";

        print_all(g_gods);
        cout << "\n";

        Link *p = greek_gods->find(g_gods, "Mars");
        if (p != nullptr)
        {
            p->value = "Ares";
        }

        Link *p2 = norse_gods->find(n_gods, "Zeus");
        if (p2 != nullptr)
        {
            if (p2 == norse_gods)
            {
                norse_gods = p2->next();
            }
            p2->erase(n_gods);
            greek_gods->add(g_gods, p2);
            greek_gods = g_gods.first_link;
        }

        print_all(n_gods);
        cout << "\n";

        print_all(g_gods);
        cout << "\n";

        delete_all(n_gods);
        delete_all(g_gods);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
{ Freia, Zeus, Odin, Thor }
{ Poseidon, Mars, Athena, Hera }
{ Freia, Odin, Thor }
{ Poseidon, Zeus, Ares, Athena, Hera }

第18章 向量和数组
18.1 介绍
18.2 拷贝
18.2.1 拷贝构造函数
18.2.2 拷贝赋值
18.2.3 拷贝术语
18.3 必要的操作
18.3.1 显示构造函数
18.3.2 调试构造函数与析构函数
18.4 访问向量元素
18.4.1 对const对象重载运算符
18.5 数组
18.5.1 指向数组元素的指针
18.5.2 指针和数组
18.5.3 数组初始化
18.5.4 指针问题
18.6 实例：回文
18.6.1 使用string实现回文
18.6.2 使用数组实现回文
18.6.3 使用指针实现回文
ch18_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

const int gas = 10;
int ga[gas] = { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 };

void print_array(const int array[], int n)
{
    for (int i = 0; i < n; ++i)
    {
        cout << array[i] << " ";
    }
}

void f(int array[], int n)
{
    const int las = 10;
    int la[las];
    for (int i = 0; i < las; ++i)
    {
        la[i] = ga[i];
    }
    print_array(la, las);
    cout << "\n";
    int *p = new int[n];
    for (int i = 0; i < n; ++i)
    {
        p[i] = array[i];
    }
    print_array(p, n);
    cout << "\n";
    delete[] p;
}

int main()
{
    try
    {
        f(ga, gas);
        const int las = 10;
        int aa[las] = { 1 };
        for (int i = 1; i < las; ++i)
        {
            aa[i] = aa[i - 1] * (i + 1);
        }
        f(aa, las);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
1 2 4 8 16 32 64 128 256 512
1 2 4 8 16 32 64 128 256 512
1 2 4 8 16 32 64 128 256 512
1 2 6 24 120 720 5040 40320 362880 3628800

ch18_d02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

vector<int> gv = { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 };

void f(const vector<int> &v)
{
    vector<int> lv(gv);
    print_vector(lv, cout);
    vector<int> lv2(v);
    print_vector(lv2, cout);
}

int main()
{
    try
    {
        f(gv);
        vector<int> vv;
        vv.push_back(1);
        for (int i = 1; i < 10; ++i)
        {
            vv.push_back((i + 1)*vv[i - 1]);
        }
        f(vv);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
1, 2, 4, 8, 16, 32, 64, 128, 256, 512
1, 2, 4, 8, 16, 32, 64, 128, 256, 512
1, 2, 4, 8, 16, 32, 64, 128, 256, 512
1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800

ch18_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

char *strdupl(const char *s)
{
    if (s == nullptr)
    {
        return nullptr;
    }

    int n = 0;
    const char *p = s;
    while (*p != '\0')
    {
        ++n;
        p++;
    }

    char *s_cpy = new char[n + 1];

    char *s_cpy_ptr = s_cpy;
    while (*s != '\0')
    {
        *s_cpy_ptr++ = *s++;
    }
    *s_cpy_ptr = '\0';
    return s_cpy;
}


const char *findx(const char *s, const char *x)
{
    if (x == nullptr || *x == '\0')
    {
        return nullptr;
    }
    if (s == nullptr || *s == '\0')
    {
        return nullptr;
    }
    for (int i = 0; * (s + i) != '\0'; ++i)
    {
        if (*(s + i) == *x)
        {
            int j = 1;
            for (; * (x + j) != '\0'; ++j)
            {
                if (*(s + i + j) == '\0')
                {
                    return nullptr;
                }
                if (*(s + i + j) != *(x + j))
                {
                    break;
                }
            }
            if (*(x + j) == '\0')
            {
                return (s + i);
            }
        }
    }
    return nullptr;
}

int strcomp(const char *s1, const char *s2)
{
    if (s1 == nullptr || s2 == nullptr)
    {
        error("Null pointer sent to strcomp()");
    }
    for (int i = 0; ; ++i)
    {
        if (*(s1 + i) == '\0' && *(s2 + i) != '\0')
        {
            return -1;
        }
        else if (*(s1 + i) == '\0' && *(s2 + i) == '\0')
        {
            return 0;
        }
        else if (*(s1 + i) != '\0' && *(s2 + i) == '\0')
        {
            return 1;
        }
        else
        {
            if (*(s1 + i) < * (s2 + i))
            {
                return -1;
            }
            else if (*(s1 + i) > *(s2 + i))
            {
                return 1;
            }
        }
    }

    return 0;
}

void print_str(const char *s)
{
    if (s == nullptr)
    {
        error("Cannot print from null pointer");
    }
    while (*s != '\0')
    {
        cout << *s++;
    }
}

int main()
{
    try
    {
        char s[] = "Test";
        char *s_cpy = strdupl(s);
        print_str(s_cpy);
        cout << "\n";
        delete[] s_cpy;

        char s2[] = "This is a test phrase";
        char x[] = "test";
        cout << "s: " << s2 << "\n";
        cout << "x: " << x << "\n";
        print_str(findx(s2, x));
        cout << "\n";

        string a;
        string b;
        while (cin >> a && cin >> b)
        {
            int comp = strcomp(a.c_str(), b.c_str());
            switch (comp)
            {
            case -1:
                cout << a << " < " << b << "\n";
                break;
            case 0:
                cout << a << " == " << b << "\n";
                break;
            case 1:
                cout << a << " > " << b << "\n";
                break;
            default:
                error("invalid result returned by strcmp");
                break;
            }
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Test
s: This is a test phrase
x: test
test phrase
Hello World
Hello < World
hello World
hello > World
hello hello
hello == hello

ch18_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

char *strdupl(const char *s, int num_max)
{
    if (s == nullptr || num_max <= 0)
    {
        return nullptr;
    }

    int n = 0;
    const char *p = s;
    while (n < num_max && *p != '\0')
    {
        ++n;
        p++;
    }

    char *s_cpy = new char[n + 1];

    char *s_cpy_ptr = s_cpy;
    int i = 0;
    while (i < n && *s != '\0')
    {
        *s_cpy_ptr++ = *s++;
        ++i;
    }
    *s_cpy_ptr = '\0';
    return s_cpy;
}

const char *findx(const char *s, const char *x, int num_max_s, int num_max_x)
{
    if (x == nullptr || *x == '\0' || num_max_x <= 0)
    {
        return nullptr;
    }
    if (s == nullptr || *s == '\0' || num_max_s <= 0)
    {
        return nullptr;
    }
    for (int i = 0; i < num_max_s && * (s + i) != '\0'; ++i)
    {
        if (*(s + i) == *x)
        {
            int j = 1;
            for (; j < num_max_x && * (x + j) != '\0'; ++j)
            {
                if ( (i + j) >= num_max_s || *(s + i + j) == '\0')
                {
                    return nullptr;
                }
                if (*(s + i + j) != *(x + j))
                {
                    break;
                }
            }
            if (j >= num_max_x || *(x + j) == '\0')
            {
                return (s + i);
            }
        }
    }
    return nullptr;
}

int strcomp(const char *s1, const char *s2, int num_max_s1, int num_max_s2)
{
    if (s1 == nullptr || s2 == nullptr)
    {
        error("Null pointer sent to strcomp()");
    }
    if (num_max_s1 <= 0 || num_max_s2 <= 0)
    {
        error("num_max <= 0 sent to strcomp()");
    }
    int n = (num_max_s1 < num_max_s2 ? num_max_s1 : num_max_s2) + 1;
    for (int i = 0; i < n; ++i)
    {
        if ( ( i >= num_max_s1 || *(s1 + i) == '\0' ) && ( i < num_max_s2 && *(s2 + i) != '\0' ) )
        {
            return -1;
        }
        else if ( ( i >= num_max_s1 || *(s1 + i) == '\0' )  && ( i >= num_max_s2 || *(s2 + i) == '\0' ) )
        {
            return 0;
        }
        else if ( ( i < num_max_s1 && *(s1 + i) != '\0' )  && ( i >= num_max_s2 || *(s2 + i) == '\0' ) )
        {
            return 1;
        }
        else
        {
            if (*(s1 + i) < * (s2 + i))
            {
                return -1;
            }
            else if (*(s1 + i) > *(s2 + i))
            {
                return 1;
            }
        }
    }

    return 0;
}

void print_str(const char *s, int num_max)
{
    if (s == nullptr)
    {
        error("Cannot print from null pointer");
    }
    int i = 0;
    while (i < num_max && *s != '\0')
    {
        cout << *s++;
        ++i;
    }
}

int main()
{
    try
    {
        char a[] = "test";
        char *a_dpl = strdupl(a, 5);
        print_str(a_dpl, 5);
        cout << "\n";
        char b[] = { 't', 'e', 's', 't' };
        char *b_dpl = strdupl(b, 4);
        print_str(b_dpl, 4);
        cout << "\n";
        delete[] b_dpl;
        delete[] a_dpl;

        char s[] = "xxxtestxxx";
        char x[] = "test";
        const char *sub = findx(s, x, 11, 5);
        print_str(sub, 11);
        cout << "\n";
        char s2[] = { 'x', 'x', 't', 'e', 's', 't', 'x', 'x' };
        char x2[] = { 't', 'e', 's', 't' };
        const char *sub2 = findx(s2, x2, 8, 4);
        print_str(sub2, 6);
        cout << "\n";

        char str1[] = "atest";
        char str2[] = "btest";
        cout << str1 << " strcomp " << str2 << " is " << strcomp(str1, str2, 6, 6) << "\n";
        char str3[] = { 't', 'e', 's', 't', '1' };
        char str4[] = { 't', 'e', 's', 't', '1', 'a' };
        print_str(str3, 5);
        cout << " strcomp ";
        print_str(str4, 6);
        cout << " is " << strcomp(str3, str4, 5, 6) << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
test
test
testxxx
testxx
atest strcomp btest is -1
test1 strcomp test1a is -1

ch18_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

string cat_dot(const string &s1, const string &s2, const string &s3 = ".")
{
    return s1 + s3 + s2;
}

int main()
{
    try
    {
        cout << cat_dot("Niels", "Bohr") << "\n";
        cout << cat_dot("Niels", "Bohr", "dot") << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Niels.Bohr
NielsdotBohr

ch18_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

char *cat_dot(const char *s1, const char *s2)
{
    const char *p = s1;
    int ctr = 0;
    while (*p != '\0')
    {
        ++ctr;
        ++p;
    }
    p = s2;
    while (*p != '\0')
    {
        ++ctr;
        ++p;
    }

    char *res = new char[ctr + 2];

    p = s1;
    char *res_ptr = res;
    while (*p != '\0') { *res_ptr++ = *p++; }
    *res_ptr++ = '.';
    p = s2;
    while (*p != '\0') { *res_ptr++ = *p++; }
    *res_ptr = '\0';

    return res;
}

char *cat_dot2(const char *s1, const char *s2, const char *s3)
{
    const char *p = s1;
    int ctr = 0;
    while (*p != '\0')
    {
        ++ctr;
        ++p;
    }
    p = s2;
    while (*p != '\0')
    {
        ++ctr;
        ++p;
    }
    p = s3;
    while (*p != '\0')
    {
        ++ctr;
        ++p;
    }

    char *res = new char[ctr + 1];

    p = s1;
    char *res_ptr = res;
    while (*p != '\0') { *res_ptr++ = *p++; }
    p = s3;
    while (*p != '\0') { *res_ptr++ = *p++; }
    p = s2;
    while (*p != '\0') { *res_ptr++ = *p++; }
    *res_ptr = '\0';

    return res;
}

int main()
{
    try
    {
        char *res = cat_dot("Niels", "Bohr");
        cout << res << "\n";
        delete[] res;

        res = cat_dot2("Niels", "Bohr", " dot ");
        cout << res << "\n";
        delete[] res;

        char a[] = "Niels";
        char b[] = "Bohr";
        res = cat_dot(a, b);
        cout << res << "\n";
        delete[] res;

        const char *ap = "Niels";
        const char *bp = "Bohr";
        res = cat_dot(a, b);
        cout << res << "\n";
        delete[] res;

        char *as = new char[6];
        for (int i = 0; i < 6; ++i) { as[i] = ap[i]; }
        char *bs = new char[5];
        for (int i = 0; i < 5; ++i) { bs[i] = bp[i]; }
        res = cat_dot(as, bs);
        cout << res << "\n";
        delete[] res;
        delete[] bs;
        delete[] as;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Niels.Bohr
Niels dot Bohr
Niels.Bohr
Niels.Bohr
Niels.Bohr

ch18_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

bool is_palindrome(const string &s)
{
    string s_cp;
    for (int i = s.size() - 1; i >= 0; --i)
    {
        s_cp.push_back(s[i]);
    }
    if (s == s_cp)
    {
        return true;
    }
    return false;
}

bool is_palindrome(const char s[], int n)
{
    char *s_cp = new char[n + 1];
    s_cp[n] = 0;
    for (int i = 0; i < n; ++i)
    {
        s_cp[n - 1 - i] = s[i];
    }

    if (strcmp(s, s_cp))
    {
        delete[] s_cp;
        return false;
    }

    delete[] s_cp;
    return true;
}

bool is_palindrome(const char *first, const char *last)
{
    char *s_cp = new char[last - first + 2];
    char *s_cp_ptr = s_cp;
    while (last >= first)
    {
        *s_cp_ptr = *last;
        ++s_cp_ptr;
        --last;
    }
    *s_cp_ptr = '\0';

    if (strcmp(first, s_cp))
    {
        delete[] s_cp;
        return false;
    }

    delete[] s_cp;
    return true;
}

istream &read_word(istream &is, char *buffer, int max)
{
    is.getline(buffer, max);
    return is;
}

int main()
{
    try
    {
        string s;
        while (getline(cin, s, '\n') && s != "")
        {
            cout << s << " is";
            if (!is_palindrome(s))
            {
                cout << " not";
            }
            cout << " a palindrome\n";
        }

        const int max = 128;
        char s2[max];
        while (read_word(cin, s2, max) && strlen(s2) > 0)
        {
            cout << s2 <<  " is";
            if (!is_palindrome(s2, strlen(s2)))
            {
                cout << " not";
            }
            cout << " a palindrome\n";
        }

        while (read_word(cin, s2, max) && strlen(s2) > 0)
        {
            cout << s2 << " is";
            if (!is_palindrome(&s2[0], &s2[strlen(s2) - 1]))
            {
                cout << " not";
            }
            cout << " a palindrome\n";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
dffa
dffa is not a palindrome
dffaaffd
dffaaffd is a palindrome
EggE
EggE is a palindrome

Hello
Hello is not a palindrome

appa
appa is a palindrome

ch18_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

int a = 0;
int b = 0;
int c = 0;
int d = 0;
int e = 0;

int main()
{
    try
    {
        int *pa = &a;
        int *pb = &b;
        int *pc = &c;
        int *pd = &d;
        int *pe = &e;
        cout << pa << "\n" << pb << "\n" << pc << "\n" << pd << "\n" << pe << "\n";

        int sa = 0;
        int sb = 0;
        int sc = 0;
        int *psa = &sa;
        int *psb = &sb;
        int *psc = &sc;
        cout << "\n" << psa << "\n" << psb << "\n" << psc << "\n";

        int *ha = new int(0);
        int *hb = new int(0);
        int *hc = new int(0);
        cout << "\n" << ha << "\n" << hb << "\n" << hc << "\n";

        int *harr = new int[5];
        cout << "\n";
        for (int i = 0; i < 5; ++i)
        {
            cout << &harr[i] << "\n";
        }
        delete[] harr;
        delete hc;
        delete hb;
        delete ha;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
0x564fdf2032f4
0x564fdf2032f8
0x564fdf2032fc
0x564fdf203300
0x564fdf203304

0x7ffe4c343160
0x7ffe4c343164
0x7ffe4c343168

0x564fe0d3e2c0
0x564fe0d3e2e0
0x564fe0d3e300

0x564fe0d3e320
0x564fe0d3e324
0x564fe0d3e328
0x564fe0d3e32c
0x564fe0d3e330

ch18_p10.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

bool is_palindrome(const char s[], int n)
{
    int first = 0;
    int last = n - 1;
    while (first < last)
    {
        if (s[first] != s[last])
        {
            return false;
        }
        ++first;
        --last;
    }
    return true;
}

istream &read_word(istream &is, char *buffer, int max)
{
    char ch;
    is.get(buffer, max);
    is.clear();
    is.get(ch);
    if (ch != '\n')
    {
        if (strlen(buffer) > 0)
        {
            cout << "Input cut off after " << strlen(buffer) << " characters!\n";
        }
        while (is.get(ch) && ch != '\n')
        {
            continue;
        }
    }
    return is;
}

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char ch)
    {
        append(ch);
        return *this;
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = s;
    r.prepend(str, strlen(str));
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

int main()
{
    try
    {
        const int max = 8;
        char s[max];
        while (read_word(cin, s, max) && strlen(s) > 0)
        {
            cout << s <<  " is";
            if (!is_palindrome(s, strlen(s)))
            {
                cout << " not";
            }
            cout << " a palindrome\n";
        }

        Str_c s2;
        while (getline(cin, s2) && s2.size() > 0)
        {
            cout << s2 <<  " is";
            if (!is_palindrome(s2.c_str(), s2.size()))
            {
                cout << " not";
            }
            cout << " a palindrome\n";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Hello,World!
Input cut off after 7 characters!
Hello,W is not a palindrome

12345678987654321
12345678987654321 is a palindrome

ch18_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

class element
{
public:
    element(int k, int new_height) : key(k), next(new_height + 1) { }
    int key;
    vector<element *> next;
};

class skip_list
{
public:
    skip_list();
    element *find(int x);
    void insert(int x);
    void remove(int x);
    void print();
    void debug_print();
    int get_height()
    {
        return height;
    }
private:
    const int max_height = 128;
    const int infty = numeric_limits<int>::max();
    element head;
    element tail;
    int height;
    mt19937 engine;
};

skip_list::skip_list()
    : head(infty, max_height), tail(infty, max_height), height(0), engine( unsigned ( std::chrono::system_clock::now().time_since_epoch().count() ) )
{
    for (int i = 0; i < head.next.size(); ++i)
    {
        head.next[i] = &tail;
    }
}

element *skip_list::find(int x)
{
    element *p = &head;

    for (int i = height; i >= 0; --i)
    {
        while (p->next[i]->key < x)
        {
            p = p->next[i];
        }
    }

    p = p->next[0];
    if (p->key == x) { return p; }
    else { return nullptr; }
}

void skip_list::insert(int x)
{
    vector<element *> update(max_height + 1);
    element *p = &head;

    for (int i = height; i >= 0; --i)
    {
        while (p->next[i]->key < x)
        {
            p = p->next[i];
        }
        update[i] = p;
    }
    p = p->next[0];

    if (p->key == x) { return; }

    int new_height = nrand_two(0, max_height + 1, engine);
    if (new_height > height)
    {
        for (int i = height + 1; i <= new_height; ++i)
        {
            update[i] = &head;
        }
        height = new_height;
    }

    p = new element(x, new_height);

    for (int i = 0; i <= new_height; ++i)
    {
        p->next[i] = update[i]->next[i];
        update[i]->next[i] = p;
    }
}

void skip_list::remove(int x)
{
    vector<element *> update(max_height + 1);
    element *p = &head;
    for (int i = height; i >= 0; --i)
    {
        while (p->next[i]->key < x)
        {
            p = p->next[i];
        }
        update[i] = p;
    }
    p = p->next[0];

    if (p->key == x)
    {
        for (int i = 0; i < p->next.size(); ++i)
        {
            update[i]->next[i] = p->next[i];
        }
        while (height >= 1 && head.next[height] == &tail)
        {
            --height;
        }
        delete p;
    }
}

void skip_list::print()
{
    element *p = head.next[0];
    while (p != &tail)
    {
        cout << setw(5) << p->key;
        p = p->next[0];
    }
    cout << endl;
}

void skip_list::debug_print()
{
    for (int i = 0; i <= height; ++i)
    {
        element *p = head.next[i];
        cout << setw(3) << i << ": ";
        while (p != &tail)
        {
            cout << setw(3) << p->key << " ";
            p = p->next[i];
        }
        cout << endl;
    }
}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);
    try
    {
            skip_list sl;
            for (int i = 0; i < 30; ++i)
            {
                sl.insert(nrand_two(0, 100, engine));
            }
            sl.debug_print();
            cout << "Enter value to remove: ";
            int x;
            cin >> x;
            element *p = sl.find(x);
            if (p != nullptr)
            {
                cout << "p->key = " << p->key << endl;
                sl.remove(x);
                sl.debug_print();
            }
            else
            {
                cout << x << " is not found\n";
            }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
  0:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
  1:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
  2:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
  3:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
  4:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
  5:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
  6:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
  7:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
  8:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
  9:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
 10:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
 11:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
 12:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
 13:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  73  76  78  80  85  92  94
 14:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  80  85  92  94
 15:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  80  85  92  94
 16:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  80  85  92  94
 17:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  80  85  92  94
 18:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  80  85  92  94
 19:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  80  85  92  94
 20:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  80  85  92  94
 21:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  80  85  92  94
 22:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 23:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 24:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 25:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 26:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 27:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 28:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 29:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 30:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 31:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 32:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 33:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 34:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 35:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 36:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 37:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 38:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 39:  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 40:  14  15  24  25  26  27  35  38  40  43  44  48  51  53  59  65  76  78  85  92  94
 41:  14  15  24  25  26  35  38  40  43  44  48  51  53  59  65  76  78  85  94
 42:  14  15  24  25  26  35  38  40  43  44  48  51  53  59  65  76  78  85  94
 43:  14  15  24  25  26  35  38  40  43  44  48  51  53  59  65  76  78  85  94
 44:  14  15  24  25  26  35  38  40  43  44  48  51  53  59  65  76  78  85  94
 45:  14  15  24  25  26  35  38  40  43  44  48  51  53  59  65  76  78  85  94
 46:  14  15  24  25  26  35  38  40  43  44  48  51  53  59  65  76  78  85  94
 47:  14  15  24  25  26  35  38  40  43  44  48  51  53  59  65  76  78  85  94
 48:  14  15  24  25  26  35  38  40  43  44  51  53  59  65  76  78  85  94
 49:  14  15  24  25  26  35  38  40  43  44  51  53  59  65  76  78  85  94
 50:  14  15  24  25  26  35  38  40  43  44  51  53  59  65  76  78  85  94
 51:  14  15  24  25  26  35  38  40  43  44  51  53  59  65  76  78  85  94
 52:  14  15  24  25  26  35  38  40  43  44  51  53  59  65  76  78  85  94
 53:  14  15  24  25  26  35  38  40  43  51  53  59  65  76  78  85  94
 54:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85  94
 55:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85  94
 56:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85  94
 57:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 58:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 59:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 60:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 61:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 62:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 63:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 64:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 65:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 66:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 67:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 68:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 69:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 70:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 71:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 72:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 73:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 74:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 75:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 76:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 77:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 78:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 79:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 80:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 81:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 82:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 83:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 84:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 85:  15  24  25  26  35  38  43  51  53  65  76  78  85
 86:  15  24  25  26  35  38  43  51  53  65  76  78  85
 87:  15  24  25  26  35  38  43  51  53  65  76  78  85
 88:  15  24  25  26  35  38  43  51  53  65  76  78  85
 89:  15  24  25  35  38  43  51  65  76  78  85
 90:  15  24  25  35  38  43  51  65  76  85
 91:  15  24  25  35  38  43  51  65  76  85
 92:  15  24  25  35  38  43  51  65  76  85
 93:  15  24  25  35  38  43  51  65  76  85
 94:  15  24  25  35  38  43  65  76  85
 95:  15  24  25  35  38  43  65  76  85
 96:  15  24  25  35  38  43  65  76  85
 97:  15  24  25  35  38  43  65  76  85
 98:  15  24  25  35  38  43  65  76  85
 99:  15  24  25  35  38  43  65  85
100:  15  24  25  35  38  43  65  85
101:  15  24  25  35  38  43  65  85
102:  15  24  35  38  43  65  85
103:  15  24  35  38  43  65  85
104:  24  35  38  65  85
105:  24  35  38  65  85
106:  24  35  38  65  85
107:  24  35  38  65  85
108:  24  35  38  65  85
109:  24  35  38  65  85
110:  24  35  38  65  85
111:  24  35  38  65
112:  24  35  38  65
113:  24  35  38  65
114:  24  38  65
115:  38  65
116:  38
117:  38
118:  38
119:  38
120:  38
121:  38
122:  38
Enter value to remove: 59
p->key = 59
  0:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
  1:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
  2:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
  3:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
  4:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
  5:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
  6:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
  7:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
  8:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
  9:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
 10:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
 11:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
 12:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
 13:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  73  76  78  80  85  92  94
 14:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  80  85  92  94
 15:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  80  85  92  94
 16:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  80  85  92  94
 17:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  80  85  92  94
 18:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  80  85  92  94
 19:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  80  85  92  94
 20:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  80  85  92  94
 21:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  80  85  92  94
 22:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 23:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 24:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 25:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 26:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 27:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 28:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 29:   6  14  15  24  25  26  27  31  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 30:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 31:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 32:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 33:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 34:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 35:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 36:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 37:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 38:   6  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 39:  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 40:  14  15  24  25  26  27  35  38  40  43  44  48  51  53  65  76  78  85  92  94
 41:  14  15  24  25  26  35  38  40  43  44  48  51  53  65  76  78  85  94
 42:  14  15  24  25  26  35  38  40  43  44  48  51  53  65  76  78  85  94
 43:  14  15  24  25  26  35  38  40  43  44  48  51  53  65  76  78  85  94
 44:  14  15  24  25  26  35  38  40  43  44  48  51  53  65  76  78  85  94
 45:  14  15  24  25  26  35  38  40  43  44  48  51  53  65  76  78  85  94
 46:  14  15  24  25  26  35  38  40  43  44  48  51  53  65  76  78  85  94
 47:  14  15  24  25  26  35  38  40  43  44  48  51  53  65  76  78  85  94
 48:  14  15  24  25  26  35  38  40  43  44  51  53  65  76  78  85  94
 49:  14  15  24  25  26  35  38  40  43  44  51  53  65  76  78  85  94
 50:  14  15  24  25  26  35  38  40  43  44  51  53  65  76  78  85  94
 51:  14  15  24  25  26  35  38  40  43  44  51  53  65  76  78  85  94
 52:  14  15  24  25  26  35  38  40  43  44  51  53  65  76  78  85  94
 53:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85  94
 54:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85  94
 55:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85  94
 56:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85  94
 57:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 58:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 59:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 60:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 61:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 62:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 63:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 64:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 65:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 66:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 67:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 68:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 69:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 70:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 71:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 72:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 73:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 74:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 75:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 76:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 77:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 78:  14  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 79:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 80:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 81:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 82:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 83:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 84:  15  24  25  26  35  38  40  43  51  53  65  76  78  85
 85:  15  24  25  26  35  38  43  51  53  65  76  78  85
 86:  15  24  25  26  35  38  43  51  53  65  76  78  85
 87:  15  24  25  26  35  38  43  51  53  65  76  78  85
 88:  15  24  25  26  35  38  43  51  53  65  76  78  85
 89:  15  24  25  35  38  43  51  65  76  78  85
 90:  15  24  25  35  38  43  51  65  76  85
 91:  15  24  25  35  38  43  51  65  76  85
 92:  15  24  25  35  38  43  51  65  76  85
 93:  15  24  25  35  38  43  51  65  76  85
 94:  15  24  25  35  38  43  65  76  85
 95:  15  24  25  35  38  43  65  76  85
 96:  15  24  25  35  38  43  65  76  85
 97:  15  24  25  35  38  43  65  76  85
 98:  15  24  25  35  38  43  65  76  85
 99:  15  24  25  35  38  43  65  85
100:  15  24  25  35  38  43  65  85
101:  15  24  25  35  38  43  65  85
102:  15  24  35  38  43  65  85
103:  15  24  35  38  43  65  85
104:  24  35  38  65  85
105:  24  35  38  65  85
106:  24  35  38  65  85
107:  24  35  38  65  85
108:  24  35  38  65  85
109:  24  35  38  65  85
110:  24  35  38  65  85
111:  24  35  38  65
112:  24  35  38  65
113:  24  35  38  65
114:  24  38  65
115:  38  65
116:  38
117:  38
118:  38
119:  38
120:  38
121:  38
122:  38

第19章向量、模板和异常
19.1 问题
19.2 改变向量大小
19.2.1 方法描述
19.2.2 reserve和capacity
19.2.3 resize
19.2.4 puah_back
19.2.5 赋值
19.2.6 到现在为止我们设计的vector类
19.3 模板
19.3.1 类型作为模板参数
19.3.2 泛型编程
19.3.3 容器和继承
19.3.4 整底魑模板⑹
19.3.5 模板参数推导
19.3.6 ―般化vector类
19.4 范围检查和异常
19.4.1 附加讨论：设计上的考虑
19.4.2 使用宏
19.5 资源和异常
19.5.1 潜在的资源管理问题
19.5.2 资源获取即初始化
19.5.3 保证
19.5.4 auto_ptr
19.5.5 vector类的RAII
ch19_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
class S
{
public:
    S() : val(T()) { }
    S(const T &d) : val(d) { }
    T &operator=(const T &d)
    {
        val = d;
        return val;
    }
    T &get()
    {
        return val;
    }
    const T &get() const
    {
        return val;
    }
    void set(const T &d)
    {
        val = d;
    }
private:
    T val;
};

template<typename T>
istream &operator>>(istream &is, S<T> &ss)
{
    T v;
    cin >> v;
    if (!is)
    {
        return is;
    }
    ss.set(v);
    return is;
}

template<typename T>
void read_val(T &v)
{
    cin >> v;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &d)
{
    os << "{ ";
    for (int i = 0; i < d.size(); ++i)
    {
        os << d[i];
        if (i < d.size() - 1)
        {
            os << ", ";
        }
    }
    os << " }";
    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (cin >> temp && cin >> ch2 && ch2 == ',')
    {
        v_temp.push_back(temp);
    }
    if (ch2 != '}')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    v_temp.push_back(temp);

    d = v_temp;
    return is;
}

int main()
{
    try
    {
        S<int> s_int(5);
        S<char> s_char('x');
        S<double> s_dbl(3.14);
        S<string> s_strg("Hello,World!");
        vector<int> vec;
        vec.push_back(1);
        vec.push_back(2);
        vec.push_back(3);
        S< vector<int> > s_vec_int(vec);

        cout << "s_int: " << s_int.get() << "\n";
        cout << "s_char: " << s_char.get() << "\n";
        cout << "s_dbl: " << s_dbl.get() << "\n";
        cout << "s_strg: " << s_strg.get() << "\n";
        for (int i = 0; i < s_vec_int.get().size(); ++i)
        {
            cout << "s_vec_int[" << i << "]: " << s_vec_int.get()[i] << "\n";
        }
        cout << s_vec_int.get() << "\n";

        s_int.set(55);
        s_char.set('y');
        s_dbl.set(4.14);
        s_strg.set("Peter Smith");
        vec[1] = 22;
        s_vec_int.set(vec);
        cout << "\ns_int: " << s_int.get() << "\n";
        cout << "s_char: " << s_char.get() << "\n";
        cout << "s_dbl: " << s_dbl.get() << "\n";
        cout << "s_strg: " << s_strg.get() << "\n";
        for (int i = 0; i < s_vec_int.get().size(); ++i)
        {
            cout << "s_vec_int[" << i << "]: " << s_vec_int.get()[i] << "\n";
        }
        cout << s_vec_int.get() << "\n";

        s_int = 66;
        s_char = 'z';
        s_dbl = 5.14;
        s_strg = "Mike Pence";
        vec[1] = 33;
        s_vec_int = vec;
        cout << "\ns_int: " << s_int.get() << "\n";
        cout << "s_char: " << s_char.get() << "\n";
        cout << "s_dbl: " << s_dbl.get() << "\n";
        cout << "s_strg: " << s_strg.get() << "\n";
        for (int i = 0; i < s_vec_int.get().size(); ++i)
        {
            cout << "s_vec_int[" << i << "]: " << s_vec_int.get()[i] << "\n";
        }
        cout << s_vec_int.get() << "\n";

        const S<int> c_s_int(5);
        cout << "\nc_s_int: " << c_s_int.get() << "\n";

        cout << "\ns_int: ";
        read_val(s_int);
        cout << "s_char: ";
        read_val(s_char);
        cout << "s_dbl: ";
        read_val(s_dbl);
        cout << "s_strg: ";
        read_val(s_strg);
        cout << "\ns_int: " << s_int.get() << "\n";
        cout << "s_char: " << s_char.get() << "\n";
        cout << "s_dbl: " << s_dbl.get() << "\n";
        cout << "s_strg: " << s_strg.get() << "\n\n";

        cout << "\ns_vec_int: ";
        read_val(s_vec_int);
        cout << "\ns_vec_int: " << s_vec_int.get() << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
s_int: 5
s_char: x
s_dbl: 3.14
s_strg: Hello,World!
s_vec_int[0]: 1
s_vec_int[1]: 2
s_vec_int[2]: 3
{ 1, 2, 3 }

s_int: 55
s_char: y
s_dbl: 4.14
s_strg: Peter Smith
s_vec_int[0]: 1
s_vec_int[1]: 22
s_vec_int[2]: 3
{ 1, 22, 3 }

s_int: 66
s_char: z
s_dbl: 5.14
s_strg: Mike Pence
s_vec_int[0]: 1
s_vec_int[1]: 33
s_vec_int[2]: 3
{ 1, 33, 3 }

c_s_int: 5

s_int: 9
s_char: j
s_dbl: 9.99
s_strg: Water

s_int: 9
s_char: j
s_dbl: 9.99
s_strg: Water


s_vec_int: { 1, 2, 3, 4, 5, 6 }

s_vec_int: { 1, 2, 3, 4, 5, 6 }

ch19_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
void f(vector<T> &v1, const vector<T> &v2)
{
    for (int i = 0; i < v1.size(); ++i)
    {
        if (i == v2.size())
        {
            break;
        }
        v1[i] += v2[i];
    }
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

int main()
{
    try
    {
        vector<int> v1;
        for (int i = 0; i < 10; ++i)
        {
            v1.push_back(i);
        }
        cout << "v1: " << v1 << "\n";
        vector<int> v2;
        for (int i = 0; i < 8; ++i)
        {
            v2.push_back(i);
        }
        cout << "v2: " << v2 << "\n";
        f(v1, v2);
        cout << "After: " << v1 << "\n\n";

        v2.push_back(15);
        v2.push_back(16);
        v2.push_back(17);
        cout << "New v2: " << v2 << "\n";
        f(v1, v2);
        cout << "After: " << v1 << "\n\n";

        vector<string> vs1;
        vs1.push_back("one");
        vs1.push_back("two");
        vs1.push_back("three");
        vs1.push_back("four");
        cout << "vs1: " << vs1 << "\n";
        vector<string> vs2;
        vs2.push_back(" ONE");
        vs2.push_back(" TWO");
        vs2.push_back(" THREE");
        cout << "vs2: " << vs2 << "\n";
        f(vs1, vs2);
        cout << "After: " << vs1 << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
v1: { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
v2: { 0, 1, 2, 3, 4, 5, 6, 7 }
After: { 0, 2, 4, 6, 8, 10, 12, 14, 8, 9 }

New v2: { 0, 1, 2, 3, 4, 5, 6, 7, 15, 16, 17 }
After: { 0, 3, 6, 9, 12, 15, 18, 21, 23, 25 }

vs1: { one, two, three, four }
vs2: {  ONE,  TWO,  THREE }
After: { one ONE, two TWO, three THREE, four }

ch19_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T, typename U>
typename common_type<T, U>::type f(const vector<T> &vt, const vector<U> &vu)
{
    typename common_type<T, U>::type sum = 0;
    int min_size = vt.size() <= vu.size() ? vt.size() : vu.size();
    for (int i = 0; i < min_size; ++i)
    {
        sum += vt[i] * vu[i];
    }
    return sum;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

int main()
{
    try
    {
        vector<int> v1;
        for (int i = 0; i < 10; ++i)
        {
            v1.push_back(i);
        }
        cout << "v1: " << v1 << "\n";
        vector<double> v2;
        for (int i = 0; i < 8; ++i)
        {
            v2.push_back(i * 1.6);
        }
        cout << "v2: " << v2 << "\n";
        cout << "f(v1,v2): " << f(v1, v2) << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
v1: { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
v2: { 0, 1.6, 3.2, 4.8, 6.4, 8, 9.6, 11.2 }
f(v1,v2): 224

ch19_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T, typename U>
class Pair
{
public:
    Pair(const T &vt, const U &vu) : val1(vt), val2(vu) { }
    T val1;
    U val2;
};

class Symbol_table
{
public:
    double get(const string &s);
    void set(const string &s, double d);
    bool is_declared(const string &s);
    double declare(const string &s, double val);
    void print();
private:
    vector< Pair<string, double> > var_table;
};

double Symbol_table::get(const string &s)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].val1 == s) { return var_table[i].val2; }
    }
    error("Variable not found: " + s);
}

void Symbol_table::set(const string &s, double d)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].val1 == s)
        {
            var_table[i].val2 = d;
            return;
        }
    }
    error("Variable not found: " + s);
}

bool Symbol_table::is_declared(const string &s)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].val1 == s) { return true; }
    }
    return false;
}

double Symbol_table::declare(const string &s, double d)
{
    if (is_declared(s)) { error("Variable exists already: " + s); }
    var_table.push_back(Pair<string, double>(s, d));
    return d;
}

void Symbol_table::print()
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        cout << var_table[i].val1 << ": " << var_table[i].val2 << "\n";
    }
}

int main()
{
    try
    {
        Symbol_table st;
        st.declare("Pi", 3.14);
        st.declare("e", 2.72);
        st.print();
        cout << "Pi is " << st.get("Pi") << "\n";
        if (st.is_declared("Pi"))
        {
            cout << "Pi is declared\n";
        }
        else
        {
            cout << "Pi is not declared\n";
        }
        if (st.is_declared("nd"))
        {
            cout << "nd is declared\n";
        }
        else
        {
            cout << "nd is not declared\n";
        }
        st.set("Pi", 4.14);
        cout << "Pi is now " << st.get("Pi") << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Pi: 3.14
e: 2.72
Pi is 3.14
Pi is declared
nd is not declared
Pi is now 4.14

ch19_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

class God
{
public:
    God(const string &n = "", const string &m = "", const string &v = "", const string &w = "")
        : name(n), mythology(m), vehicle(v), weapon(w) { }
    string name;
    string mythology;
    string vehicle;
    string weapon;
};

ostream &operator<<(ostream &os, const God &g)
{
    os << g.name << ": " << g.mythology << ", "
       << g.vehicle << ", " << g.weapon;
    return os;
}

bool operator==(const God &g1, const God &g2)
{
    return (g1.name == g2.name && g1.mythology == g2.mythology
            && g1.vehicle == g2.vehicle && g1.weapon == g2.weapon);
}

bool operator!=(const God &g1, const God &g2)
{
    return !(g1 == g2);
}

bool operator<(const God &g1, const God &g2)
{
    return g1.name < g2.name;
}

bool operator>(const God &g1, const God &g2)
{
    return g2 < g1;
}

bool operator<=(const God &g1, const God &g2)
{
    return !(g1 > g2);
}

bool operator>=(const God &g1, const God &g2)
{
    return !(g1 < g2);
}

template<typename T>
class Link
{
private:
    Link<T> *prev;
    Link<T> *succ;
public:
    T value;
    Link(const T &v = T(), Link<T> *p = nullptr, Link<T> *s = nullptr) : value(v), prev(p), succ(s) { }

    Link<T> *insert(Link<T> *n);
    Link<T> *add(Link<T> *n);
    Link<T> *add_ordered(Link<T> *n);
    Link<T> *erase();
    Link<T> *find(const T &v);

    Link<T> *advance(int n);

    Link<T> *next() const
    {
        return succ;
    }
    Link<T> *previous() const
    {
        return prev;
    }
    void print_all();
};

template<typename T>
Link<T> *Link<T>::insert(Link<T> *n)
{
    if (n == nullptr)
    {
        return n;
    }
    n->succ = this;
    if (prev != nullptr)
    {
        prev->succ = n;
    }
    n->prev = prev;
    prev = n;
    return n;
}

template<typename T>
Link<T> *Link<T>::add(Link<T> *n)
{
    if (n == nullptr)
    {
        return n;
    }
    n->prev = this;
    if (succ != nullptr)
    {
        succ->prev = n;
    }
    n->succ = succ;
    succ = n;
    return n;
}

template<typename T>
Link<T> *Link<T>::add_ordered(Link<T> *n)
{
    if (n == nullptr)
    {
        return n;
    }
    if (n->value < value)
    {
        Link<T> *p = insert(n);
        return p;
    }
    Link<T> *p = this;
    while (n->value >= p->value)
    {
        if (p->succ == nullptr)
        {
            p->add(n);
            return this;
        }
        p = p->succ;
    }
    p->insert(n);
    return this;
}

template<typename T>
Link<T> *Link<T>::erase()
{
    if (succ != nullptr)
    {
        succ->prev = prev;
    }
    if (prev != nullptr)
    {
        prev->succ = succ;
    }
    Link<T> *ret = succ;
    succ = nullptr;
    prev = nullptr;
    return ret;
}

template<typename T>
Link<T> *Link<T>::find(const T &v)
{
    Link<T> *p = this;
    while (p != nullptr)
    {
        if (p->value == v)
        {
            return p;
        }
        p = p->succ;
    }
    return nullptr;
}

template<typename T>
Link<T> *Link<T>::advance(int n)
{
    Link<T> *p = this;
    if (0 < n)
    {
        while (n--)
        {
            if (p->succ == nullptr)
            {
                return nullptr;
            }
            p = p->succ;
        }
    }
    else if (n < 0)
    {
        while (n++)
        {
            if (p->prev == nullptr)
            {
                return nullptr;
            }
            p = p->prev;
        }
    }
    return p;
}

template<typename T>
void Link<T>::print_all()
{
    Link<T> *p = this;
    while (p != nullptr)
    {
        cout << p->value << "\n";
        p = p->succ;
    }
}

template<typename T>
void delete_all(Link<T> *p)
{
    while (p != nullptr)
    {
        Link<T> *temp = p->next();
        delete p;
        p = temp;
    }
}

template<typename T>
Link<T> *extract(Link<T> **l, const T &v)
{
    if ( (*l) == nullptr )
    {
        return nullptr;
    }
    Link<T> *p = (*l)->find(v);
    if (p != nullptr)
    {
        if (p == (*l))
        {
            (*l) = p->next();
        }
        p->erase();
        return p;
    }
    return nullptr;
}

template<typename T>
void move(Link<T>*&from, Link<T>*&to, const T &v)
{
    Link<T> *temp = extract<T>(&from, v);
    if (temp != nullptr)
    {
        to = to->add_ordered(temp);
    }
}

int main()
{
    try
    {
        Link<God> *all_gods = new Link<God>(God("Thor", "Norse", "Pinzgauer", "Hammer"));
        all_gods = all_gods->insert(new Link<God>(God("Odin", "Norse", "Eight-legged horse", "")));
        all_gods = all_gods->insert(new Link<God>(God("Zeus", "Greek", "", "Lightning")));
        all_gods = all_gods->insert(new Link<God>(God("Freia", "Norse", "F-transport", "F-weapon")));
        all_gods = all_gods->insert(new Link<God>(God("Hera", "Greek", "H-transport", "Spear")));
        all_gods = all_gods->insert(new Link<God>(God("Athena", "Greek", "A-transport", "A-weapon")));
        all_gods = all_gods->insert(new Link<God>(God("Mars", "Roman", "M-transport", "M-weapon")));
        all_gods = all_gods->insert(new Link<God>(God("Poseidon", "Greek", "Seahorse", "Trident")));
        all_gods = all_gods->insert(new Link<God>(God("Ares", "Greek", "A-transport", "A-weapon")));
        all_gods = all_gods->insert(new Link<God>(God("Vesuvius", "Roman", "V-transport", "Volcano")));
        all_gods = all_gods->insert(new Link<God>(God("Bacchus", "Roman", "Stretcher", "Wine goblet")));

        all_gods->print_all();

        Link<God> *norse_gods = extract<God>(&all_gods, God("Odin", "Norse", "Eight-legged horse", ""));
        move<God>(all_gods, norse_gods, God("Thor", "Norse", "Pinzgauer", "Hammer"));
        move<God>(all_gods, norse_gods, God("Freia", "Norse", "F-transport", "F-weapon"));

        Link<God> *greek_gods = extract<God>(&all_gods, God("Hera", "Greek", "H-transport", "Spear"));
        move<God>(all_gods, greek_gods, God("Athena", "Greek", "A-transport", "A-weapon"));
        move<God>(all_gods, greek_gods, God("Poseidon", "Greek", "Seahorse", "Trident"));
        move<God>(all_gods, greek_gods, God("Zeus", "Greek", "", "Lightning"));
        move<God>(all_gods, greek_gods, God("Ares", "Greek", "A-transport", "A-weapon"));

        Link<God> *roman_gods = extract<God>(&all_gods, God("Mars", "Roman", "M-transport", "M-weapon"));
        move<God>(all_gods, roman_gods, God("Vesuvius", "Roman", "V-transport", "Volcano"));
        move<God>(all_gods, roman_gods, God("Bacchus", "Roman", "Stretcher", "Wine goblet"));

        cout << "\nNorse gods:\n";
        norse_gods->print_all();
        cout << "\nGreek gods:\n";
        greek_gods->print_all();
        cout << "\nRoman gods:\n";
        roman_gods->print_all();

        delete_all<God>(norse_gods);
        delete_all<God>(greek_gods);
        delete_all<God>(roman_gods);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Bacchus: Roman, Stretcher, Wine goblet
Vesuvius: Roman, V-transport, Volcano
Ares: Greek, A-transport, A-weapon
Poseidon: Greek, Seahorse, Trident
Mars: Roman, M-transport, M-weapon
Athena: Greek, A-transport, A-weapon
Hera: Greek, H-transport, Spear
Freia: Norse, F-transport, F-weapon
Zeus: Greek, , Lightning
Odin: Norse, Eight-legged horse,
Thor: Norse, Pinzgauer, Hammer

Norse gods:
Freia: Norse, F-transport, F-weapon
Odin: Norse, Eight-legged horse,
Thor: Norse, Pinzgauer, Hammer

Greek gods:
Ares: Greek, A-transport, A-weapon
Athena: Greek, A-transport, A-weapon
Hera: Greek, H-transport, Spear
Poseidon: Greek, Seahorse, Trident
Zeus: Greek, , Lightning

Roman gods:
Bacchus: Roman, Stretcher, Wine goblet
Mars: Roman, M-transport, M-weapon
Vesuvius: Roman, V-transport, Volcano

ch19_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

class Int
{
private:
    int val;
public:
    Int() : val(0) { }
    Int(int v) : val(v) { }
    Int(const Int &arg) : val(arg.val) { }
    Int &operator=(const Int &arg)
    {
        val = arg.val;
        return *this;
    }
    int get() const
    {
        return val;
    }
};

Int operator+(const Int &v1, const Int &v2)
{
    return Int(v1.get() + v2.get());
}

Int operator-(const Int &v1, const Int &v2)
{
    return Int(v1.get() - v2.get());
}

Int operator*(const Int &v1, const Int &v2)
{
    return Int(v1.get() * v2.get());
}

Int operator/(const Int &v1, const Int &v2)
{
    return Int(v1.get() / v2.get());
}

ostream &operator<<(ostream &os, const Int &v)
{
    os << v.get();
    return os;
}

int main()
{
    try
    {
        Int i1;
        Int i2 = 2;
        Int i3(i2);
        Int i4;
        i4 = i2;
        Int i5 = 6;
        cout << "i1 (default constructed): " << i1 << "\n";
        cout << "i2 (constructed with argument): " << i2 << "\n";
        cout << "i3 (copy constructed from i2): " << i3 << "\n";
        cout << "i4 (copy assigned  from i2): " << i4 << "\n";
        cout << "i5 (constructed with argument): " << i5 << "\n";
        cout << "i2 + i5 = " << i2 + i5 << "\n";
        cout << "i5 - i2 = " << i5 - i2 << "\n";
        cout << "i2 * i5 = " << i2 *i5 << "\n";
        cout << "i5 / i2 = " << i5 / i2 << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
i1 (default constructed): 0
i2 (constructed with argument): 2
i3 (copy constructed from i2): 2
i4 (copy assigned  from i2): 2
i5 (constructed with argument): 6
i2 + i5 = 8
i5 - i2 = 4
i2 * i5 = 12
i5 / i2 = 3

ch19_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
class Number
{
private:
    T val;
public:
    Number() : val(T()) { }
    Number(const T &v) : val(v) { }
    Number(const Number<T> &arg) : val(arg.val) { }
    Number &operator=(const Number<T> &arg)
    {
        if (this == &arg) { return *this; }
        val = arg.val;
        return *this;
    }
    T & get()
    {
        return val;
    }
    const T & get() const
    {
        return val;
    }
};

template<typename T>
Number<T> operator+(const Number<T> &v1, const Number<T> &v2)
{
    return Number<T>(v1.get() + v2.get());
}

template<typename T>
Number<T> operator-(const Number<T> &v1, const Number<T> &v2)
{
    return Number<T>(v1.get() - v2.get());
}

template<typename T>
Number<T> operator*(const Number<T> &v1, const Number<T> &v2)
{
    return Number<T>(v1.get() * v2.get());
}

template<typename T>
Number<T> operator/(const Number<T> &v1, const Number<T> &v2)
{
    return Number<T>(v1.get() / v2.get());
}

template<typename T>
Number<T> operator%(const Number<T> &v1, const Number<T> &v2)
{
    return Number<T>(v1.get() % v2.get());
}

template<class T>
ostream &operator<<(ostream &os, const Number<T> &v)
{
    os << v.get();
    return os;
}

int main()
{
    try
    {
        cout << "int:\n";
        Number<int> i1;
        Number<int> i2 = 2;
        Number<int> i3(i2);
        Number<int> i4;
        i4 = i2;
        Number<int> i5 = 5;
        cout << "i1 (default constructed): " << i1 << "\n";
        cout << "i2 (constructed with argument): " << i2 << "\n";
        cout << "i3 (copy constructed from i2): " << i3 << "\n";
        cout << "i4 (copy assigned  from i2): " << i4 << "\n";
        cout << "i5 (constructed with argument): " << i5 << "\n";
        cout << "i2 + i5 = " << i2 + i5 << "\n";
        cout << "i5 - i2 = " << i5 - i2 << "\n";
        cout << "i2 * i5 = " << i2 *i5 << "\n";
        cout << "i5 / i2 = " << i5 / i2 << "\n";
        cout << "i5 % i2 = " << i5 % i2 << "\n";

        cout << "\ndouble:\n";
        Number<double> d1;
        Number<double> d2 = 2.2;
        Number<double> d3(d2);
        Number<double> d4;
        d4 = d2;
        Number<double> d5 = 5.5;
        cout << "d1 (default constructed): " << d1 << "\n";
        cout << "d2 (constructed with argument): " << d2 << "\n";
        cout << "d3 (copy constructed from d2): " << d3 << "\n";
        cout << "d4 (copy assigned  from d2): " << d4 << "\n";
        cout << "d5 (constructed with argument): " << d5 << "\n";
        cout << "d2 + d5 = " << d2 + d5 << "\n";
        cout << "d5 - d2 = " << d5 - d2 << "\n";
        cout << "d2 * d5 = " << d2 *d5 << "\n";
        cout << "d5 / d2 = " << d5 / d2 << "\n";

        cout << "\nchar:\n";
        Number<char> c1;
        Number<char> c2 = 'x';
        Number<char> c3(c2);
        Number<char> c4;
        c4 = c2;
        Number<char> c5 = 'C';
        cout << "c1 (default constructed): " << c1 << "\n";
        cout << "c2 (constructed with argument): " << c2 << "\n";
        cout << "c3 (copy constructed from c2): " << c3 << "\n";
        cout << "c4 (copy assigned  from c2): " << c4 << "\n";
        cout << "c5 (constructed with argument): " << c5 << "\n";

        cout << "\nstring:\n";
        Number<string> s1;
        Number<string> s2("xxx");
        Number<string> s3(s2);
        Number<string> s4;
        s4 = s2;
        Number<string> s5("ABCD!");
        cout << "s1 (default constructed): " << s1 << "\n";
        cout << "s2 (constructed with argument): " << s2 << "\n";
        cout << "s3 (copy constructed from s2): " << s3 << "\n";
        cout << "s4 (copy assigned  from s2): " << s4 << "\n";
        cout << "s5 (constructed with argument): " << s5 << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
int:
i1 (default constructed): 0
i2 (constructed with argument): 2
i3 (copy constructed from i2): 2
i4 (copy assigned  from i2): 2
i5 (constructed with argument): 5
i2 + i5 = 7
i5 - i2 = 3
i2 * i5 = 10
i5 / i2 = 2
i5 % i2 = 1

double:
d1 (default constructed): 0
d2 (constructed with argument): 2.2
d3 (copy constructed from d2): 2.2
d4 (copy assigned  from d2): 2.2
d5 (constructed with argument): 5.5
d2 + d5 = 7.7
d5 - d2 = 3.3
d2 * d5 = 12.1
d5 / d2 = 2.5

char:
c1 (default constructed):
c2 (constructed with argument): x
c3 (copy constructed from c2): x
c4 (copy assigned  from c2): x
c5 (constructed with argument): C

string:
s1 (default constructed):
s2 (constructed with argument): xxx
s3 (copy constructed from s2): xxx
s4 (copy assigned  from s2): xxx
s5 (constructed with argument): ABCD!

ch19_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it++);
            alloc.destroy(pos);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() { }
    Str(size_type n, char c) : data(n, c) { }
    Str(const char *cp)
    {
        copy(cp, cp + strlen(cp), back_inserter(data));
    }

    template<typename In>
    Str(In b, In e) : data(b, e) { }

    size_type size() const
    {
        return data.size();
    }

    char &operator[](size_type i)
    {
        return data[i];
    }
    const char &operator[](size_type i) const
    {
        return data[i];
    }

    Str &operator+=(const Str &s)
    {
        copy(s.data.begin(), s.data.end(), back_inserter(data));
        return *this;
    }

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        data.insert(position, first, last);
    };

    iterator begin()
    {
        return data.begin();
    };
    const_iterator begin() const
    {
        return data.begin();
    };
    iterator end()
    {
        return data.end();
    };
    const_iterator end() const
    {
        return data.end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data.clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data.push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }
    friend ostream &operator<<(ostream &os, const Str &s)
    {
        for (size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }
    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Vec<char> data;
};

int main()
{
    try
    {
        Str s = "A lonesome string.";

        Vec<char> v(s.begin(), s.end());

        for (size_t i = 0; i < v.size(); i++)
        {
            cout << v[i];
        }
        cout << endl;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
A lonesome string.

ch19_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
T *clone(const T *tp)
{
    return tp->clone()
}

template<typename T>
class Ptr
{
public:
    Ptr() : refptr(new size_t(1)), p(nullptr) { }
    Ptr(T *t) : refptr(new size_t(1)), p(t) { }
    Ptr(const Ptr<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ptr<T> &operator=(const Ptr<T> &);
    ~Ptr();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr");
    }

    void make_unique()
    {
        if (*refptr > 1)
        {
            --*refptr;
            refptr = new size_t(1);
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

    void print()
    {
        cout << (void *)p << ": " << (void *)refptr << ", " << *refptr << endl;
    }
private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ptr<T> &Ptr<T>::operator=(const Ptr<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ptr<T>::~Ptr()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

class Tracer
{
private:
    int val;
public:
    Tracer() : val(0)
    {
        cout << "Tracer()\n";
    }
    Tracer(int n) : val(n)
    {
        cout << "Tracer(int n)\n";
    }
    Tracer(const Tracer &arg) : val(arg.val)
    {
        cout << "Tracer(const Tracer &arg)\n";
    }
    Tracer &operator=(const Tracer &arg)
    {
        cout << "operator=(const Tracer &arg)\n";
        if (this == &arg) { return *this; }
        val = arg.val;
        return *this;
    }
    ~Tracer()
    {
        cout << "~Tracer()\n";
    }
    int & get()
    {
        return val;
    }
    const int & get() const
    {
        return val;
    }
};

template<>
inline Tracer *clone<Tracer>(const Tracer *pt)
{
    return new Tracer(*pt);
}

void f1()
{
    Ptr<Tracer> p1(new Tracer());
    Ptr<Tracer> p2(new Tracer(5));
    Ptr<Tracer> p3(p2);
    p1.print();
    p2.print();
    p3.print();
    p1 = p3;
    p1.print();
    p2.print();
    p3.print();
    cout << (*p1).get() << ", " << p2->get() << ", " << (*p3).get() << endl;
}

void f2()
{
    Ptr<Tracer> p1(new Tracer());
    Ptr<Tracer> p2(new Tracer(5));
    Ptr<Tracer> p3(p2);
    error("Exception!");
}

int main()
{
    try
    {
        f1();
        f2();
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Tracer()
Tracer(int n)
0x5627e0710eb0: 0x5627e07112e0, 1
0x5627e0711300: 0x5627e0711320, 2
0x5627e0711300: 0x5627e0711320, 2
~Tracer()
0x5627e0711300: 0x5627e0711320, 3
0x5627e0711300: 0x5627e0711320, 3
0x5627e0711300: 0x5627e0711320, 3
5, 5, 5
~Tracer()
Tracer()
Tracer(int n)
Exception!
~Tracer()
~Tracer()
error: Exception!

第20章 容器和迭代器
20.1 存储和处理数据
20.1.1 处理数据
20.1.2 一般化代码
20.2 STL建议
20.3 序列和迭代器
20.3.1 回到实例
20.4 链表
20.4.1 列表操作
20.4.2 迭代
20.5 再次一般化vector
20.6 实例：一个简单的文本编器
20.6.1 处理行
20.6.2 迭代
20.7 vector、list和string
20.7.1 insert和erase
20.8 调整vector类达到STL版本的功能
20.9 调整内置数组达到STL版本的功能
20.10 容器概览
20.10.1 迭代器类别
ch20_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T, int N>
class array
{
public:
    typedef T value_type;
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;

    T elems[N];

    iterator begin()
    {
        return elems;
    }
    const_iterator begin() const
    {
        return elems;
    }
    iterator end()
    {
        return elems + N;
    }
    const_iterator end() const
    {
        return elems + N;
    }

    size_type size() const
    {
        return N;
    }

    T &operator[](int n)
    {
        return elems[n];
    }
    const T &operator[](int n) const
    {
        return elems[n];
    }

    T *data()
    {
        return elems;
    }
    const T *data() const
    {
        return elems;
    }
};

template<typename Iter>
void my_print(Iter f, Iter e, const string &s)
{
    if (f != e)
    {
        cout << s << ": { ";
        cout << *f++;
        while (f != e)
        {
            cout << ", " << *f++;
        }
        cout << " }\n";
    }
}

template<typename Iter1, typename Iter2>
Iter2 my_copy(Iter1 f1, Iter1 e1, Iter2 f2)
{
    while (f1 != e1)
    {
        *f2++ = *f1++;
    }
    return f2;
}

int main()
{
    try
    {
        const int arr_sz = 10;
        array<int, arr_sz> arr_int;
        for (int i = 0; i < arr_int.size(); ++i)
        {
            arr_int[i] = i;
        }
        my_print(arr_int.begin(), arr_int.end(), "arr_int");

        vector<int> vec_int;
        for (int i = 0; i < arr_sz; ++i)
        {
            vec_int.push_back(i);
        }
        my_print(vec_int.begin(), vec_int.end(), "vec_int");

        list<int> lst_int;
        for (int i = 0; i < arr_sz; ++i)
        {
            lst_int.push_back(i);
        }
        my_print(lst_int.begin(), lst_int.end(), "lst_int");

        array<int, arr_sz> arr_cp = arr_int;
        my_print(arr_cp.begin(), arr_cp.end(), "arr_cp");
        vector<int> vec_cp = vec_int;
        my_print(vec_cp.begin(), vec_cp.end(), "vec_cp");
        list<int> lst_cp = lst_int;
        my_print(lst_cp.begin(), lst_cp.end(), "lst_cp");

        for (array<int, arr_sz>::iterator p = arr_int.begin(); p != arr_int.end(); ++p)
        {
            *p += 2;
        }
        my_print(arr_int.begin(), arr_int.end(), "arr_int+=2");

        for (vector<int>::iterator p = vec_int.begin(); p != vec_int.end(); ++p)
        {
            *p += 3;
        }
        my_print(vec_int.begin(), vec_int.end(), "vec_int+=3");

        for (list<int>::iterator p = lst_int.begin(); p != lst_int.end(); ++p)
        {
            *p += 5;
        }
        my_print(lst_int.begin(), lst_int.end(), "lst_int+=5");

        vector<int>::iterator vec_iter = my_copy(arr_int.begin(), arr_int.end(), vec_int.begin());
        array<int, arr_sz>::iterator arr_iter = my_copy(lst_int.begin(), lst_int.end(), arr_int.begin());

        if (vec_iter != vec_int.begin() && arr_iter != arr_int.begin())
        {
            my_print(arr_int.begin(), arr_int.end(), "arr_int copied from lst_int");
            my_print(vec_int.begin(), vec_int.end(), "vec_int copied from arr_int");
            my_print(lst_int.begin(), lst_int.end(), "lst_int");
        }

        vec_iter = find(vec_int.begin(), vec_int.end(), 3);
        if (vec_iter != vec_int.end())
        {
            cout << "In vec_int, 3 has index " << vec_iter - vec_int.begin() << ".\n";
        }

        list<int>::iterator lst_iter = find(lst_int.begin(), lst_int.end(), 27);

        if (lst_iter != lst_int.end())
        {
            int idx = distance(lst_int.begin(), lst_iter);
            cout << "In lst_int, 27 has index " << idx << ".\n";
        }
        else
        {
            cout << "27 is not in lst_int.\n";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
arr_int: { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
vec_int: { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
lst_int: { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
arr_cp: { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
vec_cp: { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
lst_cp: { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
arr_int+=2: { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }
vec_int+=3: { 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 }
lst_int+=5: { 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 }
arr_int copied from lst_int: { 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 }
vec_int copied from arr_int: { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }
lst_int: { 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 }
In vec_int, 3 has index 1.
27 is not in lst_int.

ch20_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

double *get_from_jack(int *count)
{
    string ifname = "ch20_p02_in1.txt";
    ifstream ifs(ifname.c_str());
    if (!ifs)
    {
        error("Can't open input file " + ifname);
    }

    vector<double> v;
    double d;
    while (ifs >> d)
    {
        v.push_back(d);
    }

    *count = v.size();
    double *data = new double[*count];
    for (int i = 0; i < v.size(); ++i)
    {
        data[i] = v[i];
    }

    return data;
}

vector<double> *get_from_jill()
{
    string ifname = "ch20_p02_in2.txt";
    ifstream ifs(ifname.c_str());
    if (!ifs)
    {
        error ("Can't open input file " + ifname);
    }

    vector<double> *v = new vector<double>;
    double d;
    while (ifs >> d)
    {
        (*v).push_back(d);
    }

    return v;
}

double *high(double *first, double *last)
{
    double h = numeric_limits<double>::min();
    double *high = nullptr;
    for(double *p = first; p != last; ++p)
    {
        if (h < *p)
        {
            high = p;
            h = *p;
        }
    }
    return high;
}

int main()
{
    try
    {
        int jack_count = 0;
        double *jack_data = get_from_jack(&jack_count);
        vector<double> *jill_data = get_from_jill();

        double *jack_high = high(jack_data, jack_data + jack_count);
        vector<double> &v = *jill_data;
        double *jill_high = high(&v[0], &v[0] + v.size());

        cout << "Jill's max: " << *jill_high << "; Jack's max: " << *jack_high;

        delete[] jack_data;
        delete jill_data;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Jill's max: 66.6; Jack's max: 9.9

cat ch20_p02_in1.txt
1.1 5.5 9.9 7.7 3.3 6.6

cat ch20_p02_in2.txt
11.1 15.5 29.9 66.6 33.3 22.2

ch20_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

double *get_from_jack(int *count)
{
    string ifname = "ch20_p02_in1.txt";
    ifstream ifs(ifname.c_str());
    if (!ifs)
    {
        error("Can't open input file " + ifname);
    }

    vector<double> v;
    double d;
    while (ifs >> d)
    {
        v.push_back(d);
    }

    *count = v.size();
    double *data = new double[*count];
    for (int i = 0; i < v.size(); ++i)
    {
        data[i] = v[i];
    }

    return data;
}

vector<double> *get_from_jill()
{
    string ifname = "ch20_p02_in2.txt";
    ifstream ifs(ifname.c_str());
    if (!ifs)
    {
        error ("Can't open input file " + ifname);
    }

    vector<double> *v = new vector<double>;
    double d;
    while (ifs >> d)
    {
        (*v).push_back(d);
    }

    return v;
}

double *high_vec(vector<double> &v)
{
    if (v.size() == 0)
    {
        return nullptr;
    }
    double *highest = &v[0];
    for (int i = 1; i < v.size(); ++i)
    {
        if (v[i] > *highest)
        {
            highest = &v[i];
        }
    }
    return highest;
}

double *high_arr(double arg[], int n)
{
    if (n == 0)
    {
        return nullptr;
    }
    double *highest = &arg[0];
    for (int i = 1; i < n; ++i)
    {
        if (arg[i] > *highest)
        {
            highest = &arg[i];
        }
    }
    return highest;
}

double *high_ptr(double *first, double *last)
{
    double h = numeric_limits<double>::min();
    double *high = nullptr;
    for(double *p = first; p != last; ++p)
    {
        if (h < *p)
        {
            high = p;
            h = *p;
        }
    }
    return high;
}

int main()
{
    try
    {
        int jack_count = 0;
        double *jack_data = get_from_jack(&jack_count);
        vector<double> *jill_data = get_from_jill();

        vector<double> jack_vec;
        for (int i = 0; i < jack_count; ++i)
        {
            jack_vec.push_back(jack_data[i]);
        }
        double *jack_high_vec = high_vec(jack_vec);
        double *jill_high_vec = high_vec(*jill_data);
        cout << "Vector: Jill's max: " << *jill_high_vec << "; Jack's max: " << *jack_high_vec << "\n";

        double *jill_arr = new double[(*jill_data).size()];
        for (int i = 0; i < (*jill_data).size(); ++i)
        {
            jill_arr[i] = (*jill_data)[i];
        }
        double *jack_high_arr = high_arr(jack_data, jack_count);
        double *jill_high_arr = high_arr(jill_arr, (*jill_data).size());
        cout << "Array: Jill's max: " << *jill_high_arr << "; Jack's max: " << *jack_high_arr << "\n";
        delete[] jill_arr;

        double *jack_high_ptr = high_ptr(jack_data, jack_data + jack_count);
        vector<double> &v = *jill_data;
        double *jill_high_ptr = high_ptr(&v[0], &v[0] + v.size());

        cout << "Pointer: Jill's max: " << *jill_high_ptr << "; Jack's max: " << *jack_high_ptr << "\n";

        delete[] jack_data;
        delete jill_data;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Vector: Jill's max: 66.6; Jack's max: 9.9
Array: Jill's max: 66.6; Jack's max: 9.9
Pointer: Jill's max: 66.6; Jack's max: 9.9

cat ch20_p02_in1.txt
1.1 5.5 9.9 7.7 3.3 6.6

cat ch20_p02_in2.txt
11.1 15.5 29.9 66.6 33.3 22.2

ch20_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}


double *get_from_jack(int *count)
{
    string ifname = "ch20_p02_in1.txt";
    ifstream ifs(ifname.c_str());
    if (!ifs)
    {
        error("Can't open input file " + ifname);
    }

    vector<double> v;
    double d;
    while (ifs >> d)
    {
        v.push_back(d);
    }

    *count = v.size();
    double *data = new double[*count];
    for (int i = 0; i < v.size(); ++i)
    {
        data[i] = v[i];
    }

    return data;
}

vector<double> *get_from_jill()
{
    string ifname = "ch20_p02_in2.txt";
    ifstream ifs(ifname.c_str());
    if (!ifs)
    {
        error ("Can't open input file " + ifname);
    }

    vector<double> *v = new vector<double>;
    double d;
    while (ifs >> d)
    {
        (*v).push_back(d);
    }

    return v;
}

double *high_ptr(double *first, double *last)
{
    double h = numeric_limits<double>::min();
    double *high = nullptr;
    for(double *p = first; p != last; ++p)
    {
        if (h < *p)
        {
            high = p;
            h = *p;
        }
    }
    return high;
}

template<typename In>
In high(In first, In last)
{
    if (first == last)
    {
        return In(nullptr);
    }
    In high = first;
    In p = first;
    ++p;
    for (; p != last; ++p)
    {
        if (*high < *p)
        {
            high = p;
        }
    }
    return high;
}

int main()
{
    try
    {
        int jack_count = 0;
        double *jack_data = get_from_jack(&jack_count);
        vector<double> *jill_data = get_from_jill();

        double *jack_high = high(jack_data, jack_data + jack_count);
        vector<double> &v = *jill_data;
        double *jill_high = high(&v[0], &v[0] + v.size());
        cout << "Jill's high " << *jill_high << "; Jack's high " << *jack_high << endl;

        delete[] jack_data;
        delete jill_data;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Jill's high 66.6; Jack's high 9.9

ch20_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int main()
{
    try
    {
        vector<double> vd;
        vector<int> vi;
        vector<string> vs;
        cout << "Enter vector of doubles: ";
        cin >> vd;
        cout << "Enter vector of integers: ";
        cin >> vi;
        cout << "Enter vector of strings: ";
        cin >> vs;

        cout << vd << "\n" << vi << "\n" << vs << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter vector of doubles: { 1.1 , 2.2 , 3.3 }
Enter vector of integers: { 1 , 2 , 3 }
Enter vector of strings: { aaa , bbb , ccc }
{ 1.1, 2.2, 3.3 }
{ 1, 2, 3 }
{ aaa, bbb, ccc }

ch20_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

typedef vector<char> Line;

class Text_iterator;

class Document
{
public:
    list<Line> line;

    Document();

    Text_iterator begin();
    Text_iterator end();

    Text_iterator erase(Text_iterator pos);
    Text_iterator insert(Text_iterator pos, char ch);
    void concat(Text_iterator &pos);
    void break_ln(Text_iterator pos);
    void find_replace(const string &find_str, const string &repl_str);
};

class Text_iterator
{
private:
    Document &doc;
    list<Line>::iterator ln;
    Line::iterator pos;
public:
    Text_iterator(Document &d, list<Line>::iterator l, Line::iterator p) : doc(d), ln(l), pos(p) { }
    Text_iterator(const Text_iterator &other) : doc(other.doc), ln(other.ln), pos(other.pos) { }
    Text_iterator &operator=(const Text_iterator &rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        doc = rhs.doc;
        ln = rhs.ln;
        pos = rhs.pos;
        return *this;
    }

    list<Line>::iterator get_line()
    {
        return ln;
    }
    Line::iterator get_pos()
    {
        return pos;
    }

    char &operator*()
    {
        return *pos;
    }
    Text_iterator &operator++();

    bool operator==(const Text_iterator &other) const
    {
        return ln == other.ln && pos == other.pos;
    }
    bool operator!=(const Text_iterator &other) const
    {
        return !(*this == other);
    }
};

Text_iterator &Text_iterator::operator++()
{
    if (ln == doc.line.end())
    {
        return *this;
    }
    list<Line>::iterator last = doc.line.end();
    --last;
    if (ln == last && pos == (*ln).begin())
    {
        return *this;
    }
    if (pos != (*ln).end())
    {
        ++pos;
    }
    if (pos == (*ln).end())
    {
        if (ln != last)
        {
            ++ln;
            pos = (*ln).begin();
        }
    }
    return *this;
}

template<typename Iter>
bool my_match(Iter first, Iter last, const string &s)
{
    if (first == last)
    {
        return false;
    }
    if (s.size() == 0)
    {
        return false;
    }
    string::const_iterator s_itr = s.begin();
    while (first != last && s_itr != s.end())
    {
        if (*first != *s_itr)
        {
            return false;
        }
        ++first;
        ++s_itr;
    }
    if (first == last && s_itr != s.end())
    {
        return false;
    }
    return true;
}

template<typename Iter, typename T>
Iter my_find(Iter first, Iter last, const T &val)
{
    Iter p = first;
    while (p != last)
    {
        if (*p == val)
        {
            return p;
        }
        ++p;
    }
    return p;
}

Text_iterator find_txt(Text_iterator first, Text_iterator last, const string &s)
{
    if (first == last)
    {
        return last;
    }
    if (s.size() == 0)
    {
        return last;
    }
    char first_char = s[0];
    while (true)
    {
        Text_iterator p = my_find<Text_iterator, char>(first, last, first_char);
        if (p == last)
        {
            return last;
        }
        if (my_match<Text_iterator>(p, last, s))
        {
            return p;
        }
        first = ++p;
    }
}

Document::Document()
{
    line.push_back(Line());
}
Text_iterator Document::begin()
{
    return Text_iterator(*this, line.begin(), (* ( line.begin() ) ).begin());
}
Text_iterator Document::end()
{
    list<Line>::iterator last = line.end();
    --last;
    return Text_iterator(*this, last, (*last).begin());
}

Text_iterator Document::erase(Text_iterator pos)
{
    list<Line>::iterator list_it = pos.get_line();
    Line::iterator line_it = pos.get_pos();
    line_it = (*list_it).erase(line_it);
    return Text_iterator(*this, list_it, line_it);
}

Text_iterator Document::insert(Text_iterator pos, char ch)
{
    list<Line>::iterator list_it = pos.get_line();
    Line::iterator line_it = pos.get_pos();
    line_it = (*list_it).insert(line_it, ch);
    return Text_iterator(*this, list_it, line_it);
}

void Document::concat(Text_iterator &pos)
{
    list<Line>::iterator cur_line = pos.get_line();
    Line::iterator line_pos = pos.get_pos();
    Line::size_type index = line_pos - (*cur_line).begin();
    list<Line>::iterator nxt_line = cur_line;
    ++nxt_line;
    list<Line>::iterator last = line.end();
    --last;
    if (nxt_line != last && (*nxt_line).begin() != (*nxt_line).end())
    {
        (*cur_line).insert((*cur_line).end(), (*nxt_line).begin(), (*nxt_line).end());
        pos = Text_iterator(*this, cur_line, (*cur_line).begin() + index);
        line.erase(nxt_line);
    }
}

void Document::break_ln(Text_iterator pos)
{
    list<Line>::iterator cur_line = pos.get_line();
    list<Line>::iterator nxt_line = cur_line;
    ++nxt_line;
    list<Line>::iterator last = line.end();
    --last;
    if (pos.get_pos() + 1 != (*cur_line).end())
    {
        if (nxt_line == last)
        {
            line.push_back(Line());
        }
        (*nxt_line).insert((*nxt_line).begin(), pos.get_pos() + 1, (*cur_line).end());
        (*cur_line).erase(pos.get_pos() + 1, (*cur_line).end());
    }
}

void Document::find_replace(const string &find_str, const string &repl_str)
{
    if (begin() == end())
    {
        return ;
    }
    if (find_str.size() == 0)
    {
        return ;
    }
    Text_iterator pos = find_txt(begin(), end(), find_str);
    while (pos != end())
    {
        string::const_iterator find_it = find_str.begin();
        string::const_iterator repl_it = repl_str.begin();
        while (find_it != find_str.end() && repl_it != repl_str.end())
        {
            if (*find_it != *repl_it)
            {
                *pos = *repl_it;
                if (*find_it == '\n')
                {
                    concat(pos);
                }
                if (*repl_it == '\n')
                {
                    break_ln(pos);
                }
            }
            ++pos;
            ++find_it;
            ++repl_it;
        }

        while (find_it != find_str.end())
        {
            list<Line>::iterator cur_line = pos.get_line();
            if (*pos == '\n')
            {
                concat(pos);
            }
            else if (*pos != '\n' && (*cur_line).size() == 1)
            {
                concat(pos);
            }
            pos = erase(pos);
            cur_line = pos.get_line();
            if ((*cur_line).size() == 0)
            {
                line.erase(cur_line);
                pos = end();
                break;
            }
            ++find_it;
        }

        while (repl_it != repl_str.end())
        {
            list<Line>::iterator cur_line = pos.get_line();
            list<Line>::iterator last = line.end();
            --last;
            if (cur_line == last)
            {
                line.push_back(Line());
            }
            pos = insert(pos, *repl_it);
            if (*repl_it == '\n')
            {
                break_ln(pos);
            }
            ++pos;
            ++repl_it;
        }

        pos = find_txt(pos, end(), find_str);
    }
}

istream &operator>>(istream &is, Document &d)
{
    char ch;
    while (is.get(ch))
    {
        d.line.back().push_back(ch);
        if (ch == '\n')
        {
            d.line.push_back(Line());
        }
    }
    if (d.line.back().size() > 0)
    {
        d.line.push_back(Line());
    }
    return is;
}

void print(Document &d, Text_iterator p)
{
    for ( ; p != d.end(); ++p)
    {
        cout << *p;
    }
    cout << "\n";
}

int char_count(Document &d)
{
    Text_iterator iter = d.begin();
    int ctr = 0;
    while (iter != d.end())
    {
        ++iter;
        ++ctr;
    }
    return ctr;
}

int file_word_count(const string &fname)
{
    ifstream ifs(fname.c_str());
    if (!ifs)
    {
        error("can't open file " + fname);
    }
    string s;
    int ctr = 0;
    while (ifs >> s)
    {
        ++ctr;
    }
    return ctr;
}

int word_count1(Document &d)
{
    Text_iterator p = d.begin();
    string fname = "ch20_p06_tmp1.txt";
    ofstream ofs(fname.c_str());
    if (!ofs)
    {
        error("can't open file " + fname);
    }
    while (p != d.end())
    {
        ofs << *p;
        ++p;
    }
    ofs.close();

    int ctr = file_word_count(fname);
    return ctr;
}

int word_count2(Document &d)
{
    Text_iterator p = d.begin();
    string fname = "ch20_p06_tmp2.txt";
    ofstream ofs(fname.c_str());
    if (!ofs)
    {
        error("can't open file " + fname);
    }
    while (p != d.end())
    {
        if (isalpha(*p))
        {
            ofs << *p;
        }
        else
        {
            ofs << ' ';
        }
        ++p;
    }
    ofs.close();

    int ctr = file_word_count(fname);
    return ctr;
}

bool is_whitespace(char c, const string &white)
{
    for (int i = 0; i < white.size(); ++i)
    {
        if (white[i] == c)
        {
            return true;
        }
    }
    return false;
}

int word_count3(Document &d, const string &white)
{
    Text_iterator p = d.begin();
    string fname = "ch20_p06_tmp3.txt";
    ofstream ofs(fname.c_str());
    if (!ofs)
    {
        error("can't open file " + fname);
    }
    while (p != d.end())
    {
        if (is_whitespace(*p, white))
        {
            ofs << ' ';
        }
        else
        {
            ofs << *p;
        }
        ++p;
    }
    ofs.close();

    int ctr = file_word_count(fname);
    return ctr;
}

int main()
{
    try
    {
        string ifname = "ch20_p06_in.txt";
        ifstream ifs(ifname.c_str());
        if (!ifs)
        {
            error("can't open file " + ifname);
        }
        Document my_doc;
        ifs >> my_doc;
        print(my_doc, my_doc.begin());

        cout << "\nSearching for string 'wrong':\n";
        string f_str = "wrong";
        Text_iterator p = find_txt(my_doc.begin(), my_doc.end(), f_str);
        if (p == my_doc.end())
        {
            cout << "not found";
        }
        else
        {
            print(my_doc, p);
        }

        cout << "\nReplace 'wrong' with 'HelloWorld':\n";
        f_str = "wrong";
        string r_str = "HelloWorld";
        my_doc.find_replace(f_str, r_str);
        print(my_doc, my_doc.begin());


        cout << "\nNumber of characters in this document: "
             << char_count(my_doc) << "\n";

        cout << "Number of words (whitespace-separated) in this document: "
             << word_count1(my_doc) << "\n";

        cout << "Number of words (sequences of alphabetic characters) in this "
             << "document: " << word_count2(my_doc) << "\n";

        cout << "Number of words separated by whitespace or \".!'\" in this "
             << "document: " << word_count3(my_doc, ".!'") << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
cat ch20_p06_in.txt
Peter Smith Mike Pence Water Flower
123abc wrong 56789 How are You?
Orange Egg Smile wrong
Internet

ch20_p06
Peter Smith Mike Pence Water Flower
123abc wrong 56789 How are You?
Orange Egg Smile wrong
Internet


Searching for string 'wrong':
wrong 56789 How are You?
Orange Egg Smile wrong
Internet


Replace 'wrong' with 'HelloWorld':
Peter Smith Mike Pence Water Flower
123abc HelloWorld 56789 How are You?
Orange Egg Smile HelloWorld
Internet


Number of characters in this document: 110
Number of words (whitespace-separated) in this document: 17
Number of words (sequences of alphabetic characters) in this document: 16
Number of words separated by whitespace or ".!'" in this document: 17

cat ch20_p06_tmp1.txt
Peter Smith Mike Pence Water Flower
123abc HelloWorld 56789 How are You?
Orange Egg Smile HelloWorld
Internet

cat ch20_p06_tmp2.txt
Peter Smith Mike Pence Water Flower    abc HelloWorld       How are You  Orange Egg Smile HelloWorld Internet 

cat ch20_p06_tmp3.txt
Peter Smith Mike Pence Water Flower
123abc HelloWorld 56789 How are You?
Orange Egg Smile HelloWorld
Internet

ch20_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


template<typename Iterator>
Iterator biggest_element(Iterator first, Iterator last)
{
    Iterator high = first;
    while (first != last)
    {
        if (*first > *high)
        {
            high = first;
        }
        ++first;
    }
    return high;
}

int main()
{
    try
    {
        vector<string> vs;
        string s;
        cout << "Enter a few words:\n";
        while (cin >> s )
        {
            vs.push_back(s);
        }

        vector<string>::iterator last = biggest_element(vs.begin(), vs.end());
        if (last != vs.end())
        {
            cout << "The lexicographically last string in the vector is \""<< *last << "\".\n";
        }
        else
        {
            cout << "vector is empty.\n";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter a few words:
Mike Pence Hello World Water Flower
The lexicographically last string in the vector is "World".

ch20_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template<typename Iter>
void print_ctr(Iter first, Iter last)
{
    if (first != last)
    {
        cout << "{ ";

        cout << *first++;

        while (first != last)
        {
            cout << ", " << *first++;
        }
        cout << " }\n";
    }
}

void list_cpy(const list<int> &li)
{
    vector<double> vd;
    list<int>::const_iterator li_it = li.begin();
    while (li_it != li.end())
    {
        vd.push_back(*li_it);
        ++li_it;
    }

    cout << "Length of list:   " << li.size() << "\n";
    cout << "Length of vector: " << vd.size() << "\n";
    cout << "List:   ";
    print_ctr(li.begin(), li.end());
    cout << "Vector: ";
    print_ctr(vd.begin(), vd.end());
    vector<double> vd_sorted = vd;
    sort(vd_sorted.begin(), vd_sorted.end());
    cout << "Sorted: ";
    print_ctr(vd_sorted.begin(), vd_sorted.end());
}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);
    try
    {
        list<int> li;
        for (int i = 0; i < 10; ++i)
        {
            li.push_back(nrand_two(0, 100, engine));
        }
        list_cpy(li);
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Length of list:   10
Length of vector: 10
List:   { 40, 29, 84, 68, 87, 22, 72, 97, 46, 72 }
Vector: { 40, 29, 84, 68, 87, 22, 72, 97, 46, 72 }
Sorted: { 22, 29, 40, 46, 68, 72, 72, 84, 87, 97 }

ch20_p12.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>

#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::numeric_limits;
using std::common_type;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template<typename T>
class Link
{
private:
    Link<T> *prev;
    Link<T> *succ;
public:
    T value;
    Link(const T &v = T(), Link<T> *p = nullptr, Link<T> *s = nullptr) : value(v), prev(p), succ(s) { }

    Link<T> *insert(Link<T> *n);
    Link<T> *add(Link<T> *n);
    Link<T> *add_ordered(Link<T> *n);
    Link<T> *erase();
    Link<T> *find(const T &v);

    Link<T> *advance(int n);

    Link<T> *next() const
    {
        return succ;
    }
    Link<T> *previous() const
    {
        return prev;
    }
    void print_all();
};

template<typename T>
Link<T> *Link<T>::insert(Link<T> *n)
{
    if (n == nullptr)
    {
        return n;
    }
    n->succ = this;
    if (prev != nullptr)
    {
        prev->succ = n;
    }
    n->prev = prev;
    prev = n;
    return n;
}

template<typename T>
Link<T> *Link<T>::add(Link<T> *n)
{
    if (n == nullptr)
    {
        return n;
    }
    n->prev = this;
    if (succ != nullptr)
    {
        succ->prev = n;
    }
    n->succ = succ;
    succ = n;
    return n;
}

template<typename T>
Link<T> *Link<T>::add_ordered(Link<T> *n)
{
    if (n == nullptr)
    {
        return n;
    }
    if (n->value < value)
    {
        Link<T> *p = insert(n);
        return p;
    }
    Link<T> *p = this;
    while (n->value >= p->value)
    {
        if (p->succ == nullptr)
        {
            p->add(n);
            return this;
        }
        p = p->succ;
    }
    p->insert(n);
    return this;
}

template<typename T>
Link<T> *Link<T>::erase()
{
    if (succ != nullptr)
    {
        succ->prev = prev;
    }
    if (prev != nullptr)
    {
        prev->succ = succ;
    }
    Link<T> *ret = succ;
    succ = nullptr;
    prev = nullptr;
    return ret;
}

template<typename T>
Link<T> *Link<T>::find(const T &v)
{
    Link<T> *p = this;
    while (p != nullptr)
    {
        if (p->value == v)
        {
            return p;
        }
        p = p->succ;
    }
    return nullptr;
}

template<typename T>
Link<T> *Link<T>::advance(int n)
{
    Link<T> *p = this;
    if (0 < n)
    {
        while (n--)
        {
            if (p->succ == nullptr)
            {
                return nullptr;
            }
            p = p->succ;
        }
    }
    else if (n < 0)
    {
        while (n++)
        {
            if (p->prev == nullptr)
            {
                return nullptr;
            }
            p = p->prev;
        }
    }
    return p;
}

template<typename T>
void Link<T>::print_all()
{
    Link<T> *p = this;
    while (p != nullptr)
    {
        cout << p->value << "\n";
        p = p->succ;
    }
}

template<typename T>
void delete_all(Link<T> *p)
{
    while (p != nullptr)
    {
        Link<T> *temp = p->next();
        delete p;
        p = temp;
    }
}

template<typename T>
Link<T> *extract(Link<T> **l, const T &v)
{
    if ( (*l) == nullptr )
    {
        return nullptr;
    }
    Link<T> *p = (*l)->find(v);
    if (p != nullptr)
    {
        if (p == (*l))
        {
            (*l) = p->next();
        }
        p->erase();
        return p;
    }
    return nullptr;
}

template<typename T>
void move(Link<T> *&from, Link<T> *&to, const T &v)
{
    Link<T> *temp = extract<T>(&from, v);
    if (temp != nullptr)
    {
        to = to->add_ordered(temp);
    }
}

template<typename T>
class my_list
{
private:
    Link<T> *first;
    Link<T> *last;
public:
    my_list() : first(new Link<T>()), last(first) { }
    ~my_list()
    {
        delete_all(first);
    }

    void print()
    {
        Link<T> *p = first;
        while (p != last)
        {
            cout << p->value << "\n";
            p = p->next();
        }
    }

    class iterator
    {
    private:
        Link<T> *curr;
    public:
        friend class my_list<T>;
        iterator(Link<T> *p) : curr(p) { }

        iterator &operator++()
        {
            curr = curr->next();
            return *this;
        }
        iterator &operator--()
        {
            curr = curr->previous();
            return *this;
        }
        T &operator*()
        {
            return curr->value;
        }

        bool operator==(const iterator &b) const
        {
            return curr == b.curr;
        }
        bool operator!=(const iterator &b) const
        {
            return curr != b.curr;
        }
    };

    iterator begin();
    iterator end();

    iterator insert(iterator p, const T &v);
    iterator erase(iterator p);

    void push_front(const T &v);
    void push_back(const T &v);
    void pop_front();
    void pop_back();

    T &front();
    T &back();
};

template<typename T>
typename my_list<T>::iterator my_list<T>::begin()
{
    return iterator(first);
}

template<typename T>
typename my_list<T>::iterator my_list<T>::end()
{
    return iterator(last);
}

template<typename T>
typename my_list<T>::iterator my_list<T>::insert(iterator p, const T &v)
{
    Link<T> *n = new Link<T>(v);
    Link<T> *p_link = p.curr;
    Link<T> *p_ret = p_link->insert(n);
    if (first == p_link)
    {
        first = p_ret;
    }
    return iterator(p_ret);
}

template<typename T>
typename my_list<T>::iterator my_list<T>::erase(iterator p)
{
    Link<T> *p_link = p.curr;
    Link<T> *p_ret = p_link->erase();
    if (first == p_link)
    {
        first = p_ret;
    }
    delete p_link;
    return iterator(p_ret);
}

template<typename T>
void my_list<T>::push_front(const T &v)
{
    Link<T> *n = new Link<T>(v);
    Link<T> *p_link = first;
    Link<T> *p_ret = p_link->insert(n);
    first = p_ret;
}

template<typename T>
void my_list<T>::push_back(const T &v)
{
    Link<T> *n = new Link<T>(v);
    Link<T> *p_link = last;
    Link<T> *p_ret = p_link->insert(n);
    if (first == p_link)
    {
        first = p_ret;
    }
}

template<typename T>
void my_list<T>::pop_front()
{
    Link<T> *p_link = first;
    Link<T> *p_ret = p_link->erase();
    first = p_ret;
    delete p_link;
}

template<typename T>
void my_list<T>::pop_back()
{
    Link<T> *p_link = last->previous();
    Link<T> *p_ret = p_link->erase();
    if (first == p_link)
    {
        first = p_ret;
    }
    delete p_link;
}

template<typename T>
T &my_list<T>::front()
{
    Link<T> *p_link = first;
    return p_link->value;
}

template<typename T>
T &my_list<T>::back()
{
    Link<T> *p_link = last->previous();
    return p_link->value;
}

template<typename Iterator>
Iterator high(Iterator first, Iterator last)
{
    Iterator high = first;
    for (Iterator p = first; p != last; ++p)
    {
        if (*high < *p)
        {
            high = p;
        }
    }
    return high;
}

int main()
{
    try
    {
        my_list<int> lst;
        int x;
        while (cin >> x)
        {
            lst.push_front(x);
        }
        lst.print();
        my_list<int>::iterator p = high(lst.begin(), lst.end());
        cout << "The highest value was " << *p << "\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
1 3 5 9 6 18 23 7 2
2
7
23
18
6
9
5
3
1
The highest value was 23


第21章 算法和映射
21.1 标准库中的算法
21.2 最简单的算法: find
21.2.1 一些一般的应用
21.3 通用搜索算法: find_if
21.4 函数对象
21.4.1 函数对象的抽象视图
21.4.2 类成员上的谓词
21.5 数值算法
21.5.1 累积
21.5.2 一般化accumulate
21.5.3 内积
21.5.4一般化inner-product
21.6 关联容器
21.6.1 映射
21.6.2 map概览
21.6.3 另一个map实例
21.6.4 unordered_map
21.6.5 集合
21.7 拷贝操作
21.7.1 拷贝
21.7.2 流迭代器
21.7.3 使用集合保持顺序
21.7.4 copy_if
21.8 排序和搜索
ch21_d01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Item
{
public:
    string name;
    int iid;
    double value;
    Item() : name(), iid(0), value(0) { }
    Item(const string &n, int i, double v) : name(n), iid(i), value(v) { }
};

istream &operator>>(istream &is, Item &it)
{
    string name;
    int iid;
    double value;
    is >> name;
    if (!is)
    {
        return is;
    }
    is >> iid;
    if (!is)
    {
        return is;
    }
    is >> value;
    if (!is)
    {
        return is;
    }
    it = Item(name, iid, value);
    return is;
}

ostream &operator<<(ostream &os, const Item &it)
{
    return os << it.name << '\t' << it.iid << '\t' << it.value;
}

class  Comp_by_name
{
public:
    bool operator()(const Item &a, const Item &b) const
    {
        return a.name < b.name;
    }
};

class Comp_by_iid
{
public:
    bool operator()(const Item &a, const Item &b) const
    {
        return a.iid < b.iid;
    }
};

bool comp_by_value(const Item &a, const Item &b)
{
    return a.value < b.value;
}

class Find_by_name
{
private:
    string name;
public:
    Find_by_name(const string &s) : name(s) { }
    bool operator()(const Item &it) const
    {
        return it.name == name;
    }
};

class Find_by_iid
{
private:
    int iid;
public:
    Find_by_iid(int i) : iid(i) { }
    bool operator()(const Item &it) const
    {
        return it.iid == iid;
    }
};

template<typename iter>
void print(iter first, iter last)
{
    while (first != last)
    {
        cout << *first << '\n';
        ++first;
    }
}

void f1()
{
    cout << "First round: vector\n";
    vector<Item> vi;
    const string ifname = "ch21_d01_in1.txt";

    cout << "fill with ten items from file\n";
    ifstream ifs(ifname.c_str());
    if (!ifs)
    {
        error("can't open " + ifname);
    }
    Item i;
    while (ifs >> i)
    {
        vi.insert(vi.end(), i);
    }
    print(vi.begin(), vi.end());

    cout << "\nsort by name\n";
    sort(vi.begin(), vi.end(), Comp_by_name());
    print(vi.begin(), vi.end());

    cout << "\nsort by iid\n";
    sort(vi.begin(), vi.end(), Comp_by_iid());
    print(vi.begin(), vi.end());

    cout << "\nsort by value, print in decreasing order\n";
    sort(vi.begin(), vi.end(), comp_by_value);
    reverse(vi.begin(), vi.end());
    print(vi.begin(), vi.end());

    cout << "\ninsert two items, sort by value, print in decreasing order\n";
    vi.insert(vi.end(), Item("Horsesh", 99, 12.34));
    vi.insert(vi.end(), Item("C S400", 9988, 499.95));
    sort(vi.begin(), vi.end(), comp_by_value);
    reverse(vi.begin(), vi.end());
    print(vi.begin(), vi.end());

    cout << "\nremove two items identified by name\n";
    vector<Item>::iterator vi_it = find_if(vi.begin(), vi.end(), Find_by_name("GoPro"));
    vi.erase(vi_it);
    vi_it = find_if(vi.begin(), vi.end(), Find_by_name("Xbox"));
    vi.erase(vi_it);
    print(vi.begin(), vi.end());

    cout << "\nremove two tems identified by iid\n";
    vi_it = find_if(vi.begin(), vi.end(), Find_by_iid(14910));
    vi.erase(vi_it);
    vi_it = find_if(vi.begin(), vi.end(), Find_by_iid(754));
    vi.erase(vi_it);
    print(vi.begin(), vi.end());
}

void f2()
{
    cout << "\nSecond round: list\n";
    list<Item> li;
    const string ifname = "ch21_d01_in1.txt";

    cout << "fill with ten items from file\n";
    ifstream ifs(ifname.c_str());
    if (!ifs)
    {
        error("can't open " + ifname);
    }
    Item i;
    while (ifs >> i)
    {
        li.insert(li.end(), i);
    }
    print(li.begin(), li.end());

    cout << "\nsort by name\n";
    li.sort(Comp_by_name());
    print(li.begin(), li.end());

    cout << "\nsort by iid\n";
    li.sort(Comp_by_iid());
    print(li.begin(), li.end());

    cout << "\nsort by value, print in decreasing order\n";
    li.sort(comp_by_value);
    reverse(li.begin(), li.end());
    print(li.begin(), li.end());

    cout << "\ninsert two items, sort by value, print in decreasing order\n";
    li.insert(li.end(), Item("Horsesh", 99, 12.34));
    li.insert(li.end(), Item("C S400", 9988, 499.95));
    li.sort(comp_by_value);
    reverse(li.begin(), li.end());
    print(li.begin(), li.end());

    cout << "\nremove two items identified by name\n";
    list<Item>::iterator li_it = find_if(li.begin(), li.end(), Find_by_name("GoPro"));
    li.erase(li_it);
    li_it = find_if(li.begin(), li.end(), Find_by_name("Xbox"));
    li.erase(li_it);
    print(li.begin(), li.end());

    cout << "\nremove two tems identified by iid\n";
    li_it = find_if(li.begin(), li.end(), Find_by_iid(14910));
    li.erase(li_it);
    li_it = find_if(li.begin(), li.end(), Find_by_iid(754));
    li.erase(li_it);
    print(li.begin(), li.end());
}

void read_pair(map<string, int> &msi)
{
    string s;
    int i;
    cin >> s;
    if (!cin)
    {
        error("Problem reading from cin");
    }
    cin >> i;
    if (!cin)
    {
        error("Problem reading from cin");
    }
    msi[s] = i;
}

template<typename T, typename U>
ostream &operator<<(ostream &os, const pair<T, U> &p)
{
    os << setw(12) << left << p.first << '\t' << p.second;
    return os;
}

template<typename T>
class Map_add
{
public:
    T operator()(const T &v, const pair<string, T> &p)
    {
        return v + p.second;
    }
};

void f3()
{
    map<string, int> msi;

    msi["lecture"] = 21;
    msi["university"] = 35;
    msi["education"] = 15;
    msi["school"] = 99;
    msi["kindergarten"] = 105;
    msi["river"] = 5;
    msi["city"] = 10;
    msi["capital"] = 70;
    msi["software"] = 88;
    msi["hardware"] = 43;

    print(msi.begin(), msi.end());

    typedef map<string, int>::const_iterator MI;
    MI p = msi.begin();
    while (p != msi.end())
    {
        p = msi.erase(p);
    }
    cout << "Size of map after deleting: " << msi.size() << '\n';

    cout << "Enter 10 (string,int) pairs, separated by space:\n";
    for (int i = 0; i < 10; ++i)
    {
        read_pair(msi);
    }

    cout << '\n';
    print(msi.begin(), msi.end());

    int msi_sum = 0;
    msi_sum = accumulate(msi.begin(), msi.end(), msi_sum, Map_add<int>());
    cout << "\nSum of all ints in msi: " << msi_sum << '\n';

    map<int, string> mis;

    for (p = msi.begin(); p != msi.end(); ++p)
    {
        mis[p->second] = p->first;
    }

    cout << "\nContents of mis:\n";
    print(mis.begin(), mis.end());
}

template<typename T>
class Less_than
{
private:
    T v;
public:
    Less_than(const T &val) : v(val) { }
    bool operator()(const T &x) const
    {
        return x < v;
    }
};

void f4()
{
    const string fname = "ch21_d01_in2.txt";
    ifstream ifs(fname.c_str());
    if (!ifs)
    {
        error("can't open " + fname);
    }
    vector<double> vd;
    double d;
    while (ifs >> d)
    {
        vd.push_back(d);
    }

    cout << "vd:\n";
    print(vd.begin(), vd.end());

    vector<int> vi(vd.size());
    copy(vd.begin(), vd.end(), vi.begin());

    cout << "\n(vd,vi) pairs:\n";
    for (int i = 0; i < vd.size(); ++i)
    {
        cout << '(' << vd[i] << ',' << vi[i] << ")\n";
    }

    double sum_vd = 0;
    sum_vd = accumulate(vd.begin(), vd.end(), sum_vd);
    cout << "\nSum of the elements of vd: " << sum_vd << '\n';

    int sum_vi = 0;
    sum_vi = accumulate(vi.begin(), vi.end(), sum_vi);
    cout << "Difference of sum_vd and sum_vi: " << sum_vd - sum_vi << '\n';

    reverse(vd.begin(), vd.end());
    cout << "\nvd after reverse:\n";
    print(vd.begin(), vd.end());

    double vd_mean = sum_vd / vd.size();
    cout << "\nMean value of elements in vd: " << vd_mean << '\n';

    vector<double> vd2(count_if(vd.begin(), vd.end(), Less_than<double>(vd_mean)));
    copy_if(vd.begin(), vd.end(), vd2.begin(), Less_than<double>(vd_mean));
    cout << "\nvd2:\n";
    print(vd2.begin(), vd2.end());

    sort(vd.begin(), vd.end());
    cout << "\nAfter sort, vd:\n";
    print(vd.begin(), vd.end());
}

int main()
{
    try
    {
        f1();
        f2();
        f3();
        f4();
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Cards 14910 25.0
Fuji 3484 10.0
Call 2517 10.0
Lol 153 17.99
Hat 162 399.99
GoPro 667 49.95
Xbox 135 39.99
WhatIf 368 349.0
Fleece 223 39.99
Beanie 754 2.99

cat ch21_d01_in2.txt
25.0
10.0
10.0
17.99
399.99
49.95
39.99
349.0
39.99
2.99
3.14
2.17
64.2
55.1
91.1
32.1

ch21_d01
First round: vector
fill with ten items from file
Cards   14910   25
Fuji    3484    10
Call    2517    10
Lol     153     17.99
Hat     162     399.99
GoPro   667     49.95
Xbox    135     39.99
WhatIf  368     349
Fleece  223     39.99
Beanie  754     2.99

sort by name
Beanie  754     2.99
Call    2517    10
Cards   14910   25
Fleece  223     39.99
Fuji    3484    10
GoPro   667     49.95
Hat     162     399.99
Lol     153     17.99
WhatIf  368     349
Xbox    135     39.99

sort by iid
Xbox    135     39.99
Lol     153     17.99
Hat     162     399.99
Fleece  223     39.99
WhatIf  368     349
GoPro   667     49.95
Beanie  754     2.99
Call    2517    10
Fuji    3484    10
Cards   14910   25

sort by value, print in decreasing order
Hat     162     399.99
WhatIf  368     349
GoPro   667     49.95
Fleece  223     39.99
Xbox    135     39.99
Cards   14910   25
Lol     153     17.99
Fuji    3484    10
Call    2517    10
Beanie  754     2.99

insert two items, sort by value, print in decreasing order
C S400  9988    499.95
Hat     162     399.99
WhatIf  368     349
GoPro   667     49.95
Xbox    135     39.99
Fleece  223     39.99
Cards   14910   25
Lol     153     17.99
Horsesh 99      12.34
Call    2517    10
Fuji    3484    10
Beanie  754     2.99

remove two items identified by name
C S400  9988    499.95
Hat     162     399.99
WhatIf  368     349
Fleece  223     39.99
Cards   14910   25
Lol     153     17.99
Horsesh 99      12.34
Call    2517    10
Fuji    3484    10
Beanie  754     2.99

remove two tems identified by iid
C S400  9988    499.95
Hat     162     399.99
WhatIf  368     349
Fleece  223     39.99
Lol     153     17.99
Horsesh 99      12.34
Call    2517    10
Fuji    3484    10

Second round: list
fill with ten items from file
Cards   14910   25
Fuji    3484    10
Call    2517    10
Lol     153     17.99
Hat     162     399.99
GoPro   667     49.95
Xbox    135     39.99
WhatIf  368     349
Fleece  223     39.99
Beanie  754     2.99

sort by name
Beanie  754     2.99
Call    2517    10
Cards   14910   25
Fleece  223     39.99
Fuji    3484    10
GoPro   667     49.95
Hat     162     399.99
Lol     153     17.99
WhatIf  368     349
Xbox    135     39.99

sort by iid
Xbox    135     39.99
Lol     153     17.99
Hat     162     399.99
Fleece  223     39.99
WhatIf  368     349
GoPro   667     49.95
Beanie  754     2.99
Call    2517    10
Fuji    3484    10
Cards   14910   25

sort by value, print in decreasing order
Hat     162     399.99
WhatIf  368     349
GoPro   667     49.95
Fleece  223     39.99
Xbox    135     39.99
Cards   14910   25
Lol     153     17.99
Fuji    3484    10
Call    2517    10
Beanie  754     2.99

insert two items, sort by value, print in decreasing order
C S400  9988    499.95
Hat     162     399.99
WhatIf  368     349
GoPro   667     49.95
Xbox    135     39.99
Fleece  223     39.99
Cards   14910   25
Lol     153     17.99
Horsesh 99      12.34
Call    2517    10
Fuji    3484    10
Beanie  754     2.99

remove two items identified by name
C S400  9988    499.95
Hat     162     399.99
WhatIf  368     349
Fleece  223     39.99
Cards   14910   25
Lol     153     17.99
Horsesh 99      12.34
Call    2517    10
Fuji    3484    10
Beanie  754     2.99

remove two tems identified by iid
C S400  9988    499.95
Hat     162     399.99
WhatIf  368     349
Fleece  223     39.99
Lol     153     17.99
Horsesh 99      12.34
Call    2517    10
Fuji    3484    10
capital         70
city            10
education       15
hardware        43
kindergarten    105
lecture         21
river           5
school          99
software        88
university      35
Size of map after deleting: 0
Enter 10 (string,int) pairs, separated by space:
Mike 23 Pence 55 Peter 66 Smith 35 Hello 87 World 99 Water 101 Flower 32 Apple 123 Orange 36

Apple           123
Flower          32
Hello           87
Mike            23
Orange          36
Pence           55
Peter           66
Smith           35
Water           101
World           99

Sum of all ints in msi: 657

Contents of mis:
23              Mike
32              Flower
35              Smith
36              Orange
55              Pence
66              Peter
87              Hello
99              World
101             Water
123             Apple
vd:
25
10
10
17.99
399.99
49.95
39.99
349
39.99
2.99
3.14
2.17
64.2
55.1
91.1
32.1

(vd,vi) pairs:
(25,25)
(10,10)
(10,10)
(17.99,17)
(399.99,399)
(49.95,49)
(39.99,39)
(349,349)
(39.99,39)
(2.99,2)
(3.14,3)
(2.17,2)
(64.2,64)
(55.1,55)
(91.1,91)
(32.1,32)

Sum of the elements of vd: 1192.71
Difference of sum_vd and sum_vi: 6.71

vd after reverse:
32.1
91.1
55.1
64.2
2.17
3.14
2.99
39.99
349
39.99
49.95
399.99
17.99
10
10
25

Mean value of elements in vd: 74.5444

vd2:
32.1
55.1
64.2
2.17
3.14
2.99
39.99
39.99
49.95
17.99
10
10
25

After sort, vd:
2.17
2.99
3.14
10
10
17.99
25
32.1
39.99
39.99
49.95
55.1
64.2
91.1
349
399.99

ch21_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template<typename In, typename T>
int my_count(In first, In last, const T &val)
{
    int ctr = 0;
    while (first != last)
    {
        if (*first == val)
        {
            ++ctr;
        }
        ++first;
    }
    return ctr;
}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);

    try
    {
        vector<int> vi;
        for (int i = 0; i < 30; ++i)
        {
            vi.push_back(nrand_two(0, 100, engine));
        }
        cout << "vi:\n";
        cout << vi << endl;
        cout << "Enter value for which you want to know the count, -1 to exit: ";
        int val;
        while (cin >> val)
        {
            if (val == -1)
            {
                break;
            }
            int ctr = my_count(vi.begin(), vi.end(), val);
            cout << val << " is " << ctr << " time" << (ctr != 1 ? "s " : " ") << "in vi.\n";
            cout << "Enter value for which you want to know the count, -1 to exit: ";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
vi:
{ 66, 68, 94, 15, 41, 13, 90, 46, 6, 14, 75, 74, 5, 11, 49, 3, 70, 67, 13, 94, 89, 33, 84, 33, 8, 66, 25, 40, 64, 40 }
Enter value for which you want to know the count, -1 to exit: 94
94 is 2 times in vi.
Enter value for which you want to know the count, -1 to exit: 33
33 is 2 times in vi.
Enter value for which you want to know the count, -1 to exit: 25
25 is 1 time in vi.
Enter value for which you want to know the count, -1 to exit: -1

ch21_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template<typename In, typename T>
int my_count(In first, In last, const T &val)
{
    int ctr = 0;
    while (first != last)
    {
        if (*first == val)
        {
            ++ctr;
        }
        ++first;
    }
    return ctr;
}


template<typename In, typename Pred>
int my_count_if(In first, In last, const Pred &p)
{
    int ctr = 0;
    while (first != last)
    {
        if (p(*first))
        {
            ++ctr;
        }
        ++first;
    }
    return ctr;
}

template<typename T>
class Less_than
{
private:
    T val;
public:
    Less_than(const T &v) : val(v) { }
    bool operator()(const T &x) const
    {
        return x < val;
    }
};

template<typename T>
class Greater_than
{
private:
    T val;
public:
    Greater_than(const T &v) : val(v) { }
    bool operator()(const T &x) const
    {
        return x > val;
    }
};

bool odd(int i)
{
    return i % 2 != 0;
}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);

    try
    {
        vector<int> vi;
        for (int i = 0; i < 30; ++i)
        {
            vi.push_back(nrand_two(0, 100, engine));
        }
        cout << "vi:\n";
        cout << vi << endl;
        cout << "Enter value for less than count, -1 to exit: ";
        int val;
        while (cin >> val)
        {
            if (val == -1)
            {
                break;
            }
            int ctr = my_count_if(vi.begin(), vi.end(), Less_than<int>(val));
            cout << "There " << (ctr == 1 ? "is " : "are ") << ctr << " value" << (ctr == 1 ? " " : "s ")
                 << "less than " << val << " in vi.\n";
            cout << "Enter value for less than count, -1 to exit: ";
        }

        cout << "Enter value for greater than count, -1 to exit: ";
        while (cin >> val)
        {
            if (val == -1)
            {
                break;
            }
            int ctr = my_count_if(vi.begin(), vi.end(), Greater_than<int>(val));
            cout << "There " << (ctr == 1 ? "is " : "are ") << ctr << " value" << (ctr == 1 ? " " : "s ")
                 << "greater than " << val << " in vi.\n";
             cout << "Enter value for greater than count, -1 to exit: ";
        }

        int ctr = my_count_if(vi.begin(), vi.end(), odd);
        cout << "There are " << ctr << " odd values in vi.\n";
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
vi:
{ 47, 96, 40, 50, 31, 87, 46, 89, 38, 13, 2, 20, 28, 48, 22, 0, 89, 49, 69, 1, 82, 75, 6, 78, 70, 96, 80, 67, 89, 89 }
Enter value for less than count, -1 to exit: 80
There are 21 values less than 80 in vi.
Enter value for less than count, -1 to exit: -1
Enter value for greater than count, -1 to exit: 80
There are 8 values greater than 80 in vi.
Enter value for greater than count, -1 to exit: -1
There are 13 odd values in vi.

ch21_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template<typename In, typename T>
int my_count(In first, In last, const T &val)
{
    int ctr = 0;
    while (first != last)
    {
        if (*first == val)
        {
            ++ctr;
        }
        ++first;
    }
    return ctr;
}


template<typename In, typename Pred>
int my_count_if(In first, In last, const Pred &p)
{
    int ctr = 0;
    while (first != last)
    {
        if (p(*first))
        {
            ++ctr;
        }
        ++first;
    }
    return ctr;
}

template<typename T>
class Less_than
{
private:
    T val;
public:
    Less_than(const T &v) : val(v) { }
    bool operator()(const T &x) const
    {
        return x < val;
    }
};

template<typename T>
class Greater_than
{
private:
    T val;
public:
    Greater_than(const T &v) : val(v) { }
    bool operator()(const T &x) const
    {
        return x > val;
    }
};

bool odd(int i)
{
    return i % 2 != 0;
}

template<typename In, typename T>
In my_find2(In first, In last, const T &val)
{
    In p = first;
    while (p != last)
    {
        if (*p == val)
        {
            return p;
        }
        ++p;
    }

    if (*p == val)
    {
        return p;
    }

    return first;
}

template<typename In, typename T>
int my_count2(In first, In last, const T &val)
{
    int count = 0;
    while (first != last)
    {
        if (*first == val)
        {
            ++count;
        }
        ++first;
    }
    if (*first == val)
    {
        ++count;
    }
    return count;
}

int main()
{
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    mt19937 engine(seed);

    try
    {
        vector<int> vi;
        for (int i = 0; i < 30; ++i)
        {
            vi.push_back(nrand_two(0, 100, engine));
        }
        cout << "vi:\n";
        cout << vi << endl;
        typedef vector<int>::iterator vi_it;
        cout << "Enter int to search for and count (-1 to quit): ";
        int val;
        while (cin >> val)
        {
            if (val == -1)
            {
                break;
            }
            vi_it it = my_find2(vi.begin(), vi.end() - 1, val);
            int count = my_count2(vi.begin(), vi.end() - 1, val);
            if (*it != val)
            {
                cout << val << " is not in vi.\n";
            }
            else
            {
                cout << val << " is at index " << it - vi.begin()
                     << " (occurs " << count << " time" << (count == 1 ? "" : "s")
                     << ").\n";
            }
            cout << "Enter int to search for and count (-1 to quit): ";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
vi:
{ 80, 94, 92, 38, 58, 99, 90, 21, 53, 77, 89, 15, 4, 82, 36, 82, 16, 37, 92, 86, 20, 61, 97, 51, 64, 56, 8, 81, 86, 67 }
Enter int to search for and count (-1 to quit): 82
82 is at index 13 (occurs 2 times).
Enter int to search for and count (-1 to quit): -1

ch21_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


class Fruit
{
public:
    string name;
    int count;
    double unit_price;
    Fruit(const string &n, int c, double up = 0.0) : name(n), count(c), unit_price(up) { }
};

ostream &operator<<(ostream &os, const Fruit *f)
{
    os << setw(12) << left << f->name << '\t' << f->count << '\t' << f->unit_price;
    return os;
}

class Fruit_comparison
{
public:
    bool operator()(const Fruit *a, const Fruit *b) const
    {
        return a->name < b->name;
    }
};

int main()
{
    try
    {
        set<Fruit *, Fruit_comparison> inventory;
        inventory.insert(new Fruit("Quince", 5));
        inventory.insert(new Fruit("Apple", 200, 0.37));
        inventory.insert(new Fruit("Orange", 150, 0.45));
        inventory.insert(new Fruit("Grape", 13, 0.99));
        inventory.insert(new Fruit("Kiwi", 512, 1.15));
        inventory.insert(new Fruit("Plum", 750, 2.33));

        typedef set<Fruit *, Fruit_comparison>::const_iterator Si;
        for (Si p = inventory.begin(); p != inventory.end(); ++p)
        {
            cout << *p << '\n';
        }
        cout << "inventory.size() = " << inventory.size() << endl;
        for (Si p = inventory.begin(); p != inventory.end(); ++p)
        {
            delete *p;
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Apple           200     0.37
Grape           13      0.99
Kiwi            512     1.15
Orange          150     0.45
Plum            750     2.33
Quince          5       0
inventory.size() = 6

ch21_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template<typename Ran, typename T>
bool my_binary_search(Ran first, Ran last, const T &val)
{
    if (first == last)
    {
        return false;
    }
    Ran p = first + (last - first) / 2;
    if (*p == val)
    {
        return true;
    }
    Ran p2 = p;
    ++p2;
    if (*p < val && p2 != last)
    {
        return my_binary_search(p2, last, val);
    }
    if (*p > val)
    {
        return my_binary_search(first, p, val);
    }
    return false;
}

template<typename Bid>
Bid middle(Bid first, Bid last)
{
    if (first == last)
    {
        error("first==last in middle");
    }

    int dist = 0;
    Bid p = first;
    while (p != last)
    {
        ++p;
        ++dist;
    }
    p = first;
    for (int i = 0; i < dist / 2; i++)
    {
        p++;
    }
    return p;
}

template<typename Bid, typename T>
bool my_binary_bid_search(Bid first, Bid last, const T &val)
{
    if (first == last)
    {
        return false;
    }
    Bid p = middle(first, last);
    if (*p == val)
    {
        return true;
    }
    Bid p2 = p;
    ++p2;
    if (*p < val && p2 != last)
    {
        return my_binary_bid_search(p2, last, val);
    }
    if (*p > val)
    {
        return my_binary_bid_search(first, p, val);
    }
    return false;
}

template<typename Iter>
void print(Iter first, Iter last)
{
    while (first != last)
    {
        cout << *first << '\n';
        ++first;
    }
}

int main()
{
    try
    {
        vector<int> vi;
        for (int i = 0; i < 20; ++i)
        {
            vi.push_back(2 * i);
        }
        cout << "Vector:\n";
        print(vi.begin(), vi.end());

        cout << "Enter int to find (-1 to exit): ";
        int i;
        while (cin >> i && i != -1)
        {
            cout << i << " is " << (my_binary_search(vi.begin(), vi.end(), i) ? "" : "not ") << "in vi.\n";
            cout << "Enter int to find (-1 to exit): ";
        }

        list<int> li(20);
        copy(vi.begin(), vi.end(), li.begin());
        cout << "\nList:\n";
        print(li.begin(), li.end());

        cout << "Enter int to find (-1 to exit): ";
        while (cin >> i && i != -1)
        {
            cout << i << " is " << (my_binary_bid_search(li.begin(), li.end(), i) ? "" : "not ") << "in li.\n";
            cout << "Enter int to find (-1 to exit): ";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Vector:
0
2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
Enter int to find (-1 to exit): 22
22 is in vi.
Enter int to find (-1 to exit): 23
23 is not in vi.
Enter int to find (-1 to exit): 25
25 is not in vi.
Enter int to find (-1 to exit): 26
26 is in vi.
Enter int to find (-1 to exit): 27
27 is not in vi.
Enter int to find (-1 to exit): 28
28 is in vi.
Enter int to find (-1 to exit): 29
29 is not in vi.
Enter int to find (-1 to exit): 30
30 is in vi.
Enter int to find (-1 to exit): -1

List:
0
2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
Enter int to find (-1 to exit): 32
32 is in li.
Enter int to find (-1 to exit): 33
33 is not in li.
Enter int to find (-1 to exit): 31
31 is not in li.
Enter int to find (-1 to exit): 36
36 is in li.
Enter int to find (-1 to exit): 35
35 is not in li.
Enter int to find (-1 to exit): 38
38 is in li.
Enter int to find (-1 to exit): 39
39 is not in li.
Enter int to find (-1 to exit): -1

ch21_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;
using std::make_pair;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main()
{
    try
    {
        map<string, int> words;

        const string ifname = "ch21_p08_in.txt";
        ifstream ifs(ifname.c_str());
        if (!ifs)
        {
            error("couldn't open " + ifname);
        }
        string s;
        while (ifs >> s)
        {
            ++words[s];
        }

        vector<pair<int, string> > v_words;

        typedef map<string, int>::const_iterator Iter;
        for (Iter p = words.begin(); p != words.end(); ++p)
        {
            v_words.push_back(make_pair(p->second, p->first));
        }
        sort(v_words.begin(), v_words.end());

        typedef vector<pair<int, string> >::const_iterator V_iter;
        for (V_iter p = v_words.begin(); p != v_words.end(); ++p)
        {
            cout << p->first << ": " << p->second << '\n';
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
1: C
1: C,
1: Except
1: In
1: addition
1: and
1: by
1: defining
1: designed
1: details,
1: efficient
1: enjoyable
1: flexible
1: general
1: language
1: language.
1: make
1: minor
1: more
1: new
1: of
1: programmer.
1: provided
1: provides
1: purpose
1: serious
1: superset
1: types.
2: a
2: facilities
2: is
2: to
3: C++
3: for
3: programming
3: the

cat ch21_p08_in.txt
C++ is a general purpose programming language designed to make
programming more enjoyable for the serious programmer. Except for minor
details, C++ is a superset of the C programming language. In addition to
the facilities provided by C, C++ provides flexible and efficient facilities
for defining new types.

ch21_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::merge;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;
using std::make_pair;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Day
{
public:
    explicit Day(int d) : val(d) { }
    int val;
};

ostream &operator<<(ostream &os, const Day &d)
{
    os << d.val;
    return os;
}

class Month
{
public:
    explicit Month(int m) : val(m) { }
    int val;
};

ostream &operator<<(ostream &os, const Month &m)
{
    os << m.val;
    return os;
}

class Year
{
public:
    explicit Year(int y) : val(y) { }
    int val;
};

ostream &operator<<(ostream &os, const Year &y)
{
    os << y.val;
    return os;
}

class Date
{
private:
    Day d;
    Month m;
    Year y;
public:
    Date() : d(1), m(1), y(1970) { }
    Date(const Day &day, const Month &month, const Year &year) : d(day), m(month), y(year) { }
    Date(const Date &r) : d(r.d), m(r.m), y(r.y) { }
    const Day &day() const
    {
        return d;
    }
    const Month &month() const
    {
        return m;
    }
    const Year &year() const
    {
        return y;
    }
};

ostream &operator<<(ostream &os, const Date &date)
{
    os << date.day() << '.' << date.month() << '.' << date.year();
    return os;
}

istream &operator>>(istream &is, Date &date)
{
    int d;
    int m;
    int y;
    char ch1;
    char ch2;
    is >> d;
    if (!is)
    {
        return is;
    }
    is >> ch1;
    if (!is)
    {
        return is;
    }
    is >> m;
    if (!is)
    {
        return is;
    }
    is >> ch2;
    if (!is)
    {
        return is;
    }
    is >> y;
    if (!is)
    {
        return is;
    }
    if (ch1 != '.' || ch2 != '.')
    {
        is.clear(std::ios_base::failbit);
        return is;
    }
    date = Date(Day(d), Month(m), Year(y));
    return is;
}

class Purchase
{
private:
    string n;
    double up;
    int c;
public:
    Purchase() : n(""), up(0.0), c(0) { }
    Purchase(const string &name, double unit_price, int count) : n(name), up(unit_price), c(count) { }
    const string &name() const
    {
        return n;
    }
    double unit_price() const
    {
        return up;
    }
    int count() const
    {
        return c;
    }
};

ostream &operator<<(ostream &os, const Purchase &p)
{
    os << p.name() << " | " << p.unit_price() << " | " << p.count();
    return os;
}

istream &operator>>(istream &is, Purchase &p)
{
    string name;
    getline(is, name, '|');
    if (!is)
    {
        return is;
    }
    if (name.size() == 0)
    {
        is.clear(std::ios_base::failbit);
        return is;
    }
    name.pop_back();
    double unit_price;
    char ch2;
    int count;
    is >> unit_price;
    if (!is)
    {
        return is;
    }
    is >> ch2;
    if (!is)
    {
        return is;
    }
    is >> count;
    if (!is)
    {
        return is;
    }
    if (ch2 != '|')
    {
        is.clear(std::ios_base::failbit);
        return is;
    }
    p = Purchase(name, unit_price, count);
    return is;
}

class Order
{
private:
    string n;
    string addr;
    Date d;
    vector<Purchase> vp;
public:
    Order() : n(), addr(), d(), vp() { }
    Order(const string &name, const string &address, const Date &date, const vector<Purchase> &vpurchases)
        : n(name), addr(address), d(date), vp(vpurchases) { }
    const string &name() const
    {
        return n;
    }
    const string &address() const
    {
        return addr;
    }
    const Date &date() const
    {
        return d;
    }
    int n_purchases() const
    {
        return vp.size();
    }
    const Purchase &purchase(int i) const
    {
        return vp[i];
    }
};

ostream &operator<<(ostream &os, const Order &o)
{
    os << o.name() << '\n' << o.address() << '\n' << o.date() << '\n';
    for (int i = 0; i < o.n_purchases(); ++i)
    {
        os << o.purchase(i) << '\n';
    }
    return os;
}

istream &operator>>(istream &is, Order &o)
{
    char ch;
    while (is >> ch)
    {
        if (ch != '\n')
        {
            is.unget();
            break;
        }
    }
    string name;
    getline(is, name, '\n');
    if (!is)
    {
        return is;
    }
    string address;
    getline(is, address, '\n');
    if (!is)
    {
        return is;
    }
    Date date;
    is >> date;
    if (!is)
    {
        return is;
    }
    is.ignore();
    string line;
    vector<Purchase> purchases;
    while (getline(is, line, '\n') && line != "")
    {
        Purchase purchase;
        istringstream iss(line);
        iss >> purchase;
        purchases.push_back(purchase);
    }
    o = Order(name, address, date, purchases);
    return is;
}

template<typename T>
class Sort_by_name
{
public:
    bool operator()(const T &a, const T &b) const
    {
        return a.name() < b.name();
    }
};

template<typename T>
class Sort_by_address
{
public:
    bool operator()(const T &a, const T &b) const
    {
        return a.address() < b.address();
    }
};

template<typename Cont>
void read_orders_from_file(Cont &c, const string &fname)
{
    ifstream ifs(fname.c_str());
    if (!ifs)
    {
        error("can't open file " + fname);
    }
    Order o;
    while (ifs >> o)
    {
        c.push_back(o);
    }
}

template<typename Iter>
void write_orders_to_file(Iter first, Iter last, const string &fname)
{
    ofstream ofs(fname.c_str());
    if (!ofs)
    {
        error("can't open file " + fname);
    }
    while (first != last)
    {
        ofs << *first << '\n';
        ++first;
    }
}

int main()
{
    try
    {
        const string ifname1 = "ch21_p09_in1.txt";
        vector<Order> vo;
        read_orders_from_file(vo, ifname1);

        sort(vo.begin(), vo.end(), Sort_by_name<Order>());
        for (int i = 0; i < vo.size(); ++i)
        {
            cout << vo[i] << '\n';
        }

        const string ofname1 = "ch21_p09_out1.txt";
        write_orders_to_file(vo.begin(), vo.end(), ofname1);

        const string ifname2 = "ch21_p09_in2.txt";
        list<Order> lo;
        read_orders_from_file(lo, ifname2);

        cout << "\n";
        lo.sort(Sort_by_address<Order>());
        typedef list<Order>::iterator Liter;
        for (Liter it = lo.begin(); it != lo.end(); ++it)
        {
            cout << *it << '\n';
        }

        const string ofname2 = "ch21_p09_out2.txt";
        write_orders_to_file(lo.begin(), lo.end(), ofname2);

        lo.sort(Sort_by_name<Order>());
        vector<Order> vo_merge(vo.size() + lo.size());
        merge(vo.begin(), vo.end(), lo.begin(), lo.end(), vo_merge.begin(), Sort_by_name<Order>());
        const string ofname3 = "ch21_p09_out3.txt";
        write_orders_to_file(vo_merge.begin(), vo_merge.end(), ofname3);

        set<Order, Sort_by_name<Order>> so;
        typedef vector<Order>::iterator Viter;
        for (Viter it = vo_merge.begin(); it != vo_merge.end(); ++it)
        {
            so.insert(*it);
        }

        cout << "\n";
        double val_t = 0;
        for (set<Order>::iterator it = so.begin(); it != so.end(); ++it)
        {
            cout << *it << '\n';
            for (int i = 0; i < (*it).n_purchases(); ++i)
            {
                val_t += (*it).purchase(i).count() * (*it).purchase(i).unit_price();
            }
            cout << "Running total so far: " << val_t << "\n\n";
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Ardelia Allington
16 Warren Close, Ryton-on-Dunsmore, Coventry, Warwickshire CV8 3JZ, UK
20.11.2014
Frozen Little Golden Book | 2.17 | 3
Humans of New York | 17.99 | 3

Babette Brennan
4 Livera Street, Evanton, Dingwall, Highland IV16, UK
6.2.2014
Yes Please | 14.5 | 2
The Book with No Pictures | 10.79 | 5
Ultimate Sticker Book: Frozen | 4.19 | 5

Cliff Cantin
1 Bealings Road, Martlesham, Woodbridge, Suffolk IP12 4RW, UK
15.1.2014
Diary of a Wimpy Kid | 7.75 | 2

Emilee Eiler
29 Clayfield Road, Bretforton, Evesham, Worcestershire WR11 7HS, UK
26.9.2014
What If? | 14.4 | 5

Ha Hollowell
21 Heddon Place, Birmingham, West Midlands B7 4EX, UK
23.2.2014
Laugh-Out-Loud Jokes for Kids | 2.99 | 1
Unbroken: A World War II Story | 9.6 | 5

Lucius Legrand
16 Mundys Field, Ruan Minor, Helston, Cornwall TR12 7LF, UK
1.1.2013
Yes Please | 14.5 | 2
Minecraft: The Complete Handbook | 19.18 | 1

Matt Manahan
9 Haslam Crescent, Sheffield, South Yorkshire S8 7GT, UK
21.5.2013
Knock-Knock Jokes for Kids | 3.23 | 1
Killing Patton | 15.41 | 2
Thug Kitchen | 14.9 | 4

Nicolette New
9-11 Nevill Road, Brighton and Hove, Brighton, East Sussex BN2 7HH, UK
17.6.2013
The Day the Crayons Quit | 9.12 | 5

Tyler Tevis
New Road, Worcester, Worcestershire WR2, UK
6.4.2013
The Boys in the Boat | 10.2 | 2


Cliff Cantin
1 Bealings Road, Martlesham, Woodbridge, Suffolk IP12 4RW, UK
15.1.2014
Diary of a Wimpy Kid | 7.75 | 2

Augustus Amyx
17 Manner Street, Macduff, Aberdeenshire AB44 1SE, UK
28.4.2014
Ultra Pro 25.9 | 8.29 | 2

Bari Barnette
1A Orchard Castle, Cardiff, Cardiff CF14 9BA, UK
12.8.2013
FlipBelt | 27.19 | 1
Spalding NBA Street Basketball | 10.59 | 1

Ha Hollowell
21 Heddon Place, Birmingham, West Midlands B7 4EX, UK
23.2.2014
Laugh-Out-Loud Jokes for Kids | 2.99 | 1
Unbroken: A World War II Story | 9.6 | 5

Charolette Cusick
352-354 Birmingham Road, Sutton Coldfield, West Midlands B72 1YH, UK
4.7.2013
Lifestraw Personal Water Filter | 19.9 | 3
Zipp A-Frame Hand Warmer | 9.83 | 2
New Era On field Hat | 14.4 | 1

Logan Laino
4 Denmark Rise, North Cave, Brough, East Riding of Yorkshire HU15 2NB, UK
6.3.2013
Diary of a Wimpy Kid | 7.75 | 5
Killing Patton | 15.41 | 5

Miguelina Marinelli
5 Stevens Place, Gourock, Inverclyde PA19 1YY, UK
16.2.2014
Wrist Wraps + Lifting Straps | 16.95 | 3
Razor A Kick Scooter | 27.72 | 3
Tac Force TF-705 Series | 3.96 | 2
Victorinox Swiss Army Classic | 9.99 | 2

Bernita Biggerstaff
New Forest National Park, 1 Yewtree Cottages, Lyndhurst, Hampshire SO43 7AY, UK
25.4.2014
Nalgene Tritan Wide Mouth | 5.75 | 3
SoundAsleep Dream Series Mattress | 119.95 | 2
Replacement Wrist Band | 0.65 | 1

Clarine Chance
RAF Mildenhall, 139A Lancaster Road, Beck Row, Bury Saint Edmunds, Suffolk IP28 8HE, UK
26.10.2013
Zippo Lighter Fluid | 7.09 | 3
Polar FT4 HRM | 50.2 | 2
SKLZ Pro Mini Basketball Hoop | 19.99 | 1


Ardelia Allington
16 Warren Close, Ryton-on-Dunsmore, Coventry, Warwickshire CV8 3JZ, UK
20.11.2014
Frozen Little Golden Book | 2.17 | 3
Humans of New York | 17.99 | 3

Running total so far: 60.48

Augustus Amyx
17 Manner Street, Macduff, Aberdeenshire AB44 1SE, UK
28.4.2014
Ultra Pro 25.9 | 8.29 | 2

Running total so far: 77.06

Babette Brennan
4 Livera Street, Evanton, Dingwall, Highland IV16, UK
6.2.2014
Yes Please | 14.5 | 2
The Book with No Pictures | 10.79 | 5
Ultimate Sticker Book: Frozen | 4.19 | 5

Running total so far: 180.96

Bari Barnette
1A Orchard Castle, Cardiff, Cardiff CF14 9BA, UK
12.8.2013
FlipBelt | 27.19 | 1
Spalding NBA Street Basketball | 10.59 | 1

Running total so far: 218.74

Bernita Biggerstaff
New Forest National Park, 1 Yewtree Cottages, Lyndhurst, Hampshire SO43 7AY, UK
25.4.2014
Nalgene Tritan Wide Mouth | 5.75 | 3
SoundAsleep Dream Series Mattress | 119.95 | 2
Replacement Wrist Band | 0.65 | 1

Running total so far: 476.54

Charolette Cusick
352-354 Birmingham Road, Sutton Coldfield, West Midlands B72 1YH, UK
4.7.2013
Lifestraw Personal Water Filter | 19.9 | 3
Zipp A-Frame Hand Warmer | 9.83 | 2
New Era On field Hat | 14.4 | 1

Running total so far: 570.3

Clarine Chance
RAF Mildenhall, 139A Lancaster Road, Beck Row, Bury Saint Edmunds, Suffolk IP28 8HE, UK
26.10.2013
Zippo Lighter Fluid | 7.09 | 3
Polar FT4 HRM | 50.2 | 2
SKLZ Pro Mini Basketball Hoop | 19.99 | 1

Running total so far: 711.96

Cliff Cantin
1 Bealings Road, Martlesham, Woodbridge, Suffolk IP12 4RW, UK
15.1.2014
Diary of a Wimpy Kid | 7.75 | 2

Running total so far: 727.46

Emilee Eiler
29 Clayfield Road, Bretforton, Evesham, Worcestershire WR11 7HS, UK
26.9.2014
What If? | 14.4 | 5

Running total so far: 799.46

Ha Hollowell
21 Heddon Place, Birmingham, West Midlands B7 4EX, UK
23.2.2014
Laugh-Out-Loud Jokes for Kids | 2.99 | 1
Unbroken: A World War II Story | 9.6 | 5

Running total so far: 850.45

Logan Laino
4 Denmark Rise, North Cave, Brough, East Riding of Yorkshire HU15 2NB, UK
6.3.2013
Diary of a Wimpy Kid | 7.75 | 5
Killing Patton | 15.41 | 5

Running total so far: 966.25

Lucius Legrand
16 Mundys Field, Ruan Minor, Helston, Cornwall TR12 7LF, UK
1.1.2013
Yes Please | 14.5 | 2
Minecraft: The Complete Handbook | 19.18 | 1

Running total so far: 1014.43

Matt Manahan
9 Haslam Crescent, Sheffield, South Yorkshire S8 7GT, UK
21.5.2013
Knock-Knock Jokes for Kids | 3.23 | 1
Killing Patton | 15.41 | 2
Thug Kitchen | 14.9 | 4

Running total so far: 1108.08

Miguelina Marinelli
5 Stevens Place, Gourock, Inverclyde PA19 1YY, UK
16.2.2014
Wrist Wraps + Lifting Straps | 16.95 | 3
Razor A Kick Scooter | 27.72 | 3
Tac Force TF-705 Series | 3.96 | 2
Victorinox Swiss Army Classic | 9.99 | 2

Running total so far: 1269.99

Nicolette New
9-11 Nevill Road, Brighton and Hove, Brighton, East Sussex BN2 7HH, UK
17.6.2013
The Day the Crayons Quit | 9.12 | 5

Running total so far: 1315.59

Tyler Tevis
New Road, Worcester, Worcestershire WR2, UK
6.4.2013
The Boys in the Boat | 10.2 | 2

Running total so far: 1335.99

cat ch21_p09_in1.txt
Lucius Legrand
16 Mundys Field, Ruan Minor, Helston, Cornwall TR12 7LF, UK
01.01.2013
Yes Please | 14.50 | 2
Minecraft: The Complete Handbook | 19.18 | 1

Ha Hollowell
21 Heddon Place, Birmingham, West Midlands B7 4EX, UK
23.02.2014
Laugh-Out-Loud Jokes for Kids | 2.99 | 1
Unbroken: A World War II Story | 9.60 | 5

Emilee Eiler
29 Clayfield Road, Bretforton, Evesham, Worcestershire WR11 7HS, UK
26.09.2014
What If? | 14.40 | 5

Matt Manahan
9 Haslam Crescent, Sheffield, South Yorkshire S8 7GT, UK
21.05.2013
Knock-Knock Jokes for Kids | 3.23 | 1
Killing Patton | 15.41 | 2
Thug Kitchen | 14.90 | 4

Babette Brennan
4 Livera Street, Evanton, Dingwall, Highland IV16, UK
06.02.2014
Yes Please | 14.50 | 2
The Book with No Pictures | 10.79 | 5
Ultimate Sticker Book: Frozen | 4.19 | 5

Cliff Cantin
1 Bealings Road, Martlesham, Woodbridge, Suffolk IP12 4RW, UK
15.01.2014
Diary of a Wimpy Kid | 7.75 | 2

Ardelia Allington
16 Warren Close, Ryton-on-Dunsmore, Coventry, Warwickshire CV8 3JZ, UK
20.11.2014
Frozen Little Golden Book | 2.17 | 3
Humans of New York | 17.99 | 3

Nicolette New
9-11 Nevill Road, Brighton and Hove, Brighton, East Sussex BN2 7HH, UK
17.06.2013
The Day the Crayons Quit | 9.12 | 5

Tyler Tevis
New Road, Worcester, Worcestershire WR2, UK
06.04.2013
The Boys in the Boat | 10.20 | 2

Logan Laino
4 Denmark Rise, North Cave, Brough, East Riding of Yorkshire HU15 2NB, UK
06.03.2013
Diary of a Wimpy Kid | 7.75 | 5
Killing Patton | 15.41 | 5

cat ch21_p09_in2.txt
Ha Hollowell
21 Heddon Place, Birmingham, West Midlands B7 4EX, UK
23.02.2014
Laugh-Out-Loud Jokes for Kids | 2.99 | 1
Unbroken: A World War II Story | 9.60 | 5

Cliff Cantin
1 Bealings Road, Martlesham, Woodbridge, Suffolk IP12 4RW, UK
15.01.2014
Diary of a Wimpy Kid | 7.75 | 2

Logan Laino
4 Denmark Rise, North Cave, Brough, East Riding of Yorkshire HU15 2NB, UK
06.03.2013
Diary of a Wimpy Kid | 7.75 | 5
Killing Patton | 15.41 | 5

Charolette Cusick
352-354 Birmingham Road, Sutton Coldfield, West Midlands B72 1YH, UK
04.07.2013
Lifestraw Personal Water Filter | 19.90 | 3
Zipp A-Frame Hand Warmer | 9.83 | 2
New Era On field Hat | 14.40 | 1

Bari Barnette
1A Orchard Castle, Cardiff, Cardiff CF14 9BA, UK
12.08.2013
FlipBelt | 27.19 | 1
Spalding NBA Street Basketball | 10.59 | 1

Clarine Chance
RAF Mildenhall, 139A Lancaster Road, Beck Row, Bury Saint Edmunds, Suffolk IP28 8HE, UK
26.10.2013
Zippo Lighter Fluid | 7.09 | 3
Polar FT4 HRM | 50.20 | 2
SKLZ Pro Mini Basketball Hoop | 19.99 | 1

Miguelina Marinelli
5 Stevens Place, Gourock, Inverclyde PA19 1YY, UK
16.02.2014
Wrist Wraps + Lifting Straps | 16.95 | 3
Razor A Kick Scooter | 27.72 | 3
Tac Force TF-705 Series | 3.96 | 2
Victorinox Swiss Army Classic | 9.99 | 2

Bernita Biggerstaff
New Forest National Park, 1 Yewtree Cottages, Lyndhurst, Hampshire SO43 7AY, UK
25.04.2014
Nalgene Tritan Wide Mouth | 5.75 | 3
SoundAsleep Dream Series Mattress | 119.95 | 2
Replacement Wrist Band | 0.65 | 1

Augustus Amyx
17 Manner Street, Macduff, Aberdeenshire AB44 1SE, UK
28.04.2014
Ultra Pro 25.9 | 8.29 | 2

Roman Rierson
40 Anyards Road, Cobham, Surrey KT11 2LA, UK
22.11.2014
Black Mountain Resistance Bands | 29.99 | 2

ch21_p13.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

map<string, int> clean_txt(const string &fname)
{
    ifstream ifs(fname);
    if (!ifs)
    {
        error("Can not open file " + fname);
    }
    ostringstream oss;

    char ch;
    while (ifs.get(ch))
    {
        if (ispunct(ch) && ch != '\'')
        {
            ch = ' ';
        }
        oss << char(tolower(ch));
    }

    map<string, int> words;
    istringstream iss(oss.str());
    string w;
    while (iss >> w)
    {
        if (w == "can't")
        {
            ++words["cannot"];
        }
        else if (w == "shan't")
        {
            ++words["shall"];
            ++words["not"];
        }
        else if (w == "won't")
        {
            ++words["will"];
            ++words["not"];
        }
        else if (w == "let's")
        {
            ++words["let"];
            ++words["us"];
        }
        else if (w == "'" || w.size() == 2 && w[0] == '\'')
        {
            // do nothing, don't add word
        }
        else if (w.size() >= 3 && *(w.end() - 2) == '\'')
        {
            switch (w.back())
            {
            case 'd':
                ++words["would"];
                ++words[w.substr(0, w.size() - 2)];
                break;
            case 'm':
                ++words["am"];
                ++words[w.substr(0, w.size() - 2)];
                break;
            case 's':
                ++words["is"];
                ++words[w.substr(0, w.size() - 2)];
                break;
            case 't':
                ++words["not"];
                ++words[w.substr(0, w.size() - 3)];
                break;
            default:
                break;
            }
        }
        else if (w.size() >= 4 && *(w.end() - 3) == '\'')
        {
            switch (*(w.end() - 2))
            {
            case 'l':
                ++words["will"];
                ++words[w.substr(0, w.size() - 3)];
                break;
            case 'r':
                ++words["are"];
                ++words[w.substr(0, w.size() - 3)];
                break;
            case 'v':
                ++words["have"];
                ++words[w.substr(0, w.size() - 3)];
                break;
            default:
                break;
            }
        }
        else
        {
            ++words[w];
        }
    }

    typedef map<string, int>::iterator Iter;
    for (Iter p = words.begin(); p != words.end(); ++p)
    {
        Iter q = p;
        ++q;
        if (q != words.end() && q->first[0] == p->first[0]
                && q->first.size() == p->first.size() + 1
                && q->first == p->first + "s")
        {
            q = words.erase(q);
        }
    }

    return words;
}

int main()
{
    try
    {
        string ifname = "ch21_p13_in.txt";
        map<string, int> words = clean_txt(ifname);
        typedef map<string, int>::iterator Iter;
        for (Iter p = words.begin(); p != words.end(); ++p)
        {
            cout << setw(12) << left << p->first << '\t' << p->second << '\n';
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
cat ch21_p13_in.txt
I'm I'd aren't can't couldn't didn't doesn't don't hadn't hasn't haven't he'd he'll he's I'd I'll I'm I've
isn't it's let's mustn't shan't she'd she'll she's shouldn't that's there's they'd they'll they're
they've we'd we're we've weren't what'll what're what's what've where's who'd who'll who're
who's who've won't wouldn't you'd you'll you're you've

ch21_p13
am              2
are             6
cannot          1
could           1
did             1
do              1
does            1
had             1
has             1
have            7
he              3
i               6
it              1
let             1
must            1
not             15
shall           1
she             3
should          1
that            1
there           1
they            4
us              1
we              3
were            1
what            4
where           1
who             5
will            8
would           9
you             4

ch21_p14.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::copy_if;
using std::count_if;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


namespace Text_query
{
    map<string, int> clean_txt(const string &fname);
    int num_of_occurrences(const string &word, const map<string, int> &clean_txt);
    string most_frequent(const map<string, int> &clean_txt);
    string longest(const map<string, int> &clean_txt);
    string shortest(const map<string, int> &clean_txt);

    class First_char
    {
    private:
        char ch;
    public:
        First_char(char c) : ch(c) { }
        bool operator()(const pair<string, int> &p) const
        {
            return p.first[0] == ch;
        }
    };

    vector<string> start_with(char ch, const map<string, int> &clean_txt);

    class Length
    {
    private:
        int n;
    public:
        Length(int nn) : n(nn) { }
        bool operator()(const pair<string, int> &p) const
        {
            return p.first.size() == n;
        }
    };

    vector<string> has_length(int n, const map<string, int> &clean_txt);
}

namespace Text_query
{
    map<string, int> clean_txt(const string &fname)
    {
        ifstream ifs(fname);
        if (!ifs)
        {
            error("Can not open file " + fname);
        }
        ostringstream oss;

        char ch;
        while (ifs.get(ch))
        {
            if (ispunct(ch) && ch != '\'')
            {
                ch = ' ';
            }
            oss << char(tolower(ch));
        }

        map<string, int> words;
        istringstream iss(oss.str());
        string w;
        while (iss >> w)
        {
            if (w == "can't")
            {
                ++words["cannot"];
            }
            else if (w == "shan't")
            {
                ++words["shall"];
                ++words["not"];
            }
            else if (w == "won't")
            {
                ++words["will"];
                ++words["not"];
            }
            else if (w == "let's")
            {
                ++words["let"];
                ++words["us"];
            }
            else if (w == "'" || w.size() == 2 && w[0] == '\'')
            {
                // do nothing, don't add word
            }
            else if (w.size() >= 3 && *(w.end() - 2) == '\'')
            {
                switch (w.back())
                {
                case 'd':
                    ++words["would"];
                    ++words[w.substr(0, w.size() - 2)];
                    break;
                case 'm':
                    ++words["am"];
                    ++words[w.substr(0, w.size() - 2)];
                    break;
                case 's':
                    ++words["is"];
                    ++words[w.substr(0, w.size() - 2)];
                    break;
                case 't':
                    ++words["not"];
                    ++words[w.substr(0, w.size() - 3)];
                    break;
                default:
                    break;
                }
            }
            else if (w.size() >= 4 && *(w.end() - 3) == '\'')
            {
                switch (*(w.end() - 2))
                {
                case 'l':
                    ++words["will"];
                    ++words[w.substr(0, w.size() - 3)];
                    break;
                case 'r':
                    ++words["are"];
                    ++words[w.substr(0, w.size() - 3)];
                    break;
                case 'v':
                    ++words["have"];
                    ++words[w.substr(0, w.size() - 3)];
                    break;
                default:
                    break;
                }
            }
            else
            {
                ++words[w];
            }
        }

        typedef map<string, int>::iterator Iter;
        for (Iter p = words.begin(); p != words.end(); ++p)
        {
            Iter q = p;
            ++q;
            if (q != words.end() && q->first[0] == p->first[0]
                    && q->first.size() == p->first.size() + 1
                    && q->first == p->first + "s")
            {
                q = words.erase(q);
            }
        }

        return words;
    }

    int num_of_occurrences(const string &word, const map<string, int> &clean_txt)
    {
        if (clean_txt.find(word) != clean_txt.end())
        {
            return clean_txt.at(word);
        }
        else
        {
            return 0;
        }
    }

    string most_frequent(const map<string, int> &clean_txt)
    {
        string s;
        int max = 0;
        typedef map<string, int>::const_iterator Iter;
        for (Iter p = clean_txt.begin(); p != clean_txt.end(); ++p)
        {
            if (p->second > max)
            {
                max = p->second;
                s = p->first;
            }
        }
        return s;
    }

    string longest(const map<string, int> &clean_txt)
    {
        string s;
        int l_max = 0;
        typedef map<string, int>::const_iterator Iter;
        for (Iter p = clean_txt.begin(); p != clean_txt.end(); ++p)
        {
            if (p->first.length() > l_max)
            {
                l_max = p->first.length();
                s = p->first;
            }
        }
        return s;
    }

    string shortest(const map<string, int> &clean_txt)
    {
        string s;
        typedef map<string, int>::const_iterator Iter;
        Iter p = clean_txt.begin();
        s = p->first;
        int l_min = p->first.length();
        ++p;
        for (; p != clean_txt.end(); ++p)
        {
            if (p->first.length() < l_min)
            {
                l_min = p->first.length();
                s = p->first;
            }
        }
        return s;
    }

    vector<string> start_with(char ch, const map<string, int> &clean_txt)
    {
        int count = count_if(clean_txt.begin(), clean_txt.end(), First_char(ch));
        vector<pair<string, int>> vp(count);
        copy_if(clean_txt.begin(), clean_txt.end(), vp.begin(), First_char(ch));
        vector<string> vs;
        for (int i = 0; i < vp.size(); ++i)
        {
            vs.push_back(vp[i].first);
        }
        return vs;
    }

    vector<string> has_length(int n, const map<string, int> &clean_txt)
    {
        int count = count_if(clean_txt.begin(), clean_txt.end(), Length(n));
        vector<pair<string, int>> vp(count);
        copy_if(clean_txt.begin(), clean_txt.end(), vp.begin(), Length(n));
        vector<string> vs;
        for (int i = 0; i < vp.size(); ++i)
        {
            vs.push_back(vp[i].first);
        }
        return vs;
    }
}

void print_menu()
{
    cout << "What would you like to do?\n"
         << "1 - Enter input file name\n"
         << "2 - Get number of occurrences of a word\n"
         << "3 - Get most frequent word\n"
         << "4 - Get longest word\n"
         << "5 - Get shortest word\n"
         << "6 - Get words starting with a specific letter\n"
         << "7 - Get words of a specific length\n"
         << "0 - Exit\n";
}

string get_ifname()
{
    cout << "\nEnter input file name: ";
    string s;
    cin >> s;
    cout << '\n';
    return s;
}

bool file_check(const string &fname)
{
    if (fname == "")
    {
        cout << "\nFile name is empty!\n\n";
        return false;
    }

    ifstream ifs(fname.c_str());
    if (!ifs)
    {
        cout << "\nFile " << fname << " doesn't exist!\n\n";
        return false;
    }

    return true;
}

void get_n_occurrences(const map<string, int> &clean_txt)
{
    if (clean_txt.size() == 0)
    {
        cout << "\nNo text loaded!\n\n";
        return;
    }
    cout << "\nEnter word: ";
    string s;
    cin >> s;
    int n = Text_query::num_of_occurrences(s, clean_txt);
    cout << "\n\'" << s << "\' occurs " << n << " time" << (n == 1 ? "" : "s") << ".\n\n";
}

void get_most_frequent(const map<string, int> &clean_txt)
{
    if (clean_txt.size() == 0)
    {
        cout << "\nNo text loaded!\n\n";
        return;
    }
    string s = Text_query::most_frequent(clean_txt);
    cout << "\nThe most frequent word is \'" << s << "\'.\n\n";
}

void get_longest(const map<string, int> &clean_txt)
{
    if (clean_txt.size() == 0)
    {
        cout << "\nNo text loaded!\n\n";
        return;
    }
    string s = Text_query::longest(clean_txt);
    cout << "\nThe longest word is \'" << s << "\'.\n\n";
}

void get_shortest(const map<string, int> &clean_txt)
{
    if (clean_txt.size() == 0)
    {
        cout << "\nNo text loaded!\n\n";
        return;
    }
    string s = Text_query::shortest(clean_txt);
    cout << "\nThe shortest word is \'" << s << "\'.\n\n";
}

void get_start_with(const map<string, int> &clean_txt)
{
    if (clean_txt.size() == 0)
    {
        cout << "\nNo text loaded!\n\n";
        return;
    }
    cout << "\nEnter character: ";
    char ch;
    cin >> ch;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    vector<string> vs = Text_query::start_with(ch, clean_txt);
    cout << "\nWords starting with '" << ch << "':\n";
    for (int i = 0; i < vs.size(); ++i)
    {
        cout << vs[i] << '\n';
    }
    cout << '\n';
}

void get_has_length(const map<string, int> &clean_txt)
{
    if (clean_txt.size() == 0)
    {
        cout << "\nNo text loaded!\n\n";
        return;
    }
    cout << "\nEnter number of characters: ";
    int n;
    while (!( cin >> n))
    {
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
        cout << "\nPlease enter a number\n";
        cout << "\nEnter number of characters: ";
    }
    vector<string> vs = Text_query::has_length(n, clean_txt);
    cout << "\nWords with " << n << " characters:\n";
    for (int i = 0; i < vs.size(); ++i)
    {
        cout << vs[i] << '\n';
    }
    cout << '\n';
}

int main()
{
    try
    {
        string ifname;
        map<string, int> words;

        bool keep_running = true;
        while (keep_running)
        {
            print_menu();
            int n;
            while (!(cin >> n))
            {
                cin.clear();
                cin.ignore(numeric_limits<streamsize>::max(), '\n');
                cout << "\nPlease enter a number\n";
                print_menu();
            }
            switch (n)
            {
            case 0:
                keep_running = false;
                break;
            case 1:
                ifname = get_ifname();
                if (file_check(ifname))
                {
                    words = Text_query::clean_txt(ifname);
                }
                break;
            case 2:
                get_n_occurrences(words);
                break;
            case 3:
                get_most_frequent(words);
                break;
            case 4:
                get_longest(words);
                break;
            case 5:
                get_shortest(words);
                break;
            case 6:
                get_start_with(words);
                break;
            case 7:
                get_has_length(words);
                break;
            default:
                cout << "\nEnter a number between 0 and 7\n\n";
                break;
            }
        }
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
1

Enter input file name: ch21_p13_in.txt

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
3

The most frequent word is 'not'.

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
2

Enter word: would

'would' occurs 9 times.

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
4

The longest word is 'cannot'.

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
5

The shortest word is 'i'.

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
6

Enter character: w

Words starting with 'w':
we
were
what
where
who
will
would

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
7

Enter number of characters: 5

Words with 5 characters:
could
shall
there
where
would

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
0
