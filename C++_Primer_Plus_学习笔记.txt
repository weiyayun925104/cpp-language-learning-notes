C++ Primer Plus 第6版 中文版
第1章 预备知识
1.1 C++简介
1.2 C++简史
1.2.1 C语言
1.2.2 C语言编程原理
1.2.3 面向对象编程
1.2.4 C++和泛型编程
1.2.5 C++的起源
1.3 可移植性和标准
1.3.1 C++的发展
1.3.2 本书遵循的C++标准
1.4 程序创建的技巧
1.4.1 创建源代码文件
1.4.2 编译和链接
1.5 总结
本章内容包括：
C语言和C++语言的发展历史和基本原理。
过程性编程和面向对象编程。
C++是如何在C语言的基础上添加面向对象概念的。
C++是如何在C语言的基础上添加泛型编程概念的。
编程语言标准。
创建程序的技巧。
欢迎进入C++世界！这是一种令人兴奋的语言，它在C语言的基础上添加了对面向对象编程和泛型编程的支持，
在20世纪90年代便是最重要的编程语言之一，并在21世纪仍保持强劲势头。
C++继承了C语言高效、简洁、快速和可移植性的传统。
C++面向对象的特性带来了全新的编程方法，这种方法是为应付复杂程度不断提高的现代编程任务而设计的。
C++的模板特性提供了另一种全新的编程方法―泛型编程。
这三件法宝既是福也是祸，一方面让C++语言功能强大，另一方面则意味着有更多的东西需要学习。
本章首先介绍C++的背景，然后介绍创建C++程序的一些基本原则。本书其他章节将讲述如何使用C++语言，
从最浅显的基本知识开始，到面向对象的编程（OOP）及其支持的新术语――对象、类、封装、数据隐藏、多态和继承等，
然后介绍它对泛型编程的支持（当然，随着您对C++的学习，这些词汇将从花里胡哨的词语变为论述中必不可少的术语）。
1.1 C++简介
C++融合了3种不同的编程方式：C语言代表的过程性语言、C++在C语言基础上添加的类代表的面向对象语言、C++模板支持的泛型编程。
本章将简要介绍这些传统。不过首先，我们来看看这种传统对于学习C++来说意味着什么。
使用C++的原因之一是为了利用其面向对象的特性。要利用这种特性，必须对标准C语言知识有较深入的了解，因为它提供了基本类型、运算符、控制结构和语法规则。
所以，如果已经对C有所了解，便可以学习C++了，但这并不仅仅是学习更多的关键字和结构，从C过渡到C++的学习量就像从头学习C语言一样大。
另外，如果先掌握了C语言，则在过渡到C++时，必须摈弃一些编程习惯。
如果不了解C语言，则学习C++时需要掌握C语言的知识、OOP知识以及泛型编程知识，但无需挨弃任何编程习惯。
如果您认为学习C++可能需要扩展思维，这就对了。本书将以清晰的、帮助的方式，引导读者一步一个脚印地学习，
因此扩展思维的过程是温和的，不至于让您的大脑接受不了。
本书通过传授C语言基础知识和C++新增的内容，带您步入C++的世界，因此不要求读者具备C语言知识。
首先学习C++与C语言共有的一些特性。即使已经了解C语言，也会发现阅读本书的这一部分是一次很好的复习。
另外，本章还介绍了一些对后面的学习十分重要的概念，指出了C++和C之间的区别。
在牢固地掌握了C语言的基础知识后，就可以在此基础上学习C++方面的知识了。
那时将学习对象和类以及C++是如何实现它们的；另外还将学习模板。
本书不是完整的C++参考手册，不会探索该语言的每个细节，但将介绍所有的重要特性，包括模板、异常和名称空间等。
下面简要地介绍一下C++的背景知识。
1.2 C++简史
在过去的几十年，计算机技术以令大惊讶的速度发展着，当前，笔记本电脑的计算速度和存储信息的能力超过了20世纪60年代的大型机。
很多程序员可能还记得，将数叠穿孔卡片提交给充斥整个房间的大型计算机系统的时代，而这种系统只有100KB的内存，比当今智能手机的内存都少得多。
计算机语言也得到了发展，尽管变化可能不是天翻地覆的，但也是非常重要的。
体积更大、功能更强的计算机引出了更大、更复杂的程序，而这些程序在程序管理和维护方面带来了新的问题。
在20世纪70年代，C和Pascal这样的语言引领人们进入了结构化编程时代，这种机制把秩序和规程带进了迫切需要这种性质的领域中。
除了提供结构化编程工具外，C还能生成简洁、快速运行的程序，并提供了处理硬件问题的能力，如管理通信端口和磁盘驱动器。
这些因素使C语言成为20世纪80年代占统治地位的编程语言。同时，20世纪80年代，人们也见证了一种新编程模式的成长：面向对象编程（OOP）。
SmallTalk和C++语言具备这种功能。下面更深入地介绍C和OOP。
1.2.1 C语言
20世纪70年代早期，贝尔实验室的Dennis Ritchie致力于开发UNIX操作系统（操作系统是能够管理计算机资源、处理计算机与用户产之间交互的一组程序。
例如，操作系统将系统提示符显示在屏幕上以提供终端式界面、提供管理窗口和鼠标的图形界面以及运行程序）。
为完成这项工作，Ritchie需要一种语言，它必须简洁，能够生成简洁、快速的程序，并能有效地控制硬件。
传统上，程序员使用汇编语言来满足这些需求，汇编语言依赖于计算机的内部机器语言。
然而汇编语言是低级（low-level）语言，即直接操作硬件，如直接访CPU寄存器和内存单元。
因此汇编语言针对于特定的计算机处理器，要将汇编程序移植到另一种计算机上，必须使用不同的汇编语言重新编写程序。
这有点像每次购买新车时，都发现设计大量改变了控制系统的位置和功能，客户不得不重新学习驾驶。
然而，UNIX是为在不同的计算机（或平台）上工作而设计的，这意味着它需要一种高级语言。
高级（high-level）语言致力于解决问题，而不针对特定的硬件。一种被称为编译器的特殊程序将高级语言翻译成特定计算机的内部语言。
这样，就可以通过对每个平台使用不同的编译器来在不同的平台上使用同一个高级语言程序了。
Ritchie希望有一种语言能将低级语言的效率、硬件访问能力和高级语言的通用性、可移植性融合在一起，于是他在旧语言的基础上开发了C语言。
1.2.2 C语言编程原理
由于C++在C语言的基础上移植了新的编程理念，因此我们首先来看一看C所遵循的旧的理念。
一般来说，计算机语言要处理两个概念：数据和算法。数据是程序使用和处理的信息，而算法是程序使用的方法（参见图1.1）。
C语言与当前最主流的语言一样，在最初面世时也是过程性（procedural）语言，这意味着它强调的是编程的算法方面。
从概念上说，过程化编程首先要确定计算机应采取的操作，然后使用编程语言来实现这些操作。
程序命令计算机按一系列流程生成特定的结果，就像菜谱指定了厨师做蛋糕时应遵循的一系列步骤一样。
随着程序规模的扩大，早期的程序语言（如FORTRAN和BASIC）都会遇到组织方面的问题。
例如，程序经常使用分支语句，根据某种测试的结果，执行一组或另一组指令。很多旧式程序的执行路径很混乱（被称为“意大利面条式编程”），
几乎不可能通过阅读程序来理解它，修改这种程序简直是一场灾难。为了解决这种问题，计算机科学家开发了一种更有序的编程方法：结构化编程（structured programming）。
C语言具有使用这种方法的特性。例如，结构化编程将分支（决定接下来应执行哪个指令）限制为一小组行为良好的结构。
C语言的词汇表中就包含了这些结构（for循环、while循环、do while循环和if else语句）。
另一个新原则是自顶向下（top-down）的设计。在C语言中，其理念是将大型程序分解成小型、便于管理的任务。
如果其中的一项任务仍然过大，则将它分解为更小的任务。这一过程将一直持续下去，直到将程序划分为小型的、易于编写的模块
（整理一下书房。先整理桌子、桌面、档案柜，然后整理书架。好，先从桌子开始，然后整理每个抽屉，从中间的那个抽屉开始整理。也许我都可以管理这项任务）。
C语言的设计有助于使用这种方法，它鼓励程序员开发程序单元（函数）来表示各个任务模块。
如上所述，结构化编程技术反映了过程性编程的思想，根据执行的操作来构思一个程序。
1.2.3面向对象编程
虽然结构化编程的理念提高了程序的清晰度、可靠性，并使之便于维护，但它在编写大型程序时，仍面临着挑战。
为应付这种挑战，OOP提供了一种新方法。与强调算法的过程性编程不同的是，OOP强调的是数据。
OOP不像过程性编程那样，试图使问题满足语言的过程性方法，而是试图让语言来满足问题的要求。其理念是设计与问题的本质特性相对应的数据格式。
在C++中，类是一种规范，它描述了这种新型数据格式，对象是根据这种规范构造的特定数据结构。
例如，类可以描述公司管理人员的基本特征（姓名、头衔、工资、特长等），而对象则代表特定的管理人员。
通常，类规定了可使用哪些数据来表示对象以及可以对这些数据执行哪些操作。
例如，假设正在开发一个能够绘制矩形的计算机绘图程序，则可以定义一个描述矩形的类。定义的数据部分应包括顶点的位置、长和宽、4条边的颜色和样式、
矩形内部的填充颜色和图案等；定义的操作部分可以包括移动、改变大小、旋转、改变颜色和图案、将矩形复制到另一个位置上等操作。
这样，当使用该程序来绘制矩形时，它将根据类定义创建一个对象。该对象保存了描述矩形的所有数据值，因此可以使用类方法来修改该矩形。
如果绘制两个矩形，程序将创建两个对象，每个矩形对应一个。
OOP程序设计方法首先设计类，它们准确地表示了程序要处理的东西。例如，绘图程序可能定义表示矩形、直线、圆、画刷、画笔的类。
类定义描述了对每个类可执行的操作，如移动圆或旋转直线。然后您便可以设计一个使用这些类的对象的程序。
从低级组织（如类）到高级组织（如程序）的处理过程叫做自下向上（bottom-up）的编程。
OOP编程并不仅仅是将数据和方法合并为类定义。例如，OOP还有助于创建可重用的代码，这将减少大量的工作。
信息隐藏可以保护数据，使其免遭不适当的访问。多态让您能够为运算符和函数创建多个定义，通过编程上下文来确定使用哪个定义。
继承让您能够使用旧类派生出新类。正如接下来将看到的那样，OOP引入了很多新的理念，使用的编程方法不同于过程性编程。
它不是将重点放在任务上，而是放在表示概念上。有时不一定使用自上向下的编程方法，而是使用自下向上的编程方法。
本书将通过大量易于掌握的示例帮助读者理解这些要点。
设计有用、可靠的类是一项艰巨的任务，幸运的是，OOP语言使程序员在编程中能够轻松地使用已有的类。
厂商提供了大量有用的类库，包括设计用于简化Windows或Macintosh环境下编程的类库。
C++真正的优点之一是：可以方便地重用和修改现有的、经过仔细测试的代码。
1.2.4 C++和泛型编程
泛型编程（generic programming）是C+支持的另一种编程模式。它与OOP的目标相同，都使得重用代码和抽象通用概念的技术更简单。
不过OOP强调的是编程的数据方面，而泛型编程强调的是独立于特定数据类型。它们的侧重点不同。
OOP是一个管理大型项目的工具，而泛型编程提供了执行常见任务（如对数据排序或合并链表）的工具。
术语泛型（generic）指的是创建独立于类型的代码。C++的数据表示有多种类型――整数、小数、字符、字符串、用户定义的、由多种类型组成的复合结构。
例如，要对不同类型的数据进行排序，通常必须为每种类型创建一个排序函数。
泛型编程需要对语言进行扩展，以便可以只编写一个泛型（即不是特定类型的）函数，并将其用于各种实际类型。C++模板提供了完成这种任务的机制。
1.2.5 C++的起源
与C语言一样，C++也是在贝尔实验室诞生的，Bjarne Stroustrup于20世纪80年代在这里开发出了这种语言。
用他自己的话来说，“C++主要是为了我的朋友和我不必再使用汇编语言、C语言或其他现代高级语言来编程而设计的。
它的主要功能是可以更方便地编写出好程序，让每个程序员更加快乐”。
Bjarne Stroustrup设计并实现了C+编程语言，他是权威参考手册《The C++ Programming Language》和《The design and Evolution of C++》的作者。
Bjarne Stroustrup之所以在C的基础上创建C++，是因为C语言简洁、适合系统编程、使用广泛且与UNIX操作系统联系紧密。
Stroustrup加入了OOP特性和泛型编程支持，但并没有对C的组件作很大的改动。
因此，C++是C语言的超集，这意味着任何有效的C程序都是有效的C++程序。它们之间有些细微的差异，但无足轻重。
C++程序可以使用已有的C软件库。库是编程模块的集合，可以从程序中调用它们。
库对很多常见的编程问题提供了可靠的解决方法，因此能节省程序员大量的时间和工作量。这也有助于C++的广泛传播。
名称C++来自C语言中的递增运算符++，该运算符将变量加1。名称C++表明，它是C的扩充版本。
计算机程序将实际问题转换为计算机能够执行的一系列操作。OOP部分赋予了C++语言将问题所涉及的概念联系起来的能力，
C部分则赋予了C++语言紧密联系硬件的能力（参见图l.2），这种能力上的结合成就了C++的广泛传播。
另外，C++是在C语言的基础土添加OOP特性，您可以忽略C++的面向对象特性，但将错过很多有用的东西。
在C++获得一定程度的成功后，Stroustrup才添加了模板，这使得进行泛型编程成为可能。
在模板特性被使用和改进后，人们才逐渐认识到，它们和OOP同样重要――甚至比OOP还重要，但有些人不这么认为。
C++融合了OOP、泛型编程和传统的结构化编程，这表明C++强调的是实用价值，而不是意识形态方法，这也是该语言获得成功的原因之一。
1.3 可移植性和标准
假设您为运行Windows2000的老式奔腾PC编写了一个很好用的C++程序，而管理人员决定使用不同操作系统和处理器的计算机替换它。
该程序是否可以在新平台上运行呢？当然，必须使用为新平台设计的C++编译器对程序重新编译。但是否需要修改编写好的代码呢？
如果在不修改代码的情况下，重新编译程序后，程序将运行良好，则该程序是可移植的。
在可移植性方面存在两个障碍，其中的一个是硬件。硬件特定的程序是不可移植的。
将依赖于硬件的部分放在函数模块中可以最大限度地降低可移植性问题，这样只需重新编写这些模块即可。本书将避免这种编程。
可移植性的第二个障碍是语言上的差异。Windows XP的C++实现与Red Hat Linux或Macintosh OSX的C++实现相同吗？
虽然多数C++实现都希望其C++版本与其他版本兼容，但如果没有准确描述语言工作方式的公开标准，这将很难做到。
因此，美国国家标准局（American National Standards Institute，ANSI）在1990年设立了一个委员会，专门负责制定C++标准（ANSI制定了C语言标准）。
国际标准化组织（ISO）很快通过自己的委员会（ISO-WG-21）加入了这个行列，创建了联合组织ANSI/ISO，致力于制定C++标准。
经过多年的努力，制定出了一个国际标准ISO/IEC14882：1998，并于1998年获得了ISO、IEC
（International Electrotechnical Committee，国际电工技术委员会）和ANSI的批准。
该标准常被称为C++98，它不仅描述了已有的C++特性，还对该语言进行了扩展，添加了异常、运行阶段类型识别（RTTl）、模板和标准模板库（STL）。
2003年，发布了C++标准第二版（IOS/IEC14882：2003）；这个新版本是一次技术性修订，这意味着它对第一版进行了整理，修订错误、减少多义性等，但没有改变语言特性。
这个版本常被称为C++03。由于C++03没有改变语言特性，因此我们使用C++98表示C++98/C++2003。
C++在不断发展。ISO标准委员会于2011年8月批准了新标准ISO/IEC14882：2011，该标准被称为C++11。
与C++98一样，C++11也新增了众多特性，其目标是消除不一致性；让C++学习和使用起来更容易。
ISO C++标准还吸收了ANSI C语言标准，因为C++应尽量是C语言的超集。这意味着在理想情况下，任何有效的C程序都应是有效的C++程序。
ANSI C与对应的C++规则之间存在一些差别，但这种差别很小。实际上，ANSI C加入了C++首次引入的一些特性，如函数原型和类型限定符const。
在ANSI C出现之前，C语言社区遵循一种事实标准，该标准基于Kernighan和Ritchie编写的《The C Programming Language》一书，通常被称为K&R C；
ANSI C出现后，更简单的K&R C有时被称为经典C。
ANSI C标准不仅定义了C语言，还定义了一个ANSI C实现必须支持的标准C库。C++也使用了这个库；本书将其称为标准C库。
另外，ANSI/ISO C++标准还提供了一个C++标准类库。
最新的C标准为C99，ISO和ANSl分别于1999年和2000年批准了该标准。该标准在C语言中添加了一些C++编译器支持的特性，如新的整型。
1.3.1 C++的发展
Stroustrup编写的《The C++ Programming Language》包含65页的参考手册，它成了最初的C++事实标准。
下一个事实标准是Stroustrup编写的《The Annotated C++Reference Manual》。
C++98标准新增了大量特性，其篇幅将近800页，且包含的说明很少。
C++11标准的篇幅长达1350页，对旧标准做了大量的补充。
1.3.2 本书遵循的C++标准
当代的编译器都对C++98提供了很好的支持。编写本书期间，有些编译器还支持一些C++11特性：随着新标准获批，对这些特性的支持将很快得到提高。
本书反映了当前的情形，详尽地介绍了C++98，并涵盖了C++11新增的一些特性。
在探讨相关的C++98主题时顺便介绍了一些C++新特性，而第18章专门介绍新特性，它总结了本书前面提到的一些特性，并介绍了其他特性。
在编写本书期间，对C++11的支持还不全面，因此难以全面介绍C++11新增的所有特性。
考虑到篇幅限制，即使这个新标准获得了全面支持，也无法在一本书中全面介绍它。本书重点介绍大多数编译器都支持的特性，并简要地总结其他特性。
详细介绍C++之前，先介绍一些有关程序创建的基本知识。
1.4 程序创建的技巧
假设您编写了一个C++程序。如何让它运行起来呢？具体的步骤取决于计算机环境和使用的C++编译器，但大体如下（参见图1.3）。
1.使用文本编辑器编写程序，并将其保存到文件中，这个文件就是程序的源代码。
2.编译源代码。这意味着运行一个程序，将源代码翻译为主机使用的内部语言――机器语言。包含了翻译后的程序的文件就是程序的目标代码（object code）。
3.将目标代码与其他代码链接起来。例如，C++程序通常使用库。C++库包含一系列计算机例程（被称为函数）的目标代码，
这些函数可以执行诸如在屏幕上显示信息或计算平方根等任务。
链接指的是将目标代码同使用的函数的目标代码以及一些标准的启动代码（startup code）组合起来，生成程序的可执行版本。包含该最终产品的文件被称为可执行代码。
本书将不断使用术语源代码；请记住该术语。
本书的程序都是通用的，可在任何支持C++98的系统中运行；但第18章的程序要求系统支持C++11。
编写本书期间，有些编译器要求您使用特定的标记，让其支持C++11特性。
例如，g++要求您编译源代码文件时使用标记-std=c++11
g++ -std=c++11 use_auto.cpp
创建程序的步骤可能各不相同，下面深入介绍这些步骤。
1.4.1创建源代码文件
本书余下的篇幅讨论源代码文件中的内容：本节讨论创建源代码文件的技巧。
有些C++实现（如Microsoft Visual C++、C++Builder、Apple Xcode、Open Watcom C++、
Digital Mars C++和Freescale Code Warrior）提供了集成开发环境（integrated development environments，IDE），
让您能够在主程序管理程序开发的所有步骤，包括编辑。
有些实现（如用于UNIX和Linux的GNU C/C++、用于AlX的IBM XL C/C++、Borland C/C++以及Digital Mars C/C++）
只能处理编译和链接阶段，要求在系统命令行输入命令。
在这种情况下，可以使用任何文本编辑器来创建和修改源代码。
例如，在UNIX系统上，可以使用nano、vim、emacs。
如果将文件保存为标准ASCII文本文件（而不是特殊的字处理器格式），甚至可以使用字处理器。
另外，还可能有IDE选项，让您能够使用这些命令行编译器。
给源文件命名时，必须使用正确的后缀，将文件标识为C++文件。这不仅告诉您该文件是C+源代码，还将这种信息告知编译器。
后缀由一个句点和一个或多个字符组成，这些字符被称作扩展名。（参见图1.4）。
使用什么扩展名取决于C++实现，表1.1列出了一些常用的扩展名。
表1.1 源代码文件的扩展名
C++实现         源代码文件的扩展名
GNU C++       cpp、cxx、cc
Visual C++     cpp、cxx、cc
1.4.2编译和链接
最初，Stroustrup实现C++时，使用了一个C++到C的编译器程序，而不是开发直接的C++到目标代码的编译器。
前者叫做cfront（表示C前端，Cfrontend），它将C++源代码翻译成C源代码，然后使用一个标准C编译器对其进行编译。
这种方法简化了向C的领域引入C++的过程。其他实现也采用这种方法将C++引入到其他平台。
随着C++的日渐普及，越来越多的实现转向创建C++编译器，直接将C++源代码生成目标代码。
这种直接方法加速了编译过程，并强调C++是一种独立（虽然有些相似）的语言。
编译的机理取决于实现，接下来的几节将介绍一些常见的形式。这些总结概括了基本步骤，但对于具体步骤，必须查看系统文档。
1.UNIX 编译和链接
最初，UNIX命令CC调用cfront，但cfront未能紧跟C++的发展步伐，其最后一个版本发布于1993年。
当今的UNIX上有商用的C++编译器或开源免费的C++编译器。
如果UNIX上有C++编译器，很多情况下命令CC仍然管用，只是启动的编译器随系统而异。
出于简化的目的，读者应假设命令CC可用，但必须认识到这一点，即对于下述讨论中的CC，可能必须使用其他命令来代替。
请用CC命令来编译程序，名称采用大写字母。
CC编译器是命令行编译器，这意味着需要在UNIX命令行上输入编译命令。
例如，要编译C++源代码文件spiffy.cpp，则应在UNIX提示符下输入如下命令：
CC spiffy.cpp
如果程序没有错误，编译器将生成一个扩展名为o的目标代码文件。
在这个例子中，编译器将生成目标代码文件spiffy.o。
接下来，编译器自动将目标代码文件传递给系统链接程序，该程序将代码与库代码结合起来，生成一个可执行文件。
在默认情况下，可执行文件为a.out。如果只使用一个源文件，链接程序还将删除spiffy.o文件，因为这个文件不再需要了。
要运行该程序，只要输入可执行文件的文件名即可：
a.out
注意，如果编译新程序，新的可执行文件a.out将覆盖已有的a.out
（这是因为可执行文件占据了大量空间，因此覆盖旧的可执行文件有助于降低存储需求）。
然而，如果想保留可执行文件，只需使用UNIX的mv命令来修改可执行文件的文件名即可。
与在C语言中一样，在C++中，程序也可以包含多个文件（本书第8~第16章的很多程序都是这样）。
在这种情况下，可以通过在命令行上列出全部文件来编译程序：
cc my.cpp precious.cpp
如果只修改了my.cpp文件，则可以用下面的命令重新编译该程序：
cc my.cpp precious.o
这将重新编译my.cpp文件，并将它与前面编译的precious.o文件链接起来。
可能需要显式地指定一些库。例如，要访问数学库中定义的函数，必须在命令行中加上-lm标记：
cc -lm usingmath.cpp
2.Linux编译和链接
Linux系统中最常用的编译器是g++，这是来自Free Software Foundation的GNU C++编译器。
Linux的多数版本都包括该编译器，但并不一定总会安装它。g++编译器的工作方式很像标准UNIX编译器。
例如，下面的命令将生成可执行文件a.out
g++ spiffy.cpp
要编译多个源文件，只需将它们全部放到命令行中即可：
g++ my.cpp precious.cpp
这将生成一个名为a.out的可执行文件和两个目标代码文件my.o和precious.o。
如果接下来修改了其中的某个源代码文件，如my.cpp，则可以使用my.cpp和precious.o来重新编译：
g++ my.cpp precious.o
GNU编译器可以在很多平台上使用，包括基于Windows的PC和在各种平台上运行的UNIX系统。
3.Windows命令行编译器
要在Windows上编译C++程序，最便宜的方法是下载一个在Windows命令提示符模式
（在这种模式下，将打开一个类似于MS-DOS的窗口）下运行的免费命令行编译器。
Cygwin和MinGW都包含编译器GNU C++，且可免费下载；它们使用的编译器名为g++。
要使用g++编译器，首先需要打开一个命令提示符窗口。启动程序Cygwin和MinGW时，它们将自为您打开一个命令提示符窗口。
要编译名为great.cpp的源代码文件，请在提示符下输入如下命令：
g++ great.cpp
如果程序编译成功，则得到的可执行文件名为a.exe。
4.Windows编译器
Windows产品很多且修订频繁，无法对它们分别进行介绍。
当前，最流行是Microsoft Visual C++2010，可通过免费的Microsoft Visual C++ 2010学习版获得。
虽然设计和目标不同，但大多数基于Windows的C++编译器都有一些相同的功能。
通常，必须为程序创建一个项目，并将组成程序的一个或多个文件添加到该项目中。
每个厂商提供的IDE（集成开发环境）都包含用于创建项目的菜单选项（可能还有自动帮助）。
必须确定的非常重要的一点是，需要创建的是什么类型的程序。
通常，编译器提供了很多选择，如Windows应用程序、MFC Windows应用程序、动态链接库、ActiveX控件、
DOS或字符模式的可执行文件、静态库或控制台应用程序等。其中一些可能既有32位版本，又有64位版本。
由于本书的程序都是通用的，因此应当避免要求平台特定代码的选项，如Windows应用程序。
相反，应让程序以字符模式运行。具体选项取决于编译器。一般而言，应选择包含字样“控制台”、“字符模式”
或“DOS可执行文件”等选项。例如，在Microsoft Visual C++2010中，应选择Win32 Console Application
（控制台应用程序）选项，单击Application Settings（应用程序设置），并选择Empty Project（空项目）。
创建好控制台项目后，需要对程序进行编译和链接。IDE通常提供了多个菜单项，如Compile（编译）、Build
（建立）、Make（生成）、Build All（全部建立）、Link（链接）、Execute（执行）、Run（运行）和Debug（调试），
不过同一个IDE中，不一定包含所有这些选项。
Compile通常意味着对当前打开的文件中的代码进行编译。
Build和Make通常意味着编译项目中所有源代码文件的代码。这通常是一个递增过程，也就是说，
如果项目包含3个文件，而只有其中一个文件被修改，则只重新编译该文件。
BuildAll 通常意味着重新编译所有的源代码文件。
Link意味着（如前所述）将编译后的源代码与所需的库代码组合起来。
Run或Execute意味着运行程序。通常，如果您还没有执行前面的步骤，Run将在运行程序之前完成这些步骤。
Debug意味着以调试方式执行程序。
编译器可能让您选择要生成调试版还是发布版。调试版包含额外的调试符号，这会增大程序、降低执行速度，但可提供详细的调试信息。
如果程序违反了语言规则，编译器将生成错误消息，指出在在问题的行。
遗憾的是，如果不熟悉语言，将难以理解这些消息的含义。
有时，真正的问题可能在标识行之前；有时，一个错误可能引发一连串的错误消息。
提示：改正错误时，应首先改正第一个错误。如果在标识为有错误的那一行上找不到错误，请查看前一行。
需要注意的是，程序能够通过某个编译器的编译并不意味着它是合法的C+程序；
同样，程序不能通过某个编译器的编译也并不意味着它是非法的C++程序。
与几年前相比，现在的编译器更严格地遵循了C++标准。另外，编译器通常提供了可用于控制严格程度的选项。
提示：有时，编译器在不完全地构建程序后将出现混乱，它显示无法改正的、无意义的错误消息。
在这种情况下，可以选择BuildAll，重新编译整个程序，以清除这些错误消息。
遗憾的是，这种情况和那些更常见的情况（即错误消息只是看上去无意义，实际上有意义）很难区分。
通常，IDE允许在辅助窗口中运行程序。程序执行完毕后，有些IDE将关闭该窗口，而有些IDE不关闭。
如果编译器关闭窗，将难以看到程序输出，除非您眼疾手快、过目不忘。
为查看输出，必须在程序的最后加上一些代码：
cin.get();   //读取输入后遗留在缓冲区中的换行符
cin.get();   //获取一次键击

return 0;
cin.get语句读取下一次键击，因此上述语句让程序等待，直到按下了Enter键
（在按下Enter键之前，键击将不被发送给程序，因此按其他键都不管用）。
如果程序在其常规输入后留下一个没有被处理的键击，则第二条语句是必需的。
例如，如果要输入一个数字，则需要输入该数字，然后按Enter键。
程序将读取该数字，但Enter键不被处理，这样它将被第一个cin.get读取。
5.Macintosh上的C++
当前，Apple随操作系统Mac OS X提供子开发框架Xcode，该框架是免费的，但通常不会自动安装。
要安装它，可使用操作系统安装盘，也可从Apple网站免费下载（但需要注意的是，它超过4GB）。
Xcode远不仅提供了支持多种语言的IDE，还自带了两个命令行编译器（g++和clang），可在UNIX模式下运行它们。
而要进入UNIX模式，可通过实用程序Terminate。
提示：为节省时间，可对所有示例程序使用同一个项目。
方法是从项目列表中删除前一个示例程序的源代码文件；并添加当前的源代码。这样可节省时间、工作量和磁盘空间。
1.5 总结
随着计算机的功能越来越强大，计算机程序越来越庞大而复杂。
为应对这种挑战，计算机语言也得到了改进，以便编程过程更为简单。
C语言新增了诸如控制结构和函数等特性，以便更好地控制程序流程，支持结构化和模块化程度更高的方法；
而C++增加了对面向对象编程和泛型编程的支持，这有助于提高模块化和创建可重用代码，从而节省编程时间并提高程序的可靠性。
C++的流行导致大量用于各种计算平台的C++实现得以面世；而ISO C++标准为确保众多实现的相互兼容提供了基础。
这些标准规定了语言必须具备的特性、语言呈现出的行为、标准库函数、类和模板，
旨在实现该语言在不同计算平台和实现之间的可移植性。
要创建C++程序，可创建一个或多个源代码文件，其中包含了以C++语言编写的程序。
这些文件是文本文件，它们经过编译和链接后将得到机器语言文件，后者构成了可执行的程序。
上述任务通常是在IDE中完成的，IDE提供了用于创建源代码文件的文本编辑器、用于生成可执行文件的编译器和链接器以及其他资源，
如项目管理和调试功能。然而，这些任务也可以在命令行环境中通过调用合适的工具来完成。

第2章 开始学习C++
2.1 进入C+ +
2.1.1 main函数
2.1.2 C++注释
2.1.3 C++预处理器和iostream文件
2.1.4 头文件名
2.1.5 名称空间
2.1.6 使用cout进行C++输出
2.1.7 C++源代码的格 式化
2.2 C++语句
2.2.1 声明语句和变量
2.2.2 赋值语句
2.2.3 cout的新花样
2.3 其他C++语句
2.3.1 使用cin
2.3.2 使用cout进行拼接
2.3.3 类简介
2.4 函数
2.4.1 使用有返回值的函数
2.4.2 函数变体
2.4.3 用户定义的函数
2.4.4 用户定义的有返回值的函数
2.4.5 在多函数程序中使用using编译指令
2.5 总结
2.6 复习题
2.7 编程练习
本章内容包括：
创建C++程序。
C++程序的一般格式。
#include编译指令。
main函数。
使用cout对象进行输出。
在C++程序中加入注释。
何时以及如何使用endl。
声明和使用变量。
使用cin对象进行输入。
定义和使用简单函教。
要建造简单的房屋，首先要打地基、搭框架。如果一开始没有牢固的结构，后面就很难建造窗子、门框、圆屋顶和镶木地板的舞厅等。
同样，学习计算机语言时，应从程序的基本结构开始学起，只有这样，才能一步步了解其具体细节，如循环和对象等。
本章对C+程序的基本结构做一概述，并预览后面将介绍的主题，如函数和类。
（这里的理念是，先介绍一些基本概念，这样可以激发读者接下去学习的兴趣。）
2.1进入C++
首先介绍一个显示消息的简单C++程序。程序清单2.1使用C++工具cout生成字符输出。
源代码中包含一些供读者阅读的注释，这些注释都以//打头，编译器将忽略它们。
C++对大小写敏感，也就是说区分大写字符和小写字符。这意味着大小写必须与示例中相同。
例如，该程序使用的是cout，如果将其替换为Cout，程序将无法通过编译。
程序清单2.1 myfirst.cpp
#include <iostream>

using namespace std;

int main()
{
    cout << "Come up and C++ me some time.";
    cout << endl;
    cout << "You won't regret it!" << endl;

    return 0;
}
显示结果如下
Come up and C++ me some time.
You won't regret it!

2.2 C++语句
C++程序是一组函数，而每个函数又是一组语句。C++有好几种语句，下面介绍其中的一些。
程序清单2.2提供了两种新的语句。声明语句创建变量，赋值语句给该变量提供一个值。另外，该程序还演示了cout的新功能。
程序清单2.2 carrots.cpp
#include <iostream>

using namespace std;

int main()
{
    int carrots;

    carrots = 25;
    cout << "I have " << carrots << " carrots.";
    cout << endl;
    carrots = carrots - 1;
    cout << "Crunh, Crunch. Now I have " << carrots << " carrots." << endl;

    return 0;
}
显示结果如下
I have 25 carrots.
Crunh, Crunch. Now I have 24 carrots.

2.3其他C++语句
再来看几个C++语句的例子。程序清单2.3中的程序对前一个程序进行了扩展，要求在程序运行时输入一个值。
为实现这项任务，它使用了cin，这是与cout对应的用于输入的对象。另外，该程序还演示了cout对象的多功能性。
程序清单2.3 getinfo.cpp
#include <iostream>

using namespace std;

int main()
{
    int carrots = 0;

    cout << "How many carrots do you have?" << endl;
    cin >> carrots;
    cout << "Here are two more. ";
    carrots = carrots + 2;
    cout << "Now you have " << carrots << " carrots." << endl;

    return 0;
}
显示结果如下
How many carrots do you have?
66
Here are two more. Now you have 68 carrots.

2.4 函数
由于函数用于创建C++程序的模块，对C++的OOP定义至关重要，因此必须熟悉它。函数的某些方面属于高级主题，将在第7章和第8章重点讨论函数。
然而，现在了解函数的一些基本特征，将使得在以后的函数学习中更加得心应手。本章剩余的内容将介绍函数的一些基本知识。
C++函数分两种：有返回值的和没有返回值的。在标准C++函数库中可以找到这两类函数的例子，您也可以自己创建这两种类型的函数。
下面首先来看一个有返回值的库函数，然后介绍如何编写简单的函数。
2.4.1使用有返回值的函数
有返回值的函数将生成一个值，而这个值可赋给变量或在其他表达式中使用。例如，标准C/C++库包含一个名为sqrt的函数，它返回平方根。
程序清单2.4演示了库函数sqrt的用法，它通过包含cmath文件来提供该函数的原型：
程序清单2.4 sqrt.cpp
#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    double area;
    cout << "Enter the floor area, in square feet, of your hone: ";
    cin >> area;
    double side;
    side = sqrt(area);
    cout << "That's the equivalent of a square " << side
         << " feet to the side." << endl;
    cout << "How fascinating!" << endl;

    return 0;
}
显示结果如下
Enter the floor area, in square feet, of your hone: 9.9
That's the equivalent of a square 3.14643 feet to the side.
How fascinating!

标准C库提供了140多个预定义的函数。如果其中的函数能满足要求，则应使用它们。
但用户经常需要编写自己的函数，尤其是在设计类的时候。无论如何，设计自己的函数很有意思，下面来介绍这一过程。
前面已经使用过好几个用户定义的函数，它们都叫main。每个C++程序都必须有一个main函数，用户必须对它进行定义。
假设需要添加另一个用户定义的函数。和库函数一样，也可以通过函数名来调用用户定义的函数。
对于库函数，在使用之前必须提供其原型，通常把原型放到main定义之前。但现在您必须提供新函数的源代码。
最简单的方法是，将代码放在main的后面。程序清单2.5演示了这些元素。
程序清单2.5 ourfunc.cpp
#include <iostream>
#include <cmath>

using namespace std;

void simon(int);

int main()
{
    simon(3);
    cout << "Pick an integer: ";
    int count;
    cin >> count;
    simon(count);
    cout << "Done!" << endl;

    return 0;
}

void simon(int n)
{
    cout << "Simon says touch your toes " << n << " times." << endl;
}
显示结果如下
Simon says touch your toes 3 times.
Pick an integer: 6
Simon says touch your toes 6 times.
Done!

我们再深入一步，编写一个使用返回语句的函数。main函数已经揭示了有返回值的函数的格式：在函数头中指出返回类型，在函数体结尾处使用return。
可以用这种形式为在英国观光的人解决重量的问题。
在英国，很多浴室都以stone为单位，不像美国以磅或公斤为单位。一stone等于14磅，程序清单2.6使用一个函数来完成这样的转换。
程序清单2.6 convert.cpp
#include <iostream>
#include <cmath>

using namespace std;

int stonetopound(int);

int main()
{
    int stone;
    cout << "Enter the weight in stone: ";
    cin >> stone;
    int pounds = stonetopound(stone);
    cout << stone << " stone = ";
    cout << pounds << " pounds." << endl;

    return 0;
}

int stonetopound(int stone)
{
    return 14 * stone;
}
显示结果如下
Enter the weight in stone: 8
8 stone = 112 pounds.

2.5总结
C++程序由一个或多个被称为函数的模块组成。程序从main函数（全部小写）开始执行，因此该函数必不可少。
函数由函数头和函数体组成。函数头指出函数的返回值（如果有的话）的类型和函数期望通过参数传递给它的信息的类型。
函数体由一系列位于花括号 { } 中的C++语句组成。
有多种类型的C++语句，包括下述6种。
声明语句：定义函数中使用的变量的名称和类型。
赋值语句：使用赋值运算符（=）给变量赋值。
消息语句：将消息发送给对象，激发某种行动。
函数调用：执行函数。被调用的函数执行完毕后，程序返回到函数调用语句后面的语句。
函数原型：声明函数的返回类型、函数接受的参数数量和类型。
返回语句：将一个值从被调用的函数那里返回到调用函数中。
类是用户定义的数据类型规范，它详细描述了如何表示信息以及可对数据执行的操作。
对象是根据类规范创建的实体，就像简单变量是根据数据类型描述创建的实体一样。
C++提供了两个用于处理输入和输出的预定义对象（cin和cout），它们是istream和ostream类的实例，这两个类是在iostream文件中定义的。
为ostream类定义的插入运算符（<<）使得将数据插入到输出流成为可能；
为istream类定义的抽取运算符（>>）能够从输入流中抽取信息。
cin和cout都是智能对象，能够根据程序上下文自动将信息从一种形式转换为另一种形式。
C++可以使用大量的C库函数。要使用库函数，应当包含提供该函数原型的头文件。
至此，读者对简单的C++程序有了大致的了解，可以进入下一章，了解程序的细节。

2.6 复习题
1.C++程序的模块叫什么？
函数

2.下面的预处理器编译指令是做什么用的？
#include <iostream>
使用iostream文件的内容替换该编译指令

3.下面的语句是做作么用的？
using namespace std；
使得程序可以使用std名称空间中的定义

4.什么语句可以用来打印短语“Hello, world”，然后开始新的一行？
cout << "Hello, world\n";
cout << "Hello, world" << endl；

5.什么语句可以用来创建名为cheeses的整数变量？
int cheeses;

6.什么语句可以用来将值32赋给变量cheeses？
cheeses = 32;

7.什么语句可以用来将从键盘输入的值读入变量cheeses中？
cin>>cheeses;

8.什么语句可以用来打印"We have X varieties of cheese"，其中X为变量cheeses的当前值。
cout<<"We have "<< cheeses <<"varieties of cheese";

9.下面的函数原型指出了关于函数的哪些信息？
int froop (double t);
void rattle (int n);
int prune (void);
函数froop接受一个double参数，返回一个int值。
函数rattle接受一个int参数，没有返回值。
函数prune不接受任何参数，返回一个int值。

10.定义函数时，在什么情况下不必使用关键字retun？
当函数的返回类型为void时，如果不需要只执行一部分就从函数返回，则不用在函数中使用return

11.假设您编写的main函数包含如下代码：
cout << "Please enter you PIN: ";
而编译器指出cout是一个未知标识符。导致这种问题的原因很可能是什么？指出修复这种问题的方法

#include <iostream>

using namespace std;

2.7 编程练习
1.编写一个C++程序它显示您的姓名和地址。
#include <iostream>

int main()
{
    std::cout << "YAYUN WEI" << std::endl;
    std::cout << "FuZhou, JiangXi, China" << std::endl;

    return 0;
}
显示结果如下
YAYUN WEI
FuZhou, JiangXi, China

2.编写一个C+程序；它要求用户输入一个以long为单位的距离，然后将它转换为码（一long等于220码）。

#include <iostream>

int main()
{
    std::cout << "Enter the number of frolongs " << std::endl;

    int frolong = 0;
    std::cin >> frolong;

    int yard = frolong * 220;
    std::cout << frolong << " Frolong = " << yard << " yard" << std::endl;

    return 0;
}
显示结果如下
Enter the number of frolongs
6
6 Frolong = 1320 yard

3.编写一个C++程序，它使用3个用户定义的函数（包括main），并生成下面的输出
Three blind mice
Three blind mice
See how they run
See how they run
其中一个函数要调用两次，该函数生成前两行；一另个函数也被调用两次，并生成其余的输出

#include <iostream>

void function1();
void function2();

int main()
{

    function1();
    function1();
    function2();
    function2();

    return 0;
}

void function1()
{
    std::cout << "Three blind mice" << std::endl;
}

void function2()
{
    std::cout << "See how they run" << std::endl;
}
显示结果如下
Three blind mice
Three blind mice
See how they run
See how they run

4.编写一个程序；让用户输入其年龄；然后显示该年龄包含多少个月。

#include <iostream>

int age_months(int age);

int main()
{
    std::cout << "Enter your age: ";

    int age = 0;
    std::cin >> age;

    std::cout << "Your age in months is " << age_months(age) << std::endl;

    return 0;
}

int age_months(int age)
{
    return age * 12;
}
显示结果如下
Enter your age: 9
Your age in months is 108

5.编写一个程序，其中，main调用一个用户定义的函数（以摄氏温度值为参数，并返回相应的华氏温度值）。

#include <iostream>

double celsius_to_fahrenheit(double celsius);

int main()
{
    std::cout << "Please enter a celsius value: ";

    double celsius = 0;
    std::cin >> celsius;

    std::cout << celsius << " degrees Celsius is " << celsius_to_fahrenheit(celsius) << " degrees fahrenheit\n";

    return 0;
}

double celsius_to_fahrenheit(double celsius)
{
    return (1.8 * celsius + 32.0);
}
显示结果如下
Please enter a celsius value: 33
33 degrees Celsius is 91.4 degrees fahrenheit

6.编写一个程序，其中，main调用一个用户定义的函数（以光年值为参数，并返回对应天文单位的值）。
天文单位是从地球到太阳的平均距离（约150000000公里或93000000英里），
光年是光一年走的距离（约10万亿公里或6万亿英里）（除太阳外，最近的恒星大约离地球4.2光年）。
请使用double类型（参见程序清单2.4），转换公式为：1光年=63240天文单位

#include <iostream>

double light_years(double light_years);

int main()
{
    std::cout << "Enter the number of light years: ";

    double lightyears = 0;
    std::cin >> lightyears;

    std::cout << lightyears << " light year = " << light_years(lightyears) << " astronomical units\n";

    return 0;
}

double light_years(double light_years)
{
    return light_years * 63240;
}
显示结果如下
Enter the number of light years: 3
3 light year = 189720 astronomical units

7.编写一个程序，要求用户输入小时数和分钟数。在main函数中，将这两个值传递给一个用户定义的函数（返回值类型为void）。

#include <iostream>

void display_time(int hour, int minutes);

int main()
{

    std::cout << "Enter the number of hours: ";
    int hour = 0;
    std::cin >> hour;

    std::cout << "Enter the number of minutes: ";
    int minutes = 0;
    std::cin >> minutes;

    display_time (hour, minutes);

    return 0;
}

void display_time(int hour, int minutes)
{
    std::cout << "Time: " << hour << ":" << minutes << std::endl;
}
显示结果如下
Enter the number of hours: 9
Enter the number of minutes: 28
Time: 9:28

第3章 处理数据
3.1 简单变量
3.1.1变量名
3.1.2 整型
3.1.3 整型short、int、long和long long
3.14 无符号类型
3.1.5 选择整型类型
3.1.6 整型字面值
3.1.7 C++如何确定常量的类型
3.1.8 char类型：字符和小整数
3.1.9 bool类型
3.2 const 限定符
3.3 浮点数
3.3.1 书写浮点数
3.3.2 浮点类型
3.3.3 浮点常量
3.3.4 浮点数的优缺点
3.4 C++算术运算符
3.4.1 运算符优先级和结合性
3.4.2 除法分支
3.4.3 求模运算符
3.4.4 类型转换.
3.4.5 C++11中的auto声明
3.5 总结
3.6 复习题
3.7 编程练习
本章内容包括
C++变量的命名规则
C++内置的整型
unsigned long, long, unsigned int, int, unsigned short, short, char, unsigned char, signed char和bool
C++11新增的整型：unsigned long long和long long
表示各种整型的系统限制的climits文件
各种整型的数字字面值（常量）。
使用const限定符来创建符号常量。
C++内置的浮点类型：float，double和long double
表示各种浮点类型的系统限制的cfloat文件。
各种浮点类型的数字字面值。
C++的算术运算符。
自动类型转换。
强制类型转换。
面向对象编程（OOP）的本质是设计并扩展自己的数据类型。设计自己的数据类型就是让类型与数据匹配。
如果正确做到了这一点，将会发现以后使用数据时会容易得多。
然而，在创建自己的类型之前，必须了解并理解C++内置的类型，因为这些类型是创建自己类型的基本组件。
内置的C++类型分两组：基本类型和复合类型。本章将介绍基本类型，即整数和浮点数。
似乎只有两种类型，但C++知道，没有任何一种整型和浮点型能够满足所有的编程要求，
因此对于这两种数据，它提供了多种变体。
第4章将介绍在基本类型的基础上创建的复合类型，包括数组、字符串、指针和结构。
当然，程序还需要一种标识存储的数据的方法，本章将介绍这样一种方法――使用变量；
然后介绍如何在C++中进行算术运算；最后，介绍C++如何将值从一种类型转换为另一种类型。
3.1 简单变量
程序通常都需要存储信息，为把信息存储在计算机中，程序必须记录3个基本属性：
信息将存储在哪里、要存储什么值、存储何种类型的信息。
到目前为止，本书的示例采取的策略都是声明一个变量。
声明中使用的类型描述了信息的类型和通过符号来表示其值的变量名。
int braincount;
brainicount = 5;
这些语句告诉程序，它正在存储整数，并使用名称braincount来表示该整数的值（这里为5）。
实际上，程序将找到一块能够存储整数的内存，将该内存单元标记为braincount，并将5复制到该内存单元中。
然后，您可在程序中使用braincount来访问该内存单元。这些语句没有告诉您，这个值将存储在内存的什么位置，
但程序确实记录了这种信息。实际上，可以使用&运算符来检索braincount的内存地址。
下一章介绍另一种标识数据的方法（使用指针）时，将介绍这个运算符。
3.1.1变量名
C++提倡使用有一定含义的变量名。C++变量名必须遵循几种简单的命名规则。
在名称中只能使用字母字符、数字和下划线（）.
名称的第一个字符不能是数字
区分大写字符与小写字符
不能将C+关键字用作名称。
以两个下划线或一个下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用
以一个下划线开头的名称被保留给实现，用作全局标识符。
C++对于名称的长度没有限制，名称中所有的字符都有意义，但有些平台有长度限制。
最后一点使得C++与ANSI C（C99标准）有所区别，后者只保证名称中的前63个字符有意义
（在ANSI C中，前63个字符相同的名称被认为是相同的，即使第64个字符不同）
如果想用两个或更多的单词组成一个名称，通常的做法是用下划线字符将单词分开，
或者从第二个单词开始将每个单词的第一个字母大写。
C程序员倾向于按C语言的方式使用下划线，而Pascal程序员喜欢采用大写方式。
3.1.2整型
C++提供好几种整型，这样便能够根据程序的具体要求选择最合适的整型。
不同C++整型使用不同的内存量来存储整数。使用的内存量越大，可以表示的整数值范围也越大。
另外，有的类型（符号类型）可表示正值和负值，而有的类型（无符号类型）不能表示负值。
术语宽度（width）用于描述存储整数时使用的内存量。使用的内存越多，则越宽。
C++的基本整型（按宽度递增的顺序排列）分别是char，short，int，long和C++11新增的long long，
其中每种类型都有符号版本和无符号版本，因此总共有10种类型可供选择。
下面更详细地介绍这些整数类型。由于char类型有一些特殊属性（它最常用来表示字符，而不是数字），
因此本章将首先介绍其他类型。
3.1.3 整型short，int，long和long long
计算机内存由一些叫做位（bit）的单元组成，C++的short，int，long和long long类型通过使用不同数目的位来存储值，
最多能够表示4种不同的整数宽度。如果在所有的系统中，每种类型的宽度都相同，则使用起来将非常方便。
例如，如果short总是16位，int总是32位，等等。不过生活并非那么简单，没有一种选择能够满足所有的计算机设计要求。
C++提供了一种灵活的标准，它确保了最小长度（从C语言借鉴而来），如下所示：
short至少16位；int至少与short一样长；long至少32位，且至少与int一样长；long long至少64位，且至少与long一样长。
位与宇节
计算机内存的基本单元是位（bit）。可以将位看作电子开关，可以开，也可以关，关表示值0，开表示值1。
8位的内存块可以设置出256种不同的组合，因为每一位都可以有两种设置，所以8位的总组合数为2的8次方（256），
因此，8位单元可以表示0-255或者-128到127，每增加一位，组合数便加倍。
这意味着可以把16位单元设置成65 536个不同的值，把32位单元设置成4294 672 296个不同的值，
把64位单元设置为18446 744073 709 551 616个不同的值。
作为比较，unsigned long存储不了地球上当前的人数和银河系的星星数，而long long能够，
字节（byte）通常指的是8位的内存单元。从这个意义上说，字节指的就是描述计算机内存量的度量单位，
1KB等于1024字节，1MB等于1024KB，然而，C++对字节的定义与此不同。
C+字节由至少能够容纳实现的基本字符集的相邻位组成，也就是说，可能取值的数目必须等于或超过字符数目。
在美国，基本字符集通常是ASCII和EBCDIC字符集，它们都可以用8位来容纳，所以在使用这两种字符集的系统中
C++字节通常包含8位。然而，国际程可能需要使用更大的字符集，如Unicode，
因此有些实现可能使用16位甚至32位的字节。有些人使用术语八位组（octet）表示8位字节。
类型的宽度随实现而异，这可能在将C++程序从一种环境移到另一种环境
（包括在同一个系统中使用不同编译器）时引发问题。
但只要小心一点（如本章后面讨论的那样），就可以最大限度地减少这种问题。
实际上，short是short int的简称，而long是long int的简称，但是程序设计者们几乎都不使用比较长的形式。
这4种类型（int，short，long和long long）都是符号类型，这意味着每种类型的取值范围中，负值和正值几乎相同。
例如，16位的int的取值范围为-32768到+32767。
要知道系统中整数的最大长度，可以在程序中使用C++工具来检查类型的长度。
首先，sizeof运算符返回类型或变量的长度，单位为字节。
前面说过，“字节”的含义依赖于实现，因此在一个系统中，两字节的int可能是16位，而在另一个系统中可能是32位。
其次，头文件climits（在老式实现中为limits.h）中包含了关于整型限制的信息。
具体地说，它定义了表示各种限制的符号名称。例如，INT_MAX为int的最大取值，CHAR_BIT为字节的位数。
程序清单3.1演示了如何使用这些工具。该程序还演示如何初始化，即使用声明语句将值赋给变量。
程序清单3.1 limits.cpp
#include <climits>
#include <iostream>

using namespace std;

int main()
{
    int n_int = INT_MAX;
    short n_short = SHRT_MAX;
    long n_long = LONG_MAX;
    long long n_llong = LLONG_MAX;

    cout << "int is " << sizeof(int) << " bytes." << endl;
    cout << "short is " << sizeof n_short << " bytes." << endl;
    cout << "long is " << sizeof n_long << " bytes." << endl;
    cout << "long long is " << sizeof n_llong << " bytes." << endl;
    cout << endl;

    cout << "Maximum values: " << endl;
    cout << "int: " << n_int << endl;
    cout << "short: " << n_short << endl;
    cout << "long: " << n_long << endl;
    cout << "long long: " << n_llong << endl;
    cout << endl;

    cout << "Minimum int values: = " << INT_MIN << endl;
    cout << "Bits per byte: = " << CHAR_BIT << endl;

    return 0;
}
显示结果如下
int is 4 bytes.
short is 2 bytes.
long is 8 bytes.
long long is 8 bytes.

Maximum values:
int: 2147483647
short: 32767
long: 9223372036854775807
long long: 9223372036854775807

Minimum int values: = -2147483648
Bits per byte: = 8

我们来看一下该程序的主要编程特性。
1.运算符sizeof和头文件limits
可对类型名或变量名使用sizeof运算符。对类型名使用sizeof运算符时，应将名称放在括号中；但对变量名使用该运算符，括号是可选的。
头文件climits定义了符号常量表示类型的限制。如前所述，INT_MAX表示类型int能够存储的最大值。
2.初始化
初始化将赋值与声明合并在一起。例如，下面的语句声明了变量n_int，并将int的最大取值赋给它int n_int = INT_MAX;
也可以使用字面值常量来初始化。可以将变量初始化为另一个变量，条件是后者已经定义过。
甚至可以使用表达式来初始化变量，条件是当程序执行到该声明时，表达式中所有的值都是已知的。
C++还有另一种C语言没有的初始化语法：
int owls=10;   // owls初始化为10
int wrens (432);   // wrens初始化为432
注意，如果不对函数内部定义的局部变量进行初始化，该变量的值将是不确定的。
这意味着该变量的值将是它被创建之前，相应内存单元保存的值。
如果知道变量的初始值应该是什么，则应对它进行初始化。
将变量声明和赋值分开，可能会带来瞬间悬而未决的问题：
short year;
year = 1492;
然而，在声明变量时对它进行初始化，可避免以后忘记给它赋值的情况发生。
3.C++11初始化方式
还有另一种初始化方式，这种方式用于数组和结构，但在C++98中，也可用于单值变量：
int hamburgers = {24};   //hamburgers初始化为24
将大括号初始化器用于单值变量的情形还不多，但C++11标准使得这种情形更多了。
首先，采用这种方式时，可以使用等号（=），也可以不使用
int emus {7};   // emus初始化为7
int rheas = {12};   //rheas初始化为12
其次，大括号内可以不包含任何东西。在这种情况下，变量将被初始化为零：
int rocs = {};   // rocs初始化为0
int psychics {};   // psychics初始化为0
第三，这有助于更好地防范类型转换错误，这个主题将在本章末尾讨论
为何需要更多的初始化方法？有充分的理由吗？原因是让新手更容易学习C++，这可能有些奇怪。
以前，C++使用不同的方式来初始化不同的类型：初始化类变量的方式不同于初始化常规结构的方式，
而初始化常规结构的方式又不同于初始化简单变量的方式；通过使用C++新增的大括号初始化器，
初始化常规变量的方式与初始化类变量的方式更像。
C++11使得可将大括号初始化器用于任何类型（可以使用等号，也可以不使用），这是一种通用的初始化语法。
以后，教材可能介绍使用大括号进行初始化的方式，并出于向后兼容的考虑，顺便提及其他初始化方式。
3.1.4无符号类型
前面介绍的4种整型都有一种不能存储负数值的无符号变体，其优点是可以增大变量能够存储的最大值。
例如，如果short表示的范围为-32768到+32767，则无符号版本的表示范围为0-65535。
当然，仅当数值不会为负时才应使用无符号类型。
要创建无符号版本的基本整型，只需使用关键字unsigned来修改声明即可。
注意，unsigned本身是unsigned int的缩写。
程序清单3.2演示了如何使用无符号类型，并说明了程序试图超越整型的限制时将产生的后果。
程序清单3.2 exceed.cpp
#include <climits>
#include <iostream>

#define ZERO 0

using namespace std;

int main()
{
    short sam = SHRT_MAX;
    unsigned short sue = sam;

    cout << "Sam has " << sam << " dollars and Sue has " << sue << " dollars deposited." << endl;
    cout << "Add $1 to each account." << endl << "Now ";
    sam = sam + 1;
    sue = sue + 1;
    cout << "Sam has " << sam << " dollars and Sue has " << sue << " dollars deposited.\n" << endl;
    sam = ZERO;
    sue = ZERO;
    cout << "Sam has " << sam << " dollars and Sue has " << sue << " dollars deposited." << endl;
    cout << "Take $1 from each account." << endl << "Now ";
    sam = sam - 1;
    sue = sue - 1;
    cout << "Sam has " << sam << " dollars and Sue has " << sue << " dollars deposited.\n" << endl;

    return 0;
}
显示结果如下
Sam has 32767 dollars and Sue has 32767 dollars deposited.
Add $1 to each account.
Now Sam has -32768 dollars and Sue has 32768 dollars deposited.

Sam has 0 dollars and Sue has 0 dollars deposited.
Take $1 from each account.
Now Sam has -1 dollars and Sue has 65535 dollars deposited.

3.1.5选择整型类型
C++提供了大量的整型，应使用哪种类型呢？通常，int被设置为对目标计算机而言最为“自然”的长度。
自然长度（natural-size）指的是计算机处理起来效率最高的长度。如果没有非常有说服力的理由来选择其他类型，则应使用int。
现在来看看可能使用其他类型的原因。如果变量表示的值不可能为负，则可以使用无符号类型，这样变量可以表示更大的值。
如果知道变量可能表示的整数值大于16位整数的最大可能值，则使用long。即使系统上int为32位，也应这样做。
这样，将程序移植到16位系统时，就不会突然无法正常工作（参见图3.2），如果要存储的值超过20亿，可使用long long。
如果short比int小，则使用short可以节省内存。例如，假设要将程序从int为16位的系统移到int为32位的系统，
则用于存储int数组的内存量将加倍，但short数组不受影响。如果只需要一个字节，可使用char，这将稍后介绍。
3.1.6 整型字面值
整型字面值（常量）是显式书写的整型常量，与C相同，C++能够以三种不同的计数方式来书写整数：基数为10、基数为8和基数为16。
C++使用前一（两）位来标识数字常量的基数。
如果第一位为1~9，则基数为10（十进制）；因此93是以10为基数的。
如果第一位是0，第二位为1~7，则基数为8（八进制）；因此042的基数是8，它相当于十进制数34。
如果前两位为0x或0X，则基数为16（十六进制）；因此0x42为十六进制数，相当于十进制数66，
对于十六进制数，字符a~f和A-F对应于10-15，0xF为15，0xA5为165，程序清单3.3演示了这三种基数。
程序清单3.3 hexoct.cpp
#include <iostream>

using namespace std;

int main()
{
    int chest = 42;
    int waist = 0x42;
    int inseam = 042;

    cout << "Monsieur cuts a striking figure!\n";
    cout << "Chest = " << chest << " (42 in decimal)\n";
    cout << "Waist = " << waist << " (0x42 in hex)\n";
    cout << "inseam = " << inseam << " (042 in octal)\n";

    return 0;
}
显示结果如下
Monsieur cuts a striking figure!
Chest = 42 (42 in decimal)
Waist = 66 (0x42 in hex)
inseam = 34 (042 in octal)

顺便说一句，如果要以十六进制或八进制方式显示值，则可以使用cout的一些特殊特性。
前面指出过，头文件iostream提供了控制符endl，用于指示cout重起一行。
同样，它还提供了控制符dec、hex和oct，分别用于指示cout以十进制、十六进制和八进制格式显示整数。
程序清单3.4使用了hex和oct以上述三种格式显示十进制值42，默认格式为十进制，在修改格式之前，原来的格式将一直有效。
程序清单3.4 hexoct2.cpp
#include <iostream>

using namespace std;

int main()
{
    int chest = 42;
    int waist = 42;
    int inseam = 42;

    cout << "Monsieur cuts a striking figure!\n";
    cout << "Chest = " << chest << " (decimal for 42)\n";
    cout << hex << "Waist = " << waist << " (hexadecimal for 42)\n";
    cout << oct << "inseam = " << inseam << " (octal for 42)\n";

    return 0;
}
显示结果如下
Monsieur cuts a striking figure!
Chest = 42 (decimal for 42)
Waist = 2a (hexadecimal for 42)
inseam = 52 (octal for 42)

3.1.7 C++如何确定常量的类型
变量声明时指明了类型，但是，编译器如何知道常量的类型呢？
假设在程序中使用常量1492表示一个数字，程序将把1492存储为int，long还是其他整型呢？
答案是，除非有理由存储为其他类型（如使用了特殊的后缀来表示特定的类型，或者值太大，不能存储为int），否则C++将整型常量存储为int类型。
先来看看后缀。后缀是放在数字常量后面的字母，用于表示类型。
整数后面的l或L后缀表示该整数为long常量，u或U后缀表示unsigned int常量，
ul（可以采用任何一种顺序，大写小写均可）表示unsigned long常量（由于小写l看上去像数字1，因此应使用大写L作后缀）。
C++11提供了用于表示类型long long的后缀ll和LL，还提供了用于表示类型unsigned long long的后缀ull，Ull，uLL和ULL。
接下来考察长度。在C++中，对十进制整数采用的规则，与十六进制和八进制稍微有些不同。
对于不带后缀的十进制整数，将使用下面几种类型中能够存储该数的最小类型来表示：int，long或long long。
对于不带后缀的十六进制或八进制整数，将使用下面几种类型中能够存储该数的最小类型来表示：
int，unsigned int，long，unsigned long，long long或unsigned long long。
3.1.8 char类型：字符和小整数
下面介绍最后一种整型：char类型。顾名思义，char类型是专为存储字符（如字母和数字）而设计的。
现在，存储数字对于计算机来说算不了什么，但存储字母则是另一回事。编程语言通过使用字母的数值编码解决了这个问题。
因此，char类型是另一种整型。它足够长，能够表示目标计算机系统中的所有基本符号（所有的字母、数字、标点符号等）。
实际上，很多系统支持的字符都不超过128个，因此用一个字节就可以表示所有的符号。
因此，虽然char最常被用来处理字符，但也可以将它用做比short更小的整型。
在美国，最常用的符号集是ASCII字符集（参见附录C），字符集中的字符用数值编码（ASCII码）表示。
例如，字符A的编码为65，字母M的编码为77，为方便起见，本书在示例中使用的是ASCII码。
然而，C++实现使用的是其主机系统的编码-例如，IBM大型机使用EBCDIC编码。
ASCII和EBCDIC都不能很好地满足国际需要，C++支持的宽字符类型可以存储更多的值，如国际Unicode字符集使用的值。
本章稍后将介绍wchar_t类型。程序清单3.5使用了char类型
程序清单3.5 chartype.cpp
#include <iostream>

using namespace std;

int main()
{
    char ch;

    cout << "Enter a character: " << endl;
    cin >> ch;
    cout << "Hola! ";
    cout << "Thank you for the " << ch << " character." << endl;

    return 0;
}
显示结果如下
Enter a character:
A
Hola! Thank you for the A character.

程序清单3.6 morechar.cpp
#include <iostream>

using namespace std;

int main()
{
    char ch = 'M';
    int i = ch;
    cout << "The ASCII code for " << ch << " is " << i << endl;

    cout << "Add one to the character code: " << endl;
    ch = ch + 1;
    i = ch;
    cout << "The ASCII code for " << ch << " is " << i << endl;

    cout << "Display char ch using cout.put(ch): ";
    cout.put(ch);

    cout.put('!');

    cout << endl << "Done" << endl;

    return 0;
}
显示结果如下
The ASCII code for M is 77
Add one to the character code:
The ASCII code for N is 78
Display char ch using cout.put(ch): N!
Done

程序清单3.7演示了一些转义序列。
程序清单3.7 bondini.cpp
#include <iostream>

using namespace std;

int main()
{
    cout << "\aOperation \"HyperHype\" is now activated!\n";
    cout << "Enter your agent code:________\b\b\b\b\b\b\b\b";
    long code = 0;
    cin >> code;
    cout << "\aYou entered " << code << "\n";
    cout << "\aCode varified! Proceed with Plan Z3!\n";

    return 0;
}
显示结果如下
Operation "HyperHype" is now activated!
Enter your agent code:123_____
You entered 123
Code varified! Proceed with Plan Z3!

C++通用字符名（universal character name）
通用字符名类似于转义序列。但是，普通的转义序列只能出现于字符常量和字符串字面量中，
而通用字符名还可以用于标识符。这个特性允许程序员在为变量、函数等命名时使用他们的本国语言。
可以用两种方式书写通用字符名（\udddd和\Udddddddd），每个d都是一个十六进制的数字。
在格式\Udddddddd中，8个d组成一个8位的十六进制数用于标识目标字符的UCS码点。
格式\udddd可以用于码点的十六进制值为FFFF或更小的字符。
并不是所有的通用字符名都可以用于标识符，C++标准列出了哪些通用字符名可以用于标识符。
此外，标识符不能以表示数字的通用字符名开头。

signed char和unsigned char
与int不同的是，char在默认情况下既不是没有符号，也不是有符号。
是否有符号由C++实现决定，这样编译器开发人员可以最大限度地将这种类型与硬件属性匹配起来。
如果char有某种特定的行为对您来说非常重要，则可以显式地将类型设置为signed char或unsigned char。
如果将char用作数值类型，则unsigned char和signed char之间的差异将非常重要。
unsigned char类型的表示范围通常为0~255，而signed char的表示范围为-128到127，
例如，假设要使用一个char变量来存储像200这样大的值，则在某些系统上可以，而在另一些系统上可能不可以。
但使用unsigned char可以在任何系统上达到这种目的。
wchar_t
程序需要处理的字符集可能无法用一个8位的字节表示，如日文汉字系统。对于这种情况，C++的处理方式有两种。
首先，如果大型字符集是实现的基本字符集，则编译器厂商可以将char定义为一个16位的字节或更长的字节。
其次，一种实现可以同时支持一个小型基本字符集和一个较大的扩展宝符集。
8位char可以表示基本字符集，另一种类型wchar_t（宽字符类型）可以表示扩展字符集。
wchar_t类型是一种整数类型，它有足够的空间，可以表示系统使用的最大扩展字符集。
这种类型与另一种整型（底层（underlying）类型）的长度和符号属性相同。
对底层类型的选择取决于实现，因此在一个系统中，它可能是unsigned short，而在另一个系统中，则可能是int。
cin和cout将输入和输出看作是char流，因此不适于用来处理wchar t类型。
iostream头文件的最新版本提供了作用相似的工具wcin和wcout，可用于处理wchar_t流。
另外，可以通过加上前缀L来指示宽字符常量和宽字符串。下面的代码将字母P的wchar_t版本存储到变量bob电，并显示单词tall的wchar_t版本：
wchar_t bob =L'p'；
wcout << L"tall" << endl;
在支持两字节wchar_t的系统中，上述代码将把每个字符存储在一个两个字节的内存单元中。
本书不主用宽字符类型，但读者应知道有这种类型，尤其是在进行国际编程或使用Unicode或ISO 10646时。
7，C++11新增的类型：char16_t和char32_t
随着编程人员日益熟悉Unicode，类型wchar_t显然不再能够满足需求。
事实上，在计算机系统上进行字符和字符串编码时，仅使用Unicode码点并不够。
具体地说，进行字符串编码时，如果有特定长度和符号特征的类型，将很有帮助，而类型wchar_t的长度和符号特征随实现而定。
因此，C++11新增了类型char16_t和char32_t，其中前者是无符号的，长16位，而后者也是无符号的，但长32位。
C++11使用前缀u表示char16_t字符常量和字符串常量，如u'C'和u"be good"；
并使用前缀U表示char32_t常量，如U'R'和U"dirty rat"，类型char16_t与\udddd形式的通用字符名匹配，
而类型char32_t与\Udddddddd形式的通用字符名匹配
前缀u和U分别指出字符字面值的类型为char16_t和char32_t
char16_t ch1 = u'q';
char32_t ch2 = U'\U0000222B';
与wchart一样，char16_t和char32_t也都有底层类型（一种内置的整型），但底层类型可能随系统而定。
3.1.9 bool类型
ANSI/ISO C++标准添加了一种名叫bool的新类型（对C++来说是新的），
过去，C++和C一样，也没有布尔类型。在第5章和第6章中将会看到，C++将非零值解释为true，将零解释为false。
然而，现在可以使用bool类型来表示真和假了，它们分别用预定义的字面值true和false表示。
也就是说，可以这样编写语句：
bool is_ready = true;
字面值true和false都可以通过提升转换为int类型，true被转换为1，而false被转换为0：
int ans = true;   //ans初始化为1
int promise = false;   //promise初始化为0
另外，任何数字值或指针值都可以被隐式转换（即不用显式强制转换）为bool值。
任何非零值都被转换为true，而零被转换为false。
在第6章介绍if语句后，示例中将经常使用数据类型bool。
3.2 const限定符
现在回过头来介绍常量的符号名称。符号名称指出了常量表示的内容。
另外，如果程序在多个地方使用同一个常量，则需要修改该常量时，只需修改一个符号定义即可。
本章前面关于#define语句的说明指出过，C++有一种更好的处理符号常量的方法，
这种方法就是使用const关键字来修改变量声明和初始化。
例如，假设需要一个表示一年中月份数的符号常量，请在程序中输入下面这行代码：
const int Months =12;
这样便可以在程序中使用Months，而不是12了。
常量（如Months）被初始化后，其值就被固定了，编译器将不允许再修改该常量的值。
如果您这样做，g++将指出程序试图给一个只读变量赋值。
关键字const叫做限定符，因为它限定了声明的含义。
一种常见的做法是将名称的首字母大写，以提醒您Months是个常量。
这决不是一种通用约定，但在阅读程序时有助于区分常量和变量。
另一种约定是将整个名称大写，使用#define创建常量时通常使用这种约定。
创建常量的通用格式如下：
const type name-value;
注意，应在声明中对const进行初始化。如果在声明常量时没有提供值，则该常量的值将是不确定的，且无法修改。
如果以前使用过C语言，您可能觉得前面讨论的#define语句已经足够完成这样的工作了。
但const比#defien好。首先，它能够明确指定类型。
其次，可以使用C++的作用域规则将定义限制在特定的函数或文件中
（作用域规则描述了名称在各种模块中的可知程度，将在第9章讨论），
第三，可以将const用于更复杂的类型，如第4章将介绍的数组和结构。
提示：如果读者在学习C++之前学习过C语言，并打算使用#define来定义符号常量，请不要这样做，而应使用const。
ANSI C也使用const限定符，这是从C++借鉴来的。
如果熟悉ANSI C版本，则应注意，C++版本稍微有些不同。
区别之一是作用域规则，这将在第9章讨论；另一个主要的区别是，在C++（而不是C）中可以用const值来声明数组长度，
第4章将介绍一些这样的例子。
3.3浮点数
了解各种C++整型后，来看看浮点类型，它们是C++的第二组基本类型。
浮点数能够表示带小数部分的数字，它们提供的数字范围也更大。
如果数字很大，无法表示为long类型，则可以使用浮点类型来表示。
计算机将浮点数分成两部分存储。一部分表示值，另一部分用于对值进行放大或缩小。
下面扛个比方。对于数字34.1245和34124.5，它们除了小数点的位置不同外，其他都是相同的。
可以把第一个数表示为0.341245（基准值）和100（缩放因子），
而将第二个数表示为0.341245（基准值相同）和10000（缩放因子更大），
缩放因子的作用是移动小数点的位置，术语浮点因此而得名。
C++内部表示浮点数的方法与此相同，只不过它基于二进制数，因此缩放因子是2的幂，不是10的幂。
浮点数能够表示小数值、非常大和非常小的值，它们的内部表示方法与整数完全不同。
3.3.1 书写浮点数
C++有两种书写浮点数的方式。第一种是使用常用的标准小数点表示法：
即使小数部分为0（如8.0），小数点也将确保该数字以浮点格式（而不是整数格式）表示。
第二种表示浮点值的方法叫做E表示法，其外观是像这样的：3.45E6，这指的是3.45与1000000相乘的结果；
E6指的是10的6次方，即1后面6个0。因此，3.45E6表示的是3450000。
6被称为指数，3.45被称为尾数。读者可能注意到了，E表示法最适合于非常大和非常小的数。
E表示法确保数字以浮点格式存储，即使没有小数点。
注意，既可以使用E也可以使用e，指数可以是正数也可以是负数。（参见图3.3）
然而，数字中不能有空格，因此7.2 E6是非法的。
指数为负数意味着除以10的乘方，而不是乘以10的乘方。因此，8.33E-4表示8.33/10000，即0.000833。
注意，-8.33E4指的是-83300，前面的符号用于数值，而指数的符号用于缩放。
记住：d.dddE+n指的是将小数点向右移n位；而d.dddE-n指的是将小数点向左移n位。
之所以称为“浮点"，就是因为小数点可移动。
3.3.2 浮点类型
和ANSIC一样，C++也有3种浮点类型：float，double和long double，
这些类型是按它们可以表示的有效数位和允许的指数最小范围来描述的。
有效位（significant figure）是数字中有意义的位。
例如，加利福尼亚的Shasta山脉的高度为14179英尺，该数字使用了5个有效位，指出了最接近的英尺数。
然而，将Shasta山脉的高度写成约14000英尺时，有效位数为2位，因为结果经过四舍五入精确到了千位。
在这种情况下，其余的3位只不过是占位符而已。有效位数不依赖于小数点的位置。
例如，可以将高度写成14.162千英尺。这样仍有5个有效位，因为这个值精确到了第5位。
事实上，C和C++对于有效位数的要求是，float至少32位，double至少48位，且不少于float，
long double至少和double一样多。这三种类型的有效位数可以一样多。
然而，通常，float为32位，double为64位，long double为80、96或128位。
另外，这3种类型的指数范围至少是-37到37，可以从头文件cfloat或float.h中找到系统的限制。
（cfloat是C语言的float.h文件的C++版本。）
程序清单3.8演示了float和double类型及它们表示数字时在精度方面的差异（即有效位数）。
该程序预览了将在第17章介绍的ostream方法setf()。
这种调用迫使输出使用定点表示法，以便更好地了解精度，它防止程序把较大的值切换为E表示法，
并使程序显示到小数点后6位。参数ios_base::fixed和ios_base::floatfield是通过包含iostream来提供的常量。
程序清单3.8 floatnum.cpp
#include <iostream>

using namespace std;

int main()
{
    cout.setf(ios_base::fixed, ios_base::floatfield);
    float tub = 10.0 / 3.0;
    double mint = 10.0 / 3.0;
    const float million = 1.0e6;
    cout << "tub = " << tub << ", a million tubs = " << million *tub << ", \n";
    cout << "and ten million tubs = " << 10 * million *tub << endl;
    cout << "mint = " << mint << ", a million mints = " << million *mint << endl;

    return 0;
}
显示结果如下
tub = 3.333333, a million tubs = 3333333.250000,
and ten million tubs = 33333332.000000
mint = 3.333333, a million mints = 3333333.333333

1.程序说明
通常cout会删除结尾的零。例如，将3333333.250000显示为3333333.25。
调用cout.setf()将覆盖这种行为，至少在新的实现中是这样的。
这里要注意的是，为何float的精度比double低。tub和mint都被初始化为10.0/3.0。
由于cout打印6位小数，因此tub和mint都是精确的。但当程序将每个数乘以一百万后，tub在第7个3之后就与正确的值有了误差。
tub在7位有效位上还是精确的（该系统确保float至少有6位有效位，但这是最糟糕的情况）。
然而，double类型的变量显示了13个3，因此它至少有13位是精确的。由于系统确保15位有效位，因此这就没有什么好奇怪的了。
另外，将tub乘以一百万，再乘以10后，得到的结果不正确，这再一次指出了float的精度限制。
cout所属的ostream类有一个类成员函数，能够精确地控制输出的格式字段宽度、小数位数、采用小数格式还是E格式等。
第17章将介绍这些选项。为简单起见，本书的例子通常只使用<<运算符。有时候，这种方法显示的位数比需要的位数多，但这只会影响美观。
如果您介意这种问题，可以浏览第17章，了解如何使用格式化方法。然而，在这里就不作过多的解释了。
3.3.3浮点常量
在程序中书写浮点常量的时候，程序将把它存储为哪种浮点类型呢？
在默认情况下，像8.24和2.4E8这样的浮点常量都属于double类型。
如果希望常量为foat类型，请使用f或F后缀。
对于long double类型，可使用l或L后缀（由于l看起来像数字1，因此L是更好的选择），下面是一些示例：
1.234f
2.45E20F
2.345324E28
2.2L
3.3.4 浮点数的优缺点
与整数相比，浮点数有两大优点。首先，它们可以表示整数之间的值。
其次，由于有缩放因子，它们可以表示的范围大得多。
另一方面，浮点运算的速度通常比整数运算慢，且精度将降低。程序清单3.9说明了最后一点。
程序清单3.9 fltadd.cpp
#include <iostream>

using namespace std;

int main()
{
    float a = 2.34E+22F;
    float b = a + 1.0F;

    cout << "a = " << a << endl;
    cout << "b - a = " << b - a << endl;

    return 0;
}
显示结果如下
a = 2.34e+22
b - a = 0

问题在于，2.34E+22是一个小数点左边有23位的数字。加上1，就是在第23位加1。
但float类型只能表示数字中的前6位或前7位，因此修改第23位对这个值不会有任何影响。
将类型分类
C++对基本类型进行分类，形成了若干个族。类型signed char，short，int和long统称为符号整型；
它们的无符号版本统称为无符号整型；C++11新增了long long。
bool，char，wchar_t、符号整数和无符号整型统称为整型；C++11新增了char16_t和char32_t。
float，double和long double统称为浮点型。整数和浮点型统称算术（arithmetic）类型
3.4 C++算术运算符
读者可能还对学校里作的算术练习记忆犹新，在计算机上也能够获得同样的乐趣。C++使用运算符来运算。
它提供了几种运算符来完成5种基本的算术计算：加法、减法、乘法、除法以及求模。
每种运算符部使用两个值（操作数）来计算结果。运算符及其操作数构成了表达式。
例如，在下面的语句中
int wheels = 4 +2;
4和2都是操作数，+是加法运算符，4 + 2则是一个表达式，其值为6。
下面是5种基本的C++算术运算符。
+运算符对操作数执行加法运算。例如，4+20等于24。
-运算符从第一个数中减去第二个数。例如，12-3等于9。
*运算符将操作数相乘。例如，28*4等于112。
/运算符用第一个数除以第二个数。例如，1000/5等于200，如果两个操作数都是整数，则结果为商的整数部分。
例如，17/3等于5，小数部分被丢弃。
%运算符求模。也就是说，它生成第一个数除以第二个数后的余数。
例如，19%6为1，因为19是6的3倍余1，两个操作数必须都是整型，将该运算符用于浮点数将导致编译错误。
如果其中一个是负数，则结果的符号满足如下规则：
（a/b）*b + a%b =a
当然，变量和常量都可以用作操作数，程序清单3.10说明了这一点。
由于%的操作数只能是整数，因此将在后面的例子中讨论它。
程序清单3.10 arith.cpp
#include <iostream>

using namespace std;

int main()
{
    double hats, heads;

    cout.setf(ios::fixed, ios::floatfield);
    cout << "Enter number: ";
    cin >> hats;
    cout << "Enter another number: ";
    cin >> heads;
    cout << "hats = " << hats << ", heads = " << heads << endl;
    cout << "hats + heads = " << hats + heads << endl;
    cout << "hats - heads = " << hats - heads << endl;
    cout << "hats * heads = " << hats *heads << endl;
    cout << "hats / heads = " << hats / heads << endl;

    return 0;
}
显示结果如下
Enter number: 50.25
Enter another number: 11.17
hats = 50.250000, heads = 11.170000
hats + heads = 61.420000
hats - heads = 39.080000
hats * heads = 561.292500
hats / heads = 4.498657

3.4.1运算符优先级和结合性
很多表达式都包含多个运算符。这样将产生一个问题：究竟哪个运算符最先被使用呢？
例如，请看下面的语句：
int flyingpigs = 3 + 4 * 5;
操作数4旁边有两个运算符：+和*。
当多个运算符可用于同一个操作数时，C++使用优先级规则来决定首先使用哪个运算符。
算术运算符遵循通常的代数优先级，先乘除，后加减，因此3+4 * 5指的是3 + (4 * 5)，结果为23，而不是35。
当然，可以使用括号来执行自己定义的优先级。附录D介绍了所有C++运算符的优先级。
其中，*、/和%位于同一行，这说明它们的优先级相同。同样，加和减的优先级也相同，但比乘除低。
有时，优先级列表并不够用。请看下面的语句：
float logs = 120 / 4* 5;
操作数4也位于两个运算符中间，但运算符/和*的优先级相同，
因此优先级本身并不能指出程序究竟是先计算120除以4，还是先计算4乘以5，
因为第一种选择得到的结果是150，而第二种选择的结果是6。因此选择十分重要。
当两个运算符的优先级相同时，C++将看操作数的结合性：（associativity）是从左到右，还是从右到左。
从左到右的结合性意味着如果两个优先级相同的运算符被同时用于同一个操作数，则首先应用左侧的运算符。
从右到左的结合性则首先应用右侧的运算符。附录D也列出了结合性方面的信息。
从中可以看出乘除都是从左到右结合的。这说明应当先对4使用左侧的运算符，
也就是说，用120除以4，得到的结果为30，然后再乘以5，结果为150。
注意：仅当两个运算符被用于同一个操作数时，优先级和结合性规则才有效。请看下面的表达式：
int dues = 20 * 5 + 24 * 6;
运算符优先级表明了两点："程序必须在做加法之前计算20*5，必须在做加法之前计算24*6。
但优级和结合性都没有指出应先计算哪个乘法。读者可能认为，结合性表明应先做左侧的乘法，
但是在这种情况下，两个*运算符并没有用于同一个操作数，所以该规则不适用。
事实上，C++把这个问题留给了实现，让它来决定在系统中的最佳顺序。
对于这个例子来说，两种顺序的结果是一样的，但是也有两种顺序结果不同的情况。
在第5章讨论递增运算符时，将介绍一个这样的例子。
34.2除法运算符
除法运算符（/）的行为取决于操作数的类型。如果两个操作数都是整数；则C++将执行整数除法。
这意味着结果的小数部分将被丢弃，使得最后的结果是一个整数。
如果其中有一个（或两个）操作数是浮点值，则小数部分将保留，结果为浮点数。
程序清单3.11演示了C++除法如何处理不同类型的值。
和程序清单3.10一样，该程序也调用setf成员函数来修改结果的显示方式。
程序清单3.11 divide.cpp
#include <iostream>

using namespace std;

int main()
{
    cout.setf(ios::fixed, ios::floatfield);
    cout << "Integer division: 9/5 = " << 9 / 5 << endl;
    cout << "Floating-point division: 9.0/5.0 = " << 9.0 / 5.0 << endl;
    cout << "Mixed division: 9.0/5 = " << 9.0 / 5 << endl;
    cout << "double constant: 1e7/9.0 = " << 1e7 / 9.0 << endl;
    cout << "float constant: 1e7f/9.0f = " << 1e7f / 9.0f << endl;

    return 0;
}
显示结果如下
Integer division: 9/5 = 1
Floating-point division: 9.0/5.0 = 1.800000
Mixed division: 9.0/5 = 1.800000
double constant: 1e7/9.0 = 1111111.111111
float constant: 1e7f/9.0f = 1111111.125000

3.4.3求模运算符
求模运算符返回整数除法的余数。它与整数除法相结合，尤其适用于解决要求将一个量分成不同的整数单元的问题，
例如将英寸转换为英尺和英寸，或者将美元转换为元、角、分、厘。
第2章的程序清单2.6将重量单位英右转换为磅。程序清单3.12则将磅转换为英石。记住，一英石等于14磅，多数英国浴室都使用这种单位。
该程序使用整数除法来计算合多少英石，再用求模运算符来计算余下多少磅。
程序清单3.12 modulus.cpp
#include <iostream>

using namespace std;

int main()
{
    const int Lbs_per_stn = 14;

    cout << "Enter your weight in pounds: ";
    int lbs = 0;
    cin >> lbs;
    int stone = lbs / Lbs_per_stn;
    int pounds = lbs % Lbs_per_stn;
    cout << lbs << " pounds are " << stone << " stone, " << pounds << " pound(s).\n";

    return 0;
}
显示结果如下
Enter your weight in pounds: 128
128 pounds are 9 stone, 2 pound(s).

34.4 类型转换
C++丰富的类型允许根据需求选择不同的类型，这也使计算机的操作更复杂。
例如，将两个short值相加涉及到的硬件编译指令可能会与将两个long值相加不同。
由于有11种整型和3种浮点类型，因此计算机需要处理大量不同的情况，尤其是对不同的类型进行运算时。
为处理这种潜在的混乱，C++自动执行很多类型转换：
将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进行转换
表达式中包含不同的类型时，C++将对值进行转换
将参数传递给函数时，C+将对值进行转换。
如果不知道进行这些自动转换时将发生的情况，将无法理解一些程序的结果，因此下面详细地介绍这些规则。
1.初始化和赋值进行的转换
C++允许将一种类型的值赋给另一种类型的变量。这样做时，值将被转换为接收变量的类型。
例如，假设so_long的类型为long，thirty的类型为short，而程序中包含这样的语句：
so_long = thirty;
则进行赋值时，程序将thirty的值（通常是16位）扩展为long值（通常为32位），
扩展后将得到一个新值，这个值被存储在so_long中，而thirty的内容不变。
将一个值赋给值取值范围更大的类型通常不会导致什么问题。
例如，将short值赋给long变量并不会改变这个值，只是占用的字节更多而已。
然而，将一个很大的long值赋给float变量将降低精度。因为float只有6位有效数字。
因此，有些转换是安全的，有些则会带来麻烦。表3.3列出了一些可能出现的转换问题。
将较大的浮点类型转换为较小的浮点类型，如将double转换为float，
精度（有效数位）降低，值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的。
将浮点类型转换为整型
小数部分丢失，原来的值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的。
将较大的整型转换为较小的整型，如将long转换为short
原来的值可能超出目标类型的取值范围，通常只复制右边的字节。
将0赋给bool变量时，将被转换为false；而非零值将被转换为true。
将浮点值赋给整型将导致两个问题。
首先，将浮点值转换为整型会将数字截短（除掉小数部分），其次，float值对于int变量来说可能太大了。
在这种情况下，C++并没有定义结果应该是什么；这意味着不同的C++实现得到的结果可能不同。
传统初始化的行为与赋值相同，程序清单3.13演示了一些初始化进行的转换。
程序清单3.13 assign.cpp
#include <iostream>

using namespace std;

int main()
{
    cout.setf(ios::fixed, ios::floatfield);
    float tree = 3;
    int guess = 3.9832;
    int debt = 7.2E12;

    cout << "tree = " << tree << endl;
    cout << "guess = " << guess << endl;
    cout << "debt = " << debt << endl;

    return 0;
}
编译结果如下
g++ -o assign assign.cpp
assign.cpp: In function ‘int main()’:
assign.cpp:10:16: warning: overflow in conversion from ‘double’ to ‘int’ changes value from ‘7.2e+12’ to ‘2147483647’ [-Woverflow]
   10 |     int debt = 7.2E12;
      |                ^~~~~~

显示结果如下
tree = 3.000000
guess = 3
debt = 2147483647

以{}方式初始化时进行的转换（C++11）
C++11将使用大括号的初始化称为列表初始化（list-initialization），
因为这种初始化常用于给复杂的数据类型提供值列表。
与程序清单13.3所示的初始化方式相比，它对类型转换的要求更严格。
具体地说，列表初始化不允许缩窄（narrowing），即变量的类型可能无法表示赋给它的值。
例如，不允许将浮点型转换为整型。在不同的整型之间转换或将整型转换为浮点型可能被允许，
条件是编译器知道目标变量能够正确地存储赋给它的值。
例如，可将long变量初始化为int值，因为long总是至少与int一样长；
相反方向的转换也可能被允许，只要int变量能够存储赋给它的long常量。
const int code = 66;
int x = 66;
char c1 {31325};   //narrowing，not allowed
char c2 = {66};   // allowed because char can hold 66
char c3 {code};   // allowed because char can hold 66
char c4 = {x};   //not allowed，x is not constant
x=31325;
char cs = x;   //allowed by this form of initialization
在上述代码中，初始化c4时，您知道x的值为66，但在编译器看来，x是一个变量，其值可能很大。
编译器不会跟踪下述阶段可能发生的情况：从x被初始化到它被用来初始化c4。
表达式中的转换
当同一个表达式中包含两种不同的算术类型时，将出现什么情况呢？
在这种情况下，C++将执行两种自动转换：
首先，一些类型在出现时便会自动转换；其次，有些类型在与其他类型同时出现在表达式中时将被转换。
先来看看自动转换。在计算表达式时，C++将bool，char，unsigned char，signed char和short值转换为int。
具体地说，true被转换为1，false被转换为0。这些转换被称为整型提升（integral promotion）。请看下面的语句：
short chickens = 20;
short ducks = 35;
short fowl = chickens + ducks;
为执行第3条语句，C++程序取得chickens和ducks的值，并将它们转换为int，
然后，程序将结果转换为short类型，因为结果将被赋给一个short变量。
这种说法可能有点拗口，但是情况确实如此。
通常将int类型选择为计算机最自然的类型，这意味着计算机使用这种类型时，运算速度可能最快。
还有其他一些整型提升：如果short比int短，则unsigned short类型将被转换为int；
如果两种类型的长度相同，则unsigned short类型将被转换为unsigned int。
这种规则确保了在对unsigned short进行提升时不会损失数据。
同样，wchar_t被提升成为下列类型中第一个宽度足够存储wchar_t取值范围的类型：
int，unsigned int，long或unsigned long。
将不同类型进行算术运算时，也会进行一些转换，例如将int和float相加时。
当运算涉及两种类型时，较小的类型将被转换为较大的类型。
例如，程序清单3.11中的程序用9.0除以5。由于9.0的类型为double，因此程序在用5除之前，将5转换为double类型。
总之，编译器通过校验表来确定在算术表达式中执行的转换。
C++11对这个校验表稍做了修改，下面是C++11版本的校验表，编译器将依次查阅该列表
（1）如果有一个操作数的类型是long double，则将另一个操作数转换为long double。
（2）否则，如果有一个操作数的类型是double，则将另一个操作数转换为double。
（3）否则，如果有一个操作数的类型是float，则将另一个操作数转换为float。
（4）否则，说明操作数都是整型，因此执行整型提升。
（5）在这种情况下，如果两个操作数都是有符号或无符号的，且其中一个操作数的级别比另一个低，
则转换为级别高的类型。
（6）如果一个操作数为有符号的，另一个操作数为无符号的，且无符号操作数的级别比有符号操作数高，
则将有符号操作数转换为无符号操作数所属的类型。
（7）否则，如果有符号类型可表示无符号类型的所有可能取值，则将无符号操作数转换为有符号操作数所属的类型。
（8）否则，将两个操作数都转换为有符号类型的无符号版本。
ANSI C遵循的规则与ISO 2003 C+相同，这与前述规则稍有不同；而传统K&R C的规则又与ANSI C稍有不同。
例如，传统C语言总是将float提升为double，即使两个操作数都是float。
前面的列表谈到了整型级别的概念，简单地说，
有符号整型按级别从高到低依次为long long，long，int，short和signed char；
无符号整型的排列顺序与有符号整型相同。
类型char，signed char和unsigned char的级别相同。
类型bool的级别最低。
wchar_t、char16_t和char32_t的级别与其底层类型相同。
传递参数时的转换
正如第7章将介绍的，传递参数时的类型转换通常由C++函数原型控制。
然而，也可以取消原型对参数传递的控制，尽管这样做并不明智。
在这种情况下，C++将对char和short类型（signed和unsigned）应用整型提升。
另外，为保持与传统C语言中大量代码的兼容性，在将参数传递给取消原型对参数传递控制的函数时，
C++将float参数提升为double。
强制类型转换
C++还允许通过强制类型转换机制显式地进行类型转换。（C++认识到，必须有类型规则，而有时又需要推翻这些规则。）
强制类型转换的格式有两种。例如，为将存储在变量thorn中的int值转换为long类型，可以使用下述表达式中的一种：
(long) thorn
long (thorn)
强制类型转换不会修改thorn变量本身，而是创建一个新的、指定类型的值，可以在表达式中使用这个值。
强制转换的通用格式如下：
(typeName) value
typeName (value)
第一种格式来自C语言，第二种格式是纯粹的C++。新格式的想法是，要让强制类型转换就像是函数调用。
这样对内置类型的强制类型转换就像是为用户定义的类设计的类型转换。
C++还引入了4个强制类型转换运算符，对它们的使用要求更为严格，这将在第15章介绍。
在这四个运算符中，static_cast<>可用于将值从一种数值类型转换为另一种数值类型。
例如，可以像下面这样将thorn转换为long类型：static cast<long> (thorn)
推而广之，可以这样做：static_cast<typeName> (value)
Stroustrup认为，C语言式的强制类型转换由于有过多的可能性而极其危险，这将在第15章更深入地讨论。
运算符static_cast比传统强制类型转换更严格。
程序清单3.14演示了这两种基本的强制类型转换和static_cast<>。
程序清单3.14 typecast.cpp
#include <iostream>

using namespace std;

int main()
{
    int auks, bats, coots;

    auks = 19.99 + 11.99;

    bats = (int) 19.99 + (int) 11.99;
    coots = int(19.99) + int(11.99);
    cout << "auks = " << auks << ", bats = " << bats << ", coots = " << coots << endl;

    char ch = 'Z';
    cout << "The code for " << ch << " is ";
    cout << int(ch) << endl;
    cout << "Yes, the code is " << static_cast<int> (ch) << endl;

    return 0;
}
显示结果如下
auks = 31, bats = 30, coots = 30
The code for Z is 90
Yes, the code is 90

3.4.5 C++11中的auto声明
C++11新增了一个工具，让编译器能够根据初始值的类型推断变量的类型。为此，它重新定义了auto的含义。
auto是一个C语言关键字，但很少使用，有关其以前的含义，请参阅第9章。
在初始化声明中，如果使用关键字auto，而不指定变量的类型，编译器将把变量的类型设置成与初始值相同：
auto n= 100;   // n is int
auto x = 1.5;   // x is double
auto y =1.3e12L;   // y is long double
然而，自动推断类型并非为这种简单情况而设计的；事实上，如果将其用于这种简单情形，甚至可能让您误入歧途。
例如，假设您要将x、y和z都指定为double类型，并编写了如下代码：
auto x =0.0; // ok，x is double because 0.0 is double
double y = 0;   // ok，0 automatically converted to 0.0
auto z = 0;   // oops，z is int because 0 is int
显式地声明类型时，将变量初始化0（而不是0.0）不会导致任何问题，但采用自动类型推断时，这却会导致问题。
处理复杂类型，如标准模块库（STL）中的类型时，自动类型推断的作用才能显现出来。
例如，对于下述C++98代码：
std::vector<double> scores;
std::vector<double>::iterator p_itr = scores.begin();
C++11允许您将其重写为下面这样：
std::vector<double> scores;
auto p_itr = scores.begin();
本书后面讨论相关的主题时，将再次提到auto的这种新含义。
3.5总结
C++的基本类型分为两组：一组由存储为整数的值组成，另一组由存储为浮点格式的值组成。
整型之间通过存储值时使用的内存量及有无符号来区分。
整型从最小到最大依次是：bool，char，signed char，unsigned char，short，unsigned short，
int，unsigned int，long、unsigned long以及C++11新增的long long和unsigned long long。
还有一种wchar_t类型，它在这个序列中的位置取决于实现。
C++11新增了类型char16_t和char32_t，它们的宽度足以分别存储16和32位的字符编码。
C++确保了char足够大，能够存储系统基本字符集中的任何成员，而wchar_t则可以存储系统扩展字符集中的任意成员，
short至少为16位，而int至少与short一样长，long至少为32位，且至少和int一样长。确切的长度取决于实现。
字符通过其数值编码来表示。
浮点类型可以表示小数值以及比整型能够表示的值大得多的值。
3种浮点类型分别是float，double和long double。
C++确保float不比double长，而double不比long double长。
通常，float使用32位内存，doublo使用64位，long double使用80到128位。
通过提供各种长度不同、有符号或无符号的类型，c++使程序员能够根据特定的数据要求选择合适的类型。
C++使用运算符来提供对数字类型的算术运算：加、减、乘、除和求模。
当两个运算符对同一个操作数进行操作时，C++的优先级和结合性规则可以确定先执行哪种操作。
对变量赋值、在运算中使用不同类型、使用强制类型转换时，C+将把值从一种类型转换为另一种类型。
很多类型转换都是“安全的”，即可以在不损失和改变数据的情况下完成转换。
例如，可以把int值转换为long值，而不会出现任何问题。
对于其他一些转换，如将浮点类型转换为整型，则需要更加小心。
3.6 复习题
1.为什么C++有多种整型？
方便根据特定需求选择最适合的类型。

2.声明与下述描述相符的变量
a.short整数，值为80
b.unsigned int整数，值为42110
c.值为3000000000的整数

short a = 80;
unsigned int b = 42110;
unsigned long c = 3000000000; 或者 long long d = 3000000000;

3.C++提供了什么措施来防止超出整型的范围？
C++没有提供自动防止超出整型限制的功能，可以使用头文件climits来确定限制情况。

4.33L与33之间有什么区别？
常量33L的类型为long，常量33的类型为int

5，下面两条C++语句是否等价？
char grade = 65;
char grade ='A';
不等价
65是一个int常量，而'A'是一个char常量

6，如何使用C++来找出编码88表示的字符？指出至少两种方法。
char ch = 88;
cout << ch << endl;
cout.put ( char (88) );
cout << char (88) << endl;
cout  << (char) 88 << endl;

7，将long值赋给float变量会导致舍入误差，将long值赋给double变量呢？将long long值赋给double变量呢？
这个问题的答案取决于这两个类型的长度。如果long为4个字节，则没有损失。因为此时long的最大值只有10位数字。
由于double提供了至少15位有效数字，因而不需要进行任何舍入。
long long类型可提供19位有效数字，超过了double保证的15位有效数字。

8，下列C++表达式的结果分别是多少？
a.8*9+2
b.6*3/4
c.3/4*6
d.6.0*3/4
e.15%4

74
4
0
4.5
3

9.假设x1和x2是两个double变量，您要将它们作为整数相加，再将结果赋给一个整型变量。
请编写一条完成这项任务的C++语句。如果要将它们作为double值相加并转换为int呢？

int y = (int) x1 +  (int) x2;
int y = int (x1) + int (x2);

int z = (int) (x1 + x2);
int z = int (x1 + x2);


10，下面每条语句声明的变量都是什么类型？
a.auto cars = 15;
b.auto iou = 150.37f;
c.auto level= 'B';
d.auto crat =U'\U00002155'
e.auto fract =8.25f/2.5

int
float
char
char32_t
double

3.7编程练习
1.编写一个小程序，要求用户使用一个整数指出自己的身高（单位为英寸），然后将身高转换为英尺和英寸。
该程序使用下划线字符来指示输入位置。另外，使用个const符号常量来表示转换因子。
#include <iostream>

int main()
{
    std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);
    const int Foot_inch = 12;
    const double Inch_sm = 2.54;

    double Growth = 0;
    std::cout << "Enter your height in centimeters: ___\b\b\b";
    std::cin >> Growth;

    double Growth_inch = Growth / Inch_sm;
    std::cout << "Height in inches: " << Growth_inch << std::endl;

    int f = int (Growth_inch) / Foot_inch;
    int d = int (Growth_inch) % Foot_inch;
    std::cout << "Your height: " << f << " foot " << d << " inch" << std::endl;

    return 0;
}
显示结果如下
Enter your height in centimeters: 168
Height in inches: 66.141732
Your height: 5 foot 6 inch

2.编写一个小程序，要求以几英尺几英寸的方式输入其身高，并以磅为单位输入其体重。（使用3个变量来存储这些信息。）
该程序报告其BMI（Body Mass Index，体重指数）。
为了计算BMI，该程序以英寸的方式指出用户的身高（1英尺为12英寸），
并将以英寸为单位的身高转换为以米为单位的身高（1英寸=0.0254米），
然后，将以磅为单位的体重转换为以千克为单位的体重（1千克=2.2磅），
最后，计算相应的BMI = 体重（千克）除以身高（米）的平方，用符号常量表示各种转换因子。
#include <iostream>
#include <cmath>

int main()
{
    std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);

    const int Foot_inch = 12;
    const double Inch_metr = 0.0254;
    const double kg_pound = 2.2;

    int height_foot = 0;
    std::cout << "How many foot are in you: ___\b\b\b";
    std::cin >> height_foot;

    int height_inch = 0;
    std::cout << "How many inches are in you: __\b\b";
    std::cin >> height_inch;

    int weight_and_pounds = 0;
    std::cout << "Enter your weight in pounds: ___\b\b\b";
    std::cin >> weight_and_pounds;

    height_inch += height_foot * Foot_inch;

    double height_meters = height_inch * Inch_metr;

    double weight_in_kilograms = weight_and_pounds / kg_pound;

    double bmi = weight_in_kilograms / pow(height_meters, 2);

    std::cout << "BMI = " << bmi << std::endl;

    return 0;
}
显示结果如下
How many foot are in you: 5__
How many inches are in you: 6_
Enter your weight in pounds: 138
BMI = 22.320355

3.编写一个程序，要求用户以度、分、秒的方式输入一个纬度，然后以度为单位显示该纬度。
1度为60分，1分等于60秒，请以符号常量的方式表示这些值。对于每个输入值，应使用一个独立的变量存储它。
#include <iostream>
#include <cmath>

int main()
{
    std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);

    const double degree_minute = 60;
    const double degree_second = degree_minute * 60;

    std::cout << "Enter a latitude in degrees, minutes, and seconds: " << std::endl;

    std::cout << "First, enter the degrees:__\b\b ";
    int degrees = 0;
    std::cin >> degrees;

    std::cout << "Next, enter the minutes of arc:__\b\b ";
    int minutes = 0;
    std::cin >> minutes;

    std::cout << "Finally, enter the seconds of arc:__\b\b ";
    int seconds = 0;
    std::cin >> seconds;

    double Result = degrees + (minutes / degree_minute) + (seconds / degree_second);
    std::cout << degrees << " degrees, " << minutes << " minutes, " << seconds << " seconds = " << Result << " degrees\n";

    return 0;
}
显示结果如下
Enter a latitude in degrees, minutes, and seconds:
First, enter the degrees: 37
Next, enter the minutes of arc: 51
Finally, enter the seconds of arc: 19
37 degrees, 51 minutes, 19 seconds = 37.855278 degrees

4，编写一个程序，要求用户以整数方式输入秒数（使用long或long long变量存储），
然后以天、小时、分钟和秒的方式显示这段时间。
使用符号常量来表示每天存多少小时、每小时有多少分钟以及每分钟有多少秒。
#include <iostream>
#include <cmath>

int main()
{
    std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);

    const int Day = 24;
    const int Hour = 60;
    const int Minute = 60;

    long long int enter_seconds = 0;
    std::cout << "Enter the number of seconds: ________\b\b\b\b\b\b\b\b";
    std::cin >> enter_seconds;

    int seconds = (enter_seconds % Minute);
    int minutes = (enter_seconds / Minute) % Hour;
    int hours = ( enter_seconds / (Minute * Hour) ) % Day;
    int days = enter_seconds / (Minute * Hour * Day);

    std::cout << enter_seconds << " seconds = " << days << " days, " << hours << " hours, " << minutes << " minutes, ";
    std::cout << seconds << " seconds" << std::endl;

    return 0;
}
显示结果如下
Enter the number of seconds: 99999___
99999 seconds = 1 days, 3 hours, 46 minutes, 39 seconds

5.编写一个程序，要求用户输入全球当前的人口和美国当前的人口（或其他国家的人口），
将这些信息存储在long long变量中，并让程序显示美国（或其他国家）的人口占全球人口的百分比。
#include <iostream>
#include <cmath>

int main()
{
    std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);

    unsigned long long int world_population = 0;
    std::cout << "Enter the world's population: ___________\b\b\b\b\b\b\b\b\b\b\b";
    std::cin >> world_population;

    unsigned long long int population_country = 0;
    std::cout << "Enter the population of the country: ___________\b\b\b\b\b\b\b\b\b\b\b";
    std::cin >> population_country;

    double Result = double(population_country) / world_population * 100;
    std::cout << "The population of the country is " << Result << "% of the world population." << std::endl;

    return 0;
}
显示结果如下
Enter the world's population: 6898758899_
Enter the population of the country: 310783781__
The population of the country is 4.504923% of the world population.

6.编写一个程序，要求用户以公里为单位输入距离，并以升为单位输入汽油量，然后指出每100公里的耗油量（升）。
#include <iostream>
#include <cmath>

int main()
{
    std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);
    const int km_100 = 100;

    double kilometers = 0;
    std::cout << "Enter the distance in kilometers: ";
    std::cin >> kilometers;

    double litres = 0;
    std::cout << "Enter the amount of spent gasoline in litres: ";
    std::cin >> litres;

    double Result = ( (litres / kilometers) * km_100 );
    std::cout << "Fuel consumption: " << Result << " litres / 100km" << std::endl;

    return 0;
}
显示结果如下
Enter the distance in kilometers: 168
Enter the amount of spent gasoline in litres: 13.8
Fuel consumption: 8.214286 litres / 100km

7.编写一个程序，要求用户按欧洲风格输入汽车的耗油量（每100公里消耗的汽油量（升）），
然后将其转换为美国风格的耗油量，每加仑多少英里。
1英里等于1.609公里，1加仑等于3.785升。

(y 升/100公里) = 100  / ( (x 英里/加仑 ) * (1.609 / 3.785) )

(x 英里/加仑 ) = 100 / ( (y 升/100公里) * (1.609 / 3.785) )

#include <iostream>
#include <cmath>

int main()
{
    std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);
    const double mile_km = 1.609;
    const double gl_litr = 3.785;

    std::cout << "Enter the number of liters per 100 kilometers: ";
    double litr_100km = 0.0;
    std::cin >> litr_100km;

    double mile_gl = 100 / ( litr_100km * (mile_km / gl_litr) );

    std::cout << "Answer " << mile_gl << " Miles per gallon" << std::endl;

    return 0;
}
显示结果如下
Enter the number of liters per 100 kilometers: 14.7
Answer 16.002672 Miles per gallon

Enter the number of liters per 100 kilometers: 12.4
Answer 18.970910 Miles per gallon

Enter the number of liters per 100 kilometers: 8.7
Answer 27.038998 Miles per gallon

第4章复合类型
4.1 数组
4.1.1 程序说明
4.1.2 数组的初始化规则
4.1.3 C++11数组初始化方法
4.2 字符串
4.2.1 拼接字符串常量
4.2.2 在数组中使用字符串
4.2.3 字符串输入
4.2.4 每次读取一行字符串输入
4.2.5 混合输入字符串和数字
4.3 string类简介
4.3.1 C++11字符串初始化
4.3.2 赋值、拼接和附加
4.3.3 string类的其他操作
4.3.4 string类I/O
43.5 其他形式的字符串字面值
4.4 结构简介
4.4.1 在程序中使用结构
4.4.2 C++11结构初始化
4.4.3 结构可以将string类作为成员吗
4.4.4 其他结构属性
4.4.5 结构数组
4.4.6 结构中的位字段
4.5 共用体
4.6 枚举
4.6.1 设置枚举量的值
4.6.2 枚举的取值范围
4.7 指针和自由存储空间
4.7.1 声明和初始化指针
4.7.2 指针的危险
4.7.3 指针和数字
4.7.4 使用new来分配内存
4.7.5.使用delete释放内存
4.7.6 使用new来创建动态数组
4.8 指针、数组和指针算术
4.8.1 程序说明
4.8.2 指针小结
4.8.3 指针和字符串
4.8.4 使用new创建动态结构
4.8.5 自动存储、静态存储和动态存储
4.9 类型组合
4.10 数组的替代品
4.10.1 模板类vector
4.10.2 模板类array（C++11）
4.10.3 比较数组、vector对象和array对象
4.11 总结
4.12 复习题
4.13 编程练习
本章内容包括：
创建和使用数组。
创建和使用C风格字符串。
创建和使用string类字符串。
使用方法getline和get读取字符串。
混合输入字符串和数字。
创建和使用结构。
创建和使用共用体。
创建和使用枚举。
创建和使用指针。
使用new和delete管理动态内存。
创建动态数组。
创建动态结构。
自动存储、静态存储和动态存储。
vector和array类简介。
复合类型是基于基本整型和浮点类型创建的，包括类，数组，字符串，结构，联合。
4.1数组
数组（array）是一种数据格式，能够存储多个同类型的值。每个值都存储在一个独立的数组元素中，计算机在内存中依次存储数组的各个元素。
要创建数组，可使用声明语句。数组声明应指出以下三点：数组元素的类型，数组名，数组元素的个数。
在C++中，可以通过修改简单变量的声明，添加中括号（其中包含元素数目）来完成数组声明。
事实上，可以将数组中的每个元素看作是一个简单变量。
声明数组的通用格式如下：
typeName arrayName [arraysrze];
表达式 arraySize 指定元素数目，它必须是整型常数或const值，也可以是常量表达式。
具体地说，arraySize不能是变量，变量的值是在程序运行时设置的。
数组的很多用途都是基于这样一个事实：可以单独访问数组元素。方法是使用下标或索引来对元素进行编号。
C++数组从0开始编号，C++使用带索引的方括号来指定数组元素，最后一个元素的索引比数组长度小1（参见图4.1）。
编译器不会检查使用的下标是否有效。例如，如果将一个值赋给不存在的元素，编译器并不会指出错误。
但是程序运行后，这种赋值可能引发问题，它可能破坏数据或代码，也可能导致程序异常终止。
所以必须确保程序只使用有效的下标值。
程序清单4.1 arrayone.cpp
#include <iostream>

using namespace std;

int main()
{
    int yams[3];
    yams[0] = 7;
    yams[1] = 8;
    yams[2] = 6;

    int yamcosts[3] = { 20, 30, 5 };

    cout << "Total yams = " << yams[0] + yams[1] + yams[2] << endl;
    cout << "The package with " << yams[1] << " yams costs " << yams[1] * yamcosts[1] << " cents.\n";
    int total = yams[0] * yamcosts[0] + yams[1] * yamcosts[1] + yams[2] * yamcosts[2];
    cout << "The total yam expense is " << total << " cents. \n";

    cout << "\nSize of yams array = " << sizeof yams << " bytes.\n";
    cout << "Size of one element = " << sizeof yams[0] << " bytes.\n";

    return 0;
}
显示结果如下
Total yams = 21
The package with 8 yams costs 240 cents.
The total yam expense is 410 cents.

Size of yams array = 12 bytes.
Size of one element = 4 bytes.

如果将sizeof运算符用于数组名，得到的将是整个数组的长度（单位为字节）。
如果将sizeof用于某个数组元素，得到的将是这个元素的长度（单位为字节）。
4.1.2数组的初始化规则
C++有几条关于初始化数组的规则，决定了数组的元素数目与初始化器中值的数目不相同时将发生的情况。我们来看看这些规则。
只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组：
int cards[4] = {3, 6, 8, 10};   // okay
int han[4];   // okay
han[4] = {5, 6, 7, 9};   // not allowed
hand = cards;   // not allowed
然而，可以使用下标分别给数组中的元素赋值。
初始化数组时，提供的值可以少于数组的元素数目。例如，下面的语句只初始化hotelTips的前两个元素：
double hotelTips[5] = {5.0, 2.5};
如果只对数组的一部分进行初始化，则编译器将把其他元素设置为0。
因此，将数组中所有的元素都初始化为0非常简单，只要显式地将第一个元素初始化为0，
然后让编译器将其他元素都初始化为0即可：
long totals[500] = {0};
如果初始化为{1}而不是{0}，则第一个元素被设置为1，其他元素都被设置为0。
如果初始化数组时方括号内[]为空，C++编译器将计算元素个数。例如，对于下面的声明：
short things[] = {1, 5, 3, 8};
编译器将使things数组包含4个元素。
int num_elements = sizeof (things) / sizeof (short);
4.1.3 C++11数组初始化方法
第3章说过，C++11将使用大括号的初始化（列表初始化）作为一种通用初始化方式，可用于所有类型。
数组以前就可使用列表初始化，但C++11中的列表初始化新增了一些功能。
首先，初始化数组时，可省略等号（=）：
double earnings[4] {1.2e4, 1.6e4, 1.1e4, 1.7e4};   //okay with C++11
其次，可不在大括号内包含任何东西，这将把所有元素都设置为零：
unsigned int counts[10] = {};   // all elements set to 0
double balances[100] {};   // all elements set to 0
第三，列表初始化禁止缩窄转换，这在第3章介绍过：
long plifs[] = {25, 92, 3.0};   // not allowed
char slifs[4] {'h', 'i', 1122011,'\0'};   // not allowed
char tlifs[4] {'h', 'i', 112, '\0'};   // allowed
在上述代码中，第一条语句不能通过编译，因为将浮点数转换为整型是缩窄操作，即使浮点数的小数点后面为零。
第二条语句也不能通过编译，因为1122011超出了char变量的取值范围（这里假设char变量的长度为8位）。
第三条语句可通过编译，因为虽然112是一个int值，但它在char变量的取值范围内。
C++标准模板库（STL）提供了一种数组替代品――模板类vector，而C++11新增了模板类array。
这些替代品比内置复合类型数组更复杂、更灵活，本章将简要地讨论它们，而第16章将更详细地讨论它们。
4.2字符串
字符串是存储在内存的连续字节中的一系列字符。
C++处理字符串的方式有两种。第一种来自C语言，常被称为C风格字符串。
本章将首先介绍它，然后介绍另一种基于string类库的方法。
存储在连续字节中的一系列字符意味着可以将字符串存储在char数组中，其中每个字符都位于一个数组元素中。
字符串提供了一种存储文本信息的便捷方式，如提供给用户的消息或来自用户的响应。
C风格字符串具有一种特殊的性质：以空字符（null character）结尾，
空字符被写作'\0'，其ASCII码为0，用来标记字符串的结尾。空字符对C风格字符串而言至关重要。
例如，C++有很多处理字符串的函数，其中包括cout使用的那些函数。
它们都逐个地处理字符串中的字符，直到到达空字符为止。
有一种更好的、将字符数组初始化为字符串的方法――只需使用一个用引号括起的字符串即可，
这种字符串被称为字符串常量（string constant）或字符串字面值（string literal）。
用引号括起的字符串隐式地包括结尾的空字符，因此不用显式地包括它（参见图4.2）。
另外，各种C++输入工其通过键盘输入，将字符串读入到char数组中时，将自动加上结尾的空字符。
当然，应确保数组足够大，能够存储字符串中所有字符―包括空字符。
让数组比字符串长没有什么害处，只是会浪费一些空间而已。
这是因为处理字符串的函数根据空字符的位置，而不是数组长度来进行处理。C++对字符串长度没有限制。
在确定存储字符串所需的最短数组时，别忘了将结尾的空字符计算在内。
注意，字符串常量（使用双引号）不能与字符常量（使用单引号）互换。
4.2.1拼接字符串常量
有时候，字符串很长，无法放到一行中。C++允许拼接字符串字面值，即将两个用引号括起的字符串合并为一个。
事实上，任何两个由空白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个。
4.2.2在数组中使用字符串
要将字符串存储到数组中，最常用的方法有两种――将数组初始化为字符串常量、把键盘或文件输入读到字符数组中。
程序清单4.2演示了这两种方法，它将一个数组初始化为用引号括起的字符串，
并使用cin将一个输入字符串放到另一个数组中。该程序还使用了标准C语言库函数strlen来确定字符串的长度。
标准头文件cstring（老式实现为string.h）提供了该函数以及很多与字符串相关的其他函数的声明。
程序清单4.2 string.cpp
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    const int Size = 32;
    char name1[Size];
    char name2[Size] = "C++owboy";

    cout << "Howdy! I'm " << name2 << "! What's your name?\n";
    cin >> name1;
    cout << "Well, " << name1 << ", your name has "<< strlen(name1) << " letters and is stored\n";
    cout << "in an array of " << sizeof(name1) << " bytes. \n";
    cout << "Your initial is " << name1[0] << " . \n";
    name2[3] = '\0';
    cout << "Here are the first 3 characters of my name: " << name2 << endl;

    return 0;
}
显示结果如下
Howdy! I'm C++owboy! What's your name?
Peter
Well, Peter, your name has 5 letters and is stored
in an array of 32 bytes.
Your initial is P .
Here are the first 3 characters of my name: C++

4.2.3字符串输入
程序string.cpp有一个缺陷，这种缺陷通过精心选择输入被掩盖掉了。
程序清单4.3揭开了它的面纱，揭示了字符串输入的技巧。
程序清单4.3instr1.cpp
#include <iostream>

using namespace std;

int main()
{
    const int ArSize = 32;
    char name[ArSize];
    char dessert[ArSize];
    cout << "Enter your name:\n";
    cin >> name;
    cout << "Enter your favorite dessert:\n";
    cin >> dessert;
    cout << "I have some delicious " << dessert << " for you, " << name << " .\n";

    return 0;
}
显示结果如下
Enter your name:
Peter Smith
Enter your favorite dessert:
I have some delicious Smith for you, Peter .

4.2.4每次读取一行字符 串输入
每次读取一个单词通常不是最好的选择。例如，假设程序要求用户输入城市名，用户输入New York或Sao Paulo。
您希望程序读取并存储完整的城市名，而不仅仅是New或Sao。
要将整条短语而不是一个单词作为字符串输入，需要采用另一种字符串读取方法。
具体地说，需要采用面向行而不是面向单词的方法。
幸运的是，istream 中的类（如cin）提供了一些面向行的类成员函数：getline和get。
getline函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。
要调用这种方法，可以使用cin.getline。该函数有两个参数。
第一个参数是用来存储输入行的数组的名称，第二个参数是要读取的字符数。
如果这个参数为20，则函数最多读取19个字符，余下的空间用于存储自动在结尾处添加的空字符。
getline成员函数在读取指定数目的字符或遇到换行符时停止读取。
例如，假设要使用getine将姓名读入到一个包含20个元素的name数组中。可以使用这样的函数调用：
cin.getline (name, 20);
getine成员函数还可以接受第三个可选参数，这将在第17章讨论。
程序清单4.4将程序清单4.3修改为使用cin.getine，而不是简单的cin。除此之外，该程序没有做其他修改。
程序清单4.4 instr2.cpp
#include <iostream>

using namespace std;

int main()
{
    const int ArSize = 32;
    char name[ArSize];
    char dessert[ArSize];
    cout << "Enter your name:\n";
    cin.getline(name, ArSize);
    cout << "Enter your favorite dessert:\n";
    cin.getline(dessert, ArSize);
    cout << "I have some delicious " << dessert << " for you, " << name << " .\n";

    return 0;
}
显示结果如下
Enter your name:
Peter Smith
Enter your favorite dessert:
Apple
I have some delicious Apple for you, Peter Smith .

istream类有另一个名为get的成员函数，该函数有几种变体。
其中一种变体的工作方式与getline类似，它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。
但get并不丢弃读取的换行符，而是将其留在输入队列中。假设我们连续两次调用get：
    cout << "Enter your name:\n";
    cin.get(name, ArSize);
    cout << "Enter your favorite dessert:\n";
    cin.get(dessert, ArSize);
由于第一次调用后，换行符将留在输入队列中，因此第二次调用时看到的第一个字符便是换行符。
因此get认为已到达行尾，而没有发现任何可读取的内容。
幸运的是，get有另一种变体。使用不带任何参数的cin.get调用可读取下一个字符（即使是换行符），
因此可以用它来处理换行符，为读取下一行输入做好准备。也就是说，可以采用下面的调用序列：
    cout << "Enter your name:\n";
    cin.get(name, ArSize);
    cin.get();
    cout << "Enter your favorite dessert:\n";
    cin.get(dessert, ArSize);
    cin.get();
另一种使用get的方式是将两个类成员函数拼接起来（合并），如下所示：
cin.get(name, Arsize).get();
之所以可以这样做，是由于cin.get(name, ArSize)返回一个cin对象，该对象随后将被用来调用get函数。
同样，下面的语句将把输入中连续的两行分别读入到数组name1和name2中，其效果与两次调用cin.getline相同：
cin.getline (name1, Arsize).getline (name2, ArSize);
程序清单4.5采用了拼接方式。第11章将介绍如何在类定义中使用这项特性。
程序清单4.5 instr3.cpp
#include <iostream>

using namespace std;

int main()
{
    const int ArSize = 32;
    char name[ArSize];
    char dessert[ArSize];

    cout << "Enter your name:\n";
    cin.get(name, ArSize).get();
    cout << "Enter your favorite dessert:\n";
    cin.get(dessert, ArSize).get();
    cout << "I have some delicious " << dessert << " for you, " << name << " .\n";

    return 0;
}
显示结果如下
Enter your name:
Peter Smith
Enter your favorite dessert:
Orange
I have some delicious Orange for you, Peter Smith .

需要指出的一点是，C++允许函数有多个版本，条件是这些版本的参数列表不同。
如果使用的是cin.get (name, ArSize)，则编译器知道是要将一个字符串放入数组中，因而将使用适当的成员函数。
如果使用的是cin.get()，则编译器知道是要读取一个字符。第8章将探索这种特性――函数重载。
为什么要使用get，而不是getline呢？首先，老式实现没有getline。其次，get使输入更仔细。
例如，假设用get将一行读入数组中。如何知道停止读取的原因是由于已经读取了整行，而不是由于数组已填满呢？
查看下一个输入字符，如果是换行符，说明已读取了整行；否则，说明该行中还有其他输入。
第17章将介绍这种技术。总之，getline使用起来简单一些，但get使得检查错误更简单些。
可以用其中的任何一个来读取一行输入；只是应该知道，它们的行为稍有不同。
空行和其他问题
当getline或get读取空行时，将发生什么情况？最初的做法是，下一条输入语句将在前一条getline或get结束读取的位置开始读取；
但当前的做法是，当get（不是getline）读取空行后将设置失效位（failbit），这意味着接下来的输入将被阻断，但可以用下面的命令来恢复输入：cin.clear();
另一个潜在的问题是，输入字符串可能比分配的空间长。
如果输入行包含的字符数比指定的多，则getline和get将把余下的字符留在输入队列中，而getline还会设置失效位，并关闭后面的输入。
第5、6章和第17章将介绍这些属性，并探讨程序如何避免这些问题。
4.2.5 混合输入字符串和数字
混合输入数字和面向行的字符串会导致问题。请看程序清单4.6中的简单程序。
程序清单4.6 numstr.cpp
#include <iostream>

using namespace std;

int main()
{
    cout << "What year was your house built?\n";
    int year;
    cin >> year;
    cin.get();
    cout << "What is its street address?\n";
    char address[80];
    cin.getline(address, 80);
    cout << "Year built: " << year << endl;
    cout << "Address: " << address << endl;
    cout << "Done!\n";

    return 0;
}
显示结果如下
What year was your house built?
1999
What is its street address?
JiangXi
Year built: 1999
Address: JiangXi
Done!

C++程序常使用指针（而不是数组）来处理字符串。我们将在介绍指针后，再介绍字符串这个方面的特性。
4.3 string类简介
ISO/ANSI C++98标准通过添加string类扩展了C库，因此现在可以string类型的变量（使用C++的话说是对象）而不是字符数组来存储字符串。
要使用string类，必须在程序中包含头文件string。string类位于名称空间std中，因此您必须提供一条using编译指令，或者使用std:string来引用它。
string类定义隐藏了字符串的数组性质，让您能够像处理普通变量那样处理字符串。程序清单4.7说明了string对象与字符数组之间的一些相同点和不同点。
程序清单4.7 strtype1.cpp
#include <iostream>
#include <string>

using namespace std;

int main()
{
    char charr1[32];
    char charr2[32] = "jaguar";
    string str1;
    string str2 = "panther";

    cout << "Enter a kind of feline: ";
    cin >> charr1;
    cin.get();
    cout << "Enter another kind of feline: ";
    cin >> str1;
    cin.get();
    cout << "Here are some felines:\n";
    cout << charr1 << " " << charr2 << " " << str1 << " " << str2 << endl;
    cout << "The third letter in " << charr2 << " is " << charr2[2] << endl;
    cout << "The third letter in " << str2 << " is " << str2[2] << endl;

    return 0;
}
显示结果如下
Enter a kind of feline: ocelot
Enter another kind of feline: tiger
Here are some felines:
ocelot jaguar tiger panther
The third letter in jaguar is g
The third letter in panther is n

从这个示例可知，，在很多方面，使用string对象的方式与使用字符数组相同。
可以使用C风格字符串来初始化string对象。
可以使用cin来将键盘输入存储到string对象中
可以使用cout来显示string对象
可以使用数组表示法来访问存储在string对象中的字符
string对象和字符数组之间的主要区别是，可以将string对象声明为简单变量，而不是数组。
从理论上说，可以将char数组视为一组用于存储一个字符串的char存储单元，而string类变量是一个表示字符串的实体。
4.3.1 C++11字符串初始化
正如您预期的，C++11也允许将列表初始化用于C风格字符串和string对象：
char first_date[] = {"Le Chapon Dodu"};
char second_date {"The Elegant Plate"};

string third_date = {"The Bread Bowl"};
string fourth_date {"Hank's Fine Eats"}
4.3.2 赋值、拼接和附加
使用string类时，某些操作比使用数组时更简单。
例如，不能将一个数组赋给另一个数组，但可以将string对象赋给另一个string对象。
string类简化了字符串合并操作。可以使用运算符+将两个string对象合并起来，
还可以使用运算符 +=将字符串附加到string对象的末尾。
程序清单4.8演示了这些用法。可以将C风格字符串或string对象与string对象相加，或将它们附加到string对象的末尾。
程序清单4.8 strtype2.cpp
#include <iostream>
#include <string>

using namespace std;

int main()
{
    string s1 = "penguin";
    string s2, s3;

    cout << "You can assign one string object to another: s2 = s1\n";
    s2 = s1;
    cout << "s1: " << s1 << ", s2: " << s2 << endl;

    cout << "You can assign a C-style string to a string object.\n";
    cout << "s2 = \"buzzard\"\n";
    s2 = "buzzard";
    cout << "s2: " << s2 << endl;

    cout << "You can concatenate strings: s3 = s1 + s2\n";
    s3 = s1 + s2;
    cout << "s3: " << s3 << endl;

    cout << "You can append strings. \n";
    s1 += s2;
    cout << "s1 += s2 yields s1 = " << s1 << endl;
    s2 += " for a day";
    cout << "s2 += \" for a day\" yields s2 = " << s2 << endl;

    return 0;
}
显示结果如下
You can assign one string object to another: s2 = s1
s1: penguin, s2: penguin
You can assign a C-style string to a string object.
s2 = "buzzard"
s2: buzzard
You can concatenate strings: s3 = s1 + s2
s3: penguinbuzzard
You can append strings.
s1 += s2 yields s1 = penguinbuzzard
s2 += " for a day" yields s2 = buzzard for a day

4.3.3 string类的其他操作
在C++新增string类之前，程序员也需要完成诸如给字符串赋值等工作。
对于C风格字符串，程序员使用C语言库中的函数来完成这些任务，头文件cstring（以前为string.h），提供了这些函数。
例如，可以使用函数strcpy将字符串复制到字符数组中，使用函数strcat将字符串附加到字符数组末尾。
strcpy(charr1, charr2);
strcat(charr1, charr2);
程序清单4.9对用于string对象的技术和用于字符数组的技术进行了比较
程序清单4.9 strtype3.cpp
#include <iostream>
#include <string>
#include <cstring>

using namespace std;

int main()
{
    char charr1[32];
    char charr2[32] = "jaguar";
    string str1;
    string str2 = "panther";

    str1 = str2;
    strcpy(charr1, charr2);

    str1 += " paste";
    strcat(charr1, " juice");

    int len1 = str1.size();
    int len2 = strlen(charr1);

    cout << "The string " << str1 << " contains " << len1 << " characters. \n";
    cout << "The string " << charr1 << " contains " << len2 << " characters. \n";

    return 0;
}
显示结果如下
The string panther paste contains 13 characters.
The string jaguar juice contains 12 characters.

4.3.4 string类I/O
正如您知道的，可以使用cin和运算符>>来将输入存储到string对象中，使用cout和运算符<<来显示string对象，
其句法与处理C风格字符串相同。但每次读取一行而不是一个单词时，使用的句法不同，程序清单4.10说明了这一点。
程序清单4.10 strtype4.cpp
#include <iostream>
#include <string>
#include <cstring>

using namespace std;

int main()
{
    char charr[32] = {0};
    string str;

    cout << "Length of string in charr before input: " << strlen(charr) << endl;

    cout << "Length of string in str before input: " << str.size() << endl;

    cout << "Enter a line of text:\n";
    cin.getline(charr, 32);
    cout << "You entered: " << charr << endl;

    cout << "Enter another line of text:\n";
    getline(cin, str);
    cout << "You entered: " << str << endl;

    cout << "Length of string in charr after input: " << strlen(charr) << endl;
    cout << "Length of string in str after input: " << str.size() << endl;

    return 0;
}
显示结果如下
Length of string in charr before input: 0
Length of string in str before input: 0
Enter a line of text:
Peter Smith
You entered: Peter Smith
Enter another line of text:
Hello World
You entered: Hello World
Length of string in charr after input: 11
Length of string in str after input: 11

4.3.5 其他形式的字符串字面值
本书前面说过，除char类型外，C++还有类型wchar_t，而C++11新增了类型 char16_t和char32_t。
可创建这些类型的数组和这些类型的字符串字面值。对于这些类型的字符串字面值，C++分别使用前缀L、u和U表示，下面是一个如何使用这些前缀的例子：
wchar_t title[] = L"Chief Astrogator";
char16_t name[] = u"Felonia Ripova";
char32_t car[] = U"Humber Super Snipe";
C++11还支持Unicode字符编码方案UTF-8，C++使用前缀u8来表示这种类型的字符串字面值。
C++11新增的另一种类型是原始（raw）字符串。
在原始字符串中，字符表示的就是自己，例如，序列\n不表示换行符，而表示两个常规字符一一斜杠和n，
因此在屏幕上显示时，将显示这两个字符。另一个例子是，可在字符串中使用"，而无需像程序清单4.8中那样使用繁琐的\"。
当然，既然可在字符串字面量包含"，就不能再使用它来表示字符串的开头和末尾。
因此，原始字符串将 ( 和 ) 用作定界符，并使用前缀R来标识原始字符串：
cout << R"(Jim "King" Tutt uses "\n" instead of end.)" <<'\n';
上述代码将显示如下内容：
Jim "King" Tutt uses\n instead of endl.
如果使用标准字符串字面值，将需编写如下代码：
cout << "Jim \"King\" Tutt uses \"\\n\" instead of endl." << '\n';
在上述代码中，使用了\\来显示\，因为单个\表示转义序列的第一个字符。
输入原始字符串时，按回车键不仅会移到下一行，还将在原始字符串中添加回车字符。
如果要在原始字符串中包含 ) ，该如何办呢？编译器见到第一个 ) 时，会不会认为字符串到此结束？会的。
但原始字符串语法允许您在表示字符串开头的"和(之间添加其他字符，
这意味着表示字符串结尾的"和)之间也必须包含这些字符。
因此，使用R"+*(标识原始字符串的开头时，必须使用)+*"标识原始字符串的结尾。因此，下面的语句：
cout << R"+*("(Who wouldn't?)", she whispered.)+*" << endl;
将显示如下内容：
"(Who wouldn't?)", she whispered.
总之，这相当于使用 +*( 和 )+* 替代了默认定界符 ( 和 ) 。
自定义定界符时，可在默认定界符之间添加任意数量的基本字符，
但空格、左括号、右括号、斜杠和控制字符（如制表符和换行符）除外。
可将前缀R与其他字符串前缀结合使用，以标识wchar_t等类型的原始字符串。
可将R放在前面，也可将其放在后面，如Ru、UR等。
4.4结构简介
假设要存储有关篮球运动员的信息，则可能需要存储他（她）的姓名、工资、身高、体重、平均得分、命中率、助攻次数等。
希望有一种数据格式可以将所有这些信息存储在一个单元中。
数组不能完成这项任务，因为虽然数组可以存储多个元素，但所有元素的类型必须相同。
C++中的结构的可以满足要求（存储篮球运动员的信息）。
结构是一种比数组更灵活的数据格式，因为同一个结构可以存储多种类型的数据，
这使得能够将有关篮球运动员的信息放在一个结构中，从而将数据的表示合并到一起。
如果要跟踪整个球队，则可以使用结构数组。
结构是用户定义的类型，而结构声明定义了这种类型的数据属性。定义了类型后，便可以创建这种类型的变量。
因此创建结构包括两步。首先，定义结构描述――它描述并标记了能够存储在结构中的各种数据类型。
然后按描述创建结构变量（结构数据对象）。
例如，假设Bloataire公司要创建一种类型来描述其生产线上充气产品的成员。
具体地说，这种类型应存储产品名称、容量（单位为立方英尺）和售价。下面的结构描述能够满足这些要求：
struct inflatable
{
    char name[32];
    double volume;
    double price;
};

关键字struct表明，这些代码定义的是一个结构的布局。标识符inflatable是这种数据格式的名称，
因此新类型的名称为inflatable。这样，便可以像创建char或int类型的变量那样创建inflatable类型的变量了。
接下来的大括号中包含的是结构存储的数据类型的列表，其中每个列表项都是一条声明语句。
这个例子使用了一个适合用于存储字符串的char数组、一个double和一个double。
列表中的每一项都被称为结构成员，因此infatable结构有3个成员（参见图4.6）。
总之，结构定义指出了新类型（这里是inflatable）的特征。定义结构后，便可以创建这种类型的变量了：
inflatable hat;
inflatable woopie_cushion;
inflatable mainframe;
如果您熟悉C语言中的结构，则可能已经注意到了，C++允许在声明结构变量时省略关键字struct：
struct inflatable goose;
inflatable vincent;
在C++中，结构标记的用法与基本类型名相同。这种变化强调的是，结构声明定义了一种新类型。
可以使用成员运算符（.）和成员名访问结构的成员，每个成员都是一个对应类型的变量。
顺便说一句，访问类成员函数的方式是从访问结构成员变量的方式衍生而来的。
4.4.1在程序中使用结构
介绍结构的主要特征后，下面在一个使用结构的程序中使用这些概念。
程序清单4.11说明了有关结构的这些问题，还演示了如何初始化结构。
程序清单4.11 structur.cpp
#include <iostream>

using namespace std;

struct inflatable
{
    char name[32];
    double volume;
    double price;
};

int main()
{
    inflatable guest =
    {
        "Glorious Gloria",
        1.88,
        29.99
    };

    inflatable pal =
    {
        "Audacious Arthur",
        3.12,
        32.99
    };

    cout << "Expand your guest list with " << guest.name << " and " << pal.name << "!\n";
    cout << "You can have both for $" << guest.price + pal.price << "!\n";

    return 0;
}
显示结果如下
Expand your guest list with Glorious Gloria and Audacious Arthur!
You can have both for $62.98!

结构声明的位置很重要。位于函数外面的声明被称为外部声明，可以被其后面的任何函数使用；
位于函数内部的声明被称为内部声明，只能被该声明所属的函数使用。
通常应使用外部声明，这样所有函数都可以使用这种类型的结构（参见图4.7）。
变量也可以在函数内部和外部定义，外部变量由所有的函数共享（这将在第9章做更详细的介绍）。
C++不提倡使用外部变量，但提倡使用外部结构声明。另外，在外部声明符号常量通常更合理。
4.4.2-C++11结构初始化
与数组一样，C++11也支持将列表初始化用于结构，且等号（=）是可选的：
inflatable duck {"Daphne", 0.12, 9.98};
其次，如果大括号内未包含任何东西，各个成员都将被设置为零。
例如，下面的声明导致mayor.volume和mayor.price被设置为零，且mayor.name的每个字节都被设置为零：
inflatable mayor {};
最后，不允许缩窄转换。
4.4.3 结构可以将string类作为成员吗
只要您使用的编译器支持对以string对象作为成员的结构进行初始化。
可以将编译指令using移到结构定义之前，也可以将name的类型声明为std:string。
4.4.4其他结构属性
C++使用户定义的类型与内置类型尽可能相似。例如，可以将结构作为参数传递给函数，也可以让函数返回一个结构。
另外，还可以使用赋值运算符（=）将结构赋给另一个同类型的结构，
这样结构中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组。
这种赋值被称为成员赋值，将在第7章讨论函数时再介绍如何传递和返回结构。
下面简要地介绍一下结构赋值，程序清单4.12是一个这样的示例。
程序清单4.12 assgn_st.cpp：
#include <iostream>

using namespace std;

struct inflatable
{
    char name[32];
    double volume;
    double price;
};

int main()
{
    inflatable bouquet =
    {
        "sunflowers",
        0.20,
        12.49
    };

    inflatable choice;
    cout << "bouquet: " << bouquet.name << " for $" << bouquet.price << endl;
    choice = bouquet;
    cout << "choice: " << choice.name << " for $" << choice.price << endl;

    return 0;
}
显示结果如下
bouquet: sunflowers for $12.49
choice: sunflowers for $12.49

从中可以看出，成员赋值是有效的，因为choice结构的成员值与bouquet结构中存储的值相同。
可以同时完成定义结构和创建结构变量的工作。为此，只需将变量名放在结束括号的后面即可，
甚至可以初始化以这种方式创建的变量。然而，将结构定义和变量声明分开，可以使程序更易于阅读和理解。
还可以声明没有名称的结构类型，方法是省略名称。可以使用成员运算符来访问它的成员（如position.x），
但这种类型没有名称，因此以后无法创建这种类型的变量。本书将不使用这种形式的结构。
4.4.5 结构数组
inflatable结构包含一个数组（name），也可以创建元素为结构的数组，方法和创建基本类型数组完全相同。
例如，要创建一个包含100个inflatable结构的数组，可以这样做：
inflatable gifts[100];
这样，gifts将是一个inflatable数组，其中的每个元素都是inflatable对象，可以与成员运算符一起使用。
记住，gifts本身是一个数组，而不是结构，因此像gifts.price这样的表述是无效的。
要初始化结构数组，可以结合使用初始化数组的规则（用逗号分隔每个元素的值，并将这些值用花括号括起）和
初始化结构的规则（用逗号分隔每个成员的值，并将这些值用花括号括起）。
因此，最终结果为一个被括在花括号中、用逗号分隔的值列表，
其中每个值本身又是一个被括在花括号中、用逗号分隔的值列表：
inflatable guests[2] = 
{
    {"Bambi", 0.5, 21.99}, 
    {"Godzilla", 2000, 565.99}
};
程序清单4.13是一个使用结构数组的简短示例。
由于guests是一个inflatable数组，因此guests[0]的类型为inflatable，
可以使用它和句点运算符来访问相应inflatable结构的成员
程序清单4.13 arrstruc.cpp
#include <iostream>

using namespace std;

struct inflatable
{
    char name[32];
    double volume;
    double price;
};

int main()
{
    inflatable guests[2] =
    {
        { "Bambi", 0.5, 21.99 },
        { "Godzilla", 2000, 565.99 }
    };
    cout << "The guests " << guests[0].name << " and " << guests[1].name << "\n";
    cout << "have a combined volume of " << guests[0].volume + guests[1].volume << " cubic feet.\n";

    return 0;
}
显示结果如下
The guests Bambi and Godzilla
have a combined volume of 2000.5 cubic feet.

4.4.6 结构中的位字段
与C语言一样，C++也允许指定占用特定位数的结构成员，这使得创建与某个硬件设备上的寄存器对应的数据结构非常方便。
字段的类型应为整型或枚举（稍后将介绍），接下来是冒号，冒号后面是一个数字，它指定了使用的位数。
可以使用没有名称的字段来提供间距。每个成员都被称为位字段（bit field），下面是一个例子：
struct torgle_register
{
    unsigned int SN : 4;
    unsigned int : 4;
    bool goodIn : 1;
    bool goodTorgle : 1;
};
可以像通常那样初始化这些字段，还可以使用标准的结构表示法来访问位字段
torgle_register tr = {14, true, false};

if (tr.goodIn)
{
    // ...
}
位字段通常用在低级编程中，一般来说，可以使用整型和附录E介绍的按位运算符来代替这种方式。
4.5 联合
联合（union）是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。
也就是说，结构可以同时存储int、long和double，但联合每次只能存储其中的一种类型。
联合的语法与结构相似，但含义不同。例如，请看下面的声明：
union one4all
{
    int int_val;
    long long_val;
    double double_val;
};
可以使用one4all变量来存储int，long或double，条件是在不同的时间进行：
one4all pail;

pail.int_val=15;
cout << pail.int val << '\n';
pail.double_val = 1.38;
cout << pail.double_val << '\n';
由于联合每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，所以，联合的长度为其最大成员的长度。
联合的用途之一是，当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。
例如，假设管理一个小商品目录，其中有一些商品的ID为整数，而另一些的ID为字符，在这种情况下，可以这样做；
struct widget
{
    char brand[32];
    int type;
    union id
    {
        long id_num;
        char id_char[20];
    } id_val;
};

widget prize;
if (prize.type == 1)
{
    cin >> prize.id_val.id_num;
}
else
{
    cin >> prize.id_val.id_char;
}
匿名联合（anonymous union）没有名称，其成员将成为位于相同地址处的变量，
显然，每次只有一个成员是当前的成员。
struct widget
{
    char brand[32];
    int type;
    union 
    {
        long id_num;
        char id_char[20];
    };
};
id_num和id_char被视为prize的两个成员，它们的地址相同，所以不需要中间标识符id_val。
4.6 枚举
C++的enum提供了另一种创建符号常量的方式，这种方式可以代替const，它还允许定义新类型但必须按严格的限制进行。
使用enum的句法与使用结构相似。例如，请着下面的语句
enum spectrum { red, orange, yellow, green, blue, violet, indigo, ultraviolet};
这条语句完成两项工作
让spectrum成为新类型的名称；spectrum被称为枚举（enumeration），就像struct变量被称为结构一样。
将red，orange，yellow等作为符号常量，它们对应整数值0~7，这些常量叫作枚举量（enumerator）。
在默认情况下，将整数值赋给枚举量，第一个枚举量的值为0，第二个枚举量的值为1，依次类推。
可以通过显式地指定整数值来覆盖默认值，本章后面将介绍如何做。
可以用枚举名来声明这种类型的变量：
spectrum band;
枚举变量具有一些特殊的属性，下面来看一看。
在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举的变量，如下所示：
band = blue;   // valid, blue is an enumerator
band = 2000;   // invalid, 2000 not an enumerator
因此，spectrum变量受到限制，只有8个可能的值。
如果试图将一个非法值赋给它，则有些编译器将出现编译器错误，而另一些则发出警告。
对于枚举，只定义了赋值运算符。具体地说，没有为枚举定义算术运算：
band =orange;   // valid
++band;   //not valid
band = orange + red;   //not valid
枚举量是整型，可被提升为int类型，但int类型不能自动转换为枚举类型：
int color = blue;   //valid，spectrum type promoted to int
band =3;   //invalid, int not converted to spectrum
color = 3+ red;   //valid，red converted to int
用于算术表达式中时，枚举将被转换为整数，因此表达式orange + red将被转换为1+0，
这是一个合法的表达式，但其类型为int，不能将其赋给类型为spectrum的变量band。
如果int值是有效的，则可以通过强制类型转换，将它赋给枚举变量：
band = spectrum (3);
如果试图对一个不适当的值进行强制类型转换，将出现什么情况呢？
结果是不确定的，这意味着这样做不会出错，但不能依赖得到的结果：
band = spectrum (40003);   //undefined
请参阅本章后面的“枚举的取值范围”一节，以了解一下哪些值合适，哪些值不合适。
正如您看到的那样，枚举的规则相当严格。实际上，枚举更常被用来定义相关的符号常量，而不是新类型。
例如，可以用枚举来定义switch语句中使用的符号常量（有关示例见第6章）。
如果打算只使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称，如下面的例子所示：
enum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};
4.6.1 设置枚举量的值
可以使用赋值运算符来显式地设置枚举量的值
enum bits {one =1, two = 2, four = 4, eight = 8};
指定的值必须是整数。也可以只显式地定义其中一些枚举量的值：
enum bigstep {first, second = 100, third};
这里，first在默认情况下为0，后面没有被初始化的枚举量的值将比其前面的枚举量大1。因此，third的值为101。
最后，可以创建多个值相同的枚举量：
enum {zero, null = 0, one, numero_uno =1};
其中，zero和null都为0，one和numero_uno都为1。
在C++早期的版本中，只能将int值（或提升为int的值）赋给枚举量，但这种限制取消了，
因此可以使用long甚至long long类型的值
4.6.2枚举的取值范围
最初，对于枚举来说，只有声明中指出的那些值是有效的。
然而，C++现在通过强制类型转换，增加了可赋给枚举变量的合法值。
每个枚举都有取值范围（range），通过强制类型转换，可以将取值范围中的任何整数值赋给枚举变量，
即使这个值不是枚举值。例如，假设bits和myflag的定义如下：
enum bits {one = 1, two = 2, four = 4, eight =8};
bits myflag;
则下面的代码将是合法的
myflag = bits (6);   //valid, because 6 is in bits range
其中6不是枚举值，但它位于枚举定义的取值范围内。
取值范围的定义如下。首先，要找出上限，需要知道枚举量的最大值。
找到大于这个最大值的、最小的2的幂，将它减去1，得到的便是取值范围的上限。
例如，前面定义的bigstep的最大值枚举值是101。在2的幂中，比这个数大的最小值为128，因此取值范围的上限为127。
要计算下限，需要知道枚举量的最小值。如果它不小于0，则取值范围的下限为0；
否则，采用与寻找上限方式相同的方式，但加上负号。
例如，如果最小的枚举量为-6，而比它小的、最大的2的幂是-8（加上负号），因此下限为-7。
选择用多少空间来存储枚举由编译器决定。
对于取值范围较小的枚举，使用一个字节或更少的空间而对于包含long类型值的枚举，则使用4个字节。
C++11扩展了枚举，增加了作用域内枚举（scoped enumeration），第10章的“类作用域”一节将简要地介绍这种枚举。
4.7 指针和自由存储空间
在第3章的开头，提到了计算机程序在存储数据时必须跟踪的3种基本属性。为了方便，这里再次列一出了这些属性：
信息存储在何处
存储的值为多少
存储的信息是什么类型。
您使用过一种策略来达到上述目的：定义一个简单变量。
声明语句指出了值的类型和符号名，还让程序为值分配内存，并在内部跟踪该内存单元。
下面来看一看另一种策略，它在开发C++类时非常重要。
这种策略以指针为基础，指针是一个变量，其存储的是变量的地址，而不是变量的值。
在讨论指针之前，我们先看一看如何找到常规变量的地址。只需对变量应用地址运算符（&），就可以获得它的地址；
例如，如果home是一个变量，则&home是它的地址。
程序清单4.14演示了这个运算符的用法。
程序清单4.14 address.cpp
#include <iostream>

using namespace std;

int main()
{
    int donuts = 6;
    double cups = 4.5;
    cout << "donuts value = " << donuts << " and donuts address = " << &donuts << endl;
    cout << "cups value = " << cups << " and cups address = " << &cups << endl;

    return 0;
}
显示结果如下
donuts value = 6 and donuts address = 0x7ffe7b53c5fc
cups value = 4.5 and cups address = 0x7ffe7b53c600

指针与C++基本原理
面向对象编程与传统的过程性编程的区别在于，OOP强调的是在运行阶段（而不是编译阶段）进行决策。
运行阶段指的是程序正在运行时，编译阶段指的是编译器将程序组合起来时。
运行阶段决策提供了灵活性，可以根据当时的情况进行调整。
例如，考虑为数组分配内存的情况。传统的方法是声明一个数组。要在C++中声明数组，必须指定数组的长度。
因此，数组长度在程序编译时就设定好了；这就是编译阶段决策。
OOP通过将这样的决策推迟到运行阶段进行，使程序更灵活。
总之，使用OOP时，您可以在运行阶段确定数组的长度。为使用这种方法，语言必须允许在程序运行时创建数组。
稍后您看会到，C++采用的方法是，使用关键字new请求正确数量的内存以及使用指针来跟踪新分配的内存的位置。
指针用于存储变量的地址，将*运算符应用于指针，可以得到该地址处对应变量的值。
程序清单4.15说明了这几点，它还演示了如何声明指针。
程序清单4.15 pointer.cpp
#include <iostream>

using namespace std;

int main()
{
    int updates = 6;
    int *p_updates;
    p_updates = &updates;

    cout << "Values: updates = " << updates << ", *p_updates = " << *p_updates << endl;

    cout << "Addresses: &updates = " << &updates << ", p_updates = " << p_updates << endl;

    *p_updates = *p_updates + 1;
    cout << "Now updates = " << updates << endl;

    return 0;
}
显示结果如下
Values: updates = 6, *p_updates = 6
Addresses: &updates = 0x7ffe46351dbc, p_updates = 0x7ffe46351dbc
Now updates = 7

4.7.1 声明和初始化指针
*运算符两边的空格是可选的，下面的声明创建一个指针（p1）和一个int变量（p2）：
int * p1, p2;
对每个指针变量名，都需要使用一个*。
指针变量不仅仅是指针，而且是指向特定类型的指针。和数组一样，指针都是基于其他类型的。
可以在声明语句中初始化指针。在这种情况下，被初始化的是指针，而不是它指向的值。
程序清单4.16演示了如何将指针初始化为一个地址。
程序清单4.16 init_ptr.cpp
#include <iostream>

using namespace std;

int main()
{
    int higgens = 5;
    int *pt = &higgens;
    cout << "Value of higgens = " << higgens << ", Address of higgens = " << &higgens << endl;
    cout << "Value of *pt = " << *pt << ", Value of pt = " << pt << endl;


    return 0;
}
显示结果如下
Value of higgens = 5, Address of higgens = 0x7ffd4042832c
Value of *pt = 5, Value of pt = 0x7ffd4042832c

4.7.2 指针的危险
在C++中创建指针时，计算机将分配内存给用来存储地址的指针变量，不会分配内存来存储指针所指向的数据。
一定要在对指针应用解除引用运算符（*）之前，将指针初始化为一个确定的、适当的地址。
4.73 指针和数字
指针与整数是截然不同的类型。整数是可以执行加、减、除等运算的数字，而指针描述的是位置，将两个地址相乘没有任何意义。
从可以对整数和指针执行的操作上看，它们也是彼此不同的。
因此，不能简单地将整数赋给指针，要将数字值作为地址来使用，应通过强制类型转换将数字转换为适当的地址类型。
int *pt;
pt = (int *) 0xB8000000;
4.7.4 使用new来分配内存
对指针的工作方式有一定了解后，来看看它如何实现在程序运行时分配内存。
前面我们都将指针初始化为变量的地址；变量是在编译时分配的有名称的内存，
而指针只是为可以通过名称直接访问的内存提供了一个别名。
指针真正的用武之地在于，在运行阶段分配未命名的内存以存储值。
在这种情况下，只能通过指针来访问内存。在C语言中，可以用库函数malloc来分配内存；
在C++中仍然可以这样做，但C++还有更好的方法――使用new运算符。
程序员要告诉new，需要为哪种数据类型分配内存；new将找到一个长度正确的内存块，并返回该内存块的地址。
为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配内存的通用格式如下
typeName * pointer_name = new typeName;
需要在两个地方指定数据类型：用来指定需要什么样的内存和用来声明合适的指针。
当然，如果已经声明了相应类型的指针，则可以使用该指针，而不用再声明一个新的指针。
程序清单4.17演示了如何将new用于两种不同的类型。
程序清单4.17 use_new.cpp
#include <iostream>

using namespace std;

int main()
{
    int nights = 1001;
    int *pt = new int;
    *pt = 1001;
    cout << "nights value = " << nights << ", location = " << &nights << endl;
    cout << "*pt value = " << *pt << ", location = " << pt << endl;

    double *pd = new double;
    *pd = 10000001.0;
    cout << "*pd value = " << *pd << ", location = " << pd << endl;
    cout << "location of pointer pd: " << &pd << endl;

    cout << "size of pt = " << sizeof(pt) << ", size of *pt = " << sizeof(*pt) << endl;
    cout << "size of pd = " << sizeof pd << ", size of *pd = " << sizeof(*pd) << endl;

    delete pt;
    delete pd;

    return 0;
}
显示结果如下
nights value = 1001, location = 0x7ffdf2dc2b34
*pt value = 1001, location = 0x55c254d74eb0
*pd value = 1e+07, location = 0x55c254d752e0
location of pointer pd: 0x7ffdf2dc2b38
size of pt = 8, size of *pt = 4
size of pd = 8, size of *pd = 8

new分配的内存块通常与常规变量声明分配的内存块不同。变量nights和pd的值都存储在被称为栈（stack）的内存区域中，
而new从被称为堆（heap）或自由存储区（free store）的内存区域分配内存。第9章将更详细地讨论这一点。
计算机可能会由于没有足够的内存而无法满足new的请求。在这种情况下，new通常会引发异常。
4.7.5 使用delete释放内存
当需要内存时，可以使用new来请求，在使用完内存后，可以使用delete来释放内存。
一定要配对地使用new和delete；否则将发生内存泄漏（memory leak），也就是说被分配的内存再也无法使用了。
不要尝试释放已经释放的内存块，C++标准指出，这样做的结果将是不确定的，这意味着什么情况都可能发生。
另外，不能使用delete来释放声明变量所获得的内存，只能用delete来释放使用new分配的内存。然而，对空指针使用delete是安全的。
4.7.6使用new来创建动态数组
在C++中，创建动态数组很容易；只要将数组的元素类型和元素数目告诉new即可。必须在类型名后上方括号，其中包含元素数目。
例如，要创建一个包含10个int元素的数组，可以这样做：
int *psome = new int[10];
new运算符返回第一个元素的地址。在这个例子中，该地址被赋给指针psome。
当程序使用完new分配的内存块时，应使用delete释放它们。
然而，对于使用new创建的数组，应使用另一种格式的delete来释放：
delete [] psome;
方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。请注意delete和指针之间的方括号。
如果使用new时，不带方括号，则使用delete时，也不应带方括号。
如果使用new时带方括号，则使用delete时也应带方括号。
总之，使用new和delete时，应遵守以下规则。
不要使用delete来释放不是new分配的内存
不要使用delete释放同一个内存块两次
如果使用new[]为数组分配内存，则应使用delete[]来释放。
如果使用new为一个数据对象分配内存，则应使用delete（没有方括号）来释放。
对空指针应用delete是安全的。
现在我们回过头来讨论动态数组。
psome是指向一个int（数组第一个元素）的指针。
由于编译器不能对psome是指向10个整数中的第1个这种情况进行跟踪，
因此编写程序时，必须让程序跟踪元素的数目。
实际上，程序确实跟踪了分配的内存量，以便以后使用delete[]运算符时能够正确地释放这些内存。
但这种信息不是公用的，例如，不能使用sizeof运算符来确定动态分配的数组包含的字节数。
为数组分配内存的通用格式如下：
type_name  pointer_name = new type_name[num_elements];
创建动态数组后，如何访问其中的元素呢？只要把指针当作数组名使用即可。
也就是说，对于第1个元素，可以使用psome[0]，对于第2个元素，可以使用psome[1]，依此类推。
这样，使用指针来访问动态数组就非常简单了，可以这样做的原因是，C和C++内部都使用指针来处理数组。
首先，程序清单4.18演示了如何使用new来创建动态数组以及使用数组表示法来访问元素；
它还指出了指针和真正的数组名之间的根本差别。
程序清单4.18 arraynew.cpp
#include <iostream>

using namespace std;

int main()
{
    double *p3 = new double[3];
    p3[0] = 0.2;
    p3[1] = 0.5;
    p3[2] = 0.8;

    cout << "p3[1] is " << p3[1] << ".\n";
    p3 = p3 + 1;
    cout << "Now p3[0] is " << p3[0] << " and p3[1] is " << p3[1] << ".\n" ;
    p3 = p3 - 1;
    delete[] p3;

    return 0;
}
显示结果如下
p3[1] is 0.5.
Now p3[0] is 0.5 and p3[1] is 0.8.

4.8指针、数组和指针算术
将整数变量加1后，其值将增加1；但将指针变量加1后，增加的量等于它指向的类型的字节数。
将指向double的指针加1后，如果系统对double使用8个字节存储，则数值将增加8；
将指向short的指针加1后，如果系统对short使用2个字节存储，则指针值将增加2。
程序清单4.19演示了这种令人吃惊的现象，它还说明了另一点：C++将数组名解释为地址。
程序清单4.19 addpntrs.cpp
#include <iostream>

using namespace std;

int main()
{
    double wages[3] = { 10000.0, 20000.0, 30000.0 };
    short stacks[3] = { 3, 2, 1 };

    double *pw = wages;

    short *ps = &stacks[0];
    cout << "pw = " << pw << ", *pw = " << *pw << endl;
    pw = pw + 1;
    cout << "add 1 to the pw pointer: \n";
    cout << "pw = " << pw << ", *pw = " << *pw << "\n\n";
    cout << "ps = " << ps << ", *ps = " << *ps << endl;
    ps = ps + 1;
    cout << "add 1 to the ps pointer: \n";
    cout << "ps = " << ps << ", *ps = " << *ps << "\n\n";

    cout << "access two elements with array notation\n";
    cout << "stacks[0] = " << stacks[0] << ", stacks[1] = " << stacks[1] << endl;

    cout << "access two elements with pointer notation\n";
    cout << "*stacks = " << *stacks << ", * (stacks + 1) = " << * (stacks + 1) << endl;

    cout << "size of wages array = " << sizeof(wages) << endl;
    cout << "size of pw pointer = " << sizeof(pw) << endl;

    return 0;
}
显示结果如下
pw = 0x7ffdf4cc2190, *pw = 10000
add 1 to the pw pointer:
pw = 0x7ffdf4cc2198, *pw = 20000

ps = 0x7ffdf4cc218a, *ps = 3
add 1 to the ps pointer:
ps = 0x7ffdf4cc218c, *ps = 2

access two elements with array notation
stacks[0] = 3, stacks[1] = 2
access two elements with pointer notation
*stacks = 3, * (stacks + 1) = 2
size of wages array = 24
size of pw pointer = 8

将指针变量加1后，其增加的值等于指向的类型占用的字节数
通常，使用数组表示法时，C++都执行下面的转换：
arrayname [i] -> * (arrayname + i)
如果使用的是指针，而不是数组名，则C++也将执行同样的转换：
pointername[i] -> * (pointername + i)
因此，在很多情况下，可以相同的方式使用指针名和数组名。
在多数表达式中，它们都表示地址。区别之一是，可以修改指针的值，而数组名是常量。
另一个区别是，对数组应用sizeof运算符得到的是数组的长度，
而对指针应用sizeof得到的是指针的长度，即使指针指向的是一个数组。
数组名被解释为其第一个元素的地址，而对数组名应用地址运算符 & 时，得到的是整个数组的地址。
short tell[10];
cout << tell << endl;
cout << &tell << endl;
从数字上说，这两个地址相同；但从概念上说，这两个类型不同。
tell是一个short指针（*short），而&tell是一个指向包含10个元素的short数组的指针（short（*）[10]）。
因此，表达式tell+1将地址值加2，而表达式(&tell)+1将地址加20。
刚才已经介绍了大量指针的知识，下面对指针和数组做一总结。
1.声明指针
要声明指向特定类型的指针，请使用下面的格式
typeName * pointerName;
2.给指针赋值
应将内存地址赋给指针。可以对变量名应用&运算符，来获得被命名的内存的地址，new运算符返回未命名的内存的地址。
3.对指针解除引用
对指针解除引用意味着获得指针指向的值。对指针应用解除引用或间接值运算符（*）来解除引用。
另一种对指针解除引用的方法是使用数组表示法。决不要对未被初始化为适当地址的指针解除引用。
4.区分指针和指针所指向的值
int *pt;
*pt = 5;
如果pt是指向int的指针，则*pt等同于一个int类型的变量。
5.数组名
在多数情况下，C+将数组名视为数组的第一个元素的地址。
将sizeof运算符用于数组名用时，此时将返回整个数组的长度（单位为字节）
6.指针算术
C++允许将指针和整数相加。加1的结果等于原来的地址值加上指向的对象占用的字节数。
还可以将一个指针减去另一个指针，获得两个指针的差。
后一种运算将得到一个整数，仅当两个指针指向同一个数组（也可以指向超出结尾的一个位置）时，这种运算才有意义；
这将得到两个元素的间隔。
7・创建数组
使用数组声明来创建数组时，数组的长度在编译时设置；
使用new[]运算符创建数组时，数组的长度在运行时设置。
使用完这种数组后，应使用delete[]释放其占用的内存。
8，数组表示法和指针表示法
使用方括号数组表示法等同于对指针解除引用，数组名和指针变量都是如此，
因此对于指针和数组名，既可以使用指针表示法，也可以使用数组表示法。
4.8.3 指针和字符串
数组和指针的特殊关系可以扩展到C风格字符串。请看下面的代码：
char flower [10] = "rose";
cout << flower << "s are red\n";
数组名是第一个元素的地址，因此cout语句中的flower是包含字符r的char元素的地址。
如果给cout提供一个字符的地址，则它将从该字符开始打印，直到遇到空字符为止。
如果flower是字符串第一个字符的地址，则表达式"s are red\n"是什么呢？
为了与cout对字符串输出的处理保持一致；这个用引号括起的字符串也应当是一个地址。
在C++中，用引号括起的字符串像数组名一样，也是第一个元素的地址。
上述代码不会将整个字符串发送给cout，而只是发送该字符串的地址。
这意味着对于数组中的字符串、用引号括起的字符串常量以及指针所描述的字符串，处理的方式是一样的，
都将传递它们的地址。与逐个传递字符串中的所有字符相比，这样做的工作量确实要少。
在cout和多数C++表达式中，char数组名、char指针以及用引号括起的字符串常量都被解释为字符串第一个字符的地址。
程序清单4.20演示了如何使用不同形式的字符串。它使用了两个字符串库中的函数。
函数strlen返回字符串的长度。函数strcpy将字符串从一个位置复制到另一个位置。
这两个函数的原型都位于头文件cstring（在老的C++实现中为string.h）中。
程序清单4.20 ptrstr.cpp
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    char animal[32] = "bear";
    const char *bird = "wren";
    char *ps;
    cout << animal << " and " << bird << "\n";

    cout << "Enter a kind of animal: ";
    cin.getline(animal, 32);
    ps = animal;
    cout << ps << "\n";
    cout << "Before using strcpy():\n";
    cout << animal << " at " << (int *) animal << endl;
    cout << ps << " at " << (int *) ps << endl;
    ps = new char[strlen(animal) + 1];
    strncpy(ps, animal, strlen(animal) + 1);
    cout << "After using strcpy():\n";
    cout << animal << " at " << (int *) animal << endl;
    cout << ps << " at " << (int *) ps << endl;
    delete[] ps;

    return 0;
}
显示结果如下
bear and wren
Enter a kind of animal: fox
fox
Before using strcpy():
fox at 0x7ffc2c85fdd0
fox at 0x7ffc2c85fdd0
After using strcpy():
fox at 0x7ffc2c85fdd0
fox at 0x5579461046d0

4.8.4使用new创建动态结构
通过使用new，可以创建动态结构。由于类与结构非常相似，因此本节介绍的有关结构的技术也适用于类。
例如，要创建一个未命名的inflatable类型，并将其地址赋给一个指针，可以这样做：
inflatable * ps = new inflatable;
就像点运算符可用于结构名一样，箭头->运算符可用于指向结构的指针。
例如，如果ps指向一个inflatable结构，则ps->price是被指向的结构的price成员（参见图4.11）。
如果ps是指向结构的指针，则*ps就是被指向的结构本身。
由于*ps是一个结构，因此 (*ps).price是该结构的price成员。
程序清单4.21使用new创建一个未命名的结构，并演示了两种访问结构成员的指针表示法。
程序清单4.21 newstrct.cpp
#include <iostream>

using namespace std;

struct inflatable
{
    char name[32];
    double volume;
    double price;
};

int main()
{
    inflatable *ps = new inflatable;
    cout << "Enter name of inflatable item: ";
    cin.getline(ps->name, 32);
    cout << "Enter volume in cubic feet: ";
    cin >> (*ps).volume;
    cout << "Enter price: $";
    cin >> ps->price;
    cout << "Name: " << (*ps).name << endl;
    cout << "Volume: " << ps->volume << " cubic feet\n";
    cout << "Price: $" << ps->price << endl;
    delete ps;

    return 0;
}
显示结果如下
Enter name of inflatable item: Apple
Enter volume in cubic feet: 9.3
Enter price: $12.3
Name: Apple
Volume: 9.3 cubic feet
Price: $12.3

程序清单4.22定义了一个函数getname，该函数返回一个指向输入字符串的指针。
该函数将输入读入到一个大型的临时数组中，然后使用new[]创建一个刚好能够存储该输入字符串的内存块，并返回一个指向该内存块的指针。
程序清单4.22 delete.cpp
#include <iostream>
#include <cstring>

using namespace std;

char *getname(void);

int main()
{
    char *name;

    name = getname();
    cout << name << " at " << (int *)name << "\n";
    delete[] name;

    name = getname();
    cout << name << " at " << (int *)name << "\n";
    delete[] name;

    return 0;
}

char *getname()
{
    char temp[256];
    cout << "Enter name: ";
    cin.getline(temp, 256);
    char *pn = new char[strlen(temp) + 1];
    strcpy(pn, temp);
    return pn;
}
显示结果如下
Enter name: Peter Smith
Peter Smith at 0x55bc435816d0
Enter name: Hello World
Hello World at 0x55bc435816d0

4.8.5 自动存储、静态存储和动态存储
根据用于分配内存的方法，C++有3种管理数据内存的方式：自动存储、静态存储和动态存储（有时也叫作自由存储空间或堆）。
在存在时间的长短方面，以这3种方式分配的数据对象各不相同。下面简要地介绍每种类型（C++11新增了第四种类型――线程存储，这将在第9章简要地讨论）
1.自动存储
在函数内部定义的常规变量使用自动存储空间，被称为自动变量（automatic variable），
这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。
实际上，自动变量是一个局部变量，其作用域为包含它的代码块。代码块是被包含在花括号中的一段代码。
到目前为止，我们使用的所有代码块都是整个函数。然而，在下一章将会看到，函数内也可以有代码块。
如果在其中的某个代码块定义了一个变量，则该变量仅在程序执行该代码块中的代码时存在。
自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将依次加入到栈中，
而在离开代码块时，将按相反的顺座释放这些变量，这被称为后进先出，因此，在程序执行过程中，栈将不断地增大和缩小。
2.静态存储
静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字static。
3.动态存储
new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。
它们管理了一个内存池，这在C++中被称为自由存储空间（free store）或堆（heap），该内存池同用于静态变量和自动变量的内存是分开的。
与使用常规变量相比，使用new和delete让程序员对程序如何使用内存有更大的控制权。然而，内存管理也更复杂了。
在栈中，自动添加和删除机制使得占用的内存总是连续的，但new和delete的相互影响可能导致占用的自由存储区不连续，这使得跟踪新分配内存的位置更困难。
如果使用new运算符在自由存储空间（或堆）上创建变量后没有及时调用delete，则即使包含指针的内存由于作用域规则和对象生命周期的原因而被释放，
在自由存储空间上动态分配的变量或结构也将继续存在，这将导致内存泄漏。
被泄漏的内存将在程序的整个生命周期内都不可使用；这些内存被分配出去，但无法收回。
极端情况下，应用程序可用的内存被耗尽，出现内存耗尽错误，导致程序崩溃。
要避免内存泄漏，最好是养成这样一种习惯，使用new运算符在自由存储空间上分配内存后，及时使用delete运算符释放它。
C++智能指针有助于自动完成这种任务，这将在第16章介绍。
4.9类型组合
本章介绍了数组、结构和指针，可以各种方式组合它们。
程序清单4.23 mixtypes.cpp
#include <iostream>

using namespace std;

struct antarctica_years_end
{
    int year;
};

int main()
{
    antarctica_years_end s01, s02, s03;
    s01.year = 1998;
    antarctica_years_end *pa = &s02;
    pa->year = 1999;
    antarctica_years_end trio[3];
    trio[0].year = 2003;
    cout << trio->year << endl;
    const antarctica_years_end *arp[3] = { &s01, &s02, &s03 };
    cout << arp[1]->year << endl;
    const antarctica_years_end **ppa = arp;
    auto ppb = arp;

    cout << (*ppa)->year << endl;
    cout << (*(ppb + 1))->year << endl;

    return 0;
}
显示结果如下
2003
1999
1998
1999

4.10 模板类vector和array
4.10.1 模板类vector
模板类vector是一种动态数组。您可以在运行阶段设置vector对象的长度，可在末尾附加新数据，还可在中间插入新数据。
基本上，它是使用new创建动态数组的替代品。实际上，vector类确实使用new和delete来管理内存，但这种工作是自动完成的。
要使用vector对象，必须包含头文件vector。其次，vector包含在名称空间std中，因此您可使用using编译指令或std:vector。
第三，模板使用不同的语法来指出它存储的数据类型。第四，vector类使用不同的语法来指定元素数。
#include <vector>
using namespace std;
vector<int> vi;   // create a zero-size array of int
int n;
cin >> n;
vectore<double> vd (n);   //create an array of n doubles
其中，vi是一个vectorsint>对象，vd是一个vectorkdouble>对象。
由于vector对象在您插入或添加值时自动调整长度，因此可以将vi的初始长度设置为零。
下面的声明创建一个名为vt的vector对象，它可存储n_elem个类型为typeName的元素：
vector<typeName> vt (n_elem);
其中参数n_elem可以是整型常量，也可以是整型变量。
4.10.2 模板类array（C++11）
vector类的功能比数组强大，但付出的代价是效率稍低。
C++11新增了模板类array，它也位于名称空间std中。
与数组一样，array对象的长度也是固定的，也使用栈（静态内存分配），而不是自由存储区，
因此其效率与数组相同，但更方便，更安全。
要创建array对象，需要包含头文件array，array对象的创建语法与vector稍有不同：
#include <array>
using namespace std;

array<int, 5> ai;   // create array object of 5 ints
array<double, 4> ad = {1.2, 2.1, 3.43, 4.3};
下面的声明创建一个名为arr的array对象，它包含n_elem个类型为typename的元素：
array<typeName, n_elem> arr;
与创建vector对象不同的是，n_elem不能是变量。
在C++11中，可将列表初始化用于vector和array对象，但在C++98中，不能对vector对象这样做。
4.10.3 比较数组、vector对象和array对象
程序清单4.24 choices.cpp
#include <iostream>
#include <vector>
#include <array>

using namespace std;

int main()
{

    double a1[4] = { 1.2, 2.4, 3.6, 4.8 };
    vector<double> a2(4);

    a2[0] = 1.0 / 3.0;
    a2[1] = 1.0 / 5.0;
    a2[2] = 1.0 / 7.0;
    a2[3] = 1.0 / 9.0;

    array<double, 4> a3 = { 3.14, 2.72, 1.62, 1.41 };
    array<double, 4> a4;
    a4 = a3;

    cout << "a1[0]: " << a1[0] << " at " << &a1[0] << endl;
    cout << "a2[0]: " << a2[0] << " at " << &a2[0] << endl;
    cout << "a3[0]: " << a3[0] << " at " << &a3[0] << endl;
    cout << "a4[0]: " << a4[0] << " at " << &a4[0] << endl;

    cout << "a1[1]: " << a1[1] << " at " << &a1[1] << endl;
    cout << "a2[1]: " << a2[1] << " at " << &a2[1] << endl;
    cout << "a3[1]: " << a3[1] << " at " << &a3[1] << endl;
    cout << "a4[1]: " << a4[1] << " at " << &a4[1] << endl;

    cout << "a1[2]: " << a1[2] << " at " << &a1[2] << endl;
    cout << "a2[2]: " << a2[2] << " at " << &a2[2] << endl;
    cout << "a3[2]: " << a3[2] << " at " << &a3[2] << endl;
    cout << "a4[2]: " << a4[2] << " at " << &a4[2] << endl;

    cout << "a1[3]: " << a1[3] << " at " << &a1[3] << endl;
    cout << "a2[3]: " << a2[3] << " at " << &a2[3] << endl;
    cout << "a3[3]: " << a3[3] << " at " << &a3[3] << endl;
    cout << "a4[3]: " << a4[3] << " at " << &a4[3] << endl;

    return 0;
}
显示结果如下
a1[0]: 1.2 at 0x7fff2e2f0e30
a2[0]: 0.333333 at 0x55bde0bbfeb0
a3[0]: 3.14 at 0x7fff2e2f0e50
a4[0]: 3.14 at 0x7fff2e2f0e70
a1[1]: 2.4 at 0x7fff2e2f0e38
a2[1]: 0.2 at 0x55bde0bbfeb8
a3[1]: 2.72 at 0x7fff2e2f0e58
a4[1]: 2.72 at 0x7fff2e2f0e78
a1[2]: 3.6 at 0x7fff2e2f0e40
a2[2]: 0.142857 at 0x55bde0bbfec0
a3[2]: 1.62 at 0x7fff2e2f0e60
a4[2]: 1.62 at 0x7fff2e2f0e80
a1[3]: 4.8 at 0x7fff2e2f0e48
a2[3]: 0.111111 at 0x55bde0bbfec8
a3[3]: 1.41 at 0x7fff2e2f0e68
a4[3]: 1.41 at 0x7fff2e2f0e88

4.11总结
数组、结构和指针是C++的3种复合类型。数组可以在一个数据对象中存储多个同种类型的值。通过使用索引或下标，可以访问数组中各个元素。
结构可以将多个不同类型的值存储在同一个数据对象中，可以使用成员关系运算符（.）来访问其中的成员。
使用结构的第一步是创建结构模板，它定义结构存储了哪些成员。模板的名称将成为新类型的标识符，然后就可以声明这种类型的结构变量。
联合可以存储一个值，但是这个值可以是不同的类型，成员名指出了使用的模式。
指针是被设计用来存储地址的变量。我们说，指针指向它存储的地址。指针声明指出了指针指向的对象的类型。
对指针应用解除引用运算符，将得到指针指向的位置中的值。
字符串是以空字符为结尾的一系列字符。字符串可用引号括起的字符串常量表示，其中隐式包含了结尾的空字符。
可以将字符串存储在char数组中，可以用被初始化为指向字符串的char指针表示字符串。
函数stren返回字符串的长度，其中不包括空字符。函数strcpy将字符串从一个位置复制到另一个位置。
在使用这些函数时，应当包含头文件cstring或string.h.
头文件string支持的C++ string类提供了另一种对用户更友好的字符串处理方法。
具体地说，string对象将根据要存储的字符串自动调整其大小，用户可以使用赋值运算符来复制字符串。
new运算符允许在程序运行时为数据对象请求内存。该运算符返回获得内存的地址，
可以将这个地址赋给一个指针，程序将只能使用该指针来访问这块内存。
如果数据对象是简单变量，则可以使用解除引用运算符（*）来获得其值；
如果数据对象是数组，则可以像使用数组名那样使用指针来访问元素；
如果数据对象是结构，则可以用指针解除引用运算符（->）来访问其成员。
指针和数组紧密相关。如果ar是数组名，则表达式ar[i]被解释为* (ar + i)，其中数组名被解释为数组第一个元素的地址。
这样，数组名的作用和指针相同。反过来，可以使用数组表示法，通过指针名来访问new分配的数组中的元素。
运算符new和delete允许显式控制何时给数据对象分配内存，何时将内存归还给内存池。
自动变量是在函数中声明的变量，而静态变量是在函数外部或者使用关键字static声明的变量，这两种变量都不太灵活。
自动变量在程序执行到其所属的代码块（通常是函数定义）时产生，在离开该代码块时终止。静态变量在整个程序周期内都存在。
C++98新增的标准模板库（STL）提供了模板类vector，它是动态数组的替代品。C++11提供了模板类array，它是定长数组的替代品。
4.12 复习题
1.如何声明下述数据？
.actor是由30个char组成的数组
b.betsie是由100个short组成的数组
c.chuck是由13个float组成的数组
d.dipsea是由64个long double组成的数组。

char actors [30];
short betsie [100];
float chuck [13];
long double dipsea [64];

2.使用模板类array而不是数组来完成问题1。

array<char, 30>actors;
array<short, 100> betsie;
array<float, 13> chuck;
array<long double, 64> dipsea;

3.声明一个包含5个元素的int数组，并将它初始化为前5个正奇数
int oddly[5] = {1, 3, 5, 7, 9};

4.编写一条语句，将问题3中数组第一个元素和最后一个元素的和赋给变量even。
int even = oddly[0] + oddly[4];

5・编写一条语句，显示float数组ideas中的第2个元素的值。
cout << ideas[1]<<"n";

6.声明一个char的数组，并将其初始化为字符串"cheeseburger'
char lunch[32] = "cheeseburger";
char lunch[] = "cheeseburger";

7.声明一个string对象，并将其初始化为字符串"Waldorf Salad".
string lunch = "Waldorf salad";
如果没有using编译指令，则为：
std::string lunch = "Waldorf Salad";

8.设计一个描述鱼的结构声明。结构中应当包括品种、重量（整数，单位为盎司）和长度（英寸，包括小数）。
struct fish
{
    char kind[32];
    int weight;
    double length;
};

9.声明一个问题8中定义的结构的变量，并对它进行初始化。
fish petes = 
{
    "trout",
    12,
    26.25
};

10.用enum定义一个名为Response的类型，它包含Yes，No和Maybe等枚举量，
其中Yes的值为1，No为0，Maybe为2。
enum Response {No, Yes, Maybe};

11.假设ted是一个double变量，请声明一个指向ted的指针，并使用该指针来显示ted的值

double * pd = &ted;
cout << *pd << '\n';

12.假设treacle是一个包含10个元素的float数组，请声明一个指向treacle的第一个元素的指针，
并使用该指针来显示数组的第一个元素和最后一个元素。
float treacle[10];

float * pf = treacle;   // or & ( treacle[0] )
cout << pf[0] << " , " << pf[9] << '\n';   //or use *pf and * (pf + 9)


13.编写一段代码，要求用户输入一个正整数，然后创建一个动态的int数组，
其中包含的元素数目等于用户输入的值。首先使用new来完成这项任务，再使用vector对象来完成这项任务。
#include <iostream>
#include <vector>

using namespace std;

int main()
{
    int size;
    cout << "Enter a positive integer: ";
    cin >> size;
    if (size <= 0)
    {
        return 0;
    }

    int * dyn = new int[size];
    vector<int> dv (size);

    delete [] dyn;

    return 0;
}

14.下面的代码是否有效？如果有效，它将打印出什么结果？
cout << (int *) "Home of the jolly bytes";
有效，"Home of the jolly bytes"是一个字符串常量，用于表达式时，表示字符串常量第一个字符的地址。
强制类型转换 (int *) 将地址转换为int指针，然后作为地址被打印。

15.编写一段代码，给问题8中描述的结构动态分配内存，再读取该结构的成员的值。
struct fish
{
    char kind[32];
    int weight;
    double length;
};

fish * pole =new fish;
cout << "Enter kind of fish: ";
cin.getline(pole->kind, 32);

16.程序清单4.6指出了混合输入数字和一行字符串时存储的问题。
#include <iostream>

using namespace std;

int main()
{
    cout << "What year was your house built?\n";
    int year;
    cin >> year;
    cin.get();
    cout << "What is its street address?\n";
    char address[80];
    cin.getline(address, 80);
    cout << "Year built: " << year << endl;
    cout << "Address: " << address << endl;
    cout << "Done!\n";

    return 0;
}

如果将下面的代码：cin.getline(address, 80);替换为：cin >> address;将对程序的运行带来什么影响？
使用cin >>address将使得程序跳过空白，直到找到非空白字符为止。然后它将读取字符，直到再次遇到空白为止。
使用cin >>address只读取一个单词，而不是整行。

17.声明一个vector对象和一个array对象，它们都包含10个string对象。指出所需的头文件，但不要使用using。
使用const来指定要包含的string对象数。

#include <iostream>
#include <string>
#include <vector>
#include <array>

const int num_of_str = 10;

std::vector<std::string> vstr (num_of_str);
std::array<std::string, num_of_str> astr;


4.13 编程练习
1.编写一个C++程序，如下述输出示例所示的那样请求并显示信息。
#include <iostream>

int main()
{
    std::cout << "What is your first name? ";
    char first_name[128];
    std::cin.getline(first_name, 128);

    std::cout << "What is your last name? ";
    char last_name[128];
    std::cin.getline(last_name, 128);

    std::cout << "What letter grade do you deserve? ";
    char ctg;
    std::cin >> ctg;
    ctg = ctg + 1;

    std::cout << "What is your age? ";
    int age = 0;
    std::cin >> age;

    std::cout << "Name: " << last_name << ", " << first_name << std::endl;
    std::cout << "Grade: " << ctg << std::endl;
    std::cout << "Age: " << age << std::endl;

    return 0;
}
显示结果如下
What is your first name? Betty Sue
What is your last name? Yewe
What letter grade do you deserve? B
What is your age? 22
Name: Yewe, Betty Sue
Grade: C
Age: 22

2.修改程序清单4.4，使用C++ string类而不是char数组。
#include <iostream>
#include <string>

int main()
{
    std::string name;
    std::cout << "Enter your name: ";
    std::getline(std::cin, name, '\n');

    std::string dessert;
    std::cout << "Enter your favorite dessert: ";
    std::getline(std::cin, dessert, '\n');

    std::cout << "I have some delicious " << dessert << " for you, " << name << " .\n";

    return 0;
}
显示结果如下
Enter your name: Peter Smith
Enter your favorite dessert: Apple
I have some delicious Apple for you, Peter Smith .

3.编写一个程序，它要求用户首先输入其名，然后输入其姓；
然后程序使用个逗号和空格将姓和名组合起来，并存储和显示组合结果。
请使用char数组和头文件cstring中的函数。
#include <iostream>
#include <cstring>

int main()
{
    std::cout << "What is your first name? ";
    char first_name[128];
    std::cin.getline(first_name, 128);

    std::cout << "What is your last name? ";
    char last_name[128];
    std::cin.getline(last_name, 128);

    char result[256];
    strcpy(result, last_name);
    strcat(result, ", ");
    strcat(result, first_name);
    std::cout << "Here's the information in a single string: " << result << std::endl;

    return 0;
}
显示结果如下
What is your first name? Smith
What is your last name? Peter
Here's the information in a single string: Peter, Smith

4.编写一个程序，它要求用户首先输入其名，再输入其姓；
然后程序使用一个逗号和空格将姓和名组合起来，并存储和显示组合结果。
请使用string对象和头文件string中的函数。
#include <iostream>
#include <string>

int main()
{
    std::cout << "What is your first name? ";
    std::string first_name;
    std::getline(std::cin, first_name, '\n');

    std::cout << "What is your last name? ";
    std::string last_name;
    std::getline(std::cin, last_name, '\n');

    std::string result;
    result = last_name + ", " + first_name;
    std::cout << "Here's the information in a single string: " << result << std::endl;

    return 0;
}
显示结果如下
What is your first name? World
What is your last name? Hello
Here's the information in a single string: Hello, World

5.结构CandyBar包含3个成员。第一个成员存储了糖块的品牌；第二个成员存储糖块的重量（可以有小数）；
第三个成员存储了糖块的卡路里含量（整数）。请编写一个程序，声明这个结构，
创建一个名为snack的CandyBar变量，并将其成员分别初始化为"Mocha Munch"、2.3和350，
初始化应在声明snack时进行。最后，程序显示snack变量的内容。
#include <iostream>
#include <string>

struct CandyBar
{
    std::string candy_name;
    double weight;
    int calories;
};

int main()
{
    CandyBar snack;
    snack.candy_name = "Mocha Munch";
    snack.weight = 2.3;
    snack.calories= 350;

    std::cout << "Name: " << snack.candy_name << std::endl;
    std::cout << "Weight: " << snack.weight << std::endl;
    std::cout << "Calories: " << snack.calories << std::endl;

    return 0;
}
显示结果如下
Name: Mocha Munch
Weight: 2.3
Calories: 350

6，结构CandyBar包含3个成员，如编程练习5所示。
请编写一个程序，创建一个包含3个元素的CandyBar数组，并将它们初始化为所选择的值，然后显示每个结构的内容。
#include <iostream>
#include <string>

struct CandyBar
{
    std::string candy_name;
    double weight;
    int calories;
};

int main()
{
    CandyBar snack[3];

    snack[0].candy_name = "Mocha Munch";
    snack[0].weight = 1.1;
    snack[0].calories = 350;

    snack[1].candy_name = "Mocha Munch1";
    snack[1].weight = 2.2;
    snack[1].calories = 350;

    snack[2].candy_name = "Mocha Munch2";
    snack[2].weight = 3.3;
    snack[2].calories = 350;

    std::cout << "Name: " << snack[0].candy_name << std::endl;
    std::cout << "Weight: " << snack[0].weight << std::endl;
    std::cout << "Calories: " << snack[0].calories << std::endl;

    std::cout << std::endl;

    std::cout << "Name: " << snack[1].candy_name << std::endl;
    std::cout << "Weight: " << snack[1].weight << std::endl;
    std::cout << "Calories: " << snack[1].calories << std::endl;

    std::cout << std::endl;

    std::cout << "Name: " << snack[2].candy_name << std::endl;
    std::cout << "Weight: " << snack[2].weight << std::endl;
    std::cout << "Calories: " << snack[2].calories << std::endl;

    return 0;
}
显示结果如下
Name: Mocha Munch
Weight: 1.1
Calories: 350

Name: Mocha Munch1
Weight: 2.2
Calories: 350

Name: Mocha Munch2
Weight: 3.3
Calories: 350

7.William Wingate从事比萨饼分析服务。对于每个披萨饼，他都需要记录下列信息
披萨饼公司的名称，可以有多个单词组成。
披萨饼的直径。
拔萨饼的重量。
请设计一个能够存储这些信息的结构，并编写一个使用这种结构变量的程序。
程序将请求用户输入上述信息，然后显示这些信息。
#include <iostream>
#include <string>

struct WilliamWingate
{
    std::string company_name;
    double diametr = 0.0;
    double weight = 0.0;
};

int main()
{
    WilliamWingate Pizza;

    std::cout << "Enter company name: ";
    std::getline(std::cin, Pizza.company_name, '\n');

    std::cout << "Enter diametr: ";
    std::cin >> Pizza.diametr;

    std::cout << "Enter weight: ";
    std::cin >> Pizza.weight;

    std::cout << std::endl;

    std::cout << "Company name = " << Pizza.company_name << std::endl;
    std::cout << "Diametr = " << Pizza.diametr << std::endl;
    std::cout << "Weight = " << Pizza.weight << std::endl;

    return 0;
}
显示结果如下
Enter company name: Hello World
Enter diametr: 3.3
Enter weight: 12.5

Company name = Hello World
Diametr = 3.3
Weight = 12.5

8.完成编程练习7，但使用new来为结构分配内存，而不是声明一个结构变量。
另外，让程序在请求输入比萨饼公司名称之前输入比萨饼的直径。
#include <iostream>
#include <string>

struct WilliamWingate
{
    std::string company_name;
    double diametr = 0.0;
    double weight = 0.0;
};

int main()
{
    WilliamWingate *Pizza = new WilliamWingate;

    std::cout << "Enter diametr: ";
    (std::cin >> Pizza->diametr).get();

    std::cout << "Enter company name: ";
    std::getline(std::cin, Pizza->company_name, '\n');

    std::cout << "Enter weight: ";
    std::cin >> Pizza->weight;

    std::cout << std::endl;

    std::cout << "Company name = " << Pizza->company_name << std::endl;
    std::cout << "Diametr = " << Pizza->diametr << std::endl;
    std::cout << "Weight = " << Pizza->weight << std::endl;

    delete Pizza;

    return 0;
}
显示结果如下
Enter diametr: 5.5
Enter company name: Peter Smith
Enter weight: 123.6

Company name = Peter Smith
Diametr = 5.5
Weight = 123.6

9.完成编程练习6，但使用new来动态分配数组，而不是声明一个包含3个元素的CandyBar数组
#include <iostream>
#include <string>

struct CandyBar
{
    std::string candy_name;
    double weight;
    int calories;
};

int main()
{
    CandyBar *snack = new CandyBar[3];

    snack[0].candy_name = "Mocha Munch";
    snack[0].weight = 1.1;
    snack[0].calories = 350;

    snack[1].candy_name = "Mocha Munch1";
    snack[1].weight = 2.2;
    snack[1].calories = 350;

    snack[2].candy_name = "Mocha Munch2";
    snack[2].weight = 3.3;
    snack[2].calories = 350;

    std::cout << "Name: " << snack[0].candy_name << std::endl;
    std::cout << "Weight: " << snack[0].weight << std::endl;
    std::cout << "Calories: " << snack[0].calories << std::endl;

    std::cout << std::endl;

    std::cout << "Name: " << snack[1].candy_name << std::endl;
    std::cout << "Weight: " << snack[1].weight << std::endl;
    std::cout << "Calories: " << snack[1].calories << std::endl;

    std::cout << std::endl;

    std::cout << "Name: " << snack[2].candy_name << std::endl;
    std::cout << "Weight: " << snack[2].weight << std::endl;
    std::cout << "Calories: " << snack[2].calories << std::endl;

    delete[] snack;

    return 0;
}
显示结果如下
Name: Mocha Munch
Weight: 1.1
Calories: 350

Name: Mocha Munch1
Weight: 2.2
Calories: 350

Name: Mocha Munch2
Weight: 3.3
Calories: 350

10.编写 个程序，让用户输入三次赛跑的成绩，并显示次数和平均成绩。
请使用一个array对象来存储数据（如果编译器不支持array类，请使用数组）。
#include <iostream>
#include <array>

int main() 
{
	std::array<double, 3> result;

	std::cout << "Enter 3 race results: " << std::endl;
	std::cin >> result[0] >> result[1] >> result[2];

	std::cout << "You typed: ";
	std::cout << result[0] << ", " << result[1] << ", " << result[2] << std::endl;

	std::cout << "Average value: ";
	double Average = (result[0] + result[1] + result[2]) / 3.0;
	std::cout << Average << std::endl;

	return 0;
}
显示结果如下
Enter 3 race results:
8.8
7.5
6.2
You typed: 8.8, 7.5, 6.2
Average value: 7.5

第5章 循环和关系表达式
5.1 for循环
5.1.1 for循环的组成部分
5.1.2 回到for循环
5.1.3 修改步长
5.1.4 使用for循环访问字符串
5.1.5 递增运算符和递减运算符
5.1.6 副作用和顺序点
5.1.7 前缀格式和后缀格式
5.1.8 递增、递减运算符和指针
5.1.9 组合赋值运算符
5.1.10 复合语句（语句块）
5.1.11 其他语法技巧 逗号运算符
5.1.12 关系表达式
5.1.13 赋值、比较和可能犯的错误
5.1.14 C风格字符串的比较
5.1.15 比较string类字符串
5.2 while 循环.
5.2.1 for与while
5.2.2 等待一段时间：编写延时循环
5.3 do while循环
5.4 基于范围的for循环（C++1月）.
5.5 循环和文本输入.
5.5.1 使用原始的cin进行输入
5.5.2 使用cin.get(char)进行补救
5.5.3 使用哪一个cin.get()
5.5.4 文件尾条件
5.5.5 另一个cin.get()版本
5.6 嵌套循环和二维数维
5.6.1 初始化二维数组
5.6.2 使用二维数组
5.7 总结
5.8 复习题
5.9 编程练习
本章内容包括：
for循环。
表达式和语句。
递增运算符和递减运算符：++和--。
组合赋值运算符。
复合语句（语句块）。
逗号运算符。
关系运算符：>、>=、==、<、<=和!=
while循环。
typedef工具。
do while循环。
字符输入方法get。
文件尾条件。
嵌套循环和二维数组。
本章将讨论循环和关系表达式，第6将介绍分支语句和逻辑表达式。
5.1 for循环
很多情况下都需要程序执行重复的任务，C++中的for循环可以轻松地完成这种任务。
我们来看看程序清单5.1中，以了解for循环所做的工作，然后讨论它是如何工作的。
程序清单5.1 forloop.cpp
#include <iostream>

using namespace std;

int main()
{
    int i;

    for (i = 0; i < 5; i++)
    {
        cout << i << " loop.\n";
    }
    cout << "loop end.\n";

    return 0;
}
显示结果如下
0 loop.
1 loop.
2 loop.
3 loop.
4 loop.
loop end.

5.1.1 for循环的组成部分
for循环为执行重复的操作提供了循序渐进的步骤。我们来具体看一看它是如何工作的。for循环的组成部分完成下面这些步骤。
设置初始值。
执行测试，看看循环是否应当继续进行。
执行循环操作。
更新用于测试的值。
初始化、测试和更新操作构成了控制部分，这些操作由括号括起。其中每部分都是一个表达式，彼此由分号隔开。
控制部分后面的语句叫作循环体，只要测试表达式为true，它便被执行：
for (initialization; test-expression; update-expression)
    body
循环只执行一次初始化。通常，程序使用该表达式将变量设置为起始值。
test-expression（测试表达式）决定循环体是否被执行。通常，这个表达式是关系表达式。
实际上，C++并没有将test-expression的值限制为只能为真或假。可以使用任意表达式，C++将把结果强制转换为bool类型。
因此，值为0的表达式将被转换为bool值false，导致循环结束。如果表达式的值为非零，则被强制转换为bool值true，循环将继续进行。
程序清单5.2通过将表达式i用作测试条件来演示了这一特点。
程序清单5.2 num_test.cpp
#include <iostream>

using namespace std;

int main()
{
    cout << "Enter the starting countdown value: ";
    int limit = 0;
    cin >> limit;
    if (limit <= 0 )
    {
        return 0;
    }
    int i;
    for (i = limit; i; i--)
    {
        cout << "i = " << i << "\n";
    }
    cout << "Done, now i = " << i << "\n";

    return 0;
}
显示结果如下
Enter the starting countdown value: 8
i = 8
i = 7
i = 6
i = 5
i = 4
i = 3
i = 2
i = 1
Done, now i = 0

程序清单5.3 express.cpp
#include <iostream>

using namespace std;

int main()
{
    int x = 0;
    cout << "The expression x = 100 has the value ";
    cout << (x = 100) << endl;
    cout << "Now x = " << x << endl;
    cout << "The expression x < 3 has the value ";
    cout << (x < 3) << endl;
    cout << "The expression x > 3 has the value ";
    cout << (x > 3) << endl;
    cout.setf(ios_base::boolalpha);
    cout << "The expression x < 3 has the value ";
    cout << (x < 3) << endl;
    cout << "The expression x > 3 has the value ";
    cout << (x > 3) << endl;

    return 0;
}
显示结果如下
The expression x = 100 has the value 100
Now x = 100
The expression x < 3 has the value 0
The expression x > 3 has the value 1
The expression x < 3 has the value false
The expression x > 3 has the value true

程序清单5.4 formore.cpp
#include <iostream>

using namespace std;

const int ArSize = 16;

int main()
{
    long long factorials[ArSize];
    factorials[1] = factorials[0] = 1LL;
    for (int i = 2; i < ArSize; i++)
    {
        factorials[i] = i * factorials[i - 1];
    }
    for (int i = 0; i < ArSize; i++)
    {
        cout << i << " ! = " << factorials[i] << endl;
    }

    return 0;
}
显示结果如下
0 ! = 1
1 ! = 1
2 ! = 2
3 ! = 6
4 ! = 24
5 ! = 120
6 ! = 720
7 ! = 5040
8 ! = 40320
9 ! = 362880
10 ! = 3628800
11 ! = 39916800
12 ! = 479001600
13 ! = 6227020800
14 ! = 87178291200
15 ! = 1307674368000

程序清单5.5 bigstep.cpp
#include <iostream>

using namespace std;

int main()
{

    cout << "Enter an integer: ";
    int step;
    cin >> step;
    if (step <= 0)
    {
        return 0;
    }
    cout << "Counting by " << step << "\n";
    for (int i = 0; i < 100; i = i + step)
    {
        cout << i << endl;
    }

    return 0;
}
显示结果如下
Enter an integer: 5
Counting by 5
0
5
10
15
20
25
30
35
40
45
50
55
60
65
70
75
80
85
90
95

程序清单5.6 forstr1.cpp
#include <iostream>
#include <string>

using namespace std;

int main()
{
    cout << "Enter a word: ";
    string word;
    getline(cin, word, '\n');

    for (int i = word.size() - 1; i >= 0; i--)
    {
        cout << word[i];
    }
    cout << "\nDone.\n";

    return 0;
}
显示结果如下
Enter a word: Hello, World!
!dlroW ,olleH
Done.

程序清单5.7 plus_one.cpp
#include <iostream>
#include <string>

using namespace std;

int main()
{
    int a = 20;
    int b = 20;

    cout << "a = "<< a << ": b = " << b << "\n";
    cout << "a++ = " << a++ << " : ++b = " << ++b << "\n";
    cout << "a = " << a << ": b = " << b << "\n";

    return 0;
}
显示结果如下
a = 20: b = 20
a++ = 20 : ++b = 21
a = 21: b = 21

副作用（side effect）指的是在计算表达式时对某些东西（如存储在变量中的值）进行了修改；
顺序点（sequence point）是程序执行过程中的一个点，在这里，进入下一步之前将确保对所有的副作用都进行了评估。
在C++中，语句中的分号就是一个顺序点，这意味着程序处理下一条语句之前，赋值运算符、递增运算符和递减运算符执行的所有修改都必须完成。
本章后面将讨论的有些操作也有顺序点。另外，任何完整的表达式末尾都是一个顺序点。何为完整表达式呢？
它是这样一个表达式：不是另一个更大表达式的子表达式。
顺序点有助于阐明后缀递增何时进行。例如，请看下面的代码：
int guests = 0;

while (guests++ < 10)
{
    cout << guests << endl;
}
while循环将在本章后面讨论，它类似于只有测试表达式的for循环。
表达式guests++ < 10是一个完整表达式，因此该表达式的末尾是一一个顺序点。
所以，C++确保副作用（将guests加1）在程序进入cout之前完成。
然而，通过使用后缀格式，可确保将guests同10进行比较后再将其值加1。
现在来看下面的语句：
y = (4 + x++) + (6 + x++);
表达式4+x++不是一个完整表达式，因此，C+ +不保证x的值在计算子表达式4+x++后立刻增加1。
在这个例子中，整条赋值语句是一个完整表达式，而分号标示了顺序点，因此C++只保证程序执行到下一条语句之前，x的值将被递增两次。
C++没有规定是在计算每个子表达式之后将x的值递增，还是在整个表达式计算完毕后才将x的值递增，有鉴于此，您应避免使用这样的表达式。
5.1.7前缀格式和后缀格式
显然，如果变量被用于某些目的（如用作函数参数或给变量赋值），使用前缀格式和后缀格式的结果将不同。
然而。如果递增表达式的值没有被使用，情况又如何呢？例如，下面两条语句的作用是否不同？
x++;
++x;
下面两条语句的作用是否不同？
for (n =16; n > 0; --n)
和
for (n = 16; n > 0; n--)
从逻辑上说，在上述两种情形下，使用前缀格式和后缀格式没有任何区别。表达式的值未被使用，因此只存在副作用。
在上面的例子中，使用这些运算符的表达式为完整表达式，因此将x加1和n减1的副作用将在程序进入下一步之前完成，前缀格式和后缀格式的最终效果相同。
然而，虽然选择使用前缀格式还是后缀格式对程序的行为没有影响，但执行速度可能有细微的差别。
对于内置类型和当代的编译器而言，这看似不是什么问题。然而，C++ 允许您针对类定义这些运算符，
在这种情况下，用户这样定义前缀函数：将值加1，然后返回结果；但后缀版本首先复制一个副本，将其加1，然后将复制的副本返回。
因此，对于类而言，前缀版本的效率比后缀版本高。
总之，对于内置类型，采用哪种格式不会有差别：但对于用户定义的类型，如果有用户定义的递增和递减运算符，则前缀格式的效率更高。
5.1.8 递增/递减运算符和指针
将递增运算符用于指针时，将把指针的值增加其指向的数据类型占用的字节数；
将递减运算符用于指针时，将把指针的值减掉其指向的数据类型占用的字节数。
double arr[5] = {21.1, 32.8, 23.4, 45.2, 37.4};
double *pt = arr;   //pt points to arr[0]
++pt;   // pt points to arr[1]
也可以结合使用这些运算符和*运算符来修改指针指向的值。
*++pt的含义如下：现将++应用于pt，然后将*应用于被递增后的pt。
++*pt的含义如下：先取得pt指向的值，然后将这个值加1。
(*pt)++的含义如下：先取得pt指向的值，然后将这个值加1。
*pt++的含义如下：先将*应用于递增之前的pt，再将++应用于pt。
5.1.9组合赋值运算符
+=运算符将两个操作数相加，并将结果赋给左边的操作数。
这意味着左边的操作数必须能够被赋值，如变量、数组元素、结构成员或通过对指针解除引用来标识的数据。
组合赋值运算符包括+=、-=、*=、/=、%=。
5.1.10复合语句（语句块）
复合语句（代码块）由一对花括号和它们包含的语句组成，复合语句（代码块）被视为一条语句。
例如，程序清单5.8中的程序使用花括号将3条语句合并为一个代码块。
程序清单5.8 block.cpp
#include <iostream>
#include <string>

using namespace std;

int main()
{
    cout << "Please enter five numbers:\n";
    double number = 0.0;
    double sum = 0.0;
    for (int i = 1; i <= 5; i++)
    {
        cout << "Value " << i << " : ";
        cin >> number;
        sum += number;
    }

    cout << "the sum of five numbers = " << sum << endl;
    cout << "the average of five numbers = " << sum / 5 << "\n";

    return 0;
}
显示结果如下
Please enter five numbers:
Value 1 : 5.1
Value 2 : 3.2
Value 3 : 6.3
Value 4 : 2.6
Value 5 : 7.2
the sum of five numbers = 24.4
the average of five numbers = 4.88

如果在复合语句（代码块）中定义一个新的变量，则仅当程序执行该代码块中的语句时，该变量才存在。执行完该代码块后，变量将被释放。
如果在一个代码块中声明一个变量，而外部语句块中也有一个这种名称的变量，在声明位置到内部语句块结束的范围之内，新变量将隐藏旧变量。
5.1.11 逗号运算符
假设有一个循环，每轮都将一个变量加1，而将另一个变量减1。
在for循环控制部分的更新部分中完成这两项工作将非常方便，但循环句法只允许这里包含一个表达式。
在这种情况下，可以使用逗号运算符将两个表达式合并为一个。
程序清单5.9在一个程序中使用了两次逗号运算符，该程序将一个string类对象的内容反转。
程序清单5.9 forstr2.cpp
#include <iostream>
#include <string>

using namespace std;

int main()
{
    cout << "Enter a word: ";
    string word;
    getline(cin, word, '\n');

    char temp;
    int i, j;
    for (i = 0, j = word.size() - 1; i < j; ++i, --j)
    {
        temp = word[j];
        word[j] = word[i];
        word[i] = temp;
    }
    cout << word << "\nDone\n";

    return 0;
}
显示结果如下
Enter a word: Hello, World!
!dlroW ,olleH
Done

逗号运算符确保先计算第一个表达式，然后计算第二个表达式（换句话说，逗号运算符是一个顺序点）。
逗号表达式的值是最后一个表达式的值。
5.1.12 关系表达式
C++提供了6种关系运算符来对数字进行比较。由于字符用其ASCII码表示，因此也可以将这些运算符用于字符。
不能将它们用于C风格字符串，但可用于string类对象。
对于所有的关系表达式，如果比较结果为真，则其值将为true，否则为false，因此可将其用作循环测试表达式。
关系运算符
<
<=
==
>
>=
!=
5.1.13 赋值、比较和可能犯的错误
不要混淆等于运算符（==）与赋值运算符（=）。
程序清单5.10：equal.cpp
#include <iostream>
#include <string>

using namespace std;

int main()
{
    int quizscores[10] = { 20, 20, 20, 20, 20, 19, 20, 18, 20, 20 };
    cout << "Doing it right:\n";
    int i;
    for (i = 0; quizscores[i] == 20; i++)
    {
        cout << "quiz " << i << " is a 20\n";
    }

    // for (i = 0; quizscores[i] = 20; i++)

    return 0;
}
显示结果如下
Doing it right:
quiz 0 is a 20
quiz 1 is a 20
quiz 2 is a 20
quiz 3 is a 20
quiz 4 is a 20

程序清单5.11 compstr1.cpp
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    char word[5] = "?ate";
    for (char ch = 'a'; strcmp(word, "mate"); ch++)
    {
        cout << word << endl;
        word[0] = ch;
    }
    cout << "After loop ends, word is " << word << endl;

    return 0;
}
显示结果如下
?ate
aate
bate
cate
date
eate
fate
gate
hate
iate
jate
kate
late
After loop ends, word is mate

程序清单5.12 compstr2.cpp
#include <iostream>
#include <string>

using namespace std;

int main()
{
    string word = "?ate";
    for (char ch = 'a'; word != "mate"; ch++)
    {
        cout << word << endl;
        word[0] = ch;
    }
    cout << "After loop ends, word is " << word << endl;

    return 0;
}
显示结果如下
?ate
aate
bate
cate
date
eate
fate
gate
hate
iate
jate
kate
late
After loop ends, word is mate

5.2 while循环
while循环是没有初始化和更新部分的for循环，它只有测试条件和循环体：
while（test-condition）
    body
如果测试条件表达式为true，则执行循环体中的语句。
与for循环一样，循环体也由一条语句或两个花括号定义的复合语句组成。
执行完循环体后，程序返回测试条件，对它进行重新评估。如果该条件为非零，则再次执行循环体。
测试和执行将一直进行下去，直到测试条件为false为止（参见图5.3）。
显然，如果希望循环最终能够结束，循环体中的代码必须完成某种影响测试条件表达式的操作。
和for循环一样while循环也是一种入口条件循环。因此，如果测试条件一开始便为false，则程序将不会执行循环体。
程序清单5.13使用了一个while循环。该循环遍历字符串，并显示其中的字符及其ASCII码。循环在遇到空值字符时停止。
程序清单5.13 while.cpp
#include <iostream>
#include <string>

using namespace std;

const int ArSize = 128;

int main()
{
    char name[ArSize];

    cout << "Please enter your name: ";
    cin.getline(name, ArSize);

    cout << "Here is your name: \n";
    int i = 0;
    while (name[i] != '\0')
    {
        cout << name[i] << ": " << int (name[i]) << endl;
        i++;
    }

    return 0;
}
显示结果如下
Please enter your name: Peter Smith
Here is your name:
P: 80
e: 101
t: 116
e: 101
r: 114
 : 32
S: 83
m: 109
i: 105
t: 116
h: 104

for循环的3个表达式可以是空表达式，只有两个分号是必需的。如果省略for循环中的测试表达式，测试结果将一直为true。
5.2.2 编写延时循环
程序清单5.14演示了如何使用clock和头ctime来创建延迟循环。
程序清单5.14 waiting.cpp
#include <iostream>
#include <ctime>

using namespace std;

int main()
{
    cout << "Enter the delay time, in seconds: ";
    double sees;
    cin >> sees;
    clock_t delay = sees * CLOCKS_PER_SEC;
    cout << "starting\n";
    clock_t start = clock();
    while (clock() - start < delay)
        ;
    cout << "done\n";

    return 0;
}
显示结果如下
Enter the delay time, in seconds: 8
starting
done

C++为类型建立别名的方式有两种。
一种是使用预处理器：
#define BYTE char
这样，预处理器将在编译程序时用char替换所有的BYTE，从而使BYTE成为char的别名。
第二种方法是使用关键字typedef来创建别名。例如，要将byte作为char的别名，可以这样做：
typedef char byte
下面是通用格式：
typedef typeName aliasName
5.3 do while循环
do while循环是出口条件（exit condition）循环。do while循环首先执行循环体，然后再判定测试表达式，决定是否应继续执行循环。
如果条件为false，则循环终止；否则，进入新一轮的执行和测试。
这样的循环通常至少执行一次，因为其程序流必须经过循环体后才能到达测试条件。
do
    body
while (test-expression);
程序清单5.15：dowhile.cpp
#include <iostream>

using namespace std;

int main()
{
    int n = 0;
    cout << "Enter numbers in the range 1-10 to find my favorite number\n";
    do
    {
        cin >> n;
    }
    while (n != 7);
    cout << "Yes, 7 is my favorite. \n";

    return 0;
}
显示结果如下
Enter numbers in the range 1-10 to find my favorite number
1
3
5
7
Yes, 7 is my favorite.

5.4 基于范围的for循环（C++11）
C++11新增了一种循环：基于范围（range-based）的for循环。
这简化了对数组（vector和array）的每个元素执行相同的操作，如下例所示：
double prices[5] = {4.99, 10.99, 6.87, 7.99, 8.49};

for (double x : prices)
{
    cout << x << '\n';
}
for循环显示数组中的每个值。
要修改数组的元素，需要使用不同的循环变量语法：
for (double &x : prices)
{
    x = х * 0.80;
}
符号&表明x是一个引用变量，这个主题将在第8章讨论。
就这里而言，这种声明让接下来的代码能够修改数组的内容，而第一种语法不能。
还可结合使用基于范围的for循环和初始化列表：
for ( int  x : {3, 5, 2, 8, 6} )
{
    cout << x << ' ';
}
cout << '\n';

#include <iostream>

using namespace std;

int main()
{
    int i;

    double prices[5] = {4.99, 10.99, 6.87, 7.99, 8.49};

    for (double x : prices)
    {
        cout << x << '\n';
    }

    cout << '\n';

    for (double &x : prices)
    {
        x = x * 0.80;
    }

    for (double x : prices)
    {
        cout << x << '\n';
    }

    cout << '\n';

    for ( int  x :
            {
                3, 5, 2, 8, 6
            } )
    {
        cout << x << ' ';
    }
    cout << '\n';

    return 0;
}
显示结果如下
4.99
10.99
6.87
7.99
8.49

3.992
8.792
5.496
6.392
6.792

3 5 2 8 6

5.5 循环和文本输入
5.5.1 使用原始的cin进行输入
如果程序要使用循环来读取来自键盘的文本输入，则必须有办法知道何时停止读取。
如何知道这一点呢？一种方法是选择某个特殊字符，将其作为停止标记。
例如，程序清单5.16在遇到#字符时停止读取输入。该程序计算读取的字符数，并回显这些字符，即在屏幕上显示读取的字符。
按下键盘上的键不能自动将字符显示到屏幕上，程序必须通过回显输入字符来完成这项正作。
通常，这种任务由操作系统处理。运行完毕后，该程序将报告处理的总字符数。程序清单5.16列出了该程序的代码。
程序清单5.16 textin1.cpp
#include <iostream>

using namespace std;

int main()
{
    char ch;
    int count = 0;
    cout << "Enter characters; enter # to quit:\n";
    cin >> ch;
    while (ch != '#')
    {
        cout << ch;
        ++count;
        cin >> ch;
    }
    cout << '\n' << count << " characters read.\n";

    return 0;
}
显示结果如下
Enter characters; enter # to quit:
Hello, World!#
Hello,World!
12 characters read.

5.5.2 使用cin.get（char）进行补救
通常，逐个字符读取输入的程序需要检查每个字符，包括空格、制表符和换行符。
cin所属的istream类（在iostream中定义）中包含一个能够满足这种要求的成员函数。
具体地说，成员函数cin.get（ch）读取输入中的下一个字符（即使它是空格），并将其赋给变量ch。
使用这个函数调用替换cin >> ch，可以修补程序清单5.16的问题。程序清单5.17列出了修改后的代码。
程序清单5.17 textin2.cpp
#include <iostream>

using namespace std;

int main()
{
    char ch;
    int count = 0;
    cout << "Enter characters; enter # to quit:\n";
    cin.get(ch);
    while (ch != '#')
    {
        cout << ch;
        ++count;
        cin.get(ch);
    }
    cout << '\n' << count << " characters read.\n";

    return 0;
}
显示结果如下
Enter characters; enter # to quit:
Hello, World!#
Hello, World!
13 characters read.

cin.get可以接受两个参数：char *类型的地址和int类型的整数，也可以接收一个参数：char类型的引用，还可以不接受任何参数。
5.5.4 文件尾条件
程序清单5.17表明，使用诸如#等符号来表示输入结束很难令人满意，因为这样的符号可能就是合法输入的组成部分，其他符号（如@和%）也如此。
如果输入来自于文件，则可以使用一种功能更强大的技术――检测文件尾（EOF）。
很多操作系统都允许通过键盘来模拟文件尾条件。在Unix中，可以在行首按下Ctrl+D来实现。
检测到EOF后，cin将eofbit设置为1，可以通过成员函数eof来查看eofbit是否被设置。
如果检测到EOF，则cin.eof将返回bool值true，否则返回false。
注意，eof在读取到文件结尾后报告，而不是预先报告。因此应将cin.eof测试放在读取后。
程序清单5.18 textin3.cpp
#include <iostream>

using namespace std;

int main()
{
    char ch;
    int count = 0;
    cin.get(ch);
    while (cin.eof() == false)
    {
        cout << ch;
        ++count;
        cin.get(ch);
    }
    cout << '\n' << count << " characters read.\n";

    return 0;
}
显示结果如下
Hello, World!
Hello, World!

14 characters read.
注意程序读取了一个换行符

不接受任何参数的cin.get返回输入中的下一个字符。也就是说，可以这样使用它：
ch = cin.get();
该函数的工作方式与C语言中的getchar相似，将字符编码作为int返回，而cin.get(ch)返回一个对象，而不是读取的字符。
同样，可以使用cout.put函数来显示字符：
cout.put (ch);
该函数的工作方式类似C语言中的putchar，只不过其参数类型为char，而不是int。
当cin.get函数读取到文件结尾时，将返回一个用符号常量EOF表示的特殊值。该常量是在头文件iostream中定义的。
EOF值必须不同于任何有效的字符值，以便程序不会将EOF与常规字符混淆。
通常，EOF被定义为值-1，因为没有ASCII码为-1的字符，但并不需要知道实际的值，而只需在程序中使用EOF即可。
程序清单5.19将程序清单5.18进行了修改，使用了cin.get方法。
程序清单5.19 textin4.cpp
#include <iostream>

using namespace std;

int main()
{
    int ch;
    int count = 0;
    while ( ( ch = cin.get() ) != EOF )
    {
        cout.put( char (ch) );
        ++count;
    }
    cout << '\n' << count << " characters read.\n";

    return 0;
}
显示结果如下
Hello, World!
Hello, World!

14 characters read.

5.6嵌套循环和二维数组
到目前为止，本章使用的数组都是一维数组，因为每个数组都可以看作是一行数据。二维数组更像是一个表格――既有数据行又有数据列。
C++没有提供二维数组类型，但用户可以创建每个元素本身都是数组的数组。例如，假设要存储5个城市在4年间的最高温度。
在这种情况下，可以这样声明数组：
int maxtemps[4][5];
该声明意味着maxtemps是一个包含4个元素的数组，其中每个元素都是一个由5个整数组成的数组（参见图5.5）。
表达式maxtemps[0]是maxtemps数组的第一个元素，因此maxtemps[0]本身就是一个由5个int组成的数组。
maxtemps[0]数组的第一个元素是maxtemps[0][0]，该元素是一个int，因此，需要使用两个下标来访问int元素。
可以认为第一个下标表示行，第二个下标表示列（参见图5.6）。
假设要打印数组所有的内容，可以用一个for循环来改变行，用另一个被嵌套的for循环来改变列
for (int row = 0; row < 4; row++)
{
    for (int col =0; col < 5; ++col)
    {
        cout << maxtemps[row][col] << "\t";
    }
    cout << endl;
}
对于每个row值，内部的for循环将遍历所有的col值。
这个示例在每个值之后打印一个制表符，打印完每行后，打印一个换行符
5.6.1 初始化二维数组
int maxtemps[4][5] =
{
    {96, 100, 87, 101, 105},
    {96, 98, 91, 107, 104},
    {97, 101, 93, 108, 107},
    {98, 103, 95, 109, 108}
};
5.6.2 使用二维数组
程序清单5.20初始化了一个二维数组，并使用了一个嵌套循环。
程序清单5.20 nested.cpp
#include <iostream>

using namespace std;

const int Cities = 5;
const int Years = 4;

int main()
{
    const char *cities[Cities] =
    {
        "Gribble City",
        "Gribbletown",
        "New Gribble",
        "San Gribble",
        "Gribble Vista"
    };

    int maxtemps[Years][Cities] =
    {
        { 96, 100, 87, 101, 105 },
        { 96, 98, 91, 107, 104 },
        { 97, 101, 93, 108, 107 },
        { 98, 103, 95, 109, 108 }
    };

    cout << "Maximum temperatures for 2008 - 2011\n\n";
    for (int city = 0; city < Cities; ++city)
    {
        cout << cities[city] << ":\t";
        for (int year = 0; year < Years; ++year)
        {
            cout << maxtemps[year][city] << "\t";
        }
        cout << endl;
    }

    return 0;
}
显示结果如下
Maximum temperatures for 2008 - 2011

Gribble City:   96      96      97      98
Gribbletown:    100     98      101     103
New Gribble:    87      91      93      95
San Gribble:    101     107     108     109
Gribble Vista:  105     104     107     108

#include <iostream>
#include <array>
#include <string>

using namespace std;

const int Cities = 5;
const int Years = 4;

int main()
{
    const string cities[Cities] =
    {
        "Gribble City",
        "Gribbletown",
        "New Gribble",
        "San Gribble",
        "Gribble Vista"
    };

    array<array<int, Cities>, Years> maxtemps =
    {
        96, 100, 87, 101, 105,
        96, 98, 91, 107, 104,
        97, 101, 93, 108, 107,
        98, 103, 95, 109, 108
    };


    cout << "Maximum temperatures for 2008 - 2011\n\n";
    for (int city = 0; city < Cities; ++city)
    {
        cout << cities[city] << ":\t";
        for (int year = 0; year < Years; ++year)
        {
            cout << maxtemps[year][city] << "\t";
        }
        cout << endl;
    }

    return 0;
}
显示结果如下
Maximum temperatures for 2008 - 2011

Gribble City:   96      96      97      98
Gribbletown:    100     98      101     103
New Gribble:    87      91      93      95
San Gribble:    101     107     108     109
Gribble Vista:  105     104     107     108

5.7总结
C++提供了3种循环：for循环、while循环和do while循环。
如果循环测试条件为true或非零，则循环将重复执行一组指令；如果测试条件为false或0，则结束循环。
for循环和while循环都是入口条件循环，这意味着程序将在执行循环体中的语句之前检查测试条件。
do while循环是出口条件循环，这意味着其将在执行循环体中的语句之后检查条件。
每种循环都要求循环体由一条语句组成。然而，这条语句可以是复合语句（由花括号括起的多条语句）。
关系表达式对两个值进行比较，常被用作循环测试条件。
关系表达式是通过使用6种关系运算符之一构成的：<、<=、==、>、>=或!=。
关系表达式的结果为bool类型，值为true或false。
许多程序都逐字节地读取文本输入或文本文件，istream类提供了多种可完成这种工作的方法。
如果ch是一个char变量，则下面的语句将输入中的下一个字符读入到ch中：
cin >> ch;
然而，它将忽略空格、换行符和制表符。
下面的成员函数调用读取输入中的下一个字符（而不管该字符是什么）并将其存储到ch中：
cin.get (ch);
成员函数调用cin.get();返回下一个输入字符（包括空格、换行符和制表符），因此，可以这样使用它：
ch = cin.get();
cin.get(char)通过返回转换为false的bool值来指出已到达EOF（fstream类重载了bool操作符），
而cin.get通过返回EOF值来指出已到达EOF，EOF是在文件iostream中定义的。
嵌套循环适合用于处理多维数组。
5.8 复习题
1.入口条件循环和出口条件循环之间的区别是什么？各种C++循环分别属于其中的哪一种？
入口条件循环在进入输入循环体之前评估测试表达式。如果条件最初为false，则循环不会执行其循环体。
出口条件循环在处理循环体之后评估测试表达式。因此，即使测试表达式最初为false，循环也将执行一次。
for和while循环都是入口条件循环，而do while循环是出口条件循环。

2.如果下面的代码片段是有效程序的组成部分，它将打印什么内容？
int i;
for(i = 0; i < 5; i++)
    cout << i;
    cout << endl;

01234

注意，cout<< endl;不是循环体的组成部分

3.如果下面的代码片段是有效程序的组成部分，它将打印什么内容？
int j;
for (j = 0; j < 11; j += 3)
    cout << j;
cout << endl << j << endl;

0369
12

4.如果下面的代码片段是有效程序的组成部分，它将打印什么内容？
int j = 5;
while (++j < 9)
    cout << j++ << endl;

6
8

5・如果下面的代码片段是有效程序的组成部分，它将打印什么内容？
int k = 8;
do
    cout << "k = " << k << endl;
while (k++ < 5);

k = 8

6.编写一个打印1、2、4、8、16、32、64的for循环，每轮循环都将计数变量的值乘以2。

for (int i = 1; i <= 64; i *= 2)
{
    cout << i << ' ';
}
cout << '\n';

7.如何在循环体中包括多条语句？

将多条语句放在一对大括号中将形成一个复合语句或代码块。

8.下面的语句是否有效？如果无效，原因是什么？如果有效，它将完成什么工作？
int x = (1, 024);
下面的语句又如何呢？
int y;
y = 1, 024;

int x = (1, 024);是有效的。表达式1, 024由两个表达式组成1和024，用逗号运算符连接。
表达式1, 024的值为右侧表达式024的值。024是八进制，换算成十进制就是20，因此该声明将值20赋给x。
y = 1, 024;是有效的。逗号运算符的优先级低于所有其他运算符，
因此y = 1, 024;相当于(y =1), 024;
也就是说，左侧表达式将y设置成1，整个表达式的值（没有使用）为024（八进制）。

9.在查看输入方面，cin>>ch同cn.get (ch)和ch = cin.get()有什么不同？

cin>> ch将跳过空格、换行符和制表符，其他两种格式将读取这些字符

5.9 编程练习
1.编写一个要求用户输入两个整数的程序。该程序将计算并输出这两个整数之间（包括这两个整数）所有整数的和。
这里假设先输入较小的整数。
#include <iostream>

int main()
{
    std::cout << "Enter a and b: ";
    int a = 0;
    int b = 0;
    std::cin >> a >> b;
    if (a > b)
    {
        return 0;
    }
    int result = 0;
    for (int i = a; i <= b; i++)
    {
        result += i;
    }
    std::cout << "Result: " << result << std::endl;

    return 0;
}
显示结果如下
Enter a and b: 2 9
Result: 44

2.使用array对象（而不是数组）和long double（而不是long long）重新编写程序清单5.4，并计算100!的值。
#include <iostream>
#include <array>

const int arr_size = 101;

int main()
{
    std::array<long double, arr_size> factorials;

    factorials[1] = factorials[0] = 1.0L;

    for (int i = 2; i < arr_size; i++)
    {
        factorials[i] = i * factorials[i - 1];
    }

    for (int i = 0; i < arr_size; i++)
    {
        std::cout << i << " ! = " << factorials[i] << std::endl;
    }

    return 0;
}
显示结果如下
0 ! = 1
1 ! = 1
2 ! = 2
3 ! = 6
4 ! = 24
5 ! = 120
6 ! = 720
7 ! = 5040
8 ! = 40320
9 ! = 362880
10 ! = 3.6288e+06
11 ! = 3.99168e+07
12 ! = 4.79002e+08
13 ! = 6.22702e+09
14 ! = 8.71783e+10
15 ! = 1.30767e+12
16 ! = 2.09228e+13
17 ! = 3.55687e+14
18 ! = 6.40237e+15
19 ! = 1.21645e+17
20 ! = 2.4329e+18
21 ! = 5.10909e+19
22 ! = 1.124e+21
23 ! = 2.5852e+22
24 ! = 6.20448e+23
25 ! = 1.55112e+25
26 ! = 4.03291e+26
27 ! = 1.08889e+28
28 ! = 3.04888e+29
29 ! = 8.84176e+30
30 ! = 2.65253e+32
31 ! = 8.22284e+33
32 ! = 2.63131e+35
33 ! = 8.68332e+36
34 ! = 2.95233e+38
35 ! = 1.03331e+40
36 ! = 3.71993e+41
37 ! = 1.37638e+43
38 ! = 5.23023e+44
39 ! = 2.03979e+46
40 ! = 8.15915e+47
41 ! = 3.34525e+49
42 ! = 1.40501e+51
43 ! = 6.04153e+52
44 ! = 2.65827e+54
45 ! = 1.19622e+56
46 ! = 5.50262e+57
47 ! = 2.58623e+59
48 ! = 1.24139e+61
49 ! = 6.08282e+62
50 ! = 3.04141e+64
51 ! = 1.55112e+66
52 ! = 8.06582e+67
53 ! = 4.27488e+69
54 ! = 2.30844e+71
55 ! = 1.26964e+73
56 ! = 7.10999e+74
57 ! = 4.05269e+76
58 ! = 2.35056e+78
59 ! = 1.38683e+80
60 ! = 8.32099e+81
61 ! = 5.0758e+83
62 ! = 3.147e+85
63 ! = 1.98261e+87
64 ! = 1.26887e+89
65 ! = 8.24765e+90
66 ! = 5.44345e+92
67 ! = 3.64711e+94
68 ! = 2.48004e+96
69 ! = 1.71122e+98
70 ! = 1.19786e+100
71 ! = 8.50479e+101
72 ! = 6.12345e+103
73 ! = 4.47012e+105
74 ! = 3.30789e+107
75 ! = 2.48091e+109
76 ! = 1.88549e+111
77 ! = 1.45183e+113
78 ! = 1.13243e+115
79 ! = 8.94618e+116
80 ! = 7.15695e+118
81 ! = 5.79713e+120
82 ! = 4.75364e+122
83 ! = 3.94552e+124
84 ! = 3.31424e+126
85 ! = 2.8171e+128
86 ! = 2.42271e+130
87 ! = 2.10776e+132
88 ! = 1.85483e+134
89 ! = 1.6508e+136
90 ! = 1.48572e+138
91 ! = 1.352e+140
92 ! = 1.24384e+142
93 ! = 1.15677e+144
94 ! = 1.08737e+146
95 ! = 1.033e+148
96 ! = 9.91678e+149
97 ! = 9.61928e+151
98 ! = 9.42689e+153
99 ! = 9.33262e+155
100 ! = 9.33262e+157

3.编写一个要求用户输入数字的程序。每次输入后，程序都将报告到目前为止，所有输入的累计和。
当用户输入0时，程序结束。
#include <iostream>

int main()
{
    long long result = 0;
    long long a;

    do
    {
        std::cout << "Enter number: ";
        a = 0;
        std::cin >> a;
        result += a;
        std::cout << "sum = " << result << std::endl;
    }
    while (a != 0);

    return 0;
}
显示结果如下
Enter number: 1
sum = 1
Enter number: 11
sum = 12
Enter number: 111
sum = 123
Enter number: 1111
sum = 1234
Enter number: 11111
sum = 12345
Enter number: 111111
sum = 123456
Enter number: 0
sum = 123456

4.Daphne以10%的单利投资了100美元。也就是说，每一年的利润都是投资额的10%，即每年10美元。
而Cleo以5%的复利投资了100美元。也就是说，利息是当前存款（包括获得的利息）的5%。
请编写一个程序，计算多少年后，Cleo的投资价值才能超过Daphne的投资价值，并显示此时两个人的投资价值。
#include <iostream>

int main()
{
    double daphne = 100;
    double cleo = 100;
    int age = 0;

    std::cout << "Balance Daphne: " << daphne << std::endl;
    std::cout << "Balance Cleo: " << cleo << std::endl;
    std::cout << std::endl;

    do
    {
        daphne += 0.10 * 100;
        cleo += 0.05 * cleo;
        age++;

        std::cout << "Balance Daphne: " << daphne << std::endl;
        std::cout << "Balance Cleo: " << cleo << std::endl;
        std::cout << "Years passed: " << age << std::endl;

        std::cout << std::endl;
    }
    while (cleo <= daphne);

    return 0;
}
显示结果如下

Balance Daphne: 100
Balance Cleo: 100

Balance Daphne: 110
Balance Cleo: 105
Years passed: 1

Balance Daphne: 120
Balance Cleo: 110.25
Years passed: 2

Balance Daphne: 130
Balance Cleo: 115.763
Years passed: 3

Balance Daphne: 140
Balance Cleo: 121.551
Years passed: 4

Balance Daphne: 150
Balance Cleo: 127.628
Years passed: 5

Balance Daphne: 160
Balance Cleo: 134.01
Years passed: 6

Balance Daphne: 170
Balance Cleo: 140.71
Years passed: 7

Balance Daphne: 180
Balance Cleo: 147.746
Years passed: 8

Balance Daphne: 190
Balance Cleo: 155.133
Years passed: 9

Balance Daphne: 200
Balance Cleo: 162.889
Years passed: 10

Balance Daphne: 210
Balance Cleo: 171.034
Years passed: 11

Balance Daphne: 220
Balance Cleo: 179.586
Years passed: 12

Balance Daphne: 230
Balance Cleo: 188.565
Years passed: 13

Balance Daphne: 240
Balance Cleo: 197.993
Years passed: 14

Balance Daphne: 250
Balance Cleo: 207.893
Years passed: 15

Balance Daphne: 260
Balance Cleo: 218.287
Years passed: 16

Balance Daphne: 270
Balance Cleo: 229.202
Years passed: 17

Balance Daphne: 280
Balance Cleo: 240.662
Years passed: 18

Balance Daphne: 290
Balance Cleo: 252.695
Years passed: 19

Balance Daphne: 300
Balance Cleo: 265.33
Years passed: 20

Balance Daphne: 310
Balance Cleo: 278.596
Years passed: 21

Balance Daphne: 320
Balance Cleo: 292.526
Years passed: 22

Balance Daphne: 330
Balance Cleo: 307.152
Years passed: 23

Balance Daphne: 340
Balance Cleo: 322.51
Years passed: 24

Balance Daphne: 350
Balance Cleo: 338.635
Years passed: 25

Balance Daphne: 360
Balance Cleo: 355.567
Years passed: 26

Balance Daphne: 370
Balance Cleo: 373.346
Years passed: 27

5.假设要销售一本书。请编写一个程序，输入这本书全年中每个月的销售数量，
程序通过循环，使用初始化为月份字符串的char*数组（或string对象数组）逐月进行提示，
并将输入的数据储存在一个int数组中。然后，程序计算数组中各元素的总数，并报告这一年的销售情况。
#include <iostream>
#include <string>

int main()
{
    std::string month[12] =
    {
        "January", "February", "March",
        "April", "May", "June",
        "July", "August", "September",
        "October", "November", "December"
    };

    int total_book = 0;
    int array_book_sold[12];

    for (int i = 0; i < 12; i++)
    {
        std::cout << "Enter the number of books sold for: " << month[i] << std::endl;
        std::cin >> array_book_sold[i];

        total_book += array_book_sold[i];
    }
    std::cout << "Total books sold: " << total_book << std::endl;

    return 0;
}
显示结果如下
Enter the number of books sold for: January
12
Enter the number of books sold for: February
23
Enter the number of books sold for: March
34
Enter the number of books sold for: April
45
Enter the number of books sold for: May
56
Enter the number of books sold for: June
67
Enter the number of books sold for: July
78
Enter the number of books sold for: August
89
Enter the number of books sold for: September
90
Enter the number of books sold for: October
101
Enter the number of books sold for: November
112
Enter the number of books sold for: December
123
Total books sold: 830


6.完成编程练习5，但这一次使用一个二维数组来存储输入3年中每个月的销售量。
程序将报告每年销售量以及三年的总销售量。
#include <iostream>
#include <string>

int main()
{
    std::string months[12] =
    {
        "January", "February", "March",
        "April", "May", "June",
        "July", "August", "September",
        "October", "November", "December"
    };

    int value[3][12] = { 0 };
    int total_book = 0;

    for (int i = 0; i < 3; i++)
    {

        int total_book_year = 0;
        std::cout << i + 1 << " year" << std::endl;

        for (int j = 0; j < 12; j++)
        {
            std::cout << "Enter the number of books sold for: " << months[j] + " : ";
            std::cin >> value[i][j];
            total_book_year += value[i][j];
        }
        std::cout << "Total books sold year: " << total_book_year << std::endl;
        total_book += total_book_year;
    }
    std::cout << "Total books sold: " << total_book << std::endl;

    return 0;
}
显示结果如下
1 year
Enter the number of books sold for: January : 11
Enter the number of books sold for: February : 11
Enter the number of books sold for: March : 11
Enter the number of books sold for: April : 22
Enter the number of books sold for: May : 2
Enter the number of books sold for: June : ^C
[weiyayun@weiyayun-PC code]$ ch05_p06
1 year
Enter the number of books sold for: January : 11
Enter the number of books sold for: February : 11
Enter the number of books sold for: March : 11
Enter the number of books sold for: April : 22
Enter the number of books sold for: May : 22
Enter the number of books sold for: June : 22
Enter the number of books sold for: July : 33
Enter the number of books sold for: August : 33
Enter the number of books sold for: September : 33
Enter the number of books sold for: October : 123
Enter the number of books sold for: November : 123
Enter the number of books sold for: December : 123
Total books sold year: 567
2 year
Enter the number of books sold for: January : 111
Enter the number of books sold for: February : 111
Enter the number of books sold for: March : 111
Enter the number of books sold for: April : 222
Enter the number of books sold for: May : 222
Enter the number of books sold for: June : 222
Enter the number of books sold for: July : 333
Enter the number of books sold for: August : 333
Enter the number of books sold for: September : 333
Enter the number of books sold for: October : 666
Enter the number of books sold for: November : 666
Enter the number of books sold for: December : 666
Total books sold year: 3996
3 year
Enter the number of books sold for: January : 1111
Enter the number of books sold for: February : 1111
Enter the number of books sold for: March : 1111
Enter the number of books sold for: April : 2222
Enter the number of books sold for: May : 2222
Enter the number of books sold for: June : 2222
Enter the number of books sold for: July : 3333
Enter the number of books sold for: August : 3333
Enter the number of books sold for: September : 3333
Enter the number of books sold for: October : 5678
Enter the number of books sold for: November : 5678
Enter the number of books sold for: December : 5678
Total books sold year: 37032
Total books sold: 41595

7.设计一个名为car的结构，用它存储下述有关汽车的信息：
生产商（存储在字符数组或string对象中的字符串）、生产年份（整数）。
编写一个程序，向用户询问有多少辆汽车。随后，程序使用new来创建个由相应数量的car结构组成的动态数组。
接下来，程序提示用户输入每辆车的生产商（可能由多个单词组成）和年份信息。
请注意，这需要特别小心，因为它将交替读取数值和字往串（参见第4章），最后，程序将显示每个结构的内容。
#include <iostream>
#include <string>

struct car
{
    std::string name;
    int age;
};

int main()
{
    std::cout << "Enter the number of machines that you want to catalog: ";
    int array_count;
    (std::cin >> array_count).get();

    car *ptr = new car[array_count];
    for (int i = 0; i < array_count; i++)
    {
        std::cout << "Car " << i + 1 << std::endl;
        std::cout << "Enter the manufacturer: ";
        std::getline(std::cin, ptr[i].name, '\n');
        std::cout << "Please enter the year of manufacture: ";
        (std::cin >> ptr[i].age).get();
    }

    std::cout << "Here is your collection:" << std::endl;

    for (int j = 0; j < array_count; j++)
    {
        std::cout << ptr[j].age << " : " << ptr[j].name << std::endl;
    }
    delete[] ptr;

    return 0;
}
显示结果如下
Enter the number of machines that you want to catalog: 3
Car 1
Enter the manufacturer: Peter Smith
Please enter the year of manufacture: 2003
Car 2
Enter the manufacturer: Hello World
Please enter the year of manufacture: 2006
Car 3
Enter the manufacturer: Mike Pence
Please enter the year of manufacture: 2009
Here is your collection:
2003 : Peter Smith
2006 : Hello World
2009 : Mike Pence

8.编写一个程序，它使用一个char数组和循环来每次读取一个单词，直到用户输入done为止。
随后该程序指出用户输入了多少个单词（不包括done在内）。
#include <iostream>
#include <cstring>
#include <string>

int main()
{
    char exit_word[8] = "done";
    char word[128];
    int count = 0;

    std::cout << "Type in the words (to complete, enter the word done): " << std::endl;

    do
    {
        if (std::cin >> word)
        {
            std::cout << word << std::endl;
            count++;
        }
        else
        {
            std::cout << "You entered " << count << " words." << std::endl;
            return 0;
        }
    }
    while (strcmp(word, exit_word));

    std::cout << "You entered " << count - 1 << " words." << std::endl;

    return 0;
}
显示结果如下
Type in the words (to complete, enter the word done):
Hello World Peter Smith Mike Pence
Hello
World
Peter
Smith
Mike
Pence
You entered 6 words.

Type in the words (to complete, enter the word done):
Hello World Peter Smith Mike Pence done
Hello
World
Peter
Smith
Mike
Pence
done
You entered 6 words.

9.编写一个满足前一个练习中描述的程序，但使用string对象而不是字符数组。
#include <iostream>
#include <string>

int main()
{
    std::string exit_word = "done";
    std::string word;
    int count = 0;

    std::cout << "Type in the words (to complete, enter the word done): " << std::endl;

    do
    {
        if (std::cin >> word)
        {
            std::cout << word << std::endl;
            count++;
        }
        else
        {
            std::cout << "You entered " << count << " words." << std::endl;
            return 0;
        }
    }
    while (word != exit_word);

    std::cout << "You entered " << count - 1 << " words." << std::endl;

    return 0;
}
显示结果如下
Type in the words (to complete, enter the word done):
Hello World Peter Smith Mike Pence
Hello
World
Peter
Smith
Mike
Pence
You entered 6 words.

Type in the words (to complete, enter the word done):
Hello World Peter Smith Mike Pence done
Hello
World
Peter
Smith
Mike
Pence
done
You entered 6 words.

10.编写一个使用嵌套循环的程序，要求用户输入一个值，指出要显示多少行。
然后，程序将显示相应行数的星号，其中第一行包括一个星号，第二行包括两个星号，依此类推。
每一行包含的字符数等于用户指定的行数，在星号不够的情况下，在星号前面加上句点。
#include <iostream>
#include <string>

int main()
{
    std::string dot = ".";
    std::string star = "*";

    std::cout << "Enter the number of rows: ";
    int count = 0;
    std::cin >> count;

    if (count <= 0)
    {
        return 0;
    }

    for (int i = 1; i <= count; i++)
    {
        for (int j = 0; j < count - i; j++)
        {
            std::cout << dot;
        }
        for (int j = 0; j < i; j++)
        {
            std::cout << star;
        }
        std::cout << std::endl;
    }

    return 0;
}
显示结果如下
Enter the number of rows: 5
....*
...**
..***
.****
*****

第6章 分支语句和逻辑运算符
6.1 if语句
6.1.1 if else语句
6.1.2 格式化if else语句
6.1.3 if else if else结构
6.2 逻辑表达式.
6.2.1 逻辑OR运算符：||
6.2.2 逻辑AND运算符：&&
6.2.3 用&&来设置取值范围
6.2.4 逻辑NOT运算符：!
6.2.5 逻辑运算符细节
6.2.6 其他表示方式
6.3 字符函数库cctype
6.4 ? : 运算符
6.5 switch语句
6.5.1 将枚举量用作标签
6.5.2 switch和if else
6.6 break和continue语句
6.7 读取数字的循环
6.8 简单文件输入/输出
6.8.1 文本I/O和文本文件
6.8.2 写入到文本文件中
6.8.3 读取文本文件
6.9 总结
6.10 复习题
6.11 编程练习
本章内容包括：
if语句。
if else语句。
逻辑运算符：&&、||和!。
cctype字符函数库
条件运算符 ? :
switch语句。
continue和break语句。
读取数字的循环。
基本文件输入/输出。
6.1 if语句
if（test-condition）
    statement
如果test-condition（测试条件）为true，则程序将执行statement（语句），后者既可以是一条语句，也可以是符合语句。
如果测试条件为false，则程序将跳过语句（参见图6.1）。
和循环测试条件一样，if测试条件也将被强制转换为bool值，因此0将被转换为false，非零为true，整个if语句被视为一条语句。
程序清单6.1 if.cpp
#include <iostream>

using namespace std;

int main()
{
    char ch;
    int spaces = 0;
    int total = 0;
    cin.get(ch);
    while (ch != '.')
    {
        if (ch == ' ')
        {
            ++spaces;
        }
        ++total;
        cin.get(ch);
    }
    cout << spaces << " spaces, " << total << " characters total in sentence\n";

    return 0;
}
显示结果如下
Hello, World! Peter Smith.
3 spaces, 25 characters total in sentence

程序清单6.2 ifelse.cpp
#include <iostream>

int main()
{
    char ch;
    std::cout << "Type, and I shall repeat.\n";
    std::cin.get(ch);
    while (ch != '.')
    {
        if (ch == '\n')
        {
            std::cout << ch;
        }
        else
        {
            std::cout << ++ch;
        }
        std::cin.get(ch);
    }
    std::cout << "\nDone.\n";

    return 0;
}
显示结果如下
Type, and I shall repeat.
Hello, World!.
Ifmmp-!Xpsme"
Done.

程序清单6.3 ifelseif.cpp
#include <iostream>

using namespace std;

const int Fave = 27;

int main()
{
    int n;
    cout << "Enter a number in the range 1-100 to find my favorite number: ";
    do
    {
        n = 0;
        cin >> n;
        if (n < Fave)
        {
            cout << "Too low -- guess again: ";
        }
        else if (n > Fave)
        {
            cout << "Too high -- guess again: ";
        }
        else
        {
            cout << Fave << " is right! \n";
        }
    }
    while (n != Fave);

    return 0;
}
显示结果如下
Enter a number in the range 1-100 to find my favorite number: 11
Too low -- guess again: 33
Too high -- guess again: 22
Too low -- guess again: 30
Too high -- guess again: 26
Too low -- guess again: 28
Too high -- guess again: 27
27 is right!

6.2逻辑表达式
6.2.1 逻辑OR运算符：||
||运算符的优先级比关系运算符低。||运算符是个顺序点（sequence point），||运算符左边的子表达式先于右边的子表达式。
如果左侧的表达式为true，则C++将不会去判定右侧的表达式，因为只要一个表达式为true，则整个逻辑表达式为true。
程序清单6.4在一条if语句中使用||运算符来检查某个字符的大写或小写。
程序清单6.4 or.cpp
#include <iostream>

using namespace std;

int main()
{
    cout << "This program may reformat your hard disk and destroy all your data.\n";
    cout << "Do you wish to continue? <y/n> ";
    char ch;
    cin >> ch;
    if (ch == 'y' || ch == 'Y')
    {
        cout << "You were warned!\n";
    }
    else if (ch == 'n' || ch == 'N')
    {
        cout << "A wise choice, bye.\n";
    }
    else
    {
        cout << "please enter a y or n\n";
    }

    return 0;
}
显示结果如下
This program may reformat your hard disk and destroy all your data.
Do you wish to continue? <y/n> y
You were warned!

This program may reformat your hard disk and destroy all your data.
Do you wish to continue? <y/n> n
A wise choice, bye.

This program may reformat your hard disk and destroy all your data.
Do you wish to continue? <y/n> a
please enter a y or n

6.2.2 逻辑AND运算符：&&
&&运算符的优先级比关系运算符低。&&运算符也是顺序点，&&运算符左边的子表达式先于右边的子表达式。
首先判定左侧，并且在右侧被判定之前产生所有的副作用。
如果左侧为false，则整个逻辑表达式必定为false，在这种情况下，C++将不会再对右侧进行判定。
程序清单6.5 and.cpp
#include <iostream>

using namespace std;

const int ArSize = 6;

int main()
{
    double naaq[ArSize];
    cout << "Enter the NAAQs (New Age Awareness Quotients) of your neighbors.\n";
    cout << "Program terminates when you make " << ArSize << " entries "
         << "or enter a negative value.\n";

    int i = 0;
    double temp;
    cout << "First value: ";
    cin >> temp;
    while (i < ArSize && temp >= 0)
    {
        naaq[i] = temp;
        ++i;
        if (i < ArSize)
        {
            cout << "Next value: ";
            cin >> temp;
        }
    }
    if (i == 0)
    {
        cout << "No data, bye.\n";
    }
    else
    {
        cout << "Enter your NAAQ: ";
        double you;
        cin >> you;
        int count = 0;
        for (int j = 0; j < i; j++)
        {
            if (naaq[j] > you)
            {
                ++count;
            }
        }
        cout << count << " of your neighbors have greater awareness of the New Age than you do.\n";
    }

    return 0;
}
显示结果如下
Enter the NAAQs (New Age Awareness Quotients) of your neighbors.
Program terminates when you make 6 entries or enter a negative value.
First value: 1.1
Next value: 2.2
Next value: 3.3
Next value: 4.4
Next value: 5.5
Next value: -1.1
Enter your NAAQ: 2.6
3 of your neighbors have greater awareness of the New Age than you do.

程序清单6.6 moreand.cpp
#include <iostream>

using namespace std;

const char *qualify[4] =
{
    "10,000-meter race.\n",
    "mud tug-of-war.\n",
    "masters canoe jousting.\n",
    "pie-throwing festival.\n"
};

int main()
{
    int age;
    cout << "Enter your age in years: ";
    cin >> age;
    int index;

    if (age > 17 && age < 35)
    {
        index = 0;
    }
    else if (age >= 35 && age < 50)
    {
        index = 1;
    }
    else if (age >= 50 && age < 65)
    {
        index = 2;
    }
    else
    {
        index = 3;
    }

    cout << "You qualify for the " << qualify[index];

    return 0;
}
显示结果如下

Enter your age in years: 29
You qualify for the 10,000-meter race.

Enter your age in years: 39
You qualify for the mud tug-of-war.

Enter your age in years: 53
You qualify for the masters canoe jousting.

Enter your age in years: 69
You qualify for the pie-throwing festival.

6.2.4逻辑 NOT运算符：!
!运算符将它后面的表达式的真值取反。也是说如果expression为true或非零，则! expression是false；
如果expression为false或零，则! expression 是true。
程序清单 6.7not.cpp
#include <iostream>
#include <climits>

using namespace std;

bool is_int(double x);

int main()
{
    double num;

    cout << "Please enter an integer value: ";
    num = 0;
    cin >> num;
    while (!is_int(num))
    {
        cout << "Out of range, please try again: ";
        num = 0;
        cin >> num;
    }
    int val = int(num);
    cout << "You've entered the integer " << val << "\nDone.\n";

    return 0;
}

bool is_int(double x)
{
    if (x <= INT_MAX && x >= INT_MIN)
    {
        return true;
    }
    else
    {
        return false;
    }
}
显示结果如下
Please enter an integer value: 123
You've entered the integer 123
Done.

Please enter an integer value: 12345678901
Out of range, please try again: 23
You've entered the integer 23
Done.

6.3字符面数库cctype
程序清单6.8 cctypes.cpp
#include <iostream>
#include <cctype>

using namespace std;

int main()
{
    cout << "Enter text for analysis, and type @ to terminate input.\n";
    char ch;
    int whitespace = 0;
    int digits = 0;
    int chars = 0;
    int punct = 0;
    int others = 0;

    cin.get(ch);
    while (ch != '@')
    {
        if (isalpha(ch))
        {
            chars++;
        }
        else if (isspace(ch))
        {
            whitespace++;
        }
        else if (isdigit(ch))
        {
            digits++;
        }
        else if (ispunct(ch))
        {
            punct++;
        }
        else
        {
            others++;
        }
        cin.get(ch);
    }
    cout << chars << " letters, "
         << whitespace << " whitespace, "
         << digits << " digits, "
         << punct << " punctuations, "
         << others << " others.\n";

    return 0;
}
显示结果如下
Enter text for analysis, and type @ to terminate input.
Hello, World!   123@
10 letters, 4 whitespace, 3 digits, 2 punctuations, 0 others.

6.4 ? : 运算符
程序清单6.9 condit.cpp
#include <iostream>

using namespace std;

int main() 
{
	int a, b;
	cout << "Enter two integers: ";
	cin >> a >> b;
	cout << "The larger of " << a << " and " << b;
	int c = a > b ? a : b;
	cout << " is " << c << endl;

	return 0;
}
显示结果如下
Enter two integers: 3 5
The larger of 3 and 5 is 5

Enter two integers: 5 3
The larger of 5 and 3 is 5

6.5 switch语句
switch语句的通用格式：
switch (integer-expression)
{
    case label1 : statement(s); break;
    case label2 : statement(s); break;
...
    default : statement(s); break;
}
程序清单6.10 switch.cpp
#include <iostream>

using namespace std;

void showmenu();
void report();
void comfort();

int main()
{
	showmenu();
	int choice;
               choice = 0;
	cin >> choice;
	while (choice != 5)
	{
		switch (choice)
		{
		case 1:   cout << "choose alarm\n";
			break;
		case 2:   report();
			break;
		case 3:   cout << "The boss was in all day.\n";
			break;
		case 4:   comfort();
			break;
		default:   cout << "That's not a choice.\n"; break;
		}
		showmenu();
                              choice = 0;
		cin >> choice;
	}
	cout << "Done.\n";

	return 0;
}

void showmenu()
{
	cout << "Please enter 1, 2, 3, 4, or 5:\n"
		"1) alarm           2) report\n"
		"3) alibi           4) comfort\n"
		"5) quit\n";
}

void report()
{
	cout << "It's been an excellent week for business.\n"
		"Sales are up 120%. Expenses are down 35%.\n";
}
void comfort()
{
	cout << "Your employees think you are the finest CEO\n"
		"in the industry. The board of directors think\n"
		"you are the finest CEO in the industry.\n";
}
显示结果如下
Please enter 1, 2, 3, 4, or 5:
1) alarm           2) report
3) alibi           4) comfort
5) quit
1
choose alarm
Please enter 1, 2, 3, 4, or 5:
1) alarm           2) report
3) alibi           4) comfort
5) quit
2
It's been an excellent week for business.
Sales are up 120%. Expenses are down 35%.
Please enter 1, 2, 3, 4, or 5:
1) alarm           2) report
3) alibi           4) comfort
5) quit
3
The boss was in all day.
Please enter 1, 2, 3, 4, or 5:
1) alarm           2) report
3) alibi           4) comfort
5) quit
4
Your employees think you are the finest CEO
in the industry. The board of directors think
you are the finest CEO in the industry.
Please enter 1, 2, 3, 4, or 5:
1) alarm           2) report
3) alibi           4) comfort
5) quit
5
Done.

程序清单6.11 enum.cpp
#include <iostream>

using namespace std;

enum { red, orange, yellow, green, blue, violet, indigo };

int main()
{

    cout << "Enter color code (0-6): ";
    int code = 0;
    cin >> code;
    while (code >= red && code <= indigo)
    {
        switch (code)
        {
        case red:
            cout << "Her lips were red.\n";
            break;
        case orange:
            cout << "Her hair was orange.\n";
            break;
        case yellow:
            cout << "Her shoes were yellow.\n";
            break;
        case green:
            cout << "Her nails were green.\n";
            break;
        case blue:
            cout << "Her sweatsuit was blue.\n";
            break;
        case violet:
            cout << "Her eyes were violet.\n";
            break;
        case indigo:
            cout << "Her mood was indigo.\n";
            break;
        default :
            cout << "code invalid\n";
            break;
        }
        cout << "Enter color code (0-6): ";
        code = 0;
        cin >> code;
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Enter color code (0-6): 0
Her lips were red.
Enter color code (0-6): 1
Her hair was orange.
Enter color code (0-6): 2
Her shoes were yellow.
Enter color code (0-6): 3
Her nails were green.
Enter color code (0-6): 4
Her sweatsuit was blue.
Enter color code (0-6): 5
Her eyes were violet.
Enter color code (0-6): 6
Her mood was indigo.
Enter color code (0-6): 7
Done.

6.6 break和continue语句
可以在switch语句或任何循环中使用break语句，使程序跳到switch或循环后面的语句处执行。
continue语句用于循环中，让程序跳过循环体余下的代码，并开始新一轮循环（参见图6.4）。
程序清单6.12 jump.cpp
#include <iostream>

using namespace std;

const int ArSize = 128;

int main()
{
    char line[ArSize] = {0};
    int spaces = 0;

    cout << "Enter a line of text:\n";
    cin.get(line, ArSize);
    cin.get();
    cout << "Complete line:\n" << line << endl;
    cout << "Line through first period:\n";
    for (int i = 0; line[i] != '\0'; i++)
    {
        cout << line[i];
        if (line[i] == '.')
        {
            break;
        }
        if (line[i] != ' ')
        {
            continue;
        }
        spaces++;
    }
    cout << "\n" << spaces << " spaces\n";
    cout << "Done.\n";

    return 0;
}
显示结果如下
Enter a line of text:
a b c d e f g 123. h i j k l m n.
Complete line:
a b c d e f g 123. h i j k l m n.
Line through first period:
a b c d e f g 123.
7 spaces
Done.

程序清单6.13 cinfish.cpp
#include <iostream>

using namespace std;

const int Max = 5;

int main()
{
    double fish[Max];
    cout << "Please enter the weights of your fish.\n";
    cout << "You may enter up to " << Max << " fish or enter q to terminate.\n";
    cout << "fish #1: ";
    int i = 0;
    while (i < Max && cin >> fish[i])
    {
        if (++i < Max)
        {
            cout << "fish #" << i + 1 << ": ";
        }
    }
    cin.clear();
    double total = 0.0;
    for (int j = 0; j < i; j++)
    {
        total += fish[j];
    }

    if (i == 0)
    {
        cout << "No fish, bye.\n";
    }
    else
    {
        cout << "average weight of " << i << " fish = "  << total / i << endl;
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Please enter the weights of your fish.
You may enter up to 5 fish or enter q to terminate.
fish #1: 1.2
fish #2: 1.5
fish #3: 1.6
fish #4: q
average weight of 3 fish = 1.43333
Done.

程序清单6.14 cingolf.cpp
#include <iostream>

using namespace std;

const int Max = 5;

int main()
{
    double golf[Max];
    cout << "Please enter your golf scores.\n";
    cout << "You must enter " << Max << " rounds.\n";
    int i;
    for (i = 0; i < Max; i++)
    {
        cout << "round #" << i + 1 << ": ";
        while (!(cin >> golf[i]))
        {
            cin.clear();
            while (cin.get() != '\n')
            {
                continue;
            }
            cout << "Please enter a number: ";
        }
        while (cin.get() != '\n')
        {
            continue;
        }
    }

    double total = 0.0;
    for (i = 0; i < Max; i++)
    {
        total += golf[i];
    }

    cout << "average score of " << Max << " rounds = " << total / Max << endl;

    return 0;
}
显示结果如下
Please enter your golf scores.
You must enter 5 rounds.
round #1: 1.1
round #2: 2.2
round #3: 3.3
round #4: 4.4
round #5: 5.5
average score of 5 rounds = 3.3

6.8简单文件输入/输出
程序清单6.15 outfile.cpp
#include <iostream>
#include <fstream>

using namespace std;

int main()
{
	char automobile[128];
	int year;
	double a_price;
	double d_price;

	ofstream outFile;
	outFile.open("carinfo.txt");

	cout << "Enter the make and model of automobile: ";
	cin.getline(automobile, 128);
	cout << "Enter the model year: ";
	cin >> year;
	cout << "Enter the original asking price: ";
	cin >> a_price;
	d_price = 0.913 * a_price;

	cout << fixed;
	cout.precision(2);
	cout.setf(ios_base::showpoint);
	cout << "Make and model: " << automobile << endl;
	cout << "Year: " << year << endl;
	cout << "Was asking $" << a_price << endl;
	cout << "Now asking $" << d_price << endl;

	outFile << fixed;
	outFile.precision(2);
	outFile.setf(ios_base::showpoint);
	outFile << "Make and model: " << automobile << endl;
	outFile << "Year: " << year << endl;
	outFile << "Was asking $" << a_price << endl;
	outFile << "Now asking $" << d_price << endl;

	outFile.close();

	return 0;
}
显示结果如下
Enter the make and model of automobile: Hello, World!
Enter the model year: 2020
Enter the original asking price: 123.567
Make and model: Hello, World!
Year: 2020
Was asking $123.57
Now asking $112.82

cat carinfo.txt
Make and model: Hello, World!
Year: 2020
Was asking $123.57
Now asking $112.82

程序清单6.16 sumafile.cpp
#include <iostream>
#include <fstream>
#include <cstdlib>

using namespace std;

const int SIZE = 128;

int main()
{
    char filename[SIZE];
    ifstream inFile;

    cout << "Enter name of data file: ";
    cin.getline(filename, SIZE);
    inFile.open(filename);
    if (!inFile.is_open())
    {
        cout << "Could not open the file " << filename << endl;
        cout << "Program terminating.\n";
        exit(EXIT_FAILURE);
    }
    double value;
    double sum = 0.0;
    int count = 0;

    value = 0.0;
    inFile >> value;
    while (inFile.good())
    {
        ++count;
        sum += value;
        value = 0.0;
        inFile >> value;
    }
    if (inFile.eof())
    {
        cout << "End of file reached.\n";
    }
    else if (inFile.fail())
    {
        cout << "Input terminated by data mismatch.\n";
    }
    else
    {
        cout << "Input terminated for unknown reason.\n";
    }

    if (count == 0)
    {
        cout << "No data processed.\n";
    }
    else
    {
        cout << "Items read: " << count << endl;
        cout << "Sum: " << sum << endl;
        cout << "Average: " << sum / count << endl;
    }
    inFile.close();

    return 0;
}
显示结果如下
Enter name of data file: sumafile.txt
End of file reached.
Items read: 5
Sum: 16.5
Average: 3.3

cat sumafile.txt
1.1 2.2 3.3 4.4 5.5

6.9总结
if语句使程序有条件地执行语句或语句块，也就是说，如果满足特定的条件，程序将执行特定的语句或语句块。
if else语句程序选择执行两个语句或语句块之一。可以在这条语句后再加上if else，以提供一系列的选项。
switch语句引导程序执行一系列选项之一。
if和ifelse语句通常使用关系表达式作为测试条件。通过使用逻辑运算符（&&、||和!），可以组合或修改关系表达式，创建更细致的测试。
条件运算符（? :）提供了一种选择两个值之一的简洁方式。
cctype字符函数库提供了一组方便的、功能强大的工具，可用于分析字符输入。
声明ifstream和ofstream对象，并将它们同文件关联起来后，便可以像使用cin和cout那样使用这些对象编写程序。
6.10复习题
1.请看下面两个计算空格和换行符数目的代码片段：
//Version 1
while (cin.get(ch))
{
    if (ch == ' ')
    {
        spaces++;
    }
    If (ch == '\n')
    {
        newlines++;
    }
}

//Version 2
while (cin.get(ch))
{
    if (ch == ' ')
    {
        spaces++;
    }
    else If (ch == '\n')
    {
        newlines++;
    }
}
第二种格式比第一种格式好在哪里呢？
if else版本的效率更高。
例如，考虑当ch为空格时的情况。版本1对空格加1，然后看它是否为换行符。
这将浪费时间，因为程序已经知道ch为空格，因此它不是换行符。
在这种情况下，版本2将不会查看字符是否为换行符。

2.在程序清单6.2中，用ch+1替换++ch将发生什么情况呢？
#include <iostream>

int main()
{
    char ch;
    std::cout << "Type, and I shall repeat.\n";
    std::cin.get(ch);
    while (ch != '.')
    {
        if (ch == '\n')
        {
            std::cout << ch;
        }
        else
        {
            std::cout << ++ch;
        }
        std::cin.get(ch);
    }
    std::cout << "\nDone.\n";

    return 0;
}
++ch和ch+1得到的数值相同。但++ch的类型为char，将作为字符打印，而ch+1是int类型（因为将char和int相加），将作为数字打印。

3.请认真考虑下面的程序：
#include <iostream>

using namespace std;

int main()
{
    char ch;
    int ct1, ct2;
    ct1 = ct2 = 0;

    while ( ( ch = cin.get() ) != '$' )
    {
        cout << ch;
        ct1++;
        if (ch = '$')
        {
            ct2++;
        }
        cout << ch;
    }
    cout << "ct1 = " << ct1 << ", ct2 = " << ct2 << "\n";

    return 0;
}
假设输入如下（请在每行末尾按回车键）：
Hi!
Send $10 or $20 now
则输出将是什么（还记得吗，输入被缓冲）？
Hi!
H$i$!$
$Send $10 or $20 now
S$e$n$d$ $ct1 = 9, ct2 = 9

注意读取Hi!后读到的是一个换行符

4.创建表示下述条件的逻辑表达式：
a.weight大于或等于115，但小于125.
b.ch为q或Q.
c.x为偶数，但不是26
d.x为偶数，但不是26的倍数。
e.donation为1000-2000或guest为1.
f.ch是小写字母或大写字母（假设小写字母是依次编码的，大写字母也是依次编码的，但在大小写字母间编码不是连续的）

a.weight >=115 && weight < 125
b.ch =='q' || ch == 'Q'
c.x % 2 == 0 && x != 26
d.x % 2 == 0 && !(x % 26 == 0)
e.(donation >= 1000 && donation <= 2000) || guest = 1
f.(ch >= 'a' && ch <='z') || (ch >= 'A' && ch <= 'Z')

5.在英语中，"I will not not speak（我不会不说）”的意思与"I will speak（我要说）”相同。
在C++中，!!x是否与x相同呢？
不一定相同。如果x不为0和1，则!x为0，!!x为1。如果x为bool变量，则!!x为x。

6.创建一个条件表达式，其值为变量的绝对值。
也是说，如果变量x为正，则表达式的值为x；但如果x为负，则表达式的值为-x。
(x>=0) ? x : -x或(x < 0) ? -x : x

7.用switch改写下面的代码片段
if (ch == 'A')
    a_grade++;
else if (ch == 'B')
    b_grade++;
else if (ch == 'C')
    c_grade++;
else if (ch == 'D')
    d_grade++;
else
    f_grade++;

switch (ch)
{
case 'A':
    a_grade++;
    break;
case 'B':
    b_grade++;
    break;
case 'C':
    c_grade++;
    break;
case 'D':
    d_grade++;
    break;
default :
    f_grade++;
    break;
}

8.对于程序清单6.10，与使用数字相比，使用字符（如a和c）表示菜单选项和case标签有何优点呢？
提示：想想用户输入q和输入5的情况。
#include <iostream>

using namespace std;

void showmenu();
void report();
void comfort();

int main()
{
    showmenu();
    int choice;
    choice = 0;
    cin >> choice;
    while (choice != 5)
    {
        switch (choice)
        {
        case 1:
            cout << "choose alarm\n";
            break;
        case 2:
            report();
            break;
        case 3:
            cout << "The boss was in all day.\n";
            break;
        case 4:
            comfort();
            break;
        default:
            cout << "That's not a choice.\n";
            break;
        }
        showmenu();
        choice = 0;
        cin >> choice;
    }
    cout << "Done.\n";

    return 0;
}

void showmenu()
{
    cout << "Please enter 1, 2, 3, 4, or 5:\n"
         "1) alarm           2) report\n"
         "3) alibi           4) comfort\n"
         "5) quit\n";
}

void report()
{
    cout << "It's been an excellent week for business.\n"
         "Sales are up 120%. Expenses are down 35%.\n";
}
void comfort()
{
    cout << "Your employees think you are the finest CEO\n"
         "in the industry. The board of directors think\n"
         "you are the finest CEO in the industry.\n";
}

如果使用整数标签，且用户输入了非整数（如q），则cin >> choice会失败
如果使用字符标签，且用户输入了整数（如5），则cin >> choice会将5作为字符处理，然后进入switch语句的default部分。

9.请看下面的代码片段：
int line = 0;
char ch;
while ( cin.get(ch) )
{
    if ( ch == 'Q' )
    {
        break;
    }
    if (ch != '\n')
    {
        continue;
    }
    line++;
}
请重写该代码片段，不要使用break和continue语句

int line = 0;
char ch;
while ( cin.get(ch) && ch != 'Q' )
{
    if (ch == '\n')
    {
        line++;
    }
}

6.11编程练习
1.编写一个程序，读取键盘输入，直到遇到@符号为止，并回显输入，
同时将大写字符转换为小写，将小写字符转换为大写（别忘了cctype函数系列）。
#include <iostream>
#include <cctype>

int main()
{
    std::cout << "Type the text (@ means the end)" << std::endl;
    char ch;
    std::cin.get(ch);

    while (ch != '@')
    {
        if (isalpha(ch))
        {
            if (islower(ch))
            {
                std::cout << char(toupper(ch));
            }
            else
            {
                std::cout << char(tolower(ch));
            }
        }
        else
        {
            std::cout << ch;
        }
        std::cin.get(ch);
    }
    std::cout << std::endl;

    return 0;
}
显示结果如下
Type the text (@ means the end)
Hello, World! 123@
hELLO, wORLD! 123


2.编写一个程序，最多将10个donation值读入到一个double数组中（如果您愿意，也可使用模板类array）。
程序遇到非数字输入时将结束输入，并报告这些数字的平均值以及数组中有多少个数字大于平均值。
#include <iostream>

const int array_size = 10;

int main()
{
    double fond[array_size];
    double summ = 0.0;
    int count = 0;

    std::cout << "Enter 10 numbers of donations: " << std::endl;

    int i;
    for (i = 0; i < array_size; i++)
    {
        if ( ! (std::cin >> fond[i]) || fond[i] <= 0 )
        {
            break;
        }
        summ += fond[i];
    }

    double avg = summ / i;
    std::cout << "The average value of " << i << " donations: " << avg << std::endl;

    for (int j = 0; j < i; j++)
    {
        if (fond[j] > avg)
        {
            count++;
        }
    }
    std::cout << "Donations exceeding the average: " << count << std::endl;

    return 0;
}
显示结果如下
Enter 10 numbers of donations:
1.1 2.2 3.3 4.4 5.5 q
The average value of 5 donations: 3.3
Donations exceeding the average: 2

3.编写一个菜单驱动程序的雏形。该程序显示一个提供4个选项的菜单，每个选项用一个字母标记。
如果用户使用有效选项之外的字母进行响应，程序将提示用户输入一个有效的字母，直到用户这样做为止。
然后，该程序使用一条switch语句，根据用户的选择执行一个简单操作。
#include <iostream>

int main()
{
    std::cout << "Please enter one of the following choices: " << std::endl;
    std::cout << "c) carnivore p) pianist" << std::endl << "t) tree g) game" << std::endl;
    char enter;

    while ( std::cin.get(enter) )
    {
        while (std::cin.get() != '\n')
        {
            continue;
        }
        switch (enter)
        {
        case 'c':
        case 'C':
            std::cout << "Your choice is carnivore" << std::endl;
            break;
        case 'p':
        case 'P':
            std::cout << "Your choice is pianist" << std::endl;
            break;
        case 't':
        case 'T':
            std::cout << "Your choice is tree" << std::endl;
            break;
        case 'g':
        case 'G':
            std::cout << "Your choice is game" << std::endl;
            break;
        default:
            std::cout << "Please enter c, p, t, or g: ";
            break;
        }
    }

    return 0;
}
显示结果如下
Please enter one of the following choices:
c) carnivore p) pianist
t) tree g) game
c
Your choice is carnivore
p
Your choice is pianist
t
Your choice is tree
g
Your choice is game
c
Your choice is carnivore

4.加入Benevolent Order of Programmer后，在BOP大会上，
人们便可以通过加入者的真实姓名、头衔或秘密BOP姓名来了解他（她）。
请编写一个程序，可以使用真实姓名、头衔、秘密姓名或成员偏好来列出成员。
编写该程序时，请使用下面的结构；
struct bop
{
    char fullname[strsize];
    char title[strsize];
    char bopname[strsize];
    int preference;
};
该程序创建一个由上述结构组成的小型数组，并将其初始化为适当的值。
另外，该程序使用一个循环，让用户在下面的选项中进行选择
a.display by name         b.display by title
c.display by bopname   d.display by preference
q.quit
注意，"display by preference"并不意味着显示成员的偏好，而是意味着根据成员的偏好来列出成员。
例如，如果偏好号为1，则选择d将显示程序员的头衔。
#include <iostream>

const int strsize = 128;

struct bop
{
    char fullname[strsize];
    char title[strsize];
    char bopname[strsize];
    int preference;
};

int main()
{
    std::cout << "Benevolent Order of Programmers Report" << std::endl;
    std::cout << "a. display by name" << std::endl;
    std::cout << "b. display by title" << std::endl;
    std::cout << "c. display by bopname" << std::endl;
    std::cout << "d. display by preference" << std::endl;
    std::cout << "q. quit" << std::endl;
    std::cout << "Enter a,b,c,d or q: ";

    bop organization[4] =
    {
        { "Wimp Macho", "Wimp Macho - WM", "WM", 0 },
        { "Raki Rhodes", "Raki Rhodes - RR", "RR", 1 },
        { "Celia Laiter", "Celia Laiter - CL", "CL", 2 },
        { "Hoppy Hipman", "Hoppy Hipman - HH", "HH", 0 }
    };

    char enter;
    while ( std::cin.get(enter) )
    {
        while (std::cin.get() != '\n')
        {
            continue;
        }
        switch (enter)
        {
        case 'a':
        case 'A':
            for (int i = 0; i < 4; i++)
            {
                std::cout << organization[i].fullname << std::endl;
            }
            std::cout << "Enter a,b,c,d or q: ";
            break;
        case 'b':
        case 'B':
            for (int i = 0; i < 4; i++)
            {
                std::cout << organization[i].title << std::endl;
            }
            std::cout << "Enter a,b,c,d or q: ";
            break;
        case 'c':
        case 'C':
            for (int i = 0; i < 4; i++)
            {
                std::cout << organization[i].bopname << std::endl;
            }
            std::cout << "Enter a,b,c,d or q: ";
            break;
        case 'd':
        case 'D':
            for (int i = 0; i < 4; i++)
            {
                switch (organization[i].preference)
                {
                case 0:
                    std::cout << organization[i].fullname << std::endl;
                    break;
                case 1:
                    std::cout << organization[i].title << std::endl;
                    break;
                case 2:
                    std::cout << organization[i].bopname << std::endl;
                    break;
                default:
                    std::cout << organization[i].fullname << std::endl;
                    break;
                }
            }
            std::cout << "Enter a,b,c,d or q: ";
            break;
        case 'q':
        case 'Q':
            std::cout << "Done." << std::endl;

            return 0;
            break;
        default:
            std::cout << "Enter a,b,c,d or q: ";
            break;
        }
    }
    return 0;
}
显示结果如下
Benevolent Order of Programmers Report
a. display by name
b. display by title
c. display by bopname
d. display by preference
q. quit
Enter a,b,c,d or q: a
Wimp Macho
Raki Rhodes
Celia Laiter
Hoppy Hipman
Enter a,b,c,d or q: b
Wimp Macho - WM
Raki Rhodes - RR
Celia Laiter - CL
Hoppy Hipman - HH
Enter a,b,c,d or q: c
WM
RR
CL
HH
Enter a,b,c,d or q: d
Wimp Macho
Raki Rhodes - RR
CL
Hoppy Hipman
Enter a,b,c,d or q: q
Done.

5.在Ncutronia王国，货币单位是tvarp，收入所得税的计算方式如下：
5000 tvarps：不收税
5001 ~15000 tvarps：10%
15001~35000 tvarps：15%
35000 tvarps以上：20%
例如，收入为38000 tvarps时，所得税为5000 x 0.00 + 10000 × 0.10 + 20000 x 0.15 + 3000 x 0.20，即4600 tvarps。
请编写一个程序，使用循环来要求用户输入收入，并报告所得税。当用户输入负数或非数字时，循环将结束。
#include <iostream>

int main()
{
    std::cout << "Enter the number of earned tvarpov: ";
    double twarp = 0;

    while (std::cin >> twarp && twarp >= 0)
    {
        double summ = 0;

        if (twarp <= 5000)
        {
            std::cout << "Your tax = 0" << std::endl;
        }
        else if ((twarp > 5000) && (twarp <= 15000))
        {
            summ = (5000 * 0) + ((twarp - 5000) * 0.10);
            std::cout << "Your tax = " << summ << std::endl;
        }
        else if ((twarp > 15000) && (twarp <= 35000))
        {
            summ = (5000 * 0) + (10000 * 0.10) + ((twarp - 15000) * 0.15);
            std::cout << "Your tax = " << summ << std::endl;
        }
        else if (twarp > 35000)
        {
            summ = (5000 * 0) + (10000 * 0.10) + (20000 * 0.15) + ((twarp - 35000) * 0.20);
            std::cout << "Your tax = " << summ << std::endl;
        }
        std::cout << "Enter the number of earned tvarpov: ";
    }

    return 0;
}
显示结果如下
Enter the number of earned tvarpov: 38000
Your tax = 4600
Enter the number of earned tvarpov: 20000
Your tax = 1750
Enter the number of earned tvarpov: 10000
Your tax = 500
Enter the number of earned tvarpov: q

6.编写一个程序，记录捐助给“维护合法权利团体”的资金。
该程序要求用户输入捐献者数目，然后要求用户输入每一个捐献者的姓名和款项。
这些信息被储存在一个动态分配的结构数组中。
每个结构有两个成员：用来储存姓名的字符数组（或string对象）和用来存储款项的double成员。
读取所有的数据后，程序将显示所有捐款>=10000的捐款者的姓名及其捐款数额。
该列表前应包含一个标题，指出下面的捐款者是重要捐款人（Grand Patrons）。
然后，程序将列出其他的捐款者，该列表要以Patrons开头。
如果某种类别没有捐款者，则程序将打印单词"none"，该程序只显示这两种类别，而不进行排序。
#include <iostream>
#include <string>

using namespace std;

struct ZVL
{
    string name;
    double donate;
};

int main()
{
    std::cout << "Enter the number of patrons: ";
    int mecenat_count = 0;
    (std::cin >> mecenat_count).get();

    ZVL *zvl = new ZVL[mecenat_count];

    for (int i = 0; i < mecenat_count; i++)
    {
        std::cout << "Enter the name of the patron: ";
        getline(std::cin, zvl[i].name, '\n');
        std::cout << "Enter amount of donation: ";
        (std::cin >> zvl[i].donate).get();
    }

    int grand_patrons_count = 0;
    std::cout << "Grand Patrons: " << std::endl;

    for (int i = 0; i < mecenat_count; i++)
    {
        if (zvl[i].donate >= 10000)
        {
            std::cout << zvl[i].name << " = $" << zvl[i].donate  << std::endl;
            grand_patrons_count++;
        }
    }
    if (grand_patrons_count == 0)
    {
        std::cout << "NONE!" << std::endl;
    }

    int patrons_count = 0;
    std::cout << "Patrons: " << std::endl;

    for (int i = 0; i < mecenat_count; i++)
    {
        if (zvl[i].donate < 10000)
        {
            std::cout << zvl[i].name << " = $" << zvl[i].donate << std::endl;
            patrons_count++;
        }
    }

    if (patrons_count == 0)
    {
        std::cout << "NONE!" << std::endl;
    }

    delete [] zvl;

    return 0;
}
显示结果如下
Enter the number of patrons: 3
Enter the name of the patron: Peter Smith
Enter amount of donation: 8000
Enter the name of the patron: Mike Pence
Enter amount of donation: 12000
Enter the name of the patron: Hello World
Enter amount of donation: 20000
Grand Patrons:
Mike Pence = $12000
Hello World = $20000
Patrons:
Peter Smith = $8000

7.编写一个程序，它每次读取一个单词，直到用户只输入q。
然后，该程序指出有多少个单词以元音打头，有多少个单词以辅音打头，还有多少个单词不属于这两类。
为此，方法之一是，使用isalpha来区分以字母和其他字符打头的单词，
然后对于通过了isalpha测试的单词，使用if或switch语句来确定哪些以元音打头。
#include <iostream>
#include <cctype>
#include <string>

int main()
{
    std::cout << "Enter words (q to quit): " << std::endl;
    std::string words;

    int vowels = 0;
    int consonants = 0;
    int others = 0;

    while (std::cin >> words && words != "q")
    {
        if (isalpha(words[0]))
        {
            switch (words[0])
            {
            case 'a':
            case 'A':
            case 'e':
            case 'E':
            case 'i':
            case 'I':
            case 'o':
            case 'O':
            case 'u':
            case 'U':
            case 'y':
            case 'Y':
                vowels++;
                break;
            default:
                consonants++;
                break;
            }
        }
        else
        {
            others++;
        }
    }

    std::cout << vowels << " words beginning with vowels.\n";
    std::cout << consonants << " words beginning with consonants.\n";
    std::cout << others << " words beginning with any other character.\n";

    return 0;
}
显示结果如下
Enter words (q to quit):
Apple Orange Egg Peter Smith Mike Pence University Internet q
5 words beginning with vowels.
4 words beginning with consonants.
0 words beginning with any other character.

8.编写一个程序，它打开一个文件文件，逐个字符地读取该文件，直到到达文件末尾，然后指出该文件中包含多少个字符。
#include <iostream>
#include <fstream>

int main()
{
    std::ifstream finput;
    finput.open("ch06_p08.txt");

    if ( ! finput.is_open() )
    {
        std::cout << "Could not open file!" << '\n';
        return 0;
    }
    char word;
    int word_count = 0;

    while (finput.get(word))
    {
        word_count++;
    }

    if (finput.eof())
    {
        std::cout << "End of file reached.\n";
    }
    else if (finput.fail())
    {
        std::cout << "Input Fail.\n";
    }

    if (word_count == 0)
    {
        std::cout << "No data in the file.\n";
    }
    else
    {
        std::cout << "Number of characters in the file: " << word_count << std::endl;
    }

    finput.close();

    return 0;
}
显示结果如下
End of file reached.
Number of characters in the file: 26

cat ch06_p08.txt
123456789
abcdefg
hijklmn

注意每行都有一个换行符

9.完成编程练习6，但从文件中读取所需的信息。该文件的第一项应为捐款人数，余下的内容应为成对的行。
在每一对中，第一行为捐款人姓名，第二行为捐款数额。
#include <iostream>
#include <fstream>
#include <string>

struct ZVL
{
    std::string name;
    double donate;
};

int main()
{
    std::ifstream fileinp;
    fileinp.open("ch06_p09.txt");

    if (!fileinp.is_open())
    {
        std::cout << "Cound not open file." << std::endl;
        std::cout << "The program will be closed." << std::endl;
        exit(EXIT_FAILURE);
    }
    std::cout << "Number of Patrons: ";

    int mecenat_count;
    (fileinp >> mecenat_count).get();

    std::cout << mecenat_count << std::endl;
    ZVL *zvl = new ZVL[mecenat_count];

    for (int i = 0; i < mecenat_count; i++)
    {
        if ( ! std::getline(fileinp, zvl[i].name, '\n') )
        {
            break;
        }
        std::cout << "The name of the patron has been entered: ";
        std::cout << zvl[i].name << std::endl;
        (fileinp >> zvl[i].donate).get();
        std::cout << "Donation amount entered: ";
        std::cout << zvl[i].donate << std::endl;
        std::cout << std::endl;
    }

    int grand_patrons_count = 0;
    std::cout << "Grand Patrons: " << std::endl;

    for (int i = 0; i < mecenat_count; i++)
    {
        if (zvl[i].donate >= 10000)
        {
            std::cout << zvl[i].name << " = $" << zvl[i].donate << std::endl;
            grand_patrons_count++;
        }
    }

    if (grand_patrons_count == 0)
    {
        std::cout << "NONE!" << std::endl;
    }

    int patrons_count = 0;
    std::cout << "Patrons: " << std::endl;

    for (int i = 0; i < mecenat_count; i++)
    {
        if (zvl[i].donate < 10000)
        {
            std::cout << zvl[i].name << " = $" << zvl[i].donate << std::endl;
            patrons_count++;
        }
    }

    if (patrons_count == 0)
    {
        std::cout << "NONE!" << std::endl;
    }

    delete [] zvl;
    fileinp.close();

    return 0;
}
显示结果如下
Number of Patrons: 3
The name of the patron has been entered: Pete Smith
Donation amount entered: 8000

The name of the patron has been entered: Mike Pence
Donation amount entered: 12000

The name of the patron has been entered: Hello World
Donation amount entered: 20000

Grand Patrons:
Mike Pence = $12000
Hello World = $20000
Patrons:
Pete Smith = $8000

cat ch06_p09.txt
3
Pete Smith
8000
Mike Pence
12000
Hello World
20000

第7章 函数 C++的编程模块
7.1 复习函数的基本知识
7.1.1 定义函数
7.1.2 函数原型和函数调用
7.2 函数参数和按值传递
7.2.1 多个参数
7.2.2 另外一个接受两个参数的函数
7.3 函数和数组
7.3.1 函数如何使用指针来处理数组
7.3.2 将数组作为参数意味着什么
7.3.3 更多数组函数示例
7.3.4 使用数组区间的函数
7.3.5 指针和const
7.4 函数和二维数组
7.5 函数和C风格字符串
7.5.1 将C风格字符串作为参数的函数
7.5.2 返回C风格字符串的函数
7.6 函数和结构
7.6.1 传递和返回结构
7.6.2 另一个处理结构的函数示例
7.6.3 传递结构的地址.
7.7 函数和string对象
7.8 函数与array对象
7.9 递归
7.9.1 包含一个递归调甩的递归
7.9.2 包含多个递归调用的递归
7.10 函数指针
7.10.1 函数指针的基础知识
7.10.2 函数指针示例
7.10.3 深入探讨函数指针
7.10.4 使用typedef进行简化
7.11 总结
7.12 复习题
7.13 编程练习
本章内容包括：
函数基本知识。
函数原型。
按值传递函数参数。
设计处理数组的函数。
使用const指针参数。
设计处理文本字符串的函数。
设计处理结构的函数。
设计处理string对象的函数。
调用自身的函数（递归）。
指向函数的指针。

程序清单7.1.calling.cpp
#include <iostream>

using namespace std;

void simple();

int main()
{
    cout << "main () will call the simple () function: \n";
    simple();
    cout << "main() is finished with the simple () function.\n";

    return 0;
}

void simple()
{
    cout << "I'm but a simple function. \n";
}
显示结果如下
main () will call the simple () function:
I'm but a simple function.
main() is finished with the simple () function.

程序清单7.2 protos.cpp
#include <iostream>

using namespace std;

void cheers(int);
double cube(double x);

int main()
{
    cheers(5);
    cout << "Give me a number: ";
    double side;
    cin >> side;
    double volume = cube(side);
    cout << "A " << side << "-foot cube has a volume of " << volume << " cubic feet.\n";
    cheers(cube(2));

    return 0;
}


void cheers(int n)
{
    for (int i = 0; i < n; i++)
    {
        cout << "Cheers! ";
    }
    cout << endl;
}

double cube(double x)
{
    return x * x * x;
}
显示结果如下
Cheers! Cheers! Cheers! Cheers! Cheers!
Give me a number: 5
A 5-foot cube has a volume of 125 cubic feet.
Cheers! Cheers! Cheers! Cheers! Cheers! Cheers! Cheers! Cheers!

程序清单7.3演示了一个接受两个参数的函数，它还表明，在函数中修改形参的值不会影响调用程序中的数据。
程序清单7.3 twoarg.cpp
#include <iostream>

using namespace std;

void n_chars(char, int);

int main()
{
    int times;
    char ch;
    cout << "Enter a character: ";
    cin.get(ch);
    while (cin.get() != '\n')
    {
        continue;
    }
    while (ch != 'q')
    {
        cout << "Enter an integer: ";
        times = 0;
        if ( ! (cin >> times) )
        {
            break;
        }
        while (cin.get() != '\n')
        {
            continue;
        }
        n_chars(ch, times);
        cout << "\ntimes = " << times << ".\n";
        cout << "Enter a character (q to quit) : ";
        cin.get(ch);
        while (cin.get() != '\n')
        {
            continue;
        }
    }
    cout << "Done.\n";

    return 0;
}

void n_chars(char c, int n)
{
    while (n-- > 0)
    {
        cout << c;
    }
}
显示结果如下
Enter a character: a
Enter an integer: 3
aaa
times = 3.
Enter a character (q to quit) : b
Enter an integer: 5
bbbbb
times = 5.
Enter a character (q to quit) : c
Enter an integer: 7
ccccccc
times = 7.
Enter a character (q to quit) : q
Done.

程序清单7.4 lotto.cpp
#include <iostream>

using namespace std;

long double probability(int numbers, int picks);

int main()
{
    double total, choices;
    cout << "Enter the total number of choices on the game card and\n";
    cout << "the number of picks allowed:\n";
    while ( (cin >> total) && (cin >> choices) && choices <= total )
    {
        cout << "You have one chance in " << probability(total, choices) << " of winning. \n";
        cout << "Next two numbers (q to quit) : ";
    }
    cout << "Done.\n";

    return 0;
}
long double probability(int numbers, int picks)
{
    long double result = 1.0;
    long double n;
    int p;
    for (n = numbers, p = picks; p > 0; n--, p--)
    {
        result = result * n / p;
    }
    return result;
}
显示结果如下
Enter the total number of choices on the game card and
the number of picks allowed:
51 6
You have one chance in 1.80095e+07 of winning.
Next two numbers (q to quit) : q
Done.

程序清单7.5 arrfun1.cpp
#include <iostream>

using namespace std;

const int ArSize = 8;

int sum_arr(int arr[], int n);

int main()
{
    int cookies[ArSize] = { 1, 2, 4, 8, 16, 32, 64, 128 };

    int sum = sum_arr(cookies, ArSize);
    cout << "Total cookies eaten: " << sum << "\n";

    return 0;
}

int sum_arr(int arr[], int n)
{
    int total = 0;
    for (int i = 0; i < n; i++)
    {
        total = total + arr[i];
    }
    return total;
}
显示结果如下
Total cookies eaten: 255

程序清单7.6 arrfun2.cpp
#include <iostream>

const int ArSize = 8;

int sum_arr(int arr[], int n);

int main()
{
    int cookies[ArSize] = { 1, 2, 4, 8, 16, 32, 64, 128 };

    std::cout << "array address = " << cookies << '\n';
    std::cout << "sizeof cookies = " << sizeof cookies << '\n';
    int sum = sum_arr(cookies, ArSize);
    std::cout << "Total cookies eaten: " << sum << std::endl;

    sum = sum_arr(cookies, 3);
    std::cout << "First three eaters ate " << sum << " cookies.\n";

    sum = sum_arr(cookies + 4, 4);
    std::cout << "Last four eaters ate " << sum << " cookies.\n";

    return 0;
}

int sum_arr(int arr[], int n)
{
    int total = 0;
    std::cout << "arr address = " << arr << '\n';

    std::cout << "sizeof arr = " << sizeof arr << '\n';
    for (int i = 0; i < n; i++)
    {
        total = total + arr[i];
    }
    return total;
}
编译命令如下
g++ -o arrfun2 arrfun2.cpp
arrfun2.cpp: In function ‘int sum_arr(int*, int)’:
arrfun2.cpp:30:44: warning: ‘sizeof’ on array function parameter ‘arr’ will return size of ‘int*’ [-Wsizeof-array-argument]
   30 |     std::cout << "sizeof arr = " << sizeof arr << '\n';
      |                                            ^~~
arrfun2.cpp:25:17: note: declared here
   25 | int sum_arr(int arr[], int n)
      |             ~~~~^~~~~

显示结果如下
array address = 0x7ffd1df68500
sizeof cookies = 32
arr address = 0x7ffd1df68500
sizeof arr = 8
Total cookies eaten: 255
arr address = 0x7ffd1df68500
sizeof arr = 8
First three eaters ate 7 cookies.
arr address = 0x7ffd1df68510
sizeof arr = 8
Last four eaters ate 240 cookies.

程序清单7.7 arrfun3.cpp
#include <iostream>

using namespace std;

const int Max = 5;

int fill_array(double ar[], int limit);
void show_array(const double ar[], int n);
void revalue(double r, double ar[], int n);

int main()
{
    double properties[Max];
    int size = fill_array(properties, Max);
    show_array(properties, size);
    if (size > 0)
    {
        cout << "Enter revaluation factor: ";
        double factor = 0;
        while (!(cin >> factor))
        {
            cin.clear();
            while (cin.get() != '\n')
            {
                continue;
            }
            cout << "Bad input; Please enter a number: ";
        }
        revalue(factor, properties, size);
        show_array(properties, size);
    }
    cout << "Done.\n";

    return 0;
}

int fill_array(double ar[], int limit)
{
    double temp;
    int i;
    for (i = 0; i < limit; i++)
    {
        cout << "Enter value #" << (i + 1) << ": ";
        temp = 0;
        if ( ! (cin >> temp) )
        {
            cin.clear();
            while (cin.get() != '\n')
            {
                continue;
            }
            cout << "Bad input; input process terminated.\n";
            break;
        }
        else if (temp < 0)
        {
            while (cin.get() != '\n')
            {
                continue;
            }
            cout << "input process terminated.\n";
            break;
        }
        ar[i] = temp;
    }
    return i;
}

void show_array(const double ar[], int n)
{
    for (int i = 0; i < n; i++)
    {
        cout << "Property #" << (i + 1) << ": $";
        cout << ar[i] << endl;
    }
}

void revalue(double r, double ar[], int n)
{
    for (int i = 0; i < n; i++)
    {
        ar[i] *= r;
    }
}
显示结果如下
Enter value #1: 10000
Enter value #2: 20000
Enter value #3: 30000
Enter value #4: q
Bad input; input process terminated.
Property #1: $10000
Property #2: $20000
Property #3: $30000
Enter revaluation factor: 0.6
Property #1: $6000
Property #2: $12000
Property #3: $18000
Done.

程序清单7.8 arrfun4.cpp
#include <iostream>

using namespace std;

const int ArSize = 8;

int sum_arr(const int *begin, const int *end);

int main()
{
    int cookies[ArSize] = { 1, 2, 4, 8, 16, 32, 64, 128 };

    int sum = sum_arr(cookies, cookies + ArSize);
    cout << "Total cookies eaten: " << sum << endl;
    sum = sum_arr(cookies, cookies + 3);
    cout << "First three eaters ate " << sum << " cookies. \n";
    sum = sum_arr(cookies + 4, cookies + 8);
    cout << "Last four eaters ate " << sum << " cookies. \n";

    return 0;
}

int sum_arr(const int *begin, const int *end)
{
    const int *pt;
    int total = 0;
    for (pt = begin; pt != end; pt++)
    {
        total = total + *pt;
    }
    return total;
}
显示结果如下
Total cookies eaten: 255
First three eaters ate 7 cookies.
Last four eaters ate 240 cookies.

程序清单7.9 strgfun.cpp
#include <iostream>

using namespace std;

int c_in_str(const char *str, char ch);

int main()
{
    char mmm[15] = "minimum";
    const char *wail = "ululate";
    int ms = c_in_str(mmm, 'm');
    int us = c_in_str(wail, 'u');
    cout << ms << " m characters in " << mmm << endl;
    cout << us << " u characters in " << wail << endl;

    return 0;
}

int c_in_str(const char *str, char ch)
{
    int count = 0;
    while (*str)
    {
        if (*str == ch)
        {
            count++;
        }
        str++;
    }
    return count;
}
显示结果如下
3 m characters in minimum
2 u characters in ululate

程序清单7.10 strgback.cpp
#include <iostream>

using namespace std;

char *buildstr(char c, int n);

int main()
{
    char ch;
    cout << "Enter a character: ";
    cin.get(ch);
    while (cin.get() != '\n')
    {
        continue;
    }
    cout << "Enter an integer: ";
    int times = 0;
    if ( ! (cin >> times) || times <= 0)
    {
        return 0;
    }
    char *ps = buildstr(ch, times);
    cout << ps << endl;
    delete [] ps;
    ps = buildstr('+', 20);
    cout << ps << endl;
    delete [] ps;

    return 0;
}

char *buildstr(char c, int n)
{
    char *pstr = new char[n + 1];
    pstr[n] = '\0';
    while (n-- > 0)
    {
        pstr[n] = c;
    }
    return pstr;
}
显示结果如下
Enter a character: c
Enter an integer: 5
ccccc
++++++++++++++++++++

程序清单7.11 travel.cpp
#include <iostream>

using namespace std;

const int Mins_per_hr = 60;

struct travel_time
{
    int hours;
    int mins;
};

travel_time sum(travel_time t1, travel_time t2);
void show_time(travel_time t);

int main()
{

    travel_time day1 = { 5, 45 };
    travel_time day2 = { 4, 55 };
    travel_time trip = sum(day1, day2);
    cout << "Two-day total: ";
    show_time(trip);
    travel_time day3 = { 4, 32 };
    cout << "Three-day total: ";
    show_time(sum(trip, day3));

    return 0;
}

travel_time sum(travel_time t1, travel_time t2)
{
    travel_time total;
    total.mins = (t1.mins + t2.mins) % Mins_per_hr;
    total.hours = t1.hours + t2.hours + (t1.mins + t2.mins) / Mins_per_hr;
    return total;
}

void show_time(travel_time t)
{
    cout << t.hours << " hours, " << t.mins << " minutes\n";
}
显示结果如下
Two-day total: 10 hours, 40 minutes
Three-day total: 15 hours, 12 minutes

程序清单7.12 strctfun.cpp
#include <iostream>
#include <cmath>

using namespace std;

struct polar
{
    double distance;
    double angle;
};

struct rect
{
    double x;
    double y;
};

polar rect_to_polar(rect xypos);
void show_polar(polar dapos);

int main()
{
    rect rplace;
    polar pplace;
    cout << "Enter the x and y values: ";
    while ( (cin >> rplace.x) && (cin >> rplace.y) )
    {
        pplace = rect_to_polar(rplace);
        show_polar(pplace);
        cout << "Enter the x and y values (q to quit) : ";
    }
    cout << "Done.\n";

    return 0;
}

polar rect_to_polar(rect xypos)
{
    polar answer;
    answer.distance = sqrt(xypos.x * xypos.x + xypos.y * xypos.y);
    answer.angle = atan2(xypos.y, xypos.x);
    return answer;
}

void show_polar(polar dapos)
{
    const double Rad_to_deg = 57.29577951;
    cout << "distance = " << dapos.distance << ", angle = " << dapos.angle *Rad_to_deg << " degrees\n";
}
显示结果如下
Enter the x and y values: 3 3
distance = 4.24264, angle = 45 degrees
Enter the x and y values (q to quit) : q
Done.

程序清单7.13 strctptr.cpp
#include <iostream>
#include <cmath>

using namespace std;

struct polar
{
    double distance;
    double angle;
};

struct rect
{
    double x;
    double y;
};

void rect_to_polar(const rect *pxy, polar *pda);
void show_polar(const polar *pda);

int main()
{
    rect rplace;
    polar pplace;
    cout << "Enter the x and y values: ";
    while ( (cin >> rplace.x) && (cin >> rplace.y) )
    {
        rect_to_polar(&rplace, &pplace);
        show_polar(&pplace);
        cout << "Enter the x and y values (q to quit) : ";
    }
    cout << "Done.\n";

    return 0;
}

void show_polar(const polar *pda)
{
    const double Rad_to_deg = 57.29577951;
    cout << "distance = " << pda->distance << ", angle = " << pda->angle *Rad_to_deg << " degrees\n";
}

void rect_to_polar(const rect *pxy, polar *pda)
{
    pda->distance = sqrt( (pxy->x) * (pxy->x) + (pxy->y) * (pxy->y) );
    pda->angle = atan2(pxy->y, pxy->x);
}
显示结果如下
Enter the x and y values: 3 3
distance = 4.24264, angle = 45 degrees
Enter the x and y values (q to quit) : 6 6
distance = 8.48528, angle = 45 degrees
Enter the x and y values (q to quit) : q
Done.

程序清单7.14 topfive.cpp
#include <iostream>
#include <string>

using namespace std;

const int SIZE = 5;

void display(const string sa[], int n);

int main()
{
    string list[SIZE];
    cout << "Enter your " << SIZE << " favorite astronomical sights:\n";

    for (int i = 0; i < SIZE; i++)
    {
        cout << i + 1 << " : ";
        getline(cin, list[i], '\n');
    }
    cout << "Your list:\n";
    display(list, SIZE);

    return 0;
}

void display(const string sa[], int n)
{
    for (int i = 0; i < n; i++)
    {
        cout << i + 1 << " : " << sa[i] << endl;
    }
}
显示结果如下
Enter your 5 favorite astronomical sights:
1 : Peter Smith
2 : Mike Pence
3 : Hello World
4 : Apple
5 : Orange
Your list:
1 : Peter Smith
2 : Mike Pence
3 : Hello World
4 : Apple
5 : Orange

程序清单7.15 arrobj.cpp
#include <iostream>
#include <array> 
#include <string> 

using namespace std;

const int Seasons = 4;

const array<string, Seasons> Snames =
{ 
	"Spring", "Summer", "Fall", "Winter" 
};

void fill(array<double, Seasons> * pa);
void show(array<double, Seasons> & da);

int main()
{
	array<double, Seasons> expenses;
	fill(&expenses);
	show(expenses);

	return 0;
}

void fill(array<double, Seasons> * pa)
{
	for (int i = 0; i < Seasons; i++)
	{
		 cout << "Enter " << Snames[i] << " expenses: ";
		 cin >> (*pa)[i];
	}
}

void show(array<double, Seasons> & da)
{
	double total = 0.0;
	cout << "\nEXPENSES\n";
	for (int i = 0; i < Seasons; i++)
	{
		 cout << Snames[i] << ": $" << da[i] << endl;
		 total += da[i];
	}
	cout << "Total Expenses: $" << total << endl;
}
显示结果如下
Enter Spring expenses: 10000
Enter Summer expenses: 20000
Enter Fall expenses: 30000
Enter Winter expenses: 40000

EXPENSES
Spring: $10000
Summer: $20000
Fall: $30000
Winter: $40000
Total Expenses: $100000

程序清单7.16 recur.cpp
#include <iostream>

using namespace std;

void countdown(int n);

int main()
{
    countdown(4);

    return 0;
}

void countdown(int n)
{
    cout << "Counting down ... " << n << endl;
    if (n > 0)
    {
        countdown(n - 1);
    }
    cout << n << " end!\n";
}
显示结果如下
Counting down ... 4
Counting down ... 3
Counting down ... 2
Counting down ... 1
Counting down ... 0
0 end!
1 end!
2 end!
3 end!
4 end!

程序清单7.17 ruler.cpp
#include <iostream>

using namespace std;

const int Len = 66;
const int Divs = 6;

void subdivide(char ar[], int low, int high, int level);

int main()
{

    char ruler[Len];
    int i;
    for (i = 1; i < Len - 2; i++)
    {
        ruler[i] = ' ';
    }
    ruler[Len - 1] = '\0';
    int max = Len - 2;
    int min = 0;
    ruler[min] = ruler[max] = '|';
    cout << ruler << endl;
    for (i = 1; i <= Divs; i++)
    {
        subdivide(ruler, min, max, i);
        cout << ruler << endl;
        for (int j = 1; j < Len - 2; j++)
        {
            ruler[j] = ' ';
        }
    }

    return 0;
}

void subdivide(char ar[], int low, int high, int level)
{
    if (level == 0)
    {
        return;
    }
    int mid = (high + low) / 2;
    ar[mid] = '|';
    subdivide(ar, low, mid, level - 1);
    subdivide(ar, mid, high, level - 1);
}
显示结果如下
|                                                               |
|                               |                               |
|               |               |               |               |
|       |       |       |       |       |       |       |       |
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

程序清单7.18 fun_ptr.cpp
#include <iostream>

using namespace std;

double betsy(int);
double pam(int);
void estimate(int lines, double (*pf) (int));

int main()
{
    int code;
    cout << "How many lines of code do you need? ";
    cin >> code;
    cout << "Here's Betsy's estimate:\n";
    estimate(code, betsy);
    cout << "Here's Pam's estimate:\n";
    estimate(code, pam);

    return 0;
}

double betsy(int Ins)
{
    return 0.05 * Ins;
}

double pam(int Ins)
{
    return 0.03 * Ins + 0.0004 * Ins * Ins;
}

void estimate(int lines, double (*pf)(int))
{
    cout << lines << " lines will take " << (*pf)(lines) << " hour(s)\n";
}
显示结果如下
How many lines of code do you need? 8
Here's Betsy's estimate:
8 lines will take 0.4 hour(s)
Here's Pam's estimate:
8 lines will take 0.2656 hour(s)

程序清单7.19 arfupt.cpp
#include <iostream>

using namespace std;

const double *f1(const double ar[], int n);
const double *f2(const double[], int);
const double *f3(const double *, int);

int main()
{
    double av[3] = { 1112.3, 1542.6, 2227.9 };
    const double *(*p1) (const double *, int) = f1;
    auto p2 = f2;

    cout << "Using pointers to functions:\n";
    cout << " Address Value\n";
    cout << (*p1) (av, 3) << " : " << *(*p1) (av, 3) << endl;
    cout << p2(av, 3) << " : " << *p2(av, 3) << endl;

    const double *(*pa[3])(const double *, int) = { f1, f2, f3 };
    auto pb = pa;

    cout << "\nUsing an array of pointers to functions:\n";
    cout << " Address          Value\n";
    for (int i = 0; i < 3; i++)
    {
        cout << pa[i](av, 3) << " : " << *pa[i](av, 3) << endl;
    }

    cout << "\nUsing a pointer to a pointer to a function: \n";
    cout << " Address         Value\n";
    for (int i = 0; i < 3; i++)
    {
        cout << pb[i](av, 3) << " : " << *pb[i](av, 3) << endl;
    }

    cout << "\nUsing pointers to an array of pointers:\n";
    cout << " Address         Value\n";
    auto pc = &pa;
    cout << (*pc)[0](av, 3) << " : " << *(*pc)[0](av, 3) << endl;

    const double *(*(*pd)[3]) (const double *, int) = &pa;
    const double *pdb = (*pd)[1](av, 3);
    cout << pdb << " : " << *pdb << endl;
    cout << (*(*pd)[2]) (av, 3) << " : " << * (*(*pd)[2]) (av, 3) << endl;

    return 0;
}

const double *f1(const double *ar, int n)
{
    return ar;
}

const double *f2(const double ar[], int n)
{
    return ar + 1;
}

const double *f3(const double ar[], int n)
{
    return ar + 2;
}
显示结果如下
Using pointers to functions:
 Address Value
0x7ffdfe6686e0 : 1112.3
0x7ffdfe6686e8 : 1542.6

Using an array of pointers to functions:
 Address          Value
0x7ffdfe6686e0 : 1112.3
0x7ffdfe6686e8 : 1542.6
0x7ffdfe6686f0 : 2227.9

Using a pointer to a pointer to a function:
 Address         Value
0x7ffdfe6686e0 : 1112.3
0x7ffdfe6686e8 : 1542.6
0x7ffdfe6686f0 : 2227.9

Using pointers to an array of pointers:
 Address         Value
0x7ffdfe6686e0 : 1112.3
0x7ffdfe6686e8 : 1542.6
0x7ffdfe6686f0 : 2227.9

7.11 总结
函数是C++的编程模块。要使用函数，必须提供函数定义和函数原型。
函数定义是实现函数功能的代码；函数原型描述了函数的接口：传递给函数的值的数目和种类以及函数的返回类型。
函数调用使得程序将参数传递给函数，并执行函数的代码。
在默认情况下，C++函数按值传递参数。这意味着函数定义中的形参是新的变量，它们被初始化为函数调用所提供的值。
因此，C++函数通过使用拷贝，保护了原始数据的完整性。
C++将数组名参数视为数组第一个元素的地址。从技术上讲，这仍然是按值传递的，
因为指针是原始地址的拷贝，但函数将使用指针来访问原始数组的内容。
当且仅当声明函数的形参时，下面两个声明才是等价的：
typeName arr []
typeName * arr
这两个声明都表明arr是指向typeName的指针；但在编写函数代码时，可以像使用数组名那样使用arr来访问元素：arr[i]。
即使在传递指针时，也可以将形参声明为const指针，来保护原始数据的完整性。
由于传递数据的地址时，并不会传输有关数组长度的信息，因此通常将数组长度作为独立的参数来传递。
另外，也可传递两个指针（其中一个指向数组开头，另一个指向数组末尾的下一个元素），以指定一个范围，就像STL使用的算法一样。
C++提供了3种表示C风格字符串的方法：字符数组、字符串常量和字符串指针。它们的类型都是char *，因此被作为char*类型参数传递给函数。
C++使用空值字符（0）来结束字符串，因此字符串函数检测空值字符来确定字符串的结尾。
C++还提供了string类，用于表示字符串。函数可以接受string对象作为参数以及将string对象作为返回值。
string类的方法size可用于判断其存储的字符串的长度。
C++处理结构的方式与基本类型完全相同，这意味着可以按值传递结构；并将其用作函数返回类型。
然而，如果结构非常大，，则传递结构指针的效率将更高，同时函数能够使用原始数据。这些考虑因素也适用于类对象。
C++函数可以是递归的，也就是说，函数代码中可以包括对函数本身的调用。
C++函数名与函数地址的作用相同。通过将函数指针作为参数，可以传递要调用的函数的名称。
7.12 复习题
1.使用函数的3个步骤是什么？
定义函数、提供原型、调用函数

2.请创建与下面的描述匹配的函数原型。
a.igor没有参数，且没有返回值。
b.tofu接受一个int参数，并返回一个float。
c.mpg接受两个double参数，并返回一个double。
d.summation将long数组名和数组长度作为参数，并返回一个long值。
e.doctor接受一个字符串参数（不能修改该字符串），并返回一个double值。
f.ofcourse将boss结构作为参数，不返回值。
g.plot将map结构的指针作为参数，并返回一个字符串。

a.void igor (void);
b.float tofu (int n);
c.double mpg (double miles, double gallons);
d.long summation (long array[], int size);
e.double doctor (const char * str);
f.void ofcourse (boss dude);
g.char * plot (map * pmap);

3.编写一个接受3个参数的函数：int数组名、数组长度和一个int值，并将数组的所有元素都设置为该int值。
void set_array (int arr[], int size, int value)
{
    for (int i = 0; i < size; i++)
    {
        arr[i] = value;
    }
}

4.编写一个接受3个参数的函数：指向数组区间中第一个元素的指针、
指向数组区间最后一个元素后面的指针以及一个int值，并将数组中的每个元素都设置为该int值。
void set_array(int *begin, int *end, int value)
{
    for(int *pt = begin; pt != end; pt++)
    {
        *pt = value;
    }
}

5.编写将double数组名和数组长度作为参数，并返回该数组中最大值的函数。该函数不应修改数组的内容。
double find_max (const double arr[], int size)
{
    double max;
    if (size < 1)
    {
        cout << "Invalid array size : " << size << endl;
        cout << "Returning 0\n";
        return 0;
    }
    max = arr[0];
    for (int i = 1;i < size; i++)
    {
        if (arr[i] > max)
        {
            max = arr[i];
        }
    }
    return max;
}

6.为什么不对类型为基本类型的函数参数使用const限定符？
基本类型的函数参数是按值传递，原始数据不会被修改。

7.C++程序可使用哪3种C风格字符串格式？
字符数组，带双引号的字符串字面量，指向字符串第一个字符的字符指针


8.编写一个函数，其原型如下：
int replace (char * str, char c1, char c2);
该函数将字符串中所有的c1都替换为c2，并返回替换次数。
int replace (char * str, char c1, char c2)
{
    int count = 0;
    while (*str)
    {
        if (*str == c1)
        {
            *str = c2;
            count++;
        }
        str++;
    }
    return count;
}

9.表达式*"pizza"的含义是什么？"taco"[2]呢？
由于C++将"pizza"解释为其第一个元素的地址，因此使用*运算符将得到第一个元素的值，即字符p。
亩于C+将"taco"解释为第一个元素的地址；因此它将"taco"[2]解释为第三个元素的值，即字符c。

10.C++允许按值传递结构，也允许传递结构的地址。如果glitz是一个结构变量，如何按值传递它？
如何传递它的地址？这两种方法有何利弊？
要按值传递它，只要传递结构名glitz即可。要传递它的地址，需要使用地址运算符&glitz。
按值传递将自动保护原始数据，但这是以时间和内存为代价的。
按地址传递可节省时间和内存，但不能保护原始数据，除非对函数参数使用了const限定符。
另外，按值传递意味着可以使用常规的结构成员表示法，但传递指针则必须使用间接成员运算符。

11.函数judge的返回类型为int，它将这样一个函数的地址作为参数：
将const char指针作为参数，并返回一个int值。请编写judge函数的原型。
int judge ( int (*pf) (const char * ) );

12，假设有如下结构声明：
struct applicant
{
    char name[30];
    int credit_ratings[3];
};
a.编写一个函数，它将applicant结构作为参数，并显示该结构的内容。
b.编写一个函数，它将applicant结构的地址作为参数，并显示该参数指向的结构的内容。

a.
void display (applicant ap)
{
    cout << ap.name << endl;
    for (int i = 0 ;i < 3; i++)
    {
        cout << ap.credit_ratings[i] << endl;
    }
}
b.
void show(const applicant * pa)
{
    cout << pa->name << endl;
    for (int i = 0; i < 3; i++)
    {
        cout << pa->credit_ratings[i] << endl;
    }
}

13.假设函数f1()和f2()的原型如下：
void f1 (applicant * a);
const char * f2 (const applicant *a1, const applicant * a2);
请将p1和p2分别声明为指向f1和f2的指针；将ap声明为一个数组，它包含5个类型与p1相同的指针；
将pa声明为一个指针，它指向的数组包含10个类型与p2相同的指针。使用typedef来帮助完成这项工作。
typedef void (*p_f1) (applicant *);
typedef const char * (*p_f2) (const applicant *, const applicant *);
p_f1 p1 = f1;
p_f2 p2 = f2;
p_f1 ap[5];
p_f2 (*pa)[10];

7.13 编程练习
1.编写一个程序，不断要求用户输入两个数，直到其中的一个为0。
对于每两个数，程序将使用一个函数来计算它们的调和平均数，并将结果返回给main，而后者将报告结果。
调和平均数指的是倒数平均值的倒数。
1/ ( ( (1/x) + (1/y) ) / 2 ) = 2 / ( (1/x) + (1/y) ) = (2 * x * y) / (x + y) 

#include <iostream>

double average_harmonic(double x, double y);

int main()
{
    double x = 0;
    double y = 0;
    std::cout << "Enter x and y: " << std::endl;

    while ( (std::cin >> x) && x != 0 && (std::cin >> y) && y != 0)
    {
        std::cout << "The average harmonic " << x << " and " << y << " = " << average_harmonic(x, y) << std::endl;
        std::cout << "Enter x and y: " << std::endl;
    }

    return 0;
}
double average_harmonic(double x, double y)
{
    return  (2.0 * x * y) / (x + y);
}
显示结果如下
Enter x and y:
2 5
The average harmonic 2 and 5 = 2.85714
Enter x and y:
0 0

2.编写一个程序，要求用户输入最多10个高尔夫成绩，并将其存储在一个数组中。
程序允许用户提早结束输入，并在一行上显示所有成绩，然后报告平均成绩。
请使用3个数组处理函数来分别进行输入、计算和显示平均成绩。
#include <iostream>

int enter_result(int golf_result[], int array_size);
double avg_result(int golf_result[], int array_size);
void output_result(double avg, int golf_result[], int array_size);

int main()
{
    const int SIZE = 10;

    int golf_result[SIZE] = { 0 };

    int num = enter_result(golf_result, SIZE);
    double avg = avg_result(golf_result, num);
    output_result(avg, golf_result, num);

    return 0;
}
int enter_result(int golf_result[], int array_size)
{
    std::cout << "Enter the results (1-10) or q to exit : " << std::endl;
    int i;
    for (i = 0; i < array_size; i++)
    {
        std::cout << "Result " << i + 1 << " : ";
        int enter = 0;

        if ( ! (std::cin >> enter) )
        {
            std::cin.clear();

            while (std::cin.get() != '\n')
            {
                continue;
            }
            std::cout << "Invalid Input.\n" << std::endl;
            break;
        }
        else if (enter < 1 || enter > 10)
        {
            while (std::cin.get() != '\n')
            {
                continue;
            }
            std::cout << "Input not in 1-10.\n" << std::endl;
            break;
        }
        golf_result[i] = enter;
    }
    return i;
}

double avg_result(int golf_result[], int array_size)
{
    double avg = 0;
    double summ = 0;

    for (int i = 0; i < array_size; i++)
    {
        summ += golf_result[i];
    }
    avg = summ / array_size;

    return avg;
}

void output_result(double avg, int golf_result[], int array_size)
{
    std::cout << "Result = ";

    for (int i = 0; i < array_size; i++)
    {
        std::cout << golf_result[i] << " ";
    }
    std::cout << "AVG = " << avg << std::endl;
}
显示结果如下
Enter the results (1-10) or q to exit :
Result 1 : 3
Result 2 : 4
Result 3 : 5
Result 4 : 6
Result 5 : 7
Result 6 : 8
Result 7 : 9
Result 8 : 1
Result 9 : 2
Result 10 : q
Invalid Input.

Result = 3 4 5 6 7 8 9 1 2 AVG = 5


3.下面是一个结构声明：
struct box
{
    char maker[128];
    double height;
    double width;
    double length;
    double volume;
};
a.编写一个函数，按值传递box结构，并显示每个成员的值
b.编写一个函数，传递box结构的地址，并将volume成员设置为其他三维长度的乘积。
c.编写一个使用这两个函数的简单程序。
#include <iostream>

using namespace std;

struct box
{
    char maker[128];
    double height;
    double width;
    double length;
    double volume;
};

void print_box(const box details);
void set_volume(box *address);

int main()
{
    box details;
    cout << "Enter maker : ";
    cin.get(details.maker, 128);

    while (cin.get() != '\n')
    {
        continue;
    }

    cout << "Enter height : ";
    cin >> details.height;
    cout << "Enter width : ";
    cin >> details.width;
    cout << "Enter length : ";
    cin >> details.length;

    set_volume(&details);
    cout << '\n';
    print_box(details);

    return 0;
}

void print_box(const box details)
{
    cout << "maker = " << details.maker << endl;
    cout << "height = " << details.height << endl;
    cout << "width = " << details.width << endl;
    cout << "length = " << details.length << endl;
    cout << "volume = " << details.volume << endl;
}

void set_volume(box *address)
{
    address->volume = (address->height) * (address->length) * (address->width);
}
显示结果如下
Enter maker : Hello World
Enter height : 3
Enter width : 5
Enter length : 7

maker = Hello World
height = 3
width = 5
length = 7
volume = 105

4.许多州的彩票发行机构都使用如程序清单7.4所示的简单彩票玩法的变体。
在这些玩法中，玩家从一组被称为域号码（field number）的号码中选择几个。
例如，可以从域号码1~47中选择5个号码；还可以从第二个区间（如1~27）选择一个号码（称为特选号码），
要赢得头奖，必须正确猜中所有的号码。中头奖的儿率是选中所有域号码的几率与选中特选号码几率的乘积。
例如，在这个例子中，中头奖的几率是从47个号码中正确选取5个号码的几率与
从27个号码中正确选择1个号码的几率的乘积。
请修改程序清单7.4，以计算中得这种彩票头奖的几率。
#include <iostream>

long double probability(int numbers, int picks);

int main()
{
    double total1 = 0;
    double total2 = 0;
    double choices = 0;

    std::cout << "Enter the total number of choices on the game card and\n";
    std::cout << "the number of picks allowed and\n";
    std::cout << "the total number of choices on the second game field\n";

    while ( (std::cin >> total1) && (std::cin >> choices) && choices <= total1 && (std::cin >> total2) )
    {
        std::cout << "You have one chance in " << probability(total1, choices) * probability(total2, 1) << " of winning.\n";
        std::cout << "Next two numbers (q to quit) : ";
    }
    std::cout << "Done.\n";

    return 0;
}
long double probability(int numbers, int picks)
{
    long double result = 1.0;
    long double n;
    int p;
    for (n = numbers, p = picks; p > 0; n--, p--)
    {
        result = result * n / p;
    }
    return result;
}
显示结果如下
Enter the total number of choices on the game card and
the number of picks allowed and
the total number of choices on the second game field
47 5 27
You have one chance in 4.14164e+07 of winning.
Next two numbers (q to quit) : q
Done.

5.定义一个递归函数，接受一个整数参数，并返回该参数的阶乘。
在程序中对该函数进行测试，程序使用循环让用户输入不同的值，程序将报告这些值的阶乘。
#include <iostream>

long double factorial(int number);

int main()
{
    std::cout << "Enter any integer (0 - N): ";
    int number = 0;
    std::cin >> number;

    long double Result = factorial(number);
    std::cout << number << "! = " << Result << std::endl;

    return 0;
}

long double factorial(int number)
{
    return number > 0 ? number * factorial(number - 1) : 1;
}
显示结果如下
Enter any integer (0 - N): 5
5! = 120

Enter any integer (0 - N): 6
6! = 720

Enter any integer (0 - N): 7
7! = 5040

Enter any integer (0 - N): 8
8! = 40320

Enter any integer (0 - N): 9
9! = 362880

6.编写一个程序，它使用下列函数fill_array将一个double数组的名称和长度作为参数。
它提示用户输入double值，并将这些值存储到数组中。
当数组被填满或用户输入了非数字时，输入将停止，并返回实际输入了多少个数字。
show_array将一个double数组的名称和长度作为参数，并显示该数组的内容
reverse_array将一个double数组的名称和长度作为参数，并将存储在数组中的值的顺序反转。
程序将使用这些函数来填充数组，然后显示数组；反转数组，然后显示数组；
反转数组中除第一个和最后一个元素之外的所有元素，然后显示数组。
#include <iostream>

const int SIZE = 10;

int fill_array(double massiv[], int size);
void Show_array(double massiv[], int size);
void Reverse_array(double massiv[], int size);

int main()
{
    double massiv[SIZE] = { 0 };

    int num = fill_array(massiv, SIZE);
    Show_array(massiv, num);
    std::cout << '\n';
    Reverse_array(massiv, num);
    Show_array(massiv, num);
    std::cout << '\n';
    Reverse_array(massiv + 1, num - 2);
    Show_array(massiv, num);

    return 0;
}

int fill_array(double massiv[], int size)
{
    double number;
    int i;
    for (i = 0; i < size; i++)
    {
        std::cout << "Value " << i + 1 << " = ";
        number = 0;
        if ( ! (std::cin >> number) )
        {
            break;
        }
        massiv[i] = number;
    }
    return i;
}

void Reverse_array(double massiv[], int size)
{
    for (int i = 0, j = size - 1; i < j; i++, j--)
    {
        double temp = 0;

        temp = massiv[i];
        massiv[i] = massiv[j];
        massiv[j] = temp;
    }
}

void Show_array(double massiv[], int size)
{
    for (int i = 0; i < size; i++)
    {
        std::cout << massiv[i] << std::endl;
    }
}
显示结果如下
Value 1 = 1.1
Value 2 = 2.2
Value 3 = 3.3
Value 4 = 4.4
Value 5 = 5.5
Value 6 = 6.6
Value 7 = 7.7
Value 8 = q
1.1
2.2
3.3
4.4
5.5
6.6
7.7

7.7
6.6
5.5
4.4
3.3
2.2
1.1

7.7
2.2
3.3
4.4
5.5
6.6
1.1

7.修改程序清单7.7中的3个数组处理函数，使之使用两个指针参数来表示区间。
fill_array函数不返回实际读取了多少个数字，而是返回一个指针，该指针指向最后被填充的位置；
其他的函数可以将该指针作为第二个参数，以标识数据结尾。
#include <iostream>

const int Max = 5;

double *fill_array(double *arrBegin, double *arrEnd);
void show_array(double *arrBegin, double *arrEnd);
void revalue(double r, double *arrBegin, double *arrEnd);

int main()
{
    double properties[Max];
    double *size = fill_array(properties, properties + Max);
    show_array(properties, size);

    if ( (size - properties) > 0)
    {
        std::cout << "Enter revaluation factor: ";
        double factor = 0.0;
        while (!(std::cin >> factor))
        {
            std::cin.clear();
            while (std::cin.get() != '\n')
            {
                continue;
            }
            std::cout << "Bad input; Please enter a number: ";
        }
        revalue(factor, properties, size);
        show_array(properties, size);
    }
    std::cout << "Done.\n";

    return 0;
}

double *fill_array(double *arrBegin, double *arrEnd)
{
    double temp;
    int i = 0;
    double *pt = nullptr;

    for (pt = arrBegin; pt != arrEnd; pt++)
    {
        std::cout << "Enter value #" << (++i) << ": ";
        temp = 0;
        if ( ! (std::cin >> temp) )
        {
            std::cin.clear();
            while (std::cin.get() != '\n')
            {
                continue;
            }
            std::cout << "Bad input; input process terminated.\n";
            break;
        }
        else if (temp < 0)
        {
            while (std::cin.get() != '\n')
            {
                continue;
            }
            std::cout << "input process terminated.\n";
            break;
        }
        *pt = temp;
    }
    return pt;
}

void show_array(double *arrBegin, double *arrEnd)
{
    int i = 0;
    for (double *pt = arrBegin; pt != arrEnd; pt++)
    {
        std::cout << "Property #" << (++i) << ": $";
        std::cout << *pt << std::endl;
    }
}

void revalue(double factor, double *arrBegin, double *arrEnd)
{
    for (double *pt = arrBegin; pt != arrEnd; pt++)
    {
        *pt *= factor;
    }
}
显示结果如下
Enter value #1: 10000
Enter value #2: 20000
Enter value #3: 30000
Enter value #4: q
Bad input; input process terminated.
Property #1: $10000
Property #2: $20000
Property #3: $30000
Enter revaluation factor: 0.6
Property #1: $6000
Property #2: $12000
Property #3: $18000
Done.

8.在不使用array类的情况下完成程序清单7.15所做的工作。
编写两个这样的版本：
a.使用const char*数组存储表示季度名称的字符串，并使用double数组存储开支
#include <iostream>
#include <array>
#include <string>

const int Seasons = 4;

const char *Snames[Seasons] =
{
    "Spring", "Summer", "Fall", "Winter"
};

void fill(double expenses[], const int Seasons);
void show(double expenses[], const int Seasons);

int main()
{
    double expenses[Seasons];
    fill(expenses, Seasons);
    show(expenses, Seasons);

    return 0;
}

void fill(double expenses[], const int Seasons)
{
    for (int i = 0; i < Seasons; i++)
    {
        std::cout << "Enter " << Snames[i] << " expenses: ";
        std::cin >> expenses[i];
    }
}

void show(double expenses[], const int Seasons)
{
    double total = 0.0;
    std::cout << "\nEXPENSES\n";
    for (int i = 0; i < Seasons; i++)
    {
        std::cout << Snames[i] << ": $" << expenses[i] << std::endl;
        total += expenses[i];
    }
    std::cout << "Total Expenses: $" << total << std::endl;
}
显示结果如下
Enter Spring expenses: 10000
Enter Summer expenses: 20000
Enter Fall expenses: 15000
Enter Winter expenses: 23000

EXPENSES
Spring: $10000
Summer: $20000
Fall: $15000
Winter: $23000
Total Expenses: $68000

b.使用const char*数组存储表示季度名称的字符串，并使用一个结构，该结构只有一个成员：用于存储开支的double数组。
#include <iostream>
#include <array>
#include <string>

const int Seasons = 4;

const char Snames[][8] =
{
    "Spring", "Summer", "Fall", "Winter"
};

struct Expenses
{
    double expenses[Seasons];
};

void fill(const char Snames[][8], Expenses *exp);
void show(const char Snames[][8], Expenses *exp);

int main()
{
    Expenses exp;
    fill(Snames, &exp);
    show(Snames, &exp);

    return 0;
}

void fill(const char Snames[][8], Expenses *exp)
{
    for (int i = 0; i < Seasons; i++)
    {
        std::cout << "Enter " << Snames[i] << " expenses: ";
        std::cin >> exp->expenses[i];
    }
}

void show(const char Snames[][8], Expenses *exp)
{
    double total = 0.0;
    std::cout << "\nEXPENSES\n";
    for (int i = 0; i < Seasons; i++)
    {
        std::cout << Snames[i] << ": $" << exp->expenses[i] <<  std::endl;
        total += exp->expenses[i];
    }
    std::cout << "Total Expenses: $" << total <<  std::endl;
}
显示结果如下
Enter Spring expenses: 10000
Enter Summer expenses: 20000
Enter Fall expenses: 50000
Enter Winter expenses: 10000

EXPENSES
Spring: $10000
Summer: $20000
Fall: $50000
Winter: $10000
Total Expenses: $90000

9.这个练习让您编写处理数组和结构的函数。下面是程序的框架，请提供其中描述的函数，以完成该程序。
#include <iostream>
#include <cstring>

const int SLEN = 128;

struct student
{
    char fullname[SLEN] = {0};
    char hobby[SLEN];
    int ooplevel;
};

int getinfo(student pa[], int n);
void display1(student st);
void display2(const student *ps);
void display3(const student pa[], int n);

int main()
{
    std::cout << "Enter class size: ";
    int class_size = 0;
    std::cin >> class_size;

    while (std::cin.get() != '\n')
    {
        continue;
    }

    student *ptr_stu = new student[class_size];
    int entered = getinfo(ptr_stu, class_size);

    for (int i = 0; i < entered; i++)
    {
        display1(ptr_stu[i]);
        display2(&ptr_stu[i]);
    }
    display3(ptr_stu, entered);

    delete[] ptr_stu;
    std::cout << "Done.\n";

    return 0;
}

int getinfo(student pa[], int class_size)
{
    int enteredCount = 0;

    for (int i = 0; i < class_size; i++)
    {
        std::cout << "Student " << i + 1 << std::endl;
        std::cout << "Enter name: ";

        std::cin.getline(pa[i].fullname, SLEN);

        if (strlen(pa[i].fullname) != 0)
        {
            std::cout << "Enter hobby: ";
            std::cin.getline(pa[i].hobby, SLEN);

            std::cout << "Enter ooplevel: ";
            (std::cin >> pa[i].ooplevel).get();
        }
        else
        {
            break;
        }
        ++enteredCount;
        std::cout << std::endl;
    }
    return enteredCount;
}

void display1(student st)
{
    std::cout << "Name: ";
    std::cout << st.fullname << std::endl;
    std::cout << "Hobby: ";
    std::cout << st.hobby << std::endl;
    std::cout << "Ooplevel: ";
    std::cout << st.ooplevel << std::endl;
    std::cout << std::endl;
}

void display2(const student *ps)
{
    std::cout << "Name: ";
    std::cout << ps->fullname << std::endl;
    std::cout << "Hobby: ";
    std::cout << ps->hobby << std::endl;
    std::cout << "Ooplevel: ";
    std::cout << ps->ooplevel << std::endl;
    std::cout << std::endl;
}

void display3(const student pa[], int n)
{
    for (int i = 0; i < n; ++i)
    {
        std::cout << "Name: ";
        std::cout << pa[i].fullname << std::endl;
        std::cout << "Hobby: ";
        std::cout << pa[i].hobby << std::endl;
        std::cout << "Ooplevel: ";
        std::cout << pa[i].ooplevel << std::endl;
        std::cout << std::endl;
    }
}
显示结果如下
Enter class size: 6
Student 1
Enter name: Peter Smith
Enter hobby: abc
Enter ooplevel: 1

Student 2
Enter name: Mike Pence
Enter hobby: 123
Enter ooplevel: 2

Student 3
Enter name: Hello World
Enter hobby: efg
Enter ooplevel: 3

Student 4
Enter name:
Name: Peter Smith
Hobby: abc
Ooplevel: 1

Name: Peter Smith
Hobby: abc
Ooplevel: 1

Name: Mike Pence
Hobby: 123
Ooplevel: 2

Name: Mike Pence
Hobby: 123
Ooplevel: 2

Name: Hello World
Hobby: efg
Ooplevel: 3

Name: Hello World
Hobby: efg
Ooplevel: 3

Name: Peter Smith
Hobby: abc
Ooplevel: 1

Name: Mike Pence
Hobby: 123
Ooplevel: 2

Name: Hello World
Hobby: efg
Ooplevel: 3

Done.

10.设计一个名为calculate的函数，它接受两个double值和一个指向函数的指针，
而被指向的函数接受两个double参数，并返回一个double值。
calculate函数返回被指向的函数使用calculate的两个double参数计算得到的值。
请编写一个程序，该程序使用循环来让用户成对地输入数字。
对于每对数字，程序都使用calculate来调用add和至少一个其他的函数。
#include <iostream>

double Multiplication(double x, double y);
double Division(double x, double y);
double Subtraction(double x, double y);
double Addition(double x, double y);
double Calculate(double x, double y, double (*pf)(double x, double y));
void print_menu();

int main()
{
    print_menu();
    int menu = 0;
    while (std::cin >> menu)
    {
        double x = 0, y = 0;
        switch (menu)
        {
        case 1:
            std::cout << "Enter x and y : ";
            std::cin >> x >> y;
            std::cout << x << " * " << y << " = " << Calculate(x, y, Multiplication) << std::endl;
            break;
        case 2:
            std::cout << "Enter x and y : ";
            std::cin >> x >> y;
            std::cout << x << " / " << y << " = " << Calculate(x, y, Division) << std::endl;
            break;
        case 3:
            std::cout << "Enter x and y : ";
            std::cin >> x >> y;
            std::cout << x << " - " << y << " = " << Calculate(x, y, Subtraction) << std::endl;
            break;
        case 4:
            std::cout << "Enter x and y : ";
            std::cin >> x >> y;
            std::cout << x << " + " << y << " = " << Calculate(x, y, Addition) << std::endl;
            break;
        default:
            std::cout << "Invalid input" << std::endl;
            break;
        }
        print_menu();
        menu = 0;
    }

    return 0;
}

double Multiplication(double x, double y)
{
    return x * y;
}

double Division(double x, double y)
{
    return x / y;
}

double Subtraction(double x, double y)
{
    return x - y;
}

double Addition(double x, double y)
{
    return x + y;
}

double Calculate(double x, double y, double(*pf)(double x, double y))
{
    return (*pf)(x, y);
}

void print_menu()
{
    std::cout << "Choose the action of the calculator: " << std::endl;
    std::cout << "[1] - Multiplication: " << std::endl;
    std::cout << "[2] - Division: " << std::endl;
    std::cout << "[3] - Subtraction: " << std::endl;
    std::cout << "[4] - Addition: " << std::endl;
    std::cout << "[q] - Quit: " << std::endl;
}
显示结果如下
Choose the action of the calculator:
[1] - Multiplication:
[2] - Division:
[3] - Subtraction:
[4] - Addition:
[q] - Quit:
1
Enter x and y : 2 3
2 * 3 = 6
Choose the action of the calculator:
[1] - Multiplication:
[2] - Division:
[3] - Subtraction:
[4] - Addition:
[q] - Quit:
2
Enter x and y : 18 3
18 / 3 = 6
Choose the action of the calculator:
[1] - Multiplication:
[2] - Division:
[3] - Subtraction:
[4] - Addition:
[q] - Quit:
3
Enter x and y : 6 3
6 - 3 = 3
Choose the action of the calculator:
[1] - Multiplication:
[2] - Division:
[3] - Subtraction:
[4] - Addition:
[q] - Quit:
4
Enter x and y : 6 3
6 + 3 = 9
Choose the action of the calculator:
[1] - Multiplication:
[2] - Division:
[3] - Subtraction:
[4] - Addition:
[q] - Quit:
q

第8章 函数探幽
8.1 C++内联函数
8.2 引用变量
8.2.1 创建引用变量
8.2.2 将引用用作函数参数
8.2.3 引用的属性和特别之处
8.2.4 将引用用于结构
8.2.5 将引用用于类对象
8.2.6 对象、继承和引用
8.2.7 何时使用引用参数
8.3 默认参数
8.4 函数重载
8.4.1 重载示例
8.4.2 何时使用函数重载
8.5 函数模板
8.5.1 重载的模板
8.5.2 模板的局限性
8.5.3 显式具体化
8.5.4 实例化和具体化
8.5.5 编译器选择使用哪个函数版本
8.5.6 模板函数的发展
8.6 总结
8.7 复习题
8.8 编程练习
本章内容包括：
内联函数。
引用变量。
如何按引用传递函数参数。
默认参数。
函数重载。
函数模板。
函数模板具体化。
8.1 C++内联函数
内联函数是C++为提高程序运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。
常规函数调用使程序跳到另一个地址（函数的地址），并在函数结束时返回，需要额外的开销。
对于内联函数，程序无需跳到另一个位置处执行代码，再跳回来，编译器将使用内联函数的代码替换函数调用。
因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。
如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数代码的10个副本（参见图8.1）。
应有选择地使用内联函数。如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将只占整个过程的很小一部分。
如果代码执行时间很短且经常被调用，则内联调用就可以节省处理非内联调用的大部分时间。
在函数声明前加上关键字inline，在函数定义前加上关键字inline。
程序员请求将函数作为内联函数时，编译器并不一定会满足这种要求。
它可能认为该函数过大或注意到函数调用了自己（内联函数不能递归），因此不将其作为内联函数。
程序清单8.1 inline.cpp-
#include <iostream>

using namespace std;

inline double square(double x)
{
    return x * x;
}

int main()
{
    double a, b;
    double c = 13.0;
    a = square(5.0);
    b = square(4.5 + 7.5);
    cout << "a = " << a << ", b = " << b << "\n";
    cout << "c = " << c;
    cout << ", c squared = " << square(c++) << "\n";
    cout << "Now c = " << c << "\n";

    return 0;
}
显示结果如下
a = 25, b = 144
c = 13, c squared = 169
Now c = 14

8.2 引用变量
引用变量是已定义的变量的别名（另一个名称）。引用变量的主要用途是用作函数的形参。
通过将引用变量用作参数，函数将使用原始数据，而不是其副本。引用也为函数处理大型结构提供了一种非常方便的途径。
程序清单8.2 firstref.cpp
#include <iostream>

using namespace std;

int main()
{
    int rats = 101;
    int &rodents = rats;

    cout << "rats = " << rats;
    cout << ", rodents = " << rodents << endl;
    rodents++;
    cout << "rats = " << rats;
    cout << ", rodents = " << rodents << endl;

    cout << "rats address = " << &rats;
    cout << ", rodents address = " << &rodents << endl;

    return 0;
}
显示结果如下
rats = 101, rodents = 101
rats = 102, rodents = 102
rats address = 0x7ffcc6d73fec, rodents address = 0x7ffcc6d73fec

程序清单8.3 secref.cpp
#include <iostream>

using namespace std;

int main()
{
    int rats = 101;
    int &rodents = rats;
    cout << "rats = " << rats;
    cout << ", rodents = " << rodents << endl;
    cout << "rats address = " << &rats;
    cout << ", rodents address = " << &rodents << endl;

    int bunnies = 50;
    rodents = bunnies;
    cout << "bunnies = " << bunnies;
    cout << ", rats = " << rats;
    cout << ", rodents = " << rodents << endl;
    cout << "bunnies address = " << &bunnies;
    cout << ", rodents address = " << &rodents << endl;

    return 0;
}
显示结果如下
rats = 101, rodents = 101
rats address = 0x7fff8a427d58, rodents address = 0x7fff8a427d58
bunnies = 50, rats = 50, rodents = 50
bunnies address = 0x7fff8a427d5c, rodents address = 0x7fff8a427d58

程序清单8.4 swaps.cpp
#include <iostream>

using namespace std;

void swapr(int &a, int &b);
void swapp(int *p, int *q);
void swapv(int a, int b);

int main()
{
    int wallet1 = 300;
    int wallet2 = 350;
    cout << "walletl = $" << wallet1;
    cout << " wallet2 = $" << wallet2 << endl;

    cout << "Using references to swap contents:\n";
    swapr(wallet1, wallet2);
    cout << "walletl = $" << wallet1;
    cout << " wallet2 = $" << wallet2 << endl;

    cout << "Using pointers to swap contents again:\n";
    swapp(&wallet1, &wallet2);
    cout << "walletl = $" << wallet1;
    cout << " wallet2 = $" << wallet2 << endl;

    cout << "Trying to use passing by value:\n";
    swapv(wallet1, wallet2);
    cout << "walletl = $" << wallet1;
    cout << " wallet2 = $" << wallet2 << endl;

    return 0;
}

void swapr(int &a, int &b)
{
    int temp;
    temp = a;
    a = b;
    b = temp;
}

void swapp(int *p, int *q)
{
    int temp;
    temp = *p;
    *p = *q;
    *q = temp;
}

void swapv(int a, int b)
{
    int temp;
    temp = a;
    a = b;
    b = temp;
}
显示结果如下
walletl = $300 wallet2 = $350
Using references to swap contents:
walletl = $350 wallet2 = $300
Using pointers to swap contents again:
walletl = $300 wallet2 = $350
Trying to use passing by value:
walletl = $300 wallet2 = $350

程序清单8.5 cubes.cpp
#include <iostream>

using namespace std;

double cube(double a);
double refcube(double &ra);

int main()
{
    double x = 3.0;
    cout << cube(x) << " = cube of " << x << endl;
    cout << refcube(x) << " = cube of " << x << endl;

    return 0;
}
double cube(double a)
{
    a *= a * a;
    return a;
}

double refcube(double &ra)
{
    ra *= ra * ra;
    return ra;
}
显示结果如下
27 = cube of 3
27 = cube of 27

程序清单8.6 strc_ref.cpp
#include <iostream>
#include <string>

using namespace std;

struct free_throws
{
    string name;
    int made;
    int attempts;
    double percent;
};

void display(const free_throws &ft);
void set_pc(free_throws &ft);
free_throws &accumulate(free_throws &target, const free_throws &source);

int main()
{
    free_throws one = { "Ifelsa Branch", 13, 14 };
    free_throws two = { "Andor Knott", 10, 16 };
    free_throws three = { "Minnie Max", 7, 9 };
    free_throws four = { "Whily Looper", 5, 9 };
    free_throws five = { "Long Long", 6, 14 };
    free_throws team = { "Throwgoods", 0, 0 };

    free_throws dup;
    set_pc(one);
    display(one);
    accumulate(team, one);
    display(team);

    display(accumulate(team, two));
    accumulate(accumulate(team, three), four);
    display(team);

    dup = accumulate(team, five);
    cout << "Displaying team:\n";
    display(team);

    cout << "Displaying dup after assignment:\n";
    display(dup);
    set_pc(four);
    accumulate(dup, five) = four;

    cout << "Displaying dup after ill-advised assignment:\n";
    display(dup);

    return 0;
}

void display(const free_throws &ft)
{
    cout << "Name: " << ft.name << '\n';
    cout << "Made: " << ft.made << '\t';
    cout << "Attempts: " << ft.attempts << '\t';
    cout << "Percent: " << ft.percent << '\n';
}

void set_pc(free_throws &ft)
{
    if (ft.attempts != 0)
    {
        ft.percent = 100.0 * double(ft.made) / double(ft.attempts);
    }
    else
    {
        ft.percent = 0;
    }
}

free_throws &accumulate(free_throws &target, const free_throws &source)
{
    target.attempts += source.attempts;
    target.made += source.made;
    set_pc(target);
    return target;
}
显示结果如下
Name: Ifelsa Branch
Made: 13        Attempts: 14    Percent: 92.8571
Name: Throwgoods
Made: 13        Attempts: 14    Percent: 92.8571
Name: Throwgoods
Made: 23        Attempts: 30    Percent: 76.6667
Name: Throwgoods
Made: 35        Attempts: 48    Percent: 72.9167
Displaying team:
Name: Throwgoods
Made: 41        Attempts: 62    Percent: 66.129
Displaying dup after assignment:
Name: Throwgoods
Made: 41        Attempts: 62    Percent: 66.129
Displaying dup after ill-advised assignment:
Name: Whily Looper
Made: 5 Attempts: 9     Percent: 55.5556

程序清单8.7 strquote.cpp
#include <iostream>
#include <string>

using namespace std;

string version1(const string &si, const string &s2);
const string &version2(string &si, const string &s2);
const string version3(string &si, const string &s2);

int main()
{
    string input;
    string copy;
    string result;
    cout << "Enter a string: ";
    getline(cin, input, '\n');
    copy = input;
    cout << "Your string as entered: " << input << endl;
    result = version1(input, "***");
    cout << "Your string enhanced: " << result << endl;
    cout << "Your original string: " << input << endl;
    result = version2(input, "###");
    cout << "Your string enhanced: " << result << endl;
    cout << "Your original string: " << input << endl;
    cout << "Resetting original string.\n";
    input = copy;
    result = version3(input, "@@@");
    cout << "Your string enhanced: " << result << endl;
    cout << "Your original string: " << input << endl;

    return 0;
}

string version1(const string &si, const string &s2)
{
    string temp;
    temp = s2 + si + s2;
    return temp;
}

const string &version2(string &si, const string &s2)
{
    si = s2 + si + s2;
    return si;
}

const string version3(string &si, const string &s2)
{
    string temp;
    temp = s2 + si + s2;
    return temp;
}
显示结果如下
Enter a string: Hello World
Your string as entered: Hello World
Your string enhanced: ***Hello World***
Your original string: Hello World
Your string enhanced: ###Hello World###
Your original string: ###Hello World###
Resetting original string.
Your string enhanced: @@@Hello World@@@
Your original string: Hello World

程序清单8.8 filefunc.cpp
#include <iostream>
#include <fstream>
#include <cstdlib>

using namespace std;

const int LIMIT = 5;

void file_it(ostream &os, double fo, const double fe[], int n);

int main()
{
    ofstream fout;
    const char *fn = "filefun_data.txt";
    fout.open(fn);
    if (!fout.is_open())
    {
        cout << "Can't open " << fn << "\n";
        exit(EXIT_FAILURE);
    }
    double objective;
    cout << "Enter the focal length of your telescope objective in mm: ";
    cin >> objective;
    double eps[LIMIT];
    cout << "Enter the focal lengths, in mm, of " << LIMIT << " eyepieces:\n";
    for (int i = 0; i < LIMIT; i++)
    {
        cout << "Eyepiece #" << i + 1 << ": ";
        cin >> eps[i];
    }
    file_it(fout, objective, eps, LIMIT);
    file_it(cout, objective, eps, LIMIT);
    cout << "Done.\n";

    return 0;
}

void file_it(ostream &os, double fo, const double fe[], int n)
{
    ios_base::fmtflags initial;
    initial = os.setf(ios_base::fixed);
    os.precision(0);
    os << "Focal length of objective: " << fo << " mm\n";
    os.setf(ios::showpoint);
    os.precision(1);
    os.width(12);
    os << "f.l. eyepiece";
    os.width(15);
    os << "magnification" << endl;
    for (int i = 0; i < n; i++)
    {
        os.width(12);
        os << fe[i];
        os.width(15);
        os << int(fo / fe[i] + 0.5) << endl;
    }
    os.setf(initial);
}
显示结果如下
Enter the focal length of your telescope objective in mm: 1800
Enter the focal lengths, in mm, of 5 eyepieces:
Eyepiece #1: 30
Eyepiece #2: 19
Eyepiece #3: 14
Eyepiece #4: 8.8
Eyepiece #5: 7.5
Focal length of objective: 1800 mm
f.l. eyepiece  magnification
        30.0             60
        19.0             95
        14.0            129
         8.8            205
         7.5            240
Done.

cat filefun_data.txt
Focal length of objective: 1800 mm
f.l. eyepiece  magnification
        30.0             60
        19.0             95
        14.0            129
         8.8            205
         7.5            240

8.3默认参数
默认参数指的是当函数调用中省略了实参时自动使用的一个值。
程序清单8.9 left.cpp
#include <iostream>

using namespace std;

const int ArSize = 128;

char *left(const char *str, int n = 1);

int main()
{
    char sample[ArSize];
    cout << "Enter a string:\n";
    cin.getline(sample, ArSize);
    char *ps = left(sample, 4);
    cout << ps << endl;
    delete[] ps;
    ps = left(sample);
    cout << ps << endl;
    delete[] ps;

    return 0;
}
char *left(const char *str, int n)
{
    if (n < 1)
    {
        n = 1;
    }
    char *p = new char[n + 1];
    int i;
    for (i = 0; i < n && str[i]; i++)
    {
        p[i] = str[i];
    }
    while (i <= n)
    {
        p[i++] = '\0';
    }
    return p;
}
显示结果如下
Enter a string:
Hello, World!
Hell
H

8.4 函数重载
默认参数让您能够使用不同数目的参数调用同一个函数，而函数多态（函数重载）让您能够使用多个同名的函数。
可以通过函数重载来设计一系列函数，它们完成相同的工作，但使用不同的参数列表。
C++根据函数的参数列表（参数数目和参数类型）确定要使用的重载函数版本。
程序清单8.10 leftover.cpp
#include <iostream>

using namespace std;

long long left(long long num, int ct);
char *left(const char *str, int n = 1);

int main()
{
    const char *trip = "abcdefghijkl";
    long long n = 123456789876;
    int i;
    char *temp;
    for (i = 1; i < 10; i++)
    {
        cout << left(n, i) << endl;
        temp = left(trip, i);
        cout << temp << endl;
        delete[] temp;
    }

    return 0;
}

long long left(long long num, int ct)
{
    if (ct <= 0 || num <= 0)
    {
        return 0;
    }
    int digits = 1;
    long long n = num;
    while (n /= 10)
    {
        digits++;
    }
    if (digits > ct)
    {
        ct = digits - ct;
        while (ct--)
        {
            num /= 10;
        }
        return num;
    }
    else
    {
        return num;
    }
}
char *left(const char *str, int n)
{
    if (n < 1)
    {
        n = 1;
    }
    char *p = new char[n + 1];
    int i;
    for (i = 0; i < n && str[i]; i++)
    {
        p[i] = str[i];
    }
    while (i <= n)
    {
        p[i++] = '\0';
    }
    return p;
}
显示结果如下
1
a
12
ab
123
abc
1234
abcd
12345
abcde
123456
abcdef
1234567
abcdefg
12345678
abcdefgh
123456789
abcdefghi

8.5函数模板
函数模板使用泛型来定义函数，其中的泛型可用具体的类型替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。
由于模板允许以泛型（而不是具体类型）的方式编写程序，因此有时也被称为泛型编程。
程序清单8.11 funtemp.cpp
#include <iostream>

using namespace std;

template <typename T>
void Swap(T &a, T &b);

int main()
{
    int i = 10;
    int j = 20;
    cout << "i, j = " << i << ", " << j << "\n";
    cout << "Using compiler-generated int swapper:\n";
    Swap(i, j);
    cout << "Now i, j = " << i << ", " << j << "\n";
    double x = 24.5;
    double y = 81.7;
    cout << "x, y = " << x << ", " << y << "\n";
    cout << "Using compiler-generated double swapper:\n";
    Swap(x, y);
    cout << "Now x, y = " << x << ", " << y << "\n";

    return 0;
}
template <typename T>
void Swap(T &a, T &b)
{
    T temp;
    temp = a;
    a = b;
    b = temp;
}
显示结果如下
i, j = 10, 20
Using compiler-generated int swapper:
Now i, j = 20, 10
x, y = 24.5, 81.7
Using compiler-generated double swapper:
Now x, y = 81.7, 24.5

程序清单8.12 twotemps.cpp
#include <iostream>

using namespace std;

const int Lim = 8;

template <typename T>
void Swap(T &a, T &b);
template <typename T>
void Swap(T a[], T b[], int n);
void Show(int a[], int n);

int main()
{
    int i = 10, j = 20;
    cout << "i, j = " << i << ", " << j << "\n";
    cout << "Using compiler-generated int swapper:\n";
    Swap(i, j);
    cout << "Now i, j = " << i << ", " << j << "\n";
    int d1[Lim] = { 0, 7, 0, 4, 1, 7, 7, 6 };
    int d2[Lim] = { 0, 7, 2, 0, 1, 9, 6, 9 };
    cout << "Original arrays:\n";
    Show(d1, Lim);
    Show(d2, Lim);
    Swap(d1, d2, Lim);
    cout << "Swapped arrays:\n";
    Show(d1, Lim);
    Show(d2, Lim);

    return 0;
}
template <typename T>
void Swap(T &a, T &b)
{
    T temp;
    temp = a;
    a = b;
    b = temp;
}
template <typename T>
void Swap(T a[], T b[], int n)
{
    T temp;
    for (int i = 0; i < n; i++)
    {
        temp = a[i];
        a[i] = b[i];
        b[i] = temp;
    }
}
void Show(int a[], int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        if (i != 0)
        {
            cout << ", ";
        }
        cout << a[i];
    }

    cout << endl;
}
显示结果如下
i, j = 10, 20
Using compiler-generated int swapper:
Now i, j = 20, 10
Original arrays:
0, 7, 0, 4, 1, 7, 7, 6
0, 7, 2, 0, 1, 9, 6, 9
Swapped arrays:
0, 7, 2, 0, 1, 9, 6, 9
0, 7, 0, 4, 1, 7, 7, 6

对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本。
显式具体化的原型和定义应以template <>开头，并通过名称来指出类型。
具体化优先于常规模板，而非模板函数优先于具体化和常规模板。
// non-template function prototype
void Swap(job &, job &);
// template prototype
template <typename T>
void Swap(T &, T &);
// explicit specialization for the job type
template <> void Swap<job> (job &, job &);
Swap<job>中的<job>是可选的，因为函数的参数类型表明，这是job的一个具体化。
因此，该原型也可以这样编写：
template <> void Swap (job &, job &);

程序清单8.13 twoswap.cpp
#include <iostream>

using namespace std;

struct job
{
    char name[128];
    double salary;
    int floor;
};

template <typename T>
void Swap(T &a, T &b);

template <> void Swap<job> (job &j1, job &j2);
void Show(job &j);

int main()
{
    cout.precision(2);
    cout.setf(ios::fixed, ios::floatfield);
    int i = 10, j = 20;
    cout << "i, j = " << i << ", " << j << "\n";
    cout << "Using compiler-generated int swapper \n";
    Swap(i, j);
    cout << "Now i, j = " << i << ", " << j << " \n";
    job sue = { "Susan Yaffee", 73000.60, 7 };
    job sidney = { "Sidney Taffee", 78060.72, 9 };
    cout << "Before job swapping \n";
    Show(sue);
    Show(sidney);
    Swap(sue, sidney);
    cout << "After job swapping \n";
    Show(sue);
    Show(sidney);

    return 0;
}
template <typename T>
void Swap(T &a, T &b)
{
    T temp;
    temp = a;
    a = b;
    b = temp;
}
template <> void Swap<job> (job &j1, job &j2)
{
    double t1;
    int t2;
    t1 = j1.salary;
    j1.salary = j2.salary;
    j2.salary = t1;
    t2 = j1.floor;
    j1.floor = j2.floor;
    j2.floor = t2;
}
void Show(job &j)
{
    cout << j.name << " : $" << j.salary << " on floor " << j.floor << endl;
}
显示结果如下
i, j = 10, 20
Using compiler-generated int swapper
Now i, j = 20, 10
Before job swapping
Susan Yaffee : $73000.60 on floor 7
Sidney Taffee : $78060.72 on floor 9
After job swapping
Susan Yaffee : $78060.72 on floor 9
Sidney Taffee : $73000.60 on floor 7

8.5.4 实例化和具体化
在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。
编译器使用模板为特定类型生成函数定义时，得到的是模板实例（instantiation）。
这种实例化方式被称为隐式实例化（implicit instantiation）。
C++还允许显式实例化（explici instantiation），用<>符号指示类型，并在声明前加上关键字template。
template void Swap<int> (int &, int &);   //explicit instantiation
编译器看到上述声明后，将使用Swap模板生成一个使用int类型的实例。
也就是说，该声明的意思是"使用Swap模板生成int类型的函数定义"。
与显式实例化不同的是，显式具体化使用下面两个等价的声明之一
template <> void Swap<int> (int &, int &);   // explicit specialization
tempiate <> void Swap (int &, int &);   // explicit specialization
这些声明的意思是"不要使用Swap模板来生成函数定义，而应使用专门为int类型显式地定义的函数定义"。
这些原型必须有自己的函数定义。显式具体化声明在关键字template后包含<>，而显式实例化没有。
警告：试图在同一个文件（或转换单元）中使用同一种类型的显式实例和显式具体化将出错
还可通过在程序中使用函数来创建显式实例化。例如，请看下面的代码
template <typename T>
T Add (T a, T b)
{
    return a + b;
}
...
int m = 6;
double x = 10.2;
cout << Add<double> (x, m) << endl;   // explicit instantiation
这里的模板与函数调用Add (x, m)不匹配，因为该模板要求两个函数参数的类型相同。
但通过使用Add<double> (x, m) 可强制为double类型实例化，并将参数m强制转换为double类型，
以便与函数Add<double> (double, double)的第二个参数匹配。
如果对Swap做类似的处理，结果将如何呢？
int m =5;
double x=14.3;
Swap<double> (m, x);
这将为类型double生成一个显式实例化。
不幸的是，这些代码不管用，因为第一个形参的类型为double&，不能指向int变量m。
隐式实例化、显式实例化和显式具体化统称为具体化（specialization），
它们的相同之处在于，它们表示的都是使用具体类型的函数定义，而不是通用描述。
引入显式实例化后，必须在声明中使用前缀template和template <>，以区分显式实例化和显式具体化。
通常，功能越多，语法规则也越多。下面的代码片段总结了这些概念：
template <class T>
void Swap (T &, T &):   //template prototype
template <> void Swap<job> (job &, job &);   // explicit specialization for job
int main (void)
{
    template void Swap<char> (char &, char &);   //explicit instantiation for char
    short a, b;
    ...
    Swap (a, b);   //implicit template instantiation for short
    job n, m;
    ...
    Swap (n, m);   //use explicit specialization for job
    char g, h;
    ...
    Swap (g, h);   //use explicit template instantiation for char
    ...
}
编译器看到char的显式实例化后，将使用模板定义来生成Swap的char版本。
对于其他Swap调用，编译器根据函数调用中实际使用的参数，生成相应的版本。
例如，当编译器看到函数调用Swap (a, b)后，将生成Swap的short版本，因为两个参数的类型都是short。
当编译器看到Swap (n, m)后，将使用为job类型提供的独立定义（显式具体化）。
当编译器看到Swap (g, h)后，将使用处理显式实例化时生成的模板具体化。
8.5.5 编译器选择使用哪个函数版本
对于函数重载、函数模板和函数模板重载，C++需要（且有）一个定义良好的策略，
来决定为函数调用使用哪一个函数定义，尤其是有多个参数时。
这个过程称为重载解析（overloading resolution），我们先大致了解一下这个过程是如何进行的。
第1步：创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数
第2步：使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，
为此有一个隐式转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。
第3步：确定是否有最佳的可行函数。如果有，则使用它，否则该函数调用出错。
编译器必须确定哪个可行函数是最佳的。它查看为使函数调用参数与可行的候选函数的参数匹配所需要进行的转换。
通常，从最佳到最差的顺序如下所述。
1.完全匹配，但常规函数优先于模板。
2.提升转换（例如，char和short自动转换为int，float自动转换为double）。
3.标准转换（例如，int转换为char，long转换为double）。
4.用户定义的转换，如类声明中定义的转换。
通常，有两个或两个以上函数完全匹配是一种错误，但这一规则有两个例外。显然，我们需要对这一点做更深入的探讨。
完全匹配和最佳匹配
进行完全匹配时，C++允许某些"无关紧要的转换"。表8.1列出了这些转换，Type表示任意类型。
从实参                                              到形参
Type                                                Type &
Type &                                            Type
Type []                                             Type *
Type (argument-list)                      Type (*) (argument-list)
Type                                                 const Type
Type                                                 volatile Type
Type *                                               const Type *
Type *                                               volatile Type *
Type (argument-list)意味着用作实参的函数名与用作形参的函数指针只要返回类型和参数列表相同，就是匹配的。
如果有多个匹配的原型，则编译器将无法完成重载解析过程；
如果没有最佳的可行函数，则编译器将生成一条错误消息。
然而，有时候，即使两个函数都完全匹配，仍可完成重载解析。
首先，指向非const数据的指针和引用优先与非const指针和引用参数匹配。
一个完全匹配优于另一个的另一种情况是，其中一个是非模板函数，而另一个不是。
在这种情况下，非模板函数将优先于模板函数（包括显式具体化）。
如果两个完全匹配的函数都是模板函数，则较具体的模板函数优先。
例如，这意味着显式具体化将优于使用模板隐式生成的具体化。
术语“最具体（most specialized）”并不一定意味着显式具体化，而是指编译器推断使用哪种类型时执行的转换最少。
用于找出最具体的模板的规则被称为函数模板的部分排序规则（partial ordering rules）。
程序清单8.14 tempover.cpp
#include <iostream>

using namespace std;

struct debts
{
    char name[128];
    double amount;
};
template <typename T>
void ShowArray(T arr[], int n);
template <typename T>
void ShowArray(T *arr[], int n);

int main()
{
    int things[6] = { 13, 31, 103, 301, 310, 130 };
    debts mr_E[3] =
    {
        { "Ima Wolfe", 2400.0 },
        { "Ura Foxe", 1300.0 },
        { "Iby Stout", 1800.0 }
    };

    double *pd[3];
    for (int i = 0; i < 3; i++)
    {
        pd[i] = & (mr_E[i].amount);
    }
    cout << "Listing Mr. E's counts of things :\n";
    ShowArray(things, 6);
    cout << "Listing Mr. E's debts:\n";
    ShowArray(pd, 3);

    return 0;
}

template <typename T>
void ShowArray(T arr[], int n)
{
    cout << "template A\n";
    for (int i = 0; i < n; i++)
    {
        cout << arr[i] << ' ';
    }
    cout << endl;
}

template <typename T>
void ShowArray(T *arr[], int n)
{
    cout << "template B\n";
    for (int i = 0; i < n; i++)
    {
        cout << *arr[i] << ' ';
    }
    cout << endl;
}
显示结果如下
Listing Mr. E's counts of things :
template A
13 31 103 301 310 130
Listing Mr. E's debts:
template B
2400 1300 1800

程序清单8.15 tempchoices.cpp
#include <iostream>

using namespace std;

template<typename T>
T lesser(T a, T b)
{
    cout << "template lesser\n";
    return a < b ? a : b;
}

int lesser(int a, int b)
{
    a = a < 0 ? -a : a;
    b = b < 0 ? -b : b;
    return a < b ? a : b;
}

int main()
{
    int m = 20;
    int n = -30;
    double x = 15.5;
    double y = 25.9;
    cout << lesser(m, n) << endl;
    cout << lesser(x, y) << endl;
    cout << lesser<>(m, n) << endl;
    cout << lesser<int>(x, y) << endl;

    return 0;
}
显示结果如下
20
template lesser
15.5
template lesser
-30
template lesser
15

lesser<> (m, n)中的<>指出，编译器应选择模板函数，而不是非模板函数；编译器注意到实参的类型为int，因此使用int替代T对模板进行实例化。
lesser<int>(x, y) 这条语句要求进行显式实例化（使用int替代T），将使用显式实例化得到的函数。
x和y的值将被强制转换为int，该函数返回一个int值，这就是程序显示15而不是15.5的原因所在。
8.5.6模板函数的发展
C++11新增的关键字decltype
int x;
decltype(x) y;   //make y the same type as x
给decltype提供的参数可以是表达式
decltype(x+y) xpy;   //make xpy the same type as x +y
хpy = x +y;

decltype(x+ y) xpy = x +y;
decltype比这些示例演示的要复杂些。为确定类型，编译器必须遍历一个核对表。
假设有如下声明decltype (expression) var;
则核对表的简化版如下：
第一步：如果expression是一个没有用括号括起的标识符，则var的类型与该标识符的类型相同，包括const等限定符。
第二步：如果expression是一个函数调用，则var的类型与函数的返回类型相同。
编译器通过查看函数的原型来获悉返回类型，而无需实际调用函数。
第三步：如果expression是一个左值，则var为指向其类型的引用。
要进入第三步，expression不能是未用括号括起的标识符，可以是用括号括起的标识符。
第四步：如果前面的条件都不满足，则var的类型与expression的类型相同。
如果需要多次声明，可结合使用typedef和decltype。
3.另一种函数声明语法（C+11后置返回类型）
double h (int x, float y);
使用新增的语法可编写成这样：
auto h (int x, float y) -> double;
这将返回类型移到了参数声明后面。
-> double被称为后置返回类型（trailing return type），其中auto是个占位符，
表示后置返回类型提供的类型，这是C++给auto新增的一种角色。
这种语法也可用于函数定义：
auto h (int x, float y) -> double
{
    ...
}
template <typename T1, typename T2>
auto Add (T1 x, T2 y) -> decltype(x + y)
{
    return x + y;
}
现在，decltype在参数声明后面，因此x和y位于作用域内，可以使用它们。
8.6总结
通过将inline关键字用于函数定义，并在首次调用该函数前提供其函数定义，可以使得C++编译器将该函数视为内联函数。
也就是说，编译器不是让程序跳到独立的代码段，以执行函数，而是用相应的代码替换函数调用。
只有在函数很短时才能采用内联方式。
引用变量是一种伪装指针，它允许为变量创建别名（另一个名称），
引用变量主要被用作处理结构和类对象的函数的参数，通常，被声明为特定类型引用的标识符只能指向这种类型的数据；
然而，如果一个类（如ofstream）是从另一个类（如ostream）派生出来的，则基类引用可以指向派生类对象。
C++原型让您能够定义参数的默认值。如果函数调用省略了相应的参数，则程序将使用默认值；
如果函数调用提供了参数值，则程序将使用这个值（而不是默认值），只能在参数列表中从右到左提供默认参数。
因此，如果为某个参数提供了默认值，则必须为该参数右边所有的参数提供默认值。
函数的特征标是其参数列表。程序员可以定义两个同名函数，只要其特征标不同。
这被称为函数多态或函数重载。通常，通过重载函数来为不同的数据类型提供相同的服务。
函数模板自动完成重载函数的过程。只需使用泛型和具体算法来定义函数，
编译器将为程序中使用的特定参数类型生成正确的函数定义。
3.7 复习题
1.哪种函数适合定义为内联函数？
函数体很小，非递归，而且经常使用的函数

2.假设song函数的原型如下：
void song (const char * name, int times);
a.如何修改原型，使times的默认值为1？
void song (const char * name, int times = 1);
b.函数定义需要做哪些修改？
函数定义不需要做修改
c.能否为name提供默认值"O.My Papa"？
如果为name提供默认值，则也必须为times提供默认值
void song (const char * name = "O.My Papa", int times = 1);

3.编写iquote的重载版本，显示其用双引号括起的参数。
编写3个版本：一个用于int参数，一个用于double参数，另一个用于char *参数。
#include <iostream>

using namespace std;

void iquote( int n)
{
    cout << "\"" << n << "\"";
}
void iquote(double x)
{
    cout << '"' << x << '"';
}
void iquote(const char * str)
{
    cout << "\"" << str << "\"";
}
4.下面是一个结构模板：
struct box
{
    char maker [128];
    double height;
    double width;
    double length;
    double volume;
};
a.请编写一个函数，它将box结构的引用作为形参，并显示每个成员的值。
void show_box(const box & container)
{
    cout << "Made by " << container.maker << end;
    cout << "Height = " << container.height << end;
    cout << "Width = " << container.width << end;
    cout << "Length = " << container.length << end;
    cout << "Volume = " << container.volume << end;

}
b.请编写一个函数，它将box结构的引用作为形参，并将volume成责设置为其他3边的乘积为。
void set_volume (box & container)
{
    container.volume = (container.height) * (contianer.width) * (container.length);
}
5.为让函数fill和show使用引用参数，需要对程序清单7.15做哪些修改？
#include <iostream>
#include <array>
#include <string>

using namespace std;

const int Seasons = 4;

const array<string, Seasons> Snames =
{
    "Spring", "Summer", "Fall", "Winter"
};

void fill(array<double, Seasons> &pa);
void show(const array<double, Seasons> &da);

int main()
{
    array<double, Seasons> expenses;
    fill(expenses);
    show(expenses);

    return 0;
}

void fill(array<double, Seasons> & pa)
{
    for (int i = 0; i < Seasons; i++)
    {
        cout << "Enter " << Snames[i] << " expenses: ";
        cin >> pa[i];
    }
}

void show(const array<double, Seasons> &da)
{
    double total = 0.0;
    cout << "\nEXPENSES\n";
    for (int i = 0; i < Seasons; i++)
    {
        cout << Snames[i] << ": $" << da[i] << endl;
        total += da[i];
    }
    cout << "Total Expenses: $" << total << endl;
}

6.指出下面每个目标是否可以使用默认参数或函数重载完成，或者这两种方法都无法完成，并提供合适的原型。
a.mass (density, volume)返回密度为density、体积为volume的物体的质量，
而mass（denstity）返回密度为density、体积为1.0立方米的物体的质量。这些值的类型都为double。
double mass (double d, double v = 1.0);
函数重载
double mass (double d, double v);
double mass (double d);

b.repeat (10, "I'm OK")将指定的字符串显示10次，而repeat ("But you're kind of stupid")将指定的字符串显示5次。
不可以使用默认参数，因为默认参数要求从右到左提供默认值
函数重载
void repeat (int times, const char * str);
void repeat (const char * str);

c.average (3, 6)返回两个int参数的平均值（int类型），而average (3.0, 6.0)返回两个double值的平均值（double 类型）。
函数重载
int average (int a, int b);
double average (double x, double y);

d.mangle ("Im glad to meet you")根据是将值赋给char变量还是char *变量，
分别返回字符I和指向字符串"I'm mad to gleet you"的指针。
都不可以，因为函数重载是根据函数名和函数的参数列表来确定

7.编写返回两个参数中较大值的函数模板。
template <typename T>
T& max(T & a, T & b)
{
    return a > b ? a : b;
}

8.给定复习题7的模板和复习题4的box结构，提供一个模板具体化，它接受两个box参数，并返回体积较大的一个。
template <> box & max<box> (box & b1, box & b2)
{
    return b1.volume > b2.volume ? b1 : b2;
}

9.在下述代码（假定这些代码是一个完整程序的一部分）中；v1、v2、v3、v4和v5分别是哪种类型？
int g(int x);

float m = 5.5f;
float & rm = m;
decltype(m) v1 = m;   float类型
decltype(rm) v2 = m;   float &类型
decltype((m)) v3 = m;   float &类型
decltype(g(100)) v4;   int类型
decltype(2.0 * m) v5;   double类型

8.8编程练习
1.编写通常接受一个参数（字符串的地址），并打印该字符串的函数。
然而，如果提供了第三个参数（int类型），且该参数不为0，则该函数打印字符串的次数将为该函数被调用的次数
（注意，字符串的打印次数不等于第三个参数的值，而等于函数被调用的次数）。
#include <iostream>
#include <string>

using namespace std;

void print_text(const string *pt, int flag = 0);

int main()
{
    string word = "Long Live Rock-n-roll!";
    print_text(&word);
    word = "Let There Be Rock!";
    print_text(&word);
    print_text(&word);
    word = "Be Quick Or Be Dead!";
    print_text(&word, 1);

    return 0;
}
void print_text(const string *pt, int flag)
{
    static int count = 0;

    if (flag != 0)
    {
        for (int i = 0; i < count; i++)
        {
            std::cout << *pt << std::endl;
        }
    }
    else
    {
        std::cout << *pt << std::endl;
    }
    ++count;
}
显示结果如下
Long Live Rock-n-roll!
Let There Be Rock!
Let There Be Rock!
Be Quick Or Be Dead!
Be Quick Or Be Dead!
Be Quick Or Be Dead!

2.CandyBar结构包含3个成员。第一个成员存储candy bar的品牌名称；第一个成员存储candy bar的重量（可能有小数）；
第三个成员存储 candy bar的热量（整数）。请编写一个程序，它使用一个这样的函数，
即将CandyBar的引用、char指针，double和int作为参数，并用最后3个值设置相应的结构成员。
最后3个参数的默认值分别为"Millennium Munch"，2.85和350。
另外，该程序还包含一个以CandyBar的引用为参数，并显示结构内容的函数，请尽可能使用const。
#include <iostream>
#include <string>

struct CandyBar
{
    std::string CandeName;
    double weight;
    double calories;
};

void fill_struct(CandyBar &Munch, const char *name = "Millennium Munch",
                 double weight = 2.85, int calories = 350);
void Display_struct(const CandyBar &Munch);

int main()
{
    CandyBar box_1;
    CandyBar box_2;
    CandyBar box_3;

    fill_struct(box_1);
    Display_struct(box_1);

    fill_struct(box_2, "KitKat", 11.5, 400);
    Display_struct(box_2);

    fill_struct(box_3, "Pocky", 7.3, 210);
    Display_struct(box_3);

    return 0;
}

void fill_struct(CandyBar &Munch, const char *name, double weight, int calories)
{
    Munch.CandeName = name;
    Munch.weight = weight;
    Munch.calories = calories;
}

void Display_struct(const CandyBar &Munch)
{
    std::cout << "Name: ";
    std::cout << Munch.CandeName << std::endl;
    std::cout << "Weight: ";
    std::cout << Munch.weight << std::endl;
    std::cout << "Calories: ";
    std::cout << Munch.calories << std::endl;
    std::cout << std::endl;
}
显示结果如下
Name: Millennium Munch
Weight: 2.85
Calories: 350

Name: KitKat
Weight: 11.5
Calories: 400

Name: Pocky
Weight: 7.3
Calories: 210

3.编写一个函数，它接受一个指向string对象的引用作为参数，并将该string对象的内容转换为大写。
然后编写一个程序，它通过使用一个循环让您能够用不同的输入来测试这个函数。
#include <iostream>
#include <algorithm>
#include <string>
#include <cctype>

void uppercase(std::string &text);

int main()
{
    std::cout << "Enter a string (q to quit) : ";
    std::string text;

    while (std::getline(std::cin, text, '\n') && text != "q")
    {
        uppercase(text);
        std::cout << text << std::endl;
        std::cout << "Next string (q to quit) : ";
    }
    std::cout << "Done." << std::endl;

    return 0;
}

void uppercase(std::string &text)
{
    std::transform(text.begin(), text.end(), text.begin(), ::toupper);
}
::toupper表示强制使用C版本的toupper函数
::tolower表示强制使用C版本的tolower函数

显示结果如下
Enter a string (q to quit) : Hello, World!
HELLO, WORLD!
Next string (q to quit) : q
Done.

#include <iostream>
#include <string>
#include <cctype>
#include <algorithm>

using namespace std;

int main()
{
    string s = "Hello World";
    cout << s << endl;
    transform(s.begin(),s.end(),s.begin(),::toupper);
    cout << s << endl;
    transform(s.begin(),s.end(),s.begin(),::tolower);
    cout << s << endl;

    return 0;
}
Hello World
HELLO WORLD
hello world

::toupper表示强制使用C版本的toupper函数
::tolower表示强制使用C版本的tolower函数
4.下面是一个程序框架
请提供其中描述的函数和原型，从而完成该程序。注意，应有两个show函数，每个都使用默认参数。
请尽可能使用cosnt参数。set使用new分配足够的空间来存储指定的字符串。
#include <iostream>
#include <cstring>

struct stringy
{
    char *str;
    int ct;
};

void set(stringy &beany, const char *testing);
void show(const char *string, int size = 1);
void show(const stringy &beany, int size = 1);
void clear_memory(stringy &beany);

int main()
{
    stringy beany;
    char testing[] = "Reality isn't what it used to be.";
    set(beany, testing);
    show(beany);
    show(beany, 2);
    clear_memory(beany);

    testing[0] = 'D';
    testing[1] = 'u';

    show(testing);
    show(testing, 3);
    show("Done!");

    return 0;
}

void set(stringy &beany, const char *testing)
{
    beany.ct = strlen(testing);
    beany.str = new char[beany.ct + 1];
    strcpy(beany.str, testing);
}

void show(const char *string, int size)
{
    for (int i = 0; i < size; i++)
    {
        std::cout << string << std::endl;
    }
}

void show(const stringy &beany, int size)
{
    for (int i = 0; i < size; i++)
    {
        std::cout << beany.str << std::endl;
    }
}

void clear_memory(stringy &beany)
{
    delete [] beany.str;
}
显示结果如下
Reality isn't what it used to be.
Reality isn't what it used to be.
Reality isn't what it used to be.
Duality isn't what it used to be.
Duality isn't what it used to be.
Duality isn't what it used to be.
Duality isn't what it used to be.
Done!

5.编写模板函数max5，它将一个包含5个T类型元素的数组作为参数，并返回数组中最大的元素。
在一个程序中使用该函数，将T替换为一个包含5个int值的数组和一个包含5个dowble值的数组，以测试该函数。
#include <iostream>

template <typename T>
T max5(T *massiv);

int main()
{
    double double_massiv[5] = { 0.1, 1.2, 3.45, 2.2, 1.3 };
    std::cout << "Maximum value of the array double = ";
    std::cout << max5(double_massiv) << std::endl;

    int int_massiv[5] = { 2, 5, 8, 66, 231 };
    std::cout << "Maximum value of array int = ";
    std::cout << max5(int_massiv) << std::endl;

    return 0;
}

template <typename T>
T max5(T *massiv)
{
    T max = massiv[0];
    for (int i = 0; i < 5; i++)
    {
        if (massiv[i] > max)
        {
            max = massiv[i];
        }
    }
    return max;
}
显示结果如下
Maximum value of the array double = 3.45
Maximum value of array int = 231

6.编写模板函数maxn，它将由一个T类型元素组成的数组和一个表示数组元素数目的整数作为参数，
并返回数组中最大的元素。编写程序对它进行测试，该程序使用一个包含6个int元素的数组和
一个包含4个double元素的数组来调用该函数。
程序还包含一个具体化，它将char指针数组和数组中的指针数量作为参数，并返回最长的字符串的地址。
如果有多个这样的字符串，则返回其中第一个字符串的地址。使用由5个字符串指针组成的数组来测试该具体化。
#include <iostream>
#include <cstring>

const int SIZE_INT = 6;
const int SIZE_DOUBLE = 4;
const int SIZE_CHAR = 5;

template <typename T>
T maxn(T *massiv, int size);

const char *maxn(const char *massiv[], int size);

int main()
{
    int massiv_int[SIZE_INT] = { 1, 2, 2, 4, 52 };
    double massiv_double[SIZE_DOUBLE] = { 0.1, 2.4, 0.4, 33.1 };
    const char *words[SIZE_CHAR] = { "Ham", "Bread", "Sandwich", "Asparagus", "Chocolate" };

    std::cout << "The maximum value of the array INT = ";
    std::cout << maxn(massiv_int, SIZE_INT) << std::endl;
    std::cout << "The maximum value of the array DOUBLE = ";
    std::cout << maxn(massiv_double, SIZE_DOUBLE) << std::endl;
    std::cout << "The maximum value of the array CHAR = ";
    std::cout << maxn(words, SIZE_CHAR) << std::endl;

    return 0;
}

template <typename T>
T maxn(T *massiv, int size)
{
    T max = massiv[0];
    for (int i = 0; i < size; i++)
    {
        if (massiv[i] > max)
        {
            max = massiv[i];
        }
    }
    return max;
}

const char *maxn(const char *massiv[], int size)
{
    const char *max_length_string = &(massiv[0][0]);
    int max_characters = strlen(massiv[0]);
    int next = 0;

    for (int i = 0; i < size; i++)
    {
        next = strlen(massiv[i]);
        if (next > max_characters)
        {
            max_characters = next;
            max_length_string = &(massiv[i][0]);
        }
    }
    return max_length_string;
}
显示结果如下
The maximum value of the array INT = 52
The maximum value of the array DOUBLE = 33.1
The maximum value of the array CHAR = Asparagus

7.修改程序清单8.14，使其使用两个名为SumArray的模板函数来返回数组元素的总和，而不是显示数组的内容。
程序应显示thing的总和以及所有debt的总和。
#include <iostream>

struct debts
{
    char name[128];
    double amount;
};

template <typename T>
T SumArray(T arr[], int n);
template <typename T>
T SumArray(T *arr[], int n);
template <typename T>
void ShowArray(T arr[], int n);
template <typename T>
void ShowArray(T *arr[], int n);

int main()
{
    int things[6] = { 13, 31, 103, 301, 310, 130 };
    debts mr_E[3] =
    {
        { "Ima Wolfe", 2400.0 },
        { "Ura Foxe", 1300.0 },
        { "Iby Stout", 1800.0 }
    };

    double *pd[3];

    for (int i = 0; i < 3; i++)
    {
        pd[i] = &(mr_E[i].amount);
    }

    std::cout << "Listing Mr. E's counts of things :\n";
    ShowArray(things, 6);
    std::cout << "Total = " << SumArray(things, 6) << std::endl;

    std::cout << "Listing Mr. E's debts:\n";
    ShowArray(pd, 3);
    std::cout << "Total = " << SumArray(pd, 3) << std::endl;

    return 0;
}

template <typename T>
T SumArray(T arr[], int n)
{
    T summ = 0;
    for (int i = 0; i < n; i++)
    {
        summ += arr[i];
    }
    return summ;
}

template <typename T>
T SumArray(T *arr[], int n)
{
    T summ = 0;
    for (int i = 0; i < n; i++)
    {
        summ += *arr[i];
    }
    return summ;
}

template <typename T>
void ShowArray(T arr[], int n)
{
    std::cout << "template ShowArray A\n";
    for (int i = 0; i < n; i++)
    {
        std::cout << arr[i] << ' ';
    }
    std::cout << std::endl;
}

template <typename T>
void ShowArray(T *arr[], int n)
{
    std::cout << "template ShowArray B\n";
    for (int i = 0; i < n; i++)
    {
        std::cout << *arr[i] << ' ';
    }
    std::cout << std::endl;
}
显示结果如下
Listing Mr. E's counts of things :
template ShowArray A
13 31 103 301 310 130
Total = 888
Listing Mr. E's debts:
template ShowArray B
2400 1300 1800
Total = 5500

第9章 内存模型和名称空间
9.1 单独编译
9.2 存储持续性、作用域和链接性
9.2.1 作用域和链接
9.2.2 自动存储持续性
9.2.3 静态持续变量
9.2.4 静态持续性、外部链接性
9.2.5 静态持续性、内部链接性
9.2.6 静态存储持续性、无链接性
9.2.7 说明符和限定符
9.2.8 函数和链接性
9.2.9 语言链接性
9.2.10 存储方案和动态分配
9.3 名称空间
9.3.1 传统的C++名称空间
9.3.2 新的名称空间特性
9.3.3 名称空间示例
9.3.4 名称空间及其前途
9.4 总结
9.5 复习题
9.6 编程练习
本章内容包括：
单独编译。
存储持续性、作用城和链接性。
定位（placement）new运算符。
名称空间。
9.1单独编译
下面列出了头文件中常包含的内容。
函数原型。
使用#define定义的符号常量。
自定义类型。
结构声明。
类声明。
模板声明。
程序清单9.1、程序清单9.2和程序清单9.3是将程序清单7.12分成几个独立部分后得到的结果。
程序清单9.1 coordin.h
#pragma once
#ifndef COORDIN_H_
#define COORDIN_H_

struct polar
{
    double distance;
    double angle;
};

struct rect
{
    double x;
    double y;
};

polar rect_to_polar(rect xypos);
void show_polar(polar dapos);

#endif

程序清单9.2 file1.cpp
#include <iostream>
#include "coordin.h"

int main()
{
    rect rplace;
    polar pplace;
    std::cout << "Enter the x and y values: ";
    while ( (std::cin >> rplace.x) && (std::cin >> rplace.y) )
    {
        pplace = rect_to_polar(rplace);
        show_polar(pplace);
        std::cout << "Enter the x and y values (q to quit) : ";
    }
    std::cout << "Done.\n";

    return 0;
}

程序清单9.3 file2.cpp
#include <iostream>
#include <cmath>
#include "coordin.h"

polar rect_to_polar(rect xypos)
{
    polar answer;
    answer.distance = sqrt(xypos.x * xypos.x + xypos.y * xypos.y);
    answer.angle = atan2(xypos.y, xypos.x);
    return answer;
}
void show_polar(polar dapos)
{
    const double Rad_to_deg = 57.29577951;
    std::cout << "distance = " << dapos.distance << ", angle = " << dapos.angle *Rad_to_deg << " degrees\n";
}
编译命令如下
g++ -o file1 file1.cpp file2.cpp
显示结果如下
Enter the x and y values: 3.0 3.0
distance = 4.24264, angle = 45 degrees
Enter the x and y values (q to quit) : q
Done.

9.2 存储持续性、作用域和链接性
C++使用三种（在C++11中是四种）不同的方案来存储数据，这些方案的区别就在于数据保留在内存中的时间。
自动存储持续性：在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。
它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放。
静态存储持续性：在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为静态，
它们在程序整个运行过程中都存在。
线程存储持续性（C++11）：当前，多核处理器很常见，这些CPU可同时处理多个执行任务。
这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字thread_local声明的，则其生命周期与所属的线程一样长。本书不探讨并行编程。
动态存储持续性：用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止。
这种内存的存储持续性为动态，有时被称为自由存储（free store）或堆（heap）。
9.2.1作用域和链接
作用域（scope）描述了名称在文件（翻译单元）的多大范围内可见。
例如，函数中定义的变量可在该函数中使用，但不能在其他函数中使用；
而在文件中的函数定义之前定义的变量则可在所有函数中使用。
链接性（linkage）描述了名称如何在不同单元间共享。
链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享。
自动变量的名称没有链接性，因为它们不能共享。
C++变量的作用域有多种。作用域为局部的变量只在定义它的代码块中可用。
代码块是由花括号括起的一系列语句。例如函数体就是代码块，但可以在函数体中嵌入其他代码块。
作用域为全局（也叫文件作用域）的变量在定义位置到文件结尾之间都可用。
自动变量的作用域为局部，静态变量的作用域是全局还是局部取决于它是如何被定义的。
在函数原型作用域（function prototype scope）中使用的名称只在包含参数列表的括号内可用
（这就是为什么这些名称是什么以及是否出现都不重要的原因）。
在类中声明的成员的作用域为整个类（参见第10章），在名称空间中声明的变量的作用域为整个名称空间
（由于名称空间已经引入到C++语言中，因此全局作用域是名称空间作用域的特例）。
C++函数的作用域可以是整个类或整个名称空间（包括全局的），但不能是局部的
（因为不能在代码块内定义函数，如果函数的作用域为局部，则只对它自己是可见的，因此不能被其他函数调用。
这样的函数将无法运行）。
不同的C++存储方式是通过存储持续性、作用域和链接性来描述的。
下面来看看各种C++存储方式的这些特征。首先介绍引入名称空间之前的情况，然后看一看名称空间带来的影响。
9.2.2 自动存储持续性
在默认情况下，在函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性。
程序清单9.4 auto.cpp
#include <iostream>

using namespace std;

void oil(int x);

int main()
{
    int texas = 31;
    int year = 2011;
    cout << "In main(), texas = " << texas << ", &texas = " << &texas << endl;
    cout << "In main(), year = " << year << ", &year = " << &year << endl;
    oil(texas);
    cout << "In main(), texas = " << texas << ", &texas = " << &texas << endl;
    cout << "In main(), year = " << year << ", &year = " << &year << endl;

    return 0;
}
void oil(int x)
{
    int texas = 5;
    cout << "In oil(), texas = " << texas << ", &texas = " << &texas << endl;
    cout << "In oil(), x = " << x << ", &x = " << &x << endl;
    {
        int texas = 113;
        cout << "In block, texas = " << texas << ", &texas = " << &texas << endl;
        cout << "In block, x = " << x << ", &x = " << &x << endl;
    }
    cout << "Post-block texas = " << texas << ", &texas = " << &texas << endl;
}
显示结果如下
In main(), texas = 31, &texas = 0x7ffdbe70b930
In main(), year = 2011, &year = 0x7ffdbe70b934
In oil(), texas = 5, &texas = 0x7ffdbe70b910
In oil(), x = 31, &x = 0x7ffdbe70b90c
In block, texas = 113, &texas = 0x7ffdbe70b914
In block, x = 31, &x = 0x7ffdbe70b90c
Post-block texas = 5, &texas = 0x7ffdbe70b910
In main(), texas = 31, &texas = 0x7ffdbe70b930
In main(), year = 2011, &year = 0x7ffdbe70b934

在C++11中，关键字auto用于自动类型推断。但在C语言和以前的C++版本中，auto的含义截然不同，它用于显式地指出变量为自动存储。
由于只能将关键字auto用于默认为自动的变量，因此程序员几乎不使用它。
在C++11中，这种用法不再合法。制定标准的人不愿引入新关键字，因为这样做可能导致将该关键字用于其他目的的代码非法。
考虑到auto的老用法很少使用，因此赋予其新含义比引入新关键字是更好的选择。
1.自动变量的初始化
可以使用任何在声明时其值为已知的表达式来初始化自动变量
2.自动变量和栈
由于自动变量的数目随函数的开始和结束而增减，因此程序必须在运行时对自动变量进行管理。
常用的方法是留出一段内存，并将其视为栈，以管理变量的增减。
栈的默认长度取决于实现，但编译器通常提供改变栈长度的选项。
程序使用两个指针来跟踪栈，一个指针指向栈底（栈的开始位置），另一个指针指向栈顶（下一个可用内存单元）。
当函数被调用时，其自动变量将被加入到栈中，栈顶指针指向变量后面的下一个可用的内存单元；
函数结束时，栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。
栈是LIFO（后进先出）的，即最后加入到栈中的变量首先被弹出。
这种设计简化了参数传递。函数调用将其参数的值放在栈顶，然后重新设置栈顶指针。
被调用的函数根据其形参描述来确定每个参数的地址。
3・寄存器变量
关键字register最初是由C语言引入的，它建议编译器使用CPU寄存器来存储自动变量，提高访问变量的速度。
在C++11之前，这个关键字在C++中的用法始终未变，在C++11中，这种提示作用也失去了，
关键字register只是显式地指出变量是自动的。
9.2.3 静态持续变量
和C语言一样，C++也为静态存储持续性变量提供了3种链接性：
外部链接性（可在其他文件中访问）、内部链接性（只能在当前文件中访问）和无链接性（只能在当前函数或代码块中访问）。
编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在。
另外，如果没有显式地初始化静态变量，编译器将把它设置为0。
在默认情况下，静态数组和结构将每个元素或成员的所有位都设置为0。
要想创建链接性为外部的静态持续变量，必须在代码块的外面声明它；
要创建链接性为内部的静态持续变量，必须在代码块的外面声明它，并使用static限定符；
要创建没有链接性的静态持续变量，必须在代码块内声明它，并使用static限定符。
静态变量的初始化
除默认的零初始化外，还可对静态变量进行常量表达式初始化和动态初始化。
零初始化和常量表达式初始化被统称为静态初始化，这意味着在编译器处理文件（翻译单元）时初始化变量。
动态初始化意味着变量将在编译后初始化。
那么初始化形式由什么因素决定呢？首先，所有静态变量都被零初始化，而不管程序员是否显式地初始化了它。
接下来，如果使用常量表达式初始化了变量，且编译器仅根据文件内容（包括被包含的头文件）就可计算表达式，
编译器将执行常量表达式初始化。必要时，编译器将执行简单计算。如果没有足够的信息，变量将被动态初始化。
常量表达式并非只能是使用字面常量的算术表达式，它还可使用sizeof运算符。
C++11新增了关键字constexpr，这增加了创建常量表达式的方式。
9.2.4 静态持续性、外部链接性
链接性为外部的变量通常简称为外部变量，它们的存储持续性为静态，作用域为整个文件。
外部变量是在函数外部定义的，外部变量也称全局变量（相对于局部的自动变量）。
引用声明使用关键字extern，且不进行初始化；否则，声明为定义，导致分配存储空间。
如果要在多个文件中使用外部变量，只需在一个文件中包含该变量的定义，
在使用该变量的其他所有文件中，都使用关键字extern声明它。
程序清单9.5 external.cpp
#include <iostream>

using namespace std;

double warming = 0.3;

void update(double dt);
void local();

int main()
{
    cout << "Global warming is " << warming << " degrees.\n";
    update(0.1);
    cout << "Global warming is " << warming << " degrees.\n";
    local();
    cout << "Global warming is " << warming << " degrees.\n";

    return 0;
}

程序清单9.6 support.cpp
#include <iostream>

using std::cout;
extern double warming;

void update(double dt);
void local();

void update(double dt)
{
    extern double warming;
    warming += dt;
    cout << "Updating global warming to " << warming << " degrees.\n";
}

void local()
{
    double warming = 0.8;
    cout << "Local warming = " << warming << " degrees.\n";
    cout << "But global warming = " << ::warming << " degrees.\n";
}
显示结果如下
Global warming is 0.3 degrees.
Updating global warming to 0.4 degrees.
Global warming is 0.4 degrees.
Local warming = 0.8 degrees.
But global warming = 0.4 degrees.
Global warming is 0.4 degrees.

9.2.5 静态持续性、内部链接性
将static限定符用于作用域为整个文件的变量时，该变量的链接性将为内部的。
在多文件程序中，内部链接性和外部链接性之间的差别很有意义。
链接性为内部的变量只能在其所属的文件中使用；但常规外部变量都具有外部链接性，可以在其他文件中使用。
程序清单9.7 twofile1.cpp
#include <iostream>

int tom = 3;
int dick = 30;
static int harry = 300;

void remote_access();

int main()
{
    using namespace std;
    cout << "main () reports the following addresses:\n";
    cout << &tom << " = &tom, " << &dick << " = &dick, " << &harry << " = &harry\n";
    remote_access();

    return 0;
}

程序清单9.8 twofile2.cpp
#include <iostream>

extern int tom;
static int dick = 10;
int harry = 200;

void remote_access()
{
    using namespace std;
    cout << "remote_access () reports the following addresses:\n";
    cout << &tom << " = &tom, " << &dick << " = &dick, " << &harry << " = &harry\n";
}
显示结果如下
main () reports the following addresses:
0x55d3531cb048 = &tom, 0x55d3531cb04c = &dick, 0x55d3531cb050 = &harry
remote_access () reports the following addresses:
0x55d3531cb048 = &tom, 0x55d3531cb054 = &dick, 0x55d3531cb058 = &harry

9.2.6静态存储持续性、无链接性
在代码块中的变量使用static时，将导致局部变量的存储持续性为静态的。
这意味着虽然该变量只在该代码块中可用，但它在该代码块不处于活动状态时仍然存在。
因此在两次函数调用之间，静态局部变量的值将保持不变。
另外，如果初始化了静态局部变量，则程序只在启动时进行一次初始化，
以后再调用函数时，将不会像自动变量那样再次被初始化。
程序清单9.9 static.cpp
#include <iostream>

using namespace std;

const int ArSize = 128;

void strcount(const char *str);

int main()
{
    char input[ArSize];
    char next;

    cout << "Enter a line:\n";
    while ( cin.get(input, ArSize) )
    {
        while (std::cin.get() != '\n')
        {
            continue;
        }
        strcount(input);
        cout << "Enter a line:\n";
    }
    cout << "Done.\n";

    return 0;
}
void strcount(const char *str)
{
    static int total = 0;
    int count = 0;
    cout << "\"" << str << "\" contains ";
    while (*str++)
    {
        count++;
    }
    total += count;
    cout << count << " characters\n";
    cout << total << " characters total\n";
}
显示结果如下
Enter a line:
Hello World
"Hello World" contains 11 characters
11 characters total
Enter a line:
Peter Smith
"Peter Smith" contains 11 characters
22 characters total
Enter a line:
Mike Pence
"Mike Pence" contains 10 characters
32 characters total
Enter a line:
Done.

9.2.7说明符和限定符
下面是说明符：
auto（在C++11中不再是说明符）；
register；
static；
extern；
thread_local（C++11新增的）；
mutable
在同一个声明中不能使用多个说明符，但thread_local除外，它可与static或extern结合使用，
在C++11之前；可以在声明中使用关键字auto，指出变量为自动变量；但在C++11中，auto用于自动类型推断。
关键字register用于在声明中指示寄存器存储，而在C++11中，它只是显式地指出变量是自动的。
关键字static被用在作用域为整个文件的声明中时，表示内部链接性；
被用于局部声明中，表示局部变量的存储持续性为静态的。
关键字exterm表明是引用声明，即声明引用在其他地方定义的变量。
关键字thread_local指出变量的持续性与其所属线程的持续性相同。
thread_local变量之于线程，犹如常规静态变量之于整个程序。
关键字mutable的含义将根据const来解释。
下面是限定符：
const；
volatile；
const表明内存被初始化后，程序便不能再对它进行修改。
volatile表明，即使程序代码没有对内存单元进行修改，其值也可能发生变化。
该关键字的作用是为了改善编译器的优化能力。
例如，假设编译器发现，程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，
而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次使用之间不会变化。
如果不将变量声明为volatile，则编译器将进行这种优化；将变量声明为volatile，相当于告诉编译器，不要进行这种优化。
可以用mutable来指出，即使结构（或类）变量为const，其某个成员也可以被修改。
在C++中const限定符对默认存储类型稍有影响。
在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的。
也就是说，在C++看来，全局const定义就像使用了static说明符一样。
如果出于某种原因，程序员希望某个常量的链接性为外部的，则可以使用extern关键字来覆盖默认的内部链接性。
在这种情况下，必须在所有使用该常量的文件中使用exten关键字来声明它，且只有一个文件对其进行初始化。
这与常规外部变量不同，定义常规外部变量时，不必使用extern关键字，但在使用该变量的其他文件中必须使用extern。
在函数或代码块中声明const时，其作用域为代码块，仅当程序执行该代码块中的代码时，该常量才是可用的。
这意味着在函数或代码块中创建常量时，不必担心其名称与其他地方定义的常量发生冲突。
9.2.8 函数和链接性
和C语言一样，C++不允许在一个函数中定义另外一个函数，因此所有函数的存储持续性都自动为静态的，
即在整个程序执行期间都一直存在。在默认情况下，函数的链接性为外部的，即可以在文件间共享。
实际上，可以在函数原型中使用关键字extern来指出函数是在另一个文件中定义的，不过这是可选的。
还可以使用关键字static将函数的链接性设置为内部的，使之只能在一个文件中使用。
必须同时在原型和函数定义中使用该关键字，这意味着该函数只在这个文件中可见，
还意味着可以在其他文件中定义同名的的函数。
和变量一样，在定义静态函数的文件中，静态函数将覆盖外部定义，
因此即使在外部定义了同名的函数，该文件仍将使用静态函数。
对于链接性为外部的函数来说，只能有一个文件包含该函数的定义，但使用该函数的每个文件都应包含其函数原型。
内联函数不受这项规则的约束，这允许程序员能够将内联函数的定义放在头文件中。
如果该文件中的函数原型指出该函数是静态的，则编译器将只在该文件中查找函数定义；
否则，编译器（包括链接程序）将在所有的程序文件中查找。
如果找到两个定义，编译器将发出错误消息，因为每个外部函数只能有一个定义。
如果在程序文件中没有找到，编译器将在库中搜索。
这意味着如果定义了一个与库函数同名的函数，编译器将使用程序员定义的版本，而不是库函数。
然而，C++保留了标准库函数的名称，程序员不应使用它们。
9.2.9 语言链接性
链接程序要求每个不同的函数都有不同的符号名。在C语言中，一个名称只对应一个函数。
但在C++中，同一个名称可能对应多个函数，必须将这些函数翻译为不同的符号名称。
因此，C++编译器执行名称矫正或名称修饰，为重载函数生成不同的符号名称。
链接程序寻找与C++函数调用匹配的函数时，使用的方法与C语言不同。
为解决这种问题，可以用函数原型来指出要使用的约定：
extern "C" void spiff (int);   // use C protocol for name look-up
extern void spoff (int);   //use C++ protocol for name look-up
extern "C++" void spaff (int);   // use C++ protocol for name look-up
第一个原型使用C语言链接性；而后面的两个使用C++语言链接性。
第二个原型是通过默认方式指出这一点的，而第三个显式地指出了这一点。
C和C++链接性是C++标准指定的说明符，但实现可提供其他语言链接性说明符。
9.2.10存储方案和动态分配
动态内存由运算符new和delete控制，而不是由作用域和链接性规则控制。
因此，可以在一个函数中分配动态内存，而在另一个函数中将其释放。
其分配和释放顺序取决于new和delete在何时以何种方式被使用。
虽然存储方案概念不适用于动态内存，但适用于用来跟踪动态内存的自动和静态指针变量。
1.使用new运算符初始化
如果要为内置的标量类型（如int或double）分配存储空间并初始化，可在类型名后面加上初始值，并将其用括号括起：
int * pi = new int (6);
double * pd = new double (99.99);
这种括号语法也可用于有合适构造函数的类，这将在本书后面介绍。
然而，要初始化常规结构或数组，需要使用大括号的列表初始化，这要求编译器支持C++11。C+11允许您这样做：
struct where
{
    double x;
    double y;
    double z;
};
where * one = new where {2.5, 5.3, 7.2);   // C++11
int * ar = new int[4] {2, 4, 6, 7};   // C+11
在C++11中，还可将列表初始化用于单值变量：
int * pin = new int {6};
double * pdo = new double {99.99};
2.new失败时
new可能找不到请求的内存量，在这种情况下将引发异常std:bad_alloc。
3.new运算符、函数和替换函数
运算符new和new[]分别调用如下函数：
void * operator new (std::size_t):
void  operator new [] (std::size t)
这些函数被称为分配函数，它们位于全局名称空间中。
同样，也有由delete和delete[]调用的释放函数：
void operator delete (void *);
void operator delete [] (void *);
4.定位new运算符
通常，new负责在堆（heap）中找到一个足以能够满足要求的内存块。
new运算符还有另一种变体，被称为定位（placement）new运算符，它让您能够指定要使用的位置。
程序员可能使用这种特性处理需要通过特定地址进行访问的硬件或在特定位置创建对象。
要使用定位new特性，首先需要包含头文件new，它提供了这种版本的new运算符的原型；
然后将new运算符用于提供了所需地址的参数。除需要指定参数外，其他用法与常规new运算符相同。
new (参数) 类型
new (参数) 类型 [数量]
程序清单9.10 newplace.cpp
#include <iostream>
#include <new>

using namespace std;

const int BUF = 512;
const int N = 5;
char buffer[BUF];

int main()
{
    double *pd1, *pd2;
    int i;
    cout << "Calling new and placement new:\n";
    pd1 = new double[N];
    pd2 = new (buffer) double[N];
    for (i = 0; i < N; i++)
    {
        pd2[i] = pd1[i] = 1000 + 20.0 * i;
    }
    cout << "Memory addresses: \n" << "heap: " << pd1 << ", static: " << (void *) buffer << ", " << pd2 << endl;
    cout << "Memory contents:\n";
    for (i = 0; i < N; i++)
    {
        cout << pd1[i] << " at " << &(pd1[i]) << "; ";
        cout << pd2[i] << " at " << &(pd2[i]) << endl;
    }

    cout << "\nCalling new and placement new a second time:\n";
    double *pd3, *pd4;
    pd3 = new double[N];
    pd4 = new (buffer) double[N];
    for (i = 0; i < N; i++)
    {
        pd4[i] = pd3[i] = 1000 + 40.0 * i;
    }
    cout << "Memory addresses: \n" << "heap: " << pd3 << ", static: " << pd4 << endl;
    cout << "Memory contents:\n";
    for (i = 0; i < N; i++)
    {
        cout << pd3[i] << " at " << &(pd3[i]) << "; ";
        cout << pd4[i] << " at " << &(pd4[i]) << endl;
    }

    cout << "\nCalling new and placement new a third time:\n";
    delete [] pd1;
    pd1 = new double[N];
    pd2 = new (buffer + N * sizeof(double)) double[N];
    for (i = 0; i < N; i++)
    {
        pd2[i] = pd1[i] = 1000 + 60.0 * i;
    }
    cout << "Memory addresses: \n" << "heap: " << pd1 << ", static: " << pd2 << endl;
    cout << "Memory contents:\n";
    for (i = 0; i < N; i++)
    {
        cout << pd1[i] << " at " << &(pd1[i]) << "; ";
        cout << pd2[i] << " at " << &(pd2[i]) << endl;
    }
    delete[] pd1;
    delete[] pd3;

    return 0;
}
显示结果如下
Calling new and placement new:
Memory addresses:
heap: 0x55d6573622c0, static: 0x55d655b361a0, 0x55d655b361a0
Memory contents:
1000 at 0x55d6573622c0; 1000 at 0x55d655b361a0
1020 at 0x55d6573622c8; 1020 at 0x55d655b361a8
1040 at 0x55d6573622d0; 1040 at 0x55d655b361b0
1060 at 0x55d6573622d8; 1060 at 0x55d655b361b8
1080 at 0x55d6573622e0; 1080 at 0x55d655b361c0

Calling new and placement new a second time:
Memory addresses:
heap: 0x55d6573622f0, static: 0x55d655b361a0
Memory contents:
1000 at 0x55d6573622f0; 1000 at 0x55d655b361a0
1040 at 0x55d6573622f8; 1040 at 0x55d655b361a8
1080 at 0x55d657362300; 1080 at 0x55d655b361b0
1120 at 0x55d657362308; 1120 at 0x55d655b361b8
1160 at 0x55d657362310; 1160 at 0x55d655b361c0

Calling new and placement new a third time:
Memory addresses:
heap: 0x55d6573622c0, static: 0x55d655b361c8
Memory contents:
1000 at 0x55d6573622c0; 1000 at 0x55d655b361c8
1060 at 0x55d6573622c8; 1060 at 0x55d655b361d0
1120 at 0x55d6573622d0; 1120 at 0x55d655b361d8
1180 at 0x55d6573622d8; 1180 at 0x55d655b361e0
1240 at 0x55d6573622e0; 1240 at 0x55d655b361e8

9.3 名称空间
声明区域是可以在其中进行声明的区域。
对于在函数外面声明的全局变量，其声明区域为其声明所在的文件；
对于在函数中声明的局部变量，其声明区域为其声明所在的代码块。
变量的潜在作用域从声明点开始，到其声明区域的结尾。
因此潜在作用域比声明区域小，这是由于变量必须定义后才能使用。
然而，变量并非在其潜在作用域内的任何位置都是可见的。
例如，在函数中声明的局部变量将隐藏在同一个文件中声明的全局变量。
变量对程序而言可见的范围被称为作用域（scope）。
每个声明区域都可以声明名称，这些名称独立于在其他声明区域中声明的名称。
在一个函数中声明的局部变量不会与在另一个函数中声明的局部变量发生冲突。
C++新增了这样一种功能，即通过定义一种新的声明区域来创建命名的名称空间。
一个名称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西。
名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。
因此，在默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量）。
除了用户定义的名称空间外，还存在另一个名称空间――全局名称空间（global namespace）。
它对应于文件级声明区域，因此前面所说的全局变量现在被描述为位于全局名称空间中。
任何名称空间中的名称都不会与其他名称空间中的名称发生冲突。
名称空间中的声明和定义规则同全局声明和定义规则相同。
名称空间是开放的（open），可以把新的名称加入到已有的名称空间中。
可以通过作用域解析运算符 :: 来访问给定名称空间中的名称。
1.using声明和using编译指令
C++提供了两种机制（using声明和using编译指令）来简化对名称空间中名称的使用。
using声明使特定的标识符可用，using编译指令使整个名称空间可用。
using声明由被限定的名称和它前面的关键字using组成；
using Jill::fetch;   // a using declaration
using声明将特定的名称添加到它所属的声明区域中。
下面的代码段说明了这几点：
namespace Jill
{
    double bucket (double n) { ... }
    double fetch;
    struct Hill { ... };
}
char fetch;
int main ()
{
    using Jill::fetch;
    cin >> fetch;   // read a value into Jill::fetch
    cin >> ::fetch;   // read a value into global fetch
}
在函数的外面使用using声明时，将把名称添加到全局名称空间中。
using声明使一个名称可用，而using编译指令使所有的名称都可用。
using编译指令由名称空间名和它前面的关键字using namespace组成，
它使名称空间中的所有名称都可用，而不需要使用作用域解析运算符。
在全局声明区域中使用using编译指令，将使该名称空间的名称全局可用。
在函数中使用using编译指令，将使其中的名称在该函数中可用。
有关using编译指令和using声明，需要记住的一点是，它们增加了名称冲突的可能性。
如果在代码中使用作用域解析运算符 :: 不存在二义性的标识符，使用using声明或using编译指令后，情况将发生变化。
Jack::pal = 3;
Jill::pal = 10;

using Jack::pal;
using Jill::pal;
pal = 4;   // which one? now have a conflict
2.using编译指令和using声明之比较
假设名称空间和声明区域定义了相同的名称。如果试图使用using声明将名称空间的名称导入该声明区域，
则这两个名称会发生冲突，从而出错。
如果使用using编译指令将该名称空间的名称导入该声明区域，则局部版本将隐藏名称空间版本。
不过仍可以使用作用域解析运算符来访问名称空间名称。
一般说来，使用using声明比使用using编译指令更安全，这是由于它只导入指定的名称。
如果该名称与局部名称发生冲突，编译器将发出指示。using编译指令导入所有名称，包括可能并不需要的名称。
如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告，
另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。
namespace Jill
{
    double bucket (double n) { ... }
    double fetch;
    struct Hill { ... };
}
char fetch;
int main ()
{
    using namespace Jill;
    Hill Thrill;   // create a type Jill:Hill structure
    double water = bucket (2);   // use Jill::bucket()
    double fetch;   // hide Jill::fetch
    cin >> fetch;   // read a value into the local fetch
    cin >> ::fetch;   // read a value into the global fetch
    cin >> Jill::fetch;   // read a value into Jill::fetch
}
int foom()
{
    Jill::Hill crest;
}
3.名称空间的其他特性
可以将名称空间声明进行嵌套：
4.未命名的名称空间
可以通过省略名称空间的名称来创建未命名的名称空间。
在该名称空间中声明的名称的潜在作用域为：从声明点到该声明区域末尾。从这个方面看，它们与全局变量相似。
然而，由于这种名称空间没有名称，因此不能显式地使用using编译指令或using声明来使它在其他位置都可用。
具体地说，不能在未命名名称空间所属文件之外的其他文件中，使用该名称空间中的名称。
这提供了链接性为内部的静态变量的替代品。
程序清单9.11 namesp.h
#include <string>

namespace pers
{
    struct Person
    {
        std::string fname;
        std::string lname;
    };
    void getPerson(Person &);
    void showPerson(const Person &);
}

namespace debts
{
    using namespace pers;
    struct Debt
    {
        Person name;
        double amount;
    };
    void getDebt(Debt &);
    void showDebt(const Debt &);
    double sumDebts(const Debt ar[], int n);
}

程序清单9.12 namesp.cpp
#include <iostream>
#include "namesp.h"

namespace pers
{
    using std::cout;
    using std::cin;
    void getPerson(Person &rp)
    {
        cout << "Enter first name: ";
        std::getline(cin, rp.fname, '\n');
        cout << "Enter last name: ";
        std::getline(cin, rp.lname, '\n');
    }
    void showPerson(const Person &rp)
    {
        std::cout << rp.lname << ", " << rp.fname;
    }
}

namespace debts
{
    void getDebt(Debt &rd)
    {
        getPerson(rd.name);
        std::cout << "Enter debt: ";
        std::cin >> rd.amount;
        while (std::cin.get() != '\n')
        {
            continue;
        }
    }
    void showDebt(const Debt &rd)
    {
        showPerson(rd.name);
        std::cout << ": $" << rd.amount << std::endl;
    }
    double sumDebts(const Debt ar[], int n)
    {
        double total = 0;
        for (int i = 0; i < n; i++)
        {
            total += ar[i].amount;
        }
        return total;
    }
}

程序清单9.13 usenmsp.cpp
#include <iostream>
#include "namesp.h"

void other(void);
void another(void);

int main()
{
    using debts::Debt;
    using debts::showDebt;
    Debt golf = { { "Benny", "Goatsnif f" }, 120.0 };
    showDebt(golf);
    other();
    another();

    return 0;
}

void other(void)
{
    using std::cout;
    using std::endl;
    using namespace debts;
    Person dg = { "Doodles", "Glister" };
    showPerson(dg);
    cout << endl;
    Debt zippy[3];
    int i;
    for (i = 0; i < 3; i++)
    {
        getDebt(zippy[i]);
    }
    for (i = 0; i < 3; i++)
    {
        showDebt(zippy[i]);
    }
    cout << "Total debt: $" << sumDebts(zippy, 3) << endl;
    return;
}

void another(void)
{
    using pers::Person;
    Person collector = { "Milo", "Rightshift" };
    pers::showPerson(collector);
    std::cout << std::endl;
}
显示结果如下
Goatsnif f, Benny: $120
Glister, Doodles
Enter first name: Peter
Enter last name: Smith
Enter debt: 133
Enter first name: Pence
Enter last name: Mike
Enter debt: 210
Enter first name: World
Enter last name: Hello
Enter debt: 330
Smith, Peter: $133
Mike, Pence: $210
Hello, World: $330
Total debt: $673
Rightshift, Milo

下面是一些指导原则。
使用在己命名的名称空间中声明的变量，而不是使用外部全局变量。
使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。
如果开发了一个函数库或类库，将其放在一个名称空间中。
仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计。
不要在头文件中使用using编译指令。首先，这样做掩盖了要让哪些名称可用；
另外，包含头文件的顺序可能影响程序的行为。如果非要使用编译指令using，应将其放在所有预处理器编译指令#include之后。
导入名称时，首选使用作用域解析运算符或using声明的方法。
对于using声明，首选将其作用域设置为局部而不是全局。
9.4 总结
C++鼓励程序员在开发程序时使用头文件来定义用户类型，为操纵用户类型的函数提供函数原型；
并将函数定义放在一个独立的源代码文件中。头文件和源代码文件一起定义和实现了用户定义的类型及其使用方式。
最后，将main和其他使用这些函数的函数放在第三个文件中。
C++的存储方案决定了变量保留在内存中的时间以及程序的哪一部分可以访问它，
自动变量是在代码块（如函数体或函数体中的代码块）中定义的变量，
仅当程序执行到包含定义的代码块时，它们才存在，并且可见。
自动变量可以通过使用存储类型说明符register或根本不使用说明符来声明，没有使用说明符时，变量将默认为自动的。
register说明符提示编译器，该变量的使用频率很高，但C++11摒弃了这种用法。
静态变量在整个程序执行期间都存在。对于在函数外面定义的变量，
其所属文件中位于该变量的定义后面的所有函数都可以使用它（文件作用域），并可在程序的其他文件中使用（外部链接性）。
另一个文件使用这种变量，必须使用extern关键字来声明它。
对于多个文件间共享的变量，应在一个文件中包含其定义（无需使用extern，但如果同时进行初始化，也可使用它），
并在其他文件中包含引用声明（使用extern且不初始化）。
在函数的外面使用关键字static定义的变量的作用域为整个文件，但是不能用于其他文件（内部链接性）。
在代码块中使用关键字static定义的变量被限制在该代码块内（局部作用域、无链接性），
但在整个程序执行期间，它都一直存在。
在默认情况下，C++函数的链接性为外部，因此可在文件间共享；
但使用关键字static限定的函数的链接性为内部的，被限制在定义它的文件中。
动态内存分配和释放是使用new和delete进行的，它使用自由存储区或堆来存储数据。
调用new占用内存，而调用delete释放内存。程序使用指针来跟踪这些内存单元。
名称空间允许定义一个可在其中声明标识符的命名区域。
这样做的目的是减少名称冲突，尤其当程序非常大，并使用多个厂商的代码时。
可以通过使用作用域解析运算符、using声明或using编译指令，来使名称空间中的标识符可用。
9.5复习题
1.对于下面的情况，应使用哪种存储方案？
a.homer是函数的形参。
b.secret变量由两个文件共享。
c.topsecret变量由一个文件中的所有函数共享，但对于其他文件来说是隐藏的。
d.beencalled记录包含它的函数被调用的次数。

a.自动变量
b.在一个文件中将secret定义为外部变量，在另一个文件中使用extern来声明它
c.在topsecret定义前加上static，也可以在一个未命名的名称空间中定义topsecret
d.在函数中变量beencalled的定义前加上static

2.using声明和using编译指令之间有何区别？
using声明使得名称空间中对应的名称可用，using编译指令使得名称空间中所有的名称可用。
假设名称空间和声明区域定义了相同的名称。如果试图使用using声明将名称空间的名称导入该声明区域，
则这两个名称会发生冲突，从而出错。
如果使用using编译指令将该名称空间的名称导入该声明区域，则局部版本将隐藏名称空间版本。
不过仍可以使用作用域解析运算符来访问名称空间名称。

3.重新编写下面的代码，使其不使用using声明和using编译指令。
#include <iostream>

using namespace std;

int main()
{
    double x;

    cout << "Enter value : ";
    while ( ! (cin >> x) )
    {
        cin.clear();
        while (cin.get() != '\n')
        {
            continue;
        }
        cout << "Bad input. Please enter a number : ";
    }
    cout << "Value = " << x << endl;
    return 0;
}
修改后
#include <iostream>

int main()
{
    double x;

    std::cout << "Enter value : ";
    while ( ! (std::cin >> x) )
    {
        std::cin.clear();
        while (std::cin.get() != '\n')
        {
            continue;
        }
        std::cout << "Bad input. Please enter a number : ";
    }
    std::cout << "Value = " << x << std::endl;
    return 0;
}
4.重新编写下面的代码，使之使用using声明，而不是using编译指令。
#include <iostream>

using namespace std;

int main()
{
    double x;

    cout << "Enter value : ";
    while ( ! (cin >> x) )
    {
        cin.clear();
        while (cin.get() != '\n')
        {
            continue;
        }
        cout << "Bad input. Please enter a number : ";
    }
    cout << "Value = " << x << endl;
    return 0;
}
修改后
#include <iostream>

int main()
{
    using std::cin;
    using std::cout;
    using std::endl;

    double x;

    cout << "Enter value : ";
    while ( ! (cin >> x) )
    {
        cin.clear();
        while (cin.get() != '\n')
        {
            continue;
        }
        cout << "Bad input. Please enter a number : ";
    }
    cout << "Value = " << x << endl;
    return 0;
}
5.在一个文件中调用average(3, 6)函数时，它返回两个int参数的int平均值，
在同一个程序的另一个文件中调用时，它返回两个int参数的double平均值。应如何实现？
每个文件中包含对应版本的静态average函数原型和定义，
或者在每个文件中的未命名的名称空间中定义一个对应版本的average函数

6.下面的程序由两个文件组成，该程序显示什么内容？
file1.cpp
#include <iostream>

using namespace std;

void other();
void another();

int x = 10;
int y;

int main ()
{
    cout << x << endl;
    {
        int x = 4;
        cout << x << endl;
        cout << y << endl;
    }
    other();
    another();
  
    return 0;
}
void other()
{
    int y = 1;
    cout << "Other : " << x << ", " << y << endl;
}

file2.cpp
#include <iostream>

using namespace std;

extern int x;

namespace
{
    int y = -4;
}

void another()
{
    cout << "another : " << x << ", " << y << endl;
}

10
4
0
Other : 10, 1
another : 10, -4

7.下面的代码将显示什么内容？
#include <iostream>

using namespace std;

void other();

namespace n1
{
    int x = 1;
}
namespace n2
{
    int x = 2;
}

int main ()
{
    using namespace n1;

    cout << x << endl;
    {
        int x = 4;
        cout << x << ", " << n1::x << ", " << n2::x << endl;
    }
    using n2::x;
    cout << x << endl;
    other();

    return 0;
}

void other()
{
    using namespace n2;
    cout << x << endl;
    {
        int x = 4;
        cout << x << ", " << n1::x << ", " << n2::x << endl;
    }
    using n2::x;
    cout << x << endl;
}
1
4, 1, 2
2
2
4, 1, 2
2

9.6编程练习
1.下面是一个头文件：
根据这个头文件，创建一个多文件程序。其中的一个文件名为golf.cpp，它提供了与头文件中的原型匹配的函数定义；
另一个文件应包含main，并演示原型化函数的所有特性。
例如，包含一个让用户输入的循环，并使用输入的数据来填充一个由golf结构组成的数组，
数组被填满或用户将高尔夫选手的姓名设置为空字符串时，循环将结束。
main函数只使用头文件中原型化的函数来访问golf结构。
golf.h
#pragma once
#ifndef GOLF_H_
#define GOLF_H_

const int Len = 128;

struct golf
{
    char fullname[Len] = {0};
    int handicap;
};

void setgolf(golf &g, const char *name, int hc);
int setgolf(golf &g);
void handicap(golf &g, int hc);
void showgolf(const golf &g);

#endif

golf.cpp
#include <iostream>
#include <cstring>
#include "golf.h"

void setgolf(golf &g, const char *name, int hc)
{
    strcpy(g.fullname, name);
    g.handicap = hc;
}
int setgolf(golf &g)
{
    int name_valid = 0;

    std::cout << "Enter the name of the player: " << std::endl;
    std::cin.getline(g.fullname, Len);

    if (strlen(g.fullname) > 0)
    {
        name_valid = 1;

        std::cout << "Enter the player's handicap: " << std::endl;
        (std::cin >> g.handicap).get();
    }
    return name_valid;
}

void handicap(golf &g, int hc)
{
    g.handicap = hc;
}

void showgolf(const golf &g)
{
    std::cout << "Player name: " << g.fullname << std::endl;
    std::cout << "Handicap player: " << g.handicap << std::endl;
}

ch09_p01.cpp
#include <iostream>
#include "golf.h"

int main()
{
    golf ann;
    setgolf(ann, "Ann Birdfree", 24);
    showgolf(ann);

    int col_players = 0;
    std::cout << "Enter the number of players: ";
    (std::cin >> col_players).get();

    golf *players = new golf[col_players];
    int i;
    for (i = 0; i < col_players; i++)
    {
        if (setgolf(players[i]) == 0)
        {
            break;
        }
    }

    for (int j = 0; j < i; j++)
    {
        showgolf(players[j]);
    }

    delete [] players;

    return 0;
}
显示结果如下
Player name: Ann Birdfree
Handicap player: 24
Enter the number of players: 6
Enter the name of the player:
Peter Smith
Enter the player's handicap:
21
Enter the name of the player:
Mike Pence
Enter the player's handicap:
33
Enter the name of the player:
Hello World
Enter the player's handicap:
66
Enter the name of the player:

Player name: Peter Smith
Handicap player: 21
Player name: Mike Pence
Handicap player: 33
Player name: Hello World
Handicap player: 66

2.修改程序清单9.9：用string对象代替字符数组。这样，该程序将不再需要检查输入的字符串是否过长，
同时可以将输入字符串同字符串""进行比较，以判断是否为空行。
#include <iostream>
#include <string>

const int ArSize = 128;

void strcount(const std::string str);

int main()
{
    std::string input;
    std::string next;

    std::cout << "Enter a line: ";
    while ( std::getline(std::cin, input, '\n') && input != "")
    {
        strcount(input);
        std::cout << "Enter a line : ";
    }

    std::cout << "Done." << std::endl;

    return 0;
}

void strcount(const std::string str)
{
    static int total = 0;
    int count = 0;

    std::cout << "\"" << str << "\" contains ";

    for (int i = 0; i < str.size(); i++)
    {
        count++;
    }

    total += count;
    std::cout << count << " characters\n";
    std::cout << total << " characters total\n";
}
显示结果如下
Enter a line: Hello, World!
"Hello, World!" contains 13 characters
13 characters total
Enter a line : Mike Pence
"Mike Pence" contains 10 characters
23 characters total
Enter a line : Peter, Smith
"Peter, Smith" contains 12 characters
35 characters total
Enter a line :
Done.

3.下面是一个结构声明：
编写一个程序，使用定位new运算符将一个包含两个这种结构的数组放在一个缓冲区中。
然后，给结构的成员赋值，并使用一个循环来显示内容。
一种方法是像程序清单9.10那样将一个静态数组用作缓冲区；另一种方法是使用常规new运算符来分配缓冲区。
#include <iostream>
#include <new>
#include <cstring>

const int STRUCTSIZE = 2;
const int BUFFSIZE = 512;
char buffer[BUFFSIZE];

struct chaff
{
    char dross[32];
    int slag;
};

void show_chaff(const chaff &chf);
void set_chaff(chaff &chf, const char *name, int qlty);

int main()
{
    chaff *pchaff = new (buffer) chaff[STRUCTSIZE];
    char name[32];
    int quantity = 0;

    for (int i = 0; i < STRUCTSIZE; i++)
    {
        std::cout << "Enter name: ";
        std::cin.getline(name, 32);
        std::cout << "Enter the quantity: ";
        (std::cin >> quantity).get();
        set_chaff(pchaff[i], name, quantity);
    }
    std::cout << pchaff << ", " << (void *)buffer << std::endl;
    for (int i = 0; i < STRUCTSIZE; i++)
    {
        std::cout << "Chaff " << i + 1 << std::endl;
        show_chaff(pchaff[i]);
    }

    return 0;
}

void show_chaff(const chaff &chf)
{
    std::cout << "Dross : " << chf.dross << std::endl;
    std::cout << "Slag : " << chf.slag << std::endl;
}

void set_chaff(chaff &chf, const char *name, int qlty)
{
    strcpy(chf.dross, name);
    chf.slag = qlty;
}
显示结果如下
Enter name: Peter Smith
Enter the quantity: 3
Enter name: Mike Pence
Enter the quantity: 2
0x55edb41e22c0, 0x55edb41e22c0
Chaff 1
Dross : Peter Smith
Slag : 3
Chaff 2
Dross : Mike Pence
Slag : 2

4.请基于下面这个名称空间编写一个由3个文件组成的程序：
第一个文件是一个头文件，其中包含名称空间；
第二个文件是一个源代码文件，它对这个名称空间进行扩展，以提供这三个函数的定义；
第三个文件声明两个Sales对象，并使用setSales的交互式版本为一个结构提供值，
然后使用setSales的非交互式版本为另一个结构提供值。另外它还使用showSales来显示这两个结构的内容。
sales.h
#pragma once
#ifndef SALES_H_
#define SALES_H_

namespace SALES
{
    const int QUARTERS = 4;

    struct Sales
    {
        double sales[QUARTERS] = { 0, 0, 0, 0 };
        double average;
        double max;
        double min;
    };

    void setSales(Sales &s, const double arr[], int n);
    void setSales(Sales &s);
    void showSales(const Sales &s);
}

double find_avg(const double arr[], int size);
double find_max(const double arr[], int size);
double find_min(const double arr[], int size);

#endif

sales.cpp
#include <iostream>
#include "sales.h"

void SALES::setSales(Sales &s, const double arr[], int n)
{
    if (n > QUARTERS)
    {
        n = QUARTERS;
    }

    for (int i = 0; i < n; i++)
    {
        s.sales[i] = arr[i];
    }
    s.average = find_avg(s.sales, QUARTERS);
    s.max = find_max(s.sales, QUARTERS);
    s.min = find_min(s.sales, QUARTERS);
}

void SALES::setSales(Sales &s)
{
    for (int i = 0; i < QUARTERS; ++i)
    {
        std::cout << "Enter sales for quarter " << i + 1 << '\n';
        std::cin >> s.sales[i];
    }

    s.average = find_avg(s.sales, QUARTERS);
    s.max = find_max(s.sales, QUARTERS);
    s.min = find_min(s.sales, QUARTERS);
}

void SALES::showSales(const Sales &s)
{
    for (int i = 0; i < QUARTERS; i++)
    {
        if (i != 0)
        {
            std::cout << ", ";
        }
        std::cout << s.sales[i];
    }
    std::cout << std::endl;
    std::cout << "average: " << s.average << std::endl;
    std::cout << "max: " << s.max << std::endl;
    std::cout << "min: " << s.min << std::endl;
}

double find_avg(const double arr[], int size)
{
    double summ = 0;
    for (int i = 0; i < size; i++)
    {
        summ += arr[i];
    }
    return summ / size;
}

double find_max(const double arr[], int size)
{
    double max = arr[0];
    for (int i = 0; i < size; i++)
    {
        if (arr[i] > max)
        {
            max = arr[i];
        }
    }
    return max;
}

double find_min(const double arr[], int size)
{
    double min = arr[0];
    for (int i = 0; i < size; i++)
    {
        if (arr[i] < min)
        {
            min = arr[i];
        }
    }
    return min;
}

ch09_p04.cpp
#include <iostream>
#include "sales.h"

int main()
{
    SALES::Sales struct1;
    SALES::setSales(struct1);
    std::cout << std::endl;
    SALES::showSales(struct1);

    std::cout << std::endl;

    double arr[] = { 123.12, 522.22, 455.42, 777.32 };
    SALES::Sales struct2;
    SALES::setSales(struct2, arr, SALES::QUARTERS);
    SALES::showSales(struct2);

    return 0;
}
显示结果如下
Enter sales for quarter 1
125
Enter sales for quarter 2
323
Enter sales for quarter 3
256
Enter sales for quarter 4
521

125, 323, 256, 521
average: 306.25
max: 521
min: 125

123.12, 522.22, 455.42, 777.32
average: 469.52
max: 777.32
min: 123.12

第10章 对象和类
10.1 过程性编程和面向对象编程
10.2 抽象和类
10.2.1 类型是什么
10.2.2 C++中的类
10.2.3 实现类成员函数
10.2.4 使用类
10.2.5 修改实现
10.2.6 小结
10.3 类的构造函数和析构函数
10.3.1 声明和定义构造函数.
10.3.2 使用构造函数
10.3.3 默认构造函数
10.3.4 析构函数
10.3.5 改进Stock类
10.3.6 构造函数和析构函数小_.
10.4 this指针
10.5 对象数组
10.6 类作用域
10.6.1 作用域为类的常量
10.6.2 作用域内枚举（C++11）
10.7 抽象数据类型
10.8 总结
10.9 复习题
10.10 编程练习
本章内容包括：
过程性编程和面向对象编程。
类概念。
如何定义和实现类公有类访问和私有类访问。
类的数据成员。
类方法（类函数成员）。
创建和使用类对象。
类的构造函数和析构函数
const成员函数。
this指针。
创建对象数组。
类作用城
抽象数据类型。
本章首先介绍类；将解释抽象、封装、数据隐藏，并演示类是如何实现这些特性的。
本章还将讨论如何定义类、如何为类提供公有部分和私有部分以及如何创建使用类数据的成员函数。
另外，还将介绍构造函数和析构函数，它们是特殊的成员函数，用于创建和删除属于当前类的对象，最后介绍this指针。
程序清单10.1 stock00.h
#pragma once
#ifndef STOCK00_H_
#define STOCK00_H_
#include <string>

class Stock
{
private:
    std::string company;
    long shares;
    double share_val;
    double total_val;
    void set_tot()
    {
        total_val = shares * share_val;
    }
public:
    void acquire(const std::string & co, long n, double pr);
    void buy(long num, double price);
    void sell(long num, double price);
    void update(double price);
    void show();
};

#endif

关键字private和public描述了对类成员的访问控制。
使用类对象的程序都可以直接访问公有部分，但只能通过公有成员函数（或友元函数，参见第11章）来访问对象的私有成员。
因此，公有成员函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口。
防止程序直接访问数据被称为数据隐藏（参见图 10.1）。
C++还提供了第三个访问控制关键字protected，第13章介绍类继承时将讨论该关键字。
无论类成员是数据成员还是成员函数，都可以在类的公有部分或私有部分中声明它。
数据项通常放在私有部分，组成类接口的成员函数放在公有部分；否则，就无法在程序中调用这些接口函数。
也可以把成员函数放在私有部分中，不能直接在程序中调用这种函数，但公有方法却可以使用它们。
通常，程序员使用私有成员函数来处理不属于公有接口的实现细节。
关键字private是类对象的默认访问控制。
类描述看上去很像是包含成员函数以及public和private可见性标签的结构声明。
实际上，C++对结构进行了扩展，使之具有与类相同的特性。
它们之间唯一的区别是，结构的默认访问类型是public，而类为private。
C++程序员通常使用类来实现类描述，而把结构限制为只表示纯粹的数据对象。
10.2.3 实现类成员函数
成员函数定义与常规函数定义非常相似，但是它们还有两个特殊的特征：
定义成员函数时，使用作用域解析运算符 :: 来标识函数所属的类；类的成员函数可以访问类的private成员。
成员函数的函数头使用作用域运算符解析 :: 来指出函数所属的类。
void Stock::update (double price)
update函数是Stock类的成员。
我们可以将另一个类的成员函数也命名为update。
void Buffoon::update()
作用域解析运算符 :: 确定了方法定义对应的类。我们说，标识符update具有类作用域。
Stock类的其他成员函数不必使用作用域解析运算符，就可以使用update方法，
这是因为它们属于同一个类，因此update是可见的。
类方法的完整名称中包括类名，Stock:update是函数的限定名（qualified name），
简单的update是非限定名，它只能在类作用域中使用。
程序清单10.2 stock00.cpp
#include <iostream>
#include "stock00.h"

void Stock::acquire(const std::string & co, long n, double pr)
{
    company = co;
    if (n < 0)
    {
        std::cout << "Number of shares can't be negative; " << company << " shares set to 0.\n";
        shares = 0;
    }
    else
    {
        shares = n;
    }
    share_val = pr;
    set_tot();
}

void Stock::buy(long num, double price)
{
    if (num < 0)
    {
        std::cout << "Number of shares purchased can't be negative. " << "Transaction is aborted.\n";
    }
    else
    {
        shares += num;
        share_val = price;
        set_tot();
    }
}

void Stock::sell(long num, double price)
{
    using std::cout;
    if (num < 0)
    {
        cout << "Number of shares sold can't be negative. " << "Transaction is aborted.\n";
    }
    else if (num > shares)
    {
        cout << "You can't sell more than you have! " << "Transaction is aborted.\n";
    }
    else
    {
        shares -= num;
        share_val = price;
        set_tot();
    }
}

void Stock::update(double price)
{
    share_val = price;
    set_tot();
}

void Stock::show()
{
    std::cout << "Company: " << company << ", Shares: " << shares << '\n'
              << " Share Price: $" << share_val << ", Total Worth: $" << total_val << '\n';
}
定义位于类声明中的函数将自动成为内联函数，因此Stock:set_tot是一个内联函数。
如果愿意，也可以在类声明之外定义成员函数，并使其成为内联函数。
为此，只需在定义类的成员函数时使用inline限定符即可。

同一个类的每个新对象都有自己的存储空间，用于存储其成员变量，
但同一个类的所有对象共享同一组类方法，即每种方法只有一个副本。
例如，假设kate和joe都是Stock对象，则kae.shares将占据一个内存块，而joc.shares占用另一个内存块，
但kate.show和joe.show都调用同一个方法，也就是说，它们将执行同一个代码块，只是将这些代码用于不同的数据。
程序清单 10.3 usestock00.cpp
#include <iostream>
#include "stock00.h"

int main()
{
    Stock fluffy_the_cat;
    fluffy_the_cat.acquire("NanoSmart", 20, 12.50);
    fluffy_the_cat.show();
    fluffy_the_cat.buy(15, 18.125);
    fluffy_the_cat.show();
    fluffy_the_cat.sell(400, 20.00);
    fluffy_the_cat.show();
    fluffy_the_cat.buy(300000, 40.125);
    fluffy_the_cat.show();
    fluffy_the_cat.sell(300000, 0.125);
    fluffy_the_cat.show();

    return 0;
}
显示结果如下
Company: NanoSmart, Shares: 20
 Share Price: $12.5, Total Worth: $250
Company: NanoSmart, Shares: 35
 Share Price: $18.125, Total Worth: $634.375
You can't sell more than you have! Transaction is aborted.
Company: NanoSmart, Shares: 35
 Share Price: $18.125, Total Worth: $634.375
Company: NanoSmart, Shares: 300035
 Share Price: $40.125, Total Worth: $1.20389e+07
Company: NanoSmart, Shares: 35
 Share Price: $0.125, Total Worth: $4.375

10.2.5 修改实现
ostream类包含一些可用于控制格式的成员函数。使用方法setf，便可避免科学计数法：
std::cout.setf (std::ios_base::fixed, std::ios base::floatfield);
这设置了cout对象的一个标记，命令cout使用定点表示法。
同样，下面的语句导致cout在使用定点表示法时，显示三位小数：
std::cout.precision(3);
上述格式修改将一直有效，直到您再次修改，因此它们可能影响客户程序中的后续输出。
因此，应在输出结束后重置格式信息，使其恢复到之前的状态。
10.2.6小结
类声明类似结构声明，可以包括数据成员和函数成员。
声明有私有部分，在其中声明的成员只能通过成员函数进行访问；
声明还具有公有部分，在其中声明的成员可被使用类对象的程序直接访问。
通常，数据成员被放在私有部分中，成员函数被放在公有部分中，因此典型的类声明的格式如下：
cfass ClassNamé
{
private：data member declarations
public：member function prototypes
};
可以在类声明中提供完整的函数定义，而不是函数原型，但是通常的做法是单独提供函数定义（除非函数很小）。
在这种情况下，需要使用作用域解析运算符来指出成员函数属于哪个类。
要创建对象（类的实例），只需将类名视为类型名即可，因为类是用户定义的类型。
类成员函数（方法）可通过类对象来调用，需要使用成员运算符句点( . )。
10.3 类的构造面数和析构面数
常规的初始化语法不适用于类Stock，因为类Stock的数据成员是私有的，这意味着程序不能直接访问数据成员。
您已经看到，程序只能通过成员函数来访问数据成员，因此需要设计合适的成员函数，才能成功地将对象初始化。
一般来说，最好是在创建对象时自动对它进行初始化。
为此，C++提供了一个特殊的成员函数――类构造函数，专门用于构造新对象、将值赋给它们的数据成员。
更准确地说，C++为这些成员函数提供了名称和使用语法，而程序员需要提供方法定义。
名称与类名相同。例如，Stock类一个可能的构造函数是名为Stock()的成员函数。
构造函数的原型和函数头有一个有趣的特征――虽然没有返回值，但没有被声明为void类型。实际上，构造函数没有声明类型。
10.3.1 声明和定义构造函数
现在需要创建Stock的构造函数。由于需要为Stock对象提供3个值，因此应为构造函数提供3个参数。
程序员可能只想设置company成员，而将其他值设置为0；这可以使用默认参数来完成（参见第8章）。
注意，构造函数没有返回类型，且位于类声明的公有部分。
构造函数的参数名称不能与类的数据成员名称相同，一种常见的做法是在数据成员名称中使用前缀或后缀。
10.3.2 使用构造函数
C++提供了两种使用构造函数来初始化对象的方式。
第一种方式是显式地调用构造函数：
Stock food = Stock ("World cabbage", 250, 1.25);
这将food对象的company成员设置为字符串"World Cabbage"，将shares成员设置为250，依此类推。
另一种方式是隐式地调用构造函数：
Stock garment ("Furry Mason", 50, 2.5);
这种格式更紧凑，它与下面的显式调用等价：
Stock garment = Stock ("Furry Mason", 50, 2.5);
每次创建类对象（甚至使用new动态分配内存）时，C++都使用类构造函数。下面是将构造函数与new起使用的方法：
Stock * pstock = new Stock ("Electroshock Games", 18, 19.0);
这条语句创建一个Stock对象，将其初始化为参数提供的值，并将该对象的地址赋给pstock指针。
在这种情况下，对象没有名称，但可以使用指针来管理该对象。我们将在第11章进一步讨论对象指针。
构造函数的使用方式不同于其他类方法。一般来说，使用对象来调用方法，
但无法使用对象来调用构造函数，因为在构造函数构造出对象之前，对象是不存在的。
因此构造函数被用来创建对象，而不能通过对象来调用。
10.3.3 默认构造函数
默认构造函数是在未提供显式初始值时，用来创建对象的构造函数。也就是说，它是用于下面这种声明的构造函数：
Stock fluffy_the_cat;
如果没有提供任何构造函数，则C+将自动提供默认构造函数。它是默认构造函数的隐式版本，不做任何工作。
对于Stock类来说，默认构造函数可能如下：
Stock::Stock() {}
默认构造函数没有参数，因为声明中不包含值。
当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数。
为类定义了构造函数后，程序员就必须为它提供默认构造函数。
如果提供了非默认构造函数，但没有提供默认构造函数，则下面的声明将出错：
Stock stock1;
如果要创建对象，而不显式地初始化，则必须定义一个不接受任何参数的默认构造函数。
定义默认构造函数的方式有两种。一种是给已有构造函数的所有参数提供默认值：
Stock (const string & co = "Error", int n = 0, double pr = 0.0)
另一种方式是通过函数重载来定义一个没有参数的构造函数：
Stock() {}
由于只能有一个默认构造函数，因此不要同时采用这两种方式。
实际上，通常应初始化所有的对象，以确保所有成员一开始就有已知的合理值。
因此，用户定义的默认构造函数通常给所有成员提供隐式初始值。
例如，下面是为Stock类定义的一个默认构造函数：
Stock::Stock()
{
    company = "no name";
    shares = 0;
    share_val = 0.0;
    total_val = 0.0;
}
通常应提供对所有类数据成员做隐式初始化的默认构造函数。
使用上述任何一种方式（没有参数或所有参数都有默认值）创建了默认构造函数后，
便可以声明对象变量，而不对它们进行显式初始化。
Stock first ("Concrete Conglomerate");
Stock second ();
Stock third;
第一个声明调用非默认构造函数，即接受参数的构造函数；
第二个声明指出second是一个返回Stock对象的函数。
隐式地调用默认构造函数时，不要使用圆括号。
10.3.4析构函数
用构造函数创建对象后，程序负责跟踪该对象，直到其过期为止。
对象过期时，程序将自动调用一个特殊的成员函数――析构函数。
析构函数完成清理工作，例如，如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存。
Stock的构造函数没有使用new，因此析构函数实际上没有需要完成的任务。
在这种情况下，只需让编译器生成一个什么要不做的隐式析构函数即可，Stock类第一版正是这样做的。
然而，了解如何声明和定义析构函数是绝对必要的，下面为Stock类提供一个析构函数。
和构造函数一样，析构函数的名称也很特殊：在类名前加上~。因此，Stock类的析构函数为~Stock()。
另外，和构造函数一样，析构函数也可以没有返回值和声明类型。
与构造函数不同的是，析构函数没有参数，因此Stock析构函数的原型必须是这样的
~Stock();
由于Stock的析构函数不承担任何重要的工作，因此可以将它编写为不执行任何操作的函数：
Stock::~Stock() {}
然而，为让您能看出析构函数何时被调用，这样编写其代码：
Stock::~Stock()
{
    cout << "Bye, " << company << "!\n";
}
什么时候应调用析构函数呢？这由编译器决定，通常不应在代码中显式地调用标构函数。
如果创建的是静态存储类对象，则其析构函数将在程序结束时自动被调用。
如果创建的是自动存储类对象（就像前面的示例中那样），则其析构函数将在程序执行完对应的代码块时自动被调用。
如果对象是通过new创建的，则它将驻留在栈内存或自由存储区中，当使用delete来释放内存时，其析构函数将自动被调用。
最后，程序可以创建临时对象来完成特定的操作，在这种情况下，程序将在结束对该对象的使用时自动调用其析构函数。
由于在类对象过期时析构函数将自动被调用，因此必须有一个析构函数。
如果程序员没有提供析构函数，编译器将隐式地声明一个默认析构函数。
在发现导致对象被删除的代码后，提供默认析构函数的定义。
10.3.5 改进Stock.类
程序清单10.4 stock10.h
#pragma once
#ifndef STOCK10_H_
#define STOCK10_H_
#include <string>

class Stock
{
private:
    std::string company;
    long shares;
    double share_val;
    double total_val;
    void set_tot()
    {
        total_val = shares * share_val;
    }
public:
    Stock();
    Stock(const std::string &co, long n = 0, double pr = 0.0);
    ~Stock();
    void buy(long num, double price);
    void sell(long num, double price);
    void update(double price);
    void show();
};

#endif

程序清单10.5 stock10.cpp
#include <iostream>
#include "stock10.h"

Stock::Stock()
{
    std::cout << "Default constructor called\n";
    company = "no name";
    shares = 0;
    share_val = 0.0;
    total_val = 0.0;
}

Stock::Stock(const std::string & co, long n, double pr)
{
    std::cout << "Constructor using " << co << " called\n";
    company = co;
    if (n < 0)
    {
        std::cout << "Number of shares can't be negative; " << company << " shares set to 0.\n";
        shares = 0;
    }
    else
    {
        shares = n;
    }
    share_val = pr;
    set_tot();
}
Stock::~Stock()
{
    std::cout << "Bye, " << company << "!\n";
}

void Stock::buy(long num, double price)
{
    if (num < 0)
    {
        std::cout << "Number of shares purchased can't be negative. " << "Transaction is aborted.\n";
    }
    else
    {
        shares += num;
        share_val = price;
        set_tot();
    }
}

void Stock::sell(long num, double price)
{
    using std::cout;
    if (num < 0)
    {
        cout << "Number of shares sold can't be negative. " << "Transaction is aborted.\n";
    }
    else if (num > shares)
    {
        cout << "You can't sell more than you have! " << "Transaction is aborted.\n";
    }
    else
    {
        shares -= num;
        share_val = price;
        set_tot();
    }
}

void Stock::update(double price)
{
    share_val = price;
    set_tot();
}
void Stock::show()
{
    using std::cout;
    using std::ios_base;
    ios_base::fmtflags orig = cout.setf(ios_base::fixed, ios_base::floatfield);
    std::streamsize prec = cout.precision(3);
    cout << "Company: " << company << ", Shares: " << shares << '\n';
    cout << "Share Price: $ " << share_val;
    cout.precision(2);
    cout << ", Total Worth: $" << total_val << '\n';
    cout.setf(orig, ios_base::floatfield);
    cout.precision(prec);
}

程序清单10.6 usestock10.cpp
#include <iostream>
#include "stock10.h"

int main()
{

    using std::cout;
    cout << "Using constructors to create new objects\n";
    Stock stock1("NanoSmart", 12, 20.0);
    stock1.show();
    Stock stock2 = Stock("Boffo Objects", 2, 2.0);
    stock2.show();
    cout << "Assigning stock1 to stock2:\n";
    stock2 = stock1;
    cout << "Listing stock1 and stock2:\n";
    stock1.show();
    stock2.show();
    cout << "Using a constructor to reset an object\n";
    stock1 = Stock("Nifty Foods", 10, 50.0);
    cout << "Revised stock1:\n";
    stock1.show();
    cout << "Done.\n";

    return 0;
}
显示结果如下
Using constructors to create new objects
Constructor using NanoSmart called
Company: NanoSmart, Shares: 12
Share Price: $ 20.000, Total Worth: $240.00
Constructor using Boffo Objects called
Company: Boffo Objects, Shares: 2
Share Price: $ 2.000, Total Worth: $4.00
Assigning stock1 to stock2:
Listing stock1 and stock2:
Company: NanoSmart, Shares: 12
Share Price: $ 20.000, Total Worth: $240.00
Company: NanoSmart, Shares: 12
Share Price: $ 20.000, Total Worth: $240.00
Using a constructor to reset an object
Constructor using Nifty Foods called
Bye, Nifty Foods!
Revised stock1:
Company: Nifty Foods, Shares: 10
Share Price: $ 50.000, Total Worth: $500.00
Done.
Bye, NanoSmart!
Bye, Nifty Foods!

在C++11中，只要提供与某个构造函数的参数列表匹配的内容，并用大括号将它们括起：
Stock hot tip = {"Derivatives Plus Plus", 100, 45.0};
Stock jock {"Sport Age Storage，Inc"};
stock temp {}
在前两个声明中，用大括号括起的列表与下面的构造函数匹配：t
Stock::Stock(const std::string & co, long n = 0, double pr = 0.0);
因此，将使用该构造函数来创建这两个对象。创建对象jock时，第二和第三个参数将为默认值0和0.0.
第三个声明与默认构造函数匹配，因此将使用该构造函数创建对象temp。
const Stock land = Stock ("Kludgehorn Properties");
land.show();
对于当前的C++来说，编译器将拒绝第二行。这是什么原因呢？因为show的代码无法确保调用对象不被修改。
C++的解决方法是将const关键字放在函数的括号后面。也就是说，show声明应像这样：
    void show() const;
同样，函数定义的开头应像这样：
void Stock::show() const
{
    using std::cout;
    using std::ios_base;
    ios_base::fmtflags orig = cout.setf(ios_base::fixed, ios_base::floatfield);
    std::streamsize prec = cout.precision(3);
    cout << "Company: " << company << ", Shares: " << shares << '\n';
    cout << "Share Price: $ " << share_val;
    cout.precision(2);
    cout << ", Total Worth: $" << total_val << '\n';
    cout.setf(orig, ios_base::floatfield);
    cout.precision(prec);
}
以这种方式声明和定义的类函数被称为const成员函数。
只要类方法不修改调用对象，就应将其声明为const。从现在开始，我们将遵守这一规则。
10.3.6 构造函数和析构函数小结
构造函数是一种特殊的类成员函数，在创建类对象时被调用。
构造函数的名称和类名相同，但通过函数重载，可以创建多个同名的构造函数，
条件是每个函数的特征标（参数列表）都不同。另外，构造函数没有声明类型。
通常，构造函数用于初始化类对象的成员，初始化应与构造函数的参数列表匹配。
如果编译器支持C++11，则可使用列表初始化。
如果构造函数只有一个参数，则将对象初始化为一个与参数的类型相同的值时，该构造函数将被调用。
Bozo dribble = bozo (44);   //primary form
Bozo roon (66);   //secondary form
Bozo tubby = 32;   //special form for one-argument constructors
实际上，第三个示例是新内容，不属于复习内容，但现在正是介绍它的好时机。
第11章将介绍一种关闭这项特性的方式，因为它可能带来令人不愉快的意外。
接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值：
Classname object = value;
这种特性可能导致问题，但正如第11章将介绍的，可关闭这项特性。
默认构造函数没有参数，因此如果创建对象时没有进行显式地初始化，则将调用默认构造函数。
如果程序中没有提供任何构造函数，则编译器会为程序定义一个默认构造函数；
否则，必须自己提供默认构造函数。默认构造函数可以没有任何参数；如果有，则必须给所有参数都提供默认值。
对于未被初始化的对象，程序将使用默认构造函数来创建。
就像对象被创建时程序将调用构造函数一样，当对象被删除时，程序将调用析构函数。
每个类都只能有一个析构函数。析构函数没有返回类型（连void都没有），也没有参数，其名称为类名称前加上~。
如果构造函数使用了new，则必须提供使用delete的析构函数。
10.4 this指针
对于Stock类，还有很多工作要做。到目前为止，每个类成员函数都只涉及一个对象，即调用它的对象。
但有时候方法可能涉及到两个对象，在这种情况下需要使用C++的this指针。
虽然Stock类声明可以显示数据，但它缺乏分析能力。例如，从show的输出我们可以知道持有的哪一支股票价格最高，
但由于程序无法直接访问total_val，因此无法作出判断。要让程序知道存储的数据最直接的方式是让方法返回一个值。
为此，通常使用内联代码，如下例所示：
class Stock
{
private:
double total_val;
public:
   double total() const {return total_val;}
}
通过将该函数添加到类声明中，可以让程序查看一系列股票，找到价格最高的那一支。
然而，可以采用另一种方法，定义一个成员函数，它查看两个Stock对象，并返回股价较高的那个对象的引用。
实现这种方法时，将出现一些有趣的问题，下面就来讨论这些问题。
首先，如何将两个要比较的对象提供给成员函数呢？
例如，假设将该方法命名为topval，将第二个对象作为参数传递给它，可以按引用来传递参数。
其次，让方法返回一个引用，该引用指向股价总值较高的对象。因此，用于比较的方法的原型如下：
const Stock & topval (const Stock & s) const;
该函数隐式地访问一个对象，而显式地访问另一个对象，并返回其中一个对象的引用。
括号中的const表明，该函数不会修改被显式地访问的对象；而括号后的const表明，该函数不会修改被隐式地访问的对象。
由于该函数返回了两个const对象之一的引用，因此返回类型也应为const引用。
假设要对Stock对象stock1和stock2进行比较，并将其中股价总值较高的那一个赋给top对象，则可以使用下面两条语句之一
top = stock1.topval(stock2);
top = stock2.topval(stock1);
this指针指向用来调用成员函数的对象（this被作为隐藏参数传递给方法）。
这样，函数调用stock1.topval(stock2)将this设置为stock1对象的地址，使得这个指针可用于topval方法。
同样，函数调用stock2.topval(stock1)将this设置为stock2对象的地址。
一般来说，所有的类方法都将this指针设置为调用它的对象的地址。
每个成员函数（包括构造函数和析构函数）都有一个this指针。this指针指向调用对象。
如果方法需要引用整个调用对象，则可以使用表达式*this.。
在函数的括号后面使用const限定符将this限定为const，这样将不能使用this来修改对象的值。
程序清单10.7 stock20.h
#pragma once
#ifndef STOCK20_H_
#define STOCK20_H_ 
#include <string> 

class Stock
{
private:
	std::string company;
	int shares;
	double share_val;
	double total_val;
	void set_tot() { total_val = shares * share_val; }
public:
	Stock();
	Stock(const std::string & co, long n = 0, double pr = 0.0);
	~Stock();
	void buy(long num, double price);
	void sell(long num, double price);
	void update(double price);
	void show() const;
	const Stock & topval(const Stock & s) const;
};

#endif

程序清单10.8 stock20.cpp
#include <iostream>
#include "stock20.h"

Stock::Stock()
{
    std::cout << "Default constructor called\n";
    company = "no name";
    shares = 0;
    share_val = 0.0;
    total_val = 0.0;
}
Stock::Stock(const std::string & co, long n, double pr)
{
    std::cout << "Constructor using " << co << " called\n";
    company = co;
    if (n < 0)
    {
        std::cout << "Number of shares can't be negative; " << company << " shares set to 0.\n";
        shares = 0;
    }
    else
    {
        shares = n;
    }

    share_val = pr;
    set_tot();
}

Stock::~Stock()
{
    std::cout << "Bye, " << company << "!\n";
}

void Stock::buy(long num, double price)
{
    if (num < 0)
    {
        std::cout << "Number of shares purchased can't be negative. " << "Transaction is aborted.\n";
    }
    else
    {
        shares += num;
        share_val = price;
        set_tot();
    }
}

void Stock::sell(long num, double price)
{
    using std::cout;
    if (num < 0)
    {
        cout << "Number of shares sold can't be negative. " << "Transaction is aborted.\n";
    }
    else if (num > shares)
    {
        cout << "You can't sell more than you have! " << "Transaction is aborted.\n";
    }
    else
    {
        shares -= num;
        share_val = price;
        set_tot();
    }
}
void Stock::update(double price)
{
    share_val = price;
    set_tot();
}
void Stock::show() const
{
    using std::cout;
    using std::ios_base;
    ios_base::fmtflags orig = cout.setf(ios_base::fixed, ios_base::floatfield);
    std::streamsize prec = cout.precision(3);
    cout << "Company: " << company << ", Shares: " << shares << '\n';
    cout << "Share Price: $" << share_val;
    cout.precision(2);
    cout << ", Total Worth: $" << total_val << '\n';
    cout.setf(orig, ios_base::floatfield);
    cout.precision(prec);
}

const Stock &Stock::topval(const Stock &s) const
{
    if (s.total_val > total_val)
    {
        return s;
    }
    else
    {
        return *this;
    }
}
10.5对象数组
声明对象数组的方法与声明标准类型数组相同：
Stock mystuff[4];
当程序创建未被显式初始化的类对象时，总是调用默认构造函数。
上述声明要求，这个类要么没有显式地定义任何构造函数（在这种情况下，将使用不执行任何操作的隐式默认构造函数），
要么定义了一个显式默认构造函数（就像这个例子那样）。
每个元素（mystuff[0]，mystuff[1]）都是Stock对象，可以使用Stock方法。
可以用构造函数来初始化数组元素。在这种情况下，必须为每个元素调用构造函数：
const int STKS = 4;
stock stocks[STKS] = {
Stock ("NanoSmart", 12.5, 20),
Stock ("Boffo Objects", 200, 2.0),
Stock ("Monolithic Obelisks", 130, 3.25),
Stock ("Fleep Enterprises", 60, 6.5)
};
如果类包含多个构造函数，则可以对不同的元素使用不同的构造函数：
const int STKS = 10;
stock stocks[STKS] = {
Stock ("NanoSmart", 12.5, 20),
Stock (),
Stock ("Monolithic Obelisks", 130, 3.25)
};
上述代码使用Stock(const std::string & co, long n = 0, double pr = 0.0)初始化stock[0]和stock[2]，
使用构造函数Stock()初始化stock[1]。由于该声明只初始化了数组的部分元素，
因此余下的7个元素将使用默认构造函数进行初始化。
初始化对象数组的方案是，首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，
然后将临时对象的内容复制到相应的元素中。因此，要创建类对象数组，则这个类必须有默认构造函数。
程序清单10.9 usestock20.cpp
#include <iostream>
#include "stock20.h"

const int STKS = 4;

int main()
{
    Stock stocks[STKS] =
    {
        Stock("NanoSmart", 12, 20.0),
        Stock("Boffo Objects", 200, 2.0),
        Stock("Monolithic Obelisks", 130, 3.25),
        Stock("Fleep Enterprises", 60, 6.5)
    };

    std::cout << "Stock holdings:\n";
    int st;
    for (st = 0; st < STKS; st++)
    {
        stocks[st].show();
    }
    const Stock *top = &stocks[0];
    for (st = 1; st < STKS; st++)
    {
        top = & ( top->topval(stocks[st]) );
    }
    std::cout << "\nMost valuable holding:\n";
    top->show();

    return 0;
}
显示结果如下
Constructor using NanoSmart called
Constructor using Boffo Objects called
Constructor using Monolithic Obelisks called
Constructor using Fleep Enterprises called
Stock holdings:
Company: NanoSmart, Shares: 12
Share Price: $20.000, Total Worth: $240.00
Company: Boffo Objects, Shares: 200
Share Price: $2.000, Total Worth: $400.00
Company: Monolithic Obelisks, Shares: 130
Share Price: $3.250, Total Worth: $422.50
Company: Fleep Enterprises, Shares: 60
Share Price: $6.500, Total Worth: $390.00

Most valuable holding:
Company: Monolithic Obelisks, Shares: 130
Share Price: $3.250, Total Worth: $422.50
Bye, Fleep Enterprises!
Bye, Monolithic Obelisks!
Bye, Boffo Objects!
Bye, NanoSmart!

10.6 类作用域
C++类引入了一种新的作用域：类作用域，在类中定义的名称（如类数据成员名和类成员函数名）的作用域都为整个类，
作用域为整个类的名称只在该类中是已知的，在类外是不可知的。
因此，可以在不同类中使用相同的类成员名而不会引起冲突。
另外，类作用域意味着不能从外部直接访问类的成员，公有成员函数也是如此。
也就是说，要调用公有成员函数，必须通过对象。同样，在定义成员函数时，必须使用作用域解析运算符。
总之，在类声明或成员函数定义中，可以使用未修饰的成员名称。
构造函数名称在被调用时，才能被识别，因为它的名称与类名相同。
在其他情况下，使用类成员名时，必须根据上下文使用直接成员运算符（.）、间接成员运算符（->）或作用域解析运算符（：）。
10.6.1 作用域为类的常量
有时候，使符号常量的作用域为类很有用。有两种方式可以实现这个目标，并且效果相同。
第一种方式是在类中声明一个枚举。在类声明中声明的枚举的作用域为整个类，
因此可以用枚举为整型常量提供作用域为整个类的符号名称。
注意，用这种方式声明枚举并不会创建类数据成员。也就是说，所有对象中都不包含枚举。
由于这里使用枚举只是为了创建符号常量，并不打算创建枚举类型的变量，因此不需要提供枚举名。
class Bakery
{
private:
enum {Months = 12}
double costs[Months];
...
}
顺便说一句，在很多实现中，ios_base类在其公有部分中完成了类似的工作，诸如ios base:fixed等标识符就来自这里。
其中，fixed是ios_base类中定义的典型的枚举量。
C++提供了另一种在类中定义常量的方式――使用关键字static：
class Bakery
{
private:
    static const int Months = 12;
    double costs[Months];
    ...
}
这将创建一个名为Months的常量，该常量将与其他静态变量存储在一起，而不是存储在对象中。
因此，只有一个Months常量，被所有Bakery对象共享。第12章将深入介绍静态类成员。
10.6.2 作用域内枚举（C++11）
C++11提供了一种新枚举，其枚举量的作用域为类。这种枚举的声明类似于下面这样：
enum class egg {Small, Medium, Large, Jumbo};
enum class t_shirt {Small, Medium, Large, Xlarge};
也可使用关键字struct代替class。无论使用哪种方式，都需要使用枚举名来限定枚举量
egg choice = egg::Large;
t_shirt Floyd = t_shirt::Large;
枚举量的作用域为类后，不同枚举定义中的枚举量就不会发生名称冲突了。
C++11还提高了作用域内枚举的类型安全。在有些情况下，常规枚举将自动转换为整型，
如将其赋给int变量或用于比较表达式时，但作用域内校举不能隐式地转换为整型。
但在必要时，可进行显式类型转换
int Frodo = int (t_shirt::Small);
默认情况下，C++11作用域内枚举的底层类型为int。另外，还提供了一种语法，可用于做出不同的选择：
enum class :short pizza {Small, Medium, Large, XLarge};
:short将底层类型指定为short。底层类型必须为整型。
在C++11中，也使用这种语法来指定常规校举的底层类型，但如果没有指定，编译器选择的底层类型将随实现而异。
10.7 抽象数据类型
下面简要地介绍一下栈的特征。首先，栈存储了多个数据项；其次，栈由可对它执行的操作来描述。
可创建空栈。
可将数据项添加到堆顶（压入）。
可从栈顶删除数据项（弹出）
可查看栈否填满
可查看栈是否为空。
可以将上述描述转换为一个类声明，其中公有成员函数提供了表示栈操作的接口，而私有数据成员负责存储栈数据。
私有部分表明数据存储的方式。例如，可以使用常规数组、动态分配数组或更高级的数据结构（如链表），
然而，公有接口应隐藏数据表示，而以通用的术语来表达，如创建栈、压入等。
程序清单10.10 stack.h
#pragma once
#ifndef STACK_H_
#define STACK_H_

typedef unsigned long Item;

class Stack
{
private:
    enum { MAX = 10 };
    Item items[MAX];
    int top;
public:
    Stack();
    bool isempty() const;
    bool isfull() const;
    bool push(const Item &item);
    bool pop(Item &item);
};

#endif

程序清单10.11 stack.cpp
#include <iostream>
#include "stack.h"

Stack::Stack()
{
    top = 0;
}

bool Stack::isempty() const
{
    return top == 0;
}

bool Stack::isfull() const
{
    return top == MAX;
}

bool Stack::push(const Item &item)
{
    if (top < MAX)
    {
        items[top++] = item;
        return true;
    }
    else
    {
        return false;
    }
}

bool Stack::pop(Item &item)
{
    if (top > 0)
    {
        item = items[--top];
        return true;
    }
    else
    {
        return false;
    }
}

程序清单10.12 stacker.cpp
#include <iostream>
#include <cctype>
#include "stack.h"

int main()
{
    using namespace std;
    Stack st;
    char ch;
    unsigned long po;
    cout << "Please enter A to add a purchase order,\n"
         << "P to process a purchase order, or Q to quit.\n";
    while (cin >> ch && toupper(ch) != 'Q')
    {
        while (cin.get() != '\n')
        {
            continue;
        }
        if (!isalpha(ch))
        {
            cout << "Please enter A, P, Q\n";
            continue;
        }
        switch (ch)
        {
        case 'A':
        case 'a':
            cout << "Enter a purchase order number to add: ";
            cin >> po;
            if (st.isfull())
            {
                cout << "stack already full\n";
            }
            else
            {
                st.push(po);
            }
            break;
        case 'P':
        case 'p':
            if (st.isempty())
            {
                cout << "stack already empty\n";
            }
            else
            {
                st.pop(po);
                cout << "purchase order #" << po << " popped\n";
            }
            break;
        default :
            cout << "Please enter A, P, Q\n";
            continue;
            break;
        }
        cout << "Please enter A to add a purchase order,\n"
             << "P to process a purchase order, or Q to quit.\n";
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
A
Enter a purchase order number to add: 123
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
A
Enter a purchase order number to add: 456
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
A
Enter a purchase order number to add: 789
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
P
purchase order #789 popped
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
P
purchase order #456 popped
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
A
Enter a purchase order number to add: 666
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
P
purchase order #666 popped
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
P
purchase order #123 popped
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
P
stack already empty
Please enter A to add a purchase order,
P to process a purchase order, or Q to quit.
Q
Done.

10.8 总结
面向对象编程强调的是程序如何表示数据。使用OOP方法解决编程问题的第一步是根据它与程序之间的接口来描述数据，从而指定如何使用数据。
然后，设计一个类来实现该接口。一般来说，私有数据成员存储信息，公有成员函数（又称为方法）提供访问数据的唯一途径。
类将数据和方法组合成一个单元，其私有性实现数据隐藏。
通常，将类声明分成两部分组成，这两部分通常保存在不同的文件中。
类声明（包括由函数原型表示的方法）应放到头文件中。定义成员函数的源代码放在方法文件中。这样便将接口描述与实现细节分开了。
从理论上说，只需知道公有接口就可以使用类。当然，可以查看实现方法（除非只提供了编译形式），但程序不应依赖于其实现细节。
只要程序和类只通过定义接口的方法进行通信，程产员就可以随意地对任何部分做独立的改进，而不必担心这样做会导致意外的不良影响。
类是用户定义的类型，对象是类的实例。这意味着对象是这种类型的变量，例如由new按类描述分配的内存。
C++试图让用户定义的类型尽可能与标准类型类似，因此可以声明对象、指向对象的指针和对象数组。
可以按值传递对象、将对象作为函数返回值、将一个对象赋给同类型的另一个对象。
如果提供了构造函数，则在创建对象时，可以初始化对象。如果提供了析构函数方法，则在对象消亡后，程序将执行该函数。
每个对象都存储自己的数据，而共享类方法。如果mr_object是对象名，try_me是成员函数，
则可以使用成员运算符句点调用成员函数：mr_object.try me()。
在try_me方法中引用类数据成员时，将使用mr_object对象相应的数据成员。
同样，函数调用i_object.try_me()将访问i_object对象的数据成员。
如果希望成员函数对多个对象进行操作，可以将额外的对象作为参数传递给它。
如果方法需要显式地引用调用它的对象，则可以使用this指针。
由于this指针被设置为调用对象的地址，因此*this是该对象的别名。
类很适合用于描述ADT，公有成员函数接口提供了ADT描述的服务，
类的私有部分和类方法的代码提供了实现，这些实现对类的客户隐藏。
10.9 复习题
1.什么是类？
类是用户定义的类型，类声明指定了数据将如何存储，同时指定了用来访问和操纵这些数据的方法（类成员函数）。

2.类如何实现抽象、封装和数据隐藏？
类提供了完成对应任务的公有接口（类成员函数），这是抽象。
类的数据成员是私有的，只能通过公有接口（类成员函数）来访问这些数据，这是数据隐藏。
类实现的具体细节（如数据表示和方法的代码）都是隐藏的，这是封装。

3.对象和类之间的关系是什么？
类是用户定义的类型，对象是根据类定义被创建出来的变量。
类和对象之间的关系同标准类型与其变量之间的关系相同。

4.除了是函数之外，类函数成员与类数据成员之间的区别是什么？
如果创建给定类的多个对象，则每个对象都有其自己的数据内存空间；但所有的对象都使用同一组成员函数。

5.定义一个类来表示银行帐户。数据成员包括储户姓名、账号（使用字符串）和存款。
成员函数执行如下操作：创建一个对象并将其初始化；显示储户姓名、账号和存款；
存入参数指定的存款；取出参数指定的款项。
请提供类声明，而不用给出方法实现。
#include <string>

class BankAccount
{
private:
    std::string name;
    std::string acctnum;
    double balance;
public:
    BankAccount();
    BankAccount(const std::string &client, const std::string &num, double bal = 0.0);
    void show() const;
    void deposit (double cash);
    void withdraw (double cash);
};

6.类构造函数在何时被调用？类析构函数呢？
在创建类对象或显式调用构造函数时，类的构造函数都将被调用。
当对象过期时，类的析构函数将被调用。

7.给出复习题5中的银行账户类的构造函数的代码。
BankAccount::BankAccount()
{
    name = "no name";
    acctnum = "no acctnum";
    balance = 0;
}
BankAccount::BankAccount(const std::string &client, const std::string &num, double bal)
{
    name = client;
    acctnum = num;
    balance = bal;
}

8.什么是默认构造函数，拥有默认构造函数有何好处？
默认构造函数是没有参数或所有参数都有默认值的构造函数。
拥有默认构造函数后，可以声明对象，而不初始化它。它还使得能够声明对象数组。

9.修改Stock类的定义（stock20.h中的版本），使之包含返回各个数据成员值的成员函数。
stock30.h
#pragma once
#ifndef STOCK30_H_
#define STOCK30_H_ 
#include <string> 

class Stock
{
private:
	std::string company;
	int shares;
	double share_val;
	double total_val;
	void set_tot() { total_val = shares * share_val; }
public:
	Stock();
	Stock(const std::string & co, long n = 0, double pr = 0.0);
	~Stock();
	void buy(long num, double price);
	void sell(long num, double price);
	void update(double price);
	void show() const;
	const Stock & topval(const Stock & s) const;
              int sharenum() const {return shares;}
              double shareval() const {return share_val;}
              double totalval() const {return total_val;}
              const string & coname() const {return company;}
};

#endif

10.this和*this是什么？
this指针被设置为调用类成员函数的对象的地址，*this是该对象的别名。

10.10编程练习
1.为复习题5描述的类提供方法定义，并编写一个小程序来演示所有的特性。
bank_account.h
#pragma once
#ifndef BANK_ACCOUNT_H_
#define BANK_ACCOUNT_H_
#include <string>


class Bank_account
{
private:
    std::string name_depositor;
    std::string account_number;
    unsigned int balance;
public:
    Bank_account();
    Bank_account(const std::string &name_dep, const std::string &acc_num, double bal = 0);
    ~Bank_account();
    void show_account();
    void add_balance(double bal);
    void cash_withdrawal(double bal);
};

#endif

bank_account.cpp
#include <iostream>
#include "bank_account.h"

Bank_account::Bank_account()
{
    name_depositor = "NON";
    account_number = "000 000 000 000";
    balance = 0.0;
}

Bank_account::Bank_account(const std::string &name_dep, const std::string &acc_num, double bal)
{
    name_depositor = name_dep;
    account_number = acc_num;

    if (bal < 0)
    {
        std::cout << "The balance can not be negative. Your balance will be set to 0." << std::endl;
        balance = 0;
    }
    else
    {
        balance = bal;
    }
}

Bank_account::~Bank_account()
{
    std::cout << "All transactions with " << account_number << " completed." << std::endl;
    std::cout << std::endl;
}

void Bank_account::show_account()
{
    std::cout << "Name of depositor: " << name_depositor << std::endl;
    std::cout << "Deposit number: " << account_number << std::endl;
    std::cout << "Balance: $" << balance  << std::endl;
    std::cout << std::endl;
}

void Bank_account::add_balance(double bal)
{
    if (bal < 0)
    {
        std::cout << "The value can not be negative." << std::endl;
        std::cout << std::endl;
    }
    else
    {
        balance += bal;
        std::cout << "The balance is added with $" << bal  << std::endl;
        std::cout << std::endl;
    }
}

void Bank_account::cash_withdrawal(double bal)
{
    if (bal > balance)
    {
        std::cout << "Unable to withdraw $" << bal;
        std::cout << " On your balance sheet $" << balance << std::endl;
        std::cout << std::endl;
    }
    else
    {
        balance -= bal;
        std::cout << "Discontinued $" << bal;
        std::cout << " On your balance sheet $" << balance << std::endl;
        std::cout << std::endl;
    }
}

bank.cpp
#include <iostream>
#include "bank_account.h"

void print_menu();
void transactions_menu();

int main()
{
    Bank_account Acc;
    Acc.show_account();
    std::string name_depositor;
    std::string account_number;
    double balance = 0;
    int menu = 0;

    print_menu();
    while (std::cin >> menu && menu != 3)
    {
        while (std::cin.get() != '\n')
        {
            continue;
        }
        switch (menu)
        {
        case 1:
            std::cout << "Enter the name of the account holder: " << std::endl;
            std::getline(std::cin, name_depositor, '\n');

            std::cout << "Enter the account number: " << std::endl;
            std::getline(std::cin, account_number, '\n');

            std::cout << "Enter the current balance: " << std::endl;
            std::cin >> balance;
            while (std::cin.get() != '\n')
            {
                continue;
            }

            Acc = Bank_account(name_depositor, account_number, balance);
            menu = 0;
            print_menu();
            break;
        case 2:
            menu = 0;
            transactions_menu();
            while (std::cin >> menu && menu != 4)
            {
                while (std::cin.get() != '\n')
                {
                    continue;
                }

                switch (menu)
                {
                case 1:
                    std::cout << "Enter the amount to be added to the balance: ";
                    std::cin >> balance;
                    while (std::cin.get() != '\n')
                    {
                        continue;
                    }
                    Acc.add_balance(balance);
                    menu = 0;
                    transactions_menu();
                    break;
                case 2:
                    std::cout << "Enter the amount to be withdrawn from the balance: ";
                    std::cin >> balance;
                    while (std::cin.get() != '\n')
                    {
                        continue;
                    }
                    Acc.cash_withdrawal(balance);
                    menu = 0;
                    transactions_menu();
                    break;
                case 3:
                    Acc.show_account();
                    menu = 0;
                    transactions_menu();
                    break;
                default:
                    std::cout << "Please Enter 1 or 2 or 3 or 4\n";
                    menu = 0;
                    transactions_menu();
                    break;
                }
            }
            menu = 0;
            print_menu();
            break;
        default:
            std::cout << "Please Enter 1 or 2 or 3\n";
            menu = 0;
            print_menu();
            break;
        }
    }

    std::cout << "Done.\n";

    return 0;
}

void print_menu()
{
    std::cout << "[1] - Create an account" << std::endl;
    std::cout << "[2] - Account Operations" << std::endl;
    std::cout << "[3] - Quit" << std::endl;
}

void transactions_menu()
{
    std::cout << "[1] - Add cash" << std::endl;
    std::cout << "[2] - Withdraw cash" << std::endl;
    std::cout << "[3] - Display Information" << std::endl;
    std::cout << "[4] - Quit" << std::endl;
}
显示结果如下

Name of depositor: NON
Deposit number: 000 000 000 000
Balance: $0

[1] - Create an account
[2] - Account Operations
[3] - Quit
1
Enter the name of the account holder:
Mike Pence
Enter the account number:
222 222 222 222
Enter the current balance:
200
All transactions with 222 222 222 222 completed.

[1] - Create an account
[2] - Account Operations
[3] - Quit
2
[1] - Add cash
[2] - Withdraw cash
[3] - Display Information
[4] - Quit
3
Name of depositor: Mike Pence
Deposit number: 222 222 222 222
Balance: $200

[1] - Add cash
[2] - Withdraw cash
[3] - Display Information
[4] - Quit
1
Enter the amount to be added to the balance: 300
The balance is added with $300

[1] - Add cash
[2] - Withdraw cash
[3] - Display Information
[4] - Quit
3
Name of depositor: Mike Pence
Deposit number: 222 222 222 222
Balance: $500

[1] - Add cash
[2] - Withdraw cash
[3] - Display Information
[4] - Quit
2
Enter the amount to be withdrawn from the balance: 150
Discontinued $150 On your balance sheet $350

[1] - Add cash
[2] - Withdraw cash
[3] - Display Information
[4] - Quit
3
Name of depositor: Mike Pence
Deposit number: 222 222 222 222
Balance: $350

[1] - Add cash
[2] - Withdraw cash
[3] - Display Information
[4] - Quit
4
[1] - Create an account
[2] - Account Operations
[3] - Quit
3
Done.
All transactions with 222 222 222 222 completed.

2.下面是一个非常简单的类定义：
它使用了一个string对象和一个字符数组，让您能够比较它们的用法。
请提供未定义的方法的代码，以完成这个类的实现。
再编写一个使用这个类的程序，它使用了三种可能的构造函数调用（没有参数、一个参数和两个参数）以及两种显示方法。
person_class.h
#pragma once
#ifndef PERSON_CLASS_H_
#define PERSON_CLASS_H_
#include <string>

class Person
{
private:
    static const int LIMIT = 32;
    std::string lname;
    char fname[LIMIT];
public:
    Person()
    {
        lname = "";
        fname[0] = '\0';
    }
    Person(const std::string &In, const char *fn = "Heyyou");
    ~Person();

    void Show() const;
    void FormalShow() const;
};

#endif

person_class.cpp
#include <iostream>
#include <cstring>
#include "person_class.h"

Person::Person(const std::string &In, const char *fn)
{
    lname = In;
    strcpy(fname, fn);
}
Person::~Person()
{
    std::cout << "Bye, " << lname << ", " << fname << "!\n";
}
void Person::Show() const
{
    std::cout << fname << " " << lname << std::endl;
}
void Person::FormalShow() const
{
    std::cout << lname << ", " << fname << std::endl;
}

person.cpp
#include <iostream>
#include "person_class.h"

int main()
{
    Person one;
    Person two("Smythecraft");
    Person three = Person("Dimwiddy", "Sam");

    one.Show();
    std::cout << std::endl;
    one.FormalShow();

    std::cout << "=================" << std::endl;

    two.Show();
    std::cout << std::endl;
    two.FormalShow();

    std::cout << "=================" << std::endl;

    three.Show();
    std::cout << std::endl;
    three.FormalShow();

    return 0;
}
显示结果如下


,
=================
Heyyou Smythecraft

Smythecraft, Heyyou
=================
Sam Dimwiddy

Dimwiddy, Sam
Bye, Dimwiddy, Sam!
Bye, Smythecraft, Heyyou!
Bye, , !

3.完成第9章的编程练习1，但要用正确的golf类声明替换那里的代码。
用带合适参数的构造函数替换setgolf (golf &, const char *, int)，以提供初始值。
保留setgolt的交互版本，但要用构造函数来实现它
golf_class.h
#pragma once
#ifndef GOLF_CLASS_H_
#define GOLF_CLASS_H_

class Golf
{
private:
    static const int Len = 128;
    char fullname[Len];
    int handicap;
public:
    Golf();
    Golf(const char *name, int hc);
    ~Golf();
    int set_golf();
    void show_golf();
};

#endif

golf_class.cpp
#include <iostream>
#include <cstring>
#include "golf_class.h"

Golf::Golf()
{
    strcpy(fullname, "");
    handicap = 0;
}

Golf::Golf(const char *name, int hc)
{
    strcpy(fullname, name);
    handicap = hc;
}

Golf::~Golf()
{
    std::cout << "Bye, " << fullname << ", " << handicap << "!\n";
}

int Golf::set_golf()
{
    int name_valid = 0;

    std::cout << "Enter the player's name: ";
    std::cin.getline(fullname, Len);

    if (strlen(fullname) > 0)
    {
        name_valid = 1;
        std::cout << "Enter the player's handicap: " << std::endl;
        (std::cin >> handicap).get();
        Golf temp(fullname, handicap);
        *this = temp;
    }
    return name_valid;
}

void Golf::show_golf()
{
    std::cout << "Player name: " << fullname << std::endl;
    std::cout << "Player Handicap: " << handicap << std::endl;
}


ch10_p03.cpp
#include <iostream>
#include "golf_class.h"

int main()
{
    Golf ann;
    ann = Golf("Ann Birdfree", 24);
    ann.show_golf();

    std::cout << "Enter the number of players: ";
    int col_players = 0;
    (std::cin >> col_players).get();
    std::cout << std::endl;

    Golf *players = new Golf[col_players];
    int i;
    for (i = 0; i < col_players; i++)
    {
        if (players[i].set_golf() == 0)
        {
            break;
        }
    }

    for (int j = 0; j < i; j++)
    {
        players[j].show_golf();
    }

    delete [] players;

    return 0;
}
显示结果如下
Bye, Ann Birdfree, 24!
Player name: Ann Birdfree
Player Handicap: 24
Enter the number of players: 3

Enter the player's name: Mike Pence
Enter the player's handicap:
33
Bye, Mike Pence, 33!
Enter the player's name: Peter Smith
Enter the player's handicap:
22
Bye, Peter Smith, 22!
Enter the player's name:
Player name: Mike Pence
Player Handicap: 33
Player name: Peter Smith
Player Handicap: 22
Bye, , 0!
Bye, Peter Smith, 22!
Bye, Mike Pence, 33!
Bye, Ann Birdfree, 24!

4.完成第9章的编程练习4，但将Sales结构及相关的函数转换为一个类及其方法。
用构造函数替换setSales (sales &, double [], int)函数。用构造函数实现setSales (Sales &)方法的交互版本。
将类保留在名称空间SALES中。
sales_class.h
#pragma once
#ifndef SALES_CLASS_H_
#define SALES_CLASS_H_

namespace SALES
{
    static const int QUARTERS = 4;

    class Sales
    {
    private:
        double sales[QUARTERS];
        double average;
        double max;
        double min;
        double find_avg(const double arr[], int size);
        double find_max(const double arr[], int size);
        double find_min(const double arr[], int size);
    public:
        Sales();
        Sales(const double arr[], int n);
        ~Sales();
        void showSales();
        void setSales();
    };
}

#endif

sales_class.cpp
#include <iostream>
#include "sales_class.h"

SALES::Sales::Sales()
{
    for (int i = 0; i < QUARTERS; i++)
    {
        sales[i] = 0;
    }
    average = 0;
    max = 0;
    min = 0;
}
SALES::Sales::Sales(const double arr[], int n)
{
    for (int i = 0; i < QUARTERS; i++)
    {
        sales[i] = 0;
    }

    if (n > QUARTERS)
    {
        n = QUARTERS;
    }
    for (int i = 0; i < n; i++)
    {
        sales[i] = arr[i];
    }
    average = find_avg(sales, QUARTERS);
    max = find_max(sales, QUARTERS);
    min = find_min(sales, QUARTERS);
}
SALES::Sales::~Sales()
{

}

void SALES::Sales::setSales()
{
    for (int i = 0; i < QUARTERS; ++i)
    {
        std::cout << "Enter total sales for " << i + 1 << " quarter: ";
        std::cin >> sales[i];
    }

    average = find_avg(sales, QUARTERS);
    max = find_max(sales, QUARTERS);
    min = find_min(sales, QUARTERS);
}

void SALES::Sales::showSales()
{
    for (int i = 0; i < QUARTERS; i++)
    {
        if (i != 0)
        {
            std::cout << ", ";
        }
        std::cout << sales[i];
    }
    std::cout << std::endl;
    std::cout << "Average value: " << average << std::endl;
    std::cout << "Maximum value: " << max << std::endl;
    std::cout << "Minimum value: " << min << std::endl;
}
double SALES::Sales::find_avg(const double arr[], int size)
{
    double summ = 0;
    for (int i = 0; i < size; i++)
    {
        summ += arr[i];
    }
    return summ / size;
}

double SALES::Sales::find_max(const double arr[], int size)
{
    double max = arr[0];
    for (int i = 0; i < size; i++)
    {
        if (arr[i] > max)
        {
            max = arr[i];
        }
    }
    return max;
}
double SALES::Sales::find_min(const double arr[], int size)
{
    double min = arr[0];
    for (int i = 0; i < size; i++)
    {
        if (arr[i] < min)
        {
            min = arr[i];
        }
    }
    return min;
}

ch10_p04.cpp
#include <iostream>
#include "sales_class.h"

int main()
{
    double arr[] = { 123.12, 522.22, 455.42, 777.32 };

    SALES::Sales Struct1;
    Struct1.setSales();
    std::cout << std::endl;
    Struct1.showSales();
    std::cout << std::endl;

    SALES::Sales Struct2 (arr, SALES::QUARTERS);
    Struct2.showSales();

    return 0;
}
显示结果如下
Enter total sales for 1 quarter: 123
Enter total sales for 2 quarter: 567
Enter total sales for 3 quarter: 666
Enter total sales for 4 quarter: 222

123, 567, 666, 222
Average value: 394.5
Maximum value: 666
Minimum value: 123

123.12, 522.22, 455.42, 777.32
Average value: 469.52
Maximum value: 777.32
Minimum value: 123.12

5.考虑下面的结构声明：
struct customer
{
    char fullname[35];
    double payment;
}
编写一个程序，它从栈中添加和删除customer结构（栈用Stack类声明表示），
每次customer结构被删除时，其payment的值都被加入到总数中，并报告总数。
stack_class.h
#pragma once
#ifndef STACK_CLASS_H_
#define STACK_CLASS_H_


struct customer
{
    char fullname[36];
    double payment;
};

typedef customer Item;

class Stack
{
private:
    enum { MAX = 10 };
    Item items[MAX];
    int top;
public:
    Stack();
    bool isempty() const;
    bool isfull() const;
    bool push(const Item &item);
    bool pop(Item &item);
};

#endif

stack_class.cpp
#include <iostream>
#include "stack_class.h"

Stack::Stack()
{
    top = 0;
}
bool Stack::isempty() const
{
    return top == 0;
}
bool Stack::isfull() const
{
    return top == MAX;
}
bool Stack::push(const Item &item)
{
    if (top < MAX)
    {
        items[top++] = item;
        return true;
    }
    else
    {
        return false;
    }
}
bool Stack::pop(Item &item)
{
    if (top > 0)
    {
        item = items[--top];
        return true;
    }
    else
    {
        return false;
    }
}

ch10_p05.cpp
#include <iostream>
#include <string>
#include "stack_class.h"

int main()
{
    Stack st;
    char ch;
    customer po;
    double subtotal = 0.0;

    std::cout << "Type A to add the client,\n";
    std::cout << "P to delete the client, and Q to exit.\n";

    while (std::cin >> ch && toupper(ch) != 'Q')
    {
        while (std::cin.get() != '\n')
        {
            continue;
        }

        if (!isalpha(ch))
        {
            std::cout << "Please enter A, P, Q\n";
            continue;
        }

        switch (ch)
        {
        case 'A':
        case 'a':
            std::cout << "Enter customer name: ";
            std::cin.getline(po.fullname, 36);
            std::cout << "Enter customer payment: ";
            (std::cin >> po.payment).get();

            if (st.isfull())
            {
                std::cout << "Stack already full\n";
            }
            else
            {
                st.push(po);
            }
            break;
        case 'P':
        case 'p':
            if (st.isempty())
            {
                std::cout << "Stack already empty\n";
            }
            else
            {
                st.pop(po);
                subtotal += po.payment;
                std::cout << "Client " << po.fullname << " was deleted\n";
                std::cout << "Total customer payment : " << subtotal << '\n';
            }
            break;
        default :
            std::cout << "Please enter A, P, Q\n";
            continue;
            break;
        }
        std::cout << "Type A to add the client,\n";
        std::cout << "P to delete the client, and Q to exit.\n";
    }
    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Type A to add the client,
P to delete the client, and Q to exit.
A
Enter customer name: Mike Pence
Enter customer payment: 200
Type A to add the client,
P to delete the client, and Q to exit.
A
Enter customer name: Peter Smith
Enter customer payment: 300
Type A to add the client,
P to delete the client, and Q to exit.
A
Enter customer name: Hello World
Enter customer payment: 500
Type A to add the client,
P to delete the client, and Q to exit.
P
Client Hello World was deleted
Total customer payment : 500
Type A to add the client,
P to delete the client, and Q to exit.
P
Client Peter Smith was deleted
Total customer payment : 800
Type A to add the client,
P to delete the client, and Q to exit.
A
Enter customer name: aaaaa
Enter customer payment: 123
Type A to add the client,
P to delete the client, and Q to exit.
P
Client aaaaa was deleted
Total customer payment : 923
Type A to add the client,
P to delete the client, and Q to exit.
P
Client Mike Pence was deleted
Total customer payment : 1123
Type A to add the client,
P to delete the client, and Q to exit.
Q
Done.

6・下面是一个类声明：
请提供成员函数的定义和测试这个类的程序。
move_class.h
#pragma once
#ifndef MOVE_CLASS_H_
#define MOVE_CLASS_H_


class Move
{
private:
    mutable double x;
    mutable double y;
public:
    Move() {};
    ~Move() {};
    Move(double a = 0, double b = 0);
    void show_move() const;

    Move add(const Move &m) const;
    void reset(double a = 0, double b = 0);
};

#endif

move_class.cpp
#include <iostream>
#include "move_class.h"

Move::Move(double a, double b)
{
    x = a;
    y = b;
}
void Move::show_move() const
{
    std::cout << "X = " << x << std::endl;
    std::cout << "Y = " << y << std::endl;
}

Move Move::add(const Move &m) const
{
    x += m.x;
    y += m.y;
    return *this;
}

void Move::reset(double a, double b)
{
    x = a;
    y = b;
}

ch10_p06.cpp
#include <iostream>
#include "move_class.h"

int main()
{
    Move test_1(5, 10);
    test_1.show_move();

    test_1.add(test_1);
    test_1.show_move();

    test_1.reset();
    test_1.show_move();

    test_1.reset(10.0, 20.0);
    test_1.show_move();

    Move test_2(25.0, 25.0);
    test_2.show_move();

    test_2.add(test_1);
    test_2.show_move();

    return 0;
}
显示结果如下

X = 5
Y = 10
X = 10
Y = 20
X = 0
Y = 0
X = 10
Y = 20
X = 25
Y = 25
X = 35
Y = 45

7.Betelgeusean plorg有这些特征
数据：plorg的名称不超过19个字符；
plorg有满意指数（CI），这是一个整数。
操作：
新的plorg：将有名称，其CI值为50
plorg的CI可以修改；
plorg可以报告其名称和CI；
plorg的默认名称为"Plorga"。
请编写一个Plorg类声明（包括数据成员和成员函数原型）来表示plorg，并编写成员函数的函数定义。
然后编写一个小程序，以演示Plorg类的所有特性。
plorg_class.h
#pragma once
#ifndef PLORG_CLASS_H_
#define PLORG_CLASS_H_


class Plorg
{
private:
    static const int SIZE = 32;
    char name_plorg[SIZE];
    int ci;
public:
    Plorg(const char *name = "Plorga", int index = 50);
    void change_ci(char action, int index);
    void show_data() const;
};

#endif

plorg_class.cpp
#include <iostream>
#include <cstring>
#include "plorg_class.h"


Plorg::Plorg(const char *name, int index)
{
    strcpy(name_plorg, name);
    ci = index;
}

void Plorg::change_ci(char action, int index)
{
    switch (action)
    {
    case '+':
        ci += index;
        break;
    case '-':
        ci -= index;
        break;
    default:
        std::cout << "You can only use \"+\" or \"-\"" << std::endl;
        break;
    }
}

void Plorg::show_data() const
{
    std::cout << "Plorg name: " << name_plorg << std::endl;
    std::cout << "CI (contentment index): " << ci << std::endl;
}

ch10_p07.cpp
#include <iostream>
#include "plorg_class.h"


int main()
{
    Plorg Girl;
    Girl.show_data();

    Plorg Man ("Hann", 300);
    Man.show_data();

    Man.change_ci('-', 125);
    Man.show_data();

    Man.change_ci('+', 200);
    Man.show_data();

    Man.change_ci('|', 200);
    Man.show_data();

    return 0;
}
显示结果如下
Plorg name: Plorga
CI (contentment index): 50
Plorg name: Hann
CI (contentment index): 300
Plorg name: Hann
CI (contentment index): 175
Plorg name: Hann
CI (contentment index): 375
You can only use "+" or "-"
Plorg name: Hann
CI (contentment index): 375

8.可以将简单列表描述成下面这样：
可存储0或多个某种类型的列表；
可创建空列表
可在列表中添加数据项；
可确定列表是否为空；
可确定列表是否为满；
可访问列表中的每一个数据项，并对它执行某种操作。
可以看到，这个列表确实很简单，例如，它不允许插入或删除数据项。
请设计一个List类来表示这种抽象类型。您应提供头文件list.h和实现文件list.cpp，
前者包含类定义后者包含类方法的实现。您还应创建一个简短的程序来使用这个类。
该列表的规范很简单，这主要旨在简化这个编程练习。可以选择使用数组或链表来实现该列表，
但公有接口不应依赖于所做的选择。也就是说，公有接口不应有数组索引、节点指针等。
应使用通用概念来表达创建列表、在列表中添加数据项等操作。
对于访问数据项以及执行操作，通常应使用将函数指针作为参数的函数来处理：
void visit (void (*pf) (Item&) );
其中，pf指向一个将Item引用作为参数的函数（不是成员函数），Item是列表中数据项的类型。
visit函数将该函数用于列表中的每个数据项。
list.h
#pragma once
#ifndef LIST_H_
#define LIST_H_
#include <string>


static const int MAX = 5;

class List
{
private:
    std::string items[MAX];
    int top;
public:
    List();
    ~List();
    bool isempty() const;
    bool isfull() const;
    bool add_element(const std::string &item);
    void visit_element(void (*pf)(std::string &));
    void show_list();
    void reset_list();
};

#endif

list.cpp
#include <iostream>
#include "list.h"

List::List()
{
    for (int i = 0; i < MAX; i++)
    {
        items[i] = "";
    }
    top = 0;
}

List::~List()
{
    std::cout << "Working with the list is complete" << std::endl;
}

bool List::isempty() const
{
    if (top == 0)
    {
        std::cout << "The list is empty" << std::endl;
    }
    return top == 0;
}

bool List::isfull() const
{
    if (top == MAX)
    {
        std::cout << "The list is full" << std::endl;
    }
    return top == MAX;
}

bool List::add_element(const std::string &item)
{
    if (top < MAX)
    {
        items[top++] = item;
        return true;
    }
    else
    {
        return false;
    }
}

void List::visit_element(void(*pf)(std::string &))
{
    for (int i = 0; i < top; ++i)
    {
        (*pf)(items[i]);
    }
}
void List::show_list()
{
    for (int i = 0; i < top; i++)
    {
        std::cout << "Value " << i + 1 << " : " << items[i] << std::endl;
    }
}

void List::reset_list()
{
    top = 0;
}

ch10_p08.cpp
#include <iostream>
#include <cstring>
#include "list.h"


void some_func1(std::string &str);
void some_func2(std::string &str);

int main()
{
    List Game;

    std::string games[MAX] =
    {
        "Dota 2",
        "CS:GO",
        "PRAY",
        "ArcheAge",
        "Loong online"
    };


    for (int i = 0; i < MAX; i++)
    {
        Game.add_element(games[i]);
    }


    Game.show_list();
    std::cout << '\n';
    Game.visit_element(some_func1);
    Game.show_list();
    std::cout << '\n';

    Game.visit_element(some_func2);
    Game.show_list();

    return 0;
}

void some_func1(std::string &str)
{
    int size = str.size();
    for (int i = 0; i < size; ++i)
    {
        str[i] = toupper(str[i]);
    }
}

void some_func2(std::string &str)
{
    int size = str.size();
    for (int i = 0; i < size; ++i)
    {
        str[i] = tolower(str[i]);
    }
}
显示结果如下
Value 1 : Dota 2
Value 2 : CS:GO
Value 3 : PRAY
Value 4 : ArcheAge
Value 5 : Loong online

Value 1 : DOTA 2
Value 2 : CS:GO
Value 3 : PRAY
Value 4 : ARCHEAGE
Value 5 : LOONG ONLINE

Value 1 : dota 2
Value 2 : cs:go
Value 3 : pray
Value 4 : archeage
Value 5 : loong online
Working with the list is complete

第11章 使用类
11.1 运算符重载
11.2 计算时间：一个运算符重载示例.
11.2.1 添加加法运算符
11.2.2 重载限制
11.2.3 其他重载运算符
11.3 友元
11.3.1 创建友元
11.3.2 常用的友元：重载<<运算符
11.4 重载运算符：作为成员函数还是非成员函数
11.5 再谈重载：一个矢量类
11.5.1 使用状态成员
11.5.2 为Vector类重载算术运算符
11.5.3 对实现的说明
11.5.4 使用Vector类来模拟随机漫步
11.6类的自动转换和强制类型转换
11.6.1 转换函数
11.6.2 转换函数和友元函数
11.7 总结
11.8 复习题
11.9 编程练习
本章内容包括：
运算符重载。
友元函数
重载<<运算符，以便用于输出。
状态成员。
使用rand生成随机值。
类的自动转换和强制类型转换。
类转换函数。
11.1 运算符重载
C++根据操作数的数目和类型来决定采用哪种操作。
要重载运算符，需使用被称为运算符函数的特殊函数形式。运算符函数的格式如下：
operator op (argument-list)
例如，operator + ()重载+运算符，operator * ()重载*运算符。
op必须是有效的C++运算符，不能虚构一个新的符号。
operator[] () 函数将重载[]运算符，因为[]是数组索引运算符。
例如，假设有一个Salesperson类，并为它定义了一个operator + ()成员函数，以重载+运算符，
以便能够将两个Saleperson对象的销售额相加，则如果district2、sid和sara都是Salesperson类对象，便可以编写这样的等式：
district2 = sid + sara;
编译器发现，操作数是Salesperson类对象，因此使用相应的运算符函数替换上述运算符：
district2 = sid.operator+(sara);
程序清单11.1 mytime0.h
#pragma once
#ifndef MYTIME0_H_
#define MYTIME0_H_

class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    Time Sum(const Time &t) const;
    void Show() const;
};

#endif

程序清单11.2 mytime0.cpp
#include <iostream>
#include "mytime0.h"


Time::Time()
{
    hours = minutes = 0;
}

Time::Time(int h, int m)
{
    hours = h;
    minutes = m;
}

void Time::AddMin(int m)
{
    minutes += m;
    hours += minutes / 60;
    minutes %= 60;
}
void Time::AddHr(int h)
{
    hours += h;
}

void Time::Reset(int h, int m)
{
    hours = h;
    minutes = m;
}
Time Time::Sum(const Time &t) const
{
    Time sum;
    sum.minutes = minutes + t.minutes;
    sum.hours = hours + t.hours + sum.minutes / 60;
    sum.minutes %= 60;
    return sum;
}

void Time::Show() const
{
    std::cout << hours << " hours, " << minutes << " minutes";
}

程序清单11.3 usetime0.cpp
#include <iostream>
#include "mytime0.h"

int main()
{
	using std::cout;
	using std::endl;
	
	Time planning;
	Time coding(2, 40);
	Time fixing(5, 55);
	Time total;
	cout << "planning time = ";
	planning.Show();
	cout << endl;
	cout << "coding time = ";
	coding.Show();
	cout << endl;
	cout << "fixing time = ";
	fixing.Show();
	cout << endl;
	total = coding.Sum(fixing);
	cout << "coding.Sum (fixing) = ";
	total.Show();
	cout << endl;

	return 0;
}
显示结果如下
planning time = 0 hours, 0 minutes
coding time = 2 hours, 40 minutes
fixing time = 5 hours, 55 minutes
coding.Sum (fixing) = 8 hours, 35 minutes

程序清单11.4 mytime1.h
#pragma once
#ifndef MYTIME1_H_
#define MYTIME1_H_

class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    Time operator+(const Time &t) const;
    void Show() const;
};

#endif

程序清单11.5 mytime1.cpp
#include <iostream>
#include "mytime1.h"

Time::Time()
{
    hours = minutes = 0;
}

Time::Time(int h, int m)
{
    hours = h;
    minutes = m;
}

void Time::AddMin(int m)
{
    minutes += m;
    hours += minutes / 60;
    minutes %= 60;
}

void Time::AddHr(int h)
{
    hours += h;
}

void Time::Reset(int h, int m)
{
    hours = h;
    minutes = m;
}

Time Time::operator+(const Time &t) const
{
    Time sum;
    sum.minutes = minutes + t.minutes;
    sum.hours = hours + t.hours + sum.minutes / 60;
    sum.minutes %= 60;
    return sum;
}

void Time::Show() const
{
    std::cout << hours << " hours, " << minutes << " minutes";
}

程序清单11.6 usetime1.cpp
#include <iostream>
#include "mytime1.h"

int main()
{
    using std::cout;
    using std::endl;

    Time planning;
    Time coding(2, 40);
    Time fixing(5, 55);
    Time total;
    cout << "planning time = ";
    planning.Show();
    cout << endl;
    cout << "coding time = ";
    coding.Show();
    cout << endl;
    cout << "fixing time = ";
    fixing.Show();
    cout << endl;
    total = coding + fixing;
    cout << "coding + fixing = ";
    total.Show();
    cout << endl;
    Time morefixing(3, 28);
    cout << "more fixing time = ";
    morefixing.Show();
    cout << endl;
    total = morefixing.operator + (total);
    cout << "morefixing.operator+(total) = ";
    total.Show();
    cout << endl;

    return 0;
}
显示结果如下
planning time = 0 hours, 0 minutes
coding time = 2 hours, 40 minutes
fixing time = 5 hours, 55 minutes
coding + fixing = 8 hours, 35 minutes
more fixing time = 3 hours, 28 minutes
morefixing.operator+(total) = 12 hours, 3 minutes

下面详细介绍C++对用户定义的运算符重载的限制。
重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符。
因此，不能将减法运算符重载为计算两个double值的和，而不是它们的差。
虽然这种限制将对创造性有所影响，但可以确保程序正常运行。
使用运算符时不能违反运算符原来的句法规则。同样，不能修改运算符的优先级。
因此，如果将加号运算符重载成将两个类相加，则新的运算符与原来的加号具有相同的优先级。
不能创建新运算符。
不能重载下面的运算符
sizeof 运算符。
.* 成员指针运算符
->* 成员指针运算符
:: 作用域解析运算符，
? : 条件运算符。
typeid ―个RTTI运算符。
const_cast 强制类型转换运算符。
dynamic_cast 强制类型转换运算符。
reinterpret_cast 强制类型转换运算符。
static_cast 强制类型转换运算符。

成员指针是什么？是指向一个类中某个成员的指针。注意是直接指向，不是通过某个对象指向的。
如果要定义一个成员指针，用这样的语法：
class cl
{
public:
    int mint;
    double get_mint(float adder)
    {
        return mint + adder;
    }
};
int cl::*fmint = &cl::mint;
double (cl::*fget)(float) = &cl::get_mint;
怎样访问成员指针所指向的内容呢？不能用*（解引用运算符）得到，而应该通过一个对象访问。格式如下：
cl c;
c.*fmint;
cl *p;
(p->*fget)(1.0f);
注意 .* 和 ->* ，它们就是成员指针运算符。再注意访问函数时加的括号，它们是必须的，因为 .* 和 ->* 的优先级低于 () 。

表11.1中的大多数运算符都可以通过成员或非成员函数进行重载，但下面的运算符只能通过成员函数进行重载。
= 赋值运算符。
() 函数调用运算符。
[] 下标运算符。
-> 通过指针访问类成员的运算符。

表11.1
+ - * / % ^ & | ~ ! && || < > == <= >= !=
<< >> ++ -- , new delete new [] delete []
^= &= |= ~= += -= *= /= %= >>= <<=

程序清单11.7 mytime2.h
#pragma once
#ifndef MYTIME2_H_
#define MYTIME2_H_

class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    Time operator+(const Time &t) const;
    Time operator-(const Time &t) const;
    Time operator*(double n) const;
    void Show() const;
};

#endif

程序清单11.8 mytime2.cpp
#include <iostream>
#include "mytime2.h"

Time::Time()
{
    hours = minutes = 0;
}

Time::Time(int h, int m)
{
    hours = h;
    minutes = m;
}

void Time::AddMin(int m)
{
    minutes += m;
    hours += minutes / 60;
    minutes %= 60;
}

void Time::AddHr(int h)
{
    hours += h;
}

void Time::Reset(int h, int m)
{
    hours = h;
    minutes = m;
}

Time Time::operator+(const Time &t) const
{
    Time sum;
    sum.minutes = minutes + t.minutes;
    sum.hours = hours + t.hours + sum.minutes / 60;
    sum.minutes %= 60;
    return sum;
}

Time Time::operator-(const Time &t) const
{
    Time diff;
    int tot1, tot2;
    tot1 = t.minutes + 60 * t.hours;
    tot2 = minutes + 60 * hours;
    diff.minutes = (tot2 - tot1) % 60;
    diff.hours = (tot2 - tot1) / 60;
    return diff;
}

Time Time::operator*(double mult) const
{
    Time result;
    long totalminutes = hours * mult * 60 + minutes * mult;
    result.hours = totalminutes / 60;
    result.minutes = totalminutes % 60;
    return result;
}

void Time::Show() const
{
    std::cout << hours << " hours, " << minutes << " minutes";
}

程序清单 11.9 usetime2.cpp
#include <iostream>
#include "mytime2.h"

int main()
{
    using std::cout;
    using std::endl;

    Time weeding(4, 35);
    Time waxing(2, 47);
    Time total;
    Time diff;
    Time adjusted;
    cout << "weeding time = ";
    weeding.Show();
    cout << endl;
    cout << "waxing time = ";
    waxing.Show();
    cout << endl;
    cout << "total work time = ";
    total = weeding + waxing;
    total.Show();
    cout << endl;
    diff = weeding - waxing;
    cout << "weeding time - waxing time = ";
    diff.Show();
    cout << endl;
    adjusted = total * 1.5;
    cout << "adjusted work time = ";
    adjusted.Show();
    cout << endl;

    return 0;
}
显示结果如下
weeding time = 4 hours, 35 minutes
waxing time = 2 hours, 47 minutes
total work time = 7 hours, 22 minutes
weeding time - waxing time = 1 hours, 48 minutes
adjusted work time = 11 hours, 3 minutes

11.3友元
C++控制对类对象私有部分的访问。通常，公有类方法提供唯一的访问途径。
C++提供了另外一种形式的访问权限：友元。友元有3种：友元函数；友元类；友元成员函数。
通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。
下面介绍友元函数，其他两种友元将在第15章介绍。
在为类重载二元运算符时（带两个参数的运算符）常常需要友元。
在前面的Time类示例中，重载的乘法运算符与其他两种重载运算符的差别在于，它使用了两种不同的类型。
也就是说，加法和减法运算符都结合两个Time值，而乘法运算符将一个Time值与一个double值结合在一起。
A=B*2.75;
将被转换为下面的成员函数调用：
A = B.operator*(2.75);
但下面的语句又如何呢？
A=2.75*B;
左侧的操作数应是调用对象，但2.75不是对象。因此，编译器不能使用成员函数调用来替换该表达式。
解决这个难题的一种方式是非成员函数（记住，大多数运算符都可以通过成员或非成员函数来重载）。
非成员函数不是由对象调用的，它使用的所有值（包括对象）都是显式参数。这样，编译器能够将下面的表达式：
A= 2.75*B;
与下面的非成员函数调用匹配：
A = operator*(2.75, B);
该函数的原型如下：
Time operator*(double m, const Time &t);
对于非成员重载运算符函数来说，运算符表达式左边的操作数对应于运算符函数的第一个参数，
运算符表达式右边的操作数对应于运算符函数的第二个参数。
非成员函数不能直接访问类的私有数据，至少常规非成员函数不能访问。
然而，有一类特殊的非成员函数可以访问类的私有成员，它们被称为友元函数。
11.3.1 创建友元
创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend：
friend Time operator*(double m, const Time &t);
该原型意味着下面两点：
虽然operator*()函数是在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用；
虽然operator*()函数不是成员函数，但它与成员函数的访问权限相同。
第二步是编写函数定义。因为它不是成员函数，所以不要使用Time::限定符。
另外，不要在定义中使用关键字friend，定义应该如下
Time operator*(double mult, const Time &t)
{
    Time result;
    long totalminutes = t.hours * mult * 60 + t.minutes * mult;
    result.hours = totalminutes/60;
    result.minutes = totalminutes%60;
    return result;
}
有了上述声明和定义后，下面的语句
A = 2.75 * B;
将转换为如下语句，从而调用刚才定义的非成员友元函数
A = operator*(2.75, B);
总之，类的友元函数是非成员函数，其访问权限与成员函数相同。
实际上，按下面的方式对定义进行修改（交换乘法操作数的顺序），可以将这个友元函数编写为非友元函数：
Time operator*(double m, const Time & t)
{
    return t * m;
}
这个版本将Time对象t作为一个整体使用，让成员函数来处理私有值，因此不必是友元。
11.3.2 常用的友元：重载<<运算符
一个很有用的类特性是，可以对<<运算符进行重载，使之能与cout一起来显示对象的内容。
与前面介绍的示例相比，这种重载要复杂些，因此我们分两步（而不是一步）来完成。
假设trip是一个Time对象。为显示Time的值，前面使用的是Show()。然而，如果可以像下面这样操作将更好：
cout << trip;
之所以可以这样做，是因为<<是可被重载的C++运算符之一。
最初<<运算符是C和C++的位运算符，将值中的位左移（参见附录E）。
ostream类对该运算符进行了重载，将其转换为一个输出工具。
cout是一个ostream对象，它能够识别所有的C++基本类型。
这是因为对于每种基本类型，ostream类声明中都包含了相应的重载的operator<<()定义。
也就是说，一个定义使用int参数，一个定义使用double参数，等等。
因此，要使cout能够识别Time对象，一种方法是将一个新的函数定义添加到ostream类声明中。
但修改iostream文件是个危险的主意，这样做会在标准接口上浪费时间。
相反，可以通过Time类声明来让Time类知道如何使用cout。
1.<<的第一种重载版本
要使Time类知道使用cout，必须使用友元函数。这是什么原因呢？
因为下面这样的语句使用两个对象，其中第一个是ostream类对象（cout）：
cout << trip;
如果使用一个Time成员函数来重载<<，Time对象将是第一个操作数，就像使用成员函数重载*运算符那样。
这意味着必须这样使用<<：
trip << cout;
这样会令人迷惑。但通过使用友元函数，可以像下面这样重载运算符：
void operatore<<(ostream & os, const Time &t)
{
    os << t.hours << " hours, " << t.minutes << " minutes";
}
这样可以使用下面的语句：
cout << trip;
友元还是非友元？
新的Time类声明使operator<<()函数成为Time类的一个友元函数。
因为operator<<()直接访问Time对象的私有成员，所以它必须是Time类的友元。
但由于它并不直接访问ostream对象的私有成员，所以并不一定必须是ostream类的友元。
注意，新的operator<<()定义使用ostream引用os作为它的第一个参数。
通常情况下，os引用cout对象，如表达式cout <<trip所示。但也可以将这个运算符用于其他ostream对象，
在这种情况下，os将引用相应的对象。
2.<<的第二种重载版本
前面介绍的实现存在一个问题。像下面这样的语句可以正常工作
cout << trip;
但下面的语句不可行
cout << "Trip time: " << trip << " (Tuesday)\n";
关于cout操作的一点知识，请看下面的语句：
int x = 5;
int y=8;
cout << x << y;
C++从左至右读取输出语句，意味着它等同于：
(cout << x) << y;
ostream类将operators<<()函数实现为返回一个指向ostream对象的引用。
具体地说，它返回一个指向调用对象（这里是cout）的引用。
因此，表达式(cout << x)本身就是ostream对象cout，从而可以位于<<运算符的左侧。
可以对友元函数采用相同的方法。只要修改operator<<()函数，让它返回ostream对象的引用即可；
ostream & operator<<(ostream & os, const Time & t)
{
    os << t.hours << " hours, " << t.minutes << " minutes";
    return os;
}
只有在类声明的函数原型中才能使用friend关键字。除非函数定义也是原型，否则不能在函数定义中使用该关键字。
程序清单11.10 mytime3.h
#pragma once
#ifndef MYTIME3_H_
#define MYTIME3_H_

#include <iostream>

class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    Time operator+(const Time &t) const;
    Time operator-(const Time &t) const;
    Time operator*(double n) const;
    friend Time operator*(double m, const Time &t)
    {
        return t * m;
    }
    friend std::ostream &operator<<(std::ostream &os, const Time &t);
};

#endif

程序清单11.11 mytime3.cpp
#include <iostream>
#include "mytime3.h"

Time::Time()
{
    hours = minutes = 0;
}

Time::Time(int h, int m)
{
    hours = h;
    minutes = m;
}

void Time::AddMin(int m)
{
    minutes += m;
    hours += minutes / 60;
    minutes %= 60;
}

void Time::AddHr(int h)
{
    hours += h;
}

void Time::Reset(int h, int m)
{
    hours = h;
    minutes = m;
}

Time Time::operator+(const Time &t) const
{
    Time sum;
    sum.minutes = minutes + t.minutes;
    sum.hours = hours + t.hours + sum.minutes / 60;
    sum.minutes %= 60;
    return sum;
}

Time Time::operator-(const Time &t) const
{
    Time diff;
    int tot1, tot2;
    tot1 = t.minutes + 60 * t.hours;
    tot2 = minutes + 60 * hours;
    diff.minutes = (tot2 - tot1) % 60;
    diff.hours = (tot2 - tot1) / 60;
    return diff;
}

Time Time::operator*(double mult) const
{
    Time result;
    long totalminutes = hours * mult * 60 + minutes * mult;
    result.hours = totalminutes / 60;
    result.minutes = totalminutes % 60;
    return result;
}

std::ostream &operator<<(std::ostream &os, const Time &t)
{
    os << t.hours << " hours, " << t.minutes << " minutes";
    return os;
}

程序清单11.12 usetime3.cpp
#include <iostream>
#include "mytime3.h"

int main()
{
    using std::cout;
    using std::endl;

    Time aida(3, 35);
    Time tosca(2, 48);
    Time temp;
    cout << "Aida and Tosca:\n";
    cout << aida << "; " << tosca << endl;
    temp = aida + tosca;
    cout << "Aida + Tosca: " << temp << endl;
    temp = aida * 1.17;
    cout << "Aida * 1.17: " << temp << endl;
    cout << "10.0 * Tosca: " << 10.0 * tosca << endl;

    return 0;
}
显示结果如下
Aida and Tosca:
3 hours, 35 minutes; 2 hours, 48 minutes
Aida + Tosca: 6 hours, 23 minutes
Aida * 1.17: 4 hours, 11 minutes
10.0 * Tosca: 28 hours, 0 minutes

11.4 重载运算特：作为成员函数还是非成员函数
对于很多运算符来说，可以选择使用成员函数或非成员函数来实现运算符重载。
一般来说，非成员函数应是友元函数，这样它才能直接访问类的私有数据。
例如，Time类的加法运算符在Time类声明中的原型如下：
Time operator+(const Time &t) const;
也可以使用下面的原型：
friend Time operator+(const Time & t1, const Time & t2);
加法运算符需要两个操作数。对于成员函数版本来说，一个操作数通过this指针隐式地传递，
另一个操作数作为函数参数显式地传递；对于友元版本来说，两个操作数都作为参数来传递。
这两个原型都与表达式T2 + T3匹配，其中T2和T3都是Time类型对象。也就是说，编译器将下面的语句：
T1 = T2+T3;
转换为下面两个的任何一个：
T1 = T2.operator+(T3);
T1 = operator+(T2, T3);
记住，在定义运算符时，必须选择其中的一种格式，而不能同时选择这两种格式。
那么哪种格式最好呢？对于某些运算符来说（如前所述），成员函数是唯一合法的选择。
在其他情况下，这两种格式没有太大的区别。有时，使用非成员函数版本可能更好（尤其是为类定义类型转换时）。
11.5再谈重载：一个矢量类
程序清单11.13 vect.h
#pragma once
#ifndef VECT_H_
#define VECT_H_
#include <cmath>
#include <iostream>

namespace VECTOR
{
    class Vector
    {
    public:
        enum Mode { RECT, POL };
    private:
        double x;
        double y;
        double mag;
        double ang;
        Mode mode;
        void set_mag();
        void set_ang();
        void set_x();
        void set_y();
    public:
        Vector();
        Vector(double n1, double n2, Mode form = RECT);
        void reset(double n1, double n2, Mode form = RECT);
        ~Vector();
        double xval() const
        {
            return x;
        }
        double yval() const
        {
            return y;
        }
        double magval() const
        {
            return mag;
        }
        double angval() const
        {
            return ang;
        }
        void polar_mode();
        void rect_mode();
        Vector operator+(const Vector &b) const;
        Vector operator-(const Vector &b) const;
        Vector operator-() const;
        Vector operator*(double n) const;
        friend Vector operator*(double n, const Vector &a);
        friend std::ostream &operator<<(std::ostream &os, const Vector &v);
    };
}

#endif

程序清单11.14 vect.cpp
#include <iostream>
#include "vect.h"

using std::sqrt;
using std::sin;
using std::cos;
using std::atan;
using std::atan2;
using std::cout;

namespace VECTOR
{
    const double Rad_to_deg = 45.0 / atan(1.0);

    void Vector::set_mag()
    {
        mag = sqrt(x * x + y * y);
    }

    void Vector::set_ang()
    {
        if (x == 0.0 && y == 0.0)
        {
            ang = 0.0;
        }
        else
        {
            ang = atan2(y, x);
        }
    }
    void Vector::set_x()
    {
        x = mag * cos(ang);
    }
    void Vector::set_y()
    {
        y = mag * sin(ang);
    }
    Vector::Vector()
    {
        x = y = mag = ang = 0.0;
        mode = RECT;
    }
    Vector::Vector(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
        {
            x = n1;
            y = n2;
            set_mag();
            set_ang();
        }
        else if (form == POL)
        {
            mag = n1;
            ang = n2 / Rad_to_deg;
            set_x();
            set_y();
        }
        else
        {
            cout << "Incorrect argument to Vector (), ";
            cout << "vector set to 0\n";
            x = y = mag = ang = 0.0;
            mode = RECT;
        }

    }
    void Vector::reset(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
        {
            x = n1;
            y = n2;
            set_mag();
            set_ang();
        }
        else if (form == POL)
        {
            mag = n1;
            ang = n2 / Rad_to_deg;
            set_x();
            set_y();
        }
        else
        {
            cout << "Incorrect argument to Vector (), ";
            cout << "vector set to 0\n";
            x = y = mag = ang = 0.0;
            mode = RECT;
        }
    }
    Vector::~Vector()
    {

    }
    void Vector::polar_mode()
    {
        mode = POL;
    }
    void Vector::rect_mode()
    {
        mode = RECT;
    }
    Vector Vector::operator+(const Vector &b) const
    {
        return Vector(x + b.x, y + b.y);
    }
    Vector Vector::operator-(const Vector &b) const
    {
        return Vector(x - b.x, y - b.y);
    }
    Vector Vector::operator-() const
    {
        return Vector(-x, -y);
    }
    Vector Vector::operator*(double n) const
    {
        return Vector(n * x, n * y);
    }
    Vector operator*(double n, const Vector &a)
    {
        return a * n;
    }
    std::ostream &operator<<(std::ostream &os, const Vector &v)
    {
        if (v.mode == Vector::RECT)
        {
            os << " (x,y) = (" << v.x << ", " << v.y << ")";
        }
        else if (v.mode == Vector::POL)
        {
            os << " (m,a) = (" << v.mag << ", " << v.ang *Rad_to_deg << " ) ";
        }
        else
        {
            os << "Vector object mode is invalid";
        }
        return os;
    }
}

程序清单11.15 randwalk.cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
#include "vect.h"

int main()
{
    using namespace std;
    using VECTOR::Vector;
    srand(time(nullptr));
    double direction;
    Vector step;
    Vector result(0.0, 0.0);
    unsigned long steps = 0;
    double target;
    double dstep;
    cout << "Enter target distance (q to quit) : ";
    while (cin >> target)
    {
        cout << "Enter step length: ";
        if (!(cin >> dstep))
        {
            break;
        }
        while (result.magval() < target)
        {
            direction = rand() % 360;
            step.reset(dstep, direction, Vector::POL);
            result = result + step;
            steps++;
        }
        cout << "After " << steps << " steps, the subject has the following location:\n";
        cout << result << endl;
        result.polar_mode();
        cout << " or\n" << result << endl;
        cout << "Average outward distance per step = " << result.magval() / steps << endl;
        steps = 0;
        result.reset(0.0, 0.0);
        cout << "Enter target distance (q to quit): ";
    }
    cout << "Done.\n";
    cin.clear();
    while (cin.get() != '\n')
    {
        continue;
    }

    return 0;
}
显示结果如下
Enter target distance (q to quit) : 50
Enter step length: 2
After 923 steps, the subject has the following location:
 (x,y) = (51.3223, -2.86578)
 or
 (m,a) = (51.4022, -3.19602 )
Average outward distance per step = 0.0556904
Enter target distance (q to quit): 50
Enter step length: 2
After 615 steps, the subject has the following location:
 (x,y) = (49.9669, -5.38278)
 or
 (m,a) = (50.256, -6.14859 )
Average outward distance per step = 0.081717
Enter target distance (q to quit): 50
Enter step length: 1
After 609 steps, the subject has the following location:
 (x,y) = (46.6646, 19.3847)
 or
 (m,a) = (50.5307, 22.5583 )
Average outward distance per step = 0.0829732
Enter target distance (q to quit): q
Done.

11.6类的自动转换和强制类型转换
将一个标准类型变量的值赋给另一种标准类型的变量时，如果这两种类型兼容，则C++自动将这个值转换为接收变量的类型。
在无法自动转换时，可以使用强制类型转换。
程序清单11.16 stonewt.h
#pragma once
#ifndef STONEWT_H_
#define STONEWT_H_

class Stonewt
{
private:
    enum { Lbs_per_stn = 14 };
    int stone;
    double pds_left;
    double pounds;
public:
    Stonewt(double lbs);
    Stonewt(int stn, double lbs);
    Stonewt();
    ~Stonewt();
    void show_lbs() const;
    void show_stn() const;
};

#endif

程序清单11.17 stonewt.cpp
#include <iostream>
#include "stonewt.h"

using std::cout;

Stonewt::Stonewt(double lbs)
{
    stone = int(lbs) / Lbs_per_stn;
    pds_left = int(lbs) % Lbs_per_stn + lbs - int(lbs);
    pounds = lbs;
}

Stonewt::Stonewt(int stn, double lbs)
{
    stone = stn;
    pds_left = lbs;
    pounds = stn * Lbs_per_stn + lbs;
}

Stonewt::Stonewt()
{
    stone = pounds = pds_left = 0;
}

Stonewt::~Stonewt()
{

}
void Stonewt::show_stn() const
{
    cout << stone << " stone, " << pds_left << " pounds\n";
}
void Stonewt::show_lbs() const
{
    cout << pounds << " pounds\n";
}

程序清单11.18 stone.cpp
#include <iostream>
#include "stonewt.h"

using std::cout;


void display(const Stonewt &st, int n);

int main()
{
    Stonewt incognito = 275;
    Stonewt wolfe(285.7);
    Stonewt taft(21, 8);
    cout << "The celebrity weighed ";
    incognito.show_stn();
    cout << "The detective weighed ";
    wolfe.show_stn();
    cout << "The President weighed ";
    taft.show_lbs();
    incognito = 276.8;
    taft = 325;
    cout << "After dinner, the celebrity weighed ";
    incognito.show_stn();
    cout << "After dinner, the President weighed ";
    taft.show_lbs();
    display(taft, 2);
    cout << "The wrestler weighed even more.\n";
    display(422, 2);
    cout << "No stone left unearned\n";

    return 0;
}

void display(const Stonewt &st, int n)
{
    for (int i = 0; i < n; i++)
    {
        cout << "Wow! ";
        st.show_stn();
    }
}
显示结果如下
The celebrity weighed 19 stone, 9 pounds
The detective weighed 20 stone, 5.7 pounds
The President weighed 302 pounds
After dinner, the celebrity weighed 19 stone, 10.8 pounds
After dinner, the President weighed 325 pounds
Wow! 23 stone, 3 pounds
Wow! 23 stone, 3 pounds
The wrestler weighed even more.
Wow! 30 stone, 2 pounds
Wow! 30 stone, 2 pounds
No stone left unearned

程序清单11.18将数字转换为Stonewt对象。可以做相反的转换吗？也就是说，是否可以将Stonewt对象转换为double值，就像如下所示的那样？
Stonewt wolfe(285.7);
double host = wolfe;
可以这样做，但不是使用构造函数。构造函数只用于从某种类型到类类型的转换。
要进行相反的转换，必须使用特殊的C++运算符函数――转换函数。
转换函数是用户定义的强制类型转换，可以像使用强制类型转换那样使用它们。
例如，如果定义了从Stonewt到double的转换函数，就可以使用下面的转换：
Stonewt wolfe (285.7);
double host = double (wolfe);
double thinker = (double) wolfe;
也可以让编译器来决定如何做：
Stonewt wells (20, 3);
double star = wells;
编译器发现，右侧是Stonewt类型，而左侧是double类型，因此它将查看程序员是否定义了与此匹配的转换函数。
（如果没有找到这样的定义，编译器将生成错误消息，指出无法将Stonewt赋给double。）
那么，如何创建转换函数呢？要转换为typeName类型，需要使用这种形式的转换函数：
operator typeName();
请注意以下几点：
转换函数必须是类方法；
转换函数不能指定返回类型；
转换函数不能有参数。
例如，转换为double类型的函数的原型如下
operator double()
typeName（这里为double）指出了要转换成的类型，因此不需要指定返回类型。
转换函数是类方法意味着：它需要通过类对象来调用，从而告知函数要转换的值。因此，函数不需要参数。
要添加将Stonewt对象转换为int类型和double类型的函数，需要将下面的原型添加到类声明中：
operator int ();
operator double ();
程序清单11.19 stonewt1.h
#pragma once
#ifndef STONEWT1_H_
#define STONEWT1_H_

class Stonewt
{
private:
    enum { Lbs_per_stn = 14 };
    int stone;
    double pds_left;
    double pounds;
public:
    Stonewt(double lbs);
    Stonewt(int stn, double lbs);
    Stonewt();
    ~Stonewt();
    void show_lbs() const;
    void show_stn() const;

    operator int() const;
    operator double() const;
};

#endif

程序清单11.20 stonewt1.cpp
#include <iostream>
#include "stonewt1.h"

using std::cout;

Stonewt::Stonewt(double lbs)
{
    stone = int(lbs) / Lbs_per_stn;
    pds_left = int(lbs) % Lbs_per_stn + lbs - int(lbs);
    pounds = lbs;
}
Stonewt::Stonewt(int stn, double lbs)
{
    stone = stn;
    pds_left = lbs;
    pounds = stn * Lbs_per_stn + lbs;
}
Stonewt::Stonewt()
{
    stone = pounds = pds_left = 0;
}
Stonewt::~Stonewt()
{

}
void Stonewt::show_stn() const
{
    cout << stone << " stone, " << pds_left << " pounds\n";
}
void Stonewt::show_lbs() const
{
    cout << pounds << " pounds\n";
}
Stonewt::operator int() const
{
    return int(pounds + 0.5);
}

Stonewt::operator double() const
{
    return pounds;
}

程序清单11.21 stone1.cpp
#include <iostream>
#include "stonewt1.h"

int main()
{
    using std::cout;
    Stonewt poppins(9, 2.8);
    double p_wt = poppins;
    cout << "Convert to double => ";
    cout << "Poppins: " << p_wt << " pounds. \n";
    cout << "Convert to int => ";
    cout << "Poppins: " << int(poppins) << " pounds. \n";

    return 0;
}
显示结果如下
Convert to double => Poppins: 128.8 pounds.
Convert to int => Poppins: 129 pounds.

11.7 总结
一般来说，访问类的私有成员的唯一方法是使用类的公有方法。C++使用友元函数来避开这种限制。
要让函数成为友元，需要在类声明中声明该函数，并在声明前加上关键字friend。
C++允许自定义特殊的运算符函数，这种函数描述了特定的运算符与类之间的关系。
运算符函数可以是类成员函数，也可以是友元函数（有一些运算符函数只能是类成员函数）。
要调用运算符函数可以直接调用该函数，也可以以通常的句法使用被重载的运算符。
对于运算符op，其运算符函数的格式如下：
operator op (argument-list)
argument-list表示该运算符的操作数。
如果运算符函数是类成员函数，则第一个操作数是调用该函数的对象，它不在argument-list中。
定义运算符函数时，如果要使其第一个操作数不是类对象，
则必须使用友元函数，这样就可以将操作数按所需的顺序传递给函数了。
最常见的运算符重载任务之一是定义<<运算符，使之可与cout一起使用，来显示对象的内容。
要让ostream对象成为第一个操作数，需要将运算符函数定义为友元；
要使重新定义的运算符能与其自身拼接，需要将返回类型声明为ostream&。
然而，如果类包含这样的方法，它返回需要显示的数据成员的值，则可以直接使用这些方法。
C++允许指定在类和基本类型之间进行转换的方式。
首先，任何接受唯一一个参数的构造函数都可被用作转换函数，将与该参数类型相同的值转换为类，
如果将与该参数类型相同的值赋给对象，则C++将自动调用该构造函数。
例如，假设有一个String类，它包含一个将char*值作为其唯二参数的构造函数，
那么如果bean是String对象，则可以使用下面的语句：
bean = "pinto";
然而，如果在该构造函数的声明前加上了关键字explicit，则该构造函数将只能用于显式转换：
bean = String ("pinto");
要将类对象转换为其他类型，必须定义转换函数，指出如何进行这种转换。
转换函数必须是成员函数。将类对象转换为typeName类型的转换函数的原型如下：
operator typeName ()
注意，转换函数没有返回类型、没有参数，但必须返回转换后的值（虽然没有声明返回类型）。
11.8复习题
1.使用成员函数为Stonéwt类重载乘法运算符，该运算符将数据成员与double类型的值相乘。
stonewt1.h
#pragma once
#ifndef STONEWT1_H_
#define STONEWT1_H_

class Stonewt
{
private:
    enum { Lbs_per_stn = 14 };
    int stone;
    double pds_left;
    double pounds;
public:
    Stonewt(double lbs);
    Stonewt(int stn, double lbs);
    Stonewt();
    ~Stonewt();
    void show_lbs() const;
    void show_stn() const;
    Stonewt operator *(double mult) const;
    operator int() const;
    operator double() const;
};

#endif

Stonewt Stonewt::operator*(double mult) const
{
    return Stonewt (pounds * mult);
}

2.友元函数与成员函数之间的区别是什么？
成员函数是类定义的一部分，通过类的对象来调用，成员函数可以隐式访问调用对象的私有成员。
友元函数不是类定义的一部分，调用时要把类的对象作为参数，函数内部要使用成员运算符访问参数的私有成员。

3.非成员函数必须是友元才能访问类成员吗？
如果要访问类的私有成员，则必须是友元函数。如果只访问类的公有成员，则不必是友元函数。

4.使用友元函数为Stonewt类重载乘法运算符，该运算符将double值与Stone值相乘。
stonewt1.h
#pragma once
#ifndef STONEWT1_H_
#define STONEWT1_H_

class Stonewt
{
private:
    enum { Lbs_per_stn = 14 };
    int stone;
    double pds_left;
    double pounds;
public:
    Stonewt(double lbs);
    Stonewt(int stn, double lbs);
    Stonewt();
    ~Stonewt();
    void show_lbs() const;
    void show_stn() const;
    Stonewt operator *(double mult) const;
    friend Stonewt operator *(double mult, const Stonewt & s);
    operator int() const;
    operator double() const;
};

#endif

Stonewt Stonewt::operator*(double mult) const
{
    return Stonewt (pounds * mult);
}

Stonewt operator*(double mult, const Stonewt & s)
{
    return Stonewt (s.pounds * mult);
}

5.哪些运算符不能重载？
sizeof 运算符。
.* 成员指针运算符
->* 成员指针运算符
:: 作用域解析运算符，
? : 条件运算符。
typeid ―个RTTI运算符。
const_cast 强制类型转换运算符。
dynamic_cast 强制类型转换运算符。
reinterpret_cast 强制类型转换运算符。
static_cast 强制类型转换运算符。

6.在重载运算符=、()、[]和->时，有什么限制？
必须作为类的成员函数来实现重载

7.为Vector类定义一个转换函数，将Vector类转换为一个double类型的值，后者表示矢量的长度。
#pragma once
#ifndef VECT_H_
#define VECT_H_
#include <cmath>
#include <iostream>

namespace VECTOR
{
    class Vector
    {
    public:
        enum Mode { RECT, POL };
    private:
        double x;
        double y;
        double mag;
        double ang;
        Mode mode;
        void set_mag();
        void set_ang();
        void set_x();
        void set_y();
    public:
        Vector();
        Vector(double n1, double n2, Mode form = RECT);
        void reset(double n1, double n2, Mode form = RECT);
        ~Vector();
        double xval() const
        {
            return x;
        }
        double yval() const
        {
            return y;
        }
        double magval() const
        {
            return mag;
        }
        double angval() const
        {
            return ang;
        }
        void polar_mode();
        void rect_mode();
        Vector operator+(const Vector &b) const;
        Vector operator-(const Vector &b) const;
        Vector operator-() const;
        Vector operator*(double n) const;
        operator double() const {return mag;};
        friend Vector operator*(double n, const Vector &a);
        friend std::ostream &operator<<(std::ostream &os, const Vector &v);
    };
}

#endif

11.9编程练习
1.修改程序清单11.15，使之将一系列连续的随机漫步者位置写入到文件中。
对于每个位置，用步号进行标示。另外，让该程序将初始条件（目标距离和步长）以及结果小结写入到该文件中。
vect.h
#pragma once
#ifndef VECT_H_
#define VECT_H_
#include <cmath>
#include <iostream>

namespace VECTOR
{
    class Vector
    {
    public:
        enum Mode { RECT, POL };
    private:
        double x;
        double y;
        double mag;
        double ang;
        Mode mode;
        void set_mag();
        void set_ang();
        void set_x();
        void set_y();
    public:
        Vector();
        Vector(double n1, double n2, Mode form = RECT);
        void reset(double n1, double n2, Mode form = RECT);
        ~Vector();
        double xval() const
        {
            return x;
        }
        double yval() const
        {
            return y;
        }
        double magval() const
        {
            return mag;
        }
        double angval() const
        {
            return ang;
        }
        void polar_mode();
        void rect_mode();
        Vector operator+(const Vector &b) const;
        Vector operator-(const Vector &b) const;
        Vector operator-() const;
        Vector operator*(double n) const;
        friend Vector operator*(double n, const Vector &a);
        friend std::ostream &operator<<(std::ostream &os, const Vector &v);
    };
}

#endif

vect.cpp
#include <iostream>
#include "vect.h"

using std::sqrt;
using std::sin;
using std::cos;
using std::atan;
using std::atan2;
using std::cout;

namespace VECTOR
{
    const double Rad_to_deg = 45.0 / atan(1.0);

    void Vector::set_mag()
    {
        mag = sqrt(x * x + y * y);
    }

    void Vector::set_ang()
    {
        if (x == 0.0 && y == 0.0)
        {
            ang = 0.0;
        }
        else
        {
            ang = atan2(y, x);
        }
    }
    void Vector::set_x()
    {
        x = mag * cos(ang);
    }
    void Vector::set_y()
    {
        y = mag * sin(ang);
    }
    Vector::Vector()
    {
        x = y = mag = ang = 0.0;
        mode = RECT;
    }
    Vector::Vector(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
        {
            x = n1;
            y = n2;
            set_mag();
            set_ang();
        }
        else if (form == POL)
        {
            mag = n1;
            ang = n2 / Rad_to_deg;
            set_x();
            set_y();
        }
        else
        {
            cout << "Incorrect argument to Vector (), ";
            cout << "vector set to 0\n";
            x = y = mag = ang = 0.0;
            mode = RECT;
        }

    }
    void Vector::reset(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
        {
            x = n1;
            y = n2;
            set_mag();
            set_ang();
        }
        else if (form == POL)
        {
            mag = n1;
            ang = n2 / Rad_to_deg;
            set_x();
            set_y();
        }
        else
        {
            cout << "Incorrect argument to Vector (), ";
            cout << "vector set to 0\n";
            x = y = mag = ang = 0.0;
            mode = RECT;
        }
    }
    Vector::~Vector()
    {

    }
    void Vector::polar_mode()
    {
        mode = POL;
    }
    void Vector::rect_mode()
    {
        mode = RECT;
    }
    Vector Vector::operator+(const Vector &b) const
    {
        return Vector(x + b.x, y + b.y);
    }
    Vector Vector::operator-(const Vector &b) const
    {
        return Vector(x - b.x, y - b.y);
    }
    Vector Vector::operator-() const
    {
        return Vector(-x, -y);
    }
    Vector Vector::operator*(double n) const
    {
        return Vector(n * x, n * y);
    }
    Vector operator*(double n, const Vector &a)
    {
        return a * n;
    }
    std::ostream &operator<<(std::ostream &os, const Vector &v)
    {
        if (v.mode == Vector::RECT)
        {
            os << " (x,y) = (" << v.x << ", " << v.y << ")";
        }
        else if (v.mode == Vector::POL)
        {
            os << " (m,a) = (" << v.mag << ", " << v.ang *Rad_to_deg << " ) ";
        }
        else
        {
            os << "Vector object mode is invalid";
        }
        return os;
    }
}

randwalk.cpp
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <ctime>
#include "vect.h"


int main()
{
    using VECTOR::Vector;

    std::srand(std::time(nullptr));

    std::ofstream fout;
    fout.open("Vector.txt");

    double direction;
    Vector step;
    Vector result(0.0, 0.0);
    unsigned long steps = 0;
    double target;
    double dstep;

    std::cout << "Enter target distance (q to quit) : ";
    target = 0.0;
    while (std::cin >> target)
    {
        while (std::cin.get() != '\n')
        {
            continue;
        }
        std::cout << "Enter step length: ";
        dstep = 0.0;
        if (!(std::cin >> dstep))
        {
            break;
        }
        while (std::cin.get() != '\n')
        {
            continue;
        }
        fout << "Target distance : ";
        fout << target << ",";
        fout << " Step length: ";
        fout << dstep << std::endl;

        while (result.magval() < target)
        {
            direction = std::rand() % 360;
            step.reset(dstep, direction, Vector::POL);
            result = result + step;
            steps++;

            fout << steps << ": " << result << std::endl;
            std::cout << steps << ": " << result << std::endl;
        }

        fout << "After " << steps << " steps, the subject has the following location:\n";
        std::cout << "After " << steps << " steps, the subject has the following location:\n";

        fout << result << std::endl;
        std::cout << result << std::endl;
        result.polar_mode();

        fout << " or\n" << result << std::endl;
        std::cout << " or\n" << result << std::endl;

        fout << "Average outward distance per step = ";
        std::cout << "Average outward distance per step = ";
        fout << result.magval() / steps << std::endl;
        std::cout << result.magval() / steps << std::endl;

        steps = 0;
        result.reset(0.0, 0.0);
        std::cout << "Enter target distance (q to quit) : ";
        target = 0.0;
    }
    fout.close();
    std::cout << "Done.\n";
    std::cin.clear();
    while (std::cin.get() != '\n')
    {
        continue;
    }

    return 0;
}
显示结果如下
Enter target distance (q to quit) : 8
Enter step length: 1
1:  (x,y) = (-0.34202, -0.939693)
2:  (x,y) = (-0.780391, -0.0408986)
3:  (x,y) = (-1.72591, -0.366467)
4:  (x,y) = (-2.60053, 0.118343)
5:  (x,y) = (-2.10053, -0.747683)
6:  (x,y) = (-1.18002, -1.13841)
7:  (x,y) = (-1.00638, -2.12322)
8:  (x,y) = (-0.0500718, -1.83085)
9:  (x,y) = (0.906233, -1.53848)
10:  (x,y) = (1.28084, -0.611294)
11:  (x,y) = (0.451802, -1.17049)
12:  (x,y) = (-0.475382, -0.79588)
13:  (x,y) = (0.219277, -0.0765406)
14:  (x,y) = (1.1648, -0.402109)
15:  (x,y) = (0.219277, -0.0765406)
16:  (x,y) = (-0.720416, -0.418561)
17:  (x,y) = (-0.297798, 0.487747)
18:  (x,y) = (0.108939, -0.425798)
19:  (x,y) = (-0.657106, 0.216989)
20:  (x,y) = (-0.203115, 1.108)
21:  (x,y) = (-1.1303, 0.733389)
22:  (x,y) = (-1.94945, 1.30697)
23:  (x,y) = (-2.70416, 0.650906)
24:  (x,y) = (-3.70279, 0.598571)
25:  (x,y) = (-2.89377, 1.18636)
26:  (x,y) = (-2.01083, 1.65583)
27:  (x,y) = (-1.20181, 1.06804)
28:  (x,y) = (-2.17618, 1.29299)
29:  (x,y) = (-1.25567, 1.68372)
30:  (x,y) = (-0.848937, 2.59727)
31:  (x,y) = (-1.4646, 1.80926)
32:  (x,y) = (-1.41226, 0.810629)
33:  (x,y) = (-0.824477, 1.61965)
34:  (x,y) = (-0.279838, 0.780976)
35:  (x,y) = (0.158533, 1.67977)
36:  (x,y) = (1.15473, 1.59261)
37:  (x,y) = (0.263721, 2.0466)
38:  (x,y) = (-0.545296, 1.45882)
39:  (x,y) = (0.432852, 1.66673)
40:  (x,y) = (-0.551956, 1.84038)
41:  (x,y) = (-1.47246, 2.23111)
42:  (x,y) = (-1.6289, 3.2188)
43:  (x,y) = (-0.780847, 2.68888)
44:  (x,y) = (-1.70135, 2.29815)
45:  (x,y) = (-1.5277, 3.28296)
46:  (x,y) = (-2.17049, 4.049)
47:  (x,y) = (-2.08334, 3.05281)
48:  (x,y) = (-1.12703, 3.34518)
49:  (x,y) = (-0.68866, 2.44638)
50:  (x,y) = (-0.396288, 1.49008)
51:  (x,y) = (-0.22264, 2.47489)
52:  (x,y) = (-0.965785, 3.14402)
53:  (x,y) = (-0.406592, 2.31498)
54:  (x,y) = (-1.40111, 2.41951)
55:  (x,y) = (-2.37141, 2.17759)
56:  (x,y) = (-1.43172, 1.83557)
57:  (x,y) = (-1.15608, 2.79683)
58:  (x,y) = (-2.08326, 3.17143)
59:  (x,y) = (-1.13775, 3.497)
60:  (x,y) = (-1.25961, 4.48955)
61:  (x,y) = (-1.36414, 5.48407)
62:  (x,y) = (-1.92334, 6.31311)
63:  (x,y) = (-0.938528, 6.48676)
64:  (x,y) = (-1.81315, 6.97157)
65:  (x,y) = (-1.42242, 7.89207)
After 65 steps, the subject has the following location:
 (x,y) = (-1.42242, 7.89207)
 or
 (m,a) = (8.01923, 100.217 )
Average outward distance per step = 0.123373
Enter target distance (q to quit) : q
Done.

cat Vector.txt
Target distance : 8, Step length: 1
1:  (x,y) = (-0.34202, -0.939693)
2:  (x,y) = (-0.780391, -0.0408986)
3:  (x,y) = (-1.72591, -0.366467)
4:  (x,y) = (-2.60053, 0.118343)
5:  (x,y) = (-2.10053, -0.747683)
6:  (x,y) = (-1.18002, -1.13841)
7:  (x,y) = (-1.00638, -2.12322)
8:  (x,y) = (-0.0500718, -1.83085)
9:  (x,y) = (0.906233, -1.53848)
10:  (x,y) = (1.28084, -0.611294)
11:  (x,y) = (0.451802, -1.17049)
12:  (x,y) = (-0.475382, -0.79588)
13:  (x,y) = (0.219277, -0.0765406)
14:  (x,y) = (1.1648, -0.402109)
15:  (x,y) = (0.219277, -0.0765406)
16:  (x,y) = (-0.720416, -0.418561)
17:  (x,y) = (-0.297798, 0.487747)
18:  (x,y) = (0.108939, -0.425798)
19:  (x,y) = (-0.657106, 0.216989)
20:  (x,y) = (-0.203115, 1.108)
21:  (x,y) = (-1.1303, 0.733389)
22:  (x,y) = (-1.94945, 1.30697)
23:  (x,y) = (-2.70416, 0.650906)
24:  (x,y) = (-3.70279, 0.598571)
25:  (x,y) = (-2.89377, 1.18636)
26:  (x,y) = (-2.01083, 1.65583)
27:  (x,y) = (-1.20181, 1.06804)
28:  (x,y) = (-2.17618, 1.29299)
29:  (x,y) = (-1.25567, 1.68372)
30:  (x,y) = (-0.848937, 2.59727)
31:  (x,y) = (-1.4646, 1.80926)
32:  (x,y) = (-1.41226, 0.810629)
33:  (x,y) = (-0.824477, 1.61965)
34:  (x,y) = (-0.279838, 0.780976)
35:  (x,y) = (0.158533, 1.67977)
36:  (x,y) = (1.15473, 1.59261)
37:  (x,y) = (0.263721, 2.0466)
38:  (x,y) = (-0.545296, 1.45882)
39:  (x,y) = (0.432852, 1.66673)
40:  (x,y) = (-0.551956, 1.84038)
41:  (x,y) = (-1.47246, 2.23111)
42:  (x,y) = (-1.6289, 3.2188)
43:  (x,y) = (-0.780847, 2.68888)
44:  (x,y) = (-1.70135, 2.29815)
45:  (x,y) = (-1.5277, 3.28296)
46:  (x,y) = (-2.17049, 4.049)
47:  (x,y) = (-2.08334, 3.05281)
48:  (x,y) = (-1.12703, 3.34518)
49:  (x,y) = (-0.68866, 2.44638)
50:  (x,y) = (-0.396288, 1.49008)
51:  (x,y) = (-0.22264, 2.47489)
52:  (x,y) = (-0.965785, 3.14402)
53:  (x,y) = (-0.406592, 2.31498)
54:  (x,y) = (-1.40111, 2.41951)
55:  (x,y) = (-2.37141, 2.17759)
56:  (x,y) = (-1.43172, 1.83557)
57:  (x,y) = (-1.15608, 2.79683)
58:  (x,y) = (-2.08326, 3.17143)
59:  (x,y) = (-1.13775, 3.497)
60:  (x,y) = (-1.25961, 4.48955)
61:  (x,y) = (-1.36414, 5.48407)
62:  (x,y) = (-1.92334, 6.31311)
63:  (x,y) = (-0.938528, 6.48676)
64:  (x,y) = (-1.81315, 6.97157)
65:  (x,y) = (-1.42242, 7.89207)
After 65 steps, the subject has the following location:
 (x,y) = (-1.42242, 7.89207)
 or
 (m,a) = (8.01923, 100.217 )
Average outward distance per step = 0.123373

2.对Vector类的头文件（程序清单11.13）和实现文件（程序清单11.14）进行修改，
使其不再存储矢量的长度和角度，而是在magval（）和angval）被调用时计算它们。
应保留公有接口不变（公有方法及其参数不变），但对私有部分（包括一些私有方法）和方法实现进行修改。
然后，使用程序清单11.15对修改后的版本进行测试，结果应该与以前相同，因为Vector类的公有接口与原来相同。
vect1.h
#pragma once
#ifndef VECT1_H_
#define VECT1_H_
#include <cmath>
#include <iostream>

namespace VECTOR
{
    class Vector
    {
    public:
        enum Mode { RECT, POL };
    private:
        double x;
        double y;
        Mode mode;
    public:
        Vector();
        Vector(double n1, double n2, Mode form = RECT);
        void reset(double n1, double n2, Mode form = RECT);
        ~Vector();
        double xval() const
        {
            return x;
        }
        double yval() const
        {
            return y;
        }
        double magval() const;
        double angval() const;
        void polar_mode();
        void rect_mode();
        Vector operator+(const Vector &b) const;
        Vector operator-(const Vector &b) const;
        Vector operator-() const;
        Vector operator*(double n) const;
        friend Vector operator*(double n, const Vector &a);
        friend std::ostream &operator<<(std::ostream &os, const Vector &v);
    };
}

#endif

vect1.cpp
#include <iostream>
#include "vect1.h"

using std::sqrt;
using std::sin;
using std::cos;
using std::atan;
using std::atan2;
using std::cout;

namespace VECTOR
{
    const double Rad_to_deg = 45.0 / atan(1.0);

    Vector::Vector()
    {
        x = y = 0.0;
        mode = RECT;
    }
    Vector::Vector(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
        {
            x = n1;
            y = n2;
        }
        else if (form == POL)
        {
            x = n1 * cos(n2 / Rad_to_deg);
            y = n1 * sin(n2 / Rad_to_deg);
        }
        else
        {
            cout << "Incorrect argument to Vector (), ";
            cout << "vector set to 0\n";
            x = y = 0.0;
            mode = RECT;
        }
    }
    void Vector::reset(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
        {
            x = n1;
            y = n2;
        }
        else if (form == POL)
        {
            x = n1 * cos(n2 / Rad_to_deg);
            y = n1 * sin(n2 / Rad_to_deg);
        }
        else
        {
            cout << "Incorrect argument to Vector (), ";
            cout << "vector set to 0\n";
            x = y = 0.0;
            mode = RECT;
        }
    }
    Vector::~Vector()
    {

    }
    double Vector::magval() const
    {
        return sqrt(x * x + y * y);
    }
    double Vector::angval() const
    {
        return (x == 0.0 && y == 0.0) ? 0.0 : atan2(y, x);
    }
    void Vector::polar_mode()
    {
        mode = POL;
    }
    void Vector::rect_mode()
    {
        mode = RECT;
    }
    Vector Vector::operator+(const Vector &b) const
    {
        return Vector(x + b.x, y + b.y);
    }
    Vector Vector::operator-(const Vector &b) const
    {
        return Vector(x - b.x, y - b.y);
    }
    Vector Vector::operator-() const
    {
        return Vector(-x, -y);
    }
    Vector Vector::operator*(double n) const
    {
        return Vector(n * x, n * y);
    }
    Vector operator*(double n, const Vector &a)
    {
        return a * n;
    }
    std::ostream &operator<<(std::ostream &os, const Vector &v)
    {
        if (v.mode == Vector::RECT)
        {
            os << " (x,y) = (" << v.x << ", " << v.y << ")";
        }
        else if (v.mode == Vector::POL)
        {
            os << " (m,a) = (" << v.magval() << ", " << v.angval() *Rad_to_deg << " ) ";
        }
        else
        {
            os << "Vector object mode is invalid";
        }
        return os;
    }
}

ch11_p02.cpp
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <ctime>
#include "vect1.h"


int main()
{
    using VECTOR::Vector;

    std::srand(std::time(nullptr));

    std::ofstream fout;
    fout.open("Vector1.txt");

    double direction;
    Vector step;
    Vector result(0.0, 0.0);
    unsigned long steps = 0;
    double target;
    double dstep;

    std::cout << "Enter target distance (q to quit) : ";
    target = 0.0;
    while (std::cin >> target)
    {
        while (std::cin.get() != '\n')
        {
            continue;
        }
        std::cout << "Enter step length: ";
        dstep = 0.0;
        if (!(std::cin >> dstep))
        {
            break;
        }
        while (std::cin.get() != '\n')
        {
            continue;
        }
        fout << "Target distance : ";
        fout << target << ",";
        fout << " Step length: ";
        fout << dstep << std::endl;

        while (result.magval() < target)
        {
            direction = std::rand() % 360;
            step.reset(dstep, direction, Vector::POL);
            result = result + step;
            steps++;

            fout << steps << ": " << result << std::endl;
            std::cout << steps << ": " << result << std::endl;
        }

        fout << "After " << steps << " steps, the subject has the following location:\n";
        std::cout << "After " << steps << " steps, the subject has the following location:\n";

        fout << result << std::endl;
        std::cout << result << std::endl;
        result.polar_mode();

        fout << " or\n" << result << std::endl;
        std::cout << " or\n" << result << std::endl;

        fout << "Average outward distance per step = ";
        std::cout << "Average outward distance per step = ";
        fout << result.magval() / steps << std::endl;
        std::cout << result.magval() / steps << std::endl;

        steps = 0;
        result.reset(0.0, 0.0);
        std::cout << "Enter target distance (q to quit) : ";
        target = 0.0;
    }
    fout.close();
    std::cout << "Done.\n";
    std::cin.clear();
    while (std::cin.get() != '\n')
    {
        continue;
    }

    return 0;
}
显示结果如下
Enter target distance (q to quit) : 6
Enter step length: 1
1:  (x,y) = (0.819152, 0.573576)
2:  (x,y) = (1.8117, 0.451707)
3:  (x,y) = (2.54305, 1.13371)
4:  (x,y) = (3.13084, 0.324688)
5:  (x,y) = (4.12111, 0.463862)
6:  (x,y) = (3.57647, -0.374809)
7:  (x,y) = (3.20186, -1.30199)
8:  (x,y) = (2.90949, -2.2583)
9:  (x,y) = (2.36485, -3.09697)
10:  (x,y) = (1.5988, -2.45418)
11:  (x,y) = (1.94082, -1.51449)
12:  (x,y) = (1.95828, -2.51434)
13:  (x,y) = (1.75037, -1.53619)
14:  (x,y) = (0.911695, -0.991549)
15:  (x,y) = (1.08534, -1.97636)
16:  (x,y) = (0.0853429, -1.97636)
17:  (x,y) = (-0.860176, -1.65079)
18:  (x,y) = (-1.05098, -2.63242)
19:  (x,y) = (-1.59562, -3.47109)
20:  (x,y) = (-2.50917, -3.87782)
21:  (x,y) = (-1.66112, -4.40774)
22:  (x,y) = (-0.676313, -4.58139)
23:  (x,y) = (0.319881, -4.66855)
24:  (x,y) = (-0.607302, -5.04315)
25:  (x,y) = (-0.0773832, -5.8912)
26:  (x,y) = (-1.06765, -6.03037)
After 26 steps, the subject has the following location:
 (x,y) = (-1.06765, -6.03037)
 or
 (m,a) = (6.12416, -100.04 )
Average outward distance per step = 0.235544
Enter target distance (q to quit) : q
Done.

cat Vector1.txt
Target distance : 6, Step length: 1
1:  (x,y) = (0.819152, 0.573576)
2:  (x,y) = (1.8117, 0.451707)
3:  (x,y) = (2.54305, 1.13371)
4:  (x,y) = (3.13084, 0.324688)
5:  (x,y) = (4.12111, 0.463862)
6:  (x,y) = (3.57647, -0.374809)
7:  (x,y) = (3.20186, -1.30199)
8:  (x,y) = (2.90949, -2.2583)
9:  (x,y) = (2.36485, -3.09697)
10:  (x,y) = (1.5988, -2.45418)
11:  (x,y) = (1.94082, -1.51449)
12:  (x,y) = (1.95828, -2.51434)
13:  (x,y) = (1.75037, -1.53619)
14:  (x,y) = (0.911695, -0.991549)
15:  (x,y) = (1.08534, -1.97636)
16:  (x,y) = (0.0853429, -1.97636)
17:  (x,y) = (-0.860176, -1.65079)
18:  (x,y) = (-1.05098, -2.63242)
19:  (x,y) = (-1.59562, -3.47109)
20:  (x,y) = (-2.50917, -3.87782)
21:  (x,y) = (-1.66112, -4.40774)
22:  (x,y) = (-0.676313, -4.58139)
23:  (x,y) = (0.319881, -4.66855)
24:  (x,y) = (-0.607302, -5.04315)
25:  (x,y) = (-0.0773832, -5.8912)
26:  (x,y) = (-1.06765, -6.03037)
After 26 steps, the subject has the following location:
 (x,y) = (-1.06765, -6.03037)
 or
 (m,a) = (6.12416, -100.04 )
Average outward distance per step = 0.235544

3.修改程序清单11.15，使之报告N次测试中的最高、最低和平均步数（其中N是用户输入的整数），而不是报告每次测试的结果。
vect.h
#pragma once
#ifndef VECT_H_
#define VECT_H_
#include <cmath>
#include <iostream>

namespace VECTOR
{
    class Vector
    {
    public:
        enum Mode { RECT, POL };
    private:
        double x;
        double y;
        double mag;
        double ang;
        Mode mode;
        void set_mag();
        void set_ang();
        void set_x();
        void set_y();
    public:
        Vector();
        Vector(double n1, double n2, Mode form = RECT);
        void reset(double n1, double n2, Mode form = RECT);
        ~Vector();
        double xval() const
        {
            return x;
        }
        double yval() const
        {
            return y;
        }
        double magval() const
        {
            return mag;
        }
        double angval() const
        {
            return ang;
        }
        void polar_mode();
        void rect_mode();
        Vector operator+(const Vector &b) const;
        Vector operator-(const Vector &b) const;
        Vector operator-() const;
        Vector operator*(double n) const;
        friend Vector operator*(double n, const Vector &a);
        friend std::ostream &operator<<(std::ostream &os, const Vector &v);
    };
}

#endif

vect.cpp
#include <iostream>
#include "vect.h"

using std::sqrt;
using std::sin;
using std::cos;
using std::atan;
using std::atan2;
using std::cout;

namespace VECTOR
{
    const double Rad_to_deg = 45.0 / atan(1.0);

    void Vector::set_mag()
    {
        mag = sqrt(x * x + y * y);
    }

    void Vector::set_ang()
    {
        if (x == 0.0 && y == 0.0)
        {
            ang = 0.0;
        }
        else
        {
            ang = atan2(y, x);
        }
    }
    void Vector::set_x()
    {
        x = mag * cos(ang);
    }
    void Vector::set_y()
    {
        y = mag * sin(ang);
    }
    Vector::Vector()
    {
        x = y = mag = ang = 0.0;
        mode = RECT;
    }
    Vector::Vector(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
        {
            x = n1;
            y = n2;
            set_mag();
            set_ang();
        }
        else if (form == POL)
        {
            mag = n1;
            ang = n2 / Rad_to_deg;
            set_x();
            set_y();
        }
        else
        {
            cout << "Incorrect argument to Vector (), ";
            cout << "vector set to 0\n";
            x = y = mag = ang = 0.0;
            mode = RECT;
        }

    }
    void Vector::reset(double n1, double n2, Mode form)
    {
        mode = form;
        if (form == RECT)
        {
            x = n1;
            y = n2;
            set_mag();
            set_ang();
        }
        else if (form == POL)
        {
            mag = n1;
            ang = n2 / Rad_to_deg;
            set_x();
            set_y();
        }
        else
        {
            cout << "Incorrect argument to Vector (), ";
            cout << "vector set to 0\n";
            x = y = mag = ang = 0.0;
            mode = RECT;
        }
    }
    Vector::~Vector()
    {

    }
    void Vector::polar_mode()
    {
        mode = POL;
    }
    void Vector::rect_mode()
    {
        mode = RECT;
    }
    Vector Vector::operator+(const Vector &b) const
    {
        return Vector(x + b.x, y + b.y);
    }
    Vector Vector::operator-(const Vector &b) const
    {
        return Vector(x - b.x, y - b.y);
    }
    Vector Vector::operator-() const
    {
        return Vector(-x, -y);
    }
    Vector Vector::operator*(double n) const
    {
        return Vector(n * x, n * y);
    }
    Vector operator*(double n, const Vector &a)
    {
        return a * n;
    }
    std::ostream &operator<<(std::ostream &os, const Vector &v)
    {
        if (v.mode == Vector::RECT)
        {
            os << " (x,y) = (" << v.x << ", " << v.y << ")";
        }
        else if (v.mode == Vector::POL)
        {
            os << " (m,a) = (" << v.mag << ", " << v.ang *Rad_to_deg << " ) ";
        }
        else
        {
            os << "Vector object mode is invalid";
        }
        return os;
    }
}

ch11_p03.cpp
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <algorithm>
#include <numeric>
#include "vect.h"


int main()
{
    using VECTOR::Vector;

    std::srand(std::time(nullptr));

    std::vector<unsigned long> stepsResult;
    std::cout << "Enter number of attempts: ";
    int attempt = 0;
    std::cin >> attempt;
    while (std::cin.get() != '\n')
    {
        continue;
    }

    std::ofstream fout;
    fout.open("ch11_p03.txt");

    double direction;
    Vector step;
    Vector result(0.0, 0.0);
    unsigned long steps = 0;
    double target;
    double dstep;

    std::cout << "Enter target distance (q to quit) : ";
    target = 0.0;
    while (attempt > 0 && std::cin >> target)
    {
        while (std::cin.get() != '\n')
        {
            continue;
        }
        std::cout << "Enter step length: ";
        dstep = 0.0;
        if (!(std::cin >> dstep))
        {
            break;
        }
        while (std::cin.get() != '\n')
        {
            continue;
        }
        fout << "Target distance : ";
        fout << target << ",";
        fout << " Step length: ";
        fout << dstep << std::endl;

        while (result.magval() < target)
        {
            direction = std::rand() % 360;
            step.reset(dstep, direction, Vector::POL);
            result = result + step;
            steps++;

        }
        stepsResult.push_back(steps);

        fout << "After " << steps << " steps, the subject has the following location:\n";
        std::cout << "After " << steps << " steps, the subject has the following location:\n";

        fout << result << std::endl;
        std::cout << result << std::endl;
        result.polar_mode();

        fout << " or\n" << result << std::endl;
        std::cout << " or\n" << result << std::endl;

        fout << "Average outward distance per step = ";
        std::cout << "Average outward distance per step = ";
        fout << result.magval() / steps << std::endl;
        std::cout << result.magval() / steps << std::endl;

        steps = 0;
        result.reset(0.0, 0.0);
        --attempt;
        if (attempt > 0)
        {
            std::cout << "Enter target distance (q to quit) : ";
            target = 0.0;
        }
    }
    std::cout << "The smallest number of steps is ";
    std::cout << *std::min_element(stepsResult.begin(), stepsResult.end());
    std::cout << '\n';

    std::cout << "The largest number of steps is ";
    std::cout << *std::max_element(stepsResult.begin(), stepsResult.end());
    std::cout << '\n';

    std::cout << "The average number of steps is ";
    std::cout << std::accumulate(stepsResult.begin(), stepsResult.end(), 0) / stepsResult.size();
    std::cout << '\n';

    fout.close();
    std::cout << "Done.\n";
    if (attempt > 0)
    {
        std::cin.clear();
        while (std::cin.get() != '\n')
        {
            continue;
        }
    }

    return 0;
}
显示结果如下
Enter number of attempts: 5
Enter target distance (q to quit) : 5
Enter step length: 1
After 30 steps, the subject has the following location:
 (x,y) = (3.42309, -3.89729)
 or
 (m,a) = (5.18714, -48.7064 )
Average outward distance per step = 0.172905
Enter target distance (q to quit) : 6
Enter step length: 1
After 25 steps, the subject has the following location:
 (x,y) = (-5.56922, 2.26059)
 or
 (m,a) = (6.01053, 157.907 )
Average outward distance per step = 0.240421
Enter target distance (q to quit) : 7
Enter step length: 1
After 79 steps, the subject has the following location:
 (x,y) = (-2.19311, -6.66206)
 or
 (m,a) = (7.01376, -108.221 )
Average outward distance per step = 0.0887817
Enter target distance (q to quit) : 8
Enter step length: 1
After 295 steps, the subject has the following location:
 (x,y) = (-4.53022, -6.86561)
 or
 (m,a) = (8.22554, -123.418 )
Average outward distance per step = 0.0278832
Enter target distance (q to quit) : 9
Enter step length: 1
After 30 steps, the subject has the following location:
 (x,y) = (-0.383674, 9.90786)
 or
 (m,a) = (9.91529, 92.2176 )
Average outward distance per step = 0.33051
The smallest number of steps is 25
The largest number of steps is 295
The average number of steps is 91
Done.

4.重新编写最后的Time类示例（程序清单11.10、程序清单11.11和程序清单11.12），使用友元函数来实现所有的重载运算符。
mytime4.h
#pragma once
#ifndef MYTIME4_H_
#define MYTIME4_H_

#include <iostream>

class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    friend Time operator+(const Time &t1, const Time &t2);
    friend Time operator-(const Time &t1, const Time &t2);
    friend Time operator*(double n, const Time &t);
    friend Time operator*(const Time &t, double n);
    friend std::ostream &operator<<(std::ostream &os, const Time &t);
};

#endif

mytime4.cpp
#include <iostream>
#include "mytime4.h"

Time::Time()
{
    hours = minutes = 0;
}

Time::Time(int h, int m)
{
    hours = h;
    minutes = m;
}

void Time::AddMin(int m)
{
    minutes += m;
    hours += minutes / 60;
    minutes %= 60;
}

void Time::AddHr(int h)
{
    hours += h;
}

void Time::Reset(int h, int m)
{
    hours = h;
    minutes = m;
}
Time operator+(const Time & t1, const Time & t2)
{
	Time sum;
	sum.minutes = t1.minutes + t2.minutes;
	sum.hours = t1.hours + t2.hours + sum.minutes / 60;
	sum.minutes %= 60;
	return sum;
}
Time operator-(const Time & t1, const Time & t2)
{
	Time diff;
	int tot1, tot2;
	tot1 = t1.minutes + 60 * t2.hours;
	tot2 = t1.minutes + 60 * t2.hours;
	diff.minutes = (tot2 - tot1) % 60;
	diff.hours = (tot2 - tot1) / 60;
	return diff;
}
Time operator*(double n, const Time & t)
{
	Time result;
	long totalminutes = t.hours * n * 60 + t.minutes * n;
	result.hours = totalminutes / 60;
	result.minutes = totalminutes % 60;
	return result;
}
Time operator*(const Time& t, double n)
{
	Time result;
	long totalminutes = t.hours * n * 60 + t.minutes * n;
	result.hours = totalminutes / 60;
	result.minutes = totalminutes % 60;
	return result;
}
std::ostream & operator<<(std::ostream & os, const Time & t)
{
	os << t.hours << " hours, " << t.minutes << " minutes";
	return os;
}

usetime4.cpp
#include <iostream>
#include "mytime4.h"

int main()
{
    using std::cout;
    using std::endl;

    Time aida(3, 35);
    Time tosca(2, 48);
    Time temp;
    cout << "Aida and Tosca:\n";
    cout << aida << "; " << tosca << endl;
    temp = aida + tosca;
    cout << "Aida + Tosca: " << temp << endl;
    temp = aida * 1.17;
    cout << "Aida * 1.17: " << temp << endl;
    cout << "10.0 * Tosca: " << 10.0 * tosca << endl;

    return 0;
}
显示结果如下
Aida and Tosca:
3 hours, 35 minutes; 2 hours, 48 minutes
Aida + Tosca: 6 hours, 23 minutes
Aida * 1.17: 4 hours, 11 minutes
10.0 * Tosca: 28 hours, 0 minutes

5.重新编写Stonewt类（程序清单11.16和程序清单11.17），使它有一个状态成员，
由该成员控制对应转换为英石格式、整数磅格式还是浮点磅格式。
重载<<运算符，使用它来替换show_stn和show_lbs方法。
重载加法、减法和乘法运算符，以便可以对Stonewt值进行加、减、乘运算。
编写一个使用所有类方法和友元的小程序，来测试这个类。
stonewt2.h
#pragma once
#ifndef STONEWT2_H_
#define STONEWT2_H_

class Stonewt
{
private:
    enum { Lbs_per_stn = 14 };
    enum Mode { STONE, iPOUND, dPOUND };
    int stone;
    double pds_left;
    double dpounds;
    int ipounds;
    Mode mode;
    void setmode();
public:
    Stonewt(double lbs);
    Stonewt(int stn, double lbs);
    Stonewt();
    ~Stonewt();
    void setmode(int m);
    friend Stonewt operator+(const Stonewt &stn1, const Stonewt &stn2);
    friend Stonewt operator-(const Stonewt &stn1, const Stonewt &stn2);
    friend Stonewt operator*(double n, const Stonewt &stn);
    friend Stonewt operator*(const Stonewt &stn, double n);
    friend std::ostream &operator<<(std::ostream &os, const Stonewt &stn);
};

#endif

stonewt2.cpp
#include <iostream>
#include "stonewt2.h"

Stonewt::Stonewt(double lbs)
{
    stone = int(lbs) / Lbs_per_stn;
    pds_left = int(lbs) % Lbs_per_stn + lbs - int(lbs);
    dpounds = lbs;
    ipounds = int(lbs);
    setmode();
}

Stonewt::Stonewt(int stn, double lbs)
{
    stone = stn;
    pds_left = lbs;
    dpounds = stn * Lbs_per_stn + lbs;
    ipounds = int(stn * Lbs_per_stn + lbs);
    setmode();
}

Stonewt::Stonewt()
{
    stone = dpounds = ipounds = pds_left = 0;
    setmode();
}

Stonewt::~Stonewt()
{

}
void Stonewt::setmode()
{
    if (pds_left == 0)
    {
        mode = STONE;
    }
    else if (pds_left > int(pds_left))
    {
        mode = dPOUND;
    }
    else
    {
        mode = iPOUND;
    }
}
void Stonewt::setmode(int m)
{
    if (m == 0)
    {
        mode = STONE;
    }
    else if (m == 1)
    {
        mode = iPOUND;
    }
    else if (m == 2)
    {
        mode = dPOUND;
    }
    else
    {
        std::cout << "\nInvalid argument to the setmode() function, ";
        std::cout << "The mode is set to STONE.\n";
        mode = STONE;
    }
}
Stonewt operator+(const Stonewt &stn1, const Stonewt &stn2)
{
    return Stonewt (stn1.dpounds + stn2.dpounds);
}
Stonewt operator-(const Stonewt &stn1, const Stonewt &stn2)
{
    return Stonewt (stn1.dpounds - stn2.dpounds);
}
Stonewt operator*(double n, const Stonewt &stn)
{
    return Stonewt (stn.dpounds * n);
}
Stonewt operator*(const Stonewt &stn, double n)
{
    return Stonewt (stn.dpounds * n);
}
std::ostream &operator<<(std::ostream &os, const Stonewt &stn)
{
    if (stn.mode == Stonewt::STONE)
    {
        os << stn.stone << " stone, " << stn.pds_left << " pounds.";
    }
    else if (stn.mode == Stonewt::iPOUND)
    {
        os << stn.ipounds << " pounds.";
    }
    else
    {
        os << stn.dpounds << " pounds.";
    }
    return os;
}


stone2.cpp
#include <iostream>
#include "stonewt2.h"

int main()
{
    Stonewt var_a;
    std::cout << "Object var_a constructed by default constructor: " << var_a << std::endl;

    Stonewt var_b(62.52);
    std::cout << "Object var_b constructed from double value: " << var_b << std::endl;

    Stonewt var_c(10, 60.21);
    std::cout << "Object var_c constructed from stone, double values: " << var_c << std::endl;

    var_c.setmode(0);
    std::cout << "Object var_c (Mode set to STONE): " << var_c << std::endl;

    var_c.setmode(1);
    std::cout << "Object var_c (Mode set to iPOUND): " << var_c << std::endl;

    var_c.setmode(2);
    std::cout << "Object var_c (Mode set to dPOUND): " << var_c << std::endl;

    std::cout << "Object var_c (Mode set to incorrect value):\n";
    var_c.setmode(6);
    std::cout << "Object var_c after that: " << var_c << std::endl;

    Stonewt var_d = var_b + var_c;
    std::cout << "\nObject var_d after adding: " << var_d << std::endl;

    var_d.setmode(0);
    std::cout << "Object var_d (Mode set to STONE): " << var_d << std::endl;

    var_d.setmode(1);
    std::cout << "Object var_d (Mode set to iPOUND): " << var_d << std::endl;

    var_d.setmode(2);
    std::cout << "Object var_d (Mode set to dPOUND): " << var_d << std::endl;

    var_d = var_c - var_b;
    std::cout << "\nObject var_d after division: " << var_d << std::endl;

    var_d.setmode(0);
    std::cout << "Object var_d (Mode set to STONE): " << var_d << std::endl;

    var_d.setmode(1);
    std::cout << "Object var_d (Mode set to iPOUND): " << var_d << std::endl;

    var_d.setmode(2);
    std::cout << "Object var_d (Mode set to dPOUND): " << var_d << std::endl;

    var_d = 5.0 * var_b;
    std::cout << "\nObject var_d after multiplying: " << var_d << std::endl;

    var_d.setmode(0);
    std::cout << "Object var_d (Mode set to STONE): " << var_d << std::endl;

    var_d.setmode(1);
    std::cout << "Object var_d (Mode set to iPOUND): " << var_d << std::endl;

    var_d.setmode(2);
    std::cout << "Object var_d (Mode set to dPOUND): " << var_d << std::endl;

    return 0;
}
显示结果如下
Object var_a constructed by default constructor: 0 stone, 0 pounds.
Object var_b constructed from double value: 62.52 pounds.
Object var_c constructed from stone, double values: 200.21 pounds.
Object var_c (Mode set to STONE): 10 stone, 60.21 pounds.
Object var_c (Mode set to iPOUND): 200 pounds.
Object var_c (Mode set to dPOUND): 200.21 pounds.
Object var_c (Mode set to incorrect value):

Invalid argument to the setmode() function, The mode is set to STONE.
Object var_c after that: 10 stone, 60.21 pounds.

Object var_d after adding: 262.73 pounds.
Object var_d (Mode set to STONE): 18 stone, 10.73 pounds.
Object var_d (Mode set to iPOUND): 262 pounds.
Object var_d (Mode set to dPOUND): 262.73 pounds.

Object var_d after division: 137.69 pounds.
Object var_d (Mode set to STONE): 9 stone, 11.69 pounds.
Object var_d (Mode set to iPOUND): 137 pounds.
Object var_d (Mode set to dPOUND): 137.69 pounds.

Object var_d after multiplying: 312.6 pounds.
Object var_d (Mode set to STONE): 22 stone, 4.6 pounds.
Object var_d (Mode set to iPOUND): 312 pounds.
Object var_d (Mode set to dPOUND): 312.6 pounds.

6.重新编写Stonewt类（程序清单11.16和程序清单11.17），重载全部6个关系运算符。
运算符对pounds成员进行比较，并返回一个bool值。
编写一个程序，它声明一个包含6个Stonewt对象的数组，并在数组声明中初始化前3个对象。
然后使用循环来读取用于设置剩余3个数组元素的值。
接着报告最小的元素、最大的元素以及大于或等于11英石的元素的数量
（最简单的方法是创建一个Stonewt对象，并将其初始化为11英石，然后将其同其他对象进行比较）。
stonewt3.h
#pragma once
#ifndef STONEWT3_H_
#define STONEWT3_H_

class Stonewt
{
private:
    enum { Lbs_per_stn = 14 };
    enum Mode { STONE, iPOUND, dPOUND };
    int stone;
    double pds_left;
    double dpounds;
    int ipounds;
    Mode mode;
    void setmode();
public:
    Stonewt(double lbs);
    Stonewt(int stn, double lbs);
    Stonewt();
    ~Stonewt();
    void setmode(int m);
    friend Stonewt operator+(const Stonewt &stn1, const Stonewt &stn2);
    friend Stonewt operator-(const Stonewt &stn1, const Stonewt &stn2);
    friend Stonewt operator*(double n, const Stonewt &stn);
    friend Stonewt operator*(const Stonewt &stn, double n);
    friend bool operator > (const Stonewt &stn1, const Stonewt &stn2);
    friend bool operator < (const Stonewt &stn1, const Stonewt &stn2);
    friend bool operator >= (const Stonewt &stn1, const Stonewt &stn2);
    friend bool operator <= (const Stonewt &stn1, const Stonewt &stn2);
    friend bool operator == (const Stonewt &stn1, const Stonewt &stn2);
    friend bool operator != (const Stonewt &stn1, const Stonewt &stn2);
    friend std::ostream &operator<<(std::ostream &os, const Stonewt &stn);
};

#endif

stonewt3.cpp
#include <iostream>
#include "stonewt3.h"

Stonewt::Stonewt(double lbs)
{
    stone = int(lbs) / Lbs_per_stn;
    pds_left = int(lbs) % Lbs_per_stn + lbs - int(lbs);
    dpounds = lbs;
    ipounds = int(lbs);
    setmode();
}

Stonewt::Stonewt(int stn, double lbs)
{
    stone = stn;
    pds_left = lbs;
    dpounds = stn * Lbs_per_stn + lbs;
    ipounds = int(stn * Lbs_per_stn + lbs);
    setmode();
}

Stonewt::Stonewt()
{
    stone = dpounds = ipounds = pds_left = 0;
    setmode();
}

Stonewt::~Stonewt()
{

}
void Stonewt::setmode()
{
    if (pds_left == 0)
    {
        mode = STONE;
    }
    else if (pds_left > int(pds_left))
    {
        mode = dPOUND;
    }
    else
    {
        mode = iPOUND;
    }
}
void Stonewt::setmode(int m)
{
    if (m == 0)
    {
        mode = STONE;
    }
    else if (m == 1)
    {
        mode = iPOUND;
    }
    else if (m == 2)
    {
        mode = dPOUND;
    }
    else
    {
        std::cout << "Invalid argument to the setmode() function, The mode is set to STONE.\n";
        mode = STONE;
    }
}
Stonewt operator+(const Stonewt &stn1, const Stonewt &stn2)
{
    return Stonewt (stn1.dpounds + stn2.dpounds);
}
Stonewt operator-(const Stonewt &stn1, const Stonewt &stn2)
{
    return Stonewt (stn1.dpounds - stn2.dpounds);
}
Stonewt operator*(double n, const Stonewt &stn)
{
    return Stonewt (stn.dpounds * n);
}
Stonewt operator*(const Stonewt &stn, double n)
{
    return Stonewt (stn.dpounds * n);
}
bool operator > (const Stonewt &stn1, const Stonewt &stn2)
{
    return stn1.dpounds > stn2.dpounds;
}
bool operator < (const Stonewt &stn1, const Stonewt &stn2)
{
    return stn1.dpounds < stn2.dpounds;
}
bool operator >= (const Stonewt &stn1, const Stonewt &stn2)
{
    return stn1.dpounds >= stn2.dpounds;
}
bool operator <= (const Stonewt &stn1, const Stonewt &stn2)
{
    return stn1.dpounds <= stn2.dpounds;
}
bool operator == (const Stonewt &stn1, const Stonewt &stn2)
{
    return stn1.dpounds == stn2.dpounds;
}
bool operator != (const Stonewt &stn1, const Stonewt &stn2)
{
    return stn1.dpounds != stn2.dpounds;
}
std::ostream &operator<<(std::ostream &os, const Stonewt &stn)
{
    if (stn.mode == Stonewt::STONE)
    {
        os << stn.stone << " stone, " << stn.pds_left << " pounds.";
    }
    else if (stn.mode == Stonewt::iPOUND)
    {
        os << stn.ipounds << " pounds.";
    }
    else
    {
        os << stn.dpounds << " pounds.";
    }
    return os;
}

stone3.cpp
#include <iostream>
#include "stonewt3.h"

int main()
{
    const int ARR_SIZE = 6;

    Stonewt eleven(11, 0);
    Stonewt arr[ARR_SIZE] = { 30.27, 102.34, 80.51 };
    Stonewt maxElement = arr[0];
    Stonewt minElement = arr[0];

    for (int i = 0, j = ARR_SIZE - 1; i < ARR_SIZE / 2; ++i, --j)
    {
        arr[j] = arr[i] * 2.0;
    }

    int quantity = 0;

    for (int i = 0; i < ARR_SIZE; ++i)
    {
        if (arr[i] > maxElement)
        {
            maxElement = arr[i];
        }
        if (arr[i] < minElement)
        {
            minElement = arr[i];
        }
        if (arr[i] >= eleven)
        {
            ++quantity;
        }
    }

    std::cout << "Maximal element is: " << maxElement << std::endl;
    std::cout << "Minimal element is: " << minElement << std::endl;
    std::cout << "Quantity of elements bigger than 11 stones is: " << quantity << std::endl;

    return 0;
}
显示结果如下
Maximal element is: 204.68 pounds.
Minimal element is: 30.27 pounds.
Quantity of elements bigger than 11 stones is: 2

7.复数有两个部分组成：实数部分和虚数部分。复数的一种书写方式是：（3.0，4.0），其中，3.0是实数部分，4.0是虚数部分。
假设a=（A，Bi），c=（C，Di），则下面是一些复数运算
加法：a+c=（A+C，（B+D）i）
减法：a-c=（A-C，（B-D）i）。
乘法：a*c=（A*C-B*D，（A*D + B*C）i）。
乘法：x*c=（x*C，x*Di），其中x为实数
共轭：~a-（A，-Bi）
请定义一个复数类，以便下面的程序可以使用它来获得正确的结果。
注意，必须重载运算符<<和>>。标准C++使用头文件complex提供了比这个示例更广泛的复数支持，
因此应将自定义的头文件命名为complex0.h，以免发生冲突。应尽可能使用const。
请注意，经过重载后，cin>>c将提示用户输入实数和虚数部分。
complex0.h
#pragma once
#ifndef COMPLEX0_H_
#define COMPLEX0_H_
#include <iostream>

class Complex
{
private:
    double m_real;
    double m_imag;
public:
    Complex();
    Complex(double n1, double n2);
    ~Complex();
    friend Complex operator + (const Complex &n1, const Complex &n2);
    friend Complex operator - (const Complex &n1, const Complex &n2);
    friend Complex operator * (const Complex &n1, const Complex &n2);
    friend Complex operator * (double num, const Complex &n);
    friend Complex operator * (const Complex &n, double num);
    friend Complex operator ~ (const Complex &c);
    friend std::istream &operator>>(std::istream &is, Complex &c);
    friend std::ostream &operator<<(std::ostream &os, const Complex &c);
};

#endif

complex0.cpp
#include "complex0.h"

Complex::Complex()
{
    m_real = 0;
    m_imag = 0;
}
Complex::Complex(double n1, double n2)
{
    m_real = n1;
    m_imag = n2;
}
Complex::~Complex()
{

}
Complex operator + (const Complex &n1, const Complex &n2)
{
    return Complex (n1.m_real + n2.m_real, n1.m_imag + n2.m_imag);
}
Complex operator - (const Complex &n1, const Complex &n2)
{
    return Complex (n1.m_real - n2.m_real, n1.m_imag - n2.m_imag);
}
Complex operator * (const Complex &n1, const Complex &n2)
{
    return Complex ( (n1.m_real * n2.m_real) - (n1.m_imag * n2.m_imag),  (n1.m_real * n2.m_imag) + (n1.m_imag * n2.m_real));
}
Complex operator * (double num, const Complex &n)
{
    return Complex (n.m_real * num, n.m_imag * num);
}
Complex operator * (const Complex &n, double num)
{
    return Complex (n.m_real * num, n.m_imag * num);
}
Complex operator ~ (const Complex &c)
{
    return Complex (c.m_real, -c.m_imag);
}
std::istream &operator >> (std::istream &is, Complex &c)
{
    std::cout << "real: ";
    if (is >> c.m_real)
    {
        std::cout << "imaginary: ";
        is >> c.m_imag;
    }
    return is;
}
std::ostream &operator<<(std::ostream &os, const Complex &c)
{
    os << "(" << c.m_real << ", " << c.m_imag << "i)";
    return os;
}

ch11_p07.cpp
#include <iostream>
#include "complex0.h"

int main()
{
    Complex a(3.0, 4.0);
    Complex c;

    std::cout << "Enter a complex number (q to quit) :\n";
    while (std::cin >> c)
    {
        std::cout << "c is " << c<< '\n';
        std::cout << "complex conjugate is " << ~c << '\n';

        std::cout << "a is " << a << '\n';
        std::cout << "a + c is " << a + c << '\n';
        std::cout << "a - c is " << a - c << '\n';
        std::cout << "a * c is " << a * c<< '\n';
        std::cout << "2 * c is " << 2 * c << '\n';
        std::cout << "Enter a complex number (q to quit) :\n";
    }
    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Enter a complex number (q to quit) :
real: 6
imaginary: 5
c is (6, 5i)
complex conjugate is (6, -5i)
a is (3, 4i)
a + c is (9, 9i)
a - c is (-3, -1i)
a * c is (-2, 39i)
2 * c is (12, 10i)
Enter a complex number (q to quit) :
real: q
Done.

第12章 类和动态内存分配
12.1 动态内存和类
12.1.1 复习示例和静态类成员
12.1.2 特殊成员函数
12.1.3 回到Stringbad：复制构造 函数的哪里出了问题.
12.1.4 Stringbad的其他问题：赋值运算符
12.2 改进后的新String类
12.2.1 修订后的默认构造函数
12.2.2 比较成员函数
12.2.3 使用中括号表示法访问字符
12.2.4 静态类成员函数
12.2.5 进一步重载赋值运算符
12.3 在构造函数中使用new时应注意的事项
12.3.1 应该和不应该
12.3.2 包含类成员的类的逐成员复制
12.4 有关返回对象的说明
12.4.1 返回指向const对象的引用
12.4.2 返回指向非const对象的引用
12.4.3 返回对象
12.4.4 返回const对象
12.5 使用指向对象的指针
12.5.1 再谈new和delete
12.5.2 指针和对象小结
12.5.3 再谈定位new运算符
12.6 复习各种技术
12.6.1 重载<<运算符
12.6.2 转换函数
12.6.3 其构造函数使用new的类
12.7 队列模拟
12.7.1 队列类
12.7.2 Customer类
12.7.3 ATM模拟
12.8 总结
12.9 复习题
12.10 编程练习
本章内容包括：
对类成员使用动态内存分配。
隐式和显式复制构造函数。
隐式和显式重载赋值运算符。
在构造函数中使用new所必须完成的工作。
使用静态类成员。
将定位new运算符用于对象。
使用指向对象的指针。
实现队列抽象数据类型（ADT）。
12.1动态内存和类
程序清单12.1 strngbad.h
#pragma once
#ifndef STRNGBAD_H_
#define STRNGBAD_H_
#include <iostream>

class StringBad
{
private:
    char *str;
    int len;
    static int num_strings;
public:
    StringBad(const char *s);
    StringBad();
    ~StringBad();
    friend std::ostream &operator<<(std::ostream &os, const StringBad &st);
};

#endif

程序清单12.2 strngbad.cpp
#include <cstring>
#include "strngbad.h"

using std::cout;

int StringBad::num_strings = 0;

StringBad::StringBad(const char *s)
{
    len = std::strlen(s);
    str = new char[len + 1];
    std::strcpy(str, s);
    num_strings++;
    cout << num_strings << " : \"" << str << "\" object created\n";
}
StringBad::StringBad()
{
    len = 4;
    str = new char[4];
    std::strcpy(str, "C++");
    num_strings++;
    cout << num_strings << " : \"" << str << "\" default object created\n";
}
StringBad::~StringBad()
{
    cout << num_strings << " : \"" << str << "\" object deleted, ";
    --num_strings;
    cout << num_strings << " left\n";
    delete [] str;
}
std::ostream &operator<<(std::ostream &os, const StringBad &st)
{
    os << st.str;
    return os;
}
注意，不能在类声明中初始化静态成员变量。对于静态类成员，可以在类声明之外使用单独的语句来进行初始化。
int StringBad::num_strings = 0;
初始化语句指出了类型，并使用了作用域运算符，但没有使用关键字static。
初始化是在类定义文件中，而不是在类声明文件中进行的，这是因为类声明位于头文件中，
程序可能将头文件包括在其他几个文件中。如果在头文件中进行初始化，将出现多个初始化语句副本，从而引发错误。
对于不能在类声明中初始化静态数据成员的一种例外情况（见第10章）是，静态数据成员为整型或枚举型const。
程序清单12.3 vegnews.cpp
#include "strngbad.h"

using std::cout;

void callme1(StringBad &);
void callme2(StringBad);

int main()
{
    using std::endl;
    {
        cout << "Starting an inner block.\n";
        StringBad headline1("Celery Stalks at Midnight");
        StringBad headline2("Lettuce Prey");
        StringBad sports("Spinach Leaves Bowl for Dollars");
        cout << "headline1: " << headline1 << endl;
        cout << "headline2: " << headline2 << endl;
        cout << "sports: " << sports << endl;
        callme1(headline1);
        cout << "headline1: " << headline1 << endl;
        callme2(headline2);
        cout << "headline2: " << headline2 << endl;
        cout << "Initialize one object to another:\n";
        StringBad sailor = sports;
        cout << "sailor: " << sailor << endl;
        cout << "Assign one object to another:\n";
        StringBad knot;
        knot = headline1;
        cout << "knot: " << knot << endl;
        cout << "Exiting the block.\n";
    }
    cout << "End of main()\n";

    return 0;
}

void callme1(StringBad &rsb)
{
    cout << "String passed by reference:\n";
    cout << " \"" << rsb << "\"\n";
}

void callme2(StringBad sb)
{
    cout << "String passed by value:\n";
    cout << " \"" << sb << "\"\n";
}
显示结果如下

Starting an inner block.
1 : "Celery Stalks at Midnight" object created
2 : "Lettuce Prey" object created
3 : "Spinach Leaves Bowl for Dollars" object created
headline1: Celery Stalks at Midnight
headline2: Lettuce Prey
sports: Spinach Leaves Bowl for Dollars
String passed by reference:
 "Celery Stalks at Midnight"
headline1: Celery Stalks at Midnight
String passed by value:
 "Lettuce Prey"
3 : "Lettuce Prey" object deleted, 2 left
headline2: ***
Initialize one object to another:
sailor: Spinach Leaves Bowl for Dollars
Assign one object to another:
3 : "C++" default object created
knot: Celery Stalks at Midnight
Exiting the block.
3 : "Celery Stalks at Midnight" object deleted, 2 left
2 : "Spinach Leaves Bowl for Dollars" object deleted, 1 left
1 : "***" object deleted, 0 left
free(): double free detected in tcache 2
Aborted (core dumped)

12.1.2特殊成员函数
StringBad类的问题是由特殊成员函数引起的。这些成员函数是自动定义的。
具体地说，C++自动提供了下面这些成员函数：
默认构造函数，如果没有定义构造函数；
默认析构函数，如果没有定义；
复制构造函数，如果没有定义；
赋值运算符，如果没有定义
地址运算符，如果没有定义。
如果程序使用对象的方式要求这样做，编译器将生成上述最后三个函数的定义。
例如，如果您将一个对象赋给另一个对象，编译器将提供赋值运算符的定义。
结果表明，StringBad类中的问题是由隐式复制构造函数和隐式赋值运算符引起的。
隐式地址运算符返回调用对象的地址（即this指针的值）。这与我们的初衷是一致的，在此不详细讨论该成员函数。
默认析构函数不执行任何操作，因此这里也不讨论，但需要指出的是，这个类已经提供默认构造函数。
至于其他成员函数还需要进一步讨论。
C++11提供了另外两个特殊成员函数：移动构造函数和移动赋值运算符，这将在第18章讨论。
1.默认构造函数
如果没有提供任何构造函数，C++将创建默认构造函数。
也就是说，编译器将提供一个不接受任何参数，也不执行任何操作的构造函数（默认的默认构造函数）。
如果定义了构造函数，C++将不会定义默认构造函数。
默认构造函数是没有任何参数或所有参数都有默认值的构造函数。
只能有一个默认构造函数。
2.复制构造函数
复制构造函数用于将一个对象复制到新创建的对象中。它用于初始化过程中（包括按值传递参数），而不是常规的赋值过程中。
类的复制构造函数原型通常如下
class_name (const class_name &);
它接受一个指向类对象的常量引用作为参数。
3.何时调用复制构造函数
新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。
每当程序生成了对象副本时，编译器都将使用复制构造函数。
具体地说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。
按值传递意味着创建原始变量的个副本，编译器生成临时对象时，也将使用复制构造函数。
4.默认的复制构造函数的功能
默认的复制构造函数逐个复制非静态成员，复制的是成员的值。
如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。
12.1.4 赋值运算符
C++允许类对象赋值，这是通过自动为类重载赋值运算符实现的，这种运算符的原型如下：
class_name & class_name::operator = (const class_name &);
它接受并返回一个指向类对象的引用。
1.赋值运算符的功能以及何时使用它
将已有的对象赋给另一个对象时，将使用重载的赋值运算。
初始化对象时，并不一定会使用赋值运算符，也有可能使用复制构造函数。
与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制。
如果成员本身就是类对象，则程序将使用为这个类定义的赋值运算符来复制该成员，但静态数据成员不受影响。
3.解决赋值的问题
对于由于默认赋值运算符不合适而导致的问题，解决办法是提供赋值运算符（进行深度复制）定义。
其实现与复制构造函数相似，但也有一些差别。
由于目标对象可能引用了以前分配的数据，所以函数应使用delete[]来释放这些数据。
函数应当避免将对象赋给自身；否则，给对象重新赋值前，释放内存操作可能删除对象的内容。
函数返回一个指向调用对象的引用。
12.2改进后的新String类
可以将成员函数声明为静态的，函数声明必须包含关键字static。
不能通过对象调用静态成员函数；实际上，静态成员函数甚至不能使用this指针。
如果静态成员函数是在公有部分声明的，则可以使用类名和作用域解析运算符来调用它。
由于静态成员函数不与特定的对象相关联，因此只能使用静态数据成员。
程序清单12.4 string1.h
#pragma once
#ifndef STRNG1_H_
#define STRNG1_H_
#include <iostream>

using std::ostream;
using std::istream;

class String
{
private:
    char *str;
    int len;
    static int num_strings;
    static const int CINLIM = 128;
public:
    String(const char *s);
    String();
    String(const String &);
    ~String();
    int length() const
    {
        return len;
    }
    String &operator=(const String &);
    String &operator=(const char *);
    char &operator [] (int i);
    const char &operator [] (int i) const;

    friend bool operator<(const String &st1, const String &st2);
    friend bool operator>(const String &st1, const String &st2);
    friend bool operator==(const String &st1, const String &st2);
    friend ostream &operator<<(ostream &os, const String &st);
    friend istream &operator>>(istream &is, String &st);

    static int HowMany();
};

#endif

程序清单12.5 string1.cpp
#include <cstring>
#include "string1.h"

using std::cin;
using std::cout;

int String::num_strings = 0;

int String::HowMany()
{
    return num_strings;
}

String::String(const char *s)
{
    len = std::strlen(s);
    str = new char[len + 1];
    std::strcpy(str, s);
    num_strings++;
}

String::String()
{
    len = 0;
    str = new char[1];
    str[0] = '\0';
    num_strings++;
}

String::String(const String &st)
{
    len = st.len;
    str = new char[len + 1];
    std::strcpy(str, st.str);
    num_strings++;
}
String::~String()
{
    --num_strings;
    delete[] str;
}
String &String::operator= (const String &st)
{
    if (this == &st)
    {
        return *this;
    }
    delete[] str;
    len = st.len;
    str = new char[len + 1];
    std::strcpy(str, st.str);
    return *this;
}
String &String::operator=(const char *s)
{
    delete[] str;
    len = std::strlen(s);
    str = new char[len + 1];
    std::strcpy(str, s);
    return *this;
}
char &String::operator [] (int i)
{
    return str[i];
}
const char &String::operator [] (int i) const
{
    return str[i];
}
bool operator<(const String &st1, const String &st2)
{
    return (std::strcmp(st1.str, st2.str) < 0);
}
bool operator>(const String &st1, const String &st2)
{
    return (std::strcmp(st1.str, st2.str) > 0);
}
bool operator==(const String &st1, const String &st2)
{
    return (std::strcmp(st1.str, st2.str) == 0);
}
ostream &operator<<(ostream &os, const String &st)
{
    os << st.str;
    return os;
}
istream &operator>>(istream &is, String &st)
{
    char temp[String::CINLIM];
    is.get(temp, String::CINLIM);
    if (is)
    {
        st = temp;
    }
    while (is && is.get() != '\n')
    {
        continue;
    }
    return is;
}

程序清单12.6 sayings1.cpp
#include "string1.h"

const int ArSize = 10;
const int MaxLen = 128;

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    String name;
    cout << "Hi, what's your name?\n>> ";
    cin >> name;
    cout << name << ", please enter up to " << ArSize << " short sayings <empty line to quit>:\n";
    String sayings[ArSize];
    char temp[MaxLen];
    int i;
    for (i = 0; i < ArSize; i++)
    {
        cout << i + 1 << ": ";
        cin.get(temp, MaxLen);
        while (cin && cin.get() != '\n')
        {
            continue;
        }
        if (!cin || temp[0] == '\0')
        {
            break;
        }
        else
        {
            sayings[i] = temp;
        }
    }
    int total = i;
    if (total > 0)
    {
        cout << "Here are your sayings:\n";
        for (i = 0; i < total; i++)
        {
            cout << sayings[i][0] << ": " << sayings[i] << endl;
        }
        int shortest = 0;
        int first = 0;
        for (i = 1; i < total; i++)
        {
            if (sayings[i].length() < sayings[shortest].length())
            {
                shortest = i;
            }
            if (sayings[i] < sayings[first])
            {
                first = i;
            }
        }
        cout << "Shortest saying:\n" << sayings[shortest] << endl;
        cout << "First alphabetically:\n" << sayings[first] << endl;
        cout << "This program used " << String::HowMany() << " String objects.\n";
    }
    else
    {
        cout << "No input!\n";
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Hi, what's your name?
>> WEIYAYUN
WEIYAYUN, please enter up to 10 short sayings <empty line to quit>:
1: Hello, World!
2: Peter Smith
3: Mike Pence
4: Java
5: C++
6: C
7: PYTHON
8: RUST
9: D
10: SWIFT
Here are your sayings:
H: Hello, World!
P: Peter Smith
M: Mike Pence
J: Java
C: C++
C: C
P: PYTHON
R: RUST
D: D
S: SWIFT
Shortest saying:
C
First alphabetically:
C
This program used 11 String objects.
Done.

12.3在构造面数中使用new时应注意的事项
如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete。
new对应于delete，new[]对应于delete[]。
如果有多个构造函数，则必须以相同的方式使用new，要么都带中括号，要么都不带。
因为只有一个析构函数，所有的构造函数都必须与它兼容。
然而，可以在一个构造函数中使用new初始化指针，而在另一个构造函数中将指针初始化为nullptr，
这是因为delete（无论是带中括号还是不带中括号）可以用于空指针。
应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。
另外，还应该更新所有受影响的静态类成员。
应当定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象。
12.4有关返回对象的说明
当成员函数或独立的函数返回对象时，有几种返回方式可供选择。
可以返回指向对象的引用、指向对象的const引用或const对象。
返回对象将调用复制构造函数，而返回引用不会。
如果被返回的对象是被调用函数中的局部变量，则不应按引用方式返回它，
因为在被调用函数执行完毕时，局部对象将调用其析构函数。
因此，当控制权回到调用函数时，引用指向的对象将不再存在。在这种情况下，应返回对象而不是引用。
如果方法或函数要返回一个没有公有复制构造函数的类（如ostream类）的对象，它必须返回一个指向这种对象的引用。
最后，有些方法和函数（如重载的赋值运算符）可以返回对象，也可以返回指向对象的引用，
在这种情况下，应首选引用，因为其效率更高。
12.5使用指向对象的指针
程序清单12.7 sayings2.cpp
#include <cstdlib>
#include <ctime>
#include "string1.h"

const int ArSize = 10;
const int MaxLen = 128;

int main()
{
    using namespace std;
    String name;
    cout << "Hi, what's your name?\n>> ";
    cin >> name;
    cout << name << ", please enter up to " << ArSize << " short sayings <empty line to quit>:\n";
    String sayings[ArSize];
    char temp[MaxLen];
    int i;
    for (i = 0; i < ArSize; i++)
    {
        cout << i + 1 << ": ";
        cin.get(temp, MaxLen);
        while (cin && cin.get() != '\n')
        {
            continue;
        }
        if (!cin || temp[0] == '\0')
        {
            break;
        }
        else
        {
            sayings[i] = temp;
        }
    }
    int total = i;
    if (total > 0)
    {
        cout << "Here are your sayings:\n";
        for (i = 0; i < total; i++)
        {
            cout << sayings[i] << "\n";
        }
        String *shortest = &sayings[0];
        String *first = &sayings[0];
        for (i = 1; i < total; i++)
        {
            if (sayings[i].length() < shortest->length())
            {
                shortest = &sayings[i];
            }
            if (sayings[i] < *first)
            {
                first = &sayings[i];
            }
        }
        cout << "Shortest saying: \n" << *shortest << endl;
        cout << "First alphabetically: \n" << * first << endl;
        srand(time(nullptr));
        int choice = rand() % total;
        String *favorite = new String(sayings[choice]);
        cout << "My favorite saying: \n" << *favorite << endl;
        delete favorite;
    }
    else
    {
        cout << "No input!\n";
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Hi, what's your name?
>> WEIYAYUN
WEIYAYUN, please enter up to 10 short sayings <empty line to quit>:
1: Apple
2: Orange
3: Egg
4: Water
5: Sun
6: C++
7: Java
8:
Here are your sayings:
Apple
Orange
Egg
Water
Sun
C++
Java
Shortest saying:
Egg
First alphabetically:
Apple
My favorite saying:
Water
Done.

在下述情况下析构函数将被调用（参见图12.4）。
如果对象是自动变量，则当执行完定义该对象的程序块时，将调用该对象的析构函数。
如果对象是静态变量，则在程序结束时将调用对象的析构函数。
如果对象是用new创建的，则仅当您显式使用delete删除对象时，其析构函数才会被调用。
12.5.2指针和对象小结
使用对象指针时，需要注意几点（参见图12.5）：
使用常规表示法来声明指向对象的指针；
可以将指针初始化为指向已有的对象；
可以使用new来初始化指针，这将创建一个新的对象；
对类使用new将调用相应的类构造函数来初始化新创建的对象；
可以使用->运算符通过指针访问类方法；
可以对对象指针应用解除引用运算符（*）来获得对象。
12.5.3再谈定位new运算符
程序清单12.8 placenew1.cpp
#include <iostream>
#include <string>
#include <new>

using namespace std;

const int BUF = 512;

class JustTesting
{
private:
    string words;
    int number;
public:
    JustTesting(const string &s = "Just Testing", int n = 0)
    {
        words = s;
        number = n;
        cout << words << " constructed\n";
    }
    ~JustTesting()
    {
        cout << words << " destroyed\n";
    }
    void Show() const
    {
        cout << words << ", " << number << endl;
    }
};

int main()
{
    char *buffer = new char[BUF];
    JustTesting *pc1, *pc2;
    pc1 = new (buffer) JustTesting;
    pc2 = new JustTesting("Heap1", 20);
    cout << "Memory block addresses:\n" << "buffer: " << (void *) buffer << " pc1: " << pc1;
    cout << " pc2: " << pc2 << endl;
    cout << "Memory contents:\n";
    cout << "pc1 : ";
    pc1->Show();
    cout << "pc2 : ";
    pc2->Show();
    JustTesting *pc3, *pc4;
    pc3 = new (buffer) JustTesting("Bad Idea", 6);
    pc4 = new JustTesting("Heap2", 10);
    cout << "Memory block addresses:\n" << " pc3: " << pc3 << " pc4: " << pc4 << endl;
    cout << "Memory contents : \n";
    cout << "pc3 : ";
    pc3->Show();
    cout << "pc4 : ";
    pc4->Show();
    delete pc2;
    delete pc4;
    delete[] buffer;
    cout << "Done.\n";

    return 0;
}
显示结果如下
Just Testing constructed
Heap1 constructed
Memory block addresses:
buffer: 0x5646411a0eb0 pc1: 0x5646411a0eb0 pc2: 0x5646411a14d0
Memory contents:
pc1 : Just Testing, 0
pc2 : Heap1, 20
Bad Idea constructed
Heap2 constructed
Memory block addresses:
 pc3: 0x5646411a0eb0 pc4: 0x5646411a1500
Memory contents :
pc3 : Bad Idea, 6
pc4 : Heap2, 10
Heap1 destroyed
Heap2 destroyed
Done.

程序清单12.9 placenew2.cpp
#include <iostream>
#include <string>
#include <new>

using namespace std;

const int BUF = 512;

class JustTesting
{
private:
    string words;
    int number;
public:
    JustTesting(const string &s = "Just Testing", int n = 0)
    {
        words = s;
        number = n;
        cout << words << " constructed\n";
    }
    ~JustTesting()
    {
        cout << words << " destroyed\n";
    }
    void Show() const
    {
        cout << words << ", " << number << endl;
    }
};

int main()
{
    char *buffer = new char[BUF];
    JustTesting *pc1, *pc2;
    pc1 = new (buffer) JustTesting;
    pc2 = new JustTesting("Heap1", 20);
    cout << "Memory block addresses:\n" << "buffer: " << (void *) buffer << " pc1: " << pc1;
    cout << " pc2: " << pc2 << endl;
    cout << "Memory contents:\n";
    cout << "pc1 : ";
    pc1->Show();
    cout << "pc2 : ";
    pc2->Show();
    JustTesting *pc3, *pc4;
    pc3 = new (buffer + sizeof(JustTesting)) JustTesting("Bad Idea", 6);
    pc4 = new JustTesting("Heap2", 10);
    cout << "Memory block addresses:\n" << "pc3: " << pc3 << " pc4: " << pc4 << endl;
    cout << "Memory contents : \n";
    cout << "pc3 : ";
    pc3->Show();
    cout << "pc4 : ";
    pc4->Show();
    delete pc2;
    delete pc4;
    pc3->~JustTesting();
    pc1->~JustTesting();
    delete[] buffer;
    cout << "Done.\n";

    return 0;
}
显示结果如下
Just Testing constructed
Heap1 constructed
Memory block addresses:
buffer: 0x56100f686eb0 pc1: 0x56100f686eb0 pc2: 0x56100f6874d0
Memory contents:
pc1 : Just Testing, 0
pc2 : Heap1, 20
Bad Idea constructed
Heap2 constructed
Memory block addresses:
pc3: 0x56100f686ed8 pc4: 0x56100f687500
Memory contents :
pc3 : Bad Idea, 6
pc4 : Heap2, 10
Heap1 destroyed
Heap2 destroyed
Bad Idea destroyed
Just Testing destroyed
Done.

在类声明中声明的结构、类或枚举被称为是被嵌套在类中，其作用域为整个类。
这种声明不会创建数据对象，而只是指定了可以在类中使用的类型。
如果声明是在类的私有部分进行的，则只能在这个类使用被声明的类型；
如果声明是在公有部分进行的，则可以从类的外部通过作用域解析运算符使用被声明的类型。
例如，如果Node是在Queue类的公有部分声明的，则可以在类的外面声明Queue:Node类型的变量。
使用const声明的常量，可以对它进行初始化，但不能给它赋值。
从概念上说，调用构造函数时，对象将在括号中的代码执行之前被创建。
然后，程序流程进入到括号中，使用常规的赋值方式将值存储到内存中。
因此，对于const数据成员，必须在执行到构造函数体之前，即创建对象时进行初始化。
C++提供了一种特殊的语法来完成上述工作，它叫做成员初始化列表（member initializer list）。
成员初始化列表由逗号分隔的初始化列表组成（前面带冒号）。它位于参数列表的右括号之后、函数体左括号之前。
如果数据成员的名称为mdata，并需要将它初始化为val，则初始化器为mdata (val)。
通常，初值可以是常量或构造函数的参数列表中的参数。
这种方法并不限于初始化const数据成员，也可以用来初始化正常的数据成员。
只有构造函数可以使用这种初始化列表语法。对于const类成员，必须使用这种语法。
另外，对于被声明为引用的类成员，也必须使用这种语法。
这是因为引用与const数据类似，只能在被创建时进行初始化。
对于简单数据成员，使用成员初始化列表和在函数体中使用赋值没有什么区别。
然而，对于本身就是类对象的成员来说，使用成员初始化列表的效率更高。
成员初始化列表的语法
如果Classy是一个类，而mem1、mem2和mem3都是这个类的数据成员，则类构造函数可以使用如下的语法来初始化数据成员：
Classy::Crassy(int n, int m) : mem1(n), mem2(0), mem3 (n*m + 2)
{
    // ...
}
上述代码将mem1初始化为n，将mem2初始化为0，将mem3初始化为n*m+2。
从概念上说，这些初始化工作是在对象创建时完成的，此时还未执行括号中的任何代码。请注意以下几点：
这种格式只能用于构造函数；
必须用这种格式来初始化非静态const数据成员（至少在C++11之前是这样的）；
必须用这种格式来初始化引用数据成员。
数据成员被初始化的顺序与它们出现在类声明中的顺序相同，与初始化器中的排列顺序无关。
不能将成员初始化列表语法用于构造函数之外的其他类方法。
成员初始化列表使用的括号方式也可用于常规初始化。也就是说，如果愿意，可以将下述代码：
int games=162;
double talk =2.71828;
替换为：
int games (162);
double talk (2.71828);
这使得初始化内置类型就像初始化类对象一样。
C++11允许您以更直观的方式进行初始化：
class Classy
{
    int mem1=10;   //in-class initialization
    const int mem2 = 20;   //in-class initialization
    // ...
}
这与在构造函数中使用成员初始化列表等价：
Classy::Classy() : mem1(10), mem2 (20)
{
    // ...
}
成员mem1和mem2将分别被初始化为10和20，除非调用了使用成员初始化列表的构造函数，
在这种情况下，实际列表将覆盖这些默认初始值：
classy::classy (int n) : mem1(n)
{
    // ...
}
在这里，构造函数将使用n来初始化mem1，但mem2仍被设置为20。
程序清单12.10 queue.h
#pragma once
#ifndef QUEUE_H_  
#define QUEUE_H_ 

class Customer
{
private:
	long arrive;
	int processtime;
public:
	Customer() { arrive = processtime = 0; }
	void set(long when);
	long when() const { return arrive; }
	int ptime() const { return processtime; }
};

typedef Customer Item;

class Queue
{
private:
	struct Node { Item item; struct Node* next; };
	enum { Q_SIZE = 10 };
	Node* front;
	Node* rear;
	int items;
	const int qsize;
					 
	Queue(const Queue & q) : qsize(0) { }
	Queue & operator=(const Queue & q) { return *this; }
public:
	Queue(int qs = Q_SIZE);
	~Queue();
	bool isempty() const;
	bool isfull() const;
	int queuecount() const;
	bool enqueue(const Item &item);
	bool dequeue(Item &item);
};

#endif

程序清单12.11 queue.cpp
#include <cstdlib>
#include "queue.h"

Queue::Queue(int qs) : qsize(qs)
{
    front = rear = NULL;
    items = 0;
}

Queue::~Queue()
{
    Node *next;
    while (front != NULL)
    {
        next = front->next;
        delete front;
        front = next;
    }
}

bool Queue::isempty() const
{
    return items == 0;
}

bool Queue::isfull() const
{
    return items == qsize;
}

int Queue::queuecount() const
{
    return items;
}
bool Queue::enqueue(const Item &item)
{
    if (isfull())
    {
        return false;
    }
    Node *add = new Node;

    add->item = item;
    add->next = NULL;
    if (items == 0)
    {
        front = add;
        rear = add;
    }
    else
    {
        rear->next = add;
        rear = add;
    }
    items++;
    return true;
}
bool Queue::dequeue(Item &item)
{
    if (isempty())
    {
        return false;
    }
    item = front->item;
    items--;
    Node *next = front->next;
    delete front;
    front = next;
    if (items == 0)
    {
        front = NULL;
        rear = NULL;
    }
    return true;
}
void Customer::set(long when)
{
    processtime = std::rand() % 3 + 1;
    arrive = when;
}

程序清单12.12 usequeue.cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
#include "queue.h"

const int MIN_PER_HR = 60;

bool newcustomer(double x);

int main()
{
    using std::cin;
    using std::cout;
    using std::endl;
    using std::ios_base;

    std::srand(std::time(nullptr));

    cout << "Case Study: Bank of Heather Automatic Teller\n";
    cout << "Enter maximum size of queue: ";
    int qs;
    cin >> qs;
    Queue line(qs);

    cout << "Enter the number of simulation hours: ";
    int hours;
    cin >> hours;
    long cyclelimit = MIN_PER_HR * hours;

    cout << "Enter the average number of customers per hour: ";
    double perhour;
    cin >> perhour;
    double min_per_cust;
    min_per_cust = MIN_PER_HR / perhour;

    Item temp;
    long turnaways = 0;
    long customers = 0;
    long served = 0;
    long sum_line = 0;
    int wait_time = 0;
    long line_wait = 0;

    for (long cycle = 0; cycle < cyclelimit; cycle++)
    {
        if (newcustomer(min_per_cust))
        {
            if (line.isfull())
            {
                turnaways++;
            }
            else
            {
                customers++;
                temp.set(cycle);
                line.enqueue(temp);
            }
        }
        if (wait_time <= 0 && !line.isempty())
        {
            line.dequeue(temp);
            wait_time = temp.ptime();
            line_wait += cycle - temp.when();
            served++;
        }
        if (wait_time > 0)
        {
            wait_time--;
        }
        sum_line += line.queuecount();
    }

    if (customers > 0)
    {
        cout << "customers accepted: " << customers << endl;
        cout << "customers served: " << served << endl;
        cout << "customers turnaways: " << turnaways << endl;
        cout.precision(2);
        cout.setf(ios_base::fixed, ios_base::floatfield);
        cout << "average queue size: " << (double)sum_line / cyclelimit << endl;
        cout << "average wait time: " << (double)line_wait / served << " minutes\n";
    }
    else
    {
        cout << "No customers!\n";
    }
    cout << "Done.\n";

    return 0;
}
bool newcustomer(double x)
{
    return ( (std::rand() * x) / RAND_MAX < 1);
}
显示结果如下
Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 10
Enter the number of simulation hours: 3
Enter the average number of customers per hour: 30
customers accepted: 85
customers served: 80
customers turnaways: 1
average queue size: 2.76
average wait time: 5.71 minutes
Done.

Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 10
Enter the number of simulation hours: 3
Enter the average number of customers per hour: 60
customers accepted: 98
customers served: 88
customers turnaways: 82
average queue size: 8.84
average wait time: 16.80 minutes
Done.

Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 10
Enter the number of simulation hours: 3
Enter the average number of customers per hour: 90
customers accepted: 103
customers served: 94
customers turnaways: 77
average queue size: 8.83
average wait time: 16.31 minutes
Done.

12.8总结
在类构造函数中，可以使用new为数据分配内存；然后将内存地址赋给类成员。
这样，类便可以处理长度不同的字符串，而不用在类设计时提前固定数组的长度。
如果对象包含指向new分配的内存的指针成员，则释放对象的内存并不会自动释放指针成员指向的内存。
因此如果在类构造函数中使用了new来分配内存，则在类析构函数中需要使用delete来释放new分配的内存。
这样，当对象过期时将自动释放其指针成员指向的内存。
如果对象包含指向new分配的内存的指针成员，则将一个对象初始化为另一个对象或将一个对象赋给另一个对象时也会出现问题。
在默认情况下，C++逐个对成员进行初始化和赋值，这意味着被初始化或被赋值的对象的成员将与原始对象完全相同。
如果原始对象的成员指向一个数据块，则副本成员将指向同一个数据块。
当程序最终删除这两个对象时，类的析构函数将试图删除同一个内存数据块两次，这将出错。解决方法是：
定义一个特殊的复制构造函数来重新定义初始化，并重载赋值运算符。
在上述任何一种情况下，新的定义都将创建指向数据的副本；并使新对象指向这些副本。
这样，旧对象和新对象都将引用独立的、相同的数据，而不会重叠。由于同样的原因，必须定义赋值运算符。
对于每一种情况，最终目的都是执行深度复制，也就是说，复制实际的数据，而不仅仅是复制指向数据的指针。
对象的存储持续性为自动或外部时，在它不再存在时将自动调用其析构函数。
如果使用new运算符为对象分配内存，并将其地址赋给一个指针，则当您将delete用于该指针时将自动为对象调用析构函数。
然而；如果使用定位new运算符（而不是常规new运算符）为类对象分配内存，
则必须负责显式地为该对象调用析构函数，方法是使用指向该对象的指针调用析构函数。
C++允许在类中包含结构、类和枚举定义。这些嵌套类型的作用域为整个类，
这意味着它们被局限于类中，不会与其他地方定义的同名结构、类和校举发生冲突。
c++为类构造函数提供了一种可用来初始化数据成员的特殊语法。
这种语法包括冒号和由逗号分隔的初始化列表，被放在构造函数参数的右括号后，函数体的左括号之前。
每一个初始化器都由被初始化的成员的名称和包含初始值的括号组成。
从概念上来说，这些初始化操作是在对象创建时进行的，此时函数体中的语句还没有执行。
如果数据成是非静态const成员或引用，则必须采用这种格式，但可将C++11新增的类内初始化用于非静态const成员。
C++11允许类内初始化，即在类定义中进行初始化。这与使用成员初始化列表等价。
然而，使用成员初始化列表的构造函数将覆盖相应的类内初始化。
12.9复习题
1.假设String类有如下私有成员：
class String
{
private:
    char *str;
    int len;
    // ...
}
a.下述默认构造函数有什么问题？
String::String() {}
语法是正确的，但该构造函数没有将str指针初始化。该构造函数应将指针设置成nullptr或使用new[]来初始化它。
b.下述构造函数有什么问题？
String::String(const char *s)
{
    str = s;
    len = strlen(s);
}
该构造函数没有创建新的字符串，而只是复制了原有字符串的地址。它应当使用new[]和strcpy()。
c.下述构造函数有什么问题？
String::String(const char *s)
{
    strcpy(str, s);
    len = strlen(s);
}
它复制了字符串，但没有给它分配存储空间，应先使用new char[len + 1]来分配适当数量的内存。

2.如果您定义了一个类，其指针成员是使用new初始化的，请指出可能出现的3个问题以及如何纠正这些问题。
首先，当这种类型的对象过期时，对象的指针成员指向的数据仍将保留在内存中，
这将占用空间，同时不可访问，因为指针已经丢失。
可以让类析构函数删除构造函数中new分配的内存，来解决这种问题。
其次，析构函数释放这种内存后，如果程序将这样的对象初始化为另一个对象，则析构函数将试图释放这些内存两次。
这是因为将一个对象初始化为另一个对象的默认初始化，将复制指针值，但不复制指向的数据，这将使两个指针指向相同的数据。
解决方法是，定义一个复制构造函数，使初始化复制指向的数据。
第三，将一个对象赋给另一个对象也将导致两个指针指向相同的数据。
解决方法是重载赋值运算符，使之复制数据，而不是指针。

3.如果没有显式提供类方法，编译器将自动生成哪些类方法？请描述这些隐式生成的函数的行为。
C++自动提供下面的成员函数：
如果没有定义构造函数，将提供默认构造函数。
如果没有定义复制构造函数，将提供复制构造函数。
如果没有定义赋值运算符，将提供赋值运算符。
如果没有定义析构函数，将提供默认析构函数.
如果没有定义地址运算符，将提供地址运算符。
默认构造函数不完成任何工作，但使得能够声明数组和未初始化的对象。
默认复制构造函数和默认赋值运算符使用成员赋值。
默认析构函数也不完成任何工作。隐式地址运算符返回调用对象的地址（即this指针的值）。

4.找出并改正下述类声明中的错误：
class nifty
{
                                    //应该声明private:
    char personality[];   //应该声明为字符数组或字符指针或string对象
    int talents;
                                    //应该声明public:
    nifty ();
    nifty (char * s);
    ostream & operator << (ostream & os, nifty & n);
};
nifty::nifty()
{
    personality = NULL;
    talents = 0;
}
nifty:nifty(char * s)
{
    personality = new char[strlen(s)];
    personality = s;
    talents = 0;
}
ostream & nifty::operator << (ostream & os, nifty & n)
{
    os << n;
}
修改后
#include <string>

class nifty
{
private:
    std::string personality;
    int talents;
public:
    nifty();
    nifty(const char * s);
    friend ostream & operator << (ostream & os, const nifty & n);
};

nifty::nifty()
{
    personality = "";
    talents = 0;
}
nifty::nifty(const char *s)
{
    personality = s;
    talents = 0;
}
ostream & operator << (ostream & os, const nifty & n)
{
    os << n.personality << '\n';
    os << n.talents << '\n';
    return os;
}
5.对于下面的类声明：
class Golfer
{
private:
    char * fullname;
    int games;
    int * scores;
public:
    Golfer();
    Golfer (const char * name, int g = 0);
    Golfer (const Golfer & g);
    ~Golfer();
};
a.下列各条语句将调用哪些类方法？
Golfer nancy;   默认构造函数Golfer();
Golfer lulu ("Little Lulu");   Golfer (const char * name, int g);
Golfer roy ("Roy Hobbs", 12);   Golfer (const char * name, int g);
Golfer * par =new Golfer;    默认构造函数Golfer();
Golfer next = lulu;   复制构造函数 Golfer (const Golfer & g);
Golfer hazzard = "Weed Thwacker";   Golfer (const char * name, int g);
*par = nancy;   默认赋值运算符
nancy = "Nancy Putter";   先构造临时对象，再赋值 Golfer (const char * name, int g); 默认赋值运算符
b.很明显，类需要有另外几个方法才能更有用，但是类需要哪些方法才能防止数据被损坏呢？
定义复制构造函数，重载赋值运算符，处理好指针成员的数据复制问题。

12.10编程练习
1.对于下面的类声明：
给这个类提供实现，并编写一个使用所有成员函数的小程序。
cow.h
#pragma once
#ifndef COW_H_
#define COW_H_

#include <iostream>

using std::ostream;

class Cow
{
    char name[20];
    char *hobby;
    double weight;
public:
    Cow();
    Cow(const char *nm, const char *ho, double wt);
    Cow(const Cow &c);
    ~Cow();
    Cow & operator = (const Cow & c);
    friend ostream & operator << (ostream & os, const Cow & c);
};

#endif

cow.cpp
#include <iostream>
#include <cstring>
#include "cow.h"

Cow::Cow()
{
    std::cout << "Default constructor called" << std::endl;

    name[0] = '\0';
    hobby = new char[1];
    hobby[0] = '\0';
    weight = 0;
}

Cow::Cow(const char *nm, const char *ho, double wt)
{
    std::cout << "Constructor with parameters was called" << std::endl;

    strncpy(name, nm, 20);
    hobby = new char[strlen(ho) + 1];
    strcpy(hobby, ho);
    weight = wt;
}

Cow::Cow(const Cow &c)
{
    std::cout << "Copy Constructor called" << std::endl;

    strncpy(name, c.name, 20);
    hobby = new char[strlen(c.hobby) + 1];
    strcpy(hobby, c.hobby);
    weight = c.weight;
}

Cow::~Cow()
{
    std::cout << name << " Called the destructor" << std::endl;

    delete[] hobby;
}

Cow &Cow::operator = (const Cow &c)
{
    std::cout << "Assignment operator called" << std::endl;

    if (this == &c)
    {
        return *this;
    }
    delete[] hobby;

    strncpy(name, c.name, 20);
    hobby = new char[strlen(c.hobby) + 1];
    strcpy(hobby, c.hobby);
    weight = c.weight;

    return *this;
}
ostream &operator<<(ostream &os, const Cow &c)
{
    os << "Name: " << c.name << '\n';
    os << "Hobby: " << c.hobby << '\n';
    os << "Weight: " << c.weight << "\n\n";
    return os;
}

ch12_p01.cpp
#include <iostream>
#include "cow.h"

int main()
{
    {
        std::cout << "Cow 1:\n";
        Cow Cow1;

        std::cout << "Cow 2:\n";
        Cow Cow2("Cow2", "HOBBY", 89);

        std::cout << "Cow 3:\n";
        Cow Cow3 = Cow2;

        std::cout << "Cow 4:\n";
        Cow Cow4;
        Cow4 = Cow2;


        std::cout << std::endl;

        std::cout << "Cow 1:\n" << Cow1;
        std::cout << "Cow 2:\n" << Cow2;
        std::cout << "Cow 3:\n" << Cow3;
        std::cout << "Cow 4:\n" << Cow4;

        std::cout << std::endl;
    }

    return 0;
}
显示结果如下
Cow 1:
Default constructor called
Cow 2:
Constructor with parameters was called
Cow 3:
Copy Constructor called
Cow 4:
Default constructor called
Assignment operator called

Cow 1:
Name:
Hobby:
Weight: 0

Cow 2:
Name: Cow2
Hobby: HOBBY
Weight: 89

Cow 3:
Name: Cow2
Hobby: HOBBY
Weight: 89

Cow 4:
Name: Cow2
Hobby: HOBBY
Weight: 89


Cow2 Called the destructor
Cow2 Called the destructor
Cow2 Called the destructor
 Called the destructor

2.通过完成下面的工作来改进String类声明。
a.对+运算符进行重载，使之可将两个字符串合并成1个。
b.提供一个成员函数，将字符串中所有的字母字符转换为小写。
c.提供一个成员函数，将字符串中所有字母字符转换成大写。
d.提供一个这样的成员函数，它接受一个char参数，返回该字符在字符串中出现的次数。
使用下面的程序来测试您的工作：
string2.h
#pragma once
#ifndef STRNG2_H_
#define STRNG2_H_
#include <iostream>

using std::ostream;
using std::istream;

class String
{
private:
    char *str;
    int len;
    static int num_strings;
    static const int CINLIM = 128;
public:
    String(const char *s);
    String();
    String(const String &);
    ~String();
    int length() const
    {
        return len;
    }
    void stringup();
    void stringlow();
    int has(char ch);
    String &operator=(const String &);
    String &operator=(const char *);
    char &operator [] (int i);
    const char &operator [] (int i) const;

    friend bool operator<(const String &st1, const String &st2);
    friend bool operator>(const String &st1, const String &st2);
    friend bool operator==(const String &st1, const String &st2);
    friend ostream &operator<<(ostream &os, const String &st);
    friend istream &operator>>(istream &is, String &st);
    friend String operator + (const String &st1, const String &st2);
    friend String operator + (const char *s, const String &st);
    friend String operator + (const String &st, const char *s);

    static int HowMany();
};

#endif

string2.cpp
#include <cstring>
#include <cctype>
#include "string2.h"

using std::cin;
using std::cout;

int String::num_strings = 0;

int String::HowMany()
{
    return num_strings;
}

String::String(const char *s)
{
    len = std::strlen(s);
    str = new char[len + 1];
    std::strcpy(str, s);
    num_strings++;
}

String::String()
{
    len = 0;
    str = new char[1];
    str[0] = '\0';
    num_strings++;
}

String::String(const String &st)
{
    len = st.len;
    str = new char[len + 1];
    std::strcpy(str, st.str);
    num_strings++;
}
String::~String()
{
    --num_strings;
    delete[] str;
}
void String::stringup()
{
    for (int i = 0; str[i] != '\0'; i++)
    {
        str[i] = toupper(str[i]);
    }
}
void String::stringlow()
{
    for (int i = 0; str[i] != '\0'; i++)
    {
        str[i] = tolower(str[i]);
    }
}
int String::has(char ch)
{
    int count = 0;
    for (int i = 0; i < len; i++)
    {
        if (str[i] == ch)
        {
            count++;
        }
    }
    return count;
}
String &String::operator= (const String &st)
{
    if (this == &st)
    {
        return *this;
    }
    delete[] str;
    len = st.len;
    str = new char[len + 1];
    std::strcpy(str, st.str);
    return *this;
}
String &String::operator=(const char *s)
{
    delete[] str;
    len = std::strlen(s);
    str = new char[len + 1];
    std::strcpy(str, s);
    return *this;
}
char &String::operator [] (int i)
{
    return str[i];
}
const char &String::operator [] (int i) const
{
    return str[i];
}
bool operator<(const String &st1, const String &st2)
{
    return (std::strcmp(st1.str, st2.str) < 0);
}
bool operator>(const String &st1, const String &st2)
{
    return (std::strcmp(st1.str, st2.str) > 0);
}
bool operator==(const String &st1, const String &st2)
{
    return (std::strcmp(st1.str, st2.str) == 0);
}

String operator + (const String &st1, const String &st2)
{
    String temp;
    delete [] temp.str;

    temp.len = strlen(st1.str) + strlen(st2.str);
    temp.str = new char[temp.len + 1];
    strcat(strcpy(temp.str, st1.str), st2.str);

    return temp;
}
String operator+(const char *s, const String &st)
{
    String temp;
    delete[] temp.str;

    temp.len = strlen(s) + st.len;
    temp.str = new char[temp.len + 1];
    strcat(strcpy(temp.str, s), st.str);

    return temp;
}
String operator+(const String &st, const char *s)
{
    String temp;
    delete[] temp.str;

    temp.len = strlen(s) + st.len;
    temp.str = new char[temp.len + 1];
    strcat(strcpy(temp.str, st.str), s);

    return temp;
}
ostream &operator<<(ostream &os, const String &st)
{
    os << st.str;
    return os;
}
istream &operator>>(istream &is, String &st)
{
    char temp[String::CINLIM];
    is.get(temp, String::CINLIM);
    if (is)
    {
        st = temp;
    }
    while (is && is.get() != '\n')
    {
        continue;
    }
    return is;
}

ch12_p02.cpp
#include "string2.h"

const int ArSize = 10;
const int MaxLen = 128;

int main()
{
    String s1(" and I am a C++ student.");
    String s2 = "Please enter your name: ";
    String s3;

    std::cout << s2;
    std::cin >> s3;
    s2 = "My name is " + s3;

    std::cout << s2 << "." << std::endl;
    s2 = s2 + s1;

    s2.stringup();

    std::cout << "The string\n" << s2 << "\ncontains " << s2.has('A');
    std::cout << " 'A' characters in it." << std::endl;
    std::cout << std::endl;

    s1 = "red";
    String rgb[3] = { String(s1), String("green"), String("blue") };

    std::cout << "Enter the name of a primary color for mixing light: ";

    String ans;
    bool success = false;

    while (std::cin >> ans)
    {
        ans.stringlow();
        for (int i = 0; i < 3; i++)
        {
            if (ans == rgb[i])
            {
                std::cout << "That's right!\n";
                success = true;
                break;
            }
        }
        if (success)
        {
            break;
        }
        else
        {
            std::cout << "Try again! \n";
        }
    }
    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Please enter your name: Apple
My name is Apple.
The string
MY NAME IS APPLE AND I AM A C++ STUDENT.
contains 5 'A' characters in it.

Enter the name of a primary color for mixing light: yellow
Try again!
red
That's right!
Done.

3.重新编写程序清单10.7和程序清单10.8描述的Stock类，使之使用动态分配的内存，而不是string类对象来存储股票名称。
另外，使用重载的operator<<定义代替show成员函数。再使用程序清单10.9测试新的定义程序。
stock30.h
#pragma once
#ifndef STOCK30_H_
#define STOCK30_H_
#include <string>
#include <iostream>

class Stock
{
private:
    char *company;
    int shares;
    double share_val;
    double total_val;
    void set_tot()
    {
        total_val = shares * share_val;
    }
public:
    Stock();
    Stock(const char *s, long n = 0, double pr = 0.0);
    ~Stock();
    void buy(long num, double price);
    void sell(long num, double price);
    void update(double price);
    const Stock &topval(const Stock &s) const;
    friend std::ostream &operator << (std::ostream &os, const Stock &st);

};

#endif

stock30.cpp
#include <cstring>
#include "stock30.h"

Stock::Stock()
{
    std::cout << "Default constructor called\n";
    company = new char[1];
    company[0] = '\0';
    shares = 0;
    share_val = 0.0;
    total_val = 0.0;
}
Stock::Stock(const char *s, long n, double pr)
{
    std::cout << "Constructor using " << s << " called\n";
    company = new char[strlen(s) + 1];
    strcpy(company, s);

    if (n < 0)
    {
        std::cout << "Number of shares can't be negative; " << company << " shares set to 0.\n";
        shares = 0;
    }
    else
    {
        shares = n;
    }

    share_val = pr;
    set_tot();
}

Stock::~Stock()
{
    std::cout << "Bye, " << company << "!\n";
    delete[] company;
}

void Stock::buy(long num, double price)
{
    if (num < 0)
    {
        std::cout << "Number of shares purchased can't be negative. " << "Transaction is aborted.\n";
    }
    else
    {
        shares += num;
        share_val = price;
        set_tot();
    }
}

void Stock::sell(long num, double price)
{
    using std::cout;
    if (num < 0)
    {
        cout << "Number of shares sold can't be negative. " << "Transaction is aborted.\n";
    }
    else if (num > shares)
    {
        cout << "You can't sell more than you have! " << "Transaction is aborted.\n";
    }
    else
    {
        shares -= num;
        share_val = price;
        set_tot();
    }
}
void Stock::update(double price)
{
    share_val = price;
    set_tot();
}
std::ostream &operator << (std::ostream &os, const Stock &st)
{
    using std::ios_base;
    ios_base::fmtflags orig = os.setf(ios_base::fixed, ios_base::floatfield);
    std::streamsize prec = os.precision(3);
    os << "Company: " << st.company << ", Shares: " << st.shares << '\n';
    os << "Share Price: $" << st.share_val;
    os.precision(2);
    os << ", Total Worth: $" << st.total_val << '\n';
    os.setf(orig, ios_base::floatfield);
    os.precision(prec);

    return os;
}

const Stock &Stock::topval(const Stock &s) const
{
    if (s.total_val > total_val)
    {
        return s;
    }
    else
    {
        return *this;
    }
}

ch12_p03.cpp
#include <iostream>
#include "stock30.h"

const int STKS = 4;

int main()
{
    Stock stocks[STKS] =
    {
        Stock("NanoSmart", 12, 20.0),
        Stock("Boffo Objects", 200, 2.0),
        Stock("Monolithic Obelisks", 130, 3.25),
        Stock("Fleep Enterprises", 60, 6.5)
    };

    std::cout << "Stock holdings:\n";
    int st;
    for (st = 0; st < STKS; st++)
    {
        std::cout << stocks[st];
    }
    const Stock *top = &stocks[0];
    for (st = 1; st < STKS; st++)
    {
        top = & ( top->topval(stocks[st]) );
    }
    std::cout << "\nMost valuable holding:\n";
    std::cout << *top;

    return 0;
}
显示结果如下
Constructor using NanoSmart called
Constructor using Boffo Objects called
Constructor using Monolithic Obelisks called
Constructor using Fleep Enterprises called
Stock holdings:
Company: NanoSmart, Shares: 12
Share Price: $20.000, Total Worth: $240.00
Company: Boffo Objects, Shares: 200
Share Price: $2.000, Total Worth: $400.00
Company: Monolithic Obelisks, Shares: 130
Share Price: $3.250, Total Worth: $422.50
Company: Fleep Enterprises, Shares: 60
Share Price: $6.500, Total Worth: $390.00

Most valuable holding:
Company: Monolithic Obelisks, Shares: 130
Share Price: $3.250, Total Worth: $422.50
Bye, Fleep Enterprises!
Bye, Monolithic Obelisks!
Bye, Boffo Objects!
Bye, NanoSmart!

4.请看下面程序清单10.10定义的Stack类的变量：
正如私有成员表明的，这个类使用动态分配的数组来保存栈项。
请重新编写方法，以适应这种新的表示法，并编写一个程序来演示所有的方法，包括复制构造函数和赋值运算符。
stack2.h
#pragma once
#ifndef STACK2_H_
#define STACK2_H_
#include <iostream>

typedef unsigned long Item;

class Stack
{
private:
    enum { MAX = 10 };
    Item *pitems;
    int size;
    int top;
public:
    Stack(int n = MAX);
    Stack(const Stack &st);
    ~Stack();
    bool isempty() const;
    bool isfull() const;

    bool push(const Item &item);
    bool pop(Item &item);

    Stack &operator = (const Stack &st);
    friend std::ostream &operator << (std::ostream &os, const Stack &s);
};

#endif

stack2.cpp
#include <iostream>
#include "stack2.h"

Stack::Stack(int n)
{
    if (n < 1)
    {
        std::cerr << "Error. Argument must be a positive integer. ";
        std::cerr << "Setting n to 10." << std::endl;
        n = 10;
    }
    pitems = new Item[n];
    size = n;
    top = 0;
}

Stack::Stack(const Stack &st)
{
    pitems = new Item[st.size];
    for (int i = 0; i < st.size; i++)
    {
        pitems[i] = (st.pitems)[i];
    }
    size = st.size;
    top = st.top;
}

Stack::~Stack()
{
    delete[] pitems;
}

bool Stack::isempty() const
{
    return top == 0;
}

bool Stack::isfull() const
{
    return top == size;
}

bool Stack::push(const Item &item)
{
    if (top < size)
    {
        pitems[top++] = item;
        return true;
    }
    else
    {
        return false;
    }
}

bool Stack::pop(Item &item)
{
    if (top > 0)
    {
        item = pitems[--top];
        return true;
    }
    else
    {
        return false;
    }
}

Stack &Stack::operator = (const Stack &st)
{
    if (this == &st)
    {
        return *this;
    }
    delete[] pitems;

    size = st.size;
    top = st.top;
    pitems = new Item[size];

    for (int i = 0; i < size; i++)
    {
        pitems[i] = (st.pitems)[i];
    }
    return *this;
}

std::ostream &operator<<(std::ostream &os, const Stack &s)
{
    for (int i = 0; i < s.top; i++)
    {
        os << "item " << i + 1 << ": " << (s.pitems)[i] << std::endl;
    }
    return os;
}

ch12_p04.cpp
#include <iostream>
#include "stack2.h"

int main()
{
    std::cout << "setting s1..." << std::endl;
    Stack s1;
    std::cout << "setting s2..." << std::endl;
    Stack s2(5);
    std::cout << "setting s3..." << std::endl;
    Stack s3(-1);
    std::cout << "setting s4..." << std::endl;
    Stack s4 = Stack(10);
    std::cout << "setting s5..." << std::endl;
    Stack s5(s4);
    std::cout << "setting s6..." << std::endl;
    Stack s6 = Stack(s3);
    std::cout << std::endl;

    std::cout << "s1.isempty() == " << s1.isempty() << std::endl;
    s1.push(10);
    s1.push(20);
    s1.push(30);

    s2 = s1;

    unsigned long x = 0;
    s2.pop(x);

    std::cout << "We pushed 10, 20, and 30 into s1" << std::endl;
    std::cout << "We assigned s2 to s1" << std::endl;
    std::cout << "s2.pop(x), x = " << x << std::endl;
    std::cout << std::endl;

    std::cout << "s1: " << std::endl;
    std::cout << s1;
    std::cout << std::endl;
    std::cout << "s2: " << std::endl;
    std::cout << s2;

    return 0;
}
显示结果如下
setting s1...
setting s2...
setting s3...
Error. Argument must be a positive integer. Setting n to 10.
setting s4...
setting s5...
setting s6...

s1.isempty() == 1
We pushed 10, 20, and 30 into s1
We assigned s2 to s1
s2.pop(x), x = 30

s1:
item 1: 10
item 2: 20
item 3: 30

s2:
item 1: 10
item 2: 20

5.Heather银行进行的研究表明，ATM客户不希望排队时间不超过1分钟。
使用程序清单12.10中的模拟，找出要使平均等候时间为1分钟，每小时到达的客户数应为多少（试验时间不短于100小时）？
queue2.h
#pragma once
#ifndef QUEUE2_H_
#define QUEUE2_H_

class Customer
{
private:
    long arrive;
    int processtime;
public:
    Customer()
    {
        arrive = processtime = 0;
    }
    void set(long when);
    long when() const
    {
        return arrive;
    }
    int ptime() const
    {
        return processtime;
    }
};

typedef Customer Item;

class Queue
{
private:
    struct Node
    {
        Item item;
        struct Node *next;
    };
    enum { Q_SIZE = 10 };
    Node *front;
    Node *rear;
    int items;
    const int qsize;

    Queue(const Queue &q) : qsize(0) { }
    Queue &operator=(const Queue &q)
    {
        return *this;
    }
public:
    Queue(int qs = Q_SIZE);
    ~Queue();
    bool isempty() const;
    bool isfull() const;
    int queuecount() const;
    bool enqueue(const Item &item);
    bool dequeue(Item &item);
};

#endif

queue2.cpp
#include <iostream>
#include <cstdlib>
#include "queue2.h"

Queue::Queue(int qs) : qsize(qs)
{
    front = rear = nullptr;
    items = 0;
}

Queue::~Queue()
{
    Node *next;
    while (front != nullptr)
    {
        next = front->next;
        delete front;
        front = next;
    }
}

bool Queue::isempty() const
{
    return items == 0;
}

bool Queue::isfull() const
{
    return items == qsize;
}

int Queue::queuecount() const
{
    return items;
}
bool Queue::enqueue(const Item &item)
{
    if (isfull())
    {
        return false;
    }
    Node *add = new Node;

    add->item = item;
    add->next = nullptr;
    if (items == 0)
    {
        front = add;
        rear = add;
    }
    else
    {
        rear->next = add;
        rear = add;
    }
    items++;
    return true;
}
bool Queue::dequeue(Item &item)
{
    if (isempty())
    {
        return false;
    }
    item = front->item;
    items--;
    Node *next = front->next;
    delete front;
    front = next;
    if (items == 0)
    {
        front = nullptr;
        rear = nullptr;
    }
    return true;
}
void Customer::set(long when)
{
    processtime = std::rand() % 3 + 1;
    arrive = when;
}

ch12_p05.cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
#include "queue2.h"

const int MIN_PER_HR = 60;

bool newcustomer(double x);

int main()
{
    using std::cin;
    using std::cout;
    using std::endl;
    using std::ios_base;

    std::srand(std::time(nullptr));

    cout << "Case Study: Bank of Heather Automatic Teller\n";
    cout << "Enter maximum size of queue: ";
    int qs;
    cin >> qs;

    cout << "Enter the number of simulation hours: ";
    int hours;
    cin >> hours;
    long cyclelimit = MIN_PER_HR * hours;

    double perhour;
    double min_per_cust;

    Item temp;
    long turnaways = 0;
    long customers = 0;
    long served = 0;
    long sum_line = 0;
    int wait_time = 0;
    long line_wait = 0;

    int i = hours;

    do
    {
        perhour = i--;
        min_per_cust = MIN_PER_HR / perhour;
        Queue line(qs);
        turnaways = 0;
        customers = 0;
        served = 0;
        sum_line = 0;
        wait_time = 0;
        line_wait = 0;

        for (long cycle = 0; cycle < cyclelimit; cycle++)
        {
            if (newcustomer(min_per_cust))
            {
                if (line.isfull())
                {
                    turnaways++;
                }
                else
                {
                    customers++;
                    temp.set(cycle);
                    line.enqueue(temp);
                }
            }
            if (wait_time <= 0 && !line.isempty())
            {
                line.dequeue(temp);
                wait_time = temp.ptime();
                line_wait += cycle - temp.when();
                served++;
            }
            if (wait_time > 0)
            {
                wait_time--;
            }
            sum_line += line.queuecount();
        }
    }
    while ((double)line_wait / served > 1.0);
    i++;

    if (customers > 0)
    {
        std::cout << "customers per hours: " << i << std::endl;
        cout << "customers accepted: " << customers << endl;
        cout << "customers served: " << served << endl;
        cout << "customers turnaways: " << turnaways << endl;
        cout.precision(2);
        cout.setf(ios_base::fixed, ios_base::floatfield);
        cout.setf(ios_base::showpoint);
        cout << "average queue size: " << (double)sum_line / cyclelimit << endl;
        cout << "average wait time: " << (double)line_wait / served << " minutes\n";
    }
    else
    {
        cout << "No customers!\n";
    }
    cout << "Done.\n";

    return 0;
}
bool newcustomer(double x)
{
    return ( (std::rand() * x) / RAND_MAX < 1);
}
显示结果如下
Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 10
Enter the number of simulation hours: 100
customers per hours: 17
customers accepted: 1709
customers served: 1709
customers turnaways: 0
average queue size: 0.24
average wait time: 0.85 minutes
Done.

Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 20
Enter the number of simulation hours: 100
customers per hours: 18
customers accepted: 1771
customers served: 1770
customers turnaways: 0
average queue size: 0.26
average wait time: 0.89 minutes
Done.

Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 30
Enter the number of simulation hours: 100
customers per hours: 18
customers accepted: 1737
customers served: 1737
customers turnaways: 0
average queue size: 0.23
average wait time: 0.78 minutes
Done.

Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 40
Enter the number of simulation hours: 100
customers per hours: 17
customers accepted: 1687
customers served: 1687
customers turnaways: 0
average queue size: 0.24
average wait time: 0.84 minutes
Done.

Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 50
Enter the number of simulation hours: 100
customers per hours: 17
customers accepted: 1649
customers served: 1649
customers turnaways: 0
average queue size: 0.21
average wait time: 0.75 minutes
Done.

6.Heather银行想知道，如果再开设一台ATM，情况将如何。请对模拟进行修改，以包含两个队列。
假设当第一台ATM前的排队人数少于第二台ATM时，客户将排在第一队，否则将排在第二队。
然后再找出要使平均等候时间为1分钟，每小时到达的客户数应该为多少
（注意，这是一个非线性问题，即将ATM数量加倍，并不能保证每小时处理的客户数量也翻倍，
并确保客户等候的时间少于1分钟）？
ch12_p06.cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
#include "queue2.h"

const int MIN_PER_HR = 60;

bool newcustomer(double x);

int main()
{
    using std::cin;
    using std::cout;
    using std::endl;
    using std::ios_base;

    std::srand(std::time(nullptr));

    cout << "Case Study: Bank of Heather Automatic Teller\n";
    cout << "Enter maximum size of queue: ";
    int qs;
    cin >> qs;

    cout << "Enter the number of simulation hours: ";
    int hours;
    cin >> hours;
    long cyclelimit = MIN_PER_HR * hours;

    double perhour;
    double min_per_cust;

    Item temp;

    long turnawaysL1 = 0;
    long customersL1 = 0;
    long servedL1 = 0;
    long sum_lineL1 = 0;
    int wait_timeL1 = 0;
    long line_waitL1 = 0;

    long turnawaysL2 = 0;
    long customersL2 = 0;
    long servedL2 = 0;
    long sum_lineL2 = 0;
    int wait_timeL2 = 0;
    long line_waitL2 = 0;

    double average_wait;


    int i = hours;

    do
    {
        perhour = i--;
        min_per_cust = MIN_PER_HR / perhour;
        Queue line1(qs);
        Queue line2(qs);
        turnawaysL1 = turnawaysL2 = 0;
        customersL1 = customersL2 = 0;
        servedL1 = servedL2 = 0;
        sum_lineL1 = sum_lineL2 = 0;
        wait_timeL1 = wait_timeL2 = 0;
        line_waitL1 = line_waitL2 = 0;

        for (long cycle = 0; cycle < cyclelimit; cycle++)
        {
            if (newcustomer(min_per_cust))
            {
                if (line1.queuecount() <= line2.queuecount())
                {
                    if (line1.isfull())
                    {
                        turnawaysL1++;
                    }
                    else
                    {
                        customersL1++;
                        temp.set(cycle);
                        line1.enqueue(temp);
                    }
                }
                else
                {
                    if (line2.isfull())
                    {
                        turnawaysL2++;
                    }
                    else
                    {
                        customersL2++;
                        temp.set(cycle);
                        line2.enqueue(temp);
                    }
                }
            }
            if (wait_timeL1 == 0 && !line1.isempty())
            {
                line1.dequeue(temp);
                wait_timeL1 = temp.ptime();
                line_waitL1 += cycle - temp.when();
                servedL1++;
            }

            if (wait_timeL2 == 0 && !line2.isempty())
            {
                line2.dequeue(temp);
                wait_timeL2 = temp.ptime();
                line_waitL2 += cycle - temp.when();
                servedL2++;
            }
            if (wait_timeL1 > 0)
            {
                wait_timeL1--;
            }

            if (wait_timeL2 > 0)
            {
                wait_timeL2--;
            }
            sum_lineL1 += line1.queuecount();
            sum_lineL2 += line2.queuecount();
        }
        average_wait = double(line_waitL1 + line_waitL2) / (servedL1 + servedL2);

    }
    while (average_wait > 1.0);
    i++;

    if (customersL1 + customersL2 > 0)
    {
        std::cout << "customers per hours: " << i << std::endl;
        cout << "customers accepted: " << customersL1 + customersL2 << endl;
        cout << "customers served: " << servedL1 + servedL2 << endl;
        cout << "customers turnaways: " << turnawaysL1 + turnawaysL2 << endl;
        cout.precision(2);
        cout.setf(ios_base::fixed, ios_base::floatfield);
        cout.setf(ios_base::showpoint);
        cout << "average queue1 size: " << (double)sum_lineL1 / cyclelimit << endl;
        cout << "average queue2 size: " << (double)sum_lineL2 / cyclelimit << endl;
        cout << "average queue size: " << ( (double)(sum_lineL1 * sum_lineL2) / (sum_lineL1 + sum_lineL2) ) / cyclelimit << endl;
        cout << "average wait time: " << average_wait << " minutes\n";
    }
    else
    {
        cout << "No customers!\n";
    }
    cout << "Done.\n";

    return 0;
}
bool newcustomer(double x)
{
    return ( (std::rand() * x) / RAND_MAX < 1);
}
显示结果如下
Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 20
Enter the number of simulation hours: 100
customers per hours: 50
customers accepted: 5010
customers served: 5009
customers turnaways: 0
average queue1 size: 0.58
average queue2 size: 0.23
average queue size: 0.17
average wait time: 0.97 minutes
Done.

第13章 类继承
13.1 一个简单的基类
13.1.1 派生一个类
13.1.2 构造函数：访问权限的考虑
13.1.3 使用派生类
13.1.4 派生类和基类之间的特殊关系
13.2 继承：is-a关系
13.3 多态公有继承
13.4 静态联编和动态联编
13.4.1 指针和引用类型的兼容性
13.4.2 虚成员函数和动态联编
13.4.3 有关虚函数注意事项
13.5 访问控制 protected
13.6 抽象基类
13.6.1 应用ABC概念
13.6.2 ABC理念
13.7 继承和动态内存分配
13.7.1 第一种情况：派生类不使用new
13.7.2 第二种情况：派生类使用new
13.7.3 使用动态内存分配和友元的继承示例
13.8 类设计回顾
13.8.1 编译器生成的成员涵数.
13.8.2 其他的类方法
13.8.3 公有继承的考虑因素
13.8.4 类函数小结
13.9 总结
13.10 复习题
13.11 编程练习
本章内容包括：
is-a关系的继承。
如何以公有方式从一个类派生出另一个类。
保护访问。
构造函数成员初始化列表。
向上和向下强制转换。
虚成员函数。
静态联编与动态联编。
抽象基类。
纯虚函数。
何时及如何使用公有继承。
从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。
程序清单13.1 tabletenn0.h
#pragma once
#ifndef TABLETENN0_H_  
#define TABLETENN0_H_  

#include <string> 

using std::string;

class TableTennisPlayer
{
private:
	string firstname;
	string lastname;
	bool hasTable;
public:
	TableTennisPlayer(const string & fn = "none", const string & In = "none", bool ht = false);
	void Name() const;
	bool HasTable() const { return hasTable; };
	void ResetTable(bool v) { hasTable = v; };
};

#endif

程序清单13.2 tabletenn0.cpp
#include <iostream>
#include "tabletenn0.h"

TableTennisPlayer::TableTennisPlayer(const string & fn, const string & In, bool ht) : firstname(fn), lastname(In), hasTable(ht) 
{

}
void TableTennisPlayer::Name() const
{
    std::cout << lastname << ", " << firstname;
}

程序清单13.3 usett0.cpp
#include <iostream>
#include "tabletenn0.h"

int main()
{
    using std::cout;
    TableTennisPlayer player1("Chuck", "Blizzard", true);
    TableTennisPlayer player2("Tara", "Boomdea", false);
    player1.Name();
    if (player1.HasTable())
    {
        cout << " : has a table.\n";
    }
    else
    {
        cout << " : hasn't a table.\n";
    }
    player2.Name();
    if (player2.HasTable())
    {
        cout << " : has a table";
    }
    else
    {
        cout << " : hasn't a table. \n";
    }

    return 0;
}
显示结果如下
Blizzard, Chuck : has a table.
Boomdea, Tara : hasn't a table.

程序清单13.4 tabletenn1.h
#pragma once
#ifndef TABLETENN1_H_
#define TABLETENN1_H_

#include <string>

using std::string;

class TableTennisPlayer
{
private:
    string firstname;
    string lastname;
    bool hasTable;
public:
    TableTennisPlayer(const string &fn = "none", const string &In = "none", bool ht = false);
    void Name() const;
    bool HasTable() const
    {
        return hasTable;
    };
    void ResetTable(bool v)
    {
        hasTable = v;
    };
};

class RatedPlayer : public TableTennisPlayer
{
private:
    unsigned int rating;
public:
    RatedPlayer(unsigned int r = 0, const string &fn = "none", const string &In = "none", bool ht = false);
    RatedPlayer(unsigned int r, const TableTennisPlayer &tp);
    unsigned int Rating() const
    {
        return rating;
    }
    void ResetRating(unsigned int r)
    {
        rating = r;
    }
};

#endif

冒号指出RatedPlayer类的基类是TableTennisplayer类，public表明公有派生。
使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问（稍后将介绍保护成员）。
Ratedplayer对象将具有以下特征：
派生类对象存储了基类的数据成员（派生类继承了基类的实现）；
派生类对象可以使用基类的方法（派生类继承了基类的接口）。
因此，RatedPlayer对象可以存储运动员的姓名及其是否有球桌。
另外，RatedPlayer对象还可以使用TableTennisPlayer 类的Name、hasTable和ResetTable方法（参见图13.1）。
派生类需要自己的构造函数。派生类可以根据需要添加额外的数据成员和成员函数。
在这个例子中，派生类需要另一个数据成员来存储比分，还应包含检索比分的方法和重置比分的方法。
构造函数必须给新成员（如果有的话）和继承的成员提供数据。
在第一个RatedPlayer构造函数中，每个成员对应一个形参；
而第二个Ratedplayer构造函数使用一个TableTennisPlayer参数，该参数包括firstname，lastname和hasTable.
派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。
例如，RatedPlayer构造函数不能直接设置继承的成员（firstname，lastname和hasTable），而必须使用基类的公有方法来访问私有的基类成员。
具体地说，派生类构造函数必须使用基类构造函数。
创建派生类对象时，程序首先创建基类对象。从概念上说，这意味着基类对象应当在程序进入派生类构造函数之前被创建。
C++使用成员初始化列表语法来完成这种工作。例如，下面是第一个RatedPlayer构造函数的代码：
RatedPlayer::RatedPlayer(unsigned int r, const string &fn, const string &In, bool ht) : TableTennisPlayer(fn, In, ht)
{
    rating = r;
}
其中 : TableTennisPlayer (fn, In, ht)是成员初始化列表。它是可执行的代码，调用TableTennisPlayer构造函数。
如果省略成员初始化列表，不显式调用基类构造函数，程序将使用默认的基类构造函数。
除非要使用默认构造函数，否则应显式调用正确的基类构造函数。
如果愿意，也可以对派生类成员使用成员初始化列表语法。在这种情况下，应在列表中使用成员名，而不是类名。
有关派生类构造函数的要点如下：
首先创建基类对象；
派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数
派生类构造函数应初始化派生类新增的数据成员。
释放对象的顺序与创建对象的顺序相反，即首先执行派生类的析构函数，然后自动调用基类的析构函数。
创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数。
基类构造函数负责初始化继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。
派生类的构造函数总是调用一个基类构造函数。可以使用初始化器列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。
派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。
派生类构造函数可以使用初始化器列表机制将值传递给基类构造函数。
derived::derived (type1 x, type2 y) : base (x, y)
其中derived是派生类，base是基类，x和y是基类构造函数使用的变量。
例如，如果派生类构造函数接收到参数10和12，则将把10和12传递给基类构造函数。
除虚基类外（参见第14章），类只能将值传递回相邻的基类，但后者可以使用相同的机制将信息传递给相邻的基类，依此类推。
如果没有在成员初始化列表中提供基类构造函数，程序将使用默认的基类构造函数。
成员初始化列表只能用于构造函数。

程序清单13.5 tabletenn1.cpp
#include <iostream>
#include "tabletenn1.h"

TableTennisPlayer::TableTennisPlayer(const string &fn, const string &In, bool ht) : firstname(fn), lastname(In), hasTable(ht)
{

}
void TableTennisPlayer::Name() const
{
    std::cout << lastname << ", " << firstname;
}
RatedPlayer::RatedPlayer(unsigned int r, const string &fn, const string &In, bool ht) : TableTennisPlayer(fn, In, ht)
{
    rating = r;
}
RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer &tp) : TableTennisPlayer(tp), rating(r)
{

}

程序清单13.6 usett1.cpp
#include <iostream>
#include "tabletenn1.h"

int main()
{
    using std::cout;
    using std::endl;
    TableTennisPlayer player1("Tara", "Boomdea", false);
    RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
    rplayer1.Name();
    if (rplayer1.HasTable())
    {
        cout << " : has a table. \n";
    }
    else
    {
        cout << " : hasn't a table. \n";
    }
    player1.Name();
    if (player1.HasTable())
    {
        cout << " : has a table";
    }
    else
    {
        cout << " : hasn't a table. \n";
    }
    cout << "Name: ";
    rplayer1.Name();
    cout << "; Rating: " << rplayer1.Rating() << endl;
    RatedPlayer rplayer2(1212, player1);
    cout << "Name: ";
    rplayer2.Name();
    cout << "; Rating: " << rplayer2.Rating() << endl;

    return 0;
}
显示结果如下
Duck, Mallory : has a table.
Boomdea, Tara : hasn't a table.
Name: Duck, Mallory; Rating: 1140
Name: Boomdea, Tara; Rating: 1212
派生类与基类之间有一些特殊关系。
派生类对象可以使用基类的方法，条件是方法不是私有的；
基类指针可以在不进行显式类型转换的情况下指向派生类对象；
基类引用可以在不进行显式类型转换的情况下引用派生类对象。
然而，基类指针或引用只能用于调用基类方法，不能用于调用派生类的方法。
通常，C++要求引用和指针类型与赋给的类型匹配，但这一规则对继承来说是例外。
然而，这种例外只是单向的，不可以将基类对象和地址赋给派生类引用和指针。
上述规则是有道理的。例如，如果允许基类引用隐式地引用派生类对象，则可以使用基类引用为派生类对象调用基类的方法。
因为派生类继承了基类的方法，所以这样做不会出现问题。
如果可以将基类对象赋给派生类引用，派生类引用能够为基对象调用派生类方法，这样做将出现问题。
C++有3种继承方式：公有维承、保护继承和私有继承。
公有继承是最常用的方式，它建立一种is-a关系，即派生类对象也是一个基类对象，
可以对基类对象执行的任何操作，也可以对派生类对象执行。
派生类将继承基类的所有数据成员，还可以添加了专门用于派生类的成员。
因为派生类可以添加特性；所以，将这种关系称为is-a-kind-of（是一种）关系可能更准确。
公有继承不建立has-a关系。例如，午餐可能包括水果，但通常午餐并不是水果。
在午餐中加入水果的正确方法是将其作为一种has-a关系：午餐有水果。
正如将在第14章介绍的，最容易的建模方式是将Fruit对象作为Lunch类的数据成员（参见图13.3）。
公有继承不能建立is-like-a关系，也就是说，它不采用明喻。人们通常说律师就像鲨鱼，但律师并不是鲨鱼。
例如，鲨鱼可以在水下生活。所以，不应从Shark类派生出Lawyer类。
继承可以在基类的基础上添加属性，但不能删除基类的属性。
在有些情况下，可以设计一个包含共有特征的类，然后以is-a或has-a关系，在这个类的基础上定义相关的类。
公有继承不建立is-implemented-as-a（作为 实现）关系。
例如，可以使用数组来实现栈，但从Array类派生出Stack类是不合适的，因为栈不是数组。
例如，数组索引不是栈的属性。另外，可以以其他方式实现栈，如链表。
正确的方法是，通过让栈包含一个私有Array对象成员来隐藏数组实现。
公有继承不建立uses-a关系。例如，计算机可以使用激光打印机，但从Computer类派生出Printer类（或反过来）是没有意义的。
然而，可以使用友元函数或类来处理Printer对象和Computer对象之间的通信。
有两种重要的机制可用于实现多态公有继承：
在派生类中重新定义基类的方法
如果方法是通过对象调用的，程序将使用对象类型来确定使用哪个版本的方法。
如果方法是通过引用或指针而不是对象调用的，程序将根据引用类型或指针类型来确定使用哪个版本的方法。
使用虚函数。
如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法。
方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法。
然而，在派生类声明中使用关键字virtual来指出哪些函数是虚函数也不失为一个好办法。
基类声明了一个虚析构函数。这样做是为了确保释放派生对象时，按正确的顺序调用析构函数。
如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的。
这样，程序将根据对象类型而不是引用或指针的类型来选择方法版本。为基类声明一个虚析构函数也是一种惯例。
注意，关键字virtual只用于类声明的方法原型中，而没有用于方法定义中。
程序清单13.7 brass.h
#pragma once
#ifndef BRASS_H_
#define BRASS_H_
#include <string>

class Brass
{
private:
    std::string fullName;
    long acctNum;
    double balance;
public:
    Brass(const std::string &s = "Nullbody", long an = -1, double bal = 0.0);
    void Deposit(double amt);
    virtual void Withdraw(double amt);
    double Balance() const;
    virtual void ViewAcct() const;
    virtual ~Brass() {}
};

class BrassPlus : public Brass
{
private:
    double maxLoan;
    double rate;
    double owesBank;
public:
    BrassPlus(const std::string &s = "Nullbody", long an = -1, double bal = 0.0, double ml = 500, double r = 0.11125);
    BrassPlus(const Brass &ba, double ml = 500, double r = 0.11125);
    virtual void ViewAcct()const;
    virtual void Withdraw(double amt);
    void ResetMax(double m)
    {
        maxLoan = m;
    }
    void ResetRate(double r)
    {
        rate = r;
    };
    void ResetOwes()
    {
        owesBank = 0;
    }
};

#endif
派生类并不能直接访问基类的私有数据，而必须使用基类的公有方法才能访问这些数据。
访问的方式取决于方法。构造函数使用一种技术，而其他成员函数使用另一种技术。
派生类构造函数在初始化基类私有数据时，采用的是成员初始化列表语法。
非构造函数不能使用成员初始化列表语法，但可以使用作用域解析运算符来调用基类方法。
程序清单13.8 brass.cpp
#include <iostream>
#include "brass.h"

using std::cout;
using std::endl;
using std::string;

typedef std::ios_base::fmtflags format;
typedef std::streamsize precis;
format setFormat();
void restore(format f, precis p);

Brass::Brass(const string &s, long an, double bal)
{
    fullName = s;
    acctNum = an;
    balance = bal;
}

void Brass::Deposit(double amt)
{
    if (amt < 0)
    {
        cout << "Negative deposit not allowed; deposit is cancelled.\n";
    }
    else
    {
        balance += amt;
    }
}

void Brass::Withdraw(double amt)
{
    format initialState = setFormat();
    precis prec = cout.precision(2);
    if (amt < 0)
    {
        cout << "Withdrawal amount must be positive; withdrawal canceled.\n";
    }
    else if (amt <= balance)
    {
        balance -= amt;
    }
    else
    {
        cout << "Withdrawal amount of $" << amt << " exceeds your balance. Withdrawal canceled.\n";

    }
    restore(initialState, prec);
}

double Brass::Balance() const
{
    return balance;
}

void Brass::ViewAcct() const
{
    format initialState = setFormat();
    precis prec = cout.precision(2);
    cout << "Client: " << fullName << endl;
    cout << "Account Number: " << acctNum << endl;
    cout << "Balance: $" << balance << endl;
    restore(initialState, prec);
}
BrassPlus::BrassPlus(const string &s, long an, double bal, double ml, double r) : Brass(s, an, bal)
{
    maxLoan = ml;
    rate = r;
    owesBank = 0.0;
}

BrassPlus::BrassPlus(const Brass &ba, double ml, double r) : Brass(ba)
{
    maxLoan = ml;
    rate = r;
    owesBank = 0.0;
}
void BrassPlus::ViewAcct() const
{
    format initialState = setFormat();
    precis prec = cout.precision(2);
    Brass::ViewAcct();
    cout << "Maximum loan: $" << maxLoan << endl;
    cout << "Owed to bank: $" << owesBank << endl;
    cout.precision(3);
    cout << "Loan Rate: " << 100 * rate << "%\n";
    restore(initialState, prec);
}
void BrassPlus::Withdraw(double amt)
{
    format initialState = setFormat();
    precis prec = cout.precision(2);
    double bal = Balance();
    if (amt <= bal)
    {
        Brass::Withdraw(amt);
    }
    else if (amt <= bal + maxLoan)
    {
        double advance = amt - bal;
        owesBank += advance * (1.0 + rate);
        cout << "Bank advance: $" << advance << endl;
        cout << "Finance charge: $" << advance *rate << endl;
        Deposit(advance);
        Brass::Withdraw(amt);
    }
    else
    {
        cout << "Credit limit exceeded. Transaction cancelled.\n";
    }
    restore(initialState, prec);
}

format setFormat()
{
    return cout.setf(std::ios_base::fixed, std::ios_base::floatfield);
}

void restore(format f, precis p)
{
    cout.setf(f, std::ios_base::floatfield);
    cout.precision(p);
}


程序清单13.9 usebrass1.cpp
#include <iostream>
#include "brass.h"

int main()
{
    using std::cout;
    using std::endl;
    Brass Piggy("Porcelot Pigg", 381299, 4000.00);
    BrassPlus Hoggy("Horatio Hogg", 382288, 3000.00);
    Piggy.ViewAcct ();
    cout << endl;
    Hoggy.ViewAcct ();
    cout << endl;
    cout << "Depositing $1000 into the Hogg Account:\n";
    Hoggy.Deposit(1000.00);
    cout << "New balance: $" << Hoggy .Balance () << endl;
    cout << "Withdrawing $4200 from the Pigg Account: \n";
    Piggy.Withdraw(4200.00);
    cout << "Pigg account balance: $" << Piggy .Balance () << endl;
    cout << "Withdrawing $4200 from the Hogg Account: \n";
    Hoggy.Withdraw (4200.00);
    Hoggy.ViewAcct ();

    return 0;
}
显示结果如下
Client: Porcelot Pigg
Account Number: 381299
Balance: $4000.00

Client: Horatio Hogg
Account Number: 382288
Balance: $3000.00
Maximum loan: $500.00
Owed to bank: $0.00
Loan Rate: 11.125%

Depositing $1000 into the Hogg Account:
New balance: $4000
Withdrawing $4200 from the Pigg Account:
Withdrawal amount of $4200.00 exceeds your balance. Withdrawal canceled.
Pigg account balance: $4000
Withdrawing $4200 from the Hogg Account:
Bank advance: $200.00
Finance charge: $22.25
Client: Horatio Hogg
Account Number: 382288
Balance: $0.00
Maximum loan: $500.00
Owed to bank: $222.25
Loan Rate: 11.125%

程序清单13.10 usebrass2.cpp
#include <iostream>
#include "brass.h"

const int CLIENTS = 4;

int main()
{
    using std::cin;
    using std::cout;
    using std::endl;
    Brass *p_clients[CLIENTS];
    std::string temp;
    long tempnum;
    double tempbal;
    char kind;
    for (int i = 0; i < CLIENTS; i++)
    {
        cout << "Enter client's name: ";
        std::getline(cin, temp, '\n');
        cout << "Enter client's account number: ";
        cin >> tempnum;
        cout << "Enter opening balance: $";
        cin >> tempbal;
        while (cin.get() != '\n')
        {
            continue;
        }
        cout << "Enter 1 for Brass Account or 2 for BrassPlus Account: ";
        while (cin >> kind && (kind != '1' && kind != '2'))
        {
            while (cin.get() != '\n')
            {
                continue;
            }
            cout << "Enter either 1 or 2 : ";
        }
        while (cin.get() != '\n')
        {
            continue;
        }
        if (kind == '1')
        {
            p_clients[i] = new Brass(temp, tempnum, tempbal);
        }
        else
        {
            double tmax, trate;
            cout << "Enter the overdraft limit: $";
            cin >> tmax;
            cout << "Enter the interest rate as a decimal fraction: ";
            cin >> trate;
            while (cin.get() != '\n')
            {
                continue;
            }
            p_clients[i] = new BrassPlus(temp, tempnum, tempbal, tmax, trate);
        }
    }
    cout << endl;
    for (int i = 0; i < CLIENTS; i++)
    {
        p_clients[i]->ViewAcct();
        cout << endl;
    }
    for (int i = 0; i < CLIENTS; i++)
    {
        delete p_clients[i];
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Enter client's name: Peter Smith
Enter client's account number: 123456
Enter opening balance: $2000
Enter 1 for Brass Account or 2 for BrassPlus Account: 1
Enter client's name: Mike Pence
Enter client's account number: 222333
Enter opening balance: $3000
Enter 1 for Brass Account or 2 for BrassPlus Account: 2
Enter the overdraft limit: $500
Enter the interest rate as a decimal fraction: 0.11125
Enter client's name: Hello World
Enter client's account number: 555666
Enter opening balance: $6000
Enter 1 for Brass Account or 2 for BrassPlus Account: 1
Enter client's name: Apple
Enter client's account number: 777888
Enter opening balance: $8000
Enter 1 for Brass Account or 2 for BrassPlus Account: 2
Enter the overdraft limit: $800
Enter the interest rate as a decimal fraction: 0.125

Client: Peter Smith
Account Number: 123456
Balance: $2000.00

Client: Mike Pence
Account Number: 222333
Balance: $3000.00
Maximum loan: $500.00
Owed to bank: $0.00
Loan Rate: 11.125%

Client: Hello World
Account Number: 555666
Balance: $6000.00

Client: Apple
Account Number: 777888
Balance: $8000.00
Maximum loan: $800.00
Owed to bank: $0.00
Loan Rate: 12.500%

Done.
如果析构函数不是虚的，则将只调用对应于指针类型的析构函数。
对于程序清单13.10，这意味着只有Brass的析构函数被调用，即使指针指向的是一个BrassPlus对象。
如果析构函数是虚的，将调用相应对象类型的析构函数。
因此，如果指针指向的是BrassPlus对象，将调用BrassPlus的析构函数，然后自动调用基类的析构函数。
因此，使用虚析构函数可以确保正确的析构函数序列被调用。
指向基类的引用或指针可以引用派生类对象，而不必进行显式类型转换。
将派生类引用或指针转换为基类引用或指针被称为向上强制转换。
向上强制转换是可传递的，也就是说，如果从BrassPlus派生出BrassPlusPlus类，
则Brass指针或引用可以引用Brass对象、BrassPlus对象或BrassPlusPlus对象。
将基类指针或引用转换为派生类指针或引用称为向下强制转换。如果不使用显式类型转换，则向下强制转换是不允许的。
如果函数按值传递类型为Brass的参数，则导致只将BrassPlus对象的Brass部分传递给函数。
如果函数按引用和指针传递参数，隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象。
如果使用基类指针或引用调用虚函数，则导致分别为基类对象和派生类对象使用各自对应版本的函数。
通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。
这种数组称为虚函数表，虚函数表中存储了为类对象进行声明的虚函数的地址。
调用虚函数时，程序将查看存储在对象中的指向虚函数地址数组的指针，然后转向相应的虚函数地址表。
如果使用类声明中定义的第一个虚函数，则程序将使用数组中的第一个元素存储的函数地址，并执行对应的函数；
如果使用类声明中的第三个虚函数，程序将使用数组中的第三个元素存储的函数地址。
在基类方法的声明中使用关键字virtual可使该方法在基类以及所有的派生类（包括从派生类派生出来的类）中是虚的。
如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。
如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的。
构造函数不能是虚函数。
析构函数应当是虚函数，除非类不用做基类。
友元函数不能是虚函数，因为友元函数不是类成员函数，而只有类成员函数才能是虚函数。友元函数可以调用虚成员函数。
如果派生类没有重新定义函数，将使用该函数的基类版本。
如果派生类重新定义基类的函数，则会隐藏该函数的基类版本。
重新定义继承的方法并不是重载，如果在派生类中重新定义函数，不管参数特征标如何，都会隐藏同名的基类方法。
如果派生类重新定义继承的方法，应确保与基类方法的原型完全相同。但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。
注意，这种例外只适用于返回值，而不适用于参数。
如果基类声明中方法被重载了，则应在派生类中重新定义所有版本的对应方法。
如果只重新定义一个版本，则其他两个版本将被隐藏，派生类对象将无法使用它们。
注意，如果不需要修改，则新定义可只调用基类版本。
关键字protected与private相似，private和protected之间的区别只有在基类派生的类中才会表现出来。
派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。
因此，对于外部世界来说，保护成员的行为与私有成员相似；但对于派生类来说，保护成员的行为与公有成员相似。
C++通过使用纯虚函数（pure virtual function），提供没有实现的抽象函数。纯虚函数声明的结尾处为= 0。
当类声明中包含纯虚函数时，则不能创建该类的对象。这里的理念是，包含纯虚函数的类只用作基类。
纯虚函数一般不在基类的实现文件中定义，而应该在派生类的实现文件中定义。但是，C++允许在基类的实现文件中定义对应的纯虚函数。
程序清单13.11 acctabc.h
#pragma once
#ifndef ACCTABC_H_
#define ACCTABC_H_
#include <iostream>
#include <string>

class AcctABC
{
private:
    std::string fullName;
    long acctNum;
    double balance;
protected:
    struct Formatting
    {
        std::ios_base::fmtflags flag;
        std::streamsize pr;
    };
    const std::string &FullName() const
    {
        return fullName;
    }
    long AcctNum() const
    {
        return acctNum;
    }
    Formatting SetFormat() const;
    void Restore(Formatting &f) const;
public:
    AcctABC(const std::string &s = "Nullbody", long an = -1, double bal = 0.0);
    void Deposit(double amt);
    virtual void Withdraw(double amt) = 0;
    double Balance() const
    {
        return balance;
    };
    virtual void ViewAcct() const = 0;
    virtual ~AcctABC() {}
};

class Brass : public AcctABC
{
public:
    Brass(const std::string &s = "Nullbody", long an = -1, double bal = 0.0) : AcctABC(s, an, bal) { }
    virtual void Withdraw(double amt);
    virtual void ViewAcct() const;
    virtual ~Brass() {}
};
class BrassPlus : public AcctABC
{
private:
    double maxLoan;
    double rate;
    double owesBank;
public:
    BrassPlus(const std::string &s = "Nullbody", long an = -1, double bal = 0.0, double ml = 500, double r = 0.10);
    BrassPlus(const Brass &ba, double ml = 500, double r = 0.10);
    virtual void ViewAcct()const;
    virtual void Withdraw(double amt);
    void ResetMax(double m)
    {
        maxLoan = m;
    }
    void ResetRate(double r)
    {
        rate = r;
    };
    void ResetOwes()
    {
        owesBank = 0;
    }
};

#endif

程序清单13.12 acctabc.cpp
#include <iostream>
#include "acctabc.h"

using std::cout;
using std::ios_base;
using std::endl;
using std::string;

AcctABC::AcctABC(const string &s, long an, double bal)
{
    fullName = s;
    acctNum = an;
    balance = bal;
}
void AcctABC::Deposit(double amt)
{
    if (amt < 0)
    {
        cout << "Negative deposit not allowed; deposit is cancelled.\n";
    }
    else
    {
        balance += amt;
    }
}
void AcctABC::Withdraw(double amt)
{
    balance -= amt;
}
AcctABC::Formatting AcctABC::SetFormat() const
{
    Formatting f;
    f.flag = cout.setf(ios_base::fixed, ios_base::floatfield);
    f.pr = cout.precision(2);
    return f;
}
void AcctABC::Restore(Formatting &f) const
{
    cout.setf(f.flag, ios_base::floatfield);
    cout.precision(f.pr);
}
void Brass::Withdraw(double amt)
{
    if (amt < 0)
    {
        cout << "Withdrawal amount must be positive; withdrawal canceled.\n";
    }
    else if (amt <= Balance())
    {
        AcctABC::Withdraw(amt);
    }
    else
    {
        cout << "Withdrawal amount of $" << amt << " exceeds your balance. Withdrawal canceled.\n";
    }
}

void Brass::ViewAcct() const
{
    Formatting f = SetFormat();
    cout << "Brass Client: " << FullName() << endl;
    cout << "Account Number: " << AcctNum() << endl;
    cout << "Balance: $" << Balance() << endl;
    Restore(f);
}
BrassPlus::BrassPlus(const string &s, long an, double bal, double ml, double r) : AcctABC(s, an, bal)
{
    maxLoan = ml;
    rate = r;
    owesBank = 0.0;
}
BrassPlus::BrassPlus(const Brass &ba, double ml, double r) : AcctABC(ba)
{
    maxLoan = ml;
    rate = r;
    owesBank = 0.0;
}
void BrassPlus::ViewAcct() const
{
    Formatting f = SetFormat();
    cout << "BrassPlus Client: " << FullName() << endl;
    cout << "Account Number: " << AcctNum() << endl;
    cout << "Balance: $" << Balance() << endl;
    cout << "Maximum loan: $" << maxLoan << endl;
    cout << "Owed to bank: $" << owesBank << endl;
    cout.precision(3);
    cout << "Loan Rate: " << 100 * rate << "%\n";
    Restore(f);
}

void BrassPlus::Withdraw(double amt)
{
    Formatting f = SetFormat();
    double bal = Balance();
    if (amt < 0)
    {
        cout << "Withdrawal amount must be positive; withdrawal canceled.\n";
    }
    else if (amt <= bal)
    {
        AcctABC::Withdraw(amt);
    }
    else if (amt <= bal + maxLoan)
    {
        double advance = amt - bal;
        owesBank += advance * (1.0 + rate);
        cout << "Bank advance: $" << advance << endl;
        cout << "Finance charge: $" << advance *rate << endl;
        Deposit(advance);
        AcctABC::Withdraw(amt);
    }
    else
    {
        cout << "Credit limit exceeded. Transaction cancelled.\n";
    }
    Restore(f);
}

程序清单13.13 usebrass3.cpp
#include <iostream>
#include "acctabc.h"

const int CLIENTS = 4;

int main()
{
    using std::cin;
    using std::cout;
    using std::endl;
    AcctABC *p_clients[CLIENTS];
    std::string temp;
    long tempnum;
    double tempbal;
    char kind;

    for (int i = 0; i < CLIENTS; i++)
    {
        cout << "Enter client's name: ";
        std::getline(cin, temp, '\n');
        cout << "Enter client's account number: ";
        cin >> tempnum;
        cout << "Enter opening balance: $";
        cin >> tempbal;
        while (cin.get() != '\n')
        {
            continue;
        }
        cout << "Enter 1 for Brass Account or 2 for BrassPlus Account: ";
        while (cin >> kind && (kind != '1' && kind != '2'))
        {
            while (cin.get() != '\n')
            {
                continue;
            }
            cout << "Enter either 1 or 2 : ";
        }
        while (cin.get() != '\n')
        {
            continue;
        }
        if (kind == '1')
        {
            p_clients[i] = new Brass(temp, tempnum, tempbal);
        }
        else
        {
            double tmax, trate;
            cout << "Enter the overdraft limit: $";
            cin >> tmax;
            cout << "Enter the interest rate as a decimal fraction: ";
            cin >> trate;
            while (cin.get() != '\n')
            {
                continue;
            }
            p_clients[i] = new BrassPlus(temp, tempnum, tempbal, tmax, trate);
        }
    }
    cout << endl;
    for (int i = 0; i < CLIENTS; i++)
    {
        p_clients[i]->ViewAcct();
        cout << endl;
    }
    for (int i = 0; i < CLIENTS; i++)
    {
        delete p_clients[i];
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Enter client's name: Apple
Enter client's account number: 111222
Enter opening balance: $3000
Enter 1 for Brass Account or 2 for BrassPlus Account: 1
Enter client's name: Orange
Enter client's account number: 333444
Enter opening balance: $5000
Enter 1 for Brass Account or 2 for BrassPlus Account: 2
Enter the overdraft limit: $500
Enter the interest rate as a decimal fraction: 0.125
Enter client's name: Mike Pence
Enter client's account number: 555666
Enter opening balance: $8000
Enter 1 for Brass Account or 2 for BrassPlus Account: 2
Enter the overdraft limit: $800
Enter the interest rate as a decimal fraction: 0.11125
Enter client's name: Peter Smith
Enter client's account number: 777888
Enter opening balance: $9000
Enter 1 for Brass Account or 2 for BrassPlus Account: 1

Brass Client: Apple
Account Number: 111222
Balance: $3000.00

BrassPlus Client: Orange
Account Number: 333444
Balance: $5000.00
Maximum loan: $500.00
Owed to bank: $0.00
Loan Rate: 12.500%

BrassPlus Client: Mike Pence
Account Number: 555666
Balance: $8000.00
Maximum loan: $800.00
Owed to bank: $0.00
Loan Rate: 11.125%

Brass Client: Peter Smith
Account Number: 777888
Balance: $9000.00

Done.

如果基类使用动态内存分配，并重新定义赋值和复制构造函数。
class baseDMA
{
private:
    char * label;
    int rating;
public:
    baseDMA (const char * l = "null", int r = 0);
    baseDMA (const baseDMA & rs);
    virtual ~baseDMA();
    baseDMA & operator = (const baseDMA & rs);
};
现在从baseDMA派生出lackDMA类，而后者不使用new：
class lacksDMA : public baseDMA
{
private:
    char color[40];
public:
    // ...
};
不需要为lackDMA类定义显式析构函数、复制构造函数和赋值运算符。
如果没有显式定义析构函数，编译器将定义一个不执行任何操作的默认构造函数。
实际上，派生类的默认构造函数总是执行自身的代码后调用基类析构函数。
因为我们假设lackDMA成员不需执行任何特殊操作，所以默认析构函数是合适的。
如果没有显式定义复制构造函数，编译器将定义一个默认复制构造函数来执行成员复制。
成员复制将根据数据类型采用相应的复制方式；复制类成员或继承的类组件时，使用该类的复制构造函数完成的。
所以，lacksDMA类的默认复制构造函数使用显式定义的baseDMA复制构造函数来复制lacksDMA对象的baseDMA部分。
因此，默认复制构造函数对于新的lacksDMA成员来说是合适的，同时对于继承的baseDMA对象来说也是合适的。
类的默认赋值运算符将自动使用基类的赋值运算符来对基类组件进行赋值。因此，默认赋值运算符也是合适的。
现在从baseDMA派生出lackDMA类，而后者使用new：
class hasDMA : public baseDMA
{
private:
    char * style;
public:
    // ...
};
在这种情况下，必须为派生类定义显式析构函数、复制构造函数和赋值运算符。
派生类析构函数自动调用基类的析构函数，故其自身的职责是对派生类构造函数使用new分配的内存进行清理。
因此，hasDMA析构函数必须释放指针style管理的内存，并依赖于baseDMA的析构函数来释放指针label管理的内存。
baseDMA::~baseDMA()
{
    delete [] label;
}
hasDMA::~hasDMA()
{
    delete [] style;
}
baseDMA::baseDMA(const baseDMA & rs)
{
    label = new char[std::strlen(rs.label) + 1];
    std::strcpy(label, rs.label);
    rating = rs.rating;
}
hasDMA::hasDMA(const hasDMA & hs) : baseDMA(hs)
{
    style = new char[std::strlen(hs.style) + 1];
    std::strcpy(style, hs.style);
}
baseDMA & baseDMA::operator = (const baseDMA & rs)
{
    if(this == &rs)
    {
        return *this;
    }
    delete [] label;
    label = new char[std::strlen(rs.label) + 1];
    std::strcpy(label, rs.label);
    rating = rs.rating;
    return *this;
}
hasDMA & hasDMA::operator = (const hasDMA & hs)
{
    if (this == &hs)
    {
        return *this;
    }
    baseDMA::operator=(hs);
    delete [] style;
    style = new char[std::strlen(hs.style) + 1];
    std::strcpy(style, hs.style);
    return *this;
}
当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数、
赋值运算符都必须使用相应的基类方法来处理基类元素。
程序清单13.14 dma.h
#pragma once
#ifndef DMA_H_
#define DMA_H_
#include <iostream>

class baseDMA
{
private:
    char *label;
    int rating;
public:
    baseDMA(const char *l = "null", int r = 0);
    baseDMA(const baseDMA &rs);
    virtual ~baseDMA();
    baseDMA &operator=(const baseDMA &rs);
    friend std::ostream &operator<<(std::ostream &os, const baseDMA &rs);
};
class lacksDMA : public baseDMA
{
private:
    enum { COL_LEN = 40 };
    char color[COL_LEN];
public:
    lacksDMA(const char * c= "blank", const char *l = "null", int r = 0);
    lacksDMA(const char * c, const baseDMA &rs);
    friend std::ostream &operator<<(std::ostream &os, const lacksDMA &ls);
};
class hasDMA : public baseDMA
{
private:
    char *style;
public:
    hasDMA(const char * s = "none", const char *l = "null", int r = 0);
    hasDMA(const char * s, const baseDMA &rs);
    hasDMA(const hasDMA &hs);
    ~hasDMA();
    hasDMA &operator=(const hasDMA &rs);
    friend std::ostream &operator<<(std::ostream &os, const hasDMA &hs);
};

#endif

程序清单13.15 dma.cpp
#include <iostream>
#include <cstring>
#include "dma.h"

baseDMA::baseDMA(const char *l, int r)
{
    label = new char[std:: strlen(l) + 1];
    std::strcpy(label, l);
    rating = r;
}
baseDMA::baseDMA(const baseDMA &rs)
{
    label = new char[std:: strlen(rs.label) + 1];
    std::strcpy(label, rs.label);
    rating = rs.rating;
}
baseDMA::~baseDMA()
{
    delete[] label;
}
baseDMA &baseDMA::operator=(const baseDMA &rs)
{
    if (this == &rs)
    {
        return *this;
    }
    delete[] label;
    label = new char[std:: strlen(rs.label) + 1];
    std::strcpy(label, rs.label);
    rating = rs.rating;
    return *this;
}
std::ostream &operator<<(std::ostream &os, const baseDMA &rs)
{
    os << "Label: " << rs.label << std::endl;
    os << "Rating: " << rs.rating << std::endl;
    return os;
}
lacksDMA::lacksDMA(const char *c, const char *l, int r) : baseDMA(l, r)
{
    std::strncpy(color, c, COL_LEN - 1);
    color[COL_LEN - 1] = '\0';
}
lacksDMA::lacksDMA(const char *c, const baseDMA &rs) : baseDMA(rs)
{
    std::strncpy(color, c, COL_LEN - 1);
    color[COL_LEN - 1] = '\0';
}
std::ostream &operator<< (std::ostream &os, const lacksDMA &Is)
{
    os << (const baseDMA &) Is;
    os << "Color: " << Is.color << std::endl;
    return os;
}
hasDMA::hasDMA(const char *s, const char *l, int r) : baseDMA(l, r)
{
    style = new char[std:: strlen(s) + 1];
    std::strcpy(style, s);
}
hasDMA::hasDMA(const char *s, const baseDMA &rs) : baseDMA(rs)
{
    style = new char[std:: strlen(s) + 1];
    std::strcpy(style, s);
}
hasDMA::hasDMA(const hasDMA &hs) : baseDMA(hs)
{
    style = new char[std:: strlen(hs.style) + 1];
    std::strcpy(style, hs.style);
}
hasDMA::~hasDMA()
{
    delete[] style;
}
hasDMA &hasDMA::operator=(const hasDMA &hs)
{
    if (this == &hs)
    {
        return *this;
    }
    baseDMA::operator=(hs);
    delete[] style;
    style = new char[std:: strlen(hs.style) + 1];
    std::strcpy(style, hs.style);
    return *this;
}
std::ostream &operator<<(std::ostream &os, const hasDMA &hs)
{
    os << (const baseDMA &) hs;
    os << "Style: " << hs.style << std::endl;
    return os;
}

程序清单13.16 usedma.cpp
#include <iostream>
#include "dma.h"

int main()
{
    using std::cout;
    using std::endl;
    baseDMA shirt("Portabelly", 8);
    lacksDMA balloon("red", "Blimpo", 4);
    hasDMA map("Mercator", "Buffalo Keys", 5);
    cout << "Displaying baseDMA object:\n";
    cout << shirt << endl;
    cout << "Displaying lacksDMA object:\n";
    cout << balloon << endl;
    cout << "Displaying hasDMA object:\n";
    cout << map << endl;
    lacksDMA balloon2(balloon);
    cout << "Result of lacksDMA copy:\n";
    cout << balloon2 << endl;
    hasDMA map2;
    map2 = map;
    cout << "Result of hasDMA assignment:\n";
    cout << map2 << endl;

    return 0;
}
显示结果如下
Displaying baseDMA object:
Label: Portabelly
Rating: 8

Displaying lacksDMA object:
Label: Blimpo
Rating: 4
Color: red

Displaying hasDMA object:
Label: Buffalo Keys
Rating: 5
Style: Mercator

Result of lacksDMA copy:
Label: Blimpo
Rating: 4
Color: red

Result of hasDMA assignment:
Label: Buffalo Keys
Rating: 5
Style: Mercator

1.默认构造函数
默认构造函数要么没有参数，要么所有的参数都有默认值。
如果没有定义任何构造函数，编译器将定义默认构造函数，让您能够创建对象。
自动生成的默认构造函数的另一项功能是，调用基类的默认构造函数以及调用本身是对象的成员所属类的默认构造函数。
如果派生类构造函数的成员初始化列表中没有显式调用基类构造函数，
则编译器将使用基类的默认构造函数来构造派生类对象的基类部分。
在这种情况下，如果基类没有构造函数，将导致编译阶段错误。
如果定义了某种构造函数，编译器将不会定义默认构造函数。
在这种情况下，如果需要默认构造函数，则必须自己提供。提供构造函数的动机之一是确保对象总能被正确地初始化。
另外，如果类包含指针成员，则必须初始化这些成员。
因此，最好提供一个显式默认构造函数，将所有的类数据成员都初始化为合理的值。
2.复制构造函数
复制构造函数接受其所属类的对象作为参数。
在下述情况下，将使用复制构造函数：
将新对象初始化为一个同类对象；
按值将对象传递给函数；
函数按值返回对象；
编译器生成临时对象。
如果程序没有使用（显式或隐式）复制构造函数，编译器将提供原型，但不提供函数定义；
否则，编译器将定义一个执行成员初始化的复制构造函数。
也就是说，新对象的每个成员都被初始化为原始对象相应成员的值。
如果成员为类对象，则初始化该成员时，将使用相应类的复制构造函数。
在某些情况下，成员初始化是不合适的。例如，使用new初始化的成员指针通常要求执行深复制，
或者类可能包含需要修改的静态变量。在上述情况下，需要定义自己的复制构造函数。
3.赋值运算符
默认的赋值运算符用于处理同类对象之间的赋值。不要将赋值与初始化混淆了。
如果语句创建新的对象，则使用初始化；如果语句修改已有对象的值，则是赋值。
默认赋值为成员赋值。如果成员为类对象，则默认成员赋值将使用相应类的赋值运算符。
如果需要显式定义复制构造函数，则基于相同的原因，也需要显式定义赋值运算符。
编译器不会生成将一种类型赋给另一种类型的赋值运算符。
如果希望能够将不同类型的参数赋给对象，则方法之一是显式重载赋值运算符。
另一种方法是使用转换函数将参数转换成对应类型的临时对象，然后就可使用相同类型对应的赋值运算符。
定义类时，还需要注意其他几点。
1.构造函数
构造函数不同于其他类方法，因为它创建新的对象，而其他类方法只是被现有的对象调用。这是构造函数不被继承的原因之一。
继承意味着派生类对象可以使用基类的方法，然而，构造函数在完成其工作之前，对象并不在在。
2.析构函数
一定要定义显式析构函数来释放类构造函数使用new分配的所有内存，并完成类对象所需的任何特殊的清理工作。
对于基类，即使它不需要析构函数，也应提供一个虚析构函数。
3.转换
使用一个参数就可以调用的构造函数定义了从参数类型到类类型的转换。
在带一个参数的构造函数原型中使用explicit将禁止进行隐式转换，但仍允许显式转换。
要将类对象转换为其他类型，应定义转换函数。
C++11支持将关键字explicit用于转换函数。与构造函数一样，explicit允许使用强制类型转换进行显式转换，但不允许隐式转换。
4.按值传递对象与传递引用
通常，编写使用对象作为参数的函数时，应按引用而不是按值来传递对象。这样做的原因之一是为了提高效率。
按值传递对象涉及到生成临时拷贝，即调用复制构造函数，然后调用析构函数。
调用这些函数需要时间，复制大型对象比传递引用花费的时间要多得多。如果函数不修改对象，应将参数声明为const引用。
按引用传递对象的另外一个原因是，在继承使用虚函数时，被定义为接受基类引用参数的函数可以接受派生类。
5.返回对象和返回引用
有些类方法返回对象。您可能注意到了，有些成员函数直接返回对象，而另一些则返回引用。
有时方法必须返回对象，但如果可以不返回对象，则应返回引用。
在编码方面，直接返回对象与返回引用之间唯一的区别在于函数原型和函数头。
返回对象涉及生成返回对象的临时副本，这是调用函数的程序可以使用的副本。
因此，返回对象的时间成本包括调用复制构造函数来生成副本所需的时间和调用析构函数删除副本所需的时间。
函数不能返回在函数中创建的临时对象的引用，因为当函数结束时，临时对象将消失，因此这种引用将是非法的。
在这种情况下，应返回对象，以生成一个调用程序可以使用的副本。
如果函数返回在函数中创建的临时对象，则不要使用引用。
如果函数返回的是通过引用或指针传递给它的对象，则应按引用返回对象。
6.使用const
可以使用const来确保方法不修改参数；可以使用const来确保方法不修改调用它的对象；
可以使用const来确保返回的引用或指针不能用于修改对象中的数据。
注意，如果函数将参数声明为指向const对象的引用或指针，则不能将该参数传递给另一个函数，
除非后者也将参数声明为指向const对象的引用或指针。
1.is-a 关系
无需进行显式类型转换，基类指针就可以指向派生类对象，基类引用可以引用派生类对象。
不能在不进行显式类型转换的情况下，将派生类指针或引用指向基类对象。
2.什么不能被继承
构造函数是不能继承的，也就是说，创建派生类对象时，必须调用派生类的构造函数。
然而，派生类构造函数通常使用成员初始化列表语法来调用基类构造函数，以创建派生对象的基类部分。
如果派生类松造函数没有使用成员初始化列表语法显式调用基类构造函数，将使用基类的默认构造函数。
在继承链中，每个类都可以使用成员初始化列表将信息传递给相邻的基类。
C++11新增了一种让您能够继承构造函数的机制，但默认仍不继承构造函数。
析构函数也是不能继承的。然而，在释放对象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数。
通常，对于基类，其析构函数应设置为虚函数。
赋值运算符是不能继承的，原因很简单。派生类继承的方法的特征标与基类完全相同，但赋值运算符的特征标随类而异，
这是因为它包含一个类型为其所属类的形参。
3.赋值运算符
如果编译器发现程序将一个对象赋给同一个类的另一个对象，它将自动为这个类提供一个赋值运算符。
这个运算符的默认或隐式版本将采用成员赋值，即将原对象的相应成员赋给目标对象的每个成员。
然而，如果对象属于派生类，编译器将使用基类赋值运算符来处理派生对象中基类部分的赋值。
如果显式地为基类提供了赋值运算符，将使用该运算符。与此相似，如果成员是另一个类的对象，
则对于该成员，将使用其所属类的赋值运算符。
如果派生类构造函数使用new来初始化指针，则必须提供显式赋值运算符。
可以将派生对象赋给基类对象，但这只涉及基类的成员。
4.私有成员与保护成员
对派生类而言，保护成员类似于公有成员；但对于外部而言，保护成员与私有成员类似。
派生类可以直接访问基类的保护成员，但只能通过基类的成员函数来访问私有成员。
因此，将基类成员设置为私有的可以提高安全性，而将它们设置为保护成员则可简化代码的编写工作，并提高访问速度。
5.虚方法
设计基类时，必须确定是否将类方法声明为虚的。
如果希望派生类能够重新定义方法，则应在基类中将方法定义为虚的；
如果不希望重新定义方法，则不必将其声明为虚的。
6.析构函数
基类的析构函数应当是虚的。这样，当通过基类指针或引用来删除派生对象时，
程序将首先调用派生类的析构函数，然后调用基类的析构函数，而不仅仅是调用基类的析构函数。
7.友元函数
由于友元函数并非类成员，因此不能继承。然而，您可能希望派生类的友元函数能够使用基类的友元函数。
为此，可以通过运算符dynamic_cast<>将派生类引用或指针转换为基类引用或指针，
然后使用转换后的指针或引用来调用基类的友元函数。
8.有关使用基类方法的说明
以公有方式派生的类的对象可以通过多种方式来使用基类的方法。
派生类对象可以使用继承而来的基类方法，如果派生类没有重新定义该方法。
派生类的构造函数自动调用基类的构造函数。
派生类的构造函数自动调用基类的默认构造函数，如果没有在成员初始化列表中显式调用基类的构造函数。
派生类构造函数显式地调用成员初始化列表中指定的基类构造函数。
派生类方法可以使用作用域解析运算符来调用公有的和受保护的基类方法。
派生类的友元函数可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，
然后使用该引用或指针来调用基类的友元函数。
13.8.4 类函数小结
C++类函数有很多不同的变体，其中有些可以继承，有些不可以。
有些运算符函数既可以是成员函数，也可以是友元，而有些运算符函数只能是成员函数。
表13.1总结了这些特征，其中op=表示诸如+=、*等格式的赋值运算符。
注意，op=运算符的特征与“其他运算符”类别并没有区别。单独列出op=旨在指出这些运算符与=运算符的行为是不同的。
表13.1 成员函数属性
函数                  能否继承                  成员还是友元         默认能否生成         能否为虚函数         是否可以有返回类型
构造函数                  否                           成员                           能                           否                           否
析构函数                  否                           成员                           能                           能                           否
=                             否                           成员                           能                           能                           能
&                             能                           任意                           能                           能                           能
转换函数                  能                           成员                           否                           能                           否
()                             能                           成员                           否                           能                           能
[]                             能                           成员                           否                           能                           能
->                           能                           成员                           否                           能                           能
op=                        能                           任意                           否                           能                           能
new                        能                           静态成员                    否                           否                           void *
delete                     能                           静态成员                    否                           否                           void
其他运算符              能                           任意                           否                           能                           能
其他成员                  能                           成员                           否                           能                           能
友元                         否                           友元                           否                           否                           能
13.9总结
继承通过使用已有的类（基类）定义新的类（派生类），使得能够根据需要修改编程代码。
公有继承建立is-a关系，这意味着派生类对象也应该是某种基类对象。
作为is-a模型的一部分，派生类继承基类的数据成员和大部分方法，但不继承基类的构造函数、析构函数和赋值运算符。
派生类可以直接访问基类的公有成员和保护成员，并能够通过基类的公有方法和保护方法访问基类的私有成员。
可以在派生类中新增数据成员和方法，还可以将派生类用作基类，来做进一步的开发。
每个派生类都必须有自己的构造函数。程序创建派生类对象时，将首先调用基类的构造函数，然后调用派生类的构造函数；
程序删除对象时，将首先调用派生类的析构函数，然后调用基类的析构函数。
如果要将类用作基类，则可以将成员声明为保护的，而不是私有的，这样，派生类将可以直接访问这些成员。
然而，使用私有成员通常可以减少出现编程问题的可能性。
如果希望派生类可以重新定义基类的方法，则可以使用关键字virtual将它声明为虚的。
这样对于通过指针或引用访问的对象，能够根据对象类型来处理，而不是根据引用或指针的类型来处理。
具体地说，基类的析构函数通常应当是虚的。
可以考虑定义一个ABC：只定义接口，而不涉及实现。ABC必须至少包含一个纯虚方法，
可以在声明中的分号前面加上= 0来声明纯虚方法，不一定非得定义纯虚方法。
对于包含纯虚成员的类，不能使用它来创建对象。纯虚方法用于定义派生类的通用接口。
13.10复习题
1.派生类从基类那里继承了什么？
基类的公有成员成为派生类的公有成员。基类的保护成员成为派生类的保护成员。基类的私有成员被继承，但不能直接访问。

2.派生类不能从基类那里继承什么？
不能继承构造函数、析构函数、赋值运算符和友元。

3.假设baseDMA::operator=()函数的返回类型为void，而不是baseDMA &，这将有什么后果？
如果返回类型为baseDMA，而不是baseDMA &，又将有什么后果？
如果返回的类型为void，仍可以使用单个赋值，但不能使用连锁赋值；
如果返回对象而不是返回引用；则该方法的执行速度将所减慢，这是因为返回语句需要复制对象。

4.创建和删除派生类对象时，构造函数和析构函数调用的顺序是怎样的？
按派生的顺序调用构造函数，最早的构造函数最先调用。调用析构函数的顺序正好相反。

5.如果派生类没有添加任何数据成员，它是否需要构造函数？
是的，每个类都必须有自己的构造函数。如果派生类没有添加新成员，则构造函数可以为空，但必须存在。

6.如果基类和派生类定义了同名的方法，当派生类对象调用该方法时，被调用的将是哪个方法？
调用派生类方法。它取代基类定义。当派生类没有重新定义方法或使用作用域解析运算符时，才会调用基类方法。
通常，应将所有要重新定义的函数声明为虚函数。

7.在什么情况下，派生类应定义赋值运算符？
如果派生类构造函数使用new或new []运算符来初始化类的指针成员，则应定义赋值运算符。
更普遍地说，如果对于派生类成员来说，默认赋值运算符不能正确完成赋值；则应定义赋值运算符。

8.可以将派生类对象的地址赋给基类指针吗？可以将基类对象的地址赋给派生类指针吗？
可以将派生类对象的地址赋给基类指针；
只有通过显式类型转换，才可以将基类对象的地址赋给派生类指针，而使用这样的指针不一定安全。

9.可以将派生类对象赋给基类对象吗？可以将基类对象赋给派生类对象吗？
可以将派生类对象赋给基类对象。派生类中新增的数据成员不会传递给基类对象。程序将使用基类的赋值运算符。
仅当派生类定义了转换运算符（即包含将基类引用作为唯一参数的构造函数）或使用基类为参数的赋值运算符时，相反方向的赋值才是可能的。

10.假设定义了一个函数，它将基类对象的引用作为参数。为什么该函数也可以将派生类对象作为参数？
因为C++允许基类引用指向从该基类派生而来的任何类型。

11.假设定义了一个函数，它将基类对象作为参数（即函数按值传递基类对象）。为什么该函数也可以将派生类对象作为参数？
按值传递对象将调用复制构造函数。由于形参是基类对象，因此将调用基类的复制构造函数。
复制构造函数以基类引用为参数，该引用可以指向作为参数传递的派生对象。最终结果是，将生成一个新的基类对象，其成员对应于派生对象的基类部分。

12.为什么通常按引用传递对象比按值传递对象的效率更高？
按引用（而不是按值）传递对象，这样可以确保函数从虚函数受益。
按引用（而不是按值）传递对象可以节省内存和时间尤其对于大型对象。
按值传递对象的主要优点在于可以保护原始数据，但可以通过将引用作为const类型传递，来达到同样的目的。

13.假设Corporation是基类，PublicCorporation是派生类。再假设这两个类都定义了head函数，
ph是指向Corporation类型的指针，且被赋给了一个PublicCorporation对象的地址。如果基类将head定义为：
a.常规非虚方法；
b.虚方法；
则ph->head将被如何解释？
如果head是一个常规方法，则ph->head将调用Corporation:head；
如果head是一个虚函数，测ph->head将调用PublicCorporation::head。

14.下述代码有什么问题？
class Kitchen
{
private:
    double kit_sq_ft;
public:
    Kitchen() {kit_sq_ft = 0.0;}
    virtual double area() const {return kit_sq_ft * kit_sq_ft;}
};
class House : public Kitchen
{
private:
    double all_sq_ft;
public:
    House () {all_sq_ft += kit_sq_ft;}
    double area(const char * s) const {cout << s; return all_sq_ft;} 
};
首先，Kitchen和House不符合is-a模型，因此公有继承不适。
其次，House中的area定义隐藏了基类Kitchen中的area。
House不能直接访问基类Kitchen中的私有成员。

13.11编程练习
1.以下面的类声明为基础：
派生出一个Classic类，并添加一组char成员，用于存储指出CD中主要作品的字符串。
修改上述声明，使基类的所有函数都是虚的。如果上述定义声明的某个方法并不需要，则请删除它。
cd.h
#pragma once
#ifndef CD_H_
#define CD_H_
#include <iostream>
#include <cstring>

class Cd
{
private:
    char performers[50];
    char label[20];
    int selections;
    double playtime;
public:
    Cd();
    Cd(const char *perf, const char *leb, int sel, double playt);
    Cd(const Cd &d);
    virtual ~Cd();
    virtual void Report() const;
    Cd &operator = (const Cd &d);
};

class Classic : public Cd
{
private:
    static const int lenght = 40;
    char cdname[lenght];
public:
    Classic();
    Classic(const char *name, Cd &cd);
    Classic(const char *name, const char *perf, const char *leb, int sel, double playt);
    Classic(const Classic &c);
    ~Classic();
    virtual void Report() const;
    Classic &operator = (const Classic &c);
};

#endif

cd.cpp
#include <iostream>
#include "cd.h"

Cd::Cd()
{
    performers[0] = '\0';
    label[0] = '\0';
    selections = 0;
    playtime = 0;
}
Cd::Cd(const char *perf, const char *leb, int sel, double playt)
{
    strncpy(performers, perf, 50 - 1);
    performers[50 - 1] = '\0';
    strncpy(label, leb, 20 - 1);
    label[20 - 1] = '\0';

    if (sel < 0)
    {
        std::cout << "Selections must be a positive integer. ";
        std::cout << "Setting selections to 0." << std::endl;
        selections = 0;
    }
    else
    {
        selections = sel;
    }

    if (playt < 0)
    {
        std::cout << "Play time must be a positive real number. ";
        std::cout << "Setting play time to 0." << std::endl;
        playtime = 0;
    }
    else
    {
        playtime = playt;
    }
}

Cd::Cd(const Cd &d)
{
    strncpy(performers, d.performers, 50 - 1);
    performers[50 - 1] = '\0';
    strncpy(label, d.label, 20 - 1);
    label[20 - 1] = '\0';
    selections = d.selections;
    playtime = d.playtime;
}

Cd::~Cd()
{

}

Cd &Cd::operator = (const Cd &d)
{
    if (this == &d)
    {
        return *this;
    }
    strncpy(performers, d.performers, 50 - 1);
    performers[50 - 1] = '\0';
    strncpy(label, d.label, 20 - 1);
    label[20 - 1] = '\0';
    selections = d.selections;
    playtime = d.playtime;

    return *this;
}

void Cd::Report() const
{
    std::cout << "Performers: " << performers << std::endl;
    std::cout << "label: " << label << std::endl;
    std::cout << "Selections: " << selections << std::endl;
    std::cout << "Play time: " << playtime << std::endl;
}

Classic::Classic()
{
    cdname[0] = '\0';
}

Classic::Classic(const char *name, Cd &cd) : Cd(cd)
{
    strncpy(cdname, name, 40 - 1);
    cdname[40 - 1] = '\0';
}

Classic::Classic(const char *name, const char *perf, const char *leb, int sel, double playt) : Cd(perf, leb, sel, playt)
{
    strncpy(cdname, name, 40 - 1);
    cdname[40 - 1] = '\0';
}

Classic::Classic(const Classic &c) : Cd(c)
{
    strncpy(cdname, c.cdname, 40 - 1);
    cdname[40 - 1] = '\0';
}

Classic::~Classic()
{

}

void Classic::Report() const
{
    Cd::Report();
    std::cout << "Primary Work: " << cdname << std::endl;
}

Classic &Classic::operator = (const Classic &c)
{
    if (this == &c)
    {
        return *this;
    }
    Cd::operator=(c);
    strncpy(cdname, c.cdname, 40 - 1);
    cdname[40 - 1] = '\0';

    return *this;
}

ch13_p01.cpp
#include <iostream>
#include "cd.h"

void Bravo(const Cd &disk);

int main()
{
    Cd c1("Beatles", "Capitol", 14, 35.5);
    Classic c2 = Classic("Piano sonata in b flat, Fantasia in C", "Alfred Brendel", "Phillips", 2, 57.17);
    Cd *pcd = &c1;

    std::cout << "Using object directly: " << std::endl;
    std::cout << std::endl;
    c1.Report();
    std::cout << std::endl;
    c2.Report();
    std::cout << std::endl;

    std::cout << "Using type cd* pointer to objects: " << std::endl;;
    std::cout << std::endl;
    pcd->Report();
    std::cout << std::endl;
    pcd = &c2;
    pcd->Report();
    std::cout << std::endl;

    std::cout << "Calling a function with a Cd reference argument: " << std::endl;;
    std::cout << std::endl;
    Bravo(c1);
    std::cout << std::endl;
    Bravo(c2);
    std::cout << std::endl;

    std::cout << "Testing assignment: " << std::endl;
    Classic copy;
    copy = c2;
    copy.Report();

    return 0;
}

void Bravo(const Cd &disk)
{
    disk.Report();
}
显示结果如下
Using object directly:

Performers: Beatles
label: Capitol
Selections: 14
Play time: 35.5

Performers: Alfred Brendel
label: Phillips
Selections: 2
Play time: 57.17
Primary Work: Piano sonata in b flat, Fantasia in C

Using type cd* pointer to objects:

Performers: Beatles
label: Capitol
Selections: 14
Play time: 35.5

Performers: Alfred Brendel
label: Phillips
Selections: 2
Play time: 57.17
Primary Work: Piano sonata in b flat, Fantasia in C

Calling a function with a Cd reference argument:

Performers: Beatles
label: Capitol
Selections: 14
Play time: 35.5

Performers: Alfred Brendel
label: Phillips
Selections: 2
Play time: 57.17
Primary Work: Piano sonata in b flat, Fantasia in C

Testing assignment:
Performers: Alfred Brendel
label: Phillips
Selections: 2
Play time: 57.17
Primary Work: Piano sonata in b flat, Fantasia in C

2.完成练习1，但让两个类使用动态内存分配而不是长度固定的数组来记录字符串。
cd2.h
#pragma once
#ifndef CD2_H_
#define CD2_H_
#include <iostream>
#include <cstring>

class Cd
{
private:
    char *performers;
    char *label;
    int selections;
    double playtime;
public:
    Cd();
    Cd(const char *perf, const char *leb, int sel, double playt);
    Cd(const Cd &d);
    virtual ~Cd();
    virtual void Report() const;
    Cd &operator = (const Cd &d);
};

class Classic : public Cd
{
private:
    char *cdname;
public:
    Classic();
    Classic(const char *name, Cd &cd);
    Classic(const char *name, const char *perf, const char *leb, int sel, double playt);
    Classic(const Classic &c);
    ~Classic();
    virtual void Report() const;
    Classic &operator = (const Classic &c);
};

#endif

cd2.cpp
#include "cd2.h"

Cd::Cd()
{
    performers = nullptr;
    label = nullptr;
    selections = 0;
    playtime = 0;
}

Cd::Cd(const char *perf, const char *leb, int sel, double playt)
{
    if (perf == nullptr)
    {
        performers = nullptr;
    }
    else
    {
        performers = new char[strlen(perf) + 1];
        strcpy(performers, perf);
    }

    if (leb == nullptr)
    {
        label = nullptr;
    }
    else
    {
        label = new char[strlen(leb) + 1];
        strcpy(label, leb);
    }

    if (sel < 0)
    {
        std::cout << "Selections must be a positive integer. ";
        std::cout << "Setting selections to 0." << std::endl;
        selections = 0;
    }
    else
    {
        selections = sel;
    }

    if (playt < 0)
    {
        std::cout << "Play time must be a positive real number. ";
        std::cout << "Setting play time to 0." << std::endl;
        playtime = 0;
    }
    else
    {
        playtime = playt;
    }
}

Cd::Cd(const Cd &d)
{
    if (d.performers == nullptr)
    {
        performers = nullptr;
    }
    else
    {
        performers = new char[strlen(d.performers) + 1];
        strcpy(performers, d.performers);
    }

    if (d.label == nullptr)
    {
        label = nullptr;
    }
    else
    {
        label = new char[strlen(d.label) + 1];
        strcpy(label, d.label);
    }
    selections = d.selections;
    playtime = d.playtime;
}

Cd::~Cd()
{
    delete[] performers;
    delete[] label;
}

Cd &Cd::operator = (const Cd &d)
{
    if (this == &d)
    {
        return *this;
    }
    else
    {
        delete[] performers;
        delete[] label;

        if (d.performers == nullptr)
        {
            performers = nullptr;
        }
        else
        {
            performers = new char[strlen(d.performers) + 1];
            strcpy(performers, d.performers);
        }

        if (d.label == nullptr)
        {
            label = nullptr;
        }
        else
        {
            label = new char[strlen(d.label) + 1];
            strcpy(label, d.label);
        }
    }

    selections = d.selections;
    playtime = d.playtime;

    return *this;
}

void Cd::Report() const
{
    std::cout << "Performers: " << performers << std::endl;
    std::cout << "label: " << label << std::endl;
    std::cout << "Selections: " << selections << std::endl;
    std::cout << "Play time: " << playtime << std::endl;
}

Classic::Classic()
{
    cdname = nullptr;
}

Classic::Classic(const char *name, Cd &cd) : Cd(cd)
{
    if (name == nullptr)
    {
        cdname = nullptr;
    }
    else
    {
        cdname = new char[strlen(name) + 1];
        strcpy(cdname, name);
    }
}

Classic::Classic(const char *name, const char *perf, const char *leb, int sel, double playt)  : Cd(perf, leb, sel, playt)
{
    if (name == nullptr)
    {
        cdname = nullptr;
    }
    else
    {
        cdname = new char[strlen(name) + 1];
        strcpy(cdname, name);
    }
}

Classic::Classic(const Classic &c) : Cd(c)
{
    if (c.cdname == nullptr)
    {
        cdname = nullptr;
    }
    else
    {
        cdname = new char[strlen(c.cdname) + 1];
        strcpy(cdname, c.cdname);
    }
}
Classic::~Classic()
{
    delete[] cdname;
}

void Classic::Report() const
{
    Cd::Report();
    std::cout << "Primary Work: " << cdname << std::endl;
}

Classic &Classic::operator = (const Classic &c)
{
    if (this == &c)
    {
        return *this;
    }
    else
    {
        Cd::operator=(c);
        delete[] cdname;

        if (c.cdname == nullptr)
        {
            cdname = nullptr;
        }
        else
        {
            cdname = new char[strlen(c.cdname) + 1];
            strcpy(cdname, c.cdname);
        }
    }
    return *this;
}

ch13_p02.cpp
#include "cd2.h"


void Bravo(const Cd &disk);

int main()
{
    Cd c1("Beatles", "Capitol", 14, 35.5);
    Classic c2 = Classic("Piano sonata in b flat, Fantasia in C", "Alfred Brendel", "Phillips", 2, 57.17);
    Cd *pcd = &c1;

    std::cout << "Using object directly: " << std::endl;
    std::cout << std::endl;
    c1.Report();
    std::cout << std::endl;
    c2.Report();
    std::cout << std::endl;

    std::cout << "Using type cd* pointer to objects: " << std::endl;;
    std::cout << std::endl;
    pcd->Report();
    std::cout << std::endl;
    pcd = &c2;
    pcd->Report();
    std::cout << std::endl;

    std::cout << "Calling a function with a Cd reference argument: " << std::endl;;
    std::cout << std::endl;
    Bravo(c1);
    std::cout << std::endl;
    Bravo(c2);
    std::cout << std::endl;

    std::cout << "Testing assignment: " << std::endl;
    Classic copy;
    copy = c2;
    copy.Report();

    return 0;
}

void Bravo(const Cd &disk)
{
    disk.Report();
}
显示结果如下
Using object directly:

Performers: Beatles
label: Capitol
Selections: 14
Play time: 35.5

Performers: Alfred Brendel
label: Phillips
Selections: 2
Play time: 57.17
Primary Work: Piano sonata in b flat, Fantasia in C

Using type cd* pointer to objects:

Performers: Beatles
label: Capitol
Selections: 14
Play time: 35.5

Performers: Alfred Brendel
label: Phillips
Selections: 2
Play time: 57.17
Primary Work: Piano sonata in b flat, Fantasia in C

Calling a function with a Cd reference argument:

Performers: Beatles
label: Capitol
Selections: 14
Play time: 35.5

Performers: Alfred Brendel
label: Phillips
Selections: 2
Play time: 57.17
Primary Work: Piano sonata in b flat, Fantasia in C

Testing assignment:
Performers: Alfred Brendel
label: Phillips
Selections: 2
Play time: 57.17
Primary Work: Piano sonata in b flat, Fantasia in C

3.修改baseDMA-lacksDMA-hasDMA类层次，让三个类都从一个ABC派生而来，
然后使用与程序清单13.10相似的程序对结果进行测试。也就是说，它应使用ABC指针数组，并让用户决定要创建的对象类型。
在类定义中添加virtual View方法以处理数据显示。
dma2.h
#pragma once
#ifndef DMA2_H_
#define DMA2_H_
#include <iostream>
#include <cstring>

class abcDMA
{
private:
    char *label;
    int rating;
protected:
    const char *showLabel() const
    {
        return label;
    }
    int showRating() const
    {
        return rating;
    }
public:
    abcDMA(const char *l = "NULL", int r = 0);
    abcDMA(const abcDMA &rs);
    virtual void View() const = 0;
    virtual ~abcDMA();
    abcDMA &operator = (const abcDMA &rs);
    friend std::ostream &operator << (std::ostream &os, const abcDMA &rs);
};

class baseDMA : public abcDMA
{
private:
public:
    baseDMA(const char *l = "null", int r = 0);
    baseDMA(const baseDMA &rs);
    virtual ~baseDMA();
    baseDMA &operator = (const baseDMA &rs);
    friend std::ostream &operator << (std::ostream &os, const baseDMA &rs);
    virtual void View() const;
};

class lacksDMA : public abcDMA
{
private:
    enum { COL_LEN = 40 };
    char color[COL_LEN];
public:
    lacksDMA(const char *c = "blank", const char *l = "null", int r = 0);
    lacksDMA(const char *c, const abcDMA &rs);
    friend std::ostream &operator<<(std::ostream &os, const lacksDMA &ls);
    virtual void View() const;
};

class hasDMA : public abcDMA
{
private:
    char *style;
public:
    hasDMA(const char *s = "none", const char *l = "null", int r = 0);
    hasDMA(const char *s, const abcDMA &rs);
    hasDMA(const hasDMA &hs);
    ~hasDMA();
    hasDMA &operator = (const hasDMA &rs);
    friend std::ostream &operator << (std::ostream &os, const hasDMA &hs);
    virtual void View() const;
};

#endif

dma2.cpp
#include "dma2.h"

abcDMA::abcDMA(const char *l, int r)
{
    label = new char[std:: strlen(l) + 1];
    std::strcpy(label, l);
    rating = r;
}

abcDMA::abcDMA(const abcDMA &rs)
{
    label = new char[std:: strlen(rs.label) + 1];
    std::strcpy(label, rs.label);
    rating = rs.rating;
}

void abcDMA::View() const
{
    std::cout << "Label: " << label << std::endl;
    std::cout << "Rating: " << rating << std::endl;
}

abcDMA::~abcDMA()
{
    delete[] label;
}

abcDMA   &abcDMA::operator = (const abcDMA &rs)
{
    if (this == &rs)
    {
        return *this;
    }
    else
    {
        delete[] label;
        label = new char[std:: strlen(rs.label) + 1];
        std::strcpy(label, rs.label);
        rating = rs.rating;
        return *this;
    }
}

std::ostream &operator << (std::ostream &os, const abcDMA &rs)
{
    os << "Label: " << rs.label << std::endl;
    os << "Rating: " << rs.rating << std::endl;
    return os;
}

baseDMA::baseDMA(const char *l, int r) : abcDMA(l, r) { }

baseDMA::baseDMA(const baseDMA &rs) : abcDMA(rs) { }

baseDMA::~baseDMA() { }

baseDMA &baseDMA::operator = (const baseDMA &rs)
{
    if (this == &rs)
    {
        return *this;
    }
    abcDMA::operator=(rs);
    return *this;
}
void baseDMA::View() const
{
    std::cout << "baseDMA object" << std::endl;
    std::cout << "Label: " << showLabel() << std::endl;
    std::cout << "Rating: " << showRating() << std::endl;
}
std::ostream &operator << (std::ostream &os, const baseDMA &rs)
{
    os << (const abcDMA &)rs;
    return os;
}

lacksDMA::lacksDMA(const char *c, const char *l, int r) : abcDMA(l, r)
{
    std::strncpy(color, c, COL_LEN - 1);
    color[COL_LEN - 1] = '\0';
}
lacksDMA::lacksDMA(const char *c, const abcDMA &rs) : abcDMA(rs)
{
    std::strncpy(color, c, COL_LEN - 1);
    color[COL_LEN - 1] = '\0';
}

void lacksDMA::View() const
{
    std::cout << "lacksDMA object" << std::endl;
    abcDMA::View();
    std::cout << "Color: " << color << std::endl;
}

std::ostream &operator << (std::ostream &os, const lacksDMA &Is)
{
    os << (const abcDMA &) Is;
    os << "Color: " << Is.color << std::endl;
    return os;
}
hasDMA::hasDMA(const char *s, const char *l, int r) : abcDMA(l, r)
{
    style = new char[std::strlen(s) + 1];
    std::strcpy(style, s);
}
hasDMA::hasDMA(const char *s, const abcDMA &rs) : abcDMA(rs)
{
    style = new char[std::strlen(s) + 1];
    std::strcpy(style, s);
}
hasDMA::hasDMA(const hasDMA &hs) : abcDMA(hs)
{
    style = new char[std::strlen(hs.style) + 1];
    std::strcpy(style, hs.style);
}

hasDMA::~hasDMA()
{
    delete[] style;
}

hasDMA &hasDMA::operator = (const hasDMA &hs)
{
    if (this == &hs)
    {
        return *this;
    }
    else
    {
        abcDMA::operator=(hs);
        delete[] style;
        style = new char[std::strlen(hs.style) + 1];
        std::strcpy(style, hs.style);
        return *this;
    }
}

void hasDMA::View() const
{
    std::cout << "hasDMA object" << std::endl;
    abcDMA::View();
    std::cout << "Style: " << style << std::endl;
}

std::ostream &operator << (std::ostream &os, const hasDMA &hs)
{
    os << (const abcDMA &) hs;
    os << "Style: " << hs.style << std::endl;
    return os;
}

ch13_p03.cpp
#include "dma2.h"

const int ArrLength = 3;
const int LEN = 40;

int main()
{
    abcDMA *arr[ArrLength];
    char label[LEN];
    char style[LEN];
    char color[LEN];

    int rating = 0;
    int choice = 0;

    for (int i = 0; i < ArrLength; i++)
    {
        std::cout << "For element " << i + 1 << ", enter the label: ";
        std::cin.getline(label, LEN);

        std::cout << "Enter the rating: ";
        std::cin >> rating;

        std::cout << "Enter 1 if this is to be a baseDMA object" << std::endl;
        std::cout << "Enter 2 if this is to be a hasDMA object" << std::endl;
        std::cout << "Enter 3 if this is to be a lacksDMA object" << std::endl;
        std::cin >> choice;
        std::cin.get();

        switch (choice)
        {
        case 1:
            arr[i] = new baseDMA(label, rating);
            break;
        case 2:
            std::cout << "Enter the style: ";
            std::cin.getline(style, LEN);
            arr[i] = new hasDMA(style, label, rating);
            break;
        case 3:
            std::cout << "Enter color: ";
            std::cin.getline(color, LEN);
            arr[i] = new lacksDMA(color, label, rating);
            break;
        default:
            std::cout << "Unrecognized input, setting object ";
            std::cout << "to baseDMA";
            arr[i] = new baseDMA(label, rating);
            break;
        }

    }
    std::cout << "Here's what you entered:" << std::endl;

    for (int i = 0; i < ArrLength; i++)
    {
        std::cout << "Element " << i + 1 << ":" << std::endl;
        arr[i]->View();
    }

    for (int i = 0; i < ArrLength; i++)
    {
        delete arr[i];
    }

    return 0;
}
显示结果如下
For element 1, enter the label: Portabelly
Enter the rating: 8
Enter 1 if this is to be a baseDMA object
Enter 2 if this is to be a hasDMA object
Enter 3 if this is to be a lacksDMA object
1
For element 2, enter the label: Buffalo Keys
Enter the rating: 5
Enter 1 if this is to be a baseDMA object
Enter 2 if this is to be a hasDMA object
Enter 3 if this is to be a lacksDMA object
2
Enter the style: Mercator
For element 3, enter the label: Blimpo
Enter the rating: 4
Enter 1 if this is to be a baseDMA object
Enter 2 if this is to be a hasDMA object
Enter 3 if this is to be a lacksDMA object
3
Enter color: red
Here's what you entered:
Element 1:
baseDMA object
Label: Portabelly
Rating: 8
Element 2:
hasDMA object
Label: Buffalo Keys
Rating: 5
Style: Mercator
Element 3:
lacksDMA object
Label: Blimpo
Rating: 4
Color: red

4.Benevolent Order of Programmers用来维护瓶装葡萄酒箱。为描述它，BOP Portmaster设置了一个Port类，其声明如下：
show（）方法按下面的格式显示信息：
operator<<()函数按下面的格式显示信息（末尾没有换行符）：
PortMaster完成了Port类的方法定义后派生了VintagePort类，VintagePort类如下所示：
您被指定负责完成VintagePort。
a.第一个任务是重新创建Port方法定义，因为前任被开除时销毁了方法定义。
b.第二个任务是解释为什么有的方法重新定义了，而有些没有重新定义。
c.第三个任务是解释为何没有将operator=（）和operator<<（）声明为虚的。
d.第四个任务是提供VintagePort中各个方法的定义。
port.h
#pragma once
#ifndef PORT_H_
#define PORT_H_
#include <iostream>
#include <cstring>

class Port
{
private:
    char *brand;
    char style[20];
    int bottles;
public:
    Port(const char *br = "none", const char *st = "none", int b = 0);
    Port(const Port &p);
    virtual ~Port()
    {
        delete[] brand;
    }
    Port &operator = (const Port &p);
    Port &operator += (int b);
    Port &operator -= (int b);
    int BottleCount() const
    {
        return bottles;
    }
    virtual void Show() const;
    friend std::ostream &operator << (std::ostream &os, const Port &p);
};

#endif

port.cpp
#include "port.h"

Port::Port(const char *br, const char *st, int b)
{
    brand = new char[strlen(br) + 1];
    strcpy(brand, br);
    strncpy(style, st, 19);
    style[19] = '\0';

    if (b < 0)
    {
        std::cout << "Number of bottles must be a positive integer." << std::endl;
        std::cout << "Setting bottles to 0." << std::endl;
        bottles = 0;
    }
    else
    {
        bottles = b;
    }
}

Port::Port(const Port &p)
{
    brand = new char[strlen(p.brand) + 1];
    strcpy(brand, p.brand);
    strncpy(style, p.style, 19);
    style[19] = '\0';
    bottles = p.bottles;
}

Port &Port::operator = (const Port &p)
{
    if (this == &p)
    {
        return *this;
    }
    else
    {
        delete[] brand;
        brand = new char[strlen(p.brand) + 1];
        strcpy(brand, p.brand);
        strncpy(style, p.style, 19);
        style[19] = '\0';
        bottles = p.bottles;
        return *this;
    }
}

Port &Port::operator += (int b)
{
    bottles += b;
    return *this;
}
Port &Port::operator -= (int b)
{
    if (b > bottles)
    {
        std::cout << "You cannot subtract more bottles than you have!" << std::endl;
        std::cout << "Subtracting " << bottles << " bottles." << std::endl;
        bottles = 0;
    }
    else
    {
        bottles -= b;
    }
    return *this;
}

void Port::Show() const
{
    std::cout << "Brand: " << brand << std::endl;
    std::cout << "Kind: " << style << std::endl;
    std::cout << "Bottles: " << bottles << std::endl;
}

std::ostream &operator<<(std::ostream &os, const Port &p)
{
    os << p.brand << ", " << p.style << ", " << p.bottles;
    return os;
}

vintageport.h
#pragma once
#ifndef VINTAGEPORT_H_
#define VINTAGEPORT_H_
#include "port.h"

class VintagePort : public Port
{
private:
    char *nickname;
    int year;
public:
    VintagePort();
    VintagePort(const char *br, int b, const char *nn, int y);
    VintagePort(const VintagePort &vp);
    ~VintagePort()
    {
        delete[] nickname;
    }
    VintagePort &operator = (const VintagePort &vp);
    void Show() const;
    friend std::ostream &operator << (std::ostream &os, const VintagePort &vp);
};

#endif

vintageport.cpp
#include <iostream>
#include <cstring>
#include "vintageport.h"

VintagePort::VintagePort() : Port("The Noble", "Vintage")
{
    nickname = nullptr;
    year = 1900;
}

VintagePort::VintagePort(const char *br, int b, const char *nn, int y) : Port(br, "Vintage", b)
{
    nickname = new char[strlen(nn) + 1];
    strcpy(nickname, nn);
    year = y;
}

VintagePort::VintagePort(const VintagePort &vp) : Port(vp)
{
    nickname = new char[strlen(vp.nickname) + 1];
    strcpy(nickname, vp.nickname);
    year = vp.year;
}

VintagePort &VintagePort::operator = (const VintagePort &vp)
{
    if (this == &vp)
    {
        return *this;
    }
    else
    {
        Port::operator=(vp);
        delete[] nickname;
        nickname = new char[strlen(vp.nickname) + 1];
        strcpy(nickname, vp.nickname);
        year = vp.year;
        return *this;
    }
}

void VintagePort::Show() const
{
    Port::Show();
    std::cout << "Nickname: " << nickname << std::endl;
    std::cout << "Year: " << year << std::endl;
}

std::ostream &operator<<(std::ostream &os, const VintagePort &vp)
{
    os << (const Port &)vp;

    if (nullptr == vp.nickname)
    {
        os << ", " << vp.year;
    }
    else
    {
        os << ", " << vp.nickname << ", " << vp.year;
    }
    return os;
}

ch13_p04.cpp
#include <iostream>
#include "vintageport.h"

const int arrSize = 2;
const int LEN = 50;

int main()
{
    char brand[LEN];
    char style[LEN];
    int bottles = 0;
    char nickname[LEN];
    int year = 0;
    int choice = 0;
    Port *arr[arrSize];

    for (int i = 0; i < arrSize; i++)
    {
        std::cout << "Object " << i + 1 << std::endl;
        std::cout << "Enter the brand for the object: ";
        std::cin.getline(brand, LEN);
        std::cout << "Enter the number of bottles: ";
        std::cin >> bottles;
        std::cin.get();
        std::cout << "Enter 1 if you would like this to be a Port object" << std::endl;
        std::cout << "Enter 2 if you would like this to be a Vintage Port object";
        std::cout << std::endl;
        std::cin >> choice;
        std::cin.get();

        switch (choice)
        {
        case 1:
            std::cout << "Enter the style: ";
            std::cin.getline(style, LEN);
            arr[i] = new Port(brand, style, bottles);
            std::cout << std::endl;
            break;
        case 2:
            std::cout << "Enter the nickname: ";
            std::cin.getline(nickname, LEN);
            std::cout << "Enter the year: ";
            std::cin >> year;
            std::cin.get();
            arr[i] = new VintagePort(brand, bottles, nickname, year);
            std::cout << std::endl;
            break;
        default:
            std::cout << "Input not recognized. Making a default Port object";
            arr[i] = new Port();
            std::cout << std::endl;
            break;
        }
    }

    std::cout << "Here's our array:" << std::endl;
    for (int i = 0; i < arrSize; i++)
    {
        std::cout << "Object " << i + 1 << std::endl;
        arr[i]->Show();
    }
    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Object 1
Enter the brand for the object: Hello World
Enter the number of bottles: 20
Enter 1 if you would like this to be a Port object
Enter 2 if you would like this to be a Vintage Port object
1
Enter the style: aaabbb

Object 2
Enter the brand for the object: Mike Pence
Enter the number of bottles: 30
Enter 1 if you would like this to be a Port object
Enter 2 if you would like this to be a Vintage Port object
2
Enter the nickname: cccddd
Enter the year: 2020

Here's our array:
Object 1
Brand: Hello World
Kind: aaabbb
Bottles: 20
Object 2
Brand: Mike Pence
Kind: Vintage
Bottles: 30
Nickname: cccddd
Year: 2020
Done.

第14章 C++中的代码重用
14.1 包含对象成员的类
14.1.1 valarray类简介
14.1.2 Student类的设计
14.1.3 Student类示例
14.2 私有继承
14.2.1 Student 类示例（新版本）
14.2.2 使用包含还是私有继承
14.2.3 保护继承
14.2.4 使用using重新定义访问权限
14.3 多重继承
14.3.1 有多少Worker
14.3.2 哪个方法
14.3.3 MI小结
14.4 类模板
14.4.1 定义类模板
14.4.2 使用模板类
14.4.3 深入探讨模板类
14.4.4 数组模板示例和非类型参数
14.4.5 模板多功能性
14.4.6 模板的具体化
14.4.7 成员模板
14.4.8 将模板用作参数
14.4.9 模板类和友元
14.4.10 模板别名（C++11）
14.5 总结
14.6 复习题
14.7 编程练习
本章内容包括：
has-a关系。
包含对象成员的类。
模板类valarray。
私有和保护继承。
多重继承。
虚基类。
创建类模板。
使用类模板。
模板的具体化。
valarray模板类是由头文件valarray支持的。这个类用于处理数值（或具有类似特性的类），
它支持诸如将数组中所有元素的值相加以及在数组中找出最大和最小的值等操作。
使用valarray类来声明一个对象时需要在标识符valarray后面加上一对尖括号，并在其中包含所需的数据类型：
valarray<double> weights;
double gpa[5] = {3.1, 3.5, 3.8, 2.9, 3.3};
valarray<double> v1;   // an array of double, size 0
valarray<int> v2(8);   //an array of 8 int elements
valarray<int> v3(10, 8); //an array of 8 int elements, each set to 10
valarray<double> v4(gpa, 4)   // an array of 4 elements initialize to the first 4 elements of gpa
valarray<int> v5 = {20, 32, 17, 9};   //C++11初始化列表
可以创建长度为零的空数组，指定长度的空数组、所存元素度被初始化为指定值的数组、用常规数组中的值进行初始化的数组。
在C++11中，也可使用初始化列表。
下面是这个类的一些方法。
operator[]：让您能够访问各个元素。
size：返回包含的元素数。
sum：返回所有元素的总和。
max：返回最大的元素。
min（）：返回最小的元素。
程序清单14.1 studentc.h
#pragma once
#ifndef STUDENTC_H_
#define STUDENTC_H_
#include <iostream>
#include <string>
#include <valarray>

class Student
{
private:
    typedef std::valarray<double> ArrayDb;
    std::string name;
    ArrayDb scores;
    std::ostream &arr_out(std::ostream &os) const;
public:
    Student() : name("Null Student"), scores() {}
    explicit Student(const std::string &s) : name(s), scores() {}
    explicit Student(int n) : name("Nully"), scores(n) {}
    Student(const std::string &s, int n) : name(s), scores(n) {}
    Student(const std::string &s, const ArrayDb &a) : name(s), scores(a) {}
    Student(const char *str, const double *pd, int n) : name(str), scores(pd, n) {}
    ~Student() {}
    double Average() const;
    const std::string &Name() const;
    double &operator[] (int i);
    double operator[] (int i) const;
    friend std::istream &operator>>(std::istream &is, Student &stu);
    friend std::istream &getline(std::istream &is, Student &stu);
    friend std::ostream &operator<<(std::ostream &os, const Student &stu);
};

#endif
使用explicit防止单参数构造函数的隐式转换，使用const限制方法修改数据。
对于继承的对象，构造函数在成员初始化列表中使用类名来调用特定的基类构造函数；对于成员对象，构造函数则使用成员名。
C++要求在构建对象的其他部分之前，先构建继承的对象和所有成员对象。
如果省略初始化列表，C++将使用成员对象所属类的默认构造函数。
当初始化列表包含多个项目时，这些项目被初始化的顺序为它们被声明的顺序，而不是它们在初始化列表中的顺序。
通常，初始化顺序并不重要，但如果代码使用一个成员的值作为另一个成员的初始化表达式的一部分时，
初始化顺序就非常重要了。
程序清单14.2 studentc.cpp
#include <iostream>
#include "studentc.h"

double Student::Average() const
{
    if (scores.size() > 0)
    {
        return scores.sum() / scores.size();
    }
    else
    {
        return 0;
    }
}
const std::string &Student::Name() const
{
    return name;
}
double &Student::operator[](int i)
{
    return scores[i];
}
double Student::operator[](int i) const
{
    return scores[i];
}
std::ostream &Student::arr_out(std::ostream &os) const
{
    int i;
    int lim = scores.size();
    if (lim > 0)
    {
        for (i = 0; i < lim; i++)
        {
            os << scores[i] << " ";
            if (i % 5 == 4)
            {
                os << std::endl;
            }
        }
        if (i % 5 != 0)
        {
            os << std::endl;
        }
    }
    else
    {
        os << " empty array ";
    }
    return os;
}

std::istream &operator>>(std::istream &is, Student &stu)
{
    is >> stu.name;
    return is;
}
std::istream &getline(std::istream &is, Student &stu)
{
    std::getline(is, stu.name, '\n');
    return is;
}
std::ostream &operator<<(std::ostream &os, const Student &stu)
{
    os << "Scores for " << stu.name << " :\n";
    stu.arr_out(os);
    return os;
}

程序清单14.3 use_stuc.cpp
#include <iostream>
#include "studentc.h"

using std::cin;
using std::cout;
using std::endl;

const int pupils = 3;
const int quizzes = 5;

void set(Student &sa, int n);

int main()
{
    Student ada[pupils] = { Student(quizzes), Student(quizzes), Student(quizzes) };

    int i;
    for (i = 0; i < pupils; ++i)
    {
        set(ada[i], quizzes);
    }
    cout << endl;
    cout << "Student List:\n";
    for (i = 0; i < pupils; ++i)
    {
        cout << ada[i].Name() << endl;
    }
    cout << endl;
    cout << "Results:\n";
    for (i = 0; i < pupils; ++i)
    {
        cout << ada[i];
        cout << "average: " << ada[i].Average() << endl;
        cout << endl;
    }
    cout << "Done.\n";

    return 0;
}

void set(Student &sa, int n)
{
    cout << "Please enter the student's name: ";
    getline(cin, sa);
    cout << "Please enter " << n << " quiz scores :\n";
    for (int i = 0; i < n; i++)
    {
        cin >> sa[i];
    }
    while (cin.get() != '\n')
    {
        continue;
    }
}
显示结果如下
Please enter the student's name: Mike Pence
Please enter 5 quiz scores :
3.6 3.8 3.9 3.9 3.8
Please enter the student's name: Peter Smith
Please enter 5 quiz scores :
4.1 4.3 4.3 3.8 3.9
Please enter the student's name: Hello World
Please enter 5 quiz scores :
4.3 4.2 3.9 3.9 3.6

Student List:
Mike Pence
Peter Smith
Hello World

Results:
Scores for Mike Pence :
3.6 3.8 3.9 3.9 3.8
average: 3.8

Scores for Peter Smith :
4.1 4.3 4.3 3.8 3.9
average: 4.08

Scores for Hello World :
4.3 4.2 3.9 3.9 3.6
average: 3.98

Done.

使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。
这意味着基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。
使用公有继承，基类的公有方法将成为派生类的公有方法。
使用私有继承，基类的公有方法将成为派生类的私有方法。
例如，如果从String类派生出Student类，后者将有一个String类组件，可用于保存字符串。
另外，Student方法可以使用String方法来访问String组件。
包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中。
我们将使用术语子对象（subobject）来表示通过继承或包含添加的对象。
因此私有继承提供的特性与包含相同：获得实现，但不获得接口。
所以，私有继承也可以用来实现has-a关系。
要进行私有继承，请使用关键字private而不是public来定义类
（实际上，private是默认值，因此省略访问限定符也将导致私有继承）。
程序清单14.4 studenti.h
#pragma once
#ifndef STUDENTI_H_
#define STUDENTI_H_
#include <iostream>
#include <valarray>
#include <string>

class Student : private std::string, private std::valarray<double>
{
private:
    typedef std::valarray<double> ArrayDb;
    std::ostream &arr_out(std::ostream &os) const;
public:
    Student() : std::string("Null Student"), ArrayDb() {}
    explicit Student(const std::string &s) : std::string(s), ArrayDb() {}
    explicit Student(int n) : std::string("Nully"), ArrayDb(n) {}
    Student(const std::string &s, int n) : std::string(s), ArrayDb(n) {}
    Student(const std::string &s, const ArrayDb &a) : std::string(s), ArrayDb(a) {}
    Student(const char *str, const double *pd, int n) : std::string(str), ArrayDb(pd, n) {}
    ~Student() {}
    double Average() const;
    double &operator [] (int i);
    double operator [] (int i) const;
    const std::string &Name() const;

    friend std::istream &operator>>(std::istream &is, Student &stu);
    friend std::istream &getline(std::istream &is, Student &stu);
    friend std::ostream &operator<<(std::ostream &os, const Student &stu);
};

#endif

程序清单14.5 studenti.cpp
#include <iostream>
#include "studenti.h"

using std::ostream;
using std::endl;
using std::istream;
using std::string;

double Student::Average() const
{
    if (ArrayDb::size() > 0)
    {
        return ArrayDb::sum() / ArrayDb::size();
    }
    else
    {
        return 0;
    }
}

const string &Student::Name() const
{
    return (const string &) * this;
}

double &Student::operator[](int i)
{
    return ArrayDb::operator[](i);
}

double Student::operator[] (int i) const
{
    return ArrayDb::operator[](i);
}
ostream &Student::arr_out(ostream &os) const
{
    int i;
    int lim = ArrayDb::size();
    if (lim > 0)
    {
        for (i = 0; i < lim; i++)
        {
            os << ArrayDb::operator[](i) << " ";
            if (i % 5 == 4)
            {
                os << endl;
            }
        }
        if (i % 5 != 0)
        {
            os << endl;
        }
    }
    else
    {
        os << " empty array ";
    }
    return os;
}
istream &operator >> (istream &is, Student &stu)
{
    is >> (string &)stu;
    return is;
}
istream &getline(istream &is, Student &stu)
{
    std::getline(is, (string &)stu, '\n');
    return is;
}
ostream &operator << (ostream &os, const Student &stu)
{
    os << "Scores for " << (const string &) stu << " :\n";
    stu.arr_out(os);
    return os;
}
包含使用成员对象名来调用成员对象方法，而私有继承使用基类名和作用域解析运算符来调用基类方法。

程序清单14.6 use_stui.cpp
#include <iostream>
#include "studenti.h"

using std::cin;
using std::cout;
using std::endl;

const int pupils = 3;
const int quizzes = 5;

void set(Student &sa, int n);

int main()
{
    Student ada[pupils] = { Student(quizzes), Student(quizzes), Student(quizzes) };
    int i;
    for (i = 0; i < pupils; i++)
    {
        set(ada[i], quizzes);
    }
    cout << endl;
    cout << "Student List:\n";
    for (i = 0; i < pupils; ++i)
    {
        cout << ada[i].Name() << endl;
    }
    cout << endl;
    cout << "Results:\n";
    for (i = 0; i < pupils; i++)
    {
        cout << ada[i];
        cout << "average: " << ada[i].Average() << endl;
        cout << endl;
    }
    cout << "Done.\n";

    return 0;
}

void set(Student &sa, int n)
{
    cout << "Please enter the student's name: ";
    getline(cin, sa);
    cout << "Please enter " << n << " quiz scores :\n";
    for (int i = 0; i < n; i++)
    {
        cin >> sa[i];
    }
    while (cin.get() != '\n')
    {
        continue;
    }
}
显示结果如下
Please enter the student's name: Mike Pence
Please enter 5 quiz scores :
3.8 3.8 3.9 3.9 3.9
Please enter the student's name: Peter Smith
Please enter 5 quiz scores :
4.1 4.2 4.3 4.8 4.9
Please enter the student's name: Hello World
Please enter 5 quiz scores :
4.1 3.9 3.9 3.8 4.5

Student List:
Mike Pence
Peter Smith
Hello World

Results:
Scores for Mike Pence :
3.8 3.8 3.9 3.9 3.9
average: 3.86

Scores for Peter Smith :
4.1 4.2 4.3 4.8 4.9
average: 4.46

Scores for Hello World :
4.1 3.9 3.9 3.8 4.5
average: 4.04

Done.

大多数C++程序员倾向于使用包含来建立has-a关系，而不选择使用私有继承。
首先，它易于理解。类声明中包含表示被包含类的显式命名对象，代码可以通过名称引用这些对象，而使用继承将使关系更抽象。
其次，继承会引起很多问题，尤其从多个基类继承时，可能必须处理很多问题，
如包含同名方法的独立的基类或共享祖先的独立基类。总之，使用包含不太可能遇到这样的麻烦。
另外，包含能够包括多个同类的子对象。如果某个类需要3个string对象，可以使用包含声明3个独立的string成员。
而继承则只能使用一个这样的对象（当对象都没有名称时，将难以区分）。
然而，私有继承所提供的特性确实比包含多。例如，假设类包含保护成员（可以是数据成员，也可以是成员函数），
则这样的成员在派生类中是可用的，但在继承层次结构外是不可用的。
如果使用组合将这样的类包含在另一个类中，则后者将不是派生类，而是位于继承层次结构之外，因此不能访问保护成员。
但通过继承得到的将是派生类，因此它能够访问保护成员。
另一种需要使用私有继承的情况是需要重新定义虚函数。派生类可以重新定义虚函数，但包含类不能。
使用私有继承，重新定义的函数将只能在类中使用，而不是公有的。
通常，应使用包含来建立has-a关系；如果新类需要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承。
保护继承是私有继承的变体。保护继承在列出基类时使用关键字protected。
使用保护继承时，基类的公有成员和保护成员都将成为派生类的保护成员。
和私有私有继承一样，基类的接口在派生类中也是可用的，但在继承层次结构之外是不可用的。
当从派生类派生出另一个类时，私有继承和保护继承之间的主要区别便呈现出来了。
使用私有继承时，第三代类将不能使用基类的接口，这是因为基类的公有方法在派生类中将变成私有方法；
使用保护继承时，基类的公有方法在第三代中将变成受保护的，因此第三代派生类可以使用它们。
隐式向上转换（implicit upcasting）意味着无需进行显式类型转换，就可以将基类指针或引用指向派生类对象。
表14.1总结了公有、私有和保护继承。
表14.1 各种继承方式
特征                           公有继承                                    保护继承                           私有继承
公有成员变成         派生类的公有成员                  派生类的保护成员                  派生类的私有成员
保护成员变成         派生类的保护成员                  派生类的保护成员                  派生类的私有成员
私有成员变成         只能通过基类接口访问         只能通过基类接口访问         只能通过基类接口访问
能否隐式向上转换         是                                    是（但只能在派生类中）                  否
使用保护派生或私有派生时，基类的公有成员将成为保护成员或私有成员。
假设要让基类的方法在派生类外面可用，方法之一是定义一个使用该基类方法的派生类方法。
另一种方法是使用一个using 声明（就像名称空间那样）来指出派生类可以使用特定的基类成员，即使采用的是私有派生。
class Student : private std::string, private std::valarray<double>
{
    // ...
public:
    using std::valarray<double>::min;
    using std::valarray<double>::max;
    // ...
};
上述using声明使得valarray<double>::min和valarray<double>::max可用，就像它们是Student的公有方法一样。
注意，using 声明只使用成员名――没有圆括号、函数特征标和返回类型。
例如，为使Student类可以使用valarray的operator[]（）方法，只需在Student类声明的公有部分包含下面的using声明：
using std::valarray<double>::operator[];
using声明只适用于继承，而不适用于包含。
多重继承描述的是有多个直接基类的类。与单继承一样，公有多重继承表示的也是is-a关系。
请注意，必须使用关键字public来限定每一个基类。这是因为，除非特别指出，否则编译器将认为是私有派生。
私有多重继承和保护多重继承可以表示has-a 关系。
多重继承可能会给程序员带来很多新问题。其中两个主要的问题是：
从两个不同的基类继承同名方法；
从两个或更多相关基类那里继承同一个类的多个实例。为解决这些问题，需要使用一些新规则和不同的语法。
因此，与使用单继承相比，使用多重继承更困难，也更容易出现问题。
程序清单14.7 worker0.h
#pragma once
#ifndef WORKER0_H_
#define WORKER0_H_
#include <string>

class Worker
{
private:
    std::string fullname;
    long id;
public:
    Worker() : fullname("no one"), id(0L) {}
    Worker(const std::string &s, long n) : fullname(s), id(n) {}
    virtual ~Worker() = 0;
    virtual void Set();
    virtual void Show() const;
};

class Waiter : public Worker
{
private:
    int panache;
public:
    Waiter() : Worker(), panache(0) {}
    Waiter(const std::string &s, long n, int p = 0) : Worker(s, n), panache(p) {}
    Waiter(const Worker &wk, int p = 0) : Worker(wk), panache(p) {}
    void Set();
    void Show() const;
};

class Singer : public Worker
{
protected:
    enum { other, alto, contralto, soprano, bass, baritone, tenor };
    enum { Vtypes = 7 };
private:
    static const char *pv[Vtypes];
    int voice;
public:
    Singer() : Worker(), voice(other) {}
    Singer(const std::string &s, long n, int v = other) : Worker(s, n), voice(v) {}
    Singer(const Worker &wk, int v = other) : Worker(wk), voice(v) {}
    void Set();
    void Show() const;
};

#endif

程序清单14.8 worker0.cpp
#include <iostream>
#include "worker0.h"

using std::cout;
using std::cin;
using std::endl;

Worker::~Worker() {}

void Worker::Set()
{
    cout << "Enter worker's name: ";
    std::getline(cin, fullname, '\n');
    cout << "Enter worker's ID: ";
    cin >> id;
    while (cin.get() != '\n')
    {
        continue;
    }
}

void Worker::Show() const
{
    cout << "Name: " << fullname << "\n";
    cout << "Employee ID: " << id << "\n";
}

void Waiter::Set()
{
    Worker::Set();
    cout << "Enter waiter's panache rating: ";
    cin >> panache;
    while (cin.get() != '\n')
    {
        continue;
    }
}

void Waiter::Show() const
{
    cout << "Category: waiter\n";
    Worker::Show();
    cout << "Panache rating: " << panache << "\n";
}

const char *Singer::pv[] = { "other", "alto", "contralto", "soprano", "bass", "baritone", "tenor" };

void Singer::Set()
{
    Worker::Set();
    cout << "Enter number for singer's vocal range:\n";
    int i;
    for (i = 0; i < Vtypes; i++)
    {
        cout << i << ":" << pv[i] << " ";
        if (i % 4 == 3)
        {
            cout << endl;
        }
    }
    if (i % 4 != 0)
    {
        cout << endl;
    }
    while (cin >> voice && (voice < 0 || voice >= Vtypes))
    {
        cout << "Please enter a value >= 0 and < " << Vtypes << endl;
    }
    cin.clear();
    while (cin.get() != '\n')
    {
        continue;
    }
}

void Singer::Show() const
{
    cout << "Category: singer\n";
    Worker::Show();
    cout << "Vocal range: " << pv[voice] << endl;
}

程序清单14.9 worktest.cpp
#include <iostream>
#include "worker0.h"

const int LIM = 4;

int main()
{
    Waiter bob("Bob Apple", 314L, 5);
    Singer bev("Beverly Hills", 522L, 3);
    Waiter w_temp;
    Singer s_temp;
    Worker *pw[LIM] = { &bob, &bev, &w_temp, &s_temp };
    int i;
    for (i = 2; i < LIM; i++)
    {
        pw[i]->Set();
    }
    for (i = 0; i < LIM; i++)
    {
        pw[i]->Show();
        std::cout << std::endl;
    }

    return 0;
}
显示结果如下
Enter worker's name: Mike Pence
Enter worker's ID: 111222
Enter waiter's panache rating: 8
Enter worker's name: Peter Smith
Enter worker's ID: 555666
Enter number for singer's vocal range:
0:other 1:alto 2:contralto 3:soprano
4:bass 5:baritone 6:tenor
3
Category: waiter
Name: Bob Apple
Employee ID: 314
Panache rating: 5

Category: singer
Name: Beverly Hills
Employee ID: 522
Vocal range: soprano

Category: waiter
Name: Mike Pence
Employee ID: 111222
Panache rating: 8

Category: singer
Name: Peter Smith
Employee ID: 555666
Vocal range: soprano

虚基类使得从多个类（它们的基类相同）派生出的对象只继承一个基类对象。
例如，通过在类声明中使用关键字virtual，可以使Worker被用作Singer和Waiter的虚基类（virtual和public的次序无关紧要）：
class Singer : virtual public Worker
{
    // ...
};
class Waiter : public virtual Worker
{
    // ...
};
然后，可以将SingingWaiter类定义为：
class SingingWaiter : public singer, public Waiter
{
    // ...
};
现在，SingingWaiter对象将只包含Worker对象的一个副本。
从本质上说，继承的Singer和Waiter对象共享一个Worker对象，而不是各自引入自己的Worker对象副本（请参见图14.5）。
因为SingingWaiter现在只包含了一个Worker子对象，所以可以使用多态。
class A
{
private:
    int a;
public:
    A (int n = 0) : a(n) {}
    // ...
};

class B : public A
{
private:
    int b;
public:
    B (int m = 0, int n = 0) : A(n), b(m) {}
    // ...
};

class C : public B
{
private:
    int c;
public:
    C (int q = 0, int m = 0, int n = 0) : B (m, n), c(q) {}
    // ...
};
C类的构造函数只能调用B类的构造函数，而B类的构造函数只能调用A类的构造函数。
这里，C类的构造函数使用值q，并将值m和n传递给B类的构造函数；而B类的构造函数使用值m，并将值n传递给A类的构造函数。
如果Worker是虚基类，则这种信息自动传递将不起作用。例如，对于下面的构造函数：
SingingWaiter (const Worker & wk, int p = 0, int v = Singer::other) : Waiter (wk, p), Singer (wk, v) {}   //flawed
存在的问题是，自动传递信息时，将通过2条不同的途径（Waiter 和Singer）将wk传递给Worker对象。
为避免这种冲突，C++在基类是虚的时，禁止信息通过中间类自动传递给基类。
因此，上述构造函数将初始化成员panache和voice，但wk参数中的信息将不会传递给子对象Waiter。
然而，编译器必须在构造派生对象之前构造基类对象组件；在上述情况下，编译器将使用Worker的默认构造函数。
如果不希望默认构造函数来构造虚基类对象，则需要显式地调用所需的基类构造函数。因此，构造函数应该是这样：
SingingWaiter (const Worker & wk, int p = 0, int v = Singer::other) : Worker(wk), Waiter (wk, p), Singer (wk, v) {}
上述代码将显式地调用构造函数Worker (const Worker &)。
请注意，这种用法是合法的，对于虚基类，必须这样做；但对于非虚基类，则是非法的。
如果类有间接虚基类，则除非只需使用该虚基类的默认构造函数，否则必须显式地调用该虚基类的某个构造函数。
除了修改类构造函数规则外，多重继承通常还要求调整其他代码。假设要在SingingWaiter类中扩展Show方法。
因为SingingWaiter对象没有新的数据成员，所以可能会认为它只需使用继承的方法即可。这引出了第一个问题。
假设没有在SingingWaiter类中重新定义Show方法，并试图使用SingingWaiter对象调用继承的Show方法：
SingingWaiter newhire ("Elise Hawks", 2005, 6, Singer::soprano);
newhire.Show();   //ambiguous
对于单继承，如果没有重新定义Show，则将使用最近祖先中的定义。
而在多重继承中，每个直接祖先都有一个Show函数，这使得上述调用是二义性的。
可以使用作用域解析运算符来澄清编程者的意图：
SingingWaiter newhire ("Elise Hawks", 2005, 6, Singer::soprano);
newhire.Singer::Show(); 
然而，更好的方法是在SingingWaiter中重新定义Show，并指出要使用哪个Show。
例如，如果希望SingingWaiter对象使用Singer版本的Show，则可以这样做：
void SingingWaiter::Show()
{
    Singer::Show();
}
对于单继承来说，让派生方法调用基类的方法是可以的。
然而，这种方式忽略了Waiter组件，可以通过同时调用Waiter版本的Show来补救。
然而，这将显示姓名和ID两次，因为Singer::Show()和Waiter::Show()都调用了Worker::Show()。
如何解决呢？一种办法是使用模块化方式，而不是递增方式，
即提供一个只显示Worker组件的方法和一个只显示Waiter组件或Singer组件（而不是Waiter和Worker组件）的方法。
然后，在SingngWater::Show()方法中将组件组合起来。例如，可以这样做：
void Worker::Data() const
{
    cout << "Name: " << fullname << "\n";
    cout << "Employee ID: " << id << "\n";
}
void Waiter::Data() const
{
    cout << "Panache rating: " << panache << "\n";
}
void Singer::Data() const
{
    cout << "Vocal range: " << pv[voice] << "\n";
}
void SingingWaiter::Data() const
{
    Singer::Data();
    Waiter::Data();
}
void SingingWaiter::Show() const
{
    cout << "Category: singing waiter\n";
    Worker::Data();
    Data();
}
另一种办法是将所有的数据组件都设置为保护的，而不是私有的，
不过使用保护方法（而不是保护数据）将可以更严格地控制对数据的访问。
程序清单14.10 workermi.h
#pragma once
#ifndef WORKERMI_H_
#define WORKERMI_H_
#include <string>

class Worker
{
private:
    std::string fullname;
    long id;
protected:
    virtual void Data() const;
    virtual void Get();
public:
    Worker() : fullname("no one"), id(0L) {}
    Worker(const std::string &s, long n) : fullname(s), id(n) {}
    virtual ~Worker() = 0;
    virtual void Set() = 0;
    virtual void Show() const = 0;
};

class Waiter : virtual public Worker
{
private:
    int panache;
protected:
    void Data() const;
    void Get();
public:
    Waiter() : Worker(), panache(0) {}
    Waiter(const std::string &s, long n, int p = 0) : Worker(s, n), panache(p) {}
    Waiter(const Worker &wk, int p = 0) : Worker(wk), panache(p) {}
    void Set();
    void Show() const;
};

class Singer : virtual public Worker
{
protected:
    enum
    {
        other, alto, contralto, soprano,
        bass, baritone, tenor
    };
    enum { Vtypes = 7 };
    void Data() const;
    void Get();
private:
    static const char *pv[Vtypes];
    int voice;
public:
    Singer() : Worker(), voice(other) {}
    Singer(const std::string &s, long n, int v = other) : Worker(s, n), voice(v) {}
    Singer(const Worker &wk, int v = other) : Worker(wk), voice(v) {}
    void Set();
    void Show() const;
};
class SingingWaiter : public Singer, public Waiter
{
protected:
    void Data() const;
    void Get();
public:
    SingingWaiter() {}
    SingingWaiter(const std::string &s, long n, int p = 0, int v = Singer::other) : Worker(s, n), Waiter(s, n, p), Singer(s, n, v) {}
    SingingWaiter(const Worker &wk, int p = 0, int v = Singer::other) : Worker(wk), Waiter(wk, p), Singer(wk, v) {}
    SingingWaiter(const Waiter &wt, int v = Singer::other) : Worker(wt), Waiter(wt), Singer(wt, v) {}
    SingingWaiter(const Singer &wt, int p = 0) : Worker(wt), Waiter(wt, p), Singer(wt) {}
    void Set();
    void Show() const;
};

#endif

程序清单14.11 workermi.cpp
#include <iostream>
#include "workermi.h"

using std::cout;
using std::cin;
using std::endl;

Worker::~Worker() { }

void Worker::Data() const
{
    cout << "Name: " << fullname << endl;
    cout << "Employee ID: " << id << endl;
}

void Worker::Get()
{
    std::getline(cin, fullname, '\n');
    cout << "Enter worker's ID: ";
    cin >> id;
    while (cin.get() != '\n')
    {
        continue;
    }
}

void Waiter::Set()
{
    cout << "Enter waiter's name: ";
    Worker::Get();
    Get();
}
void Waiter::Show() const
{
    cout << "Category: waiter\n";
    Worker::Data();
    Data();
}
void Waiter::Data() const
{
    cout << "Panache rating: " << panache << endl;
}
void Waiter::Get()
{
    cout << "Enter waiter's panache rating: ";
    cin >> panache;
    while (cin.get() != '\n')
    {
        continue;
    }
}
const char *Singer::pv[Singer::Vtypes] = { "other", "alto", "contralto", "soprano", "bass", "baritone", "tenor" };

void Singer::Set()
{
    cout << "Enter singer's name: ";
    Worker::Get();
    Get();
}

void Singer::Show() const
{
    cout << "Category: singer\n";
    Worker::Data();
    Data();
}
void Singer::Data() const
{
    cout << "Vocal range: " << pv[voice] << endl;
}
void Singer::Get()
{
    cout << "Enter number for singer's vocal range:\n";
    int i;
    for (i = 0; i < Vtypes; i++)
    {
        cout << i << ": " << pv[i] << "   ";
        if (i % 4 == 3)
        {
            cout << endl;
        }
    }
    if (i % 4 != 0)
    {
        cout << '\n';
    }
    while (cin >> voice && (voice < 0 || voice >= Vtypes))
    {
        cout << "Please enter a value >= 0 and < " << Vtypes << endl;
    }
    cin.clear();
    while (cin.get() != '\n')
    {
        continue;
    }
}
void SingingWaiter::Data() const
{
    Singer::Data();
    Waiter::Data();
}
void SingingWaiter::Get()
{
    Waiter::Get();
    Singer::Get();
}
void SingingWaiter::Set()
{
    cout << "Enter singing waiter's name: ";
    Worker::Get();
    Get();
}
void SingingWaiter::Show() const
{
    cout << "Category: singing waiter\n";
    Worker::Data();
    Data();
}

程序清单14.12 workmitest.cpp
#include <iostream>
#include <cstring>
#include "workermi.h"

const int SIZE = 5;

int main()
{
    using std::cin;
    using std::cout;
    using std::endl;
    using std::strchr;

    Worker *lolas[SIZE];

    int ct;
    for (ct = 0; ct < SIZE; ct++)
    {
        char choice;
        cout << "Enter the employee category:\n"
             << "w: waiter  s: singer  "
             << "t: singing waiter  q: quit\n";
        cin >> choice;
        while (cin.get() != '\n')
        {
            continue;
        }
        while (strchr("wstq", choice) == nullptr)
        {
            cout << "Please enter a w, s, t, or q: ";
            cin >> choice;
            while (cin.get() != '\n')
            {
                continue;
            }
        }
        if (choice == 'q')
        {
            break;
        }
        switch (choice)
        {
        case 'w':
            lolas[ct] = new Waiter;
            break;
        case 's':
            lolas[ct] = new Singer;
            break;
        case 't':
            lolas[ct] = new SingingWaiter;
            break;
        default :
            lolas[ct] = new SingingWaiter;
            break;
        }
        lolas[ct]->Set();
    }

    cout << "\nHere is your staff:\n";
    int i;
    for (i = 0; i < ct; i++)
    {
        lolas[i]->Show();
        cout << endl;
    }
    for (i = 0; i < ct; i++)
    {
        delete lolas[i];
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
w
Enter waiter's name: Mike Pence
Enter worker's ID: 111222
Enter waiter's panache rating: 8
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
s
Enter singer's name: Peter Smith
Enter worker's ID: 555666
Enter number for singer's vocal range:
0: other   1: alto   2: contralto   3: soprano
4: bass   5: baritone   6: tenor
5
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
t
Enter singing waiter's name: Hello World
Enter worker's ID: 777888
Enter waiter's panache rating: 9
Enter number for singer's vocal range:
0: other   1: alto   2: contralto   3: soprano
4: bass   5: baritone   6: tenor
6
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
w
Enter waiter's name: Apple
Enter worker's ID: 123123
Enter waiter's panache rating: 5
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
t
Enter singing waiter's name: Orange
Enter worker's ID: 567567
Enter waiter's panache rating: 8
Enter number for singer's vocal range:
0: other   1: alto   2: contralto   3: soprano
4: bass   5: baritone   6: tenor
3

Here is your staff:
Category: waiter
Name: Mike Pence
Employee ID: 111222
Panache rating: 8

Category: singer
Name: Peter Smith
Employee ID: 555666
Vocal range: baritone

Category: singing waiter
Name: Hello World
Employee ID: 777888
Vocal range: tenor
Panache rating: 9

Category: waiter
Name: Apple
Employee ID: 123123
Panache rating: 5

Category: singing waiter
Name: Orange
Employee ID: 567567
Vocal range: soprano
Panache rating: 8

Done.

再来看一下通过多种途径继承一个基类的派生类的情况。如果基类是虚基类，派生类将包含基类的一个子对象；如果基类不是虚基类，派生类将包含多个子对象。
当虚基类和非虚基类混合时，情况将如何呢？
例如，假设类B被用作类C和D的虚基类，同时被用作类X和Y的非虚基类，而类M是从C、D、X和Y派生而来的。
在这种情况下，类M从虚派生祖先（即类C和D）那里共继承了一个B类子对象，并从每一个非虚派生祖先（即类X和Y）分别继承了一个B类子对象。
因此，它包含三个B类子对象。当类通过多条虚途径和非虚途径继承某个特定的基类时，
该类将包含一个表示所有的虚途径的基类子对象和分别表示各条非虚途径的多个基类子对象。
使用虚基类将改变C++解析二义性的方式。使用非虚基类时，规则很简单。
如果类从不同的类那里继承了两个或更多的同名成员（数据或方法），
则使用该成员名时，如果没有用类名进行限定，将导致二义性。
但如果使用的是虚基类，则这样做不一定会导致二义性。在这种情况下，如果某个名称优先于（dominates）其他所有名称，
则使用它时，即便不使用限定符，也不会导致二义性。
那么，一个成员名如何优先于另一个成员名呢？派生类中的名称优先于直接或间接祖先类中的相同名称。例如，在下面的定义中：
class B
{
public:
    short q();
    // ...
};

class C : virtual public B
{
public :
    long q();
    int omg();
    // ...
};
class D : public C
{
    // ...
}
class E: virtual public B
{
private:
    int omg();
    // ...
};
class F: public D, public E
{
    // ...
};
类C中的q定义优先于类B中的q定义，因为类C是从类B派生而来的。因此，F中的方法可以使用q来表示C::q。
另一方面，任何一个omg定义都不优先于其他omg定义，因为C和E都不是对方的基类。
所以，在F中使用非限定的omg将导致二义性。
虚二义性规则与访问规则无关，也就是说，即使E::omg是私有的，不能在F类中直接访问，但使用omg仍将导致二义性。
同样，即使C::q是私有的，它也将优先于B:q。
在这种情况下，可以在类F中调用B:q，但如果不限定q，则将意味着要调用不可访问的C::q。
首先复习一下不使用虚基类的多重继承，这种形式的多重继承不会引入新的规则。
然而，如果一个类从两个不同的类那里继承了两个同名的成员，则需要在派生类中使用类限定符来区分它们。
否则，编译器将指出二义性。
如果一个类通过多种途径继承了一个非虚基类，则该类从每种途径分别继承非虚基类的一个实例。
在某些情况下，这可能正是所希望的，但通常情况下，多个基类实例会有问题。
接下来看一看使用虚基类的多重继承。当派生类使用关键字virtual来指示派生时，基类就成为虚基类。
主要变化（同时也是使用虚基类的原因）是，从虚基类的一个或多个实例派生而来的类将只继承了一个基类对象。
为实现这种特性，必须满足其他要求：有间接虚基类的派生类包含直接调用间接基类构造函数的构造函数，
这对于间接非虚基类来说是非法的；
通过优先规则解决名称二义性。
正如您看到的，多重继承会增加编程的复杂程度。然而，这种复杂性主要是由于派生类通过多条途径继承同一个基类引起的。
避免这种情况后，唯一需要注意的是，在必要时对继承的名称进行限定。
继承（公有、私有或保护）和包含并不总是能够满足重用代码的需要。
例如，Stack类（参见第10章）和Queue类（参见第12章）都是容器类（container class），容器类设计用来存储其他对象或数据类型。
例如，第10章的Stack类设计用于存储unsigned long值。可以定义专门用于存储double值或string对象的Stack类，
除了保存的对象类型不同外，这两种Stack类的代码是相同的。然而，与其编写新的类声明，不如编写一个泛型（即独立于类型的）栈，
然后将具体的类型作为参数传递给这个类。这样就可以使用通用的代码生成存储不同类型值的栈。
第10章的Stack示例使用typedef处理这种需求。然而，这种方法有两个缺点：首先，每次修改类型时都需要编辑头文件；
其次，在每个程序中只能使用这种技术生成一种栈，即不能让typedef同时代表两种不同的类型，因此不能使用这种方法在同一个程序中同时定义int栈和string栈。
C++的类模板为生成通用的类声明提供了一种更好的方法。模板提供参数化（parameterized）类型，即能够将类型名作为参数传递给接收方来建立类或函数。
例如，将类型名int传递给Queue模板，可以让编译器构造一个对int进行排队的Queue类。
C++库提供了多个模板类，本章前面使用了模板类valarray，第4章介绍了模板类vector和array，
而第16章将讨论的C++标准模板库（STL）提供了几个功能强大而灵活的容器类模板实现。
采用模板时，将使用模板定义替换Stack声明，使用模板成员函数替换Stack的成员函数。
和模板函数一样，模板类以下面这样的代码开头：
template <typename T>
关键字template告诉编译器，将要定义一个模板。尖括号中的内容相当于函数的参数列表。
可以使用自己的泛型名代替T，其命名规则与其他标识符相同。当模板被调用时，T将被具体的类型值（如int或string）取代。
在模板定义中，可以使用泛型名来标识要存储在栈中的类型。
同样，可以使用模板成员函数替换原有类的类方法。每个函数头都将以相同的模板声明打头：
template <typename T>
如果在类模板声明中定义了方法（内联定义），则可以省略模板前缀和类限定符。
这些模板不是类和成员函数定义，它们是C++编译器指令，说明了如何生成类和成员函数定义。
模板的具体实现被称为实例化（intantiation）或具体化（specialization），不能将模板成员函数放在独立的实现文件中
由于模板不是函数，它们不能单独编译。模板必须与特定的模板实例化请求一起使用。
为此，最简单的方法是将所有模板信息放在一个头文件中，并在要使用这些模板的文件中包含该头文件。
程序清单14.13 stacktp.h
#ifndef STACKTP_H_
#define STACKTP_H_

template <typename Type>
class Stack
{
private:
    enum { MAX = 10 };
    Type items[MAX];
    int top;
public:
    Stack();
    bool isempty();
    bool isfull();
    bool push(const Type &item);
    bool pop(Type &item);
};

template <typename Type>
Stack<Type>::Stack()
{
    top = 0;
}

template <typename Type>
bool Stack<Type>::isempty()
{
    return top == 0;
}

template <typename Type>
bool Stack<Type>::isfull()
{
    return top == MAX;
}

template <typename Type>
bool Stack<Type>::push(const Type &item)
{
    if (top < MAX)
    {
        items[top++] = item;
        return true;
    }
    else
    {
        return false;
    }
}

template <class Type>
bool Stack<Type>::pop(Type &item)
{
    if (top > 0)
    {
        item = items[--top];
        return true;
    }
    else
    {
        return false;
    }
}

#endif
仅在程序包含模板并不能生成模板类，而必须请求实例化。为此，需要声明一个类型为模板类的对象，方法是使用所需的具体类型替换泛型名。
例如，下面的代码创建两个栈，一个用于存储int，另一个用于存储 string 对象
Stack<int> kernels；
Stack<string> colonels;
看到上述声明后，编译器将按Stack<Type>模板来生成两个独立的类声明和两组独立的类方法。
类声明Stack<int>将使用int替换模板中所有的Type，而类声明Stack<string>将用string替换Type。
当然，使用的算法必须与类型一致。例如，Stack类假设可以将一个项目赋给另一个项目。
这种假设对于基本类型、结构和类来说是成立的（除非将赋值运算符设置为私有的），但对于数组则不成立。
泛型标识符Type称为类型参数（type parameter），这意味着它们类似于变量，但赋给它们的不能是数字，而只能是类型。
因此，在kernel声明中，类型参数Type的值为int。注意，必须显式地提供所需的类型，这与常规的函数模板是不同的，
因为编译器可以根据函数的参数类型来确定要生成哪种函数。
程序清单14.14 stacktem.cpp
#include <iostream>
#include <string>
#include <cctype>
#include "stacktp.h"

using std::cin;
using std::cout;


int main()
{
    Stack<std::string> st;
    char ch;
    std::string po;
    cout << "Please enter A to add a purchase order,\n"
         << "P to process a PO, or Q to quit.\n";
    while (cin >> ch && std::toupper(ch) != 'Q')
    {
        while (cin.get() != '\n')
        {
            continue;
        }
        if (!std::isalpha(ch))
        {
            cout << "Please enter A, P, Q\n";
            continue;
        }
        switch (ch)
        {
        case 'A':
        case 'a':
            cout << "Enter a PO number to add: ";
            std::getline(cin, po, '\n');
            if (st.isfull())
            {
                cout << "stack already full\n";
            }
            else
            {
                st.push(po);
            }
            break;
        case 'P':
        case 'p':
            if (st.isempty())
            {
                cout << "stack already empty\n";
            }
            else
            {
                st.pop(po);
                cout << "PO #" << po << " popped\n";
            }
            break;
        default :
            std::cout << "Please enter A, P, Q\n";
            continue;
            break;
        }
        cout << "Please enter A to add a purchase order,\n"
             << "P to process a PO, or Q to quit.\n";
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
A
Enter a PO number to add: abcdefg
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
A
Enter a PO number to add: hijklmn
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
A
Enter a PO number to add: opqrst
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
A
Enter a PO number to add: uvwxyz
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
P
PO #uvwxyz popped
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
P
PO #opqrst popped
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
P
PO #hijklmn popped
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
A
Enter a PO number to add: 1234567
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
P
PO #1234567 popped
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
P
PO #abcdefg popped
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
P
stack already empty
Please enter A to add a purchase order,
P to process a PO, or Q to quit.
q
Done.

程序清单14.15 stcktp1.h
#ifndef STCKTP1_H_
#define STCKTP1_H_

template <typename Type>
class Stack
{
private:
    enum { SIZE = 10 };
    int stacksize;
    Type *items;
    int top;
public:
    explicit Stack(int ss = SIZE);
    Stack(const Stack &st);
    ~Stack()
    {
        delete[] items;
    }
    bool isempty()
    {
        return top == 0;
    }
    bool isfull()
    {
        return top == stacksize;
    }
    bool push(const Type &item);
    bool pop(Type &item);
    Stack &operator=(const Stack &st);
};

template <typename Type>
Stack<Type>::Stack(int ss) : stacksize(ss), top(0)
{
    items = new Type[stacksize];
}

template <typename Type>
Stack<Type>::Stack(const Stack &st)
{
    stacksize = st.stacksize;
    top = st.top;
    items = new Type[stacksize];
    for (int i = 0; i < top; i++)
    {
        items[i] = st.items[i];
    }
}

template <typename Type>
bool Stack<Type>::push(const Type &item)
{
    if (top < stacksize)
    {
        items[top++] = item;
        return true;
    }
    else
    {
        return false;
    }
}

template <typename Type>
bool Stack<Type>::pop(Type &item)
{
    if (top > 0)
    {
        item = items[--top];
        return true;
    }
    else
    {
        return false;
    }
}

template <typename Type>
Stack<Type> &Stack<Type>::operator=(const Stack<Type> &st)
{
    if (this == &st)
    {
        return *this;
    }
    delete[] items;
    stacksize = st.stacksize;
    top = st.top;
    items = new Type[stacksize];
    for (int i = 0; i < top; i++)
    {
        items[i] = st.items[i];
    }
    return *this;
}

#endif

程序清单14.16 stckoptr1.cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
#include "stcktp1.h"

const int Num = 10;

int main()
{
    std::srand(std::time(nullptr));
    std::cout << "Please enter stack size: ";
    int stacksize = 0;
    std::cin >> stacksize;

    Stack<const char *> st(stacksize);

    const char *in[Num] =
    {
        " 1: Hank Gilgamesh", " 2: Kiki Ishtar",
        " 3: Betty Rocker", " 4: Ian Flagranti",
        " 5: Wolfgang Kibble", " 6: Portia Koop",
        " 7: Joy Almondo", " 8: Xaverie Paprika",
        " 9: Juan Moore", "10: Misha Mache"
    };

    const char *out[Num];

    int processed = 0;
    int nextin = 0;

    while (processed < Num)
    {
        if (st.isempty())
        {
            st.push(in[nextin++]);
        }
        else if (st.isfull())
        {
            st.pop(out[processed++]);
        }
        else if (std::rand() % 2 && nextin < Num)
        {
            st.push(in[nextin++]);
        }
        else
        {
            st.pop(out[processed++]);
        }
    }
    for (int i = 0; i < Num; i++)
    {
        std::cout << out[i] << std::endl;
    }

    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Please enter stack size: 5
 2: Kiki Ishtar
 5: Wolfgang Kibble
 4: Ian Flagranti
 3: Betty Rocker
 6: Portia Koop
 7: Joy Almondo
 1: Hank Gilgamesh
 8: Xaverie Paprika
 9: Juan Moore
10: Misha Mache
Done.

Please enter stack size: 6
 2: Kiki Ishtar
 1: Hank Gilgamesh
 8: Xaverie Paprika
 7: Joy Almondo
 6: Portia Koop
10: Misha Mache
 9: Juan Moore
 5: Wolfgang Kibble
 4: Ian Flagranti
 3: Betty Rocker
Done.

Please enter stack size: 7
 2: Kiki Ishtar
 3: Betty Rocker
 1: Hank Gilgamesh
 4: Ian Flagranti
 5: Wolfgang Kibble
 7: Joy Almondo
 9: Juan Moore
10: Misha Mache
 8: Xaverie Paprika
 6: Portia Koop
Done.

程序清单14.17 arraytp.h
#ifndef ARRAYTP_H_
#define ARRAYTP_H_

#include <cstdlib>

template <typename T, int n>
class ArrayTP
{
private:
    T ar[n];
public:
    ArrayTP() {};
    explicit ArrayTP(const T &v);
    virtual T &operator[](int i);
    virtual T operator[](int i) const;
};

template <typename T, int n>
ArrayTP<T, n>::ArrayTP(const T &v)
{
    for (int i = 0; i < n; i++)
    {
        ar[i] = v;
    }
}

template <typename T, int n>
T &ArrayTP<T, n>::operator[](int i)
{
    if (i < 0 || i >= n)
    {
        std::cerr << "Error in array limits: " << i << " is out of range\n";
        std::exit(EXIT_FAILURE);
    }
    return ar[i];
}

template <typename T, int n>
T ArrayTP<T, n>::operator[](int i) const
{
    if (i < 0 || i >= n)
    {
        std::cerr << "Error in array limits: " << i << " is out of range\n";
        std::exit(EXIT_FAILURE);
    }
    return ar[i];
}

#endif

typename指出T为类型参数，int指出n的类型为int。
这种参数（指定特殊的类型而不是用作泛型名）称为非类型（non-type）或表达式（expression）参数。
表达式参数有一些限制。表达式参数可以是整型、枚举、引用或指针。
另外，模板代码不能修改参数的值，也不能使用参数的地址。所以，在ArrayTP模板中不能使用诸如n++和&n等表达式。
另外，实例化模板时，用作表达式参数的值必须是常量表达式。
与Stack中使用的构造函数方法相比，这种改变数组大小的方法有一个优点。
构造函数方法使用的是通过new和delete管理的堆内存，而表达式参数方法使用的是为自动变量维护的内存栈。
这样，执行速度将更快，尤其是在使用了很多小型数组时。
表达式参数方法的主要缺点是，每种数组大小都将生成自己的模板。
另一个区别是，构造函数方法更通用，这是因为数组大小是作为类成员存储在定义中的。
可以将用于常规类的技术用于模板类。模板类可用作基类，也可用作组件类，还可用作其他模板的类型参数。可以递归使用模板。
例如，对于前面的数组模板定义，可以这样使用：
AггауTp<ArrayтP<int, 5>, 10> twodee;
这使得twodee是一个包含10个元素的数组，其中每个元素都是一个包含5个int元素的数组。与之等价的常规数组声明如下：
int twodee [10][5];
程序清单14.18 twod.cpp
#include <iostream>
#include "arraytp.h"

int main()
{
    using std::cout;
    using std::endl;
    ArrayTP<int, 10> sums;
    ArrayTP<double, 10> aves;
    ArrayTP< ArrayTP<int, 5>, 10> twodee;

    int i, j;

    for (i = 0; i < 10; i++)
    {
        sums[i] = 0;
        for (j = 0; j < 5; j++)
        {
            twodee[i][j] = (i + 1) * (j + 1);
            sums[i] += twodee[i][j];
        }
        aves[i] = (double)sums[i] / 5;
    }
    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 5; j++)
        {
            cout.width(2);
            cout << twodee[i][j] << ' ';
        }
        cout << ": sum = ";
        cout.width(3);
        cout << sums[i] << ", average = " << aves[i] << endl;
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
 1  2  3  4  5 : sum =  15, average = 3
 2  4  6  8 10 : sum =  30, average = 6
 3  6  9 12 15 : sum =  45, average = 9
 4  8 12 16 20 : sum =  60, average = 12
 5 10 15 20 25 : sum =  75, average = 15
 6 12 18 24 30 : sum =  90, average = 18
 7 14 21 28 35 : sum = 105, average = 21
 8 16 24 32 40 : sum = 120, average = 24
 9 18 27 36 45 : sum = 135, average = 27
10 20 30 40 50 : sum = 150, average = 30
Done.

程序清单14.19 pairs.cpp
#include <iostream>
#include <string>

template <typename T1, typename T2>
class Pair
{
private:
    T1 a;
    T2 b;
public:
    T1 &first();
    T2 &second();
    T1 first() const
    {
        return a;
    }
    T2 second() const
    {
        return b;
    }
    Pair(const T1 &aval, const T2 &bval) : a(aval), b(bval) { }
    Pair() {}
};

template<typename T1, typename T2>
T1 &Pair<T1, T2>::first()
{
    return a;
}

template<typename T1, typename T2>
T2 &Pair<T1, T2>::second()
{
    return b;
}

int main()
{
    using std::cout;
    using std::endl;
    using std::string;
    Pair<string, int> ratings[4] =
    {
        Pair<string, int>("The Purpled Duck", 5),
        Pair<string, int>("Jaquie's Frisco Al Fresco", 4),
        Pair<string, int>("Cafe Souffle", 5),
        Pair<string, int>("Bertie's Eats", 3)
    };

    int joints = sizeof(ratings) / sizeof(Pair<string, int>);
    cout << "Rating:\t Eatery\n";
    for (int i = 0; i < joints; i++)
    {
        cout << ratings[i].second() << ":\t "
             << ratings[i].first() << endl;
    }
    cout << "Oops! Revised rating:\n";
    ratings[3].first() = "Bertie's Fab Eats";
    ratings[3].second() = 6;
    cout << ratings[3].second() << ":\t "
         << ratings[3].first() << endl;

    return 0;
}
显示结果如下
Rating:  Eatery
5:       The Purpled Duck
4:       Jaquie's Frisco Al Fresco
5:       Cafe Souffle
3:       Bertie's Eats
Oops! Revised rating:
6:       Bertie's Fab Eats

类模板的另一项新特性是，可以为类型参数提供默认值：
template <typename T1, typename T2 = int>
class Topo
{
    // ...
};
这样，如果省略T2的值，编译器将使用int。
虽然可以为类模板类型参数提供默认值，但不能为函数模板参数提供默认值。
然而，可以为非类型参数提供默认值，这对于类模板和函数模板都是适用的。
类模板与函数模板很相似，因为可以有隐式实例化、显式实例化和显式具体化。
模板以泛型的方式描述类，使用时以具体的类型生成类声明。
1.隐式实例化
声明一个或多个对象，指出所需的类型，而编译器使用通用模板提供的内容生成具体的类定义。
ArrayTP<int, 100> stuff;   //implicit instantiation
编译器在需要对象之前，不会生成类的隐式实例化：
ArrayTP<double, 30> * pt;   //a pointer, no object needed yet
pt = new ArrayTP<double, 30>;   //now an object is needed
第二条语句导致编译器生成类定义，并根据该定义创建一个对象。
2.显式实例化
当使用关键字template并指出所需类型来声明类时，编译器将生成类声明的显式实例化（explici instantiation），
声明必须位于模板定义所在的名称空间中。例如，下面的声明将ArrayTP<string, 100>声明为一个类：
template class ArrayTP<string, 100>;   //generate ArrayTP<string, 100> class
在这种情况下，虽然没有创建或提及类对象，编译器也将生成类声明（包括方法定义）。
和隐式实例化样，也将根据通用模板来生成具体化。
3.显式具体化
显式具体化（explicit specialization）是特定类型（用于替换模板中的泛型）的定义。
有时候，可能需要在为特殊类型实例化时，对模板进行修改，使其行为不同。在这种情况下，可以创建显式具体化。
例如假设已经为用于表示排好序数组的类（元素在加入时被排序）定义了一个模板：
template <typename T>
class SortedArray
{
   // ...
};
假设模板使用>运算符来对值进行比较。对于数字，这管用；如果T表示一种类，则只要定义了T::operator>()方法，这也管用；
但如果T是由const char*表示的字符串，这将不管用。实际上，模板倒是可以正常工作，但字符串将按地址排序。
这要求类定义使用strmp，而不是>来对值进行比较。
在这种情况下，可以提供一个显式模板具体化，这将采用为具体类型定义的模板，而不是为泛型定义的模板。
当具体化模板和通用模板都与实例化请求匹配时，编译器将使用具体化版本。
具体化类模板定义的格式如下：
template <> class Classname <specialized-type-name>
{
    // ...
};
要使用新的表示法提供一个专供const char*类型使用的SortedArray模板，可以使用类似于下面的代码
template <> class SortedArray<const char *>
{
    // ...
};
其中的实现代码将使用strcmp（而不是>）来比较字符串。现在，当请求const char *类型的SortedArray模板时，
编译器将使用上述专用的定义，而不是通用的模板定义：
SortedArray<int> scores;   //use general definition
SortedArray<const char *> dates;   //use specialized definition
4.部分具体化
C++还允许部分具体化（partial specialization），即部分限制模板的通用性。
例如，部分具体化可以给类型参数之一指定具体的类型：
//general template
template <typename T1, typename T2> class Pair
{
    // ...
};
//specialization with T2 set to int
template <typename T1> class Pair<T1, int>
{
    // ...
};
关键字template后面的声明的是没有被具体化的类型参数。因此，上述第二个声明将T2具体化为int，但T1保持不变。
注意，如果指定所有的类型，则<>内将为空，这将导致显式具体化：
//specialization with T1 and T2 set to int
template <> class Pair<int, int>
{
    // ...
};
如果有多个模板可供选择，编译器将使用具体化程度最高的模板。给定上述三个模板，情况如下：
Pair<double，double> p1;   //use general Pair template
Pair<double, int> p2;   //use Pair<T1, int> partial specialization
Pair<int, int> p3;   //use Pair<int, int> explicit specialization
也可以通过为指针提供特殊版本来部分具体化现有的模板
template <typename T>   //general version
class Feeb
{
    // ...
};
template <typename T*>   //pointer partial specialization
class Feeb
{
    // ...
};
如果提供的类型不是指针，则编译器将使用通用版本；如果提供的是指针，则编译器将使用指针具体化版本：
Feeb<char> fb1;   //use general Feeb template, T is char
Feeb<char *> fb2;   //use Feeb T* specialization, T is char
如果没有进行部分具体化，则第二个声明将使用通用模板，将T转换为char*类型。
如果进行了部分具体化，则第二个声明将使用具体化模板，将T转换为char。
部分具体化特性使得能够设置各种限制。例如，可以这样做：
//general template
template <typename T1, typename T2, typename T3> class Trio
{
    // ...
};
//specialization with T3 set to T2
template <typename T1, typename T2> class Trio<T1, T2, T2>
{
    // ...
};
//specialization with T3 and T2 set to T1*
template <class T1> class Trio<T1, T1*, T1*>
{
    // ...
};
给定上述声明，编译器将作出如下选择：
Trio<int, short, char > t1;   //use general template
Trio<int, short> t2;   //use Trio<T1, T2, T2>
Trio<char, char *, char *> t3;   //use Trio<T1, T1 *, T1 *>
14.4.7成员模板
模板可用作结构、类或模板类的成员。要完全实现STL的设计，必须使用这项特性。
程序清单14.20 tempmemb.cpp
#include <iostream>
#include <string>

using std::cout;
using std::endl;


template <typename T>
class beta
{
private:
    template <typename V>
    class hold
    {
    private:
        V val;
    public:
        hold(V v = 0) : val(v) {}
        void show() const
        {
            cout << val << endl;
        }
        V Value() const
        {
            return val;
        }
    };
    hold<T> q;
    hold<int> n;
public:
    beta(T t, int i) : q(t), n(i) {}
    template<typename U>
    U blab(U u, T t)
    {
        return (n.Value() + q.Value()) * u / t;
    }
    void Show() const
    {
        q.show();
        n.show();
    }
};

int main()
{
    beta<double> guy(3.5, 3);
    cout << "T was set to double\n";
    guy.Show();
    cout << "V was set to T, which is double, then V was set to int\n";
    cout << guy.blab(10, 2.3) << endl;
    cout << "U was set to int\n";
    cout << guy.blab(10.0, 2.3) << endl;
    cout << "U was set to double\n";
    cout << "Done.\n";

    return 0;
}
显示结果如下
T was set to double
3.5
3
V was set to T, which is double, then V was set to int
28
U was set to int
28.2609
U was set to double
Done.

模板可以包含类型参数（如typename T）和非类型参数（如int n）。
模板还可以包含本身就是模板的参数，这种参数是模板新增的特性，用于实现STL。
程序清单14.21 tempparm.cpp
#include <iostream>
#include "stacktp.h"

template <template <typename T> class Thing>
class Crab
{
private:
    Thing<int> s1;
    Thing<double> s2;
public:
    Crab() {};
    bool push(int a, double x)
    {
        return s1.push(a) && s2.push(x);
    }
    bool pop(int &a, double &x)
    {
        return s1.pop(a) && s2.pop(x);
    }
};

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    Crab<Stack> nebula;
    int ni;
    double nb;
    cout << "Enter int double pairs, such as 4 3.5 (0 0 to end):\n";
    while (cin >> ni && cin >> nb && ni > 0 && nb > 0)
    {
        if (!nebula.push(ni, nb))
        {
            break;
        }
    }

    while (nebula.pop(ni, nb))
    {
        cout << ni << ", " << nb << endl;
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Enter int double pairs, such as 4 3.5 (0 0 to end):
3 3.5
5 5.1
6 6.6
0 0
6, 6.6
5, 5.1
3, 3.5
Done.

可以混合使用模板参数和常规参数，例如，Crab类的声明可以像下面这样打头：
template <template <typename T> class Thing, typename U, typename V>
class crab
{
private:
Thing<U> s1;
Thing<V> s2;
};
现在，成员s1和s2可存储的数据类型为泛型。这要求将程序中nebula的声明修改成下面这样：
Crab<Stack, int, double> nebula;   //T=stack, U=int, V=double
模板参数T表示一种模板类型；而类型参数U和V表示非模板类型。
模板类声明也可以有友元。模板的友元分3类：
非模板友元
约束（bound）模板友元，即友元的类型取决于类被实例化时的类型；
非约束（unbound）模板友元，即友元的所有具体化都是类的每一个具体化的友元。
template <typename T>
class HasFriend
{
public:
    friend void counts();
};
上述声明使counts函数成为模板所有实例化的友元。例如，它将是类hasFriend<int>和HasFriend<string>的友元。
counts函数不是通过对象调用的（它是友元，不是成员函数）；也没有对象参数，那公它如何访问HasFriend 对象呢？
它可以访问全局对象；可以使用全局指针访问非全局对象；可以创建自己的对象；可以访问独立于对象的模板类的静态数据成员。
假设要为友元函数提供模板类参数，可以如下所示来进行友元声明吗？
friend void report(HasFriend &);
答案是不可以。原因是不存在“HasFriend这样的对象，而只有特定的具体化如HasFriend<short>。
要提供模板类参数，必须指明具体化。例如，可以这样做：
template <typename T>
class HasFriend
{
public:
    friend void report(HasFriend<T> &);
};
声明一个特定类型的对象
HasFriend<int>h1;
编译器使用int替换参数T，因此友元函数声明的格式如下：
class HasFriend<int>
{
public:
    friend void report(HasFriend<int> &);
};
也就是说，带HasFriend<int>参数的report将成为HasFriend<int>类的友元。
同样，带HasFriend<double>参数的report将是report的一个重载版本――它是Hasfriend<double>类的友元。
注意，report本身并不是模板函数，而只是使用一个模板作参数。这意味着必须为要使用的友元定义显式具体化：
void report (HasFriend<short>&)   //explicit specialization for short 
{
    // ...
};
void report（HasFriend<int>&)   //explicit specialization for int
{
    // ...
};
HasFriend模板有一个静态成员ct。这意味着这个类的每一个特定的具体化都将有自己的静态成员。
count方法是所有HasFriend具体化的友元，它报告两个特定的具体化（HasFriend<int>和HasFriend<double>）的ct的值。
该程序还提供两个report函数，它们分别是某个特定HasFriend具体化的友元。
程序清单14.22 frnd2tmp.cpp
#include <iostream>

using std::cout;
using std::endl;

template <typename T>
class HasFriend
{
private:
    T item;
    static int ct;
public:
    HasFriend(const T &i) : item(i)
    {
        ct++;
    }
    ~HasFriend()
    {
        ct--;
    }
    friend void counts();
    friend void reports(HasFriend<T> &);
};

template <typename T>
int HasFriend<T>::ct = 0;

void counts()
{
    cout << "int count: " << HasFriend<int>::ct << "; ";
    cout << "double count: " << HasFriend<double>::ct << endl;
}
void reports(HasFriend<int> &hf)
{
    cout << "HasFriend<int>: " << hf.item << endl;
}
void reports(HasFriend<double> &hf)
{
    cout << "HasFriend<double>: " << hf.item << endl;
}
int main()
{
    cout << "No objects declared: ";
    counts();
    HasFriend<int> hfi1(10);
    cout << "After hfi1 declared: ";
    counts();
    HasFriend<int> hfi2(20);
    cout << "After hfi2 declared: ";
    counts();
    HasFriend<double> hfdb(10.5);
    cout << "After hfdb declared: ";
    counts();
    reports(hfi1);
    reports(hfi2);
    reports(hfdb);

    return 0;
}
编译命令如下
g++ -o frnd2tmp frnd2tmp.cpp
frnd2tmp.cpp:22:39: warning: friend declaration ‘void reports(HasFriend<T>&)’ declares a non-template function [-Wnon-template-friend]
   22 |     friend void reports(HasFriend<T> &);
      |                                       ^
frnd2tmp.cpp:22:39: note: (if this is not what you intended, make sure the function template has already been declared and add ‘<>’ after the function name here)

显示结果如下
No objects declared: int count: 0; double count: 0
After hfi1 declared: int count: 1; double count: 0
After hfi2 declared: int count: 2; double count: 0
After hfdb declared: int count: 2; double count: 1
HasFriend<int>: 10
HasFriend<int>: 20
HasFriend<double>: 10.5

可以修改前一个示例，使友元函数本身成为模板。
首先，在模板类定义的前面声明每个模板函数。
template <typename T> void counts();
template <typename T> void report(T &);
然后，在在模板类定义中再次将模板函数声明为友元。这些语句根据类模板参数的类型声明具体化：
template<typename TT>
class HasFriendT
{
    // ...
    friend void counts<TT>();
    friend void report<>(HasFriendT<TT> &);
};
对于report函数，<>可以为空，因为可以从函数参数推断出如下模板类型参数：
HasFriendT<TT>
然而，也可以使用：
report< HasFriendT<TT> > (HasFriendT<TT> &);
但counts函数没有参数，因此必须使用模板参数语法（<TT>）来指明其具体化。
还需要注意的是，TT是HasFriendT类的参数类型。
同样，理解这些声明的最佳方式也是设想声明一个特定具体化的对象时，它们将变成什么样。例如，假设声明了这样一个对象：
HasFriendT<int> squack;
编译器将用int替换TT，并生成下面的类定义：
class HasFriendT<int>
{
    // ...
    friend void counts<int>();
    friend void report<>(HasFriendT<int> &);
};
基于T的具体化将变为int，基于HasFriendT<TT>的具体化将变为HasFriendT<int>。
因此，模板具体化counts<int>()和report<HasFriendT<int>>()被声明为HasFriendT<int>类的友元。
程序必须满足的第三个要求是，为友元提供模板定义。
程序清单14.23 tmp2tmp.cpp
#include <iostream>

using std::cout;
using std::endl;

template <typename T> void counts();
template <typename T> void report(T &);

template <typename TT>
class HasFriendT
{
private:
    TT item;
    static int ct;
public:
    HasFriendT(const TT &i) : item(i)
    {
        ct++;
    }
    ~HasFriendT()
    {
        ct--;
    }
    friend void counts<TT>();
    friend void report<>(HasFriendT<TT> &);
};

template <typename T>
int HasFriendT<T>::ct = 0;

template <typename T>
void counts()
{
    cout << "template size: " << sizeof(HasFriendT<T>) << "; ";
    cout << "template counts(): " << HasFriendT<T>::ct << endl;
}

template <typename T>
void report(T &hf)
{
    cout << hf.item << endl;
}

int main()
{
    counts<int>();
    counts<double>();
    HasFriendT<int> hfi1(10);
    HasFriendT<int> hfi2(20);
    HasFriendT<double> hfdb(10.5);
    report(hfi1);
    report(hfi2);
    report(hfdb);
    cout << "counts<int>() output:\n";
    counts<int>();
    cout << "counts<double>() output:\n";
    counts<double>();

    return 0;
}
显示结果如下
template size: 4; template counts(): 0
template size: 8; template counts(): 0
10
20
10.5
counts<int>() output:
template size: 4; template counts(): 2
counts<double>() output:
template size: 8; template counts(): 1

通过在类内部声明模板，可以创建非约束友元函数，即每个函数具体化都是每个类具体化的友元。
对于非约束友元，友元模板类型参数与模板类类型参数是不同的。
template<typename T>
class ManyFriend
{
public:
    template <typename C, typename D> friend void show2(C &, D &);
};
程序清单14.24 manyfrnd.cpp
#include <iostream>

using std::cout;
using std::endl;

template <typename T>
class ManyFriend
{
private:
    T item;
public:
    ManyFriend(const T &i) : item(i) {}
    template <typename C, typename D> friend void show2(C &, D &);
};
template <typename C, typename D> void show2(C &c, D &d)
{
    cout << c.item << ", " << d.item << endl;
}

int main()
{
    ManyFriend<int> hfi1(10);
    ManyFriend<int> hfi2(20);
    ManyFriend<double> hfdb(10.5);
    cout << "hfi1, hfi2: ";
    show2(hfi1, hfi2);
    cout << "hfdb, hfi2: ";
    show2(hfdb, hfi2);

    return 0;
}
显示结果如下
hfi1, hfi2: 10, 20
hfdb, hfi2: 10.5, 20

如果能为类型指定别名，将很方便，在模板设计中尤其如此。可使用typedef为模板具体化指定别名：
//define three typedef aliases
typedef std::array<double, 12> arrd;
typedef std::array<int, 12>arri;
typedef std::array<std::string, 12> arrst;
arrd gallons;   //gallons is type std::array<double, 12>
arri days;   //days is type std::array<int, 12>
arrst months;   //months is type std::array<std::string, 12>
但如果您经常编写类似于上述typedef的代码，您可能怀疑要么自己忘记了可简化这项任务的C++功能，
要么C++没有提供这样的功能。C++11新增了一项功能――使用模板提供一系列别名，如下所示：
template <typename T>
using arrtype = std::array<T, 12>;   //template to create multiple aliases
这将arrtype定义为一个模板别名，可使用它来指定类型，如下所示：
arrtype<double> gallons;   //gallons is type std::array<double, 12>
arrtype<int> days;   //days is type std::array<int, 12>
arrtype<std::string>months;   //months is type std::array<std::string, 12>
总之，arrtype<T>表示类型 std::array<T, 12>。
C++11允许将语法using=用于非模板。用于非模板时，这种语法与常规typedef等价：
typedef const char* pc1;   //typedef syntax
using pc2 = const char *;   //using = syntax
typedef const int * (*pa1)[10];   //typedef syntax
using pa2 = const int * (*)[10];   //using = syntax
习惯这种语法后，您可能发现其可读性更强，因为它让类型名和类型信息更清晰。
C++11新增的另一项模板功能是可变参数模板（variadic template），让您能够定义这样的模板类和模板函数，
即可接受可变数量的参数。这个主题将在第18章介绍。
14.5总结
C++提供了几种重用代码的手段。第13章介绍的公有继承能够建立is-a关系，这样派生类可以重用基类的代码。
私有继承和保护继承也使得能够重用基类的代码，但建立的是has-a关系。
使用私有继承时，基类的公有成员和保护成员将成为派生类的私有成员；
使用保护继承时，基类的公有成员和保护成员将成为派生类的保护成员。
无论使用哪种继承，基类的公有接口都将成为派生类的内部接口。
这有时候被称为继承实现，但并不继承接口，因为派生类对象不能显式地使用基类的接口。
因此，不能将派生对象看作是一种基类对象。由于这个原因，在不进行显式类型转换的情况下，
基类指针或引用将不能指向派生类对象。
还可以通过开发包含对象成员的类来重用类代码。这种方法被称为包含、层次化或组合，它建立的也是has-a关系。
与私有继承和保护继承相比，包含更容易实现和使用，所以通常优先采用这种方式。
然而，私有继承和保护继承比包含有一些不同的功能。例如，继承允许派生类访问基类的保护成员；
还允许派生类重新定义从基类那里继承的虚函数。因为包含不是继承，所以通过包含来重用类代码时，不能使用这些功能。
另一方面，如果需要使用某个类的几个对象，则用包含更适合。
多重继承（Ml）使得能够在类设计中重用多个类的代码。私有MI或保护Ml建立has-a关系，而公有Ml建立is-a关系。
Ml会带来一些问题，即多次定义同一个名称，继承多个基类对象。
可以使用类限定符来解决名称二义性的问题，使用虚基类来避免继承多个基类对象的问题。
但使用虚基类后，就需要为编写构造函数初始化列表以及解决二义性问题引入新的规则。
类模板使得能够创建通用的类设计，其中类型（通常是成员类型）由类型参数表示。
类定义（实例化）在声明类对象并指定特定类型时生成。
使用关键字template 声明类的特定具体化时，将发生显式实例化。
可以提供显式具体化――覆盖模板定义的具体类声明。方法是以template <>打头，
然后是模板类名称再加上尖括号（其中包含要具体化的类型）。
类模板可以指定多个泛型，也可以有非类型参数。
类模板还可以包含本身就是模板的参数。
类模板可以被部分具体化。
模板类可用作其他类、结构和模板的成员
所有这些机制的目的都是为了让程序员能够重用经过测试的代码，而不用手工复制它们。
这样可以简化编程工作，提供程序的可靠性。
14.6复习题
1.以A栏的类为基类时，B栏的类采用公有派生还是私有派生更合适。
class Bear                                          class PolarBear 公有派生 PolarBear is a Bear
class Kitchen                                     class Home       私有 Home has a Kitchen
class Person                                      class Programmer   公有派生 Programmer is a Person
class Person                                      class HorseAndJockey 私有 马和驯马师的组合 has a Person
class Person, class Automobile         class Driver                   Person 公有，Automobile 私有
                                                                                                Driver is a Person has a Automobile
2.假设有下面的定义：
class Frabjous
{
private:
    std::string fab;
public:
    Frabjous (const char * s = "C++") : fab(s) {}
   virtual void tell() {cout << fab;}
};
class Gloam
{
private:
    int glip;
    Frabjous fb;
public:
    Gloam (int g = 0, const char * s = "C++");
    Gloam (int g, const Frabjous &fr);
    void tell();
};
假设Gloam版本的tell应显示glip和f的值，请为这3个Gloam方法提供定义。
Gloam::Gloam(int g, const char * s) : glip(g), fb(s) {}
Gloam::Gloam(int g, const Frabjous & fr) : glip(g), fb(fr) {}
Gloam::tell()
{
    fb.tell();
    cout << '\n';
    cout << glip << '\n';
}

3.假设有下面的定义：
class Frabjous
{
private:
    std::string fab;
public:
    Frabjous (const char * s = "C++") : fab(s) {}
   virtual void tell() {cout << fab;}
};
class Gloam : private Frabjous
{
private:
    int glip;
public:
    Gloam (int g = 0, const char * s = "C++");
    Gloam (int g, const Frabjous &fr);
    void tell();
};
假设Gloam版本的tell()应显示glip和fab的值，请为这3个Gloam方法提供定义。
Gloam::Gloam(int g, const char * s) : glip(g), Frabjous(s) {}
Gloam::Gloam(int g, const Frabjous & fr) : glip(g), Frabjous(fr) {}
Gloam::tell()
{
    Frabjous::tell();
    cout << '\n';
    cout << glip << '\n';
}
4.假设有下面的定义，它是基于程序清单14.13中的Stack模板和程序清单14.10中的Woker类的：
Stack<Worker*> sw;
请写出将生成的类声明。只实现类声明，不实现非内联类方法。
class Stack<Worker *>
{
private:
    enum { MAX = 10 };
    Worker * items[MAX];
    int top;
public:
    Stack();
    bool isempty();
    bool isfull();
    bool push(const Worker * &item);
    bool pop(Worker * &item);
};

5.使用本章中的模板定义对下面的内容进行定义：
string对象数组；
double数组栈；
指向Worker对象的指针的栈数组。
程序清单14.18生成了多少个模板类定义？
template <typename T, int n>
class ArrayTP
{
private:
    T ar[n];
public:
    ArrayTP() {};
    explicit ArrayTP(const T &v);
    virtual T &operator[](int i);
    virtual T operator[](int i) const;
};

template <typename Type>
class Stack
{
private:
    enum { MAX = 10 };
    Type items[MAX];
    int top;
public:
    Stack();
    bool isempty();
    bool isfull();
    bool push(const Type &item);
    bool pop(Type &item);
};

ArrayTP<std::string, 10> sa;
Stack< ArrayTP<double, 10> > stck_arr_db;
ArrayTP< Stack<Worker *> , 10>

程序清单14.18生成了4个模板类定义
ArrayTP<int, 10>
ArrayTP<double, 10>
ArrayTP<int, 5>
ArrayTP< ArrayTP<int, 5>, 10>

6.指出虚基类与非虚基类之间的区别。
如果一个类通过多种途径继承了一个非虚基类，则该类从每种途径分别继承非虚基类的一个实例。
当派生类使用关键字virtual来指示派生时，基类就成为虚基类。
从虚基类的一个或多个实例派生而来的类将只继承一个基类对象。

14.7编程练习
1.Wine类有一个string类对象成员（参见第4章）和一个Pair对象（参见本章）；
其中前者用于存储葡萄酒的名称，而后者有2个valarray<int>对象（参见本章），
这两个valarray<int>对象分别保存了葡萄酒的酿造年份和该年生产的瓶数。
例如，Pair的第1个valarray<int>对象可能为1988、1992和1996年，第2个valarray<int>对象可能为24、48和144瓶。
Wine最好有1个int成员用于存储年数。另外，一些typedef可能有助于简化编程工作：
typedef std::valarray<int> ArrayInt;
typedef Pair<ArrayInt, ArrayInt> PairArray;
这样，PairArray表示的是类型Pair<std::valarray<int>, std::valarray<int>>。
使用包含来实现Wine类，并用一个简单的程序对其进行测试。
wine.h
#ifndef WINE_H_
#define WINE_H_
#include <string>
#include <valarray>
#include <iostream>

using ArrayInt = std::valarray<int>;
using PairArray = std::pair<ArrayInt, ArrayInt>;

class Wine
{
private:
    std::string label;
    PairArray data;
    int years;
public:
    Wine(const char *l, int у, const int yr[], const int bot[]);
    Wine(const char *l, int у);
    ~Wine();

    void Show() const;
    void GetBottles();
    const std::string &Label() const;
    int sum() const;
};

#endif

wine.cpp
#include <iostream>
#include "wine.h"

Wine::Wine(const char *l, int y, const int yr[], const int bot[])
{
    label = l;
    years = y;
    data.first.resize(years);
    data.second.resize(years);

    for (int i = 0; i < years; i++)
    {
        data.first[i] = yr[i];
        data.second[i] = bot[i];
    }
}

Wine::Wine(const char *l, int y)
{
    label = l;
    years = y;
    data.first.resize(years);
    data.second.resize(years);
}

Wine::~Wine()
{

}

void Wine::Show() const
{
    std::cout << "Wine: " << label << std::endl;
    std::cout << "\tYear\tBottles" << std::endl;

    for (int i = 0; i < years; i++)
    {
        std::cout << "\t" << data.first[i] << "\t";
        std::cout << data.second[i] << std::endl;
    }
}

const std::string &Wine::Label() const
{
    return label;
}

void Wine::GetBottles()
{
    std::cout << "Enter " << label << " data for " << years << " year(s):\n";

    int input = 0;
    for (int i = 0; i < years; i++)
    {
        std::cout << "Enter year: ";
        std::cin >> input;
        data.first[i] = input;
        std::cout << "Enter bottles for that year: ";
        std::cin >> input;
        data.second[i] = input;

        std::cout << std::endl;
    }
}

int Wine::sum() const
{
    int sum = 0;
    for (int i = 0; i < years; i++)
    {
        sum += data.second[i];
    }
    return sum;
}

ch14_p01.cpp
#include <iostream>
#include "wine.h"

int main()
{
    std::cout << "Enter name of wine: ";
    char lab[50];
    std::cin.getline(lab, 50);
    std::cout << std::endl;

    std::cout << "Enter number of years: ";
    int yrs = 0;
    std::cin >> yrs;
    while (std::cin.get() != '\n')
    {
        continue;
    }

    Wine holding(lab, yrs);
    holding.GetBottles();
    holding.Show();
    std::cout << std::endl;

    const int YRS = 3;
    int y[YRS] = { 1993, 1995, 1998 };
    int b[YRS] = { 48, 60, 72 };

    Wine more("Gushing Grape Red", YRS, y, b);
    more.Show();
    std::cout << std::endl;

    std::cout << "Total bottles for " << more.Label();
    std::cout << ": " << more.sum() << std::endl;
    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Enter name of wine: Apple Orange

Enter number of years: 5
Enter Apple Orange data for 5 year(s):
Enter year: 1992
Enter bottles for that year: 32

Enter year: 1995
Enter bottles for that year: 66

Enter year: 1998
Enter bottles for that year: 33

Enter year: 1999
Enter bottles for that year: 36

Enter year: 2003
Enter bottles for that year: 55

Wine: Apple Orange
        Year    Bottles
        1992    32
        1995    66
        1998    33
        1999    36
        2003    55

Wine: Gushing Grape Red
        Year    Bottles
        1993    48
        1995    60
        1998    72

Total bottles for Gushing Grape Red: 180
Done.

2.采用私有继承而不是包含来完成编程练习1。
wine2.h
#ifndef WINE2_H_
#define WINE2_H_
#include <string>
#include <valarray>
#include <iostream>


using ArrayInt = std::valarray<int>;
using PairArray = std::pair<ArrayInt, ArrayInt>;

class Wine : private std::string, private PairArray
{
private:
    int years;
public:
    Wine(const char *l, int y, const int yr[], const int bot[]);
    Wine(const char *l, int y);
    ~Wine();

    void Show() const;
    void GetBottles();
    const std::string &Label() const;
    int sum() const;
};

#endif

wine2.cpp
#include <iostream>
#include "wine2.h"

Wine::Wine(const char *l, int y) : PairArray(ArrayInt(y), ArrayInt(y)), std::string(l)
{
    years = y;
}

Wine::Wine(const char *l, int y, const int yr[], const int bot[]) : PairArray(ArrayInt(y), ArrayInt(y)), std::string(l)
{
    years = y;
    for (int i = 0; i < years; i++)
    {
        PairArray::first[i] = yr[i];
        PairArray::second[i] = bot[i];
    }
}

Wine::~Wine()
{

}

const std::string &Wine::Label() const
{
    return (const std::string &)(*this);
}

void Wine::Show() const
{
    std::cout << "Wine: " << Label() << std::endl;
    std::cout << "\tYear\tBottles" << std::endl;

    for (int i = 0; i < years; i++)
    {
        std::cout << "\t" << PairArray::first[i] << "\t";
        std::cout << PairArray::second[i] << std::endl;
    }
}

void Wine::GetBottles()
{
    std::cout << "Enter " << Label() << " data for " << years << " year(s):\n";

    int input;
    for (int i = 0; i < years; i++)
    {
        std::cout << "Enter year: ";
        std::cin >> input;
        PairArray::first[i] = input;
        std::cout << "Enter bottles for that year: ";
        std::cin >> input;
        PairArray::second[i] = input;

        std::cout << std::endl;
    }
}

int Wine::sum() const
{
    int sum = 0;
    for (int i = 0; i < years; i++)
    {
        sum += PairArray::second[i];
    }
    return sum;
}

ch14_p02.cpp
#include <iostream>
#include "wine2.h"

int main()
{
    std::cout << "Enter name of wine: ";
    char lab[50];
    std::cin.getline(lab, 50);
    std::cout << std::endl;

    std::cout << "Enter number of years: ";
    int yrs = 0;
    std::cin >> yrs;
    while (std::cin.get() != '\n')
    {
        continue;
    }
    Wine holding(lab, yrs);
    holding.GetBottles();
    holding.Show();
    std::cout << std::endl;

    const int YRS = 3;
    int y[YRS] = { 1993, 1995, 1998 };
    int b[YRS] = { 48, 60, 72 };

    Wine more("Gushing Grape Red", YRS, y, b);
    more.Show();
    std::cout << std::endl;

    std::cout << "Total bottles for " << more.Label();
    std::cout << ": " << more.sum() << std::endl;
    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Enter name of wine: Peter Smith

Enter number of years: 3
Enter Peter Smith data for 3 year(s):
Enter year: 1993
Enter bottles for that year: 32

Enter year: 2003
Enter bottles for that year: 55

Enter year: 2013
Enter bottles for that year: 66

Wine: Peter Smith
        Year    Bottles
        1993    32
        2003    55
        2013    66

Wine: Gushing Grape Red
        Year    Bottles
        1993    48
        1995    60
        1998    72

Total bottles for Gushing Grape Red: 180
Done.

3：定义QueueTP模板然后在一个类似于程序清单14.12的程序中创建一个指向Worker的指针队列，使用编写程序测试该队列。
queuetp.h
#ifndef QUEUETP_H_
#define QUEUETP_H_

template <typename T>
class QueueTp
{
private:
    struct Node
    {
        T value;
        Node *next = nullptr;
        Node *prev = nullptr;
    };
    using link = Node*;
    link head = nullptr;
    link tail = nullptr;
    void emptyList();
public:
    QueueTp();
    QueueTp(const QueueTp<T> &q);
    ~QueueTp();

    bool enqueue(const T &val);
    bool dequeue(T &val);
    bool isEmpty() const;

    QueueTp<T> &operator = (const QueueTp<T> &q);
};

template <typename T>
QueueTp<T>::QueueTp() : head(nullptr), tail(nullptr)
{

}

template <typename T>
QueueTp<T>::QueueTp(const QueueTp<T> &q)
{
    link tail = q.tail;
    while (tail != nullptr)
    {
        enqueue(tail->value);
        tail = tail->prev;
    }
}
template <typename T>
QueueTp<T>::~QueueTp()
{
    emptyList();
}
template <typename T>
void QueueTp<T>::emptyList()
{
    link t = head;
    link next;
    while (t != nullptr)
    {
        next = t->next;
        delete t;
        t = next;
    }
    head = nullptr;
    tail = nullptr;
}
template <typename T>
bool QueueTp<T>::enqueue(const T &val)
{
    link l = new (std::nothrow) Node;
    if (l == nullptr)
    {
        return false;
    }
    else
    {
        if (isEmpty())
        {
            l->value = val;
            l->next = nullptr;
            l->prev = nullptr;
            head = l;
            tail = l;
        }
        else
        {
            l->value = val;
            l->next = head;
            l->prev = nullptr;
            head->prev = l;
            head = l;
        }
        return true;
    }
}
template <typename T>
bool QueueTp<T>::dequeue(T &val)
{
    if (isEmpty())
    {
        return false;
    }
    else
    {
        if (head == tail)
        {
            val = tail->value;
            delete tail;
            head = tail = nullptr;
        }
        else
        {
            val = tail->value;
            link prev = tail->prev;
            delete tail;
            tail = prev;
            tail->next = nullptr;
        }
        return true;
    }
}
template <typename T>
bool QueueTp<T>::isEmpty() const
{
    if (nullptr == head && nullptr == tail)
    {
        return true;
    }
    else
    {
        return false;
    }
}
template <typename T>
QueueTp<T> &QueueTp<T>::operator = (const QueueTp<T> &q)
{
    if (&q == this)
    {
        return *this;
    }

    emptyList();
    link t = q.tail;
    while (t != nullptr)
    {
        enqueue(t->value);
        t = t->prev;
    }
    return *this;
}

#endif

workermi.h
#pragma once
#ifndef WORKERMI_H_
#define WORKERMI_H_
#include <string>

class Worker
{
private:
    std::string fullname;
    long id;
protected:
    virtual void Data() const;
    virtual void Get();
public:
    Worker() : fullname("no one"), id(0L) {}
    Worker(const std::string &s, long n) : fullname(s), id(n) {}
    virtual ~Worker() = 0;
    virtual void Set() = 0;
    virtual void Show() const = 0;
};

class Waiter : virtual public Worker
{
private:
    int panache;
protected:
    void Data() const;
    void Get();
public:
    Waiter() : Worker(), panache(0) {}
    Waiter(const std::string &s, long n, int p = 0) : Worker(s, n), panache(p) {}
    Waiter(const Worker &wk, int p = 0) : Worker(wk), panache(p) {}
    void Set();
    void Show() const;
};

class Singer : virtual public Worker
{
protected:
    enum
    {
        other, alto, contralto, soprano,
        bass, baritone, tenor
    };
    enum { Vtypes = 7 };
    void Data() const;
    void Get();
private:
    static const char *pv[Vtypes];
    int voice;
public:
    Singer() : Worker(), voice(other) {}
    Singer(const std::string &s, long n, int v = other) : Worker(s, n), voice(v) {}
    Singer(const Worker &wk, int v = other) : Worker(wk), voice(v) {}
    void Set();
    void Show() const;
};
class SingingWaiter : public Singer, public Waiter
{
protected:
    void Data() const;
    void Get();
public:
    SingingWaiter() {}
    SingingWaiter(const std::string &s, long n, int p = 0, int v = Singer::other) : Worker(s, n), Waiter(s, n, p), Singer(s, n, v) {}
    SingingWaiter(const Worker &wk, int p = 0, int v = Singer::other) : Worker(wk), Waiter(wk, p), Singer(wk, v) {}
    SingingWaiter(const Waiter &wt, int v = Singer::other) : Worker(wt), Waiter(wt), Singer(wt, v) {}
    SingingWaiter(const Singer &wt, int p = 0) : Worker(wt), Waiter(wt, p), Singer(wt) {}
    void Set();
    void Show() const;
};

#endif

workermi.cpp
#include <iostream>
#include "workermi.h"

using std::cout;
using std::cin;
using std::endl;

Worker::~Worker() { }

void Worker::Data() const
{
    cout << "Name: " << fullname << endl;
    cout << "Employee ID: " << id << endl;
}

void Worker::Get()
{
    std::getline(cin, fullname, '\n');
    cout << "Enter worker's ID: ";
    cin >> id;
    while (cin.get() != '\n')
    {
        continue;
    }
}

void Waiter::Set()
{
    cout << "Enter waiter's name: ";
    Worker::Get();
    Get();
}
void Waiter::Show() const
{
    cout << "Category: waiter\n";
    Worker::Data();
    Data();
}
void Waiter::Data() const
{
    cout << "Panache rating: " << panache << endl;
}
void Waiter::Get()
{
    cout << "Enter waiter's panache rating: ";
    cin >> panache;
    while (cin.get() != '\n')
    {
        continue;
    }
}
const char *Singer::pv[Singer::Vtypes] = { "other", "alto", "contralto", "soprano", "bass", "baritone", "tenor" };

void Singer::Set()
{
    cout << "Enter singer's name: ";
    Worker::Get();
    Get();
}

void Singer::Show() const
{
    cout << "Category: singer\n";
    Worker::Data();
    Data();
}
void Singer::Data() const
{
    cout << "Vocal range: " << pv[voice] << endl;
}
void Singer::Get()
{
    cout << "Enter number for singer's vocal range:\n";
    int i;
    for (i = 0; i < Vtypes; i++)
    {
        cout << i << ": " << pv[i] << "   ";
        if (i % 4 == 3)
        {
            cout << endl;
        }
    }
    if (i % 4 != 0)
    {
        cout << '\n';
    }
    while (cin >> voice && (voice < 0 || voice >= Vtypes))
    {
        cout << "Please enter a value >= 0 and < " << Vtypes << endl;
    }
    cin.clear();
    while (cin.get() != '\n')
    {
        continue;
    }
}
void SingingWaiter::Data() const
{
    Singer::Data();
    Waiter::Data();
}
void SingingWaiter::Get()
{
    Waiter::Get();
    Singer::Get();
}
void SingingWaiter::Set()
{
    cout << "Enter singing waiter's name: ";
    Worker::Get();
    Get();
}
void SingingWaiter::Show() const
{
    cout << "Category: singing waiter\n";
    Worker::Data();
    Data();
}

ch14_p03.cpp
#include <iostream>
#include <cstring>
#include "workermi.h"
#include "queuetp.h"

const int SIZE = 5;

int main()
{
    QueueTp<Worker *> q;
    Worker *pw;
    int ct;
    for (ct = 0; ct < SIZE; ct++)
    {
        std::cout << "Enter the employee category:\n";
        std::cout << "w: waiter  s: singer  ";
        std::cout << "t: singing waiter  q: quit\n";

        char choice = 0;
        std::cin >> choice;
        while (std::cin.get() != '\n')
        {
            continue;
        }
        while (std::strchr("wstq", choice) == nullptr)
        {
            std::cout << "Please enter a w, s, t, or q: ";
            std::cin >> choice;
            while (std::cin.get() != '\n')
            {
                continue;
            }
        }

        if (choice == 'q')
        {
            break;
        }

        switch (choice)
        {
        case 'w':
            pw = new Waiter;
            break;
        case 's':
            pw = new Singer;
            break;
        case 't':
            pw = new SingingWaiter;
            break;
        default:
            pw = new SingingWaiter;
            break;
        }

        pw->Set();
        q.enqueue(pw);
    }

    std::cout << "\nHere is your staff:\n";

    for (int i = 0; i < ct; i++)
    {
        q.dequeue(pw);
        pw->Show();
        delete pw;
        std::cout << std::endl;
    }
    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
w
Enter waiter's name: Apple
Enter worker's ID: 222333
Enter waiter's panache rating: 8
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
s
Enter singer's name: Orange
Enter worker's ID: 555666
Enter number for singer's vocal range:
0: other   1: alto   2: contralto   3: soprano
4: bass   5: baritone   6: tenor
1
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
t
Enter singing waiter's name: Water
Enter worker's ID: 888999
Enter waiter's panache rating: 9
Enter number for singer's vocal range:
0: other   1: alto   2: contralto   3: soprano
4: bass   5: baritone   6: tenor
6
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
q

Here is your staff:
Category: waiter
Name: Apple
Employee ID: 222333
Panache rating: 8

Category: singer
Name: Orange
Employee ID: 555666
Vocal range: alto

Category: singing waiter
Name: Water
Employee ID: 888999
Vocal range: tenor
Panache rating: 9

Done.

4.Person类保存人的名和姓。除构造函教外，它还有show()方法，用于显示名和姓。
Gunslinger类以Person类为虚基类派生而来，它包含一个Draw方法，返回一个double值，表示枪手的拔枪时间。
这个类还包含一个int成员，表示枪手枪上的刻痕数。最后，这个类还包含一个Show方法，用于显示所有这些信息。
PokerPlayer类以Person 类为虚基类派生而来。它包含一个Draw方法，返回一个1-52的随机数，用于表示克牌的值
（也可以定义一Card类，其中包含花色和面值成员，然后让Draw返回一个Card对象。
PokerPlayer类使用Person 类的show函数。
BadDude类从Gunslinger和PokerPlayer类公有派生而来。
它包含Gdraw方法（返回坏蛋拔枪的时间）和 Cdraw方法（返回下一张扑克牌）；
另外还有一个合适的Show函数。请定义这些类和方法以及其他必要的方法（如用于设置对象值的方法），
并使用一个类似于程序清单14.12的简单程序对它们进行测试。
person2.h
#ifndef PERSON2_H_
#define PERSON2_H_
#include <string>

class Person
{
private:
    std::string firstname;
    std::string lastname;
protected:
    virtual void Data() const;
public:
    Person(const std::string &first = "", const std::string &last = "");
    virtual ~Person() {};
    void setFirstName(const std::string &s)
    {
        firstname = s;
    }
    void setLastName(const std::string &s)
    {
        lastname = s;
    }
    virtual void Show() const;
    virtual void Set();
};
class Gunslinger : virtual public Person
{
private:
    double drawtime;
    int notches;
protected:
    void Data() const;
    virtual void setData();
public:
    Gunslinger(const std::string &first = "", const std::string &last = "", double d = 0, int n = 0);
    ~Gunslinger() {};
    void setDrawTime(double d);
    void setNotches(int n);
    double Draw() const
    {
        return drawtime;
    }
    int Notches() const
    {
        return notches;
    }
    virtual void Show() const;
    virtual void Set()
    {
        Person::Set();
        Gunslinger::setData();
    }
};

class PokerPlayer : virtual public Person
{
public:
    PokerPlayer(std::string first = "", std::string last = "");
    ~PokerPlayer() {}
    int Draw() const
    {
        return (rand() % 52) + 1;
    }
    virtual void Show() const;
    virtual void Set()
    {
        Person::Set();
    }
};

class BadDude : public Gunslinger, public PokerPlayer
{
private:
public:
    BadDude(std::string first = "", std::string last = "", double d = 0, int n = 0);
    ~BadDude() {}
    double Gdraw() const
    {
        return Gunslinger::Draw();
    }
    int Cdraw() const
    {
        return PokerPlayer::Draw();
    }
    virtual void Show() const;
    void Set();
};

#endif

person2.cpp
#include <iostream>
#include "person2.h"

void Person::Data() const
{
    std::cout << "First name: " << firstname << std::endl;
    std::cout << "Last name: " << lastname << std::endl;
}
Person::Person(const std::string &first, const std::string &last)
{
    firstname = first;
    lastname = last;
}
void Person::Show() const
{
    std::cout << "Type Person" << std::endl;
    Data();
}
void Person::Set()
{
    std::cout << "Enter the first name: ";
    std::getline(std::cin, firstname, '\n');
    std::cout << "Enter the last name: ";
    std::getline(std::cin, lastname, '\n');
}
void Gunslinger::Data() const
{
    std::cout << "Draw time: " << drawtime << std::endl;
    std::cout << "Notches: " << notches << std::endl;
}
void Gunslinger::setData()
{
    std::cout << "Enter the draw time: ";
    std::cin >> drawtime;
    while (!std::cin || drawtime < 0)
    {
        std::cin.clear();
        while (std::cin.get() != '\n')
        {
            continue;
        }
        std::cout << "Draw time must be a positive number.\nTry again: ";
        std::cin >> drawtime;
    }

    std::cout << "Enter the number of notches: ";
    std::cin >> notches;
    while (!std::cin || notches < 0)
    {
        std::cin.clear();
        while (std::cin.get() != '\n')
        {
            continue;
        }
        std::cout << "Notches must be a positive integer.\nTry again: ";
        std::cin >> notches;
    }
    while (std::cin.get() != '\n')
    {
        continue;
    }
}

Gunslinger::Gunslinger(const std::string &first, const std::string &last, double d, int n) : Person(first, last)
{
    drawtime = d;
    notches = n;
}

void Gunslinger::setDrawTime(double d)
{
    if (d < 0)
    {
        std::cerr << "Error, draw time cannot be negative. ";
        std::cerr << "Setting draw time to 0." << std::endl;
        drawtime = 0;
    }
    else
    {
        drawtime = d;
    }
}
void Gunslinger::setNotches(int n)
{
    if (n < 0)
    {
        std::cerr << "Error, notches cannot be negative. ";
        std::cerr << "Setting notches to 0." << std::endl;
        notches = 0;
    }
    else
    {
        notches = n;
    }
}

void Gunslinger::Show() const
{
    std::cout << "Type Gunslinger" << std::endl;
    Person::Data();
    Data();
}
PokerPlayer::PokerPlayer(std::string first, std::string last) : Person(first, last)
{

}
void PokerPlayer::Show() const
{
    std::cout << "Type Poker Player" << std::endl;
    Person::Data();
}
BadDude::BadDude(std::string first, std::string last, double d, int n) : Person(first, last), Gunslinger(first, last, d, n), PokerPlayer(first, last)
{

}
void BadDude::Show() const
{
    std::cout << "Type BadDude" << std::endl;
    Person::Data();
    Gunslinger::Data();
}
void BadDude::Set()
{
    Person::Set();
    Gunslinger::setData();
}

ch14_p04.cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include "person2.h"

const int SIZE = 4;

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
    using std::strchr;

    std::srand(std::time(nullptr));
    Person *pp[SIZE];
    int ct;
    for (ct = 0; ct < SIZE; ct++)
    {
        std::cout << "Enter the person category:\n";
        std::cout << "p: person        g: gunslinger" << std::endl;
        std::cout << "k: poker player  b: bad dude" << std::endl;
        std::cout << "q: quit" << std::endl;

        char choice = 0;
        std::cin >> choice;
        while (std::cin.get() != '\n')
        {
            continue;
        }

        while (std::strchr("pgkbq", choice) == nullptr)
        {
            std::cout << "Please enter a p, g, k, b, or q: ";
            std::cin >> choice;
            while (std::cin.get() != '\n')
            {
                continue;
            }
        }

        if (choice == 'q')
        {
            break;
        }

        switch (choice)
        {
        case 'p':
            pp[ct] = new Person;
            break;
        case 'g':
            pp[ct] = new Gunslinger;
            break;
        case 'k':
            pp[ct] = new PokerPlayer;
            break;
        case 'b':
            pp[ct] = new BadDude;
            break;
        default:
            pp[ct] = new BadDude;
            break;
        }
        pp[ct]->Set();
        pp[ct]->Show();
        std::cout << "ct = " << ct << std::endl;
        std::cout << std::endl;
    }

    std::cout << "Your selection:" << std::endl;
    for (int i = 0; i < ct; i++)
    {
        pp[i]->Show();
        std::cout << std::endl;
        delete *(pp + i);
    }

    return 0;
}
显示结果如下
Enter the person category:
p: person        g: gunslinger
k: poker player  b: bad dude
q: quit
p
Enter the first name: Mike
Enter the last name: Pence
Type Person
First name: Mike
Last name: Pence
ct = 0

Enter the person category:
p: person        g: gunslinger
k: poker player  b: bad dude
q: quit
g
Enter the first name: Peter
Enter the last name: Smith
Enter the draw time: 3
Enter the number of notches: 6
Type Gunslinger
First name: Peter
Last name: Smith
Draw time: 3
Notches: 6
ct = 1

Enter the person category:
p: person        g: gunslinger
k: poker player  b: bad dude
q: quit
k
Enter the first name: Hello
Enter the last name: World
Type Poker Player
First name: Hello
Last name: World
ct = 2

Enter the person category:
p: person        g: gunslinger
k: poker player  b: bad dude
q: quit
b
Enter the first name: Apple
Enter the last name: Orange
Enter the draw time: 2
Enter the number of notches: 3
Type BadDude
First name: Apple
Last name: Orange
Draw time: 2
Notches: 3
ct = 3

Your selection:
Type Person
First name: Mike
Last name: Pence

Type Gunslinger
First name: Peter
Last name: Smith
Draw time: 3
Notches: 6

Type Poker Player
First name: Hello
Last name: World

Type BadDude
First name: Apple
Last name: Orange
Draw time: 2
Notches: 3

5.下面是一些类声明：
emp.h
#ifndef EMP_H_
#define EMP_H_
#include <iostream>
#include <string>

class abstr_emp
{
private:
    std::string fname;
    std::string lname;
    std::string job;
public:
    abstr_emp();
    abstr_emp(const std::string &fn, const std::string &ln, const std::string &j);
    virtual void ShowAll() const;
    virtual void SetAll();
    friend std::ostream &operator<<(std::ostream &os, const abstr_emp &e);
    virtual ~abstr_emp() = 0;
};

class employee : public abstr_emp
{
public:
    employee();
    employee(const std::string &fn, const std::string   &ln, const std::string   &j);
    virtual void ShowAll() const;
    virtual void SetAll();
};

class manager : virtual public abstr_emp
{
private:
    int inchargeof;
protected:
    int InChargeOf() const
    {
        return inchargeof;
    }
    int &InChargeOf()
    {
        return inchargeof;
    }
public:
    manager();
    manager(const std::string &fn, const std::string &ln, const std::string &j, int ico = 0);
    manager(const abstr_emp &e, int ico);
    manager(const manager &m);
    virtual void ShowAll() const;
    virtual void SetAll();
};
class fink : virtual public abstr_emp
{
private:
    std::string reportsto;
protected:
    const std::string &ReportsTo() const
    {
        return reportsto;
    }
    std::string &ReportsTo()
    {
        return reportsto;
    }
public:
    fink();
    fink(const std::string &fn, const std::string &ln, const std::string &j, const std::string &rpo);
    fink(const abstr_emp &e, const std::string &rpo);
    fink(const fink &e);
    virtual void ShowAll() const;
    virtual void SetAll();
};

class highfink : public manager, public fink
{
public:
    highfink();
    highfink(const std::string &fn, const std::string &ln, const std::string &j, const std::string &rpo, int ico);
    highfink(const abstr_emp &e, const std::string &rpo, int ico);
    highfink(const fink &f, int ico);
    highfink(const manager &m, const std::string &rpo);
    highfink(const highfink &h);
    virtual void ShowAll() const;
    virtual void SetAll();
};

#endif

注意，该类层次结构使用子带虚基类的MI，所以要牢记这种情况下用于构造函数初始化列表的特殊规则。
还需要注意的是，有些方法被声明为保护的。这可以简化一些highfink方法的代码。
请提供类方法的实现，并在一个程序中对这些类进行测试。
emp.cpp
#include <iostream>
#include "emp.h"

abstr_emp::abstr_emp()
{
    fname = "";
    lname = "";
    job = "";
}
abstr_emp::abstr_emp(const std::string &fn, const std::string   &ln, const std::string   &j)
{
    fname = fn;
    lname = ln;
    job = j;
}
void abstr_emp::ShowAll() const
{
    std::cout << "First name: " << fname << std::endl;
    std::cout << "Last name: " << lname << std::endl;
    std::cout << "Job: " << job << std::endl;
}

void abstr_emp::SetAll()
{
    std::cout << "Enter first name: ";
    std::cin >> fname;

    while (std::cin.get() != '\n')
    {
        continue;
    }

    std::cout << "Enter last name: ";
    std::cin >> lname;

    while (std::cin.get() != '\n')
    {
        continue;
    }

    std::cout << "Enter the job: ";
    std::getline(std::cin, job, '\n');
}
std::ostream &operator << (std::ostream &os, const abstr_emp &e)
{
    os << e.lname << ", " << e.fname << " : " << e.job;
    return os;
}
abstr_emp::~abstr_emp()
{

}
employee::employee() : abstr_emp()
{

}
employee::employee(const std::string &fn, const std::string   &ln, const std::string   &j) : abstr_emp(fn, ln, j)
{

}
void employee::ShowAll() const
{
    std::cout << "Status: Employee" << std::endl;
    abstr_emp::ShowAll();
}

void employee::SetAll()
{
    abstr_emp::SetAll();
}
manager::manager() : abstr_emp()
{
    inchargeof = 0;
}
manager::manager(const std::string &fn, const std::string &ln, const std::string &j, int ico) : abstr_emp(fn, ln, j)
{
    inchargeof = ico;
    if (inchargeof < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        inchargeof = 0;
    }
}
manager::manager(const abstr_emp &e, int ico) : abstr_emp(e)
{
    inchargeof = ico;
    if (inchargeof < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        inchargeof = 0;
    }
}
manager::manager(const manager &m) : abstr_emp(m)
{
    inchargeof = m.inchargeof;
}
void manager::ShowAll() const
{
    std::cout << "Status: Manager" << std::endl;
    abstr_emp::ShowAll();
    std::cout << "In charge of " << inchargeof << " people" << std::endl;
}
void manager::SetAll()
{
    abstr_emp::SetAll();
    std::cout << "Enter the number of people the manager is in charge of: ";
    std::cin >> inchargeof;

    if (inchargeof < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        inchargeof = 0;
    }
}
fink::fink() : abstr_emp()
{
    reportsto = "";
}
fink::fink(const std::string &fn, const std::string &ln, const std::string &j, const std::string &rpo) : abstr_emp(fn, ln, j)
{
    reportsto = rpo;
}
fink::fink(const abstr_emp &e, const std::string &rpo) : abstr_emp(e)
{
    reportsto = rpo;
}
fink::fink(const fink &e) : abstr_emp(e)
{
    reportsto = e.reportsto;
}
void fink::ShowAll() const
{
    std::cout << "Status: fink" << std::endl;
    abstr_emp::ShowAll();
    std::cout << "Reports to " << reportsto << std::endl;
}
void fink::SetAll()
{
    abstr_emp::SetAll();
    std::cout << "Enter whomever is reported to: ";
    std::getline(std::cin, reportsto, '\n');
}

highfink::highfink() : abstr_emp(), manager(), fink()
{
}
highfink::highfink(const std::string &fn, const std::string &ln, const std::string &j, const std::string &rpo, int ico) :
    abstr_emp(fn, ln, j), manager(fn, ln, j, ico), fink(fn, ln, j, rpo)
{

}
highfink::highfink(const abstr_emp &e, const std::string &rpo, int ico) : abstr_emp(e), manager(e, ico), fink(e, rpo)
{

}
highfink::highfink(const fink &f, int ico) : abstr_emp(f), manager(f, ico), fink(f)
{

}
highfink::highfink(const manager &m, const std::string &rpo) : abstr_emp(m), manager(m), fink(m, rpo)
{

}
highfink::highfink(const highfink &h) : abstr_emp(h), manager(h), fink(h)
{

}
void highfink::ShowAll() const
{
    std::cout << "Status: Highfink" << std::endl;
    abstr_emp::ShowAll();
    std::cout << "In charge of " << InChargeOf() << " people" << std::endl;
    std::cout << "Reports to " << ReportsTo() << std::endl;
}
void highfink::SetAll()
{
    abstr_emp::SetAll();
    std::cout << "Enter the number of people managed: ";
    std::cin >> InChargeOf();

    if (InChargeOf() < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        InChargeOf() = 0;
    }
    while (std::cin.get() != '\n')
    {
        continue;
    }

    std::cout << "Enter whomever is reported to: ";
    std::getline(std::cin, ReportsTo(), '\n');
}

ch14_p05.cpp
#include <iostream>
#include "emp.h"

int main()
{
    employee em("Trip", "Harris", "Thumper");
    std::cout << em << std::endl;
    em.ShowAll();

    std::cout << std::endl;

    manager ma("Amorphia", "Spindragon", "Nuancer", 5);
    std::cout << ma << std::endl;
    ma.ShowAll();

    std::cout << std::endl;

    fink fi("Matt", "Oggs", "Oiler", "Juno Barr");
    std::cout << fi << std::endl;
    fi.ShowAll();

    std::cout << std::endl;

    highfink hf(ma, "Curly Kew");
    hf.ShowAll();

    std::cout << std::endl;

    highfink hf2;
    hf2.SetAll();
    hf2.ShowAll();

    std::cout << std::endl;

    std::cout << "Using an abstr_emp * pointer:\n";

    abstr_emp *tri[4] = { &em, &fi, &hf, &hf2 };
    for (int i = 0; i < 4; i++)
    {
        tri[i]->ShowAll();
        std::cout << std::endl;
    }

    return 0;
}
显示结果如下
Harris, Trip : Thumper
Status: Employee
First name: Trip
Last name: Harris
Job: Thumper

Spindragon, Amorphia : Nuancer
Status: Manager
First name: Amorphia
Last name: Spindragon
Job: Nuancer
In charge of 5 people

Oggs, Matt : Oiler
Status: fink
First name: Matt
Last name: Oggs
Job: Oiler
Reports to Juno Barr

Status: Highfink
First name: Amorphia
Last name: Spindragon
Job: Nuancer
In charge of 5 people
Reports to Curly Kew

Enter first name: Mike
Enter last name: Pence
Enter the job: Apple
Enter the number of people managed: 8
Enter whomever is reported to: Peter Smith
Status: Highfink
First name: Mike
Last name: Pence
Job: Apple
In charge of 8 people
Reports to Peter Smith

Using an abstr_emp * pointer:
Status: Employee
First name: Trip
Last name: Harris
Job: Thumper

Status: fink
First name: Matt
Last name: Oggs
Job: Oiler
Reports to Juno Barr

Status: Highfink
First name: Amorphia
Last name: Spindragon
Job: Nuancer
In charge of 5 people
Reports to Curly Kew

Status: Highfink
First name: Mike
Last name: Pence
Job: Apple
In charge of 8 people
Reports to Peter Smith

第15章 友元、异常和其他
15.1 友元
15.1.1 友元类
15.1.2 友元成员函数
15.1.3 其他友元关系
15.1.4 共同的友元
15.2 嵌套类
15.2.1 嵌套类和访间权限
15.2.2 模板中的嵌套
15.3 异常
15.3.1 调用abort
15.3.2 返回错误码
1533 异常机制
15.3.4 将对象用作异常类型
15.3.5 异常规范和C++11
15.3.6 栈解退
15.3.7 其他异常特性
15.3.8 exception类
15.3.9 异常、类和继承
15.3.10 异常何时会迷失方向
15.3.11 有关异常的注意事项
15.4 RTTI
15.4.1 RTTI的用途
15.4.2 RTTI的工作原理
15.5 类型转换运算符
15.6 总结
15.7 复习题
15.8 编程练习
本章内容包括：
友元类。
友元类方法。
嵌套类。
引发异常、try块和catch块。
异常类。
运行阶段类型识别（RTTI）。
dynamic_cast和typeid。
static_cast、const_cast和reinterpret_cast。
可以将类作为友元，在这种情况下，友元类的所有方法都可以访问原始类的私有成员和保护成员。
另外，也可以只将特定的成员函数指定为另一个类的友元。
假设需要编写一个模拟电视机和遥控器的简单程序。Tv类和Remote类分别表示电视机和遥控器。
遥控器并非电视机，反之亦然，所以公有继承的is-a关系并不适用。
遥控器也非电视机的一部分，反之亦然，因此包含或私有继承和保护继承的has-a关系也不适用。
事实上，遥控器可以改变电视机的状态，这表明应将Romote类作为Tv类的一个友元。
下面的语句使Remote成为友元类：
friend class Remote;
友元声明可以位于公有、私有或保护部分，其所在的位置无关紧要。
由于Remote类提到了Tv类，所以编译器必须了解Tv类后，才能处理Remote类，为此，最简单的方法是首先定义Tv类。
也可以使用前向声明（forward delaration），这将稍后介绍。
程序清单15.1 tv.h
#ifndef TV_H_
#define TV_H_

class Tv
{
public:
    friend class Remote;
    enum { Off, On };
    enum { MinVal, MaxVal = 20 };
    enum { Antenna, Cable };
    enum { TV, DVD };

    Tv(int s = Off, int mc = 125) : state(s), volume(5), maxchannel(mc), channel(2), mode(Cable), input(TV) {}
    void onoff()
    {
        state = (state == On) ? Off : On;
    }
    bool ison() const
    {
        return state == On;
    }
    bool volup();
    bool voldown();
    void chanup();
    void chandown();
    void set_mode()
    {
        mode = (mode == Antenna) ? Cable : Antenna;
    }
    void set_input()
    {
        input = (input == TV) ? DVD : TV;
    }
    void settings() const;
private:
    int state;
    int volume;
    int maxchannel;
    int channel;
    int mode;
    int input;
};

class Remote
{
private:
    int mode;
public:
    Remote(int m = Tv::TV) : mode(m) {}
    bool volup(Tv &t)
    {
        return t.volup();
    }
    bool voldown(Tv &t)
    {
        return t.voldown();
    }
    void onoff(Tv &t)
    {
        t.onoff();
    }
    void chanup(Tv &t)
    {
        t.chanup();
    }
    void chandown(Tv &t)
    {
        t.chandown();
    }
    void set_chan(Tv &t, int c)
    {
        t.channel = c;
    }
    void set_mode(Tv &t)
    {
        t.set_mode();
    }
    void set_input(Tv &t)
    {
        t.set_input();
    }
};

#endif

程序清单15.2 tv.cpp
#include <iostream>
#include "tv.h"

bool Tv::volup()
{
    if (volume < MaxVal)
    {
        volume++;
        return true;
    }
    else
    {
        return false;
    }
}

bool Tv::voldown()
{
    if (volume > MinVal)
    {
        volume--;
        return true;
    }
    else
    {
        return false;
    }
}

void Tv::chanup()
{
    if (channel < maxchannel)
    {
        channel++;
    }
    else
    {
        channel = 1;
    }
}

void Tv::chandown()
{
    if (channel > 1)
    {
        channel--;
    }
    else
    {
        channel = maxchannel;
    }
}

void Tv::settings() const
{
    using std::cout;
    using std::endl;
    cout << "TV is " << (state == Off ? "Off" : "On") << endl;
    if (state == On)
    {
        cout << "Volume setting = " << volume << endl;
        cout << "Channel setting = " << channel << endl;
        cout << "Mode = " << (mode == Antenna ? "antenna" : "cable") << endl;
        cout << "Input = " << (input == TV ? "TV" : "DVD") << endl;
    }
}

程序清单15.3 use_tv.cpp
#include <iostream>
#include "tv.h"

int main()
{
    using std::cout;

    Tv s42;

    cout << "Initial settings for s42\" TV:\n";
    s42.settings();
    s42.onoff();
    s42.chanup();

    cout << "\nAdjusted settings for s42\" TV:\n";
    s42.settings();

    Remote grey;

    grey.set_chan(s42, 10);
    grey.volup(s42);
    grey.volup(s42);
    cout << "\ns42\" settings after using remote:\n";
    s42.settings();

    Tv s58(Tv::On);
    s58.set_mode();
    grey.set_chan(s58, 28);
    cout << "\ns58\" settings:\n";
    s58.settings();

    return 0;
}
显示结果如下
Initial settings for s42" TV:
TV is Off

Adjusted settings for s42" TV:
TV is On
Volume setting = 5
Channel setting = 3
Mode = cable
Input = TV

s42" settings after using remote:
TV is On
Volume setting = 7
Channel setting = 10
Mode = cable
Input = TV

s58" settings:
TV is On
Volume setting = 5
Channel setting = 28
Mode = antenna
Input = TV

可以选择仅让特定的类成员成为另一个类的友元，而不必让整个类成为友元。
让Remote:set_chan成为Tv类的友元的方法是，在Tv类声明中将其声明为友元：
class TV
{
public:
    friend void Remote::set_chan(Tv & t, int c);
    // ...
}
然而，要使编译器能够处理这条语句，它必须知道Remote的定义。
否则，它无法知道Remote是一个类，而set_chan是这个类的方法。
这意味着应将Remote的定义放到Tv的定义前面。Remote的方法提到了Tv对象，而这意味着Tv定义应当位于Remote定义之前。
避开这种循环依赖的方法是，使用前向声明（forward declaration）。为此，需要在Remote定义的前面插入下面的语句：
class Tv;   //forward declaration
这样，排列次序应如下：
class Tv;   //forward declaration
class Remote
{
    // ...
};
class Tv
{
    // ...
};
能否像下面这样排列呢？
class Remote;   //forward declaration
class Tv
{
    // ...
};
class Remote
{
    // ...
};
答案是不能。原因在于，在编译器在Tv类的声明中看到Remote的一个方法被声明为Tv类的友元之前，
应该先看到Remote类的声明和set_chan方法的声明。
还有一个麻烦。程序清单15.1的Remote声明包含了内联代码，例如：
    void onoff(Tv &t)
    {
        t.onoff();
    }
由于这将调用Tv的一个方法，所以编译器此时必须已经看到了Tv类的声明，这样才能知道Tv有哪些方法，
但正如看到的，该声明位于Remote声明的后面。这种问题的解决方法是，使Remote声明中只包含方法声明，
并将实际的定义放在Tv类之后。这样，排列顺序将如下：
class Tv;   // forward declaration
class Remote    // Tv-using methods as prototypes only
{
    // ...
};
class Tv
{
    // ...
};
// put Remote method definitions here
程序清单15.4 tvfm.h
#ifndef TVFM_H_
#define TVFM_H_

class Tv;

class Remote
{
public:
	enum State { Off, On };
	enum { MinVal, MaxVal = 20 };
	enum { Antenna, Cable };
	enum { TV, DVD };
private:
	int mode;
public:
	Remote(int m = TV) : mode(m) {}
	bool volup(Tv & t);
	bool voldown(Tv & t);
	void onoff(Tv & t);
	void chanup(Tv & t);
	void chandown(Tv & t);
	void set_mode(Tv & t);
	void set_input(Tv & t);
	void set_chan(Tv & t, int c);
};

class Tv
{
public:
	friend void Remote::set_chan(Tv & t, int c);
	enum State { Off, On };
	enum { MinVal, MaxVal = 20 };
	enum { Antenna, Cable };
	enum { TV, DVD };

	Tv(int s = Off, int mc = 125) : state(s), volume(5), maxchannel(mc), channel(2), mode(Cable), input(TV) {}
	void onoff() { state = (state == On) ? Off : On; }
	bool ison() const { return state == On; }
	bool volup();
	bool voldown();
	void chanup();
	void chandown();
	void set_mode() { mode = (mode == Antenna) ? Cable : Antenna; }
	void set_input() { input = (input == TV) ? DVD : TV; }
	void settings() const;
private:
	int state;
	int volume;
	int maxchannel;
	int channel;
	int mode;
	int input;
};

inline bool Remote::volup(Tv & t) { return t.volup(); }
inline bool Remote::voldown(Tv & t) { return t.voldown(); }
inline void Remote::onoff(Tv & t) { t.onoff(); }
inline void Remote::chanup(Tv & t) { t.chanup(); }
inline void Remote::chandown(Tv & t) { t.chandown(); }
inline void Remote::set_mode(Tv & t) { t.set_mode(); }
inline void Remote::set_input(Tv & t) { t.set_input(); }
inline void Remote::set_chan(Tv & t, int c) { t.channel = c; }

#endif
显示结果如下
Initial settings for s42" TV:
TV is Off

Adjusted settings for s42" TV:
TV is On
Volume setting = 5
Channel setting = 3
Mode = cable
Input = TV

s42" settings after using remote:
TV is On
Volume setting = 7
Channel setting = 10
Mode = cable
Input = TV

s58" settings:
TV is On
Volume setting = 5
Channel setting = 28
Mode = antenna
Input = TV

如果在tv.cpp和use_tv.cpp中包含tvfm.h而不是tv.h，程序的行为与前一个程序相同，
区别在于，只有一个Remote方法是Tv类的友元，而在原来的版本中，所有的Remote方法都是Tv类的友元。
让整个Remote类成为友元并不需要前向声明，因为友元语句本身已经指出Remote是一个类：
friend class Remote;
可以通过让类彼此成为对方的友元，即Remote是Tv的友元，Tv也是Remote的友元。
需要记住的一点是，对于使用Remote对象的Tv方法，其原型可在Remote类声明之前声明，
但必须在Remote类声明之后定义，以便编译器有足够的信息来编译该方法。这种方案与下面类似：
class Tv
{
public:
    friend class Remote;
    void buzz (Remote & r);
    // ...
};
class Remote
{
public:
    friend class Tv;
    bool volup(Tv &t)
    {
        return t.volup();
    }
    // ...
};
inline void Tv::buzz(Remote & r)
{
    // ...
}
由于Remote的声明位于Tv声明的后面，所以可以在类声明中定义Remote::volup，
但T::buzz方法必须在Tv声明的外部定义，使其位于Remote声明的后面。
如果不希望buzz是内联的，则应在一个单独的方法定义文件中定义它。
如果函数需要访问两个类的私有数据，将函数作为两个类的友元更合理。
例如，假定有一个Probe类和一个Analyzer类，前者表示某种可编程的测量设备，后者表示某种可编程的分析设备。
这两个类都有内部时钟，且希望它们能够同步，则应该包含下述代码行：
class Analyzer;
class Probe
{
public:
    friend void sync (Analyzer & a, Probe & p);
    friend void sync (Probe & p, Analyzer & a);
    // ...
};
class Analyzer
{
public:
    friend void sync (Analyzer & a, Probe & p);
    friend void sync (Probe & p, Analyzer & a);
    // ...
};
inline void sync (Analyzer & a, Probe & p)
{
    // ...
}
inline void sync (Probe & p, Analyzer & a)
{
    // ...
}
可以将类声明放在另一个类中，在另一个类中声明的类被称为嵌套类（nested class）。
包含类的成员函数可以创建和使用被嵌套类的对象；而仅当声明位于公有部分，
才能在包含类的外面使用嵌套类，而且必须使用作用域解析运算符。
对类进行嵌套与包含并不同。包含意味着将类对象作为另一个类的成员，
而对类进行嵌套不创建类成员，而是定义了一种类型，该类型仅在包含嵌套类声明的类中有效。
对类进行嵌套通常是为了帮助实现另一个类，并避免名称冲突。
如果嵌套类是在另一个类的私有部分声明的，则只有后者知道它。
如果嵌套类是在另一个类的保护部分声明的，则它对于后者、后者的派生类来说是可见的，但是对于外部世界则是不可见的。
如果嵌套类是在另一个类的公有部分声明的，则允许后者、后者的派生类以及外部世界使用它，因为它是公有的。
然而，由于嵌套类的作用域为包含它的类，因此在外部世界使用它时，必须使用类限定符。
表15.1 嵌套类、结构和枚举的作用域特征
声明位置         包含它的类是否可以使用它         从包含它的类派生而来的类是否可以使用它         在外部是否可以使用
私有部分           是                                                      否                                                               否
保护部分           是                                                      是                                                               否
公有部分           是                                                      是                                                               是，通过类限定符来使用
对嵌套类访问权的控制规则与对常规类相同。
总之，类声明的位置决定了类的作用域或可见性。
类可见后，访问控制规则（公有、保护、私有、友元）将决定程序对嵌套类成员的访问权限。
程序清单15.5 queuetp2.h
#ifndef QUEUETP2_H_
#define QUEUETP2_H_

template <typename T>
class QueueTP
{
private:
    enum { Q_SIZE = 10 };
    class Node
    {
    public:
        T item;
        Node *next;
        Node(const T &i) : item(i), next(nullptr) { }
    };
    Node *front;
    Node *rear;
    int items;
    const int qsize;
    QueueTP(const QueueTP &q) : qsize(0) {}
    QueueTP &operator=(const QueueTP &q)
    {
        return *this;
    }
public:
    QueueTP(int qs = Q_SIZE);
    ~QueueTP();
    bool isempty() const
    {
        return items == 0;
    }
    bool isfull() const
    {
        return items == qsize;
    }
    int queuecount() const
    {
        return items;
    }
    bool enqueue(const T &item);
    bool dequeue(T &item);
};

template <typename T>
QueueTP<T>::QueueTP(int qs) : qsize(qs)
{
    front = rear = nullptr;
    items = 0;
}

template <typename T>
QueueTP<T>::~QueueTP()
{
    Node *next;
    while (front != nullptr)
    {
        next = front->next;
        delete front;
        front = next;
    }
}
template <typename T>
bool QueueTP<T>::enqueue(const T &item)
{
    if (isfull())
    {
        return false;
    }
    Node *add = new Node(item);
    if (isempty())
    {
        front = add;
        rear = add;
    }
    else
    {
        rear->next = add;
        rear = add;

    }
    items++;
    return true;
}

template <typename T>
bool QueueTP<T>::dequeue(T &item)
{
    if (isempty())
    {
        return false;
    }
    item = front->item;
    Node *next = front->next;
    delete front;
    front = next;
    items--;
    if (items == 0)
    {
        front = rear = nullptr;
    }
    return true;
}

#endif

程序清单15.6 nested_class.cpp
#include <iostream>
#include <string>
#include "queuetp2.h"

int main()
{
    using std::string;
    using std::cin;
    using std::cout;

    QueueTP<string> cs(5);
    string temp;

    while (!cs.isfull())
    {
        cout << "Please enter your name. You will be "
             "served in the order of arrival.\n"
             "name: ";
        std::getline(cin, temp, '\n');
        cs.enqueue(temp);
    }
    cout << "The queue is full. Processing begins!\n";

    while (!cs.isempty())
    {
        cs.dequeue(temp);
        cout << "Now processing " << temp << "\n";
    }

    return 0;
}
显示结果如下
Please enter your name. You will be served in the order of arrival.
name: Peter Smith
Please enter your name. You will be served in the order of arrival.
name: Mike Pence
Please enter your name. You will be served in the order of arrival.
name: Hello World
Please enter your name. You will be served in the order of arrival.
name: Apple
Please enter your name. You will be served in the order of arrival.
name: Orange
The queue is full. Processing begins!
Now processing Peter Smith
Now processing Mike Pence
Now processing Hello World
Now processing Apple
Now processing Orange

程序清单15.7 error1.cpp
#include <iostream>
#include <cstdlib>

double hmean(double a, double b);

int main()
{
    double x, y, z;

    std::cout << "Enter two numbers <q to quit>: ";
    while (std::cin >> x && std::cin >> y)
    {
        z = hmean(x, y);
        std::cout << "Harmonic mean of " << x << " and " << y
                  << " is " << z << std::endl;
        std::cout << "Enter two numbers <q to quit>: ";
    }
    std::cout << "Done.\n";

    return 0;
}

double hmean(double a, double b)
{
    if (a == -b)
    {
        std::cout << "untenable arguments to hmean()\n";
        std::abort();
    }
    return (2.0 * a * b) / (a + b);
}
显示结果如下
Enter two numbers <q to quit>: 2.5 3.5
Harmonic mean of 2.5 and 3.5 is 2.91667
Enter two numbers <q to quit>: 3 3
Harmonic mean of 3 and 3 is 3
Enter two numbers <q to quit>: 5 2
Harmonic mean of 5 and 2 is 2.85714
Enter two numbers <q to quit>: 3 -3
untenable arguments to hmean()
Aborted (core dumped)

程序清单15.8 error2.cpp
#include <iostream>
#include <cfloat>

bool hmean(double a, double b, double *ans);

int main()
{
    double x, y, z;

    std::cout << "Enter two numbers <q to quit>: ";
    while (std::cin >> x && std::cin >> y)
    {
        if (hmean(x, y, &z))
        {
            std::cout << "Harmonic mean of " << x << " and " << y
                      << " is " << z << std::endl;
        }
        else
        {
            std::cout << "One value should not be the negative "
                      << "of the other - try again.\n";
        }
        std::cout << "Enter two numbers <q to quit>: ";
    }
    std::cout << "Done.\n";

    return 0;
}

bool hmean(double a, double b, double *ans)
{
    if (a == -b)
    {
        *ans = DBL_MAX;
        return false;
    }
    else
    {
        *ans = (2.0 * a * b) / (a + b);
        return true;
    }
}
显示结果如下
Enter two numbers <q to quit>: 3 5
Harmonic mean of 3 and 5 is 3.75
Enter two numbers <q to quit>: 3 -3
One value should not be the negative of the other - try again.
Enter two numbers <q to quit>: 5 3
Harmonic mean of 5 and 3 is 3.75
Enter two numbers <q to quit>: 5 2
Harmonic mean of 5 and 2 is 2.85714
Enter two numbers <q to quit>: q
Done.

程序清单15.9 error3.cpp
#include <iostream>
#include <cfloat>

double hmean(double a, double b);

int main()
{
    double x, y, z;

    std::cout << "Enter two numbers <q to quit>: ";
    while (std::cin >> x && std::cin >> y)
    {
        try
        {
            z = hmean(x, y);
        }
        catch (const char *s)
        {
            std::cout << s << std::endl;
            std::cout << "Enter two numbers <q to quit>: ";
            continue;
        }
        std::cout << "Harmonic mean of " << x << " and " << y
                  << " is " << z << std::endl;
        std::cout << "Enter two numbers <q to quit>: ";
    }
    std::cout << "Done.\n";

    return 0;
}

double hmean(double a, double b)
{
    if (a == -b)
    {
        throw "bad hmean() arguments: a = -b not allowed";
    }
    return (2.0 * a * b) / (a + b);
}
显示结果如下
Enter two numbers <q to quit>: 3 5
Harmonic mean of 3 and 5 is 3.75
Enter two numbers <q to quit>: 2 5
Harmonic mean of 2 and 5 is 2.85714
Enter two numbers <q to quit>: 3 -3
bad hmean() arguments: a = -b not allowed
Enter two numbers <q to quit>: 5 2
Harmonic mean of 5 and 2 is 2.85714
Enter two numbers <q to quit>: q
Done.

异常类型可以是字符串（就像这个例子中那样）或其他C++类型；通常为类类型。
double hmean(double a, double b)
{
    if (a == -b)
    {
        throw "bad hmean() arguments: a = -b not allowed";
    }
    return (2.0 * a * b) / (a + b);
}
执行throw语句类似于执行返回语句，但throw不是将控制权返回给调用程序，而是导致程序沿函数调用序列后退，直到找到包含try块的函数。
        try
        {
            z = hmean(x, y);
        }
        catch (const char *s)
        {
            std::cout << s << std::endl;
            std::cout << "Enter two numbers <q to quit>: ";
            continue;
        }
关键字catch表明这是一个处理程序，而const char * s则表明该处理程序与字符串异常匹配。当异常与该处理程序匹配时，程序将执行括号中的代码。
执行完try块中的语句后，如果没有引发任何异常，则程序跳过try块后面的catch块，直接执行处理程序后面的第一条语句。
通常，引发异常的函数将传递一个对象。这样做的重要优点之一是，可以使用不同的异常类型来区分不同的函数在不同情况下引发的异常。
另外，对象可以携带信息，程序员可以根据这些信息来确定引发异常的原因。同时，catch块可以根据这些信息来决定采取什么样的措施。
程序清单15.10 exc_mean.h
#ifndef EXC_MEAN_H_
#define EXC_MEAN_H_
#include <iostream>

class bad_hmean
{
private:
    double v1;
    double v2;
public:
    bad_hmean(double a = 0, double b = 0) : v1(a), v2(b) {}
    void mesg();
};

inline void bad_hmean::mesg()
{
    std::cout << "hmean(" << v1 << ", " << v2 << "): "
              << "invalid arguments: a = -b\n";
}

class bad_gmean
{
public:
    double v1;
    double v2;
    bad_gmean(double a = 0, double b = 0) : v1(a), v2(b) {}
    const char *mesg();
};

inline const char *bad_gmean::mesg()
{
    return "gmean() arguments should be >= 0\n";
}
#endif

程序清单15.11 error4.cpp
#include <iostream>
#include <cmath>
#include "exc_mean.h"

double hmean(double a, double b);
double gmean(double a, double b);

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;

    double x, y, z;

    cout << "Enter two numbers <q to quit>: ";
    while (cin >> x && cin >> y)
    {
        try
        {
            z = hmean(x, y);
            cout << "Harmonic mean of " << x << " and " << y
                 << " is " << z << endl;
            cout << "Geometric mean of " << x << " and " << y
                 << " is " << gmean(x, y) << endl;
            cout << "Enter two numbers <q to quit>: ";
        }
        catch (bad_hmean &bg)
        {
            bg.mesg();
            cout << "Enter two numbers <q to quit>: ";
            continue;
        }
        catch (bad_gmean &hg)
        {
            cout << hg.mesg();
            cout << "Values used: " << hg.v1 << ", " << hg.v2 << endl;
            cout << "Sorry, you don't get to play any more.\n";
            break;
        }
    }
    cout << "Done.\n";

    return 0;
}

double hmean(double a, double b)
{
    if (a == -b)
    {
        throw bad_hmean(a, b);
    }
    return (2.0 * a * b) / (a + b);
}

double gmean(double a, double b)
{
    if (a < 0 || b < 0)
    {
        throw bad_gmean(a, b);
    }
    return std::sqrt(a * b);
}
显示结果如下
Enter two numbers <q to quit>: 2 5
Harmonic mean of 2 and 5 is 2.85714
Geometric mean of 2 and 5 is 3.16228
Enter two numbers <q to quit>: 3 5
Harmonic mean of 3 and 5 is 3.75
Geometric mean of 3 and 5 is 3.87298
Enter two numbers <q to quit>: 3 -3
hmean(3, -3): invalid arguments: a = -b
Enter two numbers <q to quit>: 5 2
Harmonic mean of 5 and 2 is 2.85714
Geometric mean of 5 and 2 is 3.16228
Enter two numbers <q to quit>: 5 -2
Harmonic mean of 5 and -2 is -6.66667
Geometric mean of 5 and -2 is gmean() arguments should be >= 0
Values used: 5, -2
Sorry, you don't get to play any more.
Done.

假设函数由于出现异常（而不是由于返回）而终止，则程序将释放栈中的内存，但不会在释放栈的第一个返回地址后停止，而是继续释放栈，
直到找到一个位于try块（参见图15.3）中的返回地址。随后，控制权将转到块尾的异常处理程序，而不是函数调用后面的第一条语句。这个过程被称为栈解退。
和函数返回一样，对于栈中的自动类对象，类的析构函数将被调用。然而，函数返回仅仅处理该函数放在栈中的对象，
而throw 语句则处理try块和throw之间整个函数调用序列放在栈中的对象。
如果没有栈解退这种特性，则引发异常后，对于中间函数调用放在栈中的自动类对象，其析构函数将不会被调用。
程序清单15.12 error5.cpp
#include <iostream>
#include <string>
#include <cmath>
#include "exc_mean.h"

class demo
{
private:
    std::string word;
public:
    demo(const std::string &str)
    {

        word = str;
        std::cout << "demo " << word << " created\n";
    }
    ~demo()
    {
        std::cout << "demo " << word << " destroyed\n";
    }
    void show() const
    {
        std::cout << "demo " << word << " lives!\n";
    }
};

double hmean(double a, double b);
double gmean(double a, double b);
double means(double a, double b);

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;

    double x, y, z;
    {
        demo d1("found in block in main()");
        cout << "Enter two numbers <q to quit>: ";
        while (cin >> x && cin >> y)
        {
            try
            {
                z = means(x, y);
                cout << "The mean mean of " << x << " and " << y
                     << " is " << z << endl;
                cout << "Enter two numbers <q to quit>: ";
            }
            catch (bad_hmean &bg)
            {
                bg.mesg();
                cout << "Enter two numbers <q to quit>: ";
                continue;
            }
            catch (bad_gmean &hg)
            {
                cout << hg.mesg();
                cout << "Values used: " << hg.v1 << ", " << hg.v2 << endl;
                cout << "Sorry, you don't get to play any more.\n";
                break;
            }
        }
        d1.show();
    }
    cout << "Done.\n";

    return 0;
}
double hmean(double a, double b)
{
    if (a == -b)
    {
        throw bad_hmean(a, b);
    }
    return (2.0 * a * b) / (a + b);
}

double gmean(double a, double b)
{
    if (a < 0 || b < 0)
    {
        throw bad_gmean(a, b);
    }
    return std::sqrt(a * b);
}

double means(double a, double b)
{
    double am, hm, gm;
    demo d2("found in means()");
    am = (a + b) / 2.0;
    try
    {
        hm = hmean(a, b);
        gm = gmean(a, b);
    }
    catch (bad_hmean &bg)
    {
        bg.mesg();
        std::cout << "Caught in means()\n";
        throw;
    }
    d2.show();
    return (am + hm + gm) / 3.0;
}
显示结果如下
demo found in block in main() created
Enter two numbers <q to quit>: 2 5
demo found in means() created
demo found in means() lives!
demo found in means() destroyed
The mean mean of 2 and 5 is 3.17314
Enter two numbers <q to quit>: 3 5
demo found in means() created
demo found in means() lives!
demo found in means() destroyed
The mean mean of 3 and 5 is 3.87433
Enter two numbers <q to quit>: 3 -3
demo found in means() created
hmean(3, -3): invalid arguments: a = -b
Caught in means()
demo found in means() destroyed
hmean(3, -3): invalid arguments: a = -b
Enter two numbers <q to quit>: 5 2
demo found in means() created
demo found in means() lives!
demo found in means() destroyed
The mean mean of 5 and 2 is 3.17314
Enter two numbers <q to quit>: 5 -3
demo found in means() created
demo found in means() destroyed
gmean() arguments should be >= 0
Values used: 5, -3
Sorry, you don't get to play any more.
demo found in block in main() lives!
demo found in block in main() destroyed
Done.

    catch (bad_hmean &bg)
    {
        bg.mesg();
        std::cout << "Caught in means()\n";
        throw;
    }
catch块中的throw 语句导致函数means终止执行，并将异常传递给main函数。
means函数被提前终止，但还是为d2调用了析构函数。
程序进行栈解退以回到能够捕获异常的地方时，将释放栈中的自动存储型变量。如果变量是类对象，将为该对象调用析构函数。
重新引发的异常被传递给main函数，在该函数中，合适的catch块将捕获它并对其进行处理。
虽然throw-catch机制类似于函数参数和函数返回机制，但还是有些不同之处。
其中之一是函数fun中的返回语句将控制权返回到调用fun的函数，但throw语句将控制权向上返回到第一个这样的函数：包含能够捕获相应异常的try-catch组合。
另一个不同之处是，引发异常时编译器总是创建一个临时拷贝，即使catch块中指定的是引用。
因为函数执行完毕后，临时的异常对象将不复存在。
double hmean(double a, double b)
{
    if (a == -b)
    {
        throw bad_hmean(a, b);
    }
    return (2.0 * a * b) / (a + b);
}

double gmean(double a, double b)
{
    if (a < 0 || b < 0)
    {
        throw bad_gmean(a, b);
    }
    return std::sqrt(a * b);
}
引用有一个重要特征：基类引用可以执行派生类对象。
使用基类引用将能够捕获基类及派生类的对象；
而使用派生类对象只能捕获派生类及派生类的派生类的对象。
引发的异常对象将被第一个与之匹配的catch块捕获。这意味着catch块的排列顺序应该与派生顺序相反。
如果有一个异常类继承层次结构，应这样排列catch块：
将捕获位于层次结构最下面的异常类的catch语句放在最前面，将捕获基类异常的catch语句放在最后面。
通过正确地排列catch块的顺序，让您能够在如何处理异常方面有选择的余地。
然而，有时候可能不知道会发生哪些异常。在这种情况下，仍能够捕获异常，即使不知道异常的类型。
方法是使用省略号来表示异常类型，从而捕获任何异常：
catch (...)
{
    // ...
}
如果知道一些可能会引发的异常，可以将上述捕获所有异常的catch块放在最后面，这有点类似于switch语句中的default。
可以创建捕获对象而不是引用的处理程序。在catch语句中使用基类对象时，将捕获所有的派生类对象，
但派生特性将被剥去，因此将使用虚方法的基类版本。

exception头文件定义了exception类，可以把它用作其他异常类的基类。
exception类有一个名为what的虚拟成员函数，它返回一个字符串，可以在从exception派生而来的类中重新定义它。
stdexcept头文件定义了其他几个异常类，它们都是以公有方式从exception派生而来的。
异常类系列logic_error描述了典型的逻辑错误。每个类的名称指出了它用于报告的错误类型：
domain_error；
invalid_argument
length_error；
out_of_bounds。
每个类独有一个类似于logic_error的构造函数，让您能够提供一个供方法what返回的字符串。
异常类系列runtime_error描述了可能在运行期间发生但难以预计和防范的错误。每个类的名称指出了它用于报告的错误类型：
range_error;
overflow_error；
underflow_error。
一般而言，logic_error系列异常表明存在可以通过编程修复的问题，而runtime_error系列异常表明存在无法避免的问题。
所有这些错误类有相同的常规特征，它们之间的主要区别在于：不同的类名让您能够分别处理每种异常。
另一方面，继承关系让您能够一起处理它们（如果您愿意的话）。
对于使用new导致的内存分配问题，C++的最新处理方式是让new引发bad_alloc异常。
头文件new包含bad_alloc类的声明，它是从exception类公有派生而来的。
程序清单15.13 newexcp.cpp
#include <iostream>
#include <new>
#include <cstdlib>

using namespace std;

struct Big
{
    double stuff[20000];
};

int main()
{
    Big *pb;
    try
    {
        cout << "Trying to get a big block of memory:\n";
        pb = new Big[10000];
        cout << "Got past the new request:\n";
    }
    catch (bad_alloc &ba)
    {
        cout << "Caught the exception!\n";
        cout << ba.what() << endl;
        exit(EXIT_FAILURE);
    }
    cout << "Memory successfully allocated\n";
    pb[0].stuff[0] = 4;
    cout << pb[0].stuff[0] << endl;
    delete [] pb;

    return 0;
}

C++标准提供了一种在失败时返回空指针的new，其用法如下
int * p1 = new (std::nothrow) int;
int * pa = new (std::nothrow) int[500];
异常规范和C++11
double harm (double a) throw (bad_thing);   // may throw bad_thing exception
double marm (double) throw ();   // doesn't throw an exception
其中的throw()部分就是异常规范，它可能出现在函数原型和函数定义中，可包含类型列表；也可不包含。
异常规范的作用之一是，告诉用户可能需要使用try块。然而，这项工作也可使用注释轻松地完成。
异常规范的另一个作用是，让编译器添加执行运行阶段检查的代码，检查是否违反了异常规范。这很难检查。
例如，marm可能不会引发异常，但它可能调用一个函数，而这个函数调用的另一个函数引发了异常。
另外，您给函数编写代码时它不会引发异常，但库更新后它却会引发异常。
总之，编程社区（尤其是尽力编写安全代码的开发人员）达成的一致意见是，最好不要使用这项功能。
而C++11也建议您忽略异常规范。然而；C++11确实支持一种特殊的异常规范：
您可使用新增的关键字noexcept指出函数不会引发异常
double marm(double) noexcept;   // doesn't throw an exception
还有运算符noexcept()，它判断其操作数是否会引发异常。
程序清单15.14 sales2.h
#ifndef SALES2_H_
#define SALES2_H_
#include <stdexcept>
#include <string>

class Sales
{
public:
    enum { MONTHS = 12 };
    class bad_index : public std::logic_error
    {
    private:
        int bi;
    public:
        explicit bad_index(int ix, const std::string &s = "Index error in Sales object\n");
        int bi_val() const
        {
            return bi;
        }
        virtual ~bad_index() {}
    };
    explicit Sales(int yy = 0);
    Sales(int yy, const double *gr, int n);
    virtual ~Sales() { }
    int Year() const
    {
        return year;
    }
    virtual double operator[](int i) const;
    virtual double &operator[](int i);
private:
    double gross[MONTHS];
    int year;
};

class LabeledSales : public Sales
{
public:
    class nbad_index : public Sales::bad_index
    {
    private:
        std::string lbl;
    public:
        nbad_index(const std::string &lb, int ix, const std::string &s = "Index error in LabeledSales object\n");
        const std::string &label_val() const
        {
            return lbl;
        }
        virtual ~nbad_index() {}
    };
    explicit LabeledSales(const std::string &lb = "none", int yy = 0);
    LabeledSales(const std::string &lb, int yy, const double *gr, int n);
    virtual ~LabeledSales() { }
    const std::string &Label() const
    {
        return label;
    }
    virtual double operator[](int i) const;
    virtual double &operator[](int i);
private:
    std::string label;
};

#endif

程序清单15.15 sales2.cpp
#include <iostream>
#include "sales2.h"

using std::string;

Sales::bad_index::bad_index(int ix, const string &s) : std::logic_error(s), bi(ix)
{
}
Sales::Sales(int yy)
{
    year = yy;
    for (int i = 0; i < MONTHS; ++i)
    {
        gross[i] = 0;
    }
}

Sales::Sales(int yy, const double *gr, int n)
{
    year = yy;
    int lim = (n < MONTHS) ? n : MONTHS;
    int i;
    for (i = 0; i < lim; ++i)
    {
        gross[i] = gr[i];
    }
    for (; i < MONTHS; ++i)
    {
        gross[i] = 0;
    }
}
double Sales::operator[](int i) const
{
    if (i < 0 || i >= MONTHS)
    {
        throw bad_index(i);
    }
    return gross[i];
}

double &Sales::operator[](int i)
{
    if (i < 0 || i >= MONTHS)
    {
        throw bad_index(i);
    }
    return gross[i];
}

LabeledSales::nbad_index::nbad_index(const string &lb, int ix, const string &s) : Sales::bad_index(ix, s)
{
    lbl = lb;
}
LabeledSales::LabeledSales(const string &lb, int yy) : Sales(yy)
{
    label = lb;
}
LabeledSales::LabeledSales(const string &lb, int yy, const double *gr, int n) : Sales(yy, gr, n)
{
    label = lb;
}
double LabeledSales::operator[](int i) const
{
    if (i < 0 || i >= MONTHS)
    {
        throw nbad_index(Label(), i);
    }
    return Sales::operator[](i);
}
double &LabeledSales::operator[](int i)
{
    if (i < 0 || i >= MONTHS)
    {
        throw nbad_index(Label(), i);
    }
    return Sales::operator[](i);
}

程序清单15.16 use_sales2.cpp
#include <iostream>
#include "sales2.h"

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;

    double vals1[12] =
    {
        1220, 1100, 1122, 2212, 1232, 2334,
        2884, 2393, 3302, 2922, 3002, 3544
    };

    double vals2[12] =
    {
        12, 11, 22, 21, 32, 34,
        28, 29, 33, 29, 32, 35
    };

    Sales sales1(2011, vals1, 12);
    LabeledSales sales2("Blogstar", 2012, vals2, 12);

    cout << "First try block:\n";
    try
    {
        int i;
        cout << "Year = " << sales1.Year() << endl;
        for (i = 0; i < 12; ++i)
        {

            cout << sales1[i] << ' ';
            if (i % 6 == 5)
            {
                cout << endl;
            }
        }
        cout << "Year = " << sales2.Year() << endl;
        cout << "Label = " << sales2.Label() << endl;
        for (i = 0; i <= 12; ++i)
        {

            cout << sales2[i] << ' ';
            if (i % 6 == 5)
            {
                cout << endl;
            }
        }
        cout << "End of try block 1.\n";
    }
    catch (LabeledSales::nbad_index &bad)
    {
        cout << bad.what();
        cout << "Company: " << bad.label_val() << endl;
        cout << "bad index: " << bad.bi_val() << endl;
    }
    catch (Sales::bad_index &bad)
    {
        cout << bad.what();
        cout << "bad index: " << bad.bi_val() << endl;
    }
    cout << "\nNext try block:\n";
    try
    {
        sales2[2] = 37.5;
        sales1[20] = 23345;
        cout << "End of try block 2.\n";
    }
    catch (LabeledSales::nbad_index &bad)
    {
        cout << bad.what();
        cout << "Company: " << bad.label_val() << endl;
        cout << "bad index: " << bad.bi_val() << endl;
    }
    catch (Sales::bad_index &bad)
    {
        cout << bad.what();
        cout << "bad index: " << bad.bi_val() << endl;
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
First try block:
Year = 2011
1220 1100 1122 2212 1232 2334
2884 2393 3302 2922 3002 3544
Year = 2012
Label = Blogstar
12 11 22 21 32 34
28 29 33 29 32 35
Index error in LabeledSales object
Company: Blogstar
bad index: 12

Next try block:
Index error in Sales object
bad index: 20
Done.

异常被引发后，在两种情况下，会导致问题。首先，如果它是在带异常规范的函数中引发的，则必须与规范列表中的某种异常匹配
（在继承层次结构中，类类型与这个类及其派生类的对象匹配），否则称为意外异常（unexpected exception）。
在默认情况下，这将导致程序异常终止（虽然C++11摒弃了异常规范，但仍支持它，且有些现有的代码使用了它）。
如果异常不是在函数中引发的（或者函数没有异常规范），则必须捕获它。
如果没被捕获（在没有try块或没有匹配的catch块时，将出现这种情况），则异常被称为未捕获异常（uncaught cxception）。
在默认情况下，这将导致程序异常终止。然而，可以修改程序对意外异常和未捕获异常的反应。下面来看如何修改，先从未捕获异常开始。
未捕获异常不会导致程序立刻异常终止。相反，程序将首先调用函数terminate。在默认情况下，terminate调用abort函数。
可以指定terminate应调用的函数来修改terminate的这种行为。为此，可调用set_terminate函数。
set_terminate和terminate都是在头文件exception中声明的。
如果发生意外异常，程序将调用unexpected函数。这个函数将调用terminate函数，后者在默认情况下将调用abort函数。
有一个可用于修改unexpected的行为的set_unexpected函数。这些新函数也是在头文件exception中声明的。
unexpected_handler函数可以：
●通过调用terminate（默认行为）、abort或exit来终止程序；
●引发异常。
引发异常（第二种选择）的结果取决于unexpected_handler函数所引发的异常以及引发意外异常的函数的异常规范：
如果新引发的异常与原来的异常规范匹配，则程序将从那里开始进行正常处理，即寻找与新引发的异常匹配的catch块。
基本上，这种方法将用预期的异常取代意外异常；
●如果新引发的异常与原来的异常规范不匹配，且异常规范中没有包括std::bad_exception 类型，则程序将调用terminate。
bad_exception是从ecxccption派生而来的，其声明位于头文件exception中；
●如果新引发的异常与原来的异常规范不匹配，且原来的异常规范中包含了std::bad_exception类型，
则不匹配的异常将被std::bad_exception异常所取代。
总之，如果要捕获所有的异常（不管是预期的异常还是意外异常），则可以这样做：
首先确保异常头文件的声明可用：
#include <exception>
using namespace std;
然后，设计一个替代函数，将意外异常转换为bad_exception异常，该函数的原型如下：
void myUnexpected()
{
    throw std::bad_exception();   // or just throw;
}
仅使用throw，而不指定异常将导致重新引发原来的异常。
如果异常规范中包含了std::bad_exception类型，则该异常将被bad_exception对象所取代。
接下来在程序的开始位置，调用set_unexpected函数：
set_unexpected (myUnexpected);
最后，将bad_exception 类型包括在异常规范中，并添加对应的catch块。
使用异常会增加程序代码，降低程序的运行速度。异常规范不适用于模板，因为模板函数引发的异常可能随特定的具体化而异。
异常和动态内存分配并非总能协同工作。
下面进一步讨论动态内存分配和异常。首先，请看下面的函数：
void test1(int n)
{
    string mesg ("I'm trapped in an endless looop");
    ...
    if (oh_no)
    {
        throw exception();
    }
    ...
}
string类采用动态内存分配。通常，当函数结束时，将为mesg调用string的析构函数。虽然throw语句过早地终止了函数，但它仍然使得析构函数被调用，这要归功于栈解退。因此在这里，内存被正确地管理。
接下来看下面这个函数：
void test2(int n)
{
    double * ar = new double[n];
    ...
    if (oh_no)
    {
        throw exception();
    }
    ...
    delete [] ar;
    ...
}
这里有个问题。解退栈时，将删除栈中的变量ar。但函数过早的终止意味着函数末尾的delete[]语句被忽略。
指针消失了，但它指向的内存块未被释放，并且不可访问。总之，这些内存被泄漏了。
这种泄漏是可以避免的。例如，可以在引发异常的函数中捕获该异常，在catch块中包含一些清理代码，然后重新引发异常：
void test3(int n)
{
    double * ar = new double[n];
    ...
    try
    {
        ...
        if (oh_no)
        {
            throw exception();
        }
        ...
    }
    catch (exception & ex)
    {
        delete [] ar;
        throw;
    }
    ...
    delete [] ar;
    ...
}
然而，这将增加疏忽和产生其他错误的机会。另一种解决方法是使用第16章将讨论的智能指针模板之一。
C++有3个支持RTTI的元素。
如果可能的话，dynamic_cast运算符将使用一个指向基类的指针来生成一个指向派生类的指针：否则，该运算符返回空指针。
typeid运算符返回一个指出对象的类型的值。
type_info结构存储了有关特定类型的信息。
只能将RTTI用于包含虚函数的类层次结构，原因在于只有对于这种类层次结构，才应该将派生对象的地址赋给基类指针。
警告：RTTI 只适用于包含虚函数的类。
下面详细介绍RTTI的这3个元素。
1.dynamic_cast 运算符
dynamic_cast 运算符是最常用的RTTI组件，它不能回答“指针指向的是哪类对象”这样的问题，
但能够回答“是否可以安全地将对象的地址赋给特定类型的指针”这样的问题。我们来看一看这意味着什么。
假设有下面这样的类层次结构：
class Grand {   // has virtual methods };
class Superb : public Grand { ... };
class Magnificent : public Superb { ... };
接下来假设有下面的指针：
Grand * pg = new Grand;
Grand * ps = new Superb;
Grand * pm = new Magnificent;
最后，对于下面的类型转换：
Magnificent * p1 = (Magnificent * ) pm;
Magnificent * p2 = (Magnificent * ) pg;
Superb * p3 = (Magnificent *) pm;
例如，类型转换1就是安全的，因为它将Magificent 类型的指针指向类型为Magnificent的对象。
类型转换2就是不安全的，因为它将基类对象（Grand）的地址赋给派生类（Magnificent）指针。
因为Magnificent对象可能包含一些Grand对象没有的数据成员。
然而，类型转换3是安全的，因为它将派生对象的地址赋给基类指针。即公有派生确保Magnificent对象同时也是一个Superb对象。
因此，将它的地址赋给这3种类型的指针都是安全的。
虚函数确保了将这3种指针中的任何一种指向Magnificent对象时，都将调用Magnificent方法。
注意，与问题“指针指向的是哪种类型的对象”相比，问题“类型转换是否安全”更通用，也更有用。
通常想知道类型的原因在于：知道类型后，就可以知道调用特定的方法是否安全。
要调用方法，类型并不一定要完全匹配，而可以是定义了方法的虚拟版本的基类类型。下面的例子说明了这一点。
程序清单15.17演示了这种处理。首先，它定义了3个类，名称为Grand、Superb和Magnificent。
Grand类定义了一个虚函数Speak，而其他类都重新定义了该虚函数。
Superb类定义了一个虚函数Say，而Magnificent也重新定义了它（参见图15.4）。
程序定义了GetOne函数，该函数随机创建这3种类中某种类的对象，并对其进行初始化，
然后将地址作为Grand *指针返回（GetOne函数模拟用户做出决定）。
循环将该指针赋给Grand *变量pg，然后使用pg调用Speak函数。
因为这个函数是虚拟的，所以代码能够正确地调用指向的对象的Speak版本。
然而，不能用相同的方式（即使用指向Grand的指针）来调用Say函数，因为Grand类没有定义它。
然而，可以使用dynamic_cast运算符来检查是否可将pg的类型安全地转换为Superb指针。
如果对象的类型为Superb或Magnificent，则可以安全转换。在这两种情况下，都可以安全地调用Say函数。
程序清单15.17 rtti1.cpp
#include <iostream>
#include <cstdlib>
#include <ctime>

using std::cout;

class Grand
{
private:
    int hold;
public:
    Grand(int h = 0) : hold(h) {}
    virtual void Speak() const
    {
        cout << "I am a grand class!\n";
    }
    virtual int Value() const
    {
        return hold;
    }
};

class Superb : public Grand
{
public:
    Superb(int h = 0) : Grand(h) {}
    void Speak() const
    {
        cout << "I am a superb class!!\n";
    }
    virtual void Say() const
    {
        cout << "I hold the superb value of " << Value() << "!\n";
    }
};

class Magnificent : public Superb
{
private:
    char ch;
public:
    Magnificent(int h = 0, char c = 'A') : Superb(h), ch(c) {}
    void Speak() const
    {
        cout << "I am a magnificent class!!!\n";
    }
    void Say() const
    {
        cout << "I hold the character " << ch <<
             " and the integer " << Value() << "!\n";
    }
};

Grand *GetOne();

int main()
{
    std::srand(std::time(nullptr));
    Grand *pg;
    Superb *ps;
    for (int i = 0; i < 5; i++)
    {
        pg = GetOne();
        pg->Speak();
        if ( (ps = dynamic_cast<Superb *>(pg) ) != nullptr)
        {
            ps->Say();
        }
    }

    return 0;
}
Grand *GetOne()
{
    Grand *p;
    switch (std::rand() % 3)
    {
    case 0:
        p = new Grand(std::rand() % 100);
        break;
    case 1:
        p = new Superb(std::rand() % 100);
        break;
    case 2:
        p = new Magnificent(std::rand() % 100, 'A' + std::rand() % 26);
        break;
    }
    return p;
}
显示结果如下
I am a superb class!!
I hold the superb value of 96!
I am a grand class!
I am a superb class!!
I hold the superb value of 20!
I am a magnificent class!!!
I hold the character M and the integer 47!
I am a superb class!!
I hold the superb value of 4!

typeid运算符使得能够确定两个对象是否为同种类型。它与sizeof有些相像，可以接受两种参数：
类名；
结果为对象的表达式。
typeid运算符返回一个type_info对象的引用，其中，type_info是在头文件typeinfo中定义的一个类。
type_info类重载了==和!=运算符，以便可以使用这些运算符来对类型进行比较。
例如，如果pg指向的是一个Magnificent对象，则下述表达式的结果为bool值true，否则为false：
typeid (Magnificent) == typeid (*pg)
如果pg是一个空指针，程序将引发bad_typeid异常。该异常类型是从exception类派生而来的，是在头文件typeinfo中声明的。
type_info类的实现随厂商而异，但包含一个name成员，该函数返回一个随实现而异的字符串，通常是类的名称。
程序清单15.18 rtti2.cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <typeinfo>

using namespace std;

class Grand
{
private:
    int hold;
public:
    Grand(int h = 0) : hold(h) {}
    virtual void Speak() const
    {
        cout << "I am a grand class!\n";
    }
    virtual int Value() const
    {
        return hold;
    }
};

class Superb : public Grand
{
public:
    Superb(int h = 0) : Grand(h) {}
    void Speak() const
    {
        cout << "I am a superb class!!\n";
    }
    virtual void Say() const
    {
        cout << "I hold the superb value of " << Value() << "!\n";
    }
};

class Magnificent : public Superb
{
private:
    char ch;
public:
    Magnificent(int h = 0, char cv = 'A') : Superb(h), ch(cv) {}
    void Speak() const
    {
        cout << "I am a magnificent class!!!\n";
    }
    void Say() const
    {
        cout << "I hold the character " << ch << " and the integer " << Value() << "!\n";
    }
};

Grand *GetOne();

int main()
{
    srand(time(nullptr));
    Grand *pg;
    Superb *ps;
    for (int i = 0; i < 5; i++)
    {
        pg = GetOne();
        cout << "Now processing type " << typeid(*pg).name() << ".\n";
        pg->Speak();
        if ( ( ps = dynamic_cast<Superb *>(pg) ) != nullptr )
        {
            ps->Say();
        }
        if (typeid(Magnificent) == typeid(*pg))
        {
            cout << "Yes, you're really magnificent.\n";
        }
    }

    return 0;
}

Grand *GetOne()
{
    Grand *p;

    switch (rand() % 3)
    {
    case 0:
        p = new Grand(rand() % 100);
        break;
    case 1:
        p = new Superb(rand() % 100);
        break;
    case 2:
        p = new Magnificent(rand() % 100, 'A' + rand() % 26);
        break;
    }
    return p;
}
显示结果如下
Now processing type 5Grand.
I am a grand class!
Now processing type 5Grand.
I am a grand class!
Now processing type 5Grand.
I am a grand class!
Now processing type 11Magnificent.
I am a magnificent class!!!
I hold the character O and the integer 5!
Yes, you're really magnificent.
Now processing type 5Grand.
I am a grand class!

Now processing type 6Superb.
I am a superb class!!
I hold the superb value of 39!
Now processing type 6Superb.
I am a superb class!!
I hold the superb value of 13!
Now processing type 5Grand.
I am a grand class!
Now processing type 5Grand.
I am a grand class!
Now processing type 5Grand.
I am a grand class!

1. static_cast
static_cast的转换格式：static_cast <type-id> (expression)
将expression转换为type-id类型，主要用于非多态类型之间的转换，不提供运行时的检查来确保转换的安全性。主要在以下几种场合中使用：
用于类层次结构中，基类和子类之间指针和引用的转换；
当进行上行转换，也就是把子类的指针或引用转换成父类表示，这种转换是安全的；
当进行下行转换，也就是把父类的指针或引用转换成子类表示，这种转换是不安全的，也需要程序员来保证；
用于基本数据类型之间的转换，如把int转换成char，把int转换成enum等等，这种转换的安全性需要程序员来保证；
把void指针转换成目标类型的指针，是及其不安全的；
static_cast不能用于在不同类型的指针之间互相转换，不能用于整型和指针之间的互相转换，不能用于不同类型的引用之间的转换。
static_cast不能转换掉expression的const、volatile等属性。
2. dynamic_cast
dynamic_cast的转换格式：dynamic_cast <type-id> (expression)
将expression转换为type-id类型，type-id必须是类的指针、类的引用或者是void *；
如果type-id是指针类型，那么expression也必须是一个指针；
如果type-id是一个引用，那么expression也必须是一个引用。
dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。
在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；
在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。
在多态类型（基类包含虚函数）之间的转换主要使用dynamic_cast，因为类型提供了运行时信息。
如果expression是type-id的基类，使用dynamic_cast进行转换时，在运行时就会检查expression是否真正的指向一个type-id类型的对象，
如果是，则能进行正确的转换，获得对应的值；否则返回空指针，如果是引用，则在运行时就会抛出异常。
dynamic_cast不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用――这种转换没法保证安全性，只好用reinterpret_cast来完成。
3.reinterpret_cast
reinterpret_cast的转换格式：reinterpret_cast<type-id> (expression)
type-id必须是一个指针、引用、算术类型、函数指针或者成员指针。
它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针
（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。
reinterpret_cast用于各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。
4.const_cast
const指针被转化成非const指针，并且仍然指向原来的对象；
const引用被转换成非const引用，并且仍然指向原来的对象；
const_cast的作用是用来改变表达式里面的常量性（const）或易变性（volatile）。
程序清单15.19 constcast.cpp
#include <iostream>

using std::cout;
using std::endl;

void change(const int *pt, int n);

int main()
{
    int pop1 = 38383;
    const int pop2 = 2000;

    cout << "pop1, pop2: " << pop1 << ", " << pop2 << endl;
    change(&pop1, -103);
    change(&pop2, -103);
    cout << "pop1, pop2: " << pop1 << ", " << pop2 << endl;

    return 0;
}
void change(const int *pt, int n)
{
    int *pc;

    pc = const_cast<int *>(pt);
    *pc += n;
}
显示结果如下
pop1, pop2: 38383, 2000
pop1, pop2: 38280, 2000

调用change时，修改了pop1，但没有修改pop2。在chang中，指针被声明为const int*，因此不能用来修改指向的int。
指针pc删除了const 特征，因此可用来修改指向的值，但仅当指向的值不是const时才可行。
因此，pc可用于修改pop1，但不能用于修改pop2。
15.6 总结
友元使得能够为类开发更灵活的接口。类可以将其他函数、其他类和其他类的成员函数作为友元。
在某些情况下，可能需要使用前向声明，需要特别注意类和方法声明的顺序，以正确地组合友元。
嵌套类是在其他类中声明的类，它有助于设计这样的助手类，即实现其他类，但不必是公有接口的组成部分。
C++异常机制为处理拙劣的编程事件，如不适当的值、I/O失败等，提供了一种灵活的方式。
引发异常将终止当前执行的函数，将控制权传给匹配的catch块。catch块紧跟在try块的后面，
为捕获异常，直接或间接导致异常的函数调用必须位于try块中。这样程序将执行catch块中的代码。
这些代码试图解决问题或终止程序。类可以包含嵌套的异常类，嵌套异常类在相应的问题被检查到时将被引发。
函数可以包含异常规范，指出在该函数中可能引发的异常：但C++11摒弃了这项功能。
未被捕获的异常（没有匹配的catch块的异常）在默认情况下将终止程序，意外异常（不与任何异常规范匹配的异常）也是如此。
RTTI（运行阶段类型信息）特性让程序能够检测对象的类型。
dynamic_cast运算符用于将派生类指针转换为基类指针，其主要用途是确保可以安全地调用虚函数。
Typeid 运算符返回一个type_info 对象。可以对两个typeid的返回值进行比较，以确定对象是否为特定的类型，而返回的type_jinfo 对象可用于获得关于对象的信息。
与通用转换机制相比，dynamic__cast、static_cast、const__cast 和reinterpret_cast提供了更安全、更明确的类型转换。
1.下面建立友元的尝试有什么错误？
a.class snap{
friend clasp；改为friend class clasp;
};
class clasp{...}；

b.
增加前向声明
class muff;

class cuff{
public:
    void snip (muff&) {...}
};
class muff{
friend void cuff::snip (muff&);
};

c.
把cuff类声明在muff类之前，同时在cuff类声明之前增加一个前向声明
class muff;

class cuff{
public:
    void snip (muff &) {...}
};
class muff{
friend void cuff::snip (muff&);
};

2.您知道了如何建立相互类友元的方法。能够创建一种更为严格的友情关系，
即类B只有部分成员是类A的友元，而类A只有部分成员是类B的友元吗？请解释原因。
不能
为使类A拥有一个本身为类B的成员函数的友元，B的声明必须位于A的声明之前。
一个前向声明是不够的，因为这种声明可以告诉A：B是一个类；但它不能指出类成员的名称。
同样，如果B拥有一个本身是A的成员函数的友元，则A的这个声明必须位于B的声明之前。这两个要求是互斥的。

3.下面的嵌套类声明中可能存在什么问题？
class Ribs
{
private:
    class Sauce
    {
        int soy;
        int sugar;
     public:
        Sauce (int s1, int s2) : soy (s1), sugar (s2) {}
    };
    ...
}；
成员soy 和sugar在默认情况下是私有的。
类Sauce的唯一公有方法是构造函数，这意味着只能调用构造函数来创建一个Sauce对象，不能进行其他操作。

4.throw 和return之间的区别何在？
假设函数f1调用函数f2。函数f2中的返回语句导致返回后程序继续执行在函数f1中调用函数f2后面的一条语句。
throw语句导致程序沿函数调用的当前序列回溯，直到找到直接或间接包含对函数f2的调用的try语句块为止。
它可能在f1中、调用函数f1的函数中或其他函数中。找到这样的try语句块后，将执行下一个匹配的catch语句块，
而不是函数调用后的语句。

5.假设有一个从异常基类派生来的异常类层次结构，则应按什么样的顺序放置catch 块？
应按从子孙到祖先的顺序排列catch语句块。

6.对于本章定义的Grand、Superb 和Magnificent 类，假设pg为Grand*指针，
并将其中某个类的对象的地址赋给了它，而ps为Superb*指针，则下面两个代码示例的行为有什么不同？
if ( ps = dynamic_cast<Superb*>(pg) )
{
    ps->say();
}
if ( typeid(*pg) == typeid(Superb) )
{
    ( (Superb *) pg)->say();
}
对于示例1，如果pg指向一个Superb对象或从Superb派生而来的任何类的对象，则if条件为true。
具体地说，如果pg指向Magnificent对象，则if条件也为true。
对于示例2，仅当指向Superb对象时，if条件才为true，如果指向的是从Superb派生出来的对象，则if条件不为true。

7.static_cast运算符与dynamic_cast 运算符有什么不同？
static_cast主要用于非多态类型之间的转换，不提供运行时的检查来确保转换的安全性。主要在以下几种场合中使用：
用于类层次结构中，基类和子类之间指针和引用的转换；
当进行上行转换，也就是把子类的指针或引用转换成父类表示，这种转换是安全的；
当进行下行转换，也就是把父类的指针或引用转换成子类表示，这种转换是不安全的，也需要程序员来保证；
用于基本数据类型之间的转换，如把int转换成char，把int转换成enum等等，这种转换的安全性需要程序员来保证；
把void指针转换成目标类型的指针，这种转换是不安全的；
dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。
在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；
在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。
在多态类型（基类包含虚函数）之间的转换主要使用dynamic_cast，因为类型提供了运行时信息。
如果expression是type-id的基类，使用dynamic_cast进行转换时，
在运行时就会检查expression是否真正的指向一个type-id类型的对象，
如果是，则能进行正确的转换，获得对应的值；否则返回空指针，如果是引用，则在运行时就会抛出异常。

15.8编程练习
1.对Tv和Remote类做如下修改：
a.让它们互为友元；
b.在Remote类中添加一个状态变量成员，该成员描述遥控器是处于常规模式还是互动模式；
c.在Remote中添加一个显示模式的方法；
d.在Tv类中添加一个对Remote中新成员进行切换的方法，该方法应仅当TV处于打开状态时才能运行。
编写一个小程序来测试这些新特性。
tv2.h
#ifndef TV2_H_
#define TV2_H_

class Remote;

class Tv
{
public:
    friend class Remote;
    enum { Off, On };
    enum { MinVal, MaxVal = 20 };
    enum { Antenna, Cable };
    enum { TV, DVD };

    Tv(int s = Off, int mc = 125) : state(s), volume(5), maxchannel(mc), channel(2), mode(Cable), input(TV) {}
    void onoff()
    {
        state = (state == On) ? Off : On;
    }
    bool ison() const
    {
        return state == On;
    }
    bool volup();
    bool voldown();
    void chanup();
    void chandown();
    void set_mode()
    {
        mode = (mode == Antenna) ? Cable : Antenna;
    }
    void set_input()
    {
        input = (input == TV) ? DVD : TV;
    }
    void settings() const;
    void toggleRemoteMode(Remote &r);
private:
    int state;
    int volume;
    int maxchannel;
    int channel;
    int mode;
    int input;
};

class Remote
{
private:
    int mode_d;
    int mode_i;
public:
    friend class Tv;
    enum { Normal, Interactive };
    void settings() const;
    Remote(int md = Tv::TV, int mi = Normal) : mode_d(md), mode_i(mi) {}
    bool volup(Tv &t)
    {
        return t.volup();
    }
    bool voldown(Tv &t)
    {
        return t.voldown();
    }
    void onoff(Tv &t)
    {
        t.onoff();
    }
    void chanup(Tv &t)
    {
        t.chanup();
    }
    void chandown(Tv &t)
    {
        t.chandown();
    }
    void set_chan(Tv &t, int c)
    {
        t.channel = c;
    }
    void set_mode(Tv &t)
    {
        t.set_mode();
    }
    void set_input(Tv &t)
    {
        t.set_input();
    }
};

#endif

tv2.cpp
#include <iostream>
#include "tv2.h"

bool Tv::volup()
{
    if (volume < MaxVal)
    {
        volume++;
        return true;
    }
    else
    {
        return false;
    }
}

bool Tv::voldown()
{
    if (volume > MinVal)
    {
        volume--;
        return true;
    }
    else
    {
        return false;
    }
}

void Tv::chanup()
{
    if (channel < maxchannel)
    {
        channel++;
    }
    else
    {
        channel = 1;
    }
}

void Tv::chandown()
{
    if (channel > 1)
    {
        channel--;
    }
    else
    {
        channel = maxchannel;
    }
}

void Tv::settings() const
{
    std::cout << "TV is " << (state == Off ? "Off" : "On") << std::endl;

    if (state == On)
    {
        std::cout << "Volume setting = " << volume << std::endl;
        std::cout << "Channel setting = " << channel << std::endl;
        std::cout << "Mode = " << (mode == Antenna ? "antenna" : "cable") << std::endl;
        std::cout << "Input = " << (input == TV ? "TV" : "DVD") << std::endl;
    }
}

void Tv::toggleRemoteMode(Remote &r)
{
    if (On == state && r.mode_i == Remote::Interactive)
    {
        r.mode_i = Remote::Normal;
    }
    else if (On == state && r.mode_i == Remote::Normal)
    {
        r.mode_i = Remote::Interactive;
    }
    else
    {
        return;
    }
}
void Remote::settings() const
{
    std::cout << "Remote is set to the " << (mode_d == Tv::TV ? "TV" : "VCR");
    std::cout << " and is in ";
    std::cout << (mode_i == Normal ? "Normal" : "Interactive") << " mode" << std::endl;
}

ch15_p01.cpp
#include <iostream>
#include "tv2.h"

int main()
{
    Tv tv;
    Remote remote;

    tv.onoff();
    std::cout << "Here are our original settings: " << std::endl;
    tv.settings();
    remote.settings();
    std::cout << std::endl;

    tv.toggleRemoteMode(remote);
    std::cout << "These are our new settings:" << std::endl;
    tv.settings();
    remote.settings();
    std::cout << std::endl;

    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Here are our original settings:
TV is On
Volume setting = 5
Channel setting = 2
Mode = cable
Input = TV
Remote is set to the TV and is in Normal mode

These are our new settings:
TV is On
Volume setting = 5
Channel setting = 2
Mode = cable
Input = TV
Remote is set to the TV and is in Interactive mode

Done.

2.修改程序清单15.11，使两种异常类型都是从头文件<stdexcept>提供的logic_error类派生出来的类。
让每个what方法都报告函数名和问题的性质。异常对象不用存储错误的参数值，而只需支持what方法。
ch15_p02.cpp
#include <iostream>
#include <stdexcept>
#include <cmath>

class bad_hmean : public std::logic_error
{
public:
    bad_hmean(const std::string &s = "hmean(a, b) invalid arguments: a = -b\n") : std::logic_error(s) {}
};

class bad_gmean : public std::logic_error
{
public:
    bad_gmean(const std::string &s = "gmean(a, b) arguments should be >= 0\n") : std::logic_error(s) {}
};

double hmean(double a, double b);
double gmean(double a, double b);

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;

    double x, y, z;

    cout << "Enter two numbers <q to quit>: ";
    while (cin >> x && cin >> y)
    {
        try
        {
            z = hmean(x, y);
            cout << "Harmonic mean of " << x << " and " << y
                 << " is " << z << endl;
            z = gmean(x, y);
            cout << "Geometric mean of " << x << " and " << y
                 << " is " << z << endl;
            cout << "Enter two numbers <q to quit>: ";
        }
        catch (bad_hmean &bg)
        {
            cout << bg.what();
            cout << "Enter two numbers <q to quit>: ";
            continue;
        }
        catch (bad_gmean &hg)
        {
            cout << hg.what();
            std::cout << "Sorry, you don't get to play any more.\n";
            break;
        }
    }
    cout << "Done.\n";

    return 0;
}

double hmean(double a, double b)
{
    if (a == -b)
    {
        throw bad_hmean();
    }
    return (2.0 * a * b) / (a + b);
}

double gmean(double a, double b)
{
    if (a < 0 || b < 0)
    {
        throw bad_gmean();
    }
    return std::sqrt(a * b);
}
显示结果如下
Enter two numbers <q to quit>: 2 5
Harmonic mean of 2 and 5 is 2.85714
Geometric mean of 2 and 5 is 3.16228
Enter two numbers <q to quit>: 3 5
Harmonic mean of 3 and 5 is 3.75
Geometric mean of 3 and 5 is 3.87298
Enter two numbers <q to quit>: 3 -3
hmean(a, b) invalid arguments: a = -b
Enter two numbers <q to quit>: 5 3
Harmonic mean of 5 and 3 is 3.75
Geometric mean of 5 and 3 is 3.87298
Enter two numbers <q to quit>: 5 -3
Harmonic mean of 5 and -3 is -15
gmean(a, b) arguments should be >= 0
Sorry, you don't get to play any more.
Done.

3.这个练习与编程练习2相同，但异常类是从一个这样的基类派生而来的：它是丛logic error派生而来的，并存储两个参数值。
异常类应该有一个这样的方法：报告这些值以及函数名。
程序使用一个catch块来捕获基类异常，其中任何一种从该基类异常派生而来的异常都将导致循环结束。
ch15_p03.cpp
#include <iostream>
#include <stdexcept>
#include <typeinfo>
#include <cmath>

double hmean(double a, double b);
double gmean(double a, double b);

class bad_hmean : public std::invalid_argument
{
private:
    int arg1;
    int arg2;
public:
    bad_hmean(int a, int b, const std::string &s = "hmean(a, b) invalid arguments: a = -b\n") : std::invalid_argument(s), arg1(a), arg2(b) {}
    void display() const;
};

void bad_hmean::display() const
{
    std::cout << "For function hmean(a, b), a != -b" << std::endl;
    std::cout << "You entered a = " << arg1 << ", b = " << arg2 << std::endl;
}
class bad_gmean : public std::domain_error
{
private:
    int arg1;
    int arg2;
public:
    bad_gmean(int a, int b, const std::string &s = "gmean(a, b) arguments should be >= 0\n") : std::domain_error(s), arg1(a), arg2(b) {}
    void display() const;
};
void bad_gmean::display() const
{
    std::cout << "For function gmean(a, b), a >= 0 and b >= 0" << std::endl;
    std::cout << "You entered a = " << arg1 << ", b = " << arg2 << std::endl;
}

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;

    double x, y, z;

    cout << "Enter two numbers <q to quit>: ";
    while (cin >> x && cin >> y)
    {
        try
        {
            z = hmean(x, y);
            cout << "Harmonic mean of " << x << " and " << y
                 << " is " << z << endl;
            z = gmean(x, y);
            cout << "Geometric mean of " << x << " and " << y
                 << " is " << z << endl;
            cout << "Enter two numbers <q to quit>: ";
        }
        catch (std::exception &e)
        {
            if (typeid(bad_hmean &) == typeid(e))
            {
                bad_hmean &bhm = dynamic_cast<bad_hmean &>(e);
                bhm.display();
            }
            else if(typeid(bad_gmean &) == typeid(e))
            {
                bad_gmean &bgm = dynamic_cast<bad_gmean &>(e);
                bgm.display();
            }
            cout << "Sorry, you don't get to play any more.\n";
            break;
        }
    }
    cout << "Done.\n";

    return 0;
}

double hmean(double a, double b)
{
    if (a == -b)
    {
        throw bad_hmean(a, b);
    }
    return (2.0 * a * b) / (a + b);
}

double gmean(double a, double b)
{
    if (a < 0 || b < 0)
    {
        throw bad_gmean(a, b);
    }
    return std::sqrt(a * b);
}
显示结果如下
Enter two numbers <q to quit>: 2 5
Harmonic mean of 2 and 5 is 2.85714
Geometric mean of 2 and 5 is 3.16228
Enter two numbers <q to quit>: 3 5
Harmonic mean of 3 and 5 is 3.75
Geometric mean of 3 and 5 is 3.87298
Enter two numbers <q to quit>: 3 -3
For function hmean(a, b), a != -b
You entered a = 3, b = -3
Sorry, you don't get to play any more.
Done.

Enter two numbers <q to quit>: 5 3
Harmonic mean of 5 and 3 is 3.75
Geometric mean of 5 and 3 is 3.87298
Enter two numbers <q to quit>: 5 -3
Harmonic mean of 5 and -3 is -15
For function gmean(a, b), a >= 0 and b >= 0
You entered a = 5, b = -3
Sorry, you don't get to play any more.
Done.

4.程序清单15.16在每个try后面都使用两个catch块，以确保nbad_index异常导致方法label_val被调用。
请修改该程序，在每个try块后面只使用一个catch块，并使用RTTI来确保合适时调用label_val。
ch15_p04.cpp
#include <iostream>
#include <typeinfo>
#include "sales2.h"

int main()
{
    double vals1[12] =
    {
        1220, 1100, 1122, 2212, 1232, 2334,
        2884, 2393, 3302, 2922, 3002, 3544
    };

    double vals2[12] =
    {
        12, 11, 22, 21, 32, 34,
        28, 29, 33, 29, 32, 35
    };

    Sales sales1(2004, vals1, 12);
    LabeledSales sales2("Blogstar", 2005, vals2, 12 );

    std::cout << "First try block:\n";
    try
    {
        std::cout << "Year = " << sales1.Year() << std::endl;
        for (int i = 0; i < 12; ++i)
        {
            std::cout << sales1[i] << ' ';

            if (i % 6 == 5)
            {
                std::cout << std::endl;
            }
        }
        std::cout << "Year = " << sales2.Year() << std::endl;
        std::cout << "Label = " << sales2.Label() << std::endl;

        for (int i = 0; i <= 12; ++i)
        {
            std::cout << sales2[i] << ' ';

            if (i % 6 == 5)
            {
                std::cout << std::endl;
            }
        }
        std::cout << "End of try block 1.\n";
    }
    catch(Sales::bad_index &bad)
    {
        std::cout << bad.what();

        if(typeid(LabeledSales::nbad_index &) == typeid(bad))
        {
            LabeledSales::nbad_index &nbi = dynamic_cast<LabeledSales::nbad_index &>(bad);
            std::cout << "Company: " << nbi.label_val() << std::endl;
        }
        std::cout << "bad index: " << bad.bi_val() << std::endl;
    }
    std::cout << "\nNext try block:\n";

    try
    {
        sales2[2] = 37.5;
        sales1[20] = 23345;
        std::cout << "End of try block 2.\n";
    }
    catch(Sales::bad_index &bad)
    {
        std::cout << bad.what();

        if ( typeid(LabeledSales::nbad_index &) == typeid(bad) )
        {
            LabeledSales::nbad_index &nbi = dynamic_cast<LabeledSales::nbad_index &>(bad);
            std::cout << "Company: " << nbi.label_val() << std::endl;
        }
        std::cout << "bad index: " << bad.bi_val() << std::endl;
    }
    std::cout << "Done.\n";

    return 0;
}
显示结果如下
First try block:
Year = 2004
1220 1100 1122 2212 1232 2334
2884 2393 3302 2922 3002 3544
Year = 2005
Label = Blogstar
12 11 22 21 32 34
28 29 33 29 32 35
Index error in LabeledSales object
Company: Blogstar
bad index: 12

Next try block:
Index error in Sales object
bad index: 20
Done.

第16章 string类和标准模板库
16.1 string类
16.1.1 构造字符串
16.1.2 string类输入
16.1.3 使用字符串
16.1.4 string还提供了哪些功能
16.1.5 字符串种类
16.2 智能指针模板类
16.2.1 使用智能指针
16.2.2 有关智能指针的注意事项
16.2.3 unique_ptr为何优于auto_ptr
16.2.4 选择智能指针
16.3 标准模板库
16.3.1 模板类vector
16.3.2 可对vector执行的操作
16.3.3 可对vector执行的其他操作
16.3.4 基于范围的for循环（C++11）
16.4 泛型编程
16.4.1 为何使用迭代器
16.4.2 迭代器类型
16.4.3 迭代器层次结构
16.4.4 概念、改进和模型
16.4.5 容器种类
16.4.6 关联容器
16.4.7 无序关联容器（C++11）.
16.5 函数对象
16.5.1 函数符概念
16.5.2 预定义的函数符
16.5.3 自适应函数符和函数适配器.
16.6 算法
16.6.1 算法组
16.6.2 算法的通用特征
16.6.3 STL和string类
16.6.4 函数和容器方法
16.6.5 使用STL
16.7 其他库
16.7.1 vector、valarray和array
16.7.2 模板initializer_list（C++11）
16.7.3 使用initializer_list
16.8 总结
16.9 复习题
16.10 编程练习
本章内容包括：
标准C++ string类。
模板 auto_ptr、unique_ptr和shared_ptr。
标准模板库（STL）。
容器类。
迭代器。
函数对象（functor）。
STL算法。
模板 initializer_list。
程序清单16.1 str1.cpp
#include <iostream>
#include <string>

int main()
{
    using namespace std;
    string one("Lottery Winner!");
    cout << one << endl;
    string two(20, '$');
    cout << two << endl;
    string three(one);
    cout << three << endl;
    one += " Oops!";
    cout << one << endl;
    two = "Sorry! That was ";
    three[0] = 'P';
    string four;
    four = two + three;
    cout << four << endl;
    char alls[] = "All's well that ends well";
    string five(alls, 20);
    cout << five << "!\n";
    string six(alls + 6, alls + 10);
    cout << six << ", ";
    string seven(&five[6], &five[10]);
    cout << seven << "...\n";
    string eight(four, 7, 16);
    cout << eight << " in motion!" << endl;

    return 0;
}
显示结果如下
Lottery Winner!
$$$$$$$$$$$$$$$$$$$$
Lottery Winner!
Lottery Winner! Oops!
Sorry! That was Pottery Winner!
All's well that ends!
well, well...
That was Pottery in motion!

程序清单16.2 strfile.cpp
#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>

int main()
{
    using namespace std;
    ifstream fin;
    fin.open("strfile.txt");
    if (fin.is_open() == false)
    {
        cerr << "Can't open file. Bye.\n";
        exit(EXIT_FAILURE);
    }
    string item;
    int count = 0;

    getline(fin, item, ':');
    while (fin)
    {
        ++count;
        cout << count << ": " << item << endl;
        getline(fin, item, ':');
    }
    cout << "Done.\n";
    fin.close();

    return 0;
}
显示结果如下
1: Peter Smith
2: Mike Pence
3: Hello World
4: Apple
5: Orange
6: Egg
Done.

cat strfile.txt
Peter Smith:Mike Pence:Hello World:Apple:Orange:Egg

注意，将 : 指定为分界字符后，换行符将被视为常规字符。
string::npos是字符串可存储的最大字符数，通常是无符号int或无符号long的最大取值。
程序清单16.3 hangman.cpp
#include <iostream>
#include <string>
#include <cstdlib>
#include <ctime>
#include <cctype>

using std::string;

const int NUM = 26;

const string wordlist[NUM] =
{
    "apiary", "beetle", "cereal",
    "danger", "ensign", "florid", "garage", "health", "insult",
    "jackal", "keeper", "loaner", "manage", "nonce", "onset",
    "plaid", "quilt", "remote", "stolid", "train", "useful",
    "valid", "whence", "xenon", "yearn", "zippy"
};

int main()
{
    using std::cout;
    using std::cin;
    using std::tolower;
    using std::endl;

    std::srand(std::time(nullptr));
    char play;
    cout << "Will you play a word game? <y/n> ";
    cin >> play;
    while (cin.get() != '\n')
    {
        continue;
    }
    play = tolower(play);
    while (play == 'y')
    {
        string target = wordlist[std::rand() % NUM];
        int length = target.length();
        string attempt(length, '-');
        string badchars;
        int guesses = 6;
        cout << "Guess my secret word. It has " << length
             << " letters, and you guess\n"
             << "one letter at a time. You get " << guesses
             << " wrong guesses.\n";
        cout << "Your word: " << attempt << endl;
        while (guesses > 0 && attempt != target)
        {
            char letter;
            cout << "Guess a letter: ";
            cin >> letter;
            while (cin.get() != '\n')
            {
                continue;
            }
            if (badchars.find(letter) != string::npos || attempt.find(letter) != string::npos)
            {
                cout << "You already guessed that. Try again.\n";
                continue;
            }
            int loc = target.find(letter);
            if (loc == string::npos)
            {
                cout << "Oh, bad guess!\n";
                --guesses;
                badchars += letter;
            }
            else
            {
                cout << "Good guess!\n";
                attempt[loc] = letter;
                loc = target.find(letter, loc + 1);
                while (loc != string::npos)
                {
                    attempt[loc] = letter;
                    loc = target.find(letter, loc + 1);
                }
            }
            cout << "Your word: " << attempt << endl;
            if (attempt != target)
            {
                if (badchars.length() > 0)
                {
                    cout << "Bad choices: " << badchars << endl;
                }
                cout << guesses << " bad guesses left\n";
            }
        }
        if (guesses > 0)
        {
            cout << "That's right!\n";
        }
        else
        {
            cout << "Sorry, the word is " << target << ".\n";
        }

        cout << "Will you play another? <y/n> ";
        cin >> play;
        while (cin.get() != '\n')
        {
            continue;
        }
        play = tolower(play);
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Will you play a word game? <y/n> y
Guess my secret word. It has 5 letters, and you guess
one letter at a time. You get 6 wrong guesses.
Your word: -----
Guess a letter: v
Oh, bad guess!
Your word: -----
Bad choices: v
5 bad guesses left
Guess a letter: p
Oh, bad guess!
Your word: -----
Bad choices: vp
4 bad guesses left
Guess a letter: x
Oh, bad guess!
Your word: -----
Bad choices: vpx
3 bad guesses left
Guess a letter: y
Oh, bad guess!
Your word: -----
Bad choices: vpxy
2 bad guesses left
Guess a letter: z
Oh, bad guess!
Your word: -----
Bad choices: vpxyz
1 bad guesses left
Guess a letter: q
Oh, bad guess!
Your word: -----
Bad choices: vpxyzq
0 bad guesses left
Sorry, the word is nonce.
Will you play another? <y/n> y
Guess my secret word. It has 5 letters, and you guess
one letter at a time. You get 6 wrong guesses.
Your word: -----
Guess a letter: n
Oh, bad guess!
Your word: -----
Bad choices: n
5 bad guesses left
Guess a letter: o
Oh, bad guess!
Your word: -----
Bad choices: no
4 bad guesses left
Guess a letter: p
Good guess!
Your word: p----
Bad choices: no
4 bad guesses left
Guess a letter: l
Good guess!
Your word: pl---
Bad choices: no
4 bad guesses left
Guess a letter: a
Good guess!
Your word: pla--
Bad choices: no
4 bad guesses left
Guess a letter: i
Good guess!
Your word: plai-
Bad choices: no
4 bad guesses left
Guess a letter: d
Good guess!
Your word: plaid
That's right!
Will you play another? <y/n> n
Done.

程序清单16.4 str2.cpp
#include <iostream>
#include <string>

int main()
{
    using namespace std;
    string empty;
    string small = "bit";
    string larger = "Elephants are a girl's best friend";
    cout << "Sizes:\n";
    cout << "\tempty: " << empty.size() << endl;
    cout << "\tsmall: " << small.size() << endl;
    cout << "\tlarger: " << larger.size() << endl;
    cout << "Capacities:\n";
    cout << "\tempty: " << empty.capacity() << endl;
    cout << "\tsmall: " << small.capacity() << endl;
    cout << "\tlarger: " << larger.capacity() << endl;
    empty.reserve(50);
    cout << "Capacity after empty.reserve(50): " << empty.capacity() << endl;

    return 0;
}
显示结果如下
Sizes:
        empty: 0
        small: 3
        larger: 34
Capacities:
        empty: 15
        small: 15
        larger: 34
Capacity after empty.reserve(50): 50

程序清单16.5 smrtptrs.cpp
#include <iostream>
#include <string>
#include <memory>

class Report
{
private:
    std::string str;
public:
    Report(const std::string s) : str(s)
    {
        std::cout << "Object of class Report created!\n";
    }
    ~Report()
    {
        std::cout << "Object of class Report deleted!\n";
    }
    void comment() const
    {
        std::cout << str << "\n";
    }
};

int main()
{
    {
        std::auto_ptr<Report> ps(new Report("using auto_ptr"));
        ps->comment();
    }
    {
        std::shared_ptr<Report> ps(new Report("using shared_ptr"));
        ps->comment();
    }
    {
        std::unique_ptr<Report> ps(new Report("using unique_ptr"));
        ps->comment();
    }

    return 0;
}
显示结果如下
Object of class Report created!
using auto_ptr
Object of class Report deleted!
Object of class Report created!
using shared_ptr
Object of class Report deleted!
Object of class Report created!
using unique_ptr
Object of class Report deleted!

程序清单16.6 fowl_ap.cpp
#include <iostream>
#include <string>
#include <memory>

int main()
{
    using namespace std;
    auto_ptr<string> films[5] =
    {
        auto_ptr<string>(new string("Fowl Balls")),
        auto_ptr<string>(new string("Duck Walks")),
        auto_ptr<string>(new string("Chicken Runs")),
        auto_ptr<string>(new string("Turkey Errors")),
        auto_ptr<string>(new string("Goose Eggs"))
    };
    auto_ptr<string> pwin;
    pwin = films[2];

    cout << "The nominees for best avian baseball film are\n";
    for (int i = 0; i < 5; i++)
    {
        cout << *films[i] << endl;
    }
    cout << "The winner is " << *pwin << "!\n";

    return 0;
}
显示结果如下
The nominees for best avian baseball film are
Fowl Balls
Duck Walks
Segmentation fault (core dumped)

fowl_sp.cpp
#include <iostream>
#include <string>
#include <memory>

int main()
{
    using namespace std;
    shared_ptr<string> films[5] =
    {
        shared_ptr<string>(new string("Fowl Balls")),
        shared_ptr<string>(new string("Duck Walks")),
        shared_ptr<string>(new string("Chicken Runs")),
        shared_ptr<string>(new string("Turkey Errors")),
        shared_ptr<string>(new string("Goose Eggs"))
    };
    shared_ptr<string> pwin;
    pwin = films[2];

    cout << "The nominees for best avian baseball film are\n";
    for (int i = 0; i < 5; i++)
    {
        cout << *films[i] << endl;
    }
    cout << "The winner is " << *pwin << "!\n";

    return 0;
}
显示结果如下
The nominees for best avian baseball film are
Fowl Balls
Duck Walks
Chicken Runs
Turkey Errors
Goose Eggs
The winner is Chicken Runs!

fowl_up.cpp
#include <iostream>
#include <string>
#include <memory>

int main()
{
    using namespace std;
    unique_ptr<string> films[5] =
    {
        unique_ptr<string>(new string("Fowl Balls")),
        unique_ptr<string>(new string("Duck Walks")),
        unique_ptr<string>(new string("Chicken Runs")),
        unique_ptr<string>(new string("Turkey Errors")),
        unique_ptr<string>(new string("Goose Eggs"))
    };
    unique_ptr<string> pwin;
    pwin = films[2];

    cout << "The nominees for best avian baseball film are\n";
    for (int i = 0; i < 5; i++)
    {
        cout << *films[i] << endl;
    }
    cout << "The winner is " << *pwin << "!\n";

    return 0;
}
编译命令如下
fowl_up.cpp: In function ‘int main()’:
fowl_up.cpp:17:19: error: use of deleted function ‘std::unique_ptr<_Tp, _Dp>& std::unique_ptr<_Tp, _Dp>::operator=(const std::unique_ptr<_Tp, _Dp>&) [with _Tp = std::__cxx11::basic_string<char>; _Dp = std::default_delete<std::__cxx11::basic_string<char> >]’
   17 |     pwin = films[2];
      |                   ^
In file included from /usr/include/c++/10.2.0/memory:83,
                 from fowl_up.cpp:3:
/usr/include/c++/10.2.0/bits/unique_ptr.h:469:19: note: declared here
  469 |       unique_ptr& operator=(const unique_ptr&) = delete;

unique_ptr代表的是专属所有权，即由 unique_ptr 管理的内存，只能被一个对象持有。
所以，unique_ptr 不支持复制和赋值，只支持移动。
如果想要把一个 unique_ptr 的内存交给另外一个 unique_ptr 对象管理。只能使用 std::move 转移当前对象的所有权。
转移之后，当前对象不再持有此内存，新的对象将获得专属所有权。
unique_ptr 在默认情况下和裸指针的大小是一样的。所以，内存上没有任何的额外消耗，性能是最优的。
shared_ptr 代表的是共享所有权，即多个 shared_ptr 可以共享同一块内存。
因此，shared_ptr 支持复制和赋值，也支持移动。
shared_ptr 内部是利用引用计数来实现内存的自动管理，每当复制一个 shared_ptr，引用计数会+1。
当一个 shared_ptr 离开作用域时，引用计数会-1。当引用计数为 0 的时候，则 delete 内存。
shared_ptr 的内存占用是裸指针的两倍。因为除了要管理一个裸指针外，还要维护一个引用计数。
因此相比于 unique_ptr, shared_ptr 的内存占用更高
考虑到线程安全问题，引用计数的增减必须是原子操作。而原子操作一般情况下都比非原子操作慢。
shared_ptr 在性能上固然是低于 unique_ptr。而通常情况，我们也可以尽量避免 shared_ptr 复制。
如果，一个 shared_ptr 需要将所有权共享给另外一个新的 shared_ptr，而我们确定在之后的代码中都不再使用这个 shared_ptr。
对于此种场景，我们尽量使用 std::move，将 shared_ptr 转移给新的对象。因为移动不用增加引用计数，性能比复制更好。
weak_ptr 是为了解决 shared_ptr 双向引用的问题。weak_ptr 不会增加引用计数，因此可以打破 shared_ptr 的循环引用。
成员函数lock返回shared_ptr对象，若对应内存已经删除，则shared_ptr对象==nullptr。
weak_ptr对象可以拷贝构造，拷贝构造出来的对象和原对象观察的是同一段内存。
成员函数reset可以解除对内存的观察，注意，是解除观察，并不会删除对应内存对象。

程序清单16.7 vector1.cpp
#include <iostream>
#include <string>
#include <vector>

const int NUM = 5;

int main()
{
    using std::vector;
    using std::string;
    using std::cin;
    using std::cout;
    using std::endl;

    vector<int> ratings(NUM);
    vector<string> titles(NUM);
    cout << "You will do exactly as told. You will enter\n"
         << NUM << " book titles and your ratings (0-10).\n";
    int i;
    for (i = 0; i < NUM; i++)
    {
        cout << "Enter title #" << i + 1 << ": ";
        std::getline(cin, titles[i], '\n');
        cout << "Enter your rating (0-10): ";
        cin >> ratings[i];
        cin.get();
    }
    cout << "Thank you. You entered the following:\n";
    cout << "Rating\tBook\n";
    for (i = 0; i < NUM; i++)
    {
        cout << ratings[i] << "\t" << titles[i] << endl;
    }

    return 0;
}
显示结果如下
You will do exactly as told. You will enter
5 book titles and your ratings (0-10).
Enter title #1: Mike Pence
Enter your rating (0-10): 3
Enter title #2: Peter Smith
Enter your rating (0-10): 5
Enter title #3: Hello World
Enter your rating (0-10): 2
Enter title #4: Apple
Enter your rating (0-10): 1
Enter title #5: Orange
Enter your rating (0-10): 6
Thank you. You entered the following:
Rating  Book
3       Mike Pence
5       Peter Smith
2       Hello World
1       Apple
6       Orange

程序清单16.8 vector2.cpp
#include <iostream>
#include <string>
#include <vector>

struct Review
{
    std::string title;
    int rating;
};

bool FillReview(Review &rr);
void ShowReview(const Review &rr);

int main()
{
    using std::cout;
    using std::vector;
    vector<Review> books;
    Review temp;
    while (FillReview(temp))
    {
        books.push_back(temp);
    }
    int num = books.size();
    if (num > 0)
    {
        cout << "Thank you. You entered the following:\n"
             << "Rating\tBook\n";
        for (int i = 0; i < num; i++)
        {
            ShowReview(books[i]);
        }
        cout << "Reprising:\n"
             << "Rating\tBook\n";
        vector<Review>::iterator pr;
        for (pr = books.begin(); pr != books.end(); pr++)
        {
            ShowReview(*pr);
        }
        vector <Review> oldlist(books);
        if (num > 3)
        {
            books.erase(books.begin() + 1, books.begin() + 3);
            cout << "After erasure:\n";
            for (pr = books.begin(); pr != books.end(); pr++)
            {
                ShowReview(*pr);
            }
            books.insert(books.begin(), oldlist.begin() + 1,
                         oldlist.begin() + 2);
            cout << "After insertion:\n";
            for (pr = books.begin(); pr != books.end(); pr++)
            {
                ShowReview(*pr);
            }
        }
        books.swap(oldlist);
        cout << "Swapping oldlist with books:\n";
        for (pr = books.begin(); pr != books.end(); pr++)
        {
            ShowReview(*pr);
        }
    }
    else
    {
        cout << "Nothing entered, nothing gained.\n";
    }

    return 0;
}
bool FillReview(Review &rr)
{
    std::cout << "Enter book title (quit to quit): ";
    std::getline(std::cin, rr.title, '\n');
    if (rr.title == "quit")
    {
        return false;
    }
    std::cout << "Enter book rating: ";
    std::cin >> rr.rating;
    if (!std::cin)
    {
        return false;
    }
    while (std::cin.get() != '\n')
    {
        continue;
    }
    return true;
}
void ShowReview(const Review &rr)
{
    std::cout << rr.rating << "\t" << rr.title << std::endl;
}
显示结果如下
Enter book title (quit to quit): Mike Pence
Enter book rating: 3
Enter book title (quit to quit): Peter Smith
Enter book rating: 5
Enter book title (quit to quit): Hello World
Enter book rating: 6
Enter book title (quit to quit): Apple
Enter book rating: 1
Enter book title (quit to quit): Orange
Enter book rating: 9
Enter book title (quit to quit): Egg
Enter book rating: 2
Enter book title (quit to quit): quit
Thank you. You entered the following:
Rating  Book
3       Mike Pence
5       Peter Smith
6       Hello World
1       Apple
9       Orange
2       Egg
Reprising:
Rating  Book
3       Mike Pence
5       Peter Smith
6       Hello World
1       Apple
9       Orange
2       Egg
After erasure:
3       Mike Pence
1       Apple
9       Orange
2       Egg
After insertion:
5       Peter Smith
3       Mike Pence
1       Apple
9       Orange
2       Egg
Swapping oldlist with books:
3       Mike Pence
5       Peter Smith
6       Hello World
1       Apple
9       Orange
2       Egg

程序清单16.9 vector3.cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

struct Review
{
    std::string title;
    int rating;
};

bool operator<(const Review &r1, const Review &r2);
bool worseThan(const Review &r1, const Review &r2);
bool FillReview(Review &rr);
void ShowReview(const Review &rr);

int main()
{
    using namespace std;

    vector<Review> books;
    Review temp;
    while (FillReview(temp))
    {
        books.push_back(temp);
    }
    if (books.size() > 0)
    {
        cout << "Thank you. You entered the following "
             << books.size() << " ratings:\n"
             << "Rating\tBook\n";
        for_each(books.begin(), books.end(), ShowReview);

        sort(books.begin(), books.end());
        cout << "Sorted by title:\nRating\tBook\n";
        for_each(books.begin(), books.end(), ShowReview);
        sort(books.begin(), books.end(), worseThan);
        cout << "Sorted by rating:\nRating\tBook\n";
        for_each(books.begin(), books.end(), ShowReview);
        random_shuffle(books.begin(), books.end());
        cout << "After shuffling:\nRating\tBook\n";
        for_each(books.begin(), books.end(), ShowReview);
    }
    else
    {
        cout << "No entries.\n";
    }
    cout << "Done.\n";

    return 0;
}
bool operator<(const Review &r1, const Review &r2)
{
    if (r1.title < r2.title)
    {
        return true;
    }
    else if (r1.title == r2.title && r1.rating < r2.rating)
    {
        return true;
    }
    else
    {
        return false;
    }
}
bool worseThan(const Review &r1, const Review &r2)
{
    if (r1.rating < r2.rating)
    {
        return true;
    }
    else
    {
        return false;
    }
}
bool FillReview(Review &rr)
{
    std::cout << "Enter book title (quit to quit): ";
    std::getline(std::cin, rr.title, '\n');
    if (rr.title == "quit")
    {
        return false;
    }
    std::cout << "Enter book rating: ";
    std::cin >> rr.rating;
    if (!std::cin)
    {
        return false;
    }
    while (std::cin.get() != '\n')
    {
        continue;
    }
    return true;
}

void ShowReview(const Review &rr)
{
    std::cout << rr.rating << "\t" << rr.title << std::endl;
}
显示结果如下
Enter book title (quit to quit): Mike Pence
Enter book rating: 3
Enter book title (quit to quit): Peter Smith
Enter book rating: 5
Enter book title (quit to quit): Hello World
Enter book rating: 6
Enter book title (quit to quit): Apple
Enter book rating: 1
Enter book title (quit to quit): Orange
Enter book rating: 9
Enter book title (quit to quit): Egg
Enter book rating: 2
Enter book title (quit to quit): quit
Thank you. You entered the following 6 ratings:
Rating  Book
3       Mike Pence
5       Peter Smith
6       Hello World
1       Apple
9       Orange
2       Egg
Sorted by title:
Rating  Book
1       Apple
2       Egg
6       Hello World
3       Mike Pence
9       Orange
5       Peter Smith
Sorted by rating:
Rating  Book
1       Apple
2       Egg
3       Mike Pence
5       Peter Smith
6       Hello World
9       Orange
After shuffling:
Rating  Book
6       Hello World
5       Peter Smith
2       Egg
3       Mike Pence
1       Apple
9       Orange
Done.

        for_each(books.begin(), books.end(), ShowReview);
可以替换为
for (auto x : books) {ShowReview(x);}
如果需要修改x，可以改成：
for (auto & x : books) {InflateReview(x);}

程序清单16.10 copyit.cpp
#include <iostream>
#include <iterator>
#include <vector>

int main()
{
    using namespace std;

    int casts[10] = { 6, 7, 2, 9, 4, 11, 8, 7, 10, 5 };
    vector<int> dice(10);
    copy(casts, casts + 10, dice.begin());
    cout << "Let the dice be cast!\n";
    ostream_iterator<int, char> out_iter(cout, " ");
    copy(dice.begin(), dice.end(), out_iter);
    cout << endl;
    cout << "Implicit use of reverse iterator.\n";
    copy(dice.rbegin(), dice.rend(), out_iter);
    cout << endl;
    cout << "Explicit use of reverse iterator.\n";
    vector<int>::reverse_iterator ri;
    for (auto ri = dice.rbegin(); ri != dice.rend(); ++ri)
    {
        cout << *ri << ' ';
    }
    cout << endl;

    return 0;
}
显示结果如下
Let the dice be cast!
6 7 2 9 4 11 8 7 10 5
Implicit use of reverse iterator.
5 10 7 8 11 4 9 2 7 6
Explicit use of reverse iterator.
5 10 7 8 11 4 9 2 7 6

程序清单16.11 inserts.cpp
#include <iostream>
#include <string>
#include <iterator>
#include <vector>
#include <algorithm>

void output(const std::string &s)
{
    std::cout << s << " ";
}

int main()
{
    using namespace std;
    string s1[4] = { "fine", "fish", "fashion", "fate" };
    string s2[2] = { "busy", "bats" };
    string s3[2] = { "silly", "singers" };
    vector<string> words(4);
    copy(s1, s1 + 4, words.begin());
    for_each(words.begin(), words.end(), output);
    cout << endl;

    copy(s2, s2 + 2, back_insert_iterator<vector<string> >(words));
    for_each(words.begin(), words.end(), output);
    cout << endl;

    copy(s3, s3 + 2, insert_iterator<vector<string> >(words, words.begin()));
    for_each(words.begin(), words.end(), output);
    cout << endl;

    return 0;
}
显示结果如下
fine fish fashion fate
fine fish fashion fate busy bats
silly singers fine fish fashion fate busy bats

程序清单16.12 list.cpp
#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>

void outint(int n)
{
    std::cout << n << " ";
}

int main()
{
    using namespace std;
    list<int> one(5, 2);
    int stuff[5] = { 1, 2, 4, 8, 6 };
    list<int> two;
    two.insert(two.begin(), stuff, stuff + 5);
    int more[6] = { 6, 4, 2, 4, 6, 5 };
    list<int> three(two);
    three.insert(three.end(), more, more + 6);

    cout << "List one: ";
    for_each(one.begin(), one.end(), outint);
    cout << endl << "List two: ";
    for_each(two.begin(), two.end(), outint);
    cout << endl << "List three: ";
    for_each(three.begin(), three.end(), outint);
    three.remove(2);
    cout << endl << "List three minus 2s: ";
    for_each(three.begin(), three.end(), outint);
    three.splice(three.begin(), one);
    cout << endl << "List three after splice: ";
    for_each(three.begin(), three.end(), outint);
    cout << endl << "List one: ";
    for_each(one.begin(), one.end(), outint);
    three.unique();
    cout << endl << "List three after unique: ";
    for_each(three.begin(), three.end(), outint);
    three.sort();
    three.unique();
    cout << endl << "List three after sort & unique: ";
    for_each(three.begin(), three.end(), outint);
    two.sort();
    three.merge(two);
    cout << endl << "Sorted two merged into three: ";
    for_each(three.begin(), three.end(), outint);
    cout << endl;

    return 0;
}
显示结果如下
List one: 2 2 2 2 2
List two: 1 2 4 8 6
List three: 1 2 4 8 6 6 4 2 4 6 5
List three minus 2s: 1 4 8 6 6 4 4 6 5
List three after splice: 2 2 2 2 2 1 4 8 6 6 4 4 6 5
List one:
List three after unique: 2 1 4 8 6 4 6 5
List three after sort & unique: 1 2 4 5 6 8
Sorted two merged into three: 1 1 2 2 4 4 5 6 6 8 8

程序清单16.13 setops.cpp
#include <iostream>
#include <string>
#include <set>
#include <algorithm>
#include <iterator>

int main()
{
    using namespace std;
    const int N = 6;
    string s1[N] = { "buffoon", "thinkers", "for", "heavy", "can", "for" };
    string s2[N] = { "metal", "any", "food", "elegant", "deliver", "for" };

    set<string> A(s1, s1 + N);
    set<string> B(s2, s2 + N);

    ostream_iterator<string, char> out(cout, " ");
    cout << "Set A: ";
    copy(A.begin(), A.end(), out);
    cout << endl;
    cout << "Set B: ";
    copy(B.begin(), B.end(), out);
    cout << endl;

    cout << "Union of A and B:\n";
    set_union(A.begin(), A.end(), B.begin(), B.end(), out);
    cout << endl;

    cout << "Intersection of A and B:\n";
    set_intersection(A.begin(), A.end(), B.begin(), B.end(), out);
    cout << endl;

    cout << "Difference of A and B:\n";
    set_difference(A.begin(), A.end(), B.begin(), B.end(), out);
    cout << endl;

    set<string> C;
    cout << "Set C:\n";
    set_union(A.begin(), A.end(), B.begin(), B.end(),
              insert_iterator<set<string> >(C, C.begin()));
    copy(C.begin(), C.end(), out);
    cout << endl;

    string s3("grungy");
    C.insert(s3);
    cout << "Set C after insertion:\n";
    copy(C.begin(), C.end(), out);
    cout << endl;

    cout << "Showing a range:\n";
    copy(C.lower_bound("ghost"), C.upper_bound("spook"), out);
    cout << endl;

    return 0;
}
显示结果如下
Set A: buffoon can for heavy thinkers
Set B: any deliver elegant food for metal
Union of A and B:
any buffoon can deliver elegant food for heavy metal thinkers
Intersection of A and B:
for
Difference of A and B:
buffoon can heavy thinkers
Set C:
any buffoon can deliver elegant food for heavy metal thinkers
Set C after insertion:
any buffoon can deliver elegant food for grungy heavy metal thinkers
Showing a range:
grungy heavy metal

程序清单16.14 multimap.cpp
#include <iostream>
#include <string>
#include <map>
#include <algorithm>

typedef int KeyType;
typedef std::pair<const KeyType, std::string> Pair;
typedef std::multimap<KeyType, std::string> MapCode;

int main()
{
    using namespace std;
    MapCode codes;

    codes.insert(Pair(415, "San Francisco"));
    codes.insert(Pair(510, "Oakland"));
    codes.insert(Pair(718, "Brooklyn"));
    codes.insert(Pair(718, "Staten Island"));
    codes.insert(Pair(415, "San Rafael"));
    codes.insert(Pair(510, "Berkeley"));

    cout << "Number of cities with area code 415: "
         << codes.count(415) << endl;
    cout << "Number of cities with area code 718: "
         << codes.count(718) << endl;
    cout << "Number of cities with area code 510: "
         << codes.count(510) << endl;
    cout << "Area Code   City\n";
    MapCode::iterator it;
    for (it = codes.begin(); it != codes.end(); ++it)
    {
        cout << "    " << (*it).first << "     "
             << (*it).second << endl;
    }

    auto range = codes.equal_range(718);
    cout << "Cities with area code 718:\n";
    for (it = range.first; it != range.second; ++it)
    {
        cout << (*it).second << endl;
    }

    return 0;
}
显示结果如下
Number of cities with area code 415: 2
Number of cities with area code 718: 2
Number of cities with area code 510: 2
Area Code   City
    415     San Francisco
    415     San Rafael
    510     Oakland
    510     Berkeley
    718     Brooklyn
    718     Staten Island
Cities with area code 718:
Brooklyn
Staten Island

程序清单16.15 functor.cpp
#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>

template<class T>
class TooBig
{
private:
    T cutoff;
public:
    TooBig(const T &t) : cutoff(t) {}
    bool operator()(const T &v)
    {
        return v > cutoff;
    }
};

void outint(int n)
{
    std::cout << n << " ";
}

int main()
{
    using std::list;
    using std::cout;
    using std::endl;
    using std::for_each;
    using std::remove_if;

    TooBig<int> f100(100);
    int vals[10] = { 50, 100, 90, 180, 60, 210, 415, 88, 188, 201 };
    list<int> yadayada(vals, vals + 10);
    list<int> etcetera(vals, vals + 10);

    cout << "Original lists:\n";
    for_each(yadayada.begin(), yadayada.end(), outint);
    cout << endl;
    for_each(etcetera.begin(), etcetera.end(), outint);
    cout << endl;
    yadayada.remove_if(f100);
    etcetera.remove_if(TooBig<int>(200));
    cout << "Trimmed lists:\n";
    for_each(yadayada.begin(), yadayada.end(), outint);
    cout << endl;
    for_each(etcetera.begin(), etcetera.end(), outint);
    cout << endl;

    return 0;
}
显示结果如下
Original lists:
50 100 90 180 60 210 415 88 188 201
50 100 90 180 60 210 415 88 188 201
Trimmed lists:
50 100 90 60 88
50 100 90 180 60 88 188

程序清单16.16 funadap.cpp
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>
#include <functional>

const int LIM = 6;

void Show(double);

int main()
{
    using namespace std;
    double arr1[LIM] = { 28, 29, 30, 35, 38, 59 };
    double arr2[LIM] = { 63, 65, 69, 75, 80, 99 };
    vector<double> gr8(arr1, arr1 + LIM);
    vector<double> m8(arr2, arr2 + LIM);
    cout.setf(ios_base::fixed);
    cout.precision(1);
    cout << "gr8:\t";
    for_each(gr8.begin(), gr8.end(), Show);
    cout << endl;
    cout << "m8:\t";
    for_each(m8.begin(), m8.end(), Show);
    cout << endl;

    vector<double> sum(LIM);
    transform(gr8.begin(), gr8.end(), m8.begin(), sum.begin(), plus<double>());
    cout << "sum:\t";
    for_each(sum.begin(), sum.end(), Show);
    cout << endl;

    vector<double> prod(LIM);
    transform(gr8.begin(), gr8.end(), prod.begin(), bind1st(multiplies<double>(), 2.5));
    cout << "prod:\t";
    for_each(prod.begin(), prod.end(), Show);
    cout << endl;

    return 0;
}

void Show(double v)
{
    std::cout.width(6);
    std::cout << v << ' ';
}
显示结果如下
gr8:      28.0   29.0   30.0   35.0   38.0   59.0
m8:       63.0   65.0   69.0   75.0   80.0   99.0
sum:      91.0   94.0   99.0  110.0  118.0  158.0
prod:     70.0   72.5   75.0   87.5   95.0  147.5


程序清单16.17 strgstl.cpp
#include <iostream>
#include <string>
#include <algorithm>

int main()
{
    using namespace std;
    string letters;

    cout << "Enter the letter grouping (quit to quit): ";
    while (cin >> letters && letters != "quit")
    {
        cout << "Permutations of " << letters << endl;
        sort(letters.begin(), letters.end());
        cout << letters << endl;
        while ( next_permutation( letters.begin(), letters.end() ) )
        {
            cout << letters << endl;
        }
        cout << "Enter next sequence (quit to quit): ";
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Enter the letter grouping (quit to quit): Water
Permutations of Water
Waert
Waetr
Waret
Warte
Water
Watre
Weart
Weatr
Werat
Werta
Wetar
Wetra
Wraet
Wrate
Wreat
Wreta
Wrtae
Wrtea
Wtaer
Wtare
Wtear
Wtera
Wtrae
Wtrea
aWert
aWetr
aWret
aWrte
aWter
aWtre
aeWrt
aeWtr
aerWt
aertW
aetWr
aetrW
arWet
arWte
areWt
aretW
artWe
arteW
atWer
atWre
ateWr
aterW
atrWe
atreW
eWart
eWatr
eWrat
eWrta
eWtar
eWtra
eaWrt
eaWtr
earWt
eartW
eatWr
eatrW
erWat
erWta
eraWt
eratW
ertWa
ertaW
etWar
etWra
etaWr
etarW
etrWa
etraW
rWaet
rWate
rWeat
rWeta
rWtae
rWtea
raWet
raWte
raeWt
raetW
ratWe
rateW
reWat
reWta
reaWt
reatW
retWa
retaW
rtWae
rtWea
rtaWe
rtaeW
rteWa
rteaW
tWaer
tWare
tWear
tWera
tWrae
tWrea
taWer
taWre
taeWr
taerW
tarWe
tareW
teWar
teWra
teaWr
tearW
terWa
teraW
trWae
trWea
traWe
traeW
treWa
treaW
Enter next sequence (quit to quit): quit
Done.

程序清单16.18 listrmv.cpp
#include <iostream>
#include <list>
#include <algorithm>

const int LIM = 10;

void Show(int);

int main()
{
    using namespace std;
    int ar[LIM] = { 4, 5, 4, 2, 2, 3, 4, 8, 1, 4 };
    list<int> la(ar, ar + LIM);
    list<int> lb(la);

    cout << "Original list contents:\n\t";
    for_each(la.begin(), la.end(), Show);
    cout << endl;
    la.remove(4);
    cout << "After using the remove() method:\n";
    cout << "la:\t";
    for_each(la.begin(), la.end(), Show);
    cout << endl;
    list<int>::iterator last;
    last = remove(lb.begin(), lb.end(), 4);
    cout << "After using the remove() function:\n";
    cout << "lb:\t";
    for_each(lb.begin(), lb.end(), Show);
    cout << endl;
    lb.erase(last, lb.end());
    cout << "After using the erase() method:\n";
    cout << "lb:\t";
    for_each(lb.begin(), lb.end(), Show);
    cout << endl;

    return 0;
}

void Show(int v)
{
    std::cout << v << ' ';
}
显示结果如下
Original list contents:
        4 5 4 2 2 3 4 8 1 4
After using the remove() method:
la:     5 2 2 3 8 1
After using the remove() function:
lb:     5 2 2 3 8 1 4 8 1 4
After using the erase() method:
lb:     5 2 2 3 8 1

程序清单16.19 usealgo.cpp
#include <iostream>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <iterator>
#include <algorithm>
#include <cctype>

using namespace std;

char toLower(char ch)
{
    return tolower(ch);
}
string &ToLower(string &st);
void display(const string &s);

int main()
{
    vector<string> words;
    cout << "Enter words (enter quit to quit):\n";
    string input;
    while (cin >> input && input != "quit")
    {
        words.push_back(input);
    }

    cout << "You entered the following words:\n";
    for_each(words.begin(), words.end(), display);
    cout << endl;

    set<string> wordset;
    transform(words.begin(), words.end(),
              insert_iterator<set<string> >(wordset, wordset.begin()),
              ToLower);
    cout << "\nAlphabetic list of words:\n";
    for_each(wordset.begin(), wordset.end(), display);
    cout << endl;

    map<string, int> wordmap;
    set<string>::iterator si;
    for (si = wordset.begin(); si != wordset.end(); si++)
    {
        wordmap[*si] = count(words.begin(), words.end(), *si);
    }

    cout << "\nWord frequency:\n";
    for (si = wordset.begin(); si != wordset.end(); si++)
    {
        cout << *si << ": " << wordmap[*si] << endl;
    }

    return 0;
}

string &ToLower(string &st)
{
    transform(st.begin(), st.end(), st.begin(), toLower);
    return st;
}

void display(const string &s)
{
    cout << s << " ";
}
显示结果如下
Enter words (enter quit to quit):
Apple
Orange
Egg
Water
Banana
Sun
Apple
Egg
Water
Sun
Water
World
Water
quit
You entered the following words:
Apple Orange Egg Water Banana Sun Apple Egg Water Sun Water World Water

Alphabetic list of words:
apple banana egg orange sun water world

Word frequency:
apple: 2
banana: 1
egg: 2
orange: 1
sun: 2
water: 4
world: 1

程序清单16.20 valvect.cpp
#include <iostream>
#include <valarray>
#include <vector>
#include <algorithm>

int main()
{
    using namespace std;
    vector<double> data;
    double temp;

    cout << "Enter numbers (<=0 to quit):\n";
    while (cin >> temp && temp > 0)
    {
        data.push_back(temp);
    }
    sort(data.begin(), data.end());
    int size = data.size();
    valarray<double> numbers(size);
    int i;
    for (i = 0; i < size; i++)
    {
        numbers[i] = data[i];
    }
    valarray<double> sq_rts(size);
    sq_rts = sqrt(numbers);
    valarray<double> results(size);
    results = numbers + 2.0 * sq_rts;
    cout.setf(ios_base::fixed);
    cout.precision(4);
    for (i = 0; i < size; i++)
    {
        cout.width(8);
        cout << numbers[i] << ": ";
        cout.width(8);
        cout << results[i] << endl;
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Enter numbers (<=0 to quit):
1 2 3 4 5 6 7 8 9 -1
  1.0000:   3.0000
  2.0000:   4.8284
  3.0000:   6.4641
  4.0000:   8.0000
  5.0000:   9.4721
  6.0000:  10.8990
  7.0000:  12.2915
  8.0000:  13.6569
  9.0000:  15.0000
Done.

程序清单16.21 vslice.cpp
#include <iostream>
#include <valarray>
#include <cstdlib>
#include <ctime>

const int SIZE = 12;
typedef std::valarray<int> vint;

void show(const vint &v, int cols);

int main()
{
    using std::slice;
    using std::cout;
    vint valint(SIZE);

    std::srand(std::time(nullptr));

    int i;
    for (i = 0; i < SIZE; ++i)
    {
        valint[i] = std::rand() % 10;
    }
    cout << "Original array:\n";
    show(valint, 3);
    vint vcol(valint[slice(1, 4, 3)]);
    cout << "Second column:\n";
    show(vcol, 1);
    vint vrow(valint[slice(3, 3, 1)]);
    cout << "Second row:\n";
    show(vrow, 3);
    valint[slice(2, 4, 3)] = 10;
    cout << "Set last column to 10:\n";
    show(valint, 3);
    cout << "Set first column to sum of next two:\n";
    valint[slice(0, 4, 3)] = vint(valint[slice(1, 4, 3)])
                             + vint(valint[slice(2, 4, 3)]);
    show(valint, 3);

    return 0;
}

void show(const vint &v, int cols)
{
    using std::cout;
    using std::endl;

    int lim = v.size();
    int i;
    for (i = 0; i < lim; ++i)
    {
        cout.width(3);
        cout << v[i];
        if (i % cols == cols - 1)
        {
            cout << endl;
        }
        else
        {
            cout << ' ';
        }
    }
    if (i % cols != 0)
    {
        cout << endl;
    }
}
显示结果如下
Original array:
  7   1   4
  2   2   5
  4   1   0
  0   1   2
Second column:
  1
  2
  1
  1
Second row:
  2   2   5
Set last column to 10:
  7   1  10
  2   2  10
  4   1  10
  0   1  10
Set first column to sum of next two:
 11   1  10
 12   2  10
 11   1  10
 11   1  10

程序清单16.22 ilist.cpp
#include <iostream>
#include <initializer_list>

double sum(std::initializer_list<double> il);
double average(const std::initializer_list<double> &ril);

int main()
{
    using std::cout;

    cout << "List 1: sum = " << sum({ 2, 3, 4 })
         << ", ave = " << average({ 2, 3, 4 }) << '\n';
    std::initializer_list<double> dl = { 1.1, 2.2, 3.3, 4.4, 5.5 };
    cout << "List 2: sum = " << sum(dl)
         << ", ave = " << average(dl) << '\n';
    dl = { 16.0, 25.0, 36.0, 40.0, 64.0 };
    cout << "List 3: sum = " << sum(dl)
         << ", ave = " << average(dl) << '\n';

    return 0;
}

double sum(std::initializer_list<double> il)
{
    double tot = 0;
    for (auto p = il.begin(); p != il.end(); p++)
    {
        tot += *p;
    }
    return tot;
}

double average(const std::initializer_list<double> &ril)
{
    double tot = 0;
    int n = ril.size();
    double ave = 0.0;

    if (n > 0)
    {
        for (auto p = ril.begin(); p != ril.end(); p++)
        {
            tot += *p;
        }
        ave = tot / n;
    }
    return ave;
}
显示结果如下
List 1: sum = 9, ave = 3
List 2: sum = 16.5, ave = 3.3
List 3: sum = 181, ave = 36.2

16.9复习题
1.考虑下面的类声明：
class RQ1
{
private:
    char * st;
public:
    RQ1() {st =new char[1];strcpy (st, "");}
    RQ1 (const char * s) { st =new char[strlen(s)+1]; strcpy(st, s);}
    RQ1 (const RQ1 & rq) { st =new char[strlen(rq.st)+1]; strcpy(st, rq.st);}
    ~RQ1() { delete [ ] st; }
    RQ & operator = (const RQ & rq);
};
将它转换为使用string对象的声明。哪些方法不再需要显式定义？
不再需要显式复制构造函数、析构程序和赋值运算符，因为string对象提供了自己的内存管理功能。

2.在易于使用方面，指出string对象至少两个优于C风格字符串的地方。
可以将一个string对象赋给另一个。string对象提供了自己的内存管理功能，所以一般不需要担心字符串超出存储容量。

3.编写一个函数，用string对象作为参数，将string对象转换为全部大写。
#include <string>
#include <cctype>

void ToUpper(std::string & str)
{
    for (int i = 0; i < str.size(); i++)
    {
        str[i] = std::toupper(str[i]);
    }
}
4.从概念上或语法上说，下面哪个不是正确使用auto_ptr的方法（假设已经包含了所需的头文件）？
auto_ptr<int> pia = new int[20];   // wrong, use with new, not new []
auto_ptr<string> (new string);   // wrong, no name for pointer
int rigue = 7;
auto_ptr<int> pr (&rigue);   // wrong, use with new, not variable
auto_ptr dbl = new double;   // wrong, auto_ptr<double>

5.如果可以生成一个存储高尔夫球棍（而不是数字）的栈，为何它（从概念上说）是一个坏的高尔夫袋子？
栈的特点是后入先出，每次只能从栈顶取数据。所以，要得到想要的数据，可能要先从栈顶取出很多其他数据。

6.为什么说对于逐洞记录高尔夫成绩来说，set容器是糟糕的选择？
set不允许键值重复，如果需要重复插入键值，可以使用multiset。

7.既然指针是一个迭代器，为什么STL设计人员没有简单地使用指针来代替迭代器呢？
使用迭代器能够遍历不以数组方式组织的数据，如双向链表中的数据。

8.为什么STL设计人员仅定义了迭代器基类，而使用继承来派生其他迭代器类型的类，并根据这些迭代器类来表示算法？
这样可以将STL函数用于指向常规数组的常规指针以及指向STL容器类的迭代器，提高了通用性。

9.给出vector对象比常规数组方便的3个例子。
可以将一个vector对象赋给另一个。vector管理自己的内存，因此可以将元素插入到矢量中，并让它自动调整长度。
使用at()方法，可以自动检查边界。

10.如果程序清单16.9是使用list（而不是vector）实现的，则该程序的哪些部分将是非法的？
非法部分能够轻松修复吗？如果可以，如何修复呢？
sort函数和random_shuffle函数要求随机访问迭代器，而list对象只有双向迭代器。可以使用list 模板类的sort成员函数，而不是通用函数来排序，
但没有与random_shuffle等效的成员函数。然而，可以将list复制到vector中，然后调用random_shuffle函数，并将结果重新复制到链表中。

11.假设有程序清单16.15所示的函数符TooBig，下面的代码有何功能？赋给bo的是什么值？
bool bo = TooBig<int>(10)(15);
15 > 10
bo = true

16.10编程练习
1.回文指的是顺读和逆读都一样的字符串。例如，“tot”和“otto”都是简短的回文。
编写一个程序，让用户输入字符串，并将字符串引用传递给一个bool函数。
如果字符串是回文，该函数将返回true，否则返回false。
#include <iostream>
#include <string>

bool isPalindrome(std::string &str);

int main()
{
    std::cout << "Enter a string: ";
    std::string str;
    std::getline(std::cin, str, '\n');

    if (isPalindrome(str))
    {
        std::cout << str << " is a palindrome" << std::endl;
    }
    else
    {
        std::cout << str << " is not a palindrome" << std::endl;
    }

    return 0;
}

bool isPalindrome(std::string &str)
{
    for (int i = 0, j = str.size() - 1; i < j; i++, j--)
    {
        if (str[i] != str[j])
        {
            return false;
        }
    }
    return true;
}
显示结果如下
Enter a string: aBBa
aBBa is a palindrome

Enter a string: Hello
Hello is not a palindrome

Enter a string: otto
otto is a palindrome

Enter a string: tot
tot is a palindrome

2.与编程练习1中给出的问题相同，但要考虑诸如大小写、空格和标点符号这样的复杂问题。
#include <iostream>
#include <string>
#include <cctype>

bool isPalindrome(std::string &str);

int main()
{
    std::cout << "Enter a string: ";
    std::string str;
    std::getline(std::cin, str, '\n');

    if (isPalindrome(str))
    {
        std::cout << str << " is a palindrome" << std::endl;
    }
    else
    {
        std::cout << str << " is not a palindrome" << std::endl;
    }

    return 0;
}

bool isPalindrome(std::string &str)
{
    std::string palind;
    for (int i = 0; i < str.size(); i++)
    {
        if (isalpha(str[i]))
        {
            palind.push_back(tolower(str[i]));
        }
    }

    for (int i = 0, j = palind.size() - 1; i < j; i++, j--)
    {
        if (palind[i] != palind[j])
        {
            return false;
        }
    }
    return true;
}
显示结果如下
Enter a string: Aba
Aba is a palindrome

Enter a string: cBa
cBa is not a palindrome

Enter a string: Toot
Toot is a palindrome

3.修改程序清单16.3，使之从文件中读取单词。一种方案是，使用vector<string>对象而不是string数组。
#include <iostream>
#include <string>
#include <cstdlib>
#include <ctime>
#include <cctype>
#include <fstream>
#include <vector>

int main()
{
    std::ifstream myfile("ch16_p03.txt");

    if (!myfile.good())
    {
        std::cout << "Unable to open Text.txt" << std::endl;
        exit(EXIT_FAILURE);
    }

    std::vector<std::string> wordlist;
    std::string word;
    while (myfile >> word)
    {
        wordlist.push_back(word);
    }
    myfile.close();

    long num = wordlist.size();

    std::srand(std::time(nullptr));

    char play;
    std::cout << "Will you play a word game? <y/n> ";
    std::cin >> play;
    while (std::cin.get() != '\n')
    {
        continue;
    }
    play = std::tolower(play);

    while (play == 'y')
    {
        std::string target = wordlist[std::rand() % num];
        int length = target.length();
        std::string attempt(length, '-');
        std::string badchars;
        int guesses = 6;

        std::cout << "Guess my secret word. It has " << length;
        std::cout << " letters, and you guess\n";
        std::cout << "one letter at a time. You get " << guesses;
        std::cout << " wrong guesses.\n";
        std::cout << "Your word: " << attempt << std::endl;

        while (guesses > 0 && attempt != target)
        {
            char letter;
            std::cout << "Guess a letter: ";
            std::cin >> letter;
            while (std::cin.get() != '\n')
            {
                continue;
            }
            if (badchars.find(letter) != std::string::npos || attempt.find(letter) != std::string::npos)
            {
                std::cout << "You already guessed that. Try again.\n";
                continue;
            }

            int loc = target.find(letter);
            if (loc == std::string::npos)
            {
                std::cout << "Oh, bad guess!\n";
                --guesses;
                badchars += letter;
            }
            else
            {
                std::cout << "Good guess!\n";
                attempt[loc] = letter;
                loc = target.find(letter, loc + 1);
                while (loc != std::string::npos)
                {
                    attempt[loc] = letter;
                    loc = target.find(letter, loc + 1);
                }
            }
            std::cout << "Your word: " << attempt << std::endl;
            if (attempt != target)
            {
                if (badchars.length() > 0)
                {
                    std::cout << "Bad choices: " << badchars << std::endl;
                }
                std::cout << guesses << " bad guesses left\n";
            }
        }
        if (guesses > 0)
        {
            std::cout << "That's right!\n";
        }
        else
        {
            std::cout << "Sorry, the word is " << target << ".\n";
        }

        std::cout << "Will you play another? <y/n> ";
        std::cin >> play;
        while (std::cin.get() != '\n')
        {
            continue;
        }
        play = std::tolower(play);
    }
    std::cout << "Done.\n";

    return 0;
}
显示结果如下
Will you play a word game? <y/n> y
Guess my secret word. It has 3 letters, and you guess
one letter at a time. You get 6 wrong guesses.
Your word: ---
Guess a letter: S
Good guess!
Your word: S--
6 bad guesses left
Guess a letter: u
Good guess!
Your word: Su-
6 bad guesses left
Guess a letter: n
Good guess!
Your word: Sun
That's right!
Will you play another? <y/n> y
Guess my secret word. It has 5 letters, and you guess
one letter at a time. You get 6 wrong guesses.
Your word: -----
Guess a letter: A
Oh, bad guess!
Your word: -----
Bad choices: A
5 bad guesses left
Guess a letter: W
Good guess!
Your word: W----
Bad choices: A
5 bad guesses left
Guess a letter: a
Good guess!
Your word: Wa---
Bad choices: A
5 bad guesses left
Guess a letter: t
Good guess!
Your word: Wat--
Bad choices: A
5 bad guesses left
Guess a letter: a
You already guessed that. Try again.
Guess a letter: b
Oh, bad guess!
Your word: Wat--
Bad choices: Ab
4 bad guesses left
Guess a letter: e
Good guess!
Your word: Wate-
Bad choices: Ab
4 bad guesses left
Guess a letter: r
Good guess!
Your word: Water
That's right!
Will you play another? <y/n> n
Done.

cat ch16_p03.txt
Apple Orange Egg Sun Water Food

4.编写一个具有老式风格接口的函数，其原型如下：
int reduce (long ar[], int n);
实参应是数组名和数组中的元素个数。该函数对数组进行排序，删除重复的值，返回缩减后数组中的元素数目。
请使用STL函数编写该函数（如果决定使用通用的unique（）函数，请注意它将返回结果区间的结尾）。使用一个小程序测试该函数。
#include <iostream>
#include <vector>
#include <algorithm>

const int SIZE = 15;

int reduce(long ar[], int n);

int main()
{

    std::cout << "Enter up to " << SIZE << " numbers (quit to quit):";

    long num = 0;
    long ar[SIZE];
    int i = 0;

    while (std::cin >> num && i < SIZE)
    {
        ar[i++] = num;
    }

    if (0 == i)
    {
        std::cout << "No values were entered" << std::endl;
        return 0;
    }

    std::cout << "You entered ";
    for (int j = 0; j < i; j++)
    {
        std::cout << ar[j] << " ";
    }
    std::cout << std::endl;

    std::cout << "Here's your sorted array, without duplicates: ";

    int j = reduce(ar, i);
    for (int k = 0; k < j; k++)
    {
        std::cout << ar[k] << " ";
    }
    std::cout << std::endl;

    return 0;
}

int reduce(long ar[], int n)
{
    std::vector<long> var;
    for (int i = 0; i < n; i++)
    {
        var.push_back(ar[i]);
    }

    sort(var.begin(), var.end());
    std::vector<long>::iterator end = unique(var.begin(), var.end());
    var.erase(end, var.end());
    std::vector<long>::iterator iv = var.begin();

    for (int i = 0; iv != var.end(); iv++, i++)
    {
        ar[i] = *iv;
    }
    return var.size();
}
显示结果如下
Enter up to 15 numbers (quit to quit):
1 3 5 7 9 1 2 3 5 6 7 8 q
You entered 1 3 5 7 9 1 2 3 5 6 7 8
Here's your sorted array, without duplicates: 1 2 3 5 6 7 8 9

5.问题与编程练习4相同，但要编写一个模板函数：
template <classT>
int reduce (T ar[], int n);
在一个使用long实例和string实例的小程序中测试该函数。
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <cctype>
#include <cstdlib>

const int SIZE = 15;

template <typename T>
int reduce(T ar[], int n);

template <>
int reduce<std::string>(std::string ar[], int n);

template <typename T>
int data_input(T ar[], int n);

template <>
int data_input<std::string>(std::string ar[], int n);

template <typename T>
void display(T ar[], int begin, int end);

bool string_compare(std::string s1, std::string s2);

int main()
{
    std::cout << "Would you like to enter strings or integers? "
              << "(s for strings, i for integers)" << std::endl;
    char ch;
    ch = std::cin.get();
    while (std::cin.get() != '\n')
    {
        continue;
    }
    ch = tolower(ch);
    if (ch != 's' && ch != 'i')
    {
        std::cout << "Input should be \"s\" or \"i\" (case insensitive)";
        std::cout << std::endl;
        std::cout << "Program abort" << std::endl;
        exit(EXIT_FAILURE);
    }

    if (ch == 's')
    {
        std::string sar[SIZE];
        int values = data_input(sar, SIZE);

        if (0 == values)
        {
            std::cout << "No values were entered" << std::endl;
            return 0;
        }

        std::cout << "You entered ";
        display(sar, 0, values);

        std::cout << "Here's your sorted array, without duplicates: \n";
        int j = reduce(sar, values);
        display(sar, 0, j);
    }
    else
    {
        long ar[SIZE];
        int values = data_input(ar, SIZE);

        if (0 == values)
        {
            std::cout << "No values were entered" << std::endl;
            return 0;
        }

        std::cout << "You entered ";
        display(ar, 0, values);

        std::cout << "Here's your sorted array, without duplicates: \n";
        int j = reduce(ar, values);
        display(ar, 0, j);
    }

    return 0;
}
template <typename T>
int reduce(T ar[], int n)
{
    typename std::vector<T> var;
    for (int i = 0; i < n; i++)
    {
        var.push_back(ar[i]);
    }

    sort(var.begin(), var.end());
    typename std::vector<T>::iterator end = unique(var.begin(), var.end());
    var.erase(end, var.end());
    typename std::vector<T>::iterator iv = var.begin();

    for (int i = 0; iv != var.end(); iv++, i++)
    {
        ar[i] = *iv;
    }
    return var.size();
}
template <>
int reduce<std::string>(std::string ar[], int n)
{
    std::vector<std::string> var;
    for (int i = 0; i < n; i++)
    {
        var.push_back(ar[i]);
    }

    sort(var.begin(), var.end(), string_compare);
    std::vector<std::string>::iterator end = unique(var.begin(), var.end());
    var.erase(end, var.end());
    std::vector<std::string>::iterator iv = var.begin();

    for (int i = 0; iv != var.end(); iv++, i++)
    {
        ar[i] = *iv;
    }
    return var.size();
}
template <typename T>
int data_input(T ar[], int n)
{
    std::cout << "Enter up to " << n << " values (quit to quit):";

    T value;
    int i = 0;

    while (std::cin >> value && i < n)
    {
        ar[i++] = value;
    }
    return i;
}
template <>
int data_input<std::string>(std::string ar[], int n)
{
    std::cout << "Enter up to " << n << " strings (quit to quit):";

    std::string value;
    int i = 0;

    while (std::cin >> value && i < n && value != "quit")
    {
        ar[i++] = value;
    }
    return i;
}
template <class T>
void display(T ar[], int begin, int end)
{
    for (int k = begin; k < end; k++)
    {
        std::cout << ar[k] << " ";
    }
    std::cout << std::endl;
}
bool string_compare(std::string s1, std::string s2)
{
    transform(s1.begin(), s1.end(), s1.begin(), ::tolower);
    transform(s2.begin(), s2.end(), s2.begin(), ::tolower);
    return s1 < s2;
}
显示结果如下
Would you like to enter strings or integers? (s for strings, i for integers)
i
Enter up to 15 values (quit to quit):
1 2 3 5 6 7 8 9 3 6 5 1 3 q
You entered 1 2 3 5 6 7 8 9 3 6 5 1 3
Here's your sorted array, without duplicates:
1 2 3 5 6 7 8 9

Would you like to enter strings or integers? (s for strings, i for integers)
s
Enter up to 15 strings (quit to quit):
Apple
Orange
Banana
Egg
Apple
Water
Sun
Strawberry
Egg
quit
You entered Apple Orange Banana Egg Apple Water Sun Strawberry Egg
Here's your sorted array, without duplicates:
Apple Banana Egg Orange Strawberry Sun Water

6.使用STL queue模板类而不是第12章的Queue类，重新编写程序清单12.12所示的示例。
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <queue>

const int MIN_PER_HR = 60;

class Customer
{
private:
    long arrive;
    int processtime;
public:
    Customer()
    {
        arrive = processtime = 0;
    }
    void set(long when);
    long when() const
    {
        return arrive;
    }
    int ptime() const
    {
        return processtime;
    }
};

void Customer::set(long when)
{
    processtime = std::rand() % 3 + 1;
    arrive = when;
}

bool newcustomer(double x);

int main()
{
    std::srand(std::time(nullptr));

    std::cout << "Case Study: Bank of Heather Automatic Teller\n";
    std::cout << "Enter maximum size of queue: ";
    int qs = 0;
    std::cin >> qs;

    std::queue<Customer> line;

    std::cout << "Enter the number of simulation hours: ";
    int hours = 0;
    std::cin >> hours;
    long cyclelimit = MIN_PER_HR * hours;

    std::cout << "Enter the average number of customers per hour: ";
    double perhour = 0.0;
    std::cin >> perhour;

    double min_per_cust = MIN_PER_HR / perhour;

    Customer temp;
    long turnaways = 0;
    long customers = 0;
    long served = 0;
    long sum_line = 0;
    int wait_time = 0;
    long line_wait = 0;

    for (long cycle = 0; cycle < cyclelimit; cycle++)
    {
        if (newcustomer(min_per_cust))
        {
            if (line.size() == (unsigned)qs)
            {
                turnaways++;
            }
            else
            {
                customers++;
                temp.set(cycle);
                line.push(temp);
            }
        }
        if (wait_time <= 0 && !line.empty())
        {
            temp = line.front();
            line.pop();
            wait_time = temp.ptime();
            line_wait += cycle - temp.when();
            served++;
        }
        if (wait_time > 0)
        {
            wait_time--;
        }
        sum_line += line.size();
    }

    if (customers > 0)
    {
        std::cout << "customers accepted: " << customers << std::endl;
        std::cout << "customers served: " << served << std::endl;
        std::cout << "customers turnaways: " << turnaways << std::endl;
        std::cout << "average queue size: ";
        std::cout.precision(2);
        std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);
        std::cout.setf(std::ios_base::showpoint);
        std::cout << (double)sum_line / cyclelimit << std::endl;
        std::cout << "average wait time: ";
        std::cout << (double)line_wait / served << " minutes\n";
    }
    else
    {
        std::cout << "No customers!\n";
    }
    std::cout << "Done.\n";

    return 0;
}
bool newcustomer(double x)
{
    return ( (std::rand() * x) / RAND_MAX < 1);
}
显示结果如下
Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 10
Enter the number of simulation hours: 100
Enter the average number of customers per hour: 30
customers accepted: 2927
customers served: 2923
customers turnaways: 92
average queue size: 4.85
average wait time: 9.94 minutes
Done.

7.彩票卡是一个常见的游戏。卡片上是带编号的圆点，其中一些圆点被随机选中。编写一个lotto()函数，它接受两个参数。
第一个参数是彩票卡上圆点的个数，第二个参数是随机选择的圆点个数。
该函数返回一个vector<int>对象，其中包含（按排列后的顺序）随机选择的号码。
编写一个小程序来测试这个函数。
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdlib>

std::vector<int> Lotto(int spots, int selected);

int main()
{
    std::cout << "Enter the number of spots on the lottery card: ";
    int spots = 0;
    std::cin >> spots;

    std::cout << "Enter the number of spots to be selected: ";
    int selected = 0;
    std::cin >> selected;

    std::vector<int> result = Lotto(spots, selected);
    std::cout << "Your lucky numbers are: ";

    for (int i = 0; i < result.size(); i++)
    {
        std::cout << result[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}

std::vector<int> Lotto(int spots, int selected)
{
    if (spots < selected)
    {
        std::cout << "The second argument of Lotto() must be less than ";
        std::cout << "the first argument." << std::endl;
        std::cout << "Program abort" << std::endl;
        exit(EXIT_FAILURE);
    }

    if (spots < 0 || selected < 0)
    {
        std::cout << "Both arguments of Lotto() must be positive integers";
        std::cout << std::endl;
        std::cout << "Program abort" << std::endl;
        exit(EXIT_FAILURE);
    }

    std::vector<int> v;
    for (int i = 1; i < spots + 1; i++)
    {
        v.push_back(i);
    }

    random_shuffle(v.begin(), v.end());

    std::vector<int> picks;
    for (int i = 0; i < selected; i++)
    {
        picks.push_back(v[i]);
    }
    return picks;
}
显示结果如下
Enter the number of spots on the lottery card: 51
Enter the number of spots to be selected: 6
Your lucky numbers are: 5 29 12 16 25 36

8.Mat和Pat：希望邀请他们的朋友来参加派对。他们要编写一个程序完成下面的任务。
让Mat 输入他朋友的姓名列表。姓名存储在一个容器中，然后按排列后的顺序显示出来。
让Pat输入她朋友的姓名列表。姓名存储在另一个容器中；然后按排列后的顺序显示出来。
创建第三个容器，将两个列表合并，删除重复的部分，并显示这个容器的内容。
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <cctype>
#include <iterator>
#include <string>

bool string_compare(std::string s1, std::string s2);

int main()
{
    std::cout << "Enter Mat's list of friends ";
    std::cout << "(enter after each name, quit to quit):\n";

    std::vector<std::string> mat_list;

    std::string name;
    std::getline(std::cin, name, '\n');
    while (name != "quit")
    {
        if (name != "")
        {
            mat_list.push_back(name);
        }
        std::getline(std::cin, name, '\n');
    }
    std::cout << std::endl;

    std::cout << "Enter Pat's list of friends ";
    std::cout << "(enter after each name, quit to quit):\n";
    std::vector<std::string> pat_list;

    std::getline(std::cin, name, '\n');
    while (name != "quit")
    {
        if (name != "")
        {
            pat_list.push_back(name);
        }
        std::getline(std::cin, name, '\n');
    }
    std::cout << std::endl;

    sort(mat_list.begin(), mat_list.end(), string_compare);
    sort(pat_list.begin(), pat_list.end(), string_compare);
    std::vector<std::string> merged_list;
    std::insert_iterator<std::vector<std::string>> insert(merged_list, merged_list.begin());
    set_union(mat_list.begin(), mat_list.end(), pat_list.begin(), pat_list.end(), insert, string_compare);

    std::cout << "Here is our guestlist: " << std::endl;

    for (int i = 0; i < merged_list.size(); i++)
    {
        std::cout << merged_list[i] << std::endl;
    }

    return 0;
}

bool string_compare(std::string s1, std::string s2)
{
    transform(s1.begin(), s1.end(), s1.begin(), ::tolower);
    transform(s2.begin(), s2.end(), s2.begin(), ::tolower);
    return s1 < s2;
}
显示结果如下
Enter Mat's list of friends (enter after each name, quit to quit):
Peter Smith
Mike Pence
Hello World
Apple Mike
Orange Egg
quit

Enter Pat's list of friends (enter after each name, quit to quit):
Mike Pence
Orange Egg
Sun Java
Water Earth
quit

Here is our guestlist:
Apple Mike
Hello World
Mike Pence
Orange Egg
Peter Smith
Sun Java
Water Earth

9.相对手数组，在链表中添加和删除元素更容易，但排速度更慢。这就引出了一种可能性：
相对于使用链表算法进行排序，将链表复制到数组中，对数组进行排序，再将排序后的结果复制到链表中的速度可能更块；
但这也可能占用更多的内存。请使用如下方法检验上述假设。
a.创建大型vector<int>对象vi0，并使用rand()给它提供初始值。
b.创建vector<int>对象vi和list<int>对象li，它们的长度都和初始值与vi0相同。
c.计算使用STL算法sort()对vi进行排序所需的时间，再计算使用list的方法sort()对li进行排序所需的时间。
d.将li重置为排序的vi0的内容，并计算执行如下操作所需的时间：将li的内容复制到vi中，对vi进行排序，并将结果复制到 li 中。
#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include <cstdlib>
#include <ctime>

int main()
{
    std::srand(std::time(nullptr));
    std::vector <int> vi0(100000);

    for (int i = 0; i < 100000; i++)
    {
        vi0[i] = std::rand();
    }

    std::vector<int> vi = vi0;
    std::list<int> li(100000);
    copy(vi0.begin(), vi0.end(), li.begin());

    clock_t start = clock();
    sort(vi.begin(), vi.end());

    clock_t end = clock();
    std::cout << (double)(end - start) / CLOCKS_PER_SEC << std::endl;

    start = clock();
    li.sort();
    end = clock();
    std::cout << (double)(end - start) / CLOCKS_PER_SEC << std::endl;

    copy(vi0.begin(), vi0.end(), li.begin());

    start = clock();
    copy(li.begin(), li.end(), vi.begin());
    sort(vi.begin(), vi.end());
    copy(vi.begin(), vi.end(), li.begin());
    end = clock();

    std::cout << (double)(end - start) / CLOCKS_PER_SEC << std::endl;

    return 0;
}
显示结果如下
0.035057
0.083333
0.051078

10.请按如下方式修改程序清单16.9（vect3.cpp）。
a.在结构Review中添加成员price。
b.不使用vector<Review>来存储输入，而使用vector<shared_ptr<Review>>。别忘了，必须使用new返回的指针来初始化shared_ptr。
c.在输入阶段结束后，使用一个循环让用户选择如下方式之一显示书籍：
按原始顺序显示、按字母表顺序显示、按评级升序显示、按评级降序显示、按价格升序显示、按价格降序显示、退出。
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <algorithm>

const int SIZE = 2;

struct Review
{
    std::string title;
    int rating;
    int price;
};

bool operator < (const std::shared_ptr<Review> &r1, const std::shared_ptr<Review> &r2);
bool sortByTitle(const std::shared_ptr<Review> &r1, const std::shared_ptr<Review> &r2);
bool sortByRating(const std::shared_ptr<Review> &r1, const std::shared_ptr<Review> &r2);
bool sortByPrice(const std::shared_ptr<Review> &r1, const std::shared_ptr<Review> &r2);
bool FillReview(Review &rr);
void ShowReview(const std::shared_ptr<Review> &rr);
void print_menu();

int main()
{
    std::vector<std::shared_ptr<Review> > books;
    Review temp;

    while (FillReview(temp))
    {
        std::shared_ptr<Review> t(new Review);
        t->title = temp.title;
        t->rating = temp.rating;
        t->price = temp.price;
        books.push_back(t);
    }
    print_menu();

    char select;
    while (std::cin >> select && select != 'q')
    {
        while (std::cin.get() != '\n')
        {
            continue;
        }
        switch (select)
        {
        case 'f':
            std::cout << "Title reserve output:\nRating\tTitle\tPrice" << std::endl;
            for_each(books.rbegin(), books.rend(), ShowReview);
            print_menu();
            break;
        case 't':
            std::cout << "Sort by title:\nRating\tTitle\tPrice" << std::endl;
            sort(books.begin(), books.end(), sortByTitle);
            for_each(books.begin(), books.end(), ShowReview);
            print_menu();
            break;
        case 'r':
            std::cout << "Sort by rating:\nRating\tTitle\tPrice" << std::endl;
            sort(books.begin(), books.end(), sortByRating);
            for_each(books.begin(), books.end(), ShowReview);
            print_menu();
            break;
        case 'p':
            std::cout << "Sort by price:\nRating\tTitle\tPrice" << std::endl;
            sort(books.begin(), books.end(), sortByPrice);
            for_each(books.begin(), books.end(), ShowReview);
            print_menu();
            break;
        default:
            std::cout << "please enter f, t, r, p or q.\n";
            print_menu();
            break;
        }
    }

    std::cout << "Done.\n";

    return 0;
}

bool operator<(const std::shared_ptr<Review> &r1, const std::shared_ptr<Review> &r2)
{
    if (r1->title < r2->title)
    {
        return true;
    }
    else if (r1->title == r2->title && r1->rating < r2->rating)
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool sortByTitle(const std::shared_ptr<Review> &r1, const std::shared_ptr<Review> &r2)
{
    if (r1->title < r2->title)
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool sortByRating(const std::shared_ptr<Review> &r1, const std::shared_ptr<Review> &r2)
{
    if (r1->rating < r2->rating)
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool sortByPrice(const std::shared_ptr<Review> &r1, const std::shared_ptr<Review> &r2)
{
    if (r1->price < r2->price)
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool FillReview(Review &rr)
{
    std::cout << "Enter book title (quit to quit): ";
    std::getline(std::cin, rr.title, '\n');

    if (rr.title == "quit")
    {
        return false;
    }

    std::cout << "Enter book rating: ";
    std::cin >> rr.rating;

    if (!std::cin)
    {
        return false;
    }

    std::cout << "Enter book price: ";
    std::cin >> rr.price;

    if (!std::cin)
    {
        return false;
    }

    while (std::cin.get() != '\n')
    {
        continue;
    }
    return true;
}

void ShowReview(const std::shared_ptr<Review> &rr)
{
    std::cout << rr->rating << "\t" << rr->title << "\t" << rr->price << std::endl;
}
void print_menu()
{
    std::cout << "Please select the sort:" << std::endl;
    std::cout << "t.sort by title       r.sort by rating" << std::endl;
    std::cout << "p.sort by price       f.sort by title reserve" << std::endl;
    std::cout << "q.quit" << std::endl;
}
显示结果如下
Enter book title (quit to quit): Peter Smith
Enter book rating: 3
Enter book price: 6
Enter book title (quit to quit): Mike Pence
Enter book rating: 2
Enter book price: 1
Enter book title (quit to quit): Hello World
Enter book rating: 9
Enter book price: 11
Enter book title (quit to quit): Apple
Enter book rating: 8
Enter book price: 9
Enter book title (quit to quit): Orange
Enter book rating: 3
Enter book price: 11
Enter book title (quit to quit): Egg
Enter book rating: 2
Enter book price: 7
Enter book title (quit to quit): quit
Please select the sort:
t.sort by title       r.sort by rating
p.sort by price       f.sort by title reserve
q.quit
f
Title reserve output:
Rating  Title   Price
2       Egg     7
3       Orange  11
8       Apple   9
9       Hello World     11
2       Mike Pence      1
3       Peter Smith     6
Please select the sort:
t.sort by title       r.sort by rating
p.sort by price       f.sort by title reserve
q.quit
p
Sort by price:
Rating  Title   Price
2       Mike Pence      1
3       Peter Smith     6
2       Egg     7
8       Apple   9
9       Hello World     11
3       Orange  11
Please select the sort:
t.sort by title       r.sort by rating
p.sort by price       f.sort by title reserve
q.quit
r
Sort by rating:
Rating  Title   Price
2       Mike Pence      1
2       Egg     7
3       Peter Smith     6
3       Orange  11
8       Apple   9
9       Hello World     11
Please select the sort:
t.sort by title       r.sort by rating
p.sort by price       f.sort by title reserve
q.quit
t
Sort by title:
Rating  Title   Price
8       Apple   9
2       Egg     7
9       Hello World     11
2       Mike Pence      1
3       Orange  11
3       Peter Smith     6
Please select the sort:
t.sort by title       r.sort by rating
p.sort by price       f.sort by title reserve
q.quit
q
Done.

第17章 输入、输出和文件
17.1 C++输入和输出概述
17.1.1 流和缓冲区
17.1.2 流、缓冲区和iostream文件
17.1.3 重定向
17.2 使用cout进行输出
17.2.1 重载的<<运算符
17.2.2 其他ostream方法
17.2.3 刷新输出缓冲
17.2.4 用cout进行格式化
17.3 使用cin进行输入
17.3.1 cin>>如何检查输入
17.3.2 流状态
17.3.3 其他istream类方法
17.3.4 其他istream方法
17.4 文件输入和输出
17.4.1 简单的文件I/O
17.4.2 流状态检查和 is_open
17.4.3 打开多个文件
17.4.4 命令行处理技术
17.4.5 文件模式
17.4.6 随机存取
17.5 内核格式化
17.6 总结
17.7 复习题
17.8 编程练习
本章内容包括：
C++角度的输入和输出。
iostream类系列。
重定向。
ostream类方法。
格式化输出。
istream类方法。
流状态。
文件I/O。
使用ifstream类从文件输入。
使用ofstream类输出到文件。
使用fstream类进行文件输入和输出。
命令行处理。
二进制文件。
随机文件访问。
内核格式化。
streambuf类为缓冲区提供了内存，并提供了用于填充缓冲区、访问缓冲区内容、刷新缓冲区和管理缓冲区内存的类方法；
ios_base类表示流的一般特征，如是否可读取、是二进制流还是文本流等；
ios类基于ios_base，其中包括了一个指向streambuf对象的指针成员；
ostream类是从ios类派生而来的，提供了输出方法；
istream类也是从ios类派生而来的，提供了输入方法；
iostream类是基于istream和ostream类的，因此继承了输入方法和输出方法。
cin对象对应于标准输入流。在默认情况下，这个流被关联到标准输入设备（通常为键盘）。
wcin对象与此类似，但处理的是wchar_t类型。
cout对象与标准输出流相对应。在默认情况下，这个流被关联到标准输出设备（通常为显示器）。
wcout对象与此类似，但处理的是wchar_t类型。
cerr对象与标准错误流相对应，可用于显示错误消息。在默认情况下，这个流被关联到标准输出设备（通常为显示器）。
这个流没有被缓冲，这意味着信息将被直接发送给屏幕，而不会等到缓冲区填满或新的换行符。
wcerr对象与此类似；但处理的是wchar_t类型。
clog对象也对应着标准错误流。在默认情况下，这个流被关联到标准输出设备（通常为显示器）。这个流被缓冲。
wclog对象与此类似，但处理的是wchar_t类型。
ostream类重载了<<运算符，使之能够识别C++中所有的基本类型。
对于不是char *类型的指针，C++将其对应于void*，并打印地址的数值表示。
如果要获得字符串的地址，则必须将其强制转换为其他类型。
除了各种operator<<()函数外，ostream类还提供了put()法和write()方法，前者用于显示字符，后者用于显示字符串。
write()的第一个参数提供了要显示的字符串的地址，第二个参数指出要显示多少个字符。
程序清单17.1 write.cpp
#include <iostream>
#include <cstring>

int main()
{
    using std::cout;
    using std::endl;
    const char *state1 = "Florida";
    const char *state2 = "Kansas";
    const char *state3 = "Euphoria";
    int len = std::strlen(state2);
    cout << "Increasing loop index:\n";
    int i;
    for (i = 1; i <= len; i++)
    {
        cout.write(state2, i);
        cout << endl;
    }

    cout << "Decreasing loop index:\n";
    for (i = len; i > 0; i--)
    {
        cout.write(state2, i) << endl;
    }

    cout << "Exceeding string length:\n";
    cout.write(state2, len + 5) << endl;

    return 0;
}
注意，write方法并不会在遇到空字符时自动停止打印字符，而只是印指定数目的字符，即使超出了字符串的边界！
显示结果如下
Increasing loop index:
K
Ka
Kan
Kans
Kansa
Kansas
Decreasing loop index:
Kansas
Kansa
Kans
Kan
Ka
K
Exceeding string length:
KansasEuph

控制符flush刷新缓冲区，而控制符endl刷新缓冲区，并插入一个换行符。
事实上，控制符也是函数。ostream类对<<插入运算符进行了重载，使得下述表达式将被替换为函数调用flush(cout)：
cout << flush
程序清单17.2 defaults.cpp
#include <iostream>

int main()
{
    using std::cout;
    cout << "12345678901234567890\n";
    char ch = 'K';
    int t = 273;
    cout << ch << ":\n";
    cout << t << ":\n";
    cout << -t << ":\n";

    double f1 = 1.200;
    cout << f1 << ":\n";
    cout << (f1 + 1.0 / 9.0) << ":\n";

    double f2 = 1.67E2;
    cout << f2 << ":\n";
    f2 += 1.0 / 9.0;
    cout << f2 << ":\n";
    cout << (f2 * 1.0e4) << ":\n";


    double f3 = 2.3e-4;
    cout << f3 << ":\n";
    cout << f3 / 10 << ":\n";

    return 0;
}
显示结果如下
12345678901234567890
K:
273:
-273:
1.2:
1.31111:
167:
167.111:
1.67111e+06:
0.00023:
2.3e-05:


程序清单17.3 manip.cpp
#include <iostream>

int main()
{
    using namespace std;
    cout << "Enter an integer: ";
    int n;
    cin >> n;

    cout << "n     n*n\n";
    cout << n << "     " << n *n << " (decimal)\n";
    cout << hex;
    cout << n << "     ";
    cout << n *n << " (hexadecimal)\n";

    cout << oct << n << "     " << n *n << " (octal)\n";

    dec(cout);
    cout << n << "     " << n *n << " (decimal)\n";

    return 0;
}
显示结果如下
Enter an integer: 32
n     n*n
32     1024 (decimal)
20     400 (hexadecimal)
40     2000 (octal)
32     1024 (decimal)

Enter an integer: 55
n     n*n
55     3025 (decimal)
37     bd1 (hexadecimal)
67     5721 (octal)

可以使用width成员函数将长度不同的数字放到宽度相同的字段中，该方法的原型为：
int width();
int width(int i);
第一种格式返回字段宽度的当前设置；第二种格式将字段宽度设置为i个空格，并返回以前的字段宽度值。
这使得能够保存以前的值，以便以后恢复宽度值时使用。
width()方法只影响将显示的下一个项目，然后字段宽度将恢复为默认值。
程序清单17.4 width.cpp
#include <iostream>

int main()
{
    using std::cout;
    int w = cout.width(30);
    cout << "default field width = " << w << ":\n";

    cout.width(5);
    cout << "N" << ':';
    cout.width(8);
    cout << "N * N" << ":\n";

    for (long i = 1; i <= 100; i *= 10)
    {
        cout.width(5);
        cout << i << ':';
        cout.width(8);
        cout << i *i << ":\n";
    }

    return 0;
}
显示结果如下
        default field width = 0:
    N:   N * N:
    1:       1:
   10:     100:
  100:   10000:

在默认情况下，cout用空格填充字段中未被使用的部分，可以用fill()成员函数来改变填充字符。
程序清单17.5 fill.cpp
#include <iostream>

int main()
{
    using std::cout;
    cout.fill('*');
    const char *staff[2] = { "Waldo Whipsnade", "Wilmarie Wooper" };
    long bonus[2] = { 900, 1350 };

    for (int i = 0; i < 2; i++)
    {
        cout << staff[i] << ": $";
        cout.width(7);
        cout << bonus[i] << "\n";
    }

    return 0;
}
显示结果如下
Waldo Whipsnade: $****900
Wilmarie Wooper: $***1350

C++的浮点数显示精度默认为6位（末尾的0不显示），precision()成员函数使得能够选择其他值。
和width()的情况不同，但与fill类似，新的精度设置将一直有效，直到被重新设置。
程序清单17.6 precise.cpp
#include <iostream>

int main()
{
    using std::cout;
    float price1 = 20.40;
    float price2 = 1.9 + 8.0 / 9.0;

    cout << "\"Furry Friends\" is $" << price1 << "!\n";
    cout << "\"Fiery Fiends\" is $" << price2 << "!\n";

    cout.precision(2);
    cout << "\"Furry Friends\" is $" << price1 << "!\n";
    cout << "\"Fiery Fiends\" is $" << price2 << "!\n";

    return 0;
}
显示结果如下
"Furry Friends" is $20.4!
"Fiery Fiends" is $2.78889!
"Furry Friends" is $20!
"Fiery Fiends" is $2.8!

程序清单17.7 showpt.cpp
#include <iostream>

int main()
{
    using std::cout;
    using std::ios_base;

    float price1 = 20.40;
    float price2 = 1.9 + 8.0 / 9.0;

    cout.setf(ios_base::showpoint);
    cout << "\"Furry Friends\" is $" << price1 << "!\n";
    cout << "\"Fiery Fiends\" is $" << price2 << "!\n";

    cout.precision(2);
    cout << "\"Furry Friends\" is $" << price1 << "!\n";
    cout << "\"Fiery Fiends\" is $" << price2 << "!\n";

    return 0;
}
显示结果如下
"Furry Friends" is $20.4000!
"Fiery Fiends" is $2.78889!
"Furry Friends" is $20.!
"Fiery Fiends" is $2.8!

setf()函数有两个原型。第一个为：
fmtflags setf(fmtflags);
其中，fmtflags是bitmask类型的typedef名，用于存储格式标记。该名称是在ios_base类中定义的。
这个版本的set()用来设置单个位控制的格式信息。参数是一个fmtflags值，指出要设置哪一位。
返回值是类型为fmtflags的数字，指出所有标记以前的设置。如果打算以后恢复原始设置，则可以保存这个值。
程序清单17.8 setf.cpp
#include <iostream>

int main()
{
    using std::cout;
    using std::endl;
    using std::ios_base;

    int temperature = 63;

    cout << "Today's water temperature: ";
    cout.setf(ios_base::showpos);
    cout << temperature << endl;

    cout << "For our programming friends, that's\n";
    cout << std::hex << temperature << endl;
    cout.setf(ios_base::uppercase);
    cout.setf(ios_base::showbase);
    cout << "or\n";
    cout << temperature << endl;
    cout << "How " << true << "!  oops -- How ";
    cout.setf(ios_base::boolalpha);
    cout << true << "!\n";

    return 0;
}
显示结果如下
Today's water temperature: +63
For our programming friends, that's
3f
or
0X3F
How 0X1!  oops -- How true!

第二个setf()原型接受两个参数，并返回以前的设置：
fmtflage setf (fmtflags, fmtflags);
第一个参数和以前一样，也是一个包含了所需设置的fmtflags值。第二参数指出要清除第一个参数中的哪些位。
程序清单17.9 setf2.cpp
#include <iostream>
#include <cmath>

int main()
{
    using namespace std;
    cout.setf(ios_base::left, ios_base::adjustfield);
    cout.setf(ios_base::showpos);
    cout.setf(ios_base::showpoint);
    cout.precision(3);
    ios_base::fmtflags old = cout.setf(ios_base::scientific, ios_base::floatfield);
    cout << "Left Justification:\n";
    long n;
    for (n = 1; n <= 41; n += 10)
    {
        cout.width(4);
        cout << n << "|";
        cout.width(12);
        cout << sqrt(double(n)) << "|\n";
    }

    cout.setf(ios_base::internal, ios_base::adjustfield);
    cout.setf(old, ios_base::floatfield);

    cout << "Internal Justification:\n";
    for (n = 1; n <= 41; n += 10)
    {
        cout.width(4);
        cout << n << "|";
        cout.width(12);
        cout << sqrt(double(n)) << "|\n";
    }

    cout.setf(ios_base::right, ios_base::adjustfield);
    cout.setf(ios_base::fixed, ios_base::floatfield);
    cout << "Right Justification:\n";
    for (n = 1; n <= 41; n += 10)
    {
        cout.width(4);
        cout << n << "|";
        cout.width(12);
        cout << sqrt(double(n)) << "|\n";
    }

    return 0;
}
显示结果如下
Left Justification:
+1  |+1.000e+00  |
+11 |+3.317e+00  |
+21 |+4.583e+00  |
+31 |+5.568e+00  |
+41 |+6.403e+00  |
Internal Justification:
+  1|+       1.00|
+ 11|+       3.32|
+ 21|+       4.58|
+ 31|+       5.57|
+ 41|+       6.40|
Right Justification:
  +1|      +1.000|
 +11|      +3.317|
 +21|      +4.583|
 +31|      +5.568|
 +41|      +6.403|

调用setf()的效果可以通过unsetf()消除，unsetf的原型如下：
void unsetf (fmtflags mask);
setf()将位设置为1，unsetf()将位恢复为0。
cout.unsetf (ios_base::floatfield);   // go to-default mode


程序清单17.10 iomanip.cpp
#include <iostream>
#include <iomanip>
#include <cmath>

int main()
{
    using namespace std;
    cout << fixed << right;

    cout << setw(6) << "N" << setw(14) << "square root"
         << setw(15) << "fourth root\n";

    double root;
    for (int n = 10; n <= 100; n += 10)
    {
        root = sqrt(double(n));
        cout << setw(6) << setfill('.') << n << setfill(' ')
             << setw(12) << setprecision(3) << root
             << setw(14) << setprecision(4) << sqrt(root)
             << endl;
    }

    return 0;
}
显示结果如下
     N   square root   fourth root
....10       3.162        1.7783
....20       4.472        2.1147
....30       5.477        2.3403
....40       6.325        2.5149
....50       7.071        2.6591
....60       7.746        2.7832
....70       8.367        2.8925
....80       8.944        2.9907
....90       9.487        3.0801
...100      10.000        3.1623

通常，可以这样使用cin:
cin >> value_holder;
cin解释输入的方式取决于value_holder 的数据类型。
istream类重载了抽取运算符>>，使之能够识别所有的基本类型。
可以将hex、oct 和dec控制符与cin一起使用，来指定将整数输入解释为十六进制、八进制还是十进制格式。
对于字符指针，istream类将读取输入中的一个单词。
程序清单17.11 check_it.cpp
#include <iostream>

int main()
{
    using namespace std;
    cout << "Enter numbers: ";

    int sum = 0;
    int input;
    while (cin >> input)
    {
        sum += input;
    }

    cout << "Last value entered = " << input << endl;
    cout << "Sum = " << sum << endl;

    return 0;
}
显示结果如下
Enter numbers: 1 2 3 4 5 6 7 8 9 q
Last value entered = 0
Sum = 45

程序清单17.12 cinexcp.cpp
#include <iostream>

int main()
{
    using namespace std;
    cin.exceptions(ios_base::failbit);
    cout << "Enter numbers: ";
    int sum = 0;
    int input;
    try
    {
        while (cin >> input)
        {
            sum += input;
        }
    }
    catch (ios_base::failure &bf)
    {
        cout << bf.what() << endl;
        cout << "O! the horror!\n";
    }

    cout << "Last value entered = " << input << endl;
    cout << "Sum = " << sum << endl;

    return 0;
}
显示结果如下
Enter numbers: 1 2 3 4 5 6 7 8 9 q
basic_ios::clear: iostream error
O! the horror!
Last value entered = 0
Sum = 45

程序清单17.13 get_fun.cpp
#include <iostream>

const int Limit = 255;

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;

    char input[Limit];

    cout << "Enter a string for getline() processing:\n";
    cin.getline(input, Limit, '#');
    cout << "Here is your input:\n";
    cout << input << "\nDone with phase 1\n";

    char ch;
    cin.get(ch);
    cout << "The next input character is " << ch << endl;

    if (ch != '\n')
    {
        cin.ignore(Limit, '\n');
    }

    cout << "Enter a string for get() processing:\n";
    cin.get(input, Limit, '#');
    cout << "Here is your input:\n";
    cout << input << "\nDone with phase 2\n";

    cin.get(ch);
    cout << "The next input character is " << ch << endl;

    return 0;
}
显示结果如下
Enter a string for getline() processing:
Hello World#123 abc
Here is your input:
Hello World
Done with phase 1
The next input character is 1
Enter a string for get() processing:
Hello World#567 efg
Here is your input:
Hello World
Done with phase 2
The next input character is #

getline (char *, int)
如果没有读取任何字符（读取到换行符被视为读取了一个字符），则设置failbit，比如读取到文件结尾EOF
如果读取了最大数目的字符，且行中还有其他字符，则设置failbit
get (char *, int)
如果没有读取任何字符，则设置failbit，比如读取到文件结尾EOF
程序清单17.14 peeker.cpp
#include <iostream>

int main()
{
    using std::cout;
    using std::cin;
    using std::endl;

    char ch;

    while (cin.get(ch))
    {
        if (ch != '#')
        {
            cout << ch;
        }
        else
        {
            cin.putback(ch);
            break;
        }
    }

    if (!cin.eof())
    {
        cin.get(ch);
        cout << endl << ch << " is next input character.\n";
    }
    else
    {
        cout << "End of file reached.\n";
        std::exit(0);
    }

    while (cin.peek() != '#')
    {
        cin.get(ch);
        cout << ch;
    }
    if (!cin.eof())
    {
        cin.get(ch);
        cout << endl << ch << " is next input character.\n";
    }
    else
        cout << "End of file reached.\n";

    return 0;
}
显示结果如下
Hello World#123 abc#
Hello World
# is next input character.
123 abc
# is next input character.

程序清单17.15 truncate.cpp
#include <iostream>

const int SLEN = 10;

inline void eatline()
{
    while (std::cin.get() != '\n') continue;
}

int main()
{
    using std::cin;
    using std::cout;
    using std::endl;

    char name[SLEN];
    char title[SLEN];
    cout << "Enter your name: ";
    cin.get(name, SLEN);
    if (cin.peek() != '\n')
    {
        cout << "Sorry, we only have enough room for "
             << name << endl;
    }
    eatline();
    cout << "Dear " << name << ", enter your title: \n";
    cin.get(title, SLEN);
    if (cin.peek() != '\n')
    {
        cout << "We were forced to truncate your title.\n";
    }
    eatline();
    cout << " Name: " << name
         << "\nTitle: " << title << endl;

    return 0;
}
显示结果如下
Enter your name: Hello World!
Sorry, we only have enough room for Hello Wor
Dear Hello Wor, enter your title:
Peter Smith
We were forced to truncate your title.
 Name: Hello Wor
Title: Peter Smi

程序清单17.16 fileio.cpp
#include <iostream>
#include <fstream>
#include <string>

int main()
{
    using namespace std;
    string filename;

    cout << "Enter name for new file: ";
    cin >> filename;

    ofstream fout(filename.c_str());

    fout << "For your eyes only!\n";
    cout << "Enter your secret number: ";
    double secret;
    cin >> secret;
    fout << "Your secret number is " << secret << endl;
    fout.close();

    ifstream fin(filename.c_str());
    cout << "Here are the contents of " << filename << ":\n";
    char ch;
    while (fin.get(ch))
    {
        cout << ch;
    }
    cout << "Done.\n";
    fin.close();

    return 0;
}
显示结果如下
Enter name for new file: fileio.txt
Enter your secret number: 123.125
Here are the contents of fileio.txt:
For your eyes only!
Your secret number is 123.125
Done.

cat fileio.txt
For your eyes only!
Your secret number is 123.125

程序清单17.17 count.cpp
#include <iostream>
#include <fstream>
#include <cstdlib>

int main(int argc, char *argv[])
{
    using namespace std;
    if (argc == 1)
    {
        cerr << "Usage: " << argv[0] << " filename[s]\n";
        exit(EXIT_FAILURE);
    }

    ifstream fin;
    long count;
    long total = 0;
    char ch;

    for (int file = 1; file < argc; file++)
    {
        fin.open(argv[file]);
        if (!fin.is_open())
        {
            cerr << "Could not open " << argv[file] << endl;
            fin.clear();
            continue;
        }
        count = 0;
        while (fin.get(ch))
        {
            count++;
        }
        cout << count << " characters in " << argv[file] << endl;
        total += count;
        fin.clear();
        fin.close();
    }
    cout << total << " characters in all files\n";

    return 0;
}
显示结果如下
count
Usage: count filename[s]

count fileio.txt
50 characters in fileio.txt
50 characters in all files

ls -l fileio.txt
-rw-r--r-- 1 weiyayun weiyayun 50 Nov  7 06:51 fileio.txt

count count.cpp fileio.txt
876 characters in count.cpp
50 characters in fileio.txt
926 characters in all files

ls -l count.cpp
-rw-r--r-- 1 weiyayun weiyayun 876 Nov  7 07:05 count.cpp

ios::in 为了读取而打开文件
ios::out 为了输出而打开文件
ios::app 在原来文件结尾追加新的输出
ios::ate 在打开文件后立即把位置设为最后
ios::trunc 在打开文件后删除原来文件的内容
ios::binary 以二进制模式打开文件


程序清单17.18 append.cpp
#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>

const char *file = "guests.txt";

int main()
{
    using namespace std;
    char ch;

    ifstream fin;
    fin.open(file);

    if (fin.is_open())
    {
        cout << "Here are the current contents of the "
             << file << " file:\n";
        while (fin.get(ch))
        {
            cout << ch;
        }
        fin.close();
    }

    ofstream fout(file, ios::out | ios::app);
    if (!fout.is_open())
    {
        cerr << "Can't open " << file << " file for output.\n";
        exit(EXIT_FAILURE);
    }

    cout << "Enter guest names (enter a blank line to quit):\n";
    string name;
    while (std::getline(cin, name, '\n') && name.size() > 0)
    {
        fout << name << endl;
    }
    fout.close();

    fin.clear();
    fin.open(file);
    if (fin.is_open())
    {
        cout << "Here are the new contents of the "
             << file << " file:\n";
        while (fin.get(ch))
        {
            cout << ch;
        }
        fin.close();
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
append
Enter guest names (enter a blank line to quit):
Mike Pence
Peter Smith
Hello World

Here are the new contents of the guests.txt file:
Mike Pence
Peter Smith
Hello World
Done.

append
Here are the current contents of the guests.txt file:
Mike Pence
Peter Smith
Hello World
Enter guest names (enter a blank line to quit):
Apple Water
Sun Flower

Here are the new contents of the guests.txt file:
Mike Pence
Peter Smith
Hello World
Apple Water
Sun Flower
Done.

cat guests.txt
Mike Pence
Peter Smith
Hello World
Apple Water
Sun Flower

程序清单17.19 binary.cpp
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdlib>

const char *file = "planets.dat";

inline void eatline()
{
    while (std::cin.get() != '\n') continue;
}

struct planet
{
    char name[20];
    double population;
    double g;
};

int main()
{
    using namespace std;
    planet pl;
    cout << fixed << right;

    ifstream fin;
    fin.open(file, ios_base::in | ios_base::binary);
    if (fin.is_open())
    {
        cout << "Here are the current contents of the "
             << file << " file:\n";
        while (fin.read((char *)&pl, sizeof pl))
        {
            cout << setw(20) << pl.name << ": "
                 << setprecision(0) << setw(12) << pl.population
                 << setprecision(2) << setw(6) << pl.g << endl;
        }
        fin.close();
    }

    ofstream fout(file, ios_base::out | ios_base::app | ios_base::binary);
    if (!fout.is_open())
    {
        cerr << "Can't open " << file << " file for output:\n";
        exit(EXIT_FAILURE);
    }

    cout << "Enter planet name (enter a blank line to quit):\n";
    cin.get(pl.name, 20);
    while (pl.name[0] != '\0')
    {
        eatline();
        cout << "Enter planetary population: ";
        cin >> pl.population;
        cout << "Enter planet's acceleration of gravity: ";
        cin >> pl.g;
        eatline();
        fout.write((char *)&pl, sizeof pl);
        cout << "Enter planet name (enter a blank line to quit):\n";
        cin.get(pl.name, 20);
    }
    fout.close();

    fin.clear();
    fin.open(file, ios_base::in | ios_base::binary);
    if (fin.is_open())
    {
        cout << "Here are the new contents of the "
             << file << " file:\n";
        while (fin.read((char *)&pl, sizeof pl))
        {
            cout << setw(20) << pl.name << ": "
                 << setprecision(0) << setw(12) << pl.population
                 << setprecision(2) << setw(6) << pl.g << endl;
        }
        fin.close();
    }
    cout << "Done.\n";

    return 0;
}
显示结果如下
Enter planet name (enter a blank line to quit):
Peter Smith
Enter planetary population: 120
Enter planet's acceleration of gravity: 7.15
Enter planet name (enter a blank line to quit):
Mike Pence
Enter planetary population: 221
Enter planet's acceleration of gravity: 8.1
Enter planet name (enter a blank line to quit):
Hello World
Enter planetary population: 188
Enter planet's acceleration of gravity: 7.8
Enter planet name (enter a blank line to quit):

Here are the new contents of the planets.dat file:
         Peter Smith:          120  7.15
          Mike Pence:          221  8.10
         Hello World:          188  7.80
Done.

Here are the current contents of the planets.dat file:
         Peter Smith:          120  7.15
          Mike Pence:          221  8.10
         Hello World:          188  7.80
Enter planet name (enter a blank line to quit):
Apple Water
Enter planetary population: 166
Enter planet's acceleration of gravity: 7.5
Enter planet name (enter a blank line to quit):
Sun Flower
Enter planetary population: 181
Enter planet's acceleration of gravity: 7.9
Enter planet name (enter a blank line to quit):

Here are the new contents of the planets.dat file:
         Peter Smith:          120  7.15
          Mike Pence:          221  8.10
         Hello World:          188  7.80
         Apple Water:          166  7.50
          Sun Flower:          181  7.90
Done.

可以使用tellg和tellp方法来获取当前的位置。这两个方法给你返回当前读取（g代表get） 和写入（p代表put）的位置。
也可以在当前位置的基础上移动来设置你在文件中的位置，使用seekp和seekg。
程序清单17.20 random.cpp
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdlib>

const int LIM = 20;

struct planet
{
    char name[LIM];
    double population;
    double g;
};

const char *file = "planets.dat";

inline void eatline()
{
    while (std::cin.get() != '\n') continue;
}

int main()
{
    using namespace std;
    planet pl;
    cout << fixed;

    fstream finout;
    finout.open(file, ios_base::in | ios_base::out | ios_base::binary);
    int ct = 0;
    if (finout.is_open())
    {
        finout.seekg(0);
        cout << "Here are the current contents of the "
             << file << " file:\n";
        while (finout.read((char *)&pl, sizeof pl))
        {
            cout << ct++ << ": " << setw(LIM) << pl.name << ": "
                 << setprecision(0) << setw(12) << pl.population
                 << setprecision(2) << setw(6) << pl.g << endl;
        }
        if (finout.eof())
        {
            finout.clear();
        }
        else
        {
            cerr << "Error in reading " << file << ".\n";
            exit(EXIT_FAILURE);
        }
    }
    else
    {
        cerr << file << " could not be opened -- bye.\n";
        exit(EXIT_FAILURE);
    }

    cout << "Enter the record number you wish to change: ";
    long rec;
    cin >> rec;
    eatline();
    if (rec < 0 || rec >= ct)
    {
        cerr << "Invalid record number -- bye\n";
        exit(EXIT_FAILURE);
    }
    streampos place = rec * sizeof pl;
    finout.seekg(place);
    if (finout.fail())
    {
        cerr << "Error on attempted seek\n";
        exit(EXIT_FAILURE);
    }

    finout.read((char *)&pl, sizeof pl);
    cout << "Your selection:\n";
    cout << rec << ": " << setw(LIM) << pl.name << ": "
         << setprecision(0) << setw(12) << pl.population
         << setprecision(2) << setw(6) << pl.g << endl;
    if (finout.eof())
    {
        finout.clear();
    }

    cout << "Enter planet name: ";
    cin.get(pl.name, LIM);
    eatline();
    cout << "Enter planetary population: ";
    cin >> pl.population;
    cout << "Enter planet's acceleration of gravity: ";
    cin >> pl.g;
    eatline();
    finout.seekp(place);
    finout.write((char *)&pl, sizeof pl) << flush;
    if (finout.fail())
    {
        cerr << "Error on attempted write\n";
        exit(EXIT_FAILURE);
    }

    ct = 0;
    finout.seekg(0);
    cout << "Here are the new contents of the " << file
         << " file:\n";
    while (finout.read((char *)&pl, sizeof pl))
    {
        cout << ct++ << ": " << setw(LIM) << pl.name << ": "
             << setprecision(0) << setw(12) << pl.population
             << setprecision(2) << setw(6) << pl.g << endl;
    }
    finout.close();
    cout << "Done.\n";

    return 0;
}
显示结果如下
Here are the current contents of the planets.dat file:
0:          Peter Smith:          120  7.15
1:           Mike Pence:          221  8.10
2:          Hello World:          188  7.80
3:          Apple Water:          166  7.50
4:           Sun Flower:          181  7.90
Enter the record number you wish to change: 3
Your selection:
3:          Apple Water:          166  7.50
Enter planet name: Apple Cake
Enter planetary population: 182
Enter planet's acceleration of gravity: 7.68
Here are the new contents of the planets.dat file:
0:          Peter Smith:          120  7.15
1:           Mike Pence:          221  8.10
2:          Hello World:          188  7.80
3:           Apple Cake:          182  7.68
4:           Sun Flower:          181  7.90
Done.

程序清单17.21 strout.cpp
#include <iostream>
#include <sstream>
#include <string>

int main()
{
    using namespace std;
    ostringstream outstr;

    string hdisk;
    cout << "What's the name of your hard disk? ";
    std::getline(cin, hdisk, '\n');
    int cap;
    cout << "What's its capacity in GB? ";
    cin >> cap;
    outstr << "The hard disk " << hdisk << " has a capacity of "
           << cap << " gigabytes.\n";
    string result = outstr.str();
    cout << result;

    return 0;
}
显示结果如下
What's the name of your hard disk? Hello World
What's its capacity in GB? 256
The hard disk Hello World has a capacity of 256 gigabytes.

程序清单17.22 strin.cpp
#include <iostream>
#include <sstream>
#include <string>

int main()
{
    using namespace std;
    string lit = "It was a dark and stormy day, and "
                 " the full moon glowed brilliantly. ";
    istringstream instr(lit);
    string word;
    while (instr >> word)
    {
        cout << word << endl;
    }

    return 0;
}
显示结果如下
It
was
a
dark
and
stormy
day,
and
the
full
moon
glowed
brilliantly.

17.6总结
包含了iostream文件的C++程序将自动打开8个流，并使用8个对象管理它们。
cin对象管理标准输入流，后者默认与标准输入设备（通常为键盘）相连；
cout对象管理标准输出流，后者默认与标准输出设备（通常为显示器）相连；
cerr和clog对象管理与标准错误设备（通常为显示器）相连的未被缓冲的流和被缓冲的流。
这4个对象有都有用于宽字符的副本，它们是wcin，wcout，wcerr和wclog。
istream类定义了多个版本的抽取运算符（>>），用于识别所有的C++基本类型，并将字符输入转换为这些类型。
get方法和getline方法为单字符输入和字符串输入提供了进一步的支持。
同样，ostream类定义了多个版本的插入运算符（<<），用于识别所有的C++基本类型，并将它们转换为相应的字符输出。
put方法对单字符输出提供了进一步的支持。wistream和wostream类对宽字符提供了类似的支持。
使用ios_base类方法以及文件iostream和iomanip中定义的控制符（可与插入运算符拼接的函数），可以控制程序如何格式化输出。
这些方法和控制符使得能够控制计数系统、字段宽度、小数位数、显示浮点变量时采用的计数系统以及其他元素。
fstream文件提供了将iostream方法扩展到文件I/O的类定义。ifstream类是从istream类派生而来的。
通过将ifstream对象与文件关联起来，可以使用所有的istream方法来读取文件。
同样，通过将ofstream对象与文件关联起来，可以使用ostream方法来写文件；
通过将fstream对象与文件关联起来，可以将输入和输出方法用于文件。
要将文件与流关联起来，可以在初始化文件流对象时提供文件名，也可以先创建一个文件流对象，然后用open方法将这个流与文件关联起来。
close方法终止流与文件之间的连接。类构造函数和open方法接受可选的第二个参数，该参数提供文件模式。
文本文件以字符格式存储所有的信息，例如，数字值将被转换为字符表示。
常规的插入和抽取运算符以及get和getline都支持这种模式。
二进制文件使用计算机内部使用的二进制表示来存储信息。
与文本文件相比，二进制文件存储数据（尤其是浮点值）更为精确、简洁，但可移植性较差。
read和write方法都支持二进制输入和输出。
seekg和seekp函数提供对文件的随机存取。这些类方法使得能够将文件指针放置到相对于文件开头、文件尾和当前位置的某个位置。
tellg和tellp方法报告当前的文件位置。
sstream头文件定义了istringstream和ostringstream类，这些类使得能够使用istream和ostream方法来抽取字符串中的信息，
并对要放入到字符串中的信息进行格式化。
17.7 复习题
1.iostream头文件在C++ I/O中扮演何种角色？
iostream头文件定义了用于管理输入和输出的类、常量和操纵符，这些对象管理用于处理I/O的流和缓冲区。
iostream头文件还创建了一些标准对象（cin，cout，cerr和clog以及对应的宽字符对象），用于处理与每个程序相连的标准输入和输出流。

2.为什么键入数字（如121）作为输入要求程序进行转换？
输入121将生成3个字符，每个字符都由一个1字节的二进制码表示。
要将这个值存储为int类型，则必须将这3个字符转换为121值的二进制表示。

3.标准输出与标准错误之间有什么区别？
在默认情况下，标准输出和标准错误都将输出发送给标准输出设备（通常为显示器）。
然而，如果要求操作系统将输出重定向到文件，则标准输出将与文件（而不是显示器）相连，但标准错误仍与显示器相连。

4.为什么在不为每个类型提供明确指示的情况下，cout仍能够显示不同的C++类型？
ostream类为每种C++基本类型定义了一个operator <<()函数的版本。cout会根据要显示的数据类型选择合适的版本。

5.输出方法的定义的哪一特征让您能够拼接输出？
operator <<()函数返回作为输入参数的ostream引用。
这样，通过一个ostream对象调用方法时，将返回该ostream对象的引用。

6.编写一个程序，要求用户输入一个整数，然后以十进制、八进制和十六进制显示该整数。
在宽度为15个字符的字段中显示每种形式，并将它们显示在同一行上，同时显示十进制、八进制、十六进制前缀。
#include <iostream>
#include <iomanip>

int main()
{
    using namespace std;
    cout << "Enter an integer: ";
    int n;
    cin >> n;
    cout << setw(15) << "base ten" << setw(15) << "base sixteen" << setw(15) << "base eight" << endl;
    cout << showbase << setw(15) << n << hex << setw(15) << n << oct << setw(15) << n << endl;

    return 0;
}
显示结果如下
Enter an integer: 129
       base ten   base sixteen     base eight
            129           0x81           0201

7.编写一个程序，请求用户输入下面的信息，并按下面的格式显示它们：
#include <iostream>
#include <iomanip>

int main()
{
    using namespace std;
    char name[20];
    double hourly;
    double hours;

    cout << "Enter your name: ";
    cin.get(name,20).get();
    cout << "Enter your hourly wages: ";
    cin >> hourly;
    cout << "Enter number of hours worked: ";
    cin >> hours;

    cout << showpoint << fixed << right;
    cout << "First format: \n";
    cout << setw(30) << name << ": $" << setprecision(2)
            << setw(10) << hourly << ":" << setprecision(1)
            << setw(5) << hours << "\n";
    cout << "Second format: \n";
    cout << left;
    cout << setw(30) << name << ": $" << setprecision(2)
            << setw(10) << hourly << ":" << setprecision(1)
            << setw(5) << hours << "\n";

    return 0;
}
显示结果如下
Enter your name: Hello World
Enter your hourly wages: 12
Enter number of hours worked: 7.5
First format:
                   Hello World: $     12.00:  7.5
Second format:
Hello World                   : $12.00     :7.5

8.对于下面的程序
#include <iostream>

int main()
{
    using namespace std;
    char ch;
    int ct1 = 0;

    cin >> ch;
    while (ch != 'q')
    {
        ct1++;
        cin >> ch;
    }
    
    int ct2 = 0;
    cin.get(ch);
    while (ch != 'q')
    {
        ct2++;
        cin.get(ch);
    }
    cout << "ct1 = " << ct1 << "; ct2 = " << ct2 << "\n";

    return 0;
}
如果输入如下，该程序将打印什么内容?
I see a q<Enter>
I see a q<Enter>
其中，<Enter>表示按下回车键。
显示结果如下
I see a q
I see a q
ct1 = 5; ct2 = 9

9.下面的两条语句都读取并丢弃行尾之前的所有字符（包括行尾）。这两条语句的行为在哪方面不同？
while (cin.get() != '\n')
{
    continue;
}
cin.ignore(80, '\n');
如果输入行剩余的字符数超过80，while循环仍然能工作，ignore只丢弃前80个字符

17.8编程练习
1・编写一个程序计算输入流中第一个$之前的字符数目，并将$留在输入流中
#include <iostream>

int main()
{
    std::cout << "Please enter string: ";

    char ch;
    std::cin.get(ch);

    int count = 0;
    while (ch != '$')
    {
        count++;
        std::cin.get(ch);
    }
    std::cin.putback(ch);

    std::cout << "count = " << count << std::endl;
    std::cout << "The next character in the input buffer is ";
    std::cout << (char) std::cin.get() << std::endl;

    return 0;
}
显示结果如下
Please enter string: Hello, World$
count = 12
The next character in the input buffer is $

2.编写一个程序，将键盘输入（直到模拟的文件尾）复制到通过命令行指定的文件中。
#include <iostream>
#include <fstream>
#include <cstdlib>

int main(int argc, char *argv[])
{
    if (argc == 1)
    {
        std::cerr << "Error, a filename must be an argument on the command line.";
        std::cerr << std::endl;
        exit(EXIT_FAILURE);
    }

    if (argc > 2)
    {
        std::cout << "Arguments on the command line beyond the first are ignored";
        std::cout << std::endl;
    }

    std::ofstream outfile;
    outfile.open(argv[1]);

    if (!outfile.is_open())
    {
        std::cerr << "Error, could not open file." << std::endl;
        exit(EXIT_FAILURE);
    }

    std::cout << "Enter input (ctrl-D when done): ";

    char ch;
    while (std::cin.get(ch))
    {
        outfile.put(ch);
    }

    if (!std::cin.eof())
    {
        std::cerr << "Warning, input quit due to something other than ";
        std::cerr << "simulated EOF" << std::endl;
    }
    outfile.close();

    return 0;
}
显示结果如下
Enter input (ctrl-D when done): Hello World
Peter Smith
Mike Pence
Apple
Orange
Sun Flower

cat ch17_p02.txt
Hello World
Peter Smith
Mike Pence
Apple
Orange
Sun Flower

3.编写一个程序，将一个文件复制到另一个文件中。让程序通过命令行获取文件名。如果文件无法打开，程序将指出这一点。
#include <iostream>
#include <fstream>
#include <cstdlib>

int main(int argc, char *argv[])
{
    if (argc < 3)
    {
        std::cerr << "Error, two arguments representing filenames are missing";
        std::cerr << std::endl;
        exit(EXIT_FAILURE);
    }
    else  if (argc > 3)
    {
        std::cerr << "More arguments than necessary are detected" << std::endl;
        std::cerr << "Only the first two arguments will be used" << std::endl;
    }

    std::cout << "Warning: this will erase the contents of " << argv[2];
    std::cout << ". Proceed? (y/n) ";

    char ch;
    std::cin >> ch;
    while (std::cin.get() != '\n')
    {
        continue;
    }

    if (ch != 'y' && ch != 'Y')
    {
        return 0;
    }
    else
    {
        std::ifstream infile;
        infile.open(argv[1]);

        if (!infile.is_open())
        {
            std::cerr << "Error, could not open " << argv[1] << std::endl;
            exit(EXIT_FAILURE);
        }

        std::ofstream outfile;
        outfile.open(argv[2]);

        if (!outfile.is_open())
        {
            std::cerr << "Error, could not open " << argv[2] << std::endl;
            exit(EXIT_FAILURE);
        }

        while (infile.get(ch))
        {
            outfile.put(ch);
        }
        infile.close();
        outfile.close();
    }

    return 0;
}
显示结果如下
ch17_p03
Error, two arguments representing filenames are missing

ch17_p03 ch17_p02.txt ch17_p03.txt
Warning: this will erase the contents of ch17_p03.txt. Proceed? (y/n) y

cat ch17_p03.txt
Hello World
Peter Smith
Mike Pence
Apple
Orange
Sun Flower

ls -l ch17_p0?.txt
-rw-r--r-- 1 weiyayun weiyayun 59 Nov  7 11:54 ch17_p02.txt
-rw-r--r-- 1 weiyayun weiyayun 59 Nov  7 12:03 ch17_p03.txt


4・编写一个程序，它打开两个文本文件进行输入，打开一个文本文件进行输出。
该程序将两个输入文件中对应的行并接起来，并用空格分隔，然后将结果写入到输出文件中。
如果一个文件比另一个短，则将较长文件中余下的几行直接复制到输出文件中。
#include <iostream>
#include <fstream>
#include <cstdlib>

int main(int argc, char *argv[])
{
    if (argc < 4)
    {
        std::cerr << "Error, three arguments representing filenames are missing";
        std::cerr << std::endl;
        exit(EXIT_FAILURE);
    }
    else if (argc > 4)
    {
        std::cerr << "More arguments than necessary are detected" << std::endl;
        std::cerr << "Only the first three arguments will be used" << std::endl;
    }

    std::cout << "Warning: this will erase the contents of " << argv[3];
    std::cout << ". Proceed? (y/n) ";

    char ch;
    std::cin >> ch;
    while (std::cin.get() != '\n')
    {
        continue;
    }

    if (ch != 'y' && ch != 'Y')
    {
        return 0;
    }
    else
    {
        std::ifstream infile_first;
        infile_first.open(argv[1]);

        if (!infile_first.is_open())
        {
            std::cerr << "Error, could not open " << argv[1] << std::endl;
            exit(EXIT_FAILURE);
        }

        std::ifstream infile_second;
        infile_second.open(argv[2]);

        if (!infile_second.is_open())
        {
            std::cerr << "Error, could not open " << argv[2] << std::endl;
            exit(EXIT_FAILURE);
        }

        std::ofstream outfile;
        outfile.open(argv[3]);

        if (!outfile.is_open())
        {
            std::cerr << "Error, could not open " << argv[3] << std::endl;
            exit(EXIT_FAILURE);
        }

        infile_first.peek();
        infile_second.peek();
        while (!infile_first.eof() && !infile_second.eof())
        {
            while (infile_first.get(ch) && ch != '\n')
            {
                outfile.put(ch);
            }
            outfile.put(' ');

            while (infile_second.get(ch) && ch != '\n')
            {
                outfile.put(ch);
            }
            outfile.put('\n');

            infile_first.peek();
            infile_second.peek();
        }

        if (infile_first.eof() && !infile_second.eof())
        {
            while (infile_second.get(ch) && ch != '\n')
            {
                outfile.put(ch);
            }
            outfile.put('\n');
        }
        else if (infile_second.eof() && !infile_first.eof())
        {
            while (infile_first.get(ch) && ch != '\n')
            {
                outfile.put(ch);
            }
            outfile.put('\n');
        }
        infile_first.close();
        infile_second.close();
        outfile.close();
    }

    return 0;
}
显示结果如下
ch17_p04
Error, three arguments representing filenames are missing

ch17_p04 ch17_p02.txt ch17_p03.txt ch17_p04.txt
Warning: this will erase the contents of ch17_p04.txt. Proceed? (y/n) y

cat ch17_p04.txt
Hello World Hello World
Peter Smith Peter Smith
Mike Pence Mike Pence
Apple Apple
Orange Orange
Sun Flower Sun Flower

ls -l ch17_p0?.txt
-rw-r--r-- 1 weiyayun weiyayun  59 Nov  7 11:54 ch17_p02.txt
-rw-r--r-- 1 weiyayun weiyayun  59 Nov  7 12:03 ch17_p03.txt
-rw-r--r-- 1 weiyayun weiyayun 118 Nov  7 12:11 ch17_p04.txt

5.Mat和Pat想邀请他们的朋友来参加派对，就像第16章中的编程练习8那样，但现在他们希望程序使用文件。
他们请您编写一个完成下述任务的程序。
从文本文件mat.dat中读取Mat朋友的姓名清单，其中每行为一个朋友。姓名将被存储在容器然后按顺序显示出来
从文本文件pat.dat中读取Pat朋友的姓名清单，其中每行为一个朋友。姓名将被存储在容器中，然后按顺序显示出来。
合并两个清单，删除重复的条目，并将结果保存在文件matnpat.dat中，其中每行为一个朋友。
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <algorithm>
#include <iterator>
#include <cstdlib>
#include <cctype>

void check(std::ifstream &infile, std::string filename);
void check(std::ofstream &infile, std::string filename);
bool stringComp(std::string s1, std::string s2);
bool stringEqual(std::string s1, std::string s2);

int main()
{
    std::ifstream patfile("pat.dat");
    std::ifstream matfile("mat.dat");
    std::ofstream patnmat("matnpat.dat");

    check(patfile, "pat.dat");
    check(matfile, "mat.dat");
    check(patnmat, "matnpat.dat");

    std::string name;
    std::vector<std::string> patlist;
    std::vector<std::string> matlist;

    while (std::getline(patfile, name, '\n') && name != "")
    {
        patlist.push_back(name);
    }

    while (getline(matfile, name) && name != "")
    {
        matlist.push_back(name);
    }

    std::vector<std::string> matnpat_list;
    std::back_insert_iterator<std::vector<std::string>> iiter(matnpat_list);

    copy(patlist.begin(), patlist.end(), iiter);
    copy(matlist.begin(), matlist.end(), iiter);

    sort(matnpat_list.begin(), matnpat_list.end(), stringComp);
    std::vector<std::string>::iterator iv = unique(matnpat_list.begin(), matnpat_list.end(), stringEqual);
    matnpat_list.erase(iv, matnpat_list.end());

    std::ostream_iterator<std::string, char> os_iter(std::cout, "\n");
    std::ostream_iterator<std::string, char> os_iter_file(patnmat, "\n");

    std::cout << "Here is your list of guests: " << std::endl;
    copy(matnpat_list.begin(), matnpat_list.end(), os_iter);

    patnmat << "Here is your list of guests: " << std::endl;
    copy(matnpat_list.begin(), matnpat_list.end(), os_iter_file);

    return 0;
}

void check(std::ifstream &infile, std::string filename)
{
    if (!infile.is_open())
    {
        std::cerr << "Error, cannot open " << filename << std::endl;
        exit(EXIT_FAILURE);
    }
}

void check(std::ofstream &infile, std::string filename)
{
    if (!infile.is_open())
    {
        std::cerr << "Error, cannot open " << filename << std::endl;
        exit(EXIT_FAILURE);
    }
}

bool stringComp(std::string s1, std::string s2)
{
    transform(s1.begin(), s1.end(), s1.begin(), ::tolower);
    transform(s2.begin(), s2.end(), s2.begin(), ::tolower);
    return s1 < s2;
}

bool stringEqual(std::string s1, std::string s2)
{
    transform(s1.begin(), s1.end(), s1.begin(), ::tolower);
    transform(s2.begin(), s2.end(), s2.begin(), ::tolower);
    return s1 == s2;
}
显示结果如下
Here is your list of guests:
a1
a2
a3
a4
a5
a6
b1
b2
b3
b4
b5
b6

cat mat.dat
b1
b2
a3
a5
b3
b4
b5
a6
b6

cat pat.dat
a1
b1
a2
a3
b2
a4
a5
a6

cat matnpat.dat
Here is your list of guests:
a1
a2
a3
a4
a5
a6
b1
b2
b3
b4
b5
b6

6.考虑14章的编程练习5中的类定义。如果还没有完成这个练习，请现在就做，然后完成下面的任务。
编写一个程序，它使用标准C++ I/O、文件I/O以及14章的编程练习5中定义的employee，manager，fink和highfink类型的数据。
该程序应包含程序清单17.17中的代码行，即允许用户将新数据添加到文件中。
该程序首次被运行时，将要求用户输入数据，然后显示所有的数据，并将这些信息保存到一个文件中。
当该程序再次被运行时，将首先读取并显示文件中的数据，然后让用户添加数据，并显示所有的数据。
差别之一是，应通过一个指向employee类型的指针数组来处理数据。这样，指针可以指向employee对象，
也可以指向从employee派生出来的其他三种对象中的任何一种。
使数组较小有助于检查程序，例如，您可能将数组限定为最多包含10个元素。
为通过键盘输入，程序应使用一个菜单，让用户选择要创建的对象类型。
菜单将使用一个switch，以便使用new来创建指定类型的对象，并将它的地址赋给pc数组中的一个指针。
然后该对象可以使用虚函数setall()来提示用户输入相应的数据。
为将数据保存到文件中，应设计一个虚函数writeall()。
注意：对于这个练习，应使用文本I/O，而不是二进制I/O
（遗憾的是，虚对象包含指向虚函数指针表的指针，而write()将把这种信息复制到文件中。
使用read()读取文件的内容，以填充对象时，函数指针值将为乱码，这将扰乱虚函数的行为）。
可使用换行符将字段分隔开，这样在输入时将很容易识别各个字段。
也可以使用二进制I/O，但不能将对象作为一个整体写入，而应该提供分别对每个类成员应用write()和read()的类方法。
这样，程序将只把所需的数据保存到文件中。
比较难处理的部分是使用文件恢复数据。问题在于：
程序如何才能知道接下来要恢复的项目是employee对象、manager对象、fink对象还是highfink对象？
一种方法是，在对象的数据写入文件时，在数据前面加上一个指示对象类型的整数。
这样，在文件输入时，程序便可以读取该整数，并使用switch语句创建一个适当的对象来接收数据。
然后便可以使用指针调用虚函数getall()来读取信息。
emp2.h
#ifndef EMP2_H_
#define EMP2_H_
#include <iostream>
#include <string>
#include <fstream>

class abstr_emp
{
private:
    std::string fname;
    std::string lname;
    std::string job;
public:
    enum classkind { Employee, Manager, Fink, Highfink };
    abstr_emp();
    abstr_emp(const std::string &fn, const std::string   &ln, const std::string   &j);
    virtual void ShowAll() const;
    virtual void SetAll();
    friend std::ostream &operator <<(std::ostream &os, const abstr_emp &e);
    virtual ~abstr_emp() = 0;
    virtual void writeall(std::ofstream &ofs) const;
    virtual void getall(std::ifstream &ofs);
};

class employee : public abstr_emp
{
public:
    employee();
    employee(const std::string &fn, const std::string &ln, const std::string &j);
    virtual void ShowAll() const;
    virtual void SetAll();
    virtual void writeall(std::ofstream &ofs) const;
    virtual void getall(std::ifstream &ofs);
};

class manager : virtual public abstr_emp
{
private:
    int inchargeof;
protected:
    int InChargeOf() const
    {
        return inchargeof;
    }
    int &InChargeOf()
    {
        return inchargeof;
    }
public:
    manager();
    manager(const std::string &fn, const std::string &ln, const std::string &j, int ico = 0);
    manager(const abstr_emp &e, int ico);
    manager(const manager &m);
    virtual void ShowAll() const;
    virtual void SetAll();
    virtual void writeall(std::ofstream &ofs) const;
    virtual void getall(std::ifstream &ofs);
};

class fink : virtual public abstr_emp
{
private:
    std::string reportsto;
protected:
    const std::string &ReportsTo() const
    {
        return reportsto;
    }
    std::string &ReportsTo()
    {
        return reportsto;
    }
public:
    fink();
    fink(const std::string &fn, const std::string &ln, const std::string &j, const std::string &rpo);
    fink(const abstr_emp &e, const std::string &rpo);
    fink(const fink &e);
    virtual void ShowAll() const;
    virtual void SetAll();
    virtual void writeall(std::ofstream &ofs) const;
    virtual void getall(std::ifstream &ofs);
};

class highfink : public manager, public fink
{
public:
    highfink();
    highfink(const std::string &fn, const std::string &ln, const std::string &j, const std::string &rpo, int ico);
    highfink(const abstr_emp &e, const std::string &rpo, int ico);
    highfink(const fink &f, int ico);
    highfink(const manager &m, const std::string &rpo);
    highfink(const highfink &h);
    virtual void ShowAll() const;
    virtual void SetAll();
    virtual void writeall(std::ofstream &ofs) const;
    virtual void getall(std::ifstream &ofs);
};

#endif

emp2.cpp
#include "emp2.h"

abstr_emp::abstr_emp()
{
    fname = "";
    lname = "";
    job = "";
}

abstr_emp::abstr_emp(const std::string &fn, const std::string   &ln, const std::string   &j) : fname(fn), lname(ln), job(j)
{

}

void abstr_emp::ShowAll() const
{
    std::cout << "First name: " << fname << std::endl;
    std::cout << "Last name: " << lname << std::endl;
    std::cout << "Job: " << job << std::endl;
}

void abstr_emp::SetAll()
{
    std::cout << "Enter first name: ";
    std::cin >> fname;

    while (std::cin.get() != '\n')
    {
        continue;
    }

    std::cout << "Enter last name: ";
    std::cin >> lname;

    while (std::cin.get() != '\n')
    {
        continue;
    }

    std::cout << "Enter the job: ";
    std::getline(std::cin, job, '\n');
}

std::ostream &operator<<(std::ostream &os, const abstr_emp &e)
{
    os << e.lname << ", " << e.fname << " : " << e.job;
    return os;
}

abstr_emp::~abstr_emp()
{

}

void abstr_emp::writeall(std::ofstream &ofs) const
{
    ofs << "First name: " << fname << std::endl;
    ofs << "Last name: " << lname << std::endl;
    ofs << "Job: " << job << std::endl;
}
void abstr_emp::getall(std::ifstream &ifs)
{
    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    std::getline(ifs, fname, '\n');
    std::cout << "First name is " << fname << std::endl;

    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    std::getline(ifs, lname, '\n');
    std::cout << "Last name is " << lname << std::endl;

    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    std::getline(ifs, job, '\n');
    std::cout << "Job is " << job << std::endl;
}

employee::employee() : abstr_emp()
{

}

employee::employee(const std::string &fn, const std::string   &ln, const std::string   &j) : abstr_emp(fn, ln, j)
{

}

void employee::ShowAll() const
{
    std::cout << "Status: Employee" << std::endl;
    abstr_emp::ShowAll();
}

void employee::SetAll()
{
    abstr_emp::SetAll();
}

void employee::writeall(std::ofstream &ofs) const
{
    ofs << abstr_emp::Employee << std::endl;
    abstr_emp::writeall(ofs);
}

void employee::getall(std::ifstream &ifs)
{
    abstr_emp::getall(ifs);
}

manager::manager() : abstr_emp()
{
    inchargeof = 0;
}

manager::manager(const std::string &fn, const std::string &ln,
                 const std::string &j, int ico) : abstr_emp(fn, ln, j)
{
    inchargeof = ico;

    if (inchargeof < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        inchargeof = 0;
    }
}

manager::manager(const abstr_emp &e, int ico) : abstr_emp(e)
{
    inchargeof = ico;

    if (inchargeof < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        inchargeof = 0;
    }
}

manager::manager(const manager &m) : abstr_emp(m)
{
    inchargeof = m.inchargeof;
}

void manager::ShowAll() const
{
    std::cout << "Status: Manager" << std::endl;
    abstr_emp::ShowAll();
    std::cout << "In charge of " << inchargeof << " people" << std::endl;
}

void manager::SetAll()
{
    abstr_emp::SetAll();
    std::cout << "Enter the number of people the manager is in charge of: ";
    std::cin >> inchargeof;
    while (std::cin.get() != '\n')
    {
        continue;
    }
    if (inchargeof < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        inchargeof = 0;
    }
}

void manager::writeall(std::ofstream &ofs) const
{
    ofs << abstr_emp::Manager << std::endl;
    abstr_emp::writeall(ofs);
    ofs << "Number of people managed: " << inchargeof << std::endl;
}

void manager::getall(std::ifstream &ifs)
{
    abstr_emp::getall(ifs);
    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    ifs >> inchargeof;
    ifs.get();
}

fink::fink() : abstr_emp(), reportsto("")
{

}

fink::fink(const std::string &fn, const std::string &ln,
           const std::string &j, const std::string &rpo) : abstr_emp(fn, ln, j), reportsto(rpo)
{

}

fink::fink(const abstr_emp &e, const std::string &rpo) : abstr_emp(e), reportsto(rpo)
{

}

fink::fink(const fink &e) : abstr_emp(e)
{
    reportsto = e.reportsto;
}

void fink::ShowAll() const
{
    std::cout << "Status: fink" << std::endl;
    abstr_emp::ShowAll();
    std::cout << "Reports to " << reportsto << std::endl;
}

void fink::SetAll()
{
    abstr_emp::SetAll();
    std::cout << "Enter whomever is reported to: ";
    std::getline(std::cin, reportsto, '\n');
}

void fink::writeall(std::ofstream &ofs) const
{
    ofs << abstr_emp::Fink << std::endl;
    abstr_emp::writeall(ofs);
    ofs << "Reports to: " << reportsto << std::endl;
}

void fink::getall(std::ifstream &ifs)
{
    abstr_emp::getall(ifs);
    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    std::getline(ifs, reportsto, '\n');
}
highfink::highfink() : abstr_emp(), manager(), fink()
{

}
highfink::highfink(const std::string &fn, const std::string &ln,
                   const std::string &j, const std::string &rpo, int ico) : abstr_emp(fn, ln, j), manager(fn, ln, j, ico), fink(fn, ln, j, rpo)
{

}
highfink::highfink(const abstr_emp &e, const std::string &rpo, int ico) : abstr_emp(e), manager(e, ico), fink(e, rpo)
{

}

highfink::highfink(const fink &f, int ico) : abstr_emp(f), manager(f, ico), fink(f)
{

}

highfink::highfink(const manager &m, const std::string &rpo) : abstr_emp(m), manager(m), fink(m, rpo)
{

}

highfink::highfink(const highfink &h) : abstr_emp(h), manager(h), fink(h)
{

}

void highfink::ShowAll() const
{
    std::cout << "Status: Highfink" << std::endl;
    abstr_emp::ShowAll();
    std::cout << "In charge of " << InChargeOf() << " people" << std::endl;
    std::cout << "Reports to " << ReportsTo() << std::endl;
}

void highfink::SetAll()
{
    abstr_emp::SetAll();
    std::cout << "Enter the number of people managed: ";
    std::cin >> InChargeOf();
    while (std::cin.get() != '\n')
    {
        continue;
    }
    if (InChargeOf() < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        InChargeOf() = 0;
    }

    std::cout << "Enter whomever is reported to: ";
    std::getline(std::cin, ReportsTo(), '\n');
}

void highfink::writeall(std::ofstream &ofs) const
{
    ofs << abstr_emp::Highfink << std::endl;
    abstr_emp::writeall(ofs);
    ofs << "Number of people managed: " << InChargeOf() << std::endl;
    ofs << "Reports to: " << ReportsTo() << std::endl;
}

void highfink::getall(std::ifstream &ifs)
{
    abstr_emp::getall(ifs);
    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    ifs >> InChargeOf();
    ifs.get();
    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    std::getline(ifs, ReportsTo(), '\n');
}

ch17_p06.cpp
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdlib>
#include "emp2.h"

const int MAX = 10;

void displayMenu(void);
void eatline(void);

int main()
{
    abstr_emp *pc[MAX];
    std::cout << "You may enter of to " << MAX << " employees" << std::endl;

    int count = 0;
    char ch;
    std::ifstream fin;
    fin.open("employeeList.dat");

    if (fin.is_open())
    {
        int classtype = 0;
        while ( fin >> classtype && fin.get(ch) )
        {
            switch (classtype)
            {
            case abstr_emp::Employee:
                std::cout << "Creating an employee object" << std::endl;
                pc[count] = new employee;
                pc[count++]->getall(fin);
                break;
            case abstr_emp::Manager:
                std::cout << "Creating an manager object" << std::endl;
                pc[count] = new manager;
                pc[count++]->getall(fin);
                break;
            case abstr_emp::Fink:
                std::cout << "Creating an fink object" << std::endl;
                pc[count] = new fink;
                pc[count++]->getall(fin);
                break;
            case abstr_emp::Highfink:
                std::cout << "Creating an highfink object" << std::endl;
                pc[count] = new highfink;
                pc[count++]->getall(fin);
                break;
            default:
                std::cerr << "It looks like an error has occurred" << std::endl;
                break;
            }
        }
        std::cout << "Here is your current employee list: " << std::endl;
        for (int i = 0; i < count; i++)
        {
            pc[i]->ShowAll();
            std::cout << std::endl;
        }
        fin.close();
    }

    while (count < MAX)
    {
        displayMenu();
        std::cin >> ch;
        eatline();

        switch (ch)
        {
        case 'a':
            pc[count] = new employee;
            pc[count]->SetAll();
            count++;
            break;
        case 'b':
            pc[count] = new manager;
            pc[count]->SetAll();
            count++;
            break;
        case 'c':
            pc[count] = new fink;
            pc[count]->SetAll();
            count++;
            break;
        case 'd':
            pc[count] = new highfink;
            pc[count]->SetAll();
            count++;
            break;
        case 'q':
            break;
        default:
            std::cout << "Error input not recognized" << std::endl;
            continue;
            break;
        }
        if (ch == 'q')
        {
            break;
        }
    }

    std::ofstream fout;
    fout.open("employeeList.dat");

    if (!fout.is_open())
    {
        std::cerr << "Error, cannot open employeeList.dat" << std::endl;
        exit(EXIT_FAILURE);
    }

    std::cout << "Here's our updated list: " << std::endl;

    for (int i = 0; i < count; i++)
    {
        pc[i]->ShowAll();
        std::cout << std::endl;
        pc[i]->writeall(fout);
    }
    fout.close();
    for (int i = 0; i < count; i++)
    {
        delete pc[i];
    }

    return 0;
}

void displayMenu(void)
{
    std::cout << "Select one of the following:" << std::endl;
    std::cout << std::left;
    std::cout << std::setw(20) << "a. Employee";
    std::cout << std::setw(20) << "b. Manager";
    std::cout << std::endl;
    std::cout << std::setw(20) << "c. Fink";
    std::cout << std::setw(20) << "d. Highfink";
    std::cout << std::endl;
    std::cout << "(q to quit)" << std::endl;
}

void eatline(void)
{
    while (std::cin.get() != '\n')
    {
        continue;
    }
}
显示结果如下
You may enter of to 10 employees
Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
a
Enter first name: Hello
Enter last name: World
Enter the job: aaabbb
Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
b
Enter first name: Mike
Enter last name: Pence
Enter the job: cccddd
Enter the number of people the manager is in charge of: 5
Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
c
Enter first name: Peter
Enter last name: Smith
Enter the job: eeefff
Enter whomever is reported to: Peter
Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
d
Enter first name: Apple
Enter last name: Water
Enter the job: hhhiii
Enter the number of people managed: 8
Enter whomever is reported to: Mike
Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
q
Here's our updated list:
Status: Employee
First name: Hello
Last name: World
Job: aaabbb

Status: Manager
First name: Mike
Last name: Pence
Job: cccddd
In charge of 5 people

Status: fink
First name: Peter
Last name: Smith
Job: eeefff
Reports to Peter

Status: Highfink
First name: Apple
Last name: Water
Job: hhhiii
In charge of 8 people
Reports to Mike

ch17_p06
You may enter of to 10 employees
Creating an employee object
First name is Hello
Last name is World
Job is aaabbb
Creating an manager object
First name is Mike
Last name is Pence
Job is cccddd
Creating an fink object
First name is Peter
Last name is Smith
Job is eeefff
Creating an highfink object
First name is Apple
Last name is Water
Job is hhhiii
Here is your current employee list:
Status: Employee
First name: Hello
Last name: World
Job: aaabbb

Status: Manager
First name: Mike
Last name: Pence
Job: cccddd
In charge of 5 people

Status: fink
First name: Peter
Last name: Smith
Job: eeefff
Reports to Peter

Status: Highfink
First name: Apple
Last name: Water
Job: hhhiii
In charge of 8 people
Reports to Mike

Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
b
Enter first name: Sun
Enter last name: Flower
Enter the job: jjjkkk
Enter the number of people the manager is in charge of: 9
Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
q
Here's our updated list:
Status: Employee
First name: Hello
Last name: World
Job: aaabbb

Status: Manager
First name: Mike
Last name: Pence
Job: cccddd
In charge of 5 people

Status: fink
First name: Peter
Last name: Smith
Job: eeefff
Reports to Peter

Status: Highfink
First name: Apple
Last name: Water
Job: hhhiii
In charge of 8 people
Reports to Mike

Status: Manager
First name: Sun
Last name: Flower
Job: jjjkkk
In charge of 9 people

7.下面是某个程序的部分代码。该程序将键盘输入读取到一个由string对象组成的vector中，
将字符串内容（而不是string对象）存储到一个文件中，然后该文件的内容复制到另一个由string对象组成的vector中。
该程序以二进制格式打开文件，并想使用read()和write()来完成I/O。余下的工作如下所述。
编写函数void ShowStr (const string &)，它显示一个string对象，并在显示完后换行。
编写函数符Store，它将字符串信息写入到文件中。Store的构造函数应接受一个指定ifstream对象的参数，
而重载的operator() (const string &)应指出要写入到文件中的字符串。
一种可行的计划是，首先将字符串的长度写入到文件中，然后将字符串的内容写入到文件中。
成员函数data()返回一个指针，该指针指向一个其中存储了字符串中字符的数组。
它类似于成员函数c_str()，只是后者在数组末尾加上了一个空字符。
编写函数GetStrs()，它根据文件恢复信息。该函数可以使用read()来获得字符串的长度，然后使用一个循环从文件中读取相应数量的字符，
并将它们附加到一个原来为空的临时string末尾。由于string的数据是私有的，因此必须使用string类的方法来将数据存储到string对象中，
而不能直接存储。
ch17_p07.cpp
#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <algorithm>
#include <cstdlib>

class Store
{
private:
    std::ofstream *pfout;
public:
    Store(std::ofstream &fout)
    {
        pfout = &fout;
    }
    ~Store() {}
    Store &operator()(const std::string &str)
    {
        size_t len = str.length();
        pfout->write((char *)&len, sizeof(size_t));
        pfout->write(str.data(), len);
        return *this;
    }
};

void ShowStr(const std::string &str);
void GetStrs(std::ifstream &fin, std::vector<std::string> &vistr);

int main()
{
    std::vector<std::string> vostr;
    std::string temp;

    std::cout << "Enter strings (empty line to quit) :\n";
    while (std::getline(std::cin, temp, '\n') && temp[0] != '\0')
    {
        vostr.push_back(temp);
    }

    std::cout << "Here is your input. \n";
    for_each(vostr.begin(), vostr.end(), ShowStr);

    std::ofstream fout("strings.dat", std::ios_base::out | std::ios_base::binary);
    for_each(vostr.begin(), vostr.end(), Store(fout));
    fout.close();

    std::vector<std::string> vistr;
    std::ifstream fin("strings.dat", std::ios_base::in | std::ios_base::binary);
    if (!fin.is_open())
    {
        std::cerr << "Could not open file for input. \n";
        exit(EXIT_FAILURE);
    }
    GetStrs(fin, vistr);
    std::cout << "\nHere are the strings read from the file:\n";

    for_each(vistr.begin(), vistr.end(), ShowStr);

    return 0;
}

void ShowStr(const std::string &str)
{
    std::cout << str << std::endl;
}

void GetStrs(std::ifstream &fin, std::vector<std::string> &vistr)
{
    size_t len = 0;
    std::string str;
    char ch;
    fin.peek();
    while (!fin.eof())
    {
        fin.read((char *)&len, sizeof(size_t));
        for (size_t i = 0; i < len; i++)
        {
            fin.read(&ch, sizeof(char));
            str.push_back(ch);
        }
        vistr.push_back(str);
        str.clear();
        fin.peek();
    }
}
显示结果如下
Enter strings (empty line to quit) :
Hello World
Peter Smith
Mike Pence
Apple Water
Sun Flower

Here is your input.
Hello World
Peter Smith
Mike Pence
Apple Water
Sun Flower

Here are the strings read from the file:
Hello World
Peter Smith
Mike Pence
Apple Water
Sun Flower

第18章 探讨C++新标准
18.1 复习前面介绍过的C++11功能
18.1.1 新类型
18.1.2 统一的初始化
18.1.3 声明
18.1.4 智能指针
18.1.5 异常规范方面的修改
18.1.6 作用域内枚举
18.1.7 对类的修改
18.1.8 模板和STL方面的修改
18.1.9 右值引用
18.2 移动语义和右值引用
18.2.1 为何需要移动语义
18.2.2 一个移动示例
18.2.3 移动构造函数解析
18.2.4 赋值
18.2.5 强制移动
18.3 新的类功能
18.3.1 特殊的成员函数
18.3.2 默认的方 法和禁用的方法.
18.3.3 委托构造函数
18.3.4 继承构造函 数
18.3.5 管理方法：override 和final
18.4 Lambda函数
18.4.1 比较函数指针、函数符和Lambda函数
18.4.2 为何使用lambda
18.5 包装器
18.5.1 包装器function及模板的低效性
18.5.2 修复问题
18.5.3 其他方式
18.6 可变参数模板
18.6.1 模板和函数参数包
18.6.2 展开参数包
18.6.3 在可变参数模板函数中使用递归
18.7 C++11新增的其他功能.
18.7.1 并行编程
18.7.2 新增的库
18.7.3 低级编程
18.7.4 杂项
18.8 语言变化
18.8.1 Boost项目
18.8.2 TR1
18.8.3 使用Boost
18.9 接下来的任务
18.10 总结
18.11 复习题
18.12 编程练习
本章首先复习前面介绍过的C++11功能，然后介绍如下主题：
移动语义和右值引用。
Lambda表达式。
包装器模板function
可变参数模板。
C++11新增了类型long long和unsigned long long；新增了类型char16_t和char32_t。
C++11扩大了用大括号括起的列表（初始化列表）的适用范围，使其可用于所有内置类型和用户定义的类型（即类对象），
使用初始化列表时，可添加等号（=），也可不添加。另外，列表初始化语法也可用于new表达式中。
创建对象时，也可使用大括号（而不是圆括号）括起的列表来调用构造函数。
然而，如果类有将模板std:initializerlist作为参数的构造函数，则只有该构造函数可以使用列表初始化形式。
初始化列表语法可防止缩窄，即禁止将数值赋给无法存储它的数值变量。常规初始化允许程序员执行这样的操作。
初始化列表语法允许转换为更宽的类型。另外，只要值在较窄类型的取值范围内，将其转换为较窄的类型也是允许的。
C++11提供了模板类initializer_list，可将其用作构造函数的参数。
如果类有接受initializer_list作为参数的构造函数，则初始化列表语法就只能用于该构造函数。
列表中的元素必须是同种类型或可转换为同一种类型。STL容器提供了将initializer_list作为参数的构造函数。
头文件initializer_list提供了对模板类initializer_list的支持。这个类包含成员函数begin()和end()，可用于获悉列表的范围。
除用于构造函数外，还可将initializer_list用作常规函数的参数。
C++11提供了多种简化声明的功能，尤其在使用模板时。
以前，关键字auto是一个存储类型说明符（见第9章），C++11将其用于实现自动类型推断（见第3章）。
这要求进行显式初始化，让编译器能够将变量的类型设置为初始值的类型。关键字auto还可简化模板声明。
关键字decltype将变量的类型声明为表达式指定的类型。
C++11新增了一种函数声明语法：在函数名和参数列表后面（而不是前面）指定返回类型。
对于冗长或复杂的标识符，如果能够创建其别名将很方便。以前，C++使用typedef来创建别名。
C++11提供了另一种创建别名的语法，使用using =来创建别名。
差别在于，新语法也可用于模板部分具体化，但typedef不能。
C++11新增了关键字nullptr，用于表示空指针；它是指针类型，不能转换为整型类型。
如果在程序中使用new从堆（自由存储区）分配内存，等到不再需要时，应使用delete将其释放。
C++11摒弃了auto_ptr，并新增了三种智能指针：unique_ptr，shared_ptr和weak_ptr。
所有新增的智能指针都能与STL容器和移动语义协同工作。
C++11摒弃了用于指出函数可能引发哪些异常的异常规范。然而，标准委员会认为，指出函数不会引发异常有一定的价值，
他们为此添加了关键字noexcept。
传统的C++枚举提供了一种创建名称常量的方式，枚举名的作用域为枚举定义所属的作用域，
这意味着如果在同一个作用域内定义两个枚举，它们的枚举成员不能同名。
最后枚举可能不是可完全移植的，因为不同的实现可能选择不同的底层类型。
为解决这些问题，C++11新增了一种使用class或struct定义的枚举。
新枚举要求进行显式限定，以免发生名称冲突。因此，引用特定枚举时，需要使用枚举名::常量名。
C++引入了关键字explicit，以禁止单参数构造函数导致的自动转换。
C++11拓展了explicit的这种用法，使得可对转换函数做类似的处理。
C++11可在类定义中初始化成员，可使用等号或大括号版本的初始化，但不能使用圆括号版本的初始化。
其结果与给构造函数提供成员初始化列表相同。
如果构造函数在成员初始化列表中提供了相应的值，这些默认值将被覆盖。
对于内置数组以及包含方法begin()和end()的类（如std:string）和STL容器，
基于范围的for循环对数组或容器中的每个元素执行指定的操作。
如果要在循环中修改数组或容器的每个元素，可使用引用类型。
C++11新增了STL容器forward_list，unordered_map，unordered_multimap，unordered set和unordered_multiset。
容器forward_list是一种单向链表，只能沿一个方向遍历。其他四种容器都是使用哈希表实现的。
C++11还新增了模板array，要实例化这种模板，可指定元素类型和固定的元素数。
由于长度固定，您不能使用任何修改容器大小的方法，如put_back()。但array有begin()和end()方法，
这让您能够对array对象使用众多基于范围的STL算法。
C++11新增了STL方法cbegin()和cend()。与begin()和end()一样，这些新方法也返回一个选代器，
指向容器的第一个元素和最后一个元素的后面，因此可用于指定包含全部元素的区间。
另外，这些新方法将元素视为const。与此类似，crbegin()和crend()是rbegin()和rend()的const版本。
更重要的是，除传统的复制构造函数和常规赋值运算符外，STL容器现在还有移动构造函数和移动赋值运算符。
C++11 添加了两个函数begin()和end()，它们都接受valarray作为参数，并返回迭代器，
这些选代器分别指向valarray对象的第一个元素和最后一个元素后面。这让您能够将基于范围的STL算法用于valarray。
C++11终止了C++98新增的关键字export用法，但仍保留了关键字export，供以后使用。
为避免与运算符>>混淆，C++要求在声明嵌套模板时使用空格将尖括号分开。C++11不再这样要求。
传统的C++引用（现在称为左值引用）使得标识符关联到左值。
左值是一个表示数据的表达式（如变量名或解除引用的指针），程序可获取其地址。
最初，左值可出现在赋值语句的左边，但修饰符const的出现使得可以声明这样的标识符，即不能给它赋值，但可获取其地址。
C++11新增了右值引用，使用&&表示。右值引用可关联到右值，即可出现在赋值表达式右边，但不能对其应用地址运算符。
右值包括字面常量（C风格字符串除外，它表示地址）、诸如x+y等表达式以及返回值的函数（条件是该函数返回的不是引用）。
int x = 10;
int y = 23;
int && r1 = 13;
int && r2 = x + y;
double && r3 = std::sqrt(2.0);
有趣的是，将右值关联到右值引用导致该右值被存储到特定的位置，且可以获取该位置的地址。
也就是说，虽然不能将运算符&用于13，但可将其用于r1。通过将数据与特定的地址关联，使得可以通过右值引用来访问该数据。
程序清单18.1 rvref.cpp
#include <iostream>

inline double f(double tf)
{
    return 5.0 * (tf - 32.0) / 9.0;
};

int main()
{
    double tc = 21.5;
    double &&rd1 = 7.07;
    double &&rd2 = 1.8 * tc + 32.0;
    double &&rd3 = f(rd2);

    std::cout << " tc value and address: " << tc << ", " << &tc << std::endl;
    std::cout << "rd1 value and address: " << rd1 << ", " << &rd1 << std::endl;
    std::cout << "rd2 value and address: " << rd2 << ", " << &rd2 << std::endl;
    std::cout << "rd3 value and address: " << rd3 << ", " << &rd3 << std::endl;

    return 0;
}
显示结果如下
 tc value and address: 21.5, 0x7ffc7f1e7210
rd1 value and address: 7.07, 0x7ffc7f1e7218
rd2 value and address: 70.7, 0x7ffc7f1e7220
rd3 value and address: 21.5, 0x7ffc7f1e7228

引入右值引用的主要目的之一是实现移动语义，C++11支持移动语义。移动语义避免了移动原始数据，而只是修改了记录。
要实现移动语义，需要采取某种方式，让编译器知道什么时候需要复制，什么时候不需要。这就是右值引用发挥作用的地方。
可定义两个构造函数。其中一个是常规复制构造函数，它使用const左值引用作为参数，这个引用关联到左值实参。
另一个是移动构造函数，它使用右值引用作为参数，该引用关联到右值实参。
复制构造函数可执行深复制，而移动构造函数只调整记录。
在将所有权转移给新对象的过程中，移动构造函数可能修改其实参，这意味着右值引用参数不应是const。
程序清单18.2 useless.cpp
#include <iostream>

using namespace std;

class Useless
{
private:
    int n;
    char *pc;
    static int ct;
    void ShowObject() const;
public:
    Useless();
    explicit Useless(int k);
    Useless(int k, char ch);
    Useless(const Useless &f);
    Useless(Useless &&f);
    ~Useless();
    Useless operator+(const Useless &f) const;

    void ShowData() const;
};

int Useless::ct = 0;

Useless::Useless()
{
    ++ct;
    n = 0;
    pc = nullptr;
    cout << "default constructor called; number of objects: " << ct << endl;
    ShowObject();
}
Useless::Useless(int k) : n(k)
{
    ++ct;
    cout << "int constructor called; number of objects: " << ct << endl;
    pc = new char[n];
    ShowObject();
}

Useless::Useless(int k, char ch) : n(k)
{
    ++ct;
    cout << "int, char constructor called; number of objects: " << ct << endl;
    pc = new char[n];
    for (int i = 0; i < n; i++)
    {
        pc[i] = ch;
    }
    ShowObject();
}

Useless::Useless(const Useless &f) : n(f.n)
{
    ++ct;
    cout << "copy const called; number of objects: " << ct << endl;
    pc = new char[n];
    for (int i = 0; i < n; i++)
    {
        pc[i] = f.pc[i];
    }
    ShowObject();
}

Useless::Useless(Useless &&f) : n(f.n)
{
    ++ct;
    cout << "move constructor called; number of objects: " << ct << endl;
    pc = f.pc;
    f.pc = nullptr;
    f.n = 0;
    ShowObject();

}

Useless::~Useless()
{
    cout << "destructor called; objects left: " << --ct << endl;
    cout << "deleted object:\n";
    ShowObject();
    delete[] pc;
}

Useless Useless::operator+(const Useless &f)const
{
    cout << "Entering operator+()\n";
    Useless temp = Useless(n + f.n);
    for (int i = 0; i < n; i++)
    {
        temp.pc[i] = pc[i];
    }
    for (int i = n; i < temp.n; i++)
    {
        temp.pc[i] = f.pc[i - n];
    }
    cout << "temp object:\n";
    cout << "Leaving operator+()\n";
    return temp;
}

void Useless::ShowObject() const
{
    cout << "Number of elements: " << n;
    cout << " Data address: " << (void *)pc << endl;
}

void Useless::ShowData() const
{
    if (n == 0)
    {
        cout << "(object empty)";
    }
    else
    {
        for (int i = 0; i < n; i++)
        {
            cout << pc[i];
        }
    }
    cout << endl;
}

int main()
{
    {
        Useless one(10, 'x');
        Useless two = one;
        Useless three(20, 'o');
        Useless four(one + three);
        cout << "object one: ";
        one.ShowData();
        cout << "object two: ";
        two.ShowData();
        cout << "object three: ";
        three.ShowData();
        cout << "object four: ";
        four.ShowData();
    }

    return 0;
}
显示结果如下
int, char constructor called; number of objects: 1
Number of elements: 10 Data address: 0x5631323e82c0
copy const called; number of objects: 2
Number of elements: 10 Data address: 0x5631323e82e0
int, char constructor called; number of objects: 3
Number of elements: 20 Data address: 0x5631323e8300
Entering operator+()
int constructor called; number of objects: 4
Number of elements: 30 Data address: 0x5631323e8320
temp object:
Leaving operator+()
object one: xxxxxxxxxx
object two: xxxxxxxxxx
object three: oooooooooooooooooooo
object four: xxxxxxxxxxoooooooooooooooooooo
destructor called; objects left: 3
deleted object:
Number of elements: 30 Data address: 0x5631323e8320
destructor called; objects left: 2
deleted object:
Number of elements: 20 Data address: 0x5631323e8300
destructor called; objects left: 1
deleted object:
Number of elements: 10 Data address: 0x5631323e82e0
destructor called; objects left: 0
deleted object:
Number of elements: 10 Data address: 0x5631323e82c0

通过提供一个使用左值引用的构造函数和一个使用右值引用的构造函数，将初始化分成了两组。
使用左值对象初始化对象时，将使用复制构造函数，而使用右值对象初始化对象时，将使用移动构造函数。
程序员可根据需要赋予这些构造函数不同的行为。适用于构造函数的移动语义考虑也适用于赋值运算符。
与移动构造函数一样，移动赋值运算符的参数也不能是const引用。
移动构造函数和移动赋值运算符使用右值。如果要让它们使用左值，可以使用头文件utility中声明的函数std::move()。
程序清单18.3 stdmove.cpp
#include <iostream>
#include <utility>

class Useless
{
private:
    int n;
    char *pc;
    static int ct;
    void ShowObject() const;
public:
    Useless();
    explicit Useless(int k);
    Useless(int k, char ch);
    Useless(const Useless &f);
    Useless(Useless &&f);
    ~Useless();
    Useless operator+(const Useless &f) const;
    Useless &operator=(const Useless &f);
    Useless &operator=(Useless &&f);
    void ShowData() const;
};

int Useless::ct = 0;

Useless::Useless()
{
    ++ct;
    n = 0;
    pc = nullptr;
}

Useless::Useless(int k) : n(k)
{
    ++ct;
    pc = new char[n];
}

Useless::Useless(int k, char ch) : n(k)
{
    ++ct;
    pc = new char[n];
    for (int i = 0; i < n; i++)
    {
        pc[i] = ch;
    }
}

Useless::Useless(const Useless &f) : n(f.n)
{
    ++ct;
    pc = new char[n];
    for (int i = 0; i < n; i++)
    {
        pc[i] = f.pc[i];
    }
}

Useless::Useless(Useless &&f) : n(f.n)
{
    ++ct;
    pc = f.pc;
    f.pc = nullptr;
    f.n = 0;
}

Useless::~Useless()
{
    delete[] pc;
}

Useless &Useless::operator=(const Useless &f)
{
    std::cout << "copy assignment operator called:\n";
    if (this == &f)
    {
        return *this;
    }
    delete[] pc;
    n = f.n;
    pc = new char[n];
    for (int i = 0; i < n; i++)
    {
        pc[i] = f.pc[i];
    }
    return *this;
}

Useless &Useless::operator=(Useless &&f)
{
    std::cout << "move assignment operator called:\n";
    if (this == &f)
    {
        return *this;
    }
    delete[] pc;
    n = f.n;
    pc = f.pc;
    f.n = 0;
    f.pc = nullptr;
    return *this;
}

Useless Useless::operator+(const Useless &f) const
{
    Useless temp = Useless(n + f.n);
    for (int i = 0; i < n; i++)
    {
        temp.pc[i] = pc[i];
    }
    for (int i = n; i < temp.n; i++)
    {
        temp.pc[i] = f.pc[i - n];
    }
    return temp;
}
void Useless::ShowObject() const
{
    std::cout << "Number of elements: " << n;
    std::cout << " Data address: " << (void *) pc << std::endl;
}

void Useless::ShowData() const
{
    if (n == 0)
    {
        std::cout << " (object empty)";
    }
    else
    {
        for (int i = 0; i < n; i++)
        {
            std::cout << pc[i];
        }
    }
    std::cout << std::endl;
}

int main()
{
    using std::cout;
    {
        Useless one(10, 'x');
        Useless two = one + one;
        cout << "object one: ";
        one.ShowData();
        cout << "object two: ";
        two.ShowData();
        Useless three, four;
        cout << "three = one\n";
        three = one;
        cout << "now object three = ";
        three.ShowData();
        cout << "and object one = ";
        one.ShowData();
        cout << "four = one + two\n";
        four = one + two;
        cout << "now object four = ";
        four.ShowData();
        cout << "four = move(one)\n";
        four = std::move(one);
        cout << "now object four = ";
        four.ShowData();
        cout << "and object one = ";
        one.ShowData();
    }

    return 0;
}
显示结果如下
object one: xxxxxxxxxx
object two: xxxxxxxxxxxxxxxxxxxx
three = one
copy assignment operator called:
now object three = xxxxxxxxxx
and object one = xxxxxxxxxx
four = one + two
move assignment operator called:
now object four = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
four = move(one)
move assignment operator called:
now object four = xxxxxxxxxx
and object one =  (object empty)

需要知道的是，函数std:move()并非一定会导致移动操作。如果没有定义移动赋值运算符，编译器将使用复制赋值运算符。
在原有4个特殊成员函数（默认构造函数、复制构造函数、复制赋值运算符和析构函数）的基础上，
C++11新增了两个：移动构造函数和移动赋值运算符。
这些成员函数是编译器在各种情况下自动提供的前面说过，在没有提供任何参数的情况下，将调用默认构造函数。
如果您没有给类定义任何构造函数，编译器将提供一个默认构造函数。这种版本的默认构造函数被称为默认的默认构造函数。
对于使用内置类型的成员，默认的默认构造函数不对其进行初始化；对于属于类对象的成员，则调用其默认构造函数。
另外，如果您没有提供复制构造函数，而代码又需要使用它，编译器将提供一个默认的复制构造函数；
如果您没有提供移动构造函数，而代码又需要使用它，编译器将提供一个默认的移动构造函数。
在类似的情况下，编译器将提供默认的复制运算符和默认的移动运算符。最后，如果您没有提供析构函数，编译器将提供一个。
对于前面描述的情况，有一些例外。
如果您提供了析构函数、复制构造函数或复制赋值运算符，编译器将不会自动提供移动构造函数和移动赋值运算符；
如果您提供了移动构造函数或移动赋值运算符，编译器将不会自动提供复制构造函数和复制赋值运算符。
另外，默认的移动构造函数和移动赋值运算符的工作方式与复制版本类似：
执行逐成员初始化并复制内置类型。如果成员是类对象，将使用相应类的构造函数和赋值运算符，就像参数为右值一样。
如果定义了移动构造函数和移动赋值运算符，这将调用它们；否则将调用复制构造函数和复制赋值运算符。
假定您要使用某个默认的函数，而这个函数由于某种原因不会自动创建。
例如，您提供了移动构造函数，因此编译器不会自动创建默认的构造函数、复制构造函数和复制赋值构造函数。
在这些情况下，您可使用关键字default显式地声明这些方法的默认版本。
编译器将创建在您没有提供移动构造函数的情况下将自动提供的构造函数。
另一方面，关键字delete可用于禁止编译器使用特定方法。例如，要禁止复制对象，可禁用复制构造函数和复制赋值运算符。
第12章说过，要禁止复制，可将复制构造函数和赋值运算符放在类定义的private部分，
但使用delete也能达到这个目的，且更不容易犯错、更容易理解。
如果在启用移动方法的同时禁用复制方法，结果将如何呢？前面说过，移动操作使用的右值引用只能关联到右值表达式，这意味着：
Someclass one;
Someclass two;
Someclass three (one);   // not allowed, one an Ivalue
Someclass four (one + two);   // allowed, expression is an rvalue
关键字default只能用于6个特殊成员函数，但delete可用于任何成员函数。delete的一种可能用法是禁止特定的转换。
如果给类提供了多个构造函数，您可能重复编写相同的代码。也就是说，有些构造函数可能需要包含其他构造函数中已有的代码。
为让编码工作更简单、更可靠，C++11允许您在一个构造函数的定义中使用另一个构造函数。
这被称为委托，因为构造函数暂时将创建对象的工作委托给另一个构造函数。委托使用成员初始化列表语法的变种。
为进一步简化编码工作，C++11提供了一种让派生类能够继承基类构造函数的机制。C++98提供了一种让名称空间中函数可用的语法：
namespace Box
{
    int fn (int) { ... }
    int fn (double) { ... }
    int fn (const char *) { ... }
}
...
using Box::fn;
...
这让函数fn的所有重载版本都可用。也可使用这种方法让基类的所有非特殊成员函数对派生类可用。
class C1
{
public:
    int fn (int j) { ... }
    double fn (double w) { ... }
    void fn (const char * s) { ... }

};
class C2 : public C1
{
public:
    using C1::fn;
    double fn (double) { ... };
};
C2 c2;
int k = c2.fn(3);   // uses C1::fn (int)
double z = c2.fn(2.4);   // uses C2::fn (double)
C2中的using声明让C2对象可使用C1的三个fn()方法，但将选择C2而不是C1定义的方法fn(double)。
C++11将这种方法用于构造函数。这让派生类继承基类的所有构造函数（默认构造函数、复制构造函数和移动构造函数除外），
但不会使用与派生类构造函数的特征标匹配的基类构造函数。注意，派生类要有自己的默认构造函数、复制构造函数和移动构造函数。
继承的基类构造函数只初始化基类成员；如果还要初始化派生类成员，则应使用成员列表初始化语法。
虚方法让基类引用或指针能够根据指向的对象类型调用相应的方法，但虚方法也带来了一些编程陷阱。
例如，假设基类声明了一个虚方法，而您决定在派生类中提供不同的版本，这将覆盖旧版本。
但正如第13章讨论的，如果特征标不匹配，将隐藏而不是覆盖旧版本。
在C+11中，可使用说明符override指出您要覆盖一个虚函数：将其放在参数列表后面。
如果声明与基类方法不匹配，编译器将视为错误。
说明符final解决了另一个问题。您可能想禁止派生类覆盖特定的虚方法，为此可在参数列表后面加上final。
说明符override和final并非关键字，而是具有特殊含义的标识符。
这意味着编译器根据上下文确定它们是否有特殊含义；在其他上下文中，可将它们用作常规标识符，如变量名或枚举。
假设您要生成一个随机整数列表，并判断其中多少个整数可被3整除，多个少整数可被13整除。
生成这样的列表很简单。一种方案是，使用vector<int>存储数字，并使用STL算法generate()在其中填充随机数：
#include <vector>
#include <algorithm>
#include <cmath>
std::vector<int> numbers (1000);
std::generate(numbers.begin(), numbers.end(), std::rand);
函数generate()接受一个区间（由前两个参数指定），并将每个元素设置为第三个参数返回的值，
而第三个参数是一个不接受任何参数的函数对象。在上述示例中，该函数对象是一个指向标准函数rand()的指针。
通过使用算法count_if()，很容易计算出有多少个元素可被3整除。
与函数generate()一样，前两个参数应指定区间，而第三个参数应是一个返回true或false的函数对象。
函数count_if()算这样的元素数，即它使得指定的函数对象返回true。
为判断元素能否被3整除，可使用下面的函数定义：
bool f3(int x) { return x % 3 == 0 }
为判断元素能否被13整除，可使用下面的函数定义：
bool f13(int x) { return x % 13 == 0 }

int count3 = std::count_if(numbers.begin(), numbers.end(), f3);
int count13 = std::count_if(numbers.begin(), numbers.end(), f13);
使用函数符来完成这个任务
class f_mod
{
private:
    int dv;
public:
    f_mod(int d = 1) : dv(d) {}
    bool operator() (int x) { return x % dv == 0;}
};

int count3 = std::count_if(numbers.begin(), numbers.end(), f_mod(3));
int count13 = std::count_if(numbers.begin(), numbers.end(), f_mod(13));

在C++11中，对于接受函数指针或函数符的函数，可使用匿名函数定义（lambda）作为其参数。
与前述函数对应的lambda如下：
[] (int x) { return x % 3 == 0; }
这与f3()的函数定义很像：
bool f3(int x) { return x % 3 == 0 }
差别有两个：使用[]替代了函数名（这就是匿名的由来）；没有声明返回类型。
返回类型相当于使用decltype根据返回值推断得到的，这里为bool。如果lambda不包含返回语句，推断出的返回类型将为void。
就这个示例而言，您将以如下方式使用该lambda：
int count3 = std::count_if(numbers.begin(), numbers.end(), [] (int x) { return x % 3 == 0; });
当lambad表达式完全由一条返回语句组成时，自动类型推断才管用：否则，需要使用新增的返回类型后置语法：
[] (double x) -> double {int y = x; return x - y;}   // return type is double
程序清单18.4 lambda0.cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <ctime>

const long Size1 = 39L;
const long Size2 = 100 * Size1;
const long Size3 = 100 * Size2;

bool f3(int x)
{
    return x % 3 == 0;
}
bool f13(int x)
{
    return x % 13 == 0;
}

int main()
{
    using std::cout;
    std::vector<int> numbers(Size1);
    std::srand(std::time(nullptr));
    std::generate(numbers.begin(), numbers.end(), std::rand);
    cout << "Sample size = " << Size1 << '\n';
    int count3 = std::count_if(numbers.begin(), numbers.end(), f3);
    cout << "Count of numbers divisible by 3: " << count3 << '\n';
    int count13 = std::count_if(numbers.begin(), numbers.end(), f13);
    cout << "Count of numbers divisible by 13: " << count13 << "\n\n";

    numbers.resize(Size2);
    std::generate(numbers.begin(), numbers.end(), std::rand);
    cout << "Sample size = " << Size2 << '\n';

    class f_mod
    {
    private:
        int dv;
    public:
        f_mod(int d = 1) : dv(d) {}
        bool operator () (int x)
        {
            return x % dv == 0;
        }
    };

    count3 = std::count_if(numbers.begin(), numbers.end(), f_mod(3));
    cout << "Count of numbers divisible by 3 : " << count3 << '\n';
    count13 = std::count_if(numbers.begin(), numbers.end(), f_mod(13));
    cout << "Count of numbers divisible by 13: " << count13 << "\n\n";

    numbers.resize(Size3);
    std::generate(numbers.begin(), numbers.end(), std::rand);
    cout << "Sample size = " << Size3 << '\n';

    count3 = std::count_if(numbers.begin(), numbers.end(),
                           [] (int x) -> bool
    {
        return x % 3 == 0;
    });
    cout << "Count of numbers divisible by 3: " << count3 << '\n';
    count13 = std::count_if(numbers.begin(), numbers.end(),
                            [] (int x) -> bool
    {
        return x % 13 == 0;
    });
    cout << "Count of numbers divisible by 13: " << count13 << '\n';

    return 0;
}
显示结果如下
Sample size = 39
Count of numbers divisible by 3: 17
Count of numbers divisible by 13: 5

Sample size = 3900
Count of numbers divisible by 3 : 1332
Count of numbers divisible by 13: 268

Sample size = 390000
Count of numbers divisible by 3: 129294
Count of numbers divisible by 13: 30348

可给lambda指定一个名称
auto mod3 = [] (int x) -> bool { return x % 3 == 0; }   // mod3 a name for the lambda
int count3 = std::count_if(numbers.begin(), numbers.end(), mod3);
您甚至可以像使用常规函数那样使用有名称的lambda：
bool result = mod3(z);   // result is true if z % 3 == 0
lambda可访问作用域内的任何动态变量：要捕获要使用的变量，可将其名称放在中括号内。
如果只指定了变量名，如[z]，将按值访问变量；如果在名称前加上&，如[&count]，将按引用访问变量。
[&]让您能够按引用访问所有动态变量，而[=]让您能够按值访问所有动态变量。
例如，[ted, &ed]让您能够按值访问ted以及按引用访问ed，[&, ted]让您能够按值访问ted以及按引用访问其他所有动态变量，
[=, &ed]让您能够按引用访问ed以及按值访问其他所有动态变量。
程序清单18.5 lambda1.cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <ctime>

const long Size = 390000L;

int main()
{
    using std::cout;
    std::vector<int> numbers(Size);
    std::srand(std::time(nullptr));
    std::generate(numbers.begin(), numbers.end(), std::rand);
    cout << "Sample size = " << Size << '\n';

    int count3 = std::count_if(numbers.begin(), numbers.end(),
                               [] (int x) -> bool {return x % 3 == 0; });
    cout << "Count of numbers divisible by 3 : " << count3 << '\n';
    int count13 = 0;
    std::for_each(numbers.begin(), numbers.end(),
                  [&count13] (int x)
    {
        count13 += (x % 13 == 0);
    });
    cout << "Count of numbers divisible by 13: " << count13 << '\n';

    count3 = count13 = 0;
    std::for_each(numbers.begin(), numbers.end(),
                  [&] (int x)
    {
        count3 += (x % 3 == 0);
        count13 += (x % 13 == 0);
    });
    cout << "Count of numbers divisible by 3: " << count3 << '\n';
    cout << "Count of numbers divisible by 13: " << count13 << '\n';

    return 0;
}
显示结果如下
Sample size = 390000
Count of numbers divisible by 3 : 129948
Count of numbers divisible by 13: 29989
Count of numbers divisible by 3: 129948
Count of numbers divisible by 13: 29989

程序清单18.6 somedefs.h
#ifndef SOMEDEFS_H_
#define SOMEDEFS_H_
#include <iostream>

template <typename T, typename F>
T use_f(T v, F f)
{
    static int count = 0;
    count++;
    std::cout << " use_f count = " << count
              << ", &count = " << &count << std::endl;
    return f(v);
}

class Fp
{
private:
    double z_;
public:
    Fp(double z = 1.0) : z_(z) {}
    double operator () (double p)
    {
        return z_ * p;
    }
};

class Fq
{
private:
    double z_;
public:
    Fq(double z = 1.0) : z_(z) {}
    double operator () (double q)
    {
        return z_ + q;
    }
};

#endif

程序清单18.7 callable.cpp
#include "somedefs.h"

double dub(double x)
{
    return 2.0 * x;
}
double square(double x)
{
    return x * x;
}

int main()
{
    using std::cout;
    using std::endl;
    double y = 1.21;
    cout << "Function pointer dub:\n";
    cout << " " << use_f(y, dub) << endl;
    cout << "Function pointer square:\n";
    cout << " " << use_f(y, square) << endl;
    cout << "Function object Fp:\n";
    cout << " " << use_f(y, Fp(5.0)) << endl;
    cout << "Function object Fq:\n";
    cout << " " << use_f(y, Fq(5.0)) << endl;
    cout << "Lambda expression 1:\n";
    cout << " " << use_f(y, [] (double u) -> double { return u *u; }) << endl;
    cout << "Lambda expression 2:\n";
    cout << " " << use_f(y, [] (double u) -> double { return u + u / 2.0; }) << endl;

    return 0;
}
显示结果如下
Function pointer dub:
  use_f count = 1, &count = 0x562e89e161a0
2.42
Function pointer square:
  use_f count = 2, &count = 0x562e89e161a0
1.4641
Function object Fp:
  use_f count = 1, &count = 0x562e89e161a4
6.05
Function object Fq:
  use_f count = 1, &count = 0x562e89e161a8
6.21
Lambda expression 1:
  use_f count = 1, &count = 0x562e89e16198
1.4641
Lambda expression 2:
  use_f count = 1, &count = 0x562e89e1619c
1.815

程序清单18.8 wrapped.cpp
#include <functional>
#include "somedefs.h"

double dub(double x)
{
    return 2.0 * x;
}
double square(double x)
{
    return x * x;
}

int main()
{
    using std::cout;
    using std::endl;
    using std::function;
    double y = 1.21;
    function<double(double)> ef1 = dub;
    function<double(double)> ef2 = square;
    function<double(double)> ef3 = Fq(10.0);
    function<double(double)> ef4 = Fp(10.0);
    function<double(double)> ef5 = [] (double u) -> double {return u * u; };
    function<double(double)> ef6 = [] (double u) -> double {return u + u / 2.0; };
    cout << "Function pointer dub:\n";
    cout << " " << use_f(y, ef1) << endl;
    cout << "Function pointer square:\n";
    cout << " " << use_f(y, ef2) << endl;
    cout << "Function object Fp:\n";
    cout << " " << use_f(y, ef3) << endl;
    cout << "Function object Fq:\n";
    cout << " " << use_f(y, ef4) << endl;
    cout << "Lambda expression l:\n";
    cout << " " << use_f(y, ef5) << endl;
    cout << "Lambda expression 2:\n";
    cout << " " << use_f(y, ef6) << endl;

    return 0;
}
显示结果如下
Function pointer dub:
  use_f count = 1, &count = 0x5606dc561194
2.42
Function pointer square:
  use_f count = 2, &count = 0x5606dc561194
1.4641
Function object Fp:
  use_f count = 3, &count = 0x5606dc561194
11.21
Function object Fq:
  use_f count = 4, &count = 0x5606dc561194
12.1
Lambda expression l:
  use_f count = 5, &count = 0x5606dc561194
1.4641
Lambda expression 2:
  use_f count = 6, &count = 0x5606dc561194
1.815

#include <functional>
template <typename T>
T use_f (T v, std::function<T (T) > f)
{
    static int count = 0;
    count++;
    std::cout << " use_f count = " << count << ", &count = " << &count << std::endl;
    return f(v);
}

cout << " " << use_f<double>(y, dub) << endl;
cout << " " << use_f<double>(y, Fp(5.0)) << endl;
cout << " " << use_f<double>(y, [] (double u) -> double {return u * u;}) << endl;

可变参数模板
模板参数包（parameter pack）；
函数参数包；
展开（unpack）参数包；
递归。
C++11提供了一个用省略号表示的元运算符（meta-operator），让您能够声明表示模板参数包的标识符，
模板参数包基本上是一个类型列表。同样，它还让您能够声明表示函数参数包的标识符，而函数参数包基本上是一个值列表。其语法如下：
template <typename... Args>
void show_list1(Args... args)
{
    ...
}
其中，Args是一个模板参数包，而args是一个函数参数包。与其他参数名一样，可将这些参数包的名称指定为任何符合C++标识符规则的名称。
Args和T的差别在于，T与一种类型匹配，而Args与任意数量（包括零）的类型匹配。请看下面的函数调用：
show_list1 ('S', 80, "sweet", 4.5);
在这种情况下，参数包Args包含与函数调用中的参数匹配的类型：char，int，const char *和double。
函数参数包args包含的值列表与模板参数包Args包含的类型列表匹配（无论是类型还是数量）。
在上面的示例中，args包含值'S'，80、"sweet"和4.5。
可将省略号放在函数参数包名的右边，将参数包展开。
程序清单18.9 variadic1.cpp
#include <iostream>
#include <string>

void show_list3() {}

template<typename T, typename... Args>
void show_list3(T value, Args... args)
{
    std::cout << value << ", ";
    show_list3(args...);
}

int main()
{
    int n = 14;
    double x = 2.71828;
    std::string mr = "Mr. String objects!";
    show_list3(n, x);
    show_list3(x * x, '!', 7, mr);

    return 0;
}
显示结果如下
14, 2.71828, 7.38905, !, 7, Mr. String objects!, 

在可变参数模板中，可指定展开模式（pattern）。为此，可将下述代码：
show_list3 (Args ... args);
替换为如下代码：
show_list3 (const Args & ... args);
这将对每个函数参数应用模式const &，这样，最后分析的参数将不是std:string mr，而是const std:string & mr。
程序清单18.10 variadic2.cpp
#include <iostream>
#include <string>

void show_list() {}

template<typename T>
void show_list(const T &value)
{
    std::cout << value << '\n';
}

template<typename T, typename ... Args>
void show_list(const T & value, const Args & ... args)
{
    std::cout << value << ", ";
    show_list(args ... );
}

int main()
{
    int n = 14;
    double x = 2.71828;
    std::string mr = "Mr. String objects!";
    show_list(n, x);
    show_list(x * x, '!', 7, mr);

    return 0;
}
显示结果如下
14, 2.71828
7.38905, !, 7, Mr. String objects!

为解决并行编程问题，C++11定义了一个支持线程化执行的内存模型，添加了关键字thread_local，，提供了相关的库支持。
关键字thread_local将变量声明为静态存储，其持续性与特定线程相关，即定义这种变量的线程过期时，变量也将过期。
库支持由原子操作（atomic operation）库和线程支持库组成，其中原子操作库提供了头文件atomic，
而线程支持库提供了头文件thread，mutex，condition_variable和future。
C++11添加了多个专用库。头文件random支持的可扩展随机数库提供了大量比rand()复杂的随机数工具。
例如，您可以选择随机数生成器和分布状态，分布状态包括均匀分布（类似于rand()）、二项式分布和正态分布等。
头文件chrono提供了处理时间间隔的途径。
头文件tuple支持模板tuple，tuple对象是广义的pair对象。
pair对象可存储两个类型不同的值，而tuple对象可存储任意多个类型不同的值。
头文件ratio支持的编译阶段有理数算术库让您能够准确地表示任何有理数，其分子和分母可用最宽的整型表示。
它还支持对这些有理数进行算术运算。
在新增的库中，最有趣的一个是头文件regex支持的正则表达式库。正则表达式指定了一种模式，可用于与文本字符串中的内容匹配。
要获悉有关类型或对象的对齐要求，可使用运算符alignof()，要控制对齐方式，可使用说明符alignas。
constexpr机制让编译器能够在编译阶段计算结果为常量的表达式，让const变量可存储在只读内存中这对嵌入式编程来说很有用
（在运行阶段初始化的变量存储在随机访问内存中）。

18.11 复习题
1.使用用大括号括起的初始化列表语法重写下述代码。重写后的代码不应使用数组ar
class Z200
{
private:
    int j;
    char ch;
    double z;
public:
    Z200(int jv, char chv, zv) : j(jv), ch(chv), z(zv) {}
...
};
double x = 8.8;   // double x {8.8}
std::string s = "What a bracing effect!";   // std::string s {"What a bracing effect!"}
int k(99);   // int k {99};
Z200 zip(200, 'Z', 0.675);   // Z200 zip {200, 'Z', 0.675};
std::vector<int> ai(5);   // std::vector<int> ai {3, 9 ,4, 7, 1};
int ar[5] = {3, 9, 4, 7, 1};
for (auto pt = ai.begin(), int i = 0; pt != ai.end(); ++pt, ++i)
{
    *pt = ar[i];
}

2.在下述简短的程序中，哪些函数调用不对？为什么？对于合法的函数调用，指出其引用参数指向的是什么。
#include <iostream>

using namespace std;

double up(double x)
{
    return 2.0 * x;
}
void r1(const double &rx)
{
    cout << rx << endl;
}
void r2(double &rx)
{
    cout << rx << endl;
}
void r3(double &&rx)
{
    cout << rx << endl;
}
int main()
{
    double w = 10.0;
    r1(w);   // 合法，指向w
    r1(w + 1);   //合法，指向临时变量（被初始化为w+1）
    r1(up(w));   //合法，指向临时变量（被初始化为up(w)）
    r2(w);   // 合法，指向w
    r2(w + 1);   // 非法，w+1是一个右值
    r2(up(w));   // 非法，up(w)的返回值是一个右值
    r3(w);   // 非法，右值引用不能指向左值
    r3(w + 1);   //合法，指向表达式w+1的临时拷贝
    r3(up(w));   //合法，指向up(w)的临时返回值
    return 0;
}

3.a.下述简短的程序显示什么？为什么？
#include <iostream>

using namespace std;

double up(double x)
{
    return 2.0 * x;
}
void r1(const double &rx)
{
    cout << "const double & rx\n";
}
void r1(double &rx)
{
    cout << "double & rx\n";
}
int main()
{
    double w = 10.0;
    r1(w);   //double & rx
    r1(w + 1);   //const double & rx
    r1(up(w));   //const double & rx
    return 0;
}
b.下述简短的程序显示什么？为什么？
#include <iostream>

using namespace std;

double up(double x)
{
    return 2.0 * x;
}
void r1(double &rx)
{
    cout << "double & rx\n";
}
void r1(double &&rx)
{
    cout << "double && rx\n";
}
int main()
{
    double w = 10.0;
    r1(w);   //double & rx
    r1(w + 1);   //double && rx
    r1(up(w));   //double && rx
    return 0;
}
c.下述简短的程序显示什么？为什么？
#include <iostream>
using namespace std;

double up(double x)
{
    return 2.0 * x;
}
void r1(const double &rx)
{
    cout << "const double &rx\n";
}
void r1(double &&rx)
{
    cout << "double &&rx\n";
}
int main()
{
    double w = 10.0;
    r1(w);   //const double & rx
    r1(w + 1);   //double && rx
    r1(up(w));   //double && rx
    return 0;
}
4，哪些成员函数是特殊的成员函数？它们特殊的原因是什么？
默认构造函数、复制构造函数、移动构造函数、析构函数、复制赋值运算符和移动赋值运算符
编译器将根据情况自动提供它们的默认版本。

5，假设Fizzle类只有如下所示的数据成员：
class Fizzle
{
private:
    double bubbles[4000];
    ...
};
为什么不适合给这个类定义移动构造函数？要让这个类适合定义移动构造函数，应如何修改存储4000个doublef的方式？
对于标准数组，没有转让其所有权的机制。如果Fizzle使用指针和动态内存分配，则可将数据的地址赋给新指针，以转让其所有权。

6，修改下述简短的程序，使其使用lambda表达式而不是f1()。请不要修改show2()。
#include <iostream>
#include <algorithm>

template<typename T> 
void show2(double x, T & fp)
{
    std::cout << x << " -> " << fp(x) << '\n';
}
double f1(double x)
{
    return 1.8 * x + 32;
}
int main()
{
    show2(18.0, f1);   //show2(18.0, [] (double x) -> double {return 1.8 * x + 32;});
    return 0;
}

7.修改下述简短而丑陋的程序，使其使用lambda表达式而不是函数符Adder。请不要修改sum()。
#include <iostream>
#include <array>
#include <algorithm>

const int Size = 5;

template<typename T>
void sum(std::array<double, Size> & a, T & fp);

class Adder
{
    double tot;
public:
    Adder(double q = 0) : tot(q) {}
    void operator()(double w)
    {
        tot += w;
    }
    double tot_v () const
    {
        return tot;
    };
};
int main()
{
    double total = 0.0;
    Adder ad(total);
    std::array<double, Size> temp_c = {32.1, 34.3, 37.8, 35.2, 34.7};
    sum(temp_c, ad);   // sum (temp_c, [&total] (double w) {total += w;});
    total = ad.tot_v();
    std::cout << "total: " << total << '\n';
    return 0;
}
template<typename T>
void sum(std::array<double, Size> & a, T & fp)
{
    for(auto pt = a.begin(); pt != a.end(); ++pt)
    {
        fp(*pt);
    }
}

18.12 编程练习
1.下面是一个简短程序的一部分：
int main()
{
    using namespace std;
    auto q = average_list({15.4, 10.7, 9.0});
    cout << q << endl;
    cout << average_list({20, 30, 19, 17, 45, 38})<< endl;
    auto ad = average_list<double>({'A', 70, 65.33});
    cout << ad << endl;
    return 0;
}
请提供函数average list()，让该程序变得完整。它应该是一个模板函数，
其中的类型参数指定了用作函数参数的intitlize_list模板的类型以及函数的返回类型。
#include <iostream>
#include <initializer_list>

template <typename T>
T average_list(std::initializer_list<T> il)
{
    T sum = 0;
    for (auto pi = il.begin(); pi != il.end(); pi++)
    {
        sum += *pi;
    }
    T average = sum / il.size();
    return average;
}

int main()
{
    auto q = average_list({ 15.4, 10.7, 9.0 });
    std::cout << q << std::endl;

    std::cout << average_list({ 20, 30, 19, 17, 45, 38 }) << std::endl;

    auto ad = average_list<double>({ 'A', 70, 65.33 });
    std::cout << ad << std::endl;

    return 0;
}
显示结果如下
11.7
28
66.7767

2.下面是类Cpmv的声明：
class Cpmv
{
public:
    struct Info
    {
        std::string qcode;
        std::string zcode;
    };
private:
    Info *pi;
public:
    Cpmv();
    Cpmv(std::string q, std::string z);
    Cpmv(const Cpmv &cp);
    Cpmv(Cpmv &&mv);
    ~Cpmv();
    Cpmv &operator=(const Cpmv &cp);
    Cpmv &operator=(Cpmv &&mv);
    Cpmv operator+(const Cpmv &obj) const;
    void Display() const;
};
函数operator+()应创建一个对象，其成员qcode和zcode由操作数的相应成员拼接而成。
请提供为移动构造函数和移动赋值运算符实现移动语义的代码。编写一个使用所有这些方法的程序。
为方便测试，让各个方法都显示特定的内容，以便知道它们被调用。
#include <iostream>
#include <string>

class Cpmv
{
public:
    struct Info
    {
        std::string qcode;
        std::string zcode;
    };
private:
    Info *pi;
public:
    Cpmv();
    Cpmv(std::string q, std::string z);
    Cpmv(const Cpmv &cp);
    Cpmv(Cpmv &&mv);
    ~Cpmv();

    Cpmv &operator = (const Cpmv &cp);
    Cpmv &operator = (Cpmv &&mv);
    Cpmv operator + (const Cpmv &obj) const;
    void Display() const;
};

Cpmv::Cpmv()
{
    pi = new Info;
    std::cout << "Default constructor called\n";
    std::cout << "Address " << (void *)pi << std::endl << std::endl;
}

Cpmv::Cpmv(std::string q, std::string z)
{
    pi = new Info;
    pi->qcode = q;
    pi->zcode = z;
    std::cout << "q and z constructor called\n";
    std::cout << "Address " << (void *)pi << std::endl << std::endl;
}

Cpmv::Cpmv(const Cpmv &cp)
{
    std::cout << "Copy constructor called\n";
    pi = new Info;
    pi->qcode = cp.pi->qcode;
    pi->zcode = cp.pi->zcode;
    std::cout << "Address " << (void *)pi << std::endl << std::endl;
}

Cpmv::Cpmv(Cpmv && mv)
{
    std::cout << "Move constructor called\n";
    pi = new Info;
    pi = mv.pi;
    mv.pi = nullptr;
    std::cout << "Address " << (void *)pi << std::endl << std::endl;
}

Cpmv Cpmv::operator + (const Cpmv &obj) const
{
    std::cout << "Entering operator +()\n";
    Cpmv temp;
    temp.pi->qcode = pi->qcode + obj.pi->qcode;
    temp.pi->zcode = pi->zcode + obj.pi->zcode;

    std::cout << "Leaving operator+()\n";
    return temp;
}

Cpmv &Cpmv::operator = (const Cpmv &cp)
{
    std::cout << "Entering operator=(const Cpmv & cp)\n";

    if (this == &cp)
    {
        return *this;
    }

    delete pi;
    pi = new Info;
    pi->qcode = cp.pi->qcode;
    pi->zcode = cp.pi->zcode;

    std::cout << "Leaving operator=()\n";
    return *this;
}

Cpmv &Cpmv::operator = (Cpmv &&mv)
{
    std::cout << "Entering operator=(Cpmv && mv)\n";

    if (this == &mv)
    {
        return *this;
    }

    delete pi;
    pi = mv.pi;
    mv.pi = nullptr;

    std::cout << "Address " << (void *)pi << std::endl << std::endl;
    return *this;
}

Cpmv::~Cpmv()
{
    std::cout << "Destructor called\n";
    std::cout << "Address " << (void *)pi << std::endl << std::endl;

    delete pi;
}

void Cpmv::Display() const
{
    if (pi == nullptr)
    {
        std::cout << "Empty object\n";
    }
    else
    {
        std::cout << " " << pi->qcode << ", ";
        std::cout << pi->zcode << std::endl;
    }
}

int main()
{
    {
        Cpmv one("Hi ", "Sunny");
        Cpmv two = one;

        Cpmv three("Hello", "World!");
        Cpmv four = one + three;

        Cpmv five;
        five = one;

        Cpmv six;
        six = five + three;

        std::cout << "\nobject 1";
        one.Display();

        std::cout << "\nobject 2";
        two.Display();

        std::cout << "\nobject 3";
        three.Display();

        std::cout << "\nobject 4";
        four.Display();

        std::cout << "\nobject 5";
        five.Display();

        std::cout << "\nobject 6";
        six.Display();
    }
    std::cout << std::endl;

    return 0;
}
显示结果如下
q and z constructor called
Address 0x561e7f070eb0

Copy constructor called
Address 0x561e7f071310

q and z constructor called
Address 0x561e7f071360

Entering operator +()
Default constructor called
Address 0x561e7f0713b0

Leaving operator+()
Default constructor called
Address 0x561e7f071400

Entering operator=(const Cpmv & cp)
Leaving operator=()
Default constructor called
Address 0x561e7f071450

Entering operator +()
Default constructor called
Address 0x561e7f0714a0

Leaving operator+()
Entering operator=(Cpmv && mv)
Address 0x561e7f0714a0

Destructor called
Address 0


object 1 Hi , Sunny

object 2 Hi , Sunny

object 3 Hello, World!

object 4 Hi Hello, SunnyWorld!

object 5 Hi , Sunny

object 6 Hi Hello, SunnyWorld!
Destructor called
Address 0x561e7f0714a0

Destructor called
Address 0x561e7f071400

Destructor called
Address 0x561e7f0713b0

Destructor called
Address 0x561e7f071360

Destructor called
Address 0x561e7f071310

Destructor called
Address 0x561e7f070eb0

3，编写并测试可变参数模板函数sum_values()，它接受任意长度的参数列表（其中包含数值，但可以是任何类型），并以long double的方式返回这些数值的和。
#include <iostream>
#include <iomanip>

long double sum_values()
{
    return 0.0;
}

template <typename T, typename ... Args>
long double sum_values(const T &value, const Args &... args)
{
    long double sum = 0;
    sum = value + sum_values(args ...);
    return sum;
}

int main()
{
    std::cout << std::fixed;
    std::cout << sum_values(5, 5, 5) << std::endl;
    std::cout << std::setprecision(10) << sum_values(20.0, 1.0, 8.6578787879, 1) << std::endl;

    return 0;
}
显示结果如下
15.000000
30.6578787879

4.使用lambda重新编写程序清单16.15，具体地说，使用一个有名称的lambda替换函数outint()，并将函数符替换为两个匿名lambda表达式。
#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>

int main()
{
    int vals[10] = { 50, 100, 90, 180, 60, 210, 415, 88, 188, 201 };
    std::list<int> yadayada(vals, vals + 10);
    std::list<int> etcetera(vals, vals + 10);

    auto outint = [](int n)
    {
        std::cout << n << " ";
    };
    std::cout << "Original lists:\n";
    std::for_each(yadayada.begin(), yadayada.end(), outint);
    std::cout << std::endl;
    std::for_each(etcetera.begin(), etcetera.end(), outint);
    std::cout << std::endl;

    yadayada.remove_if([](int x)
    {
        return x > 100;
    });
    etcetera.remove_if([](int x)
    {
        return x > 200;
    });

    std::cout << "Trimmed lists:\n";
    std::for_each(yadayada.begin(), yadayada.end(), outint);
    std::cout << std::endl;
    std::for_each(etcetera.begin(), etcetera.end(), outint);
    std::cout << std::endl;

    return 0;
}
显示结果如下
Original lists:
50 100 90 180 60 210 415 88 188 201
50 100 90 180 60 210 415 88 188 201
Trimmed lists:
50 100 90 60 88
50 100 90 180 60 88 188
