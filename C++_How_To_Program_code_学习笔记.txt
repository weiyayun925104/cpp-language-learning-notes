C++大学教程第九版 C++ How to Program 9th
第2章 C++编程入门、输入/输出和运算符
2.1 简介
2.2 第一个C++程序：输出一行文本
2.3 修改第一个C++程序
2.4 另一个C++程序：整数相加
2.5 内存的概念
2.6 算术运算
2.7 判断：相等运算符和关系运算符
2.8 本章小结
ch02_b01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Welcome to C++!" << std::endl;
        std::cout << "Welcome ";
        std::cout << "to C++!" << std::endl;
        std::cout << "Welcome\nto\nC++!" << std::endl;
        int number1;
        int number2;
        int sum;

        std::cout << "Enter first integer: ";
        std::cin >> number1;

        std::cout << "Enter second integer: ";
        std::cin >> number2;

        sum = number1 + number2;

        std::cout << "Sum is " << sum << std::endl;

        std::cout << "Enter two integers to compare: ";
        std::cin >> number1 >> number2;

        if (number1 == number2)
        {
            std::cout << number1 << " == " << number2 << std::endl;
        }
        if (number1 != number2)
        {
            std::cout << number1 << " != " << number2 << std::endl;
        }
        if (number1 < number2)
        {
            std::cout << number1 << " < " << number2 << std::endl;
        }
        if (number1 > number2)
        {
            std::cout << number1 << " > " << number2 << std::endl;
        }
        if (number1 <= number2)
        {
            std::cout << number1 << " <= " << number2 << std::endl;
        }
        if (number1 >= number2)
        {
            std::cout << number1 << " >= " << number2 << std::endl;
        }
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Welcome to C++!
Welcome to C++!
Welcome
to
C++!
Enter first integer: 33
Enter second integer: 55
Sum is 88
Enter two integers to compare: 22 66
22 != 66
22 < 66
22 <= 66

ch02_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        int a, b, c;

        std::cout << "Enter two numbers ";
        std::cin >> b >> c;

        a = b * c;
        cout << a << ", " << b << ", " << c << endl;

        std::cout << "This program performs a payroll calculation" << std::endl;
        std::cout << "Enter three integer values ";

        std::cin >> a >> b >> c;
        cout << a << ", " << b << ", " << c << endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter two numbers 3 5
15, 3, 5
This program performs a payroll calculation
Enter three integer values 2 6 9
2, 6, 9

ch02_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        int num1, num2;

        std::cout << "Enter two integers: ";
        std::cin >> num1 >> num2;

        std::cout << num1 << " + " << num2 << " = " << num1 + num2 << std::endl;
        std::cout << num1 << " * " << num2 << " = " << num1 *num2 << std::endl;
        std::cout << "Difference of " << num1 << " and " << num2 << " = " << abs(num1 - num2) << std::endl;
        std::cout << num1 << " / " << num2 << " = " << num1 / num2 << std::endl;
        std::cout << num1 << " % " << num2 << " = " << num1 % num2 << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter two integers: 3 13
3 + 13 = 16
3 * 13 = 39
Difference of 3 and 13 = 10
3 / 13 = 0
3 % 13 = 3

Enter two integers: 13 3
13 + 3 = 16
13 * 3 = 39
Difference of 13 and 3 = 10
13 / 3 = 4
13 % 3 = 1

ch02_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "1 2 3 4" << std::endl;
        std::cout << "1 "
                  << "2 "
                  << "3 "
                  << "4 " << std::endl;
        std::cout << "1 ";
        std::cout << "2 ";
        std::cout << "3 ";
        std::cout << "4 " << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
1 2 3 4
1 2 3 4
1 2 3 4

ch02_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template <typename T>
const T & my_max(const T & a, const T & b)
{
    return (a > b) ? a : b;
}

int main(int argc, const char *argv[])
{
    try
    {
        int num1, num2;

        std::cout << "Enter two integers: ";
        std::cin >> num1 >> num2;

        if (num1 == num2)
        {
            std::cout << "These numbers are equal" << std::endl;
        }
        else
        {
            std::cout << my_max(num1, num2) << " is Larger." << std::endl;
        }
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter two integers: 33 55
55 is Larger.

Enter two integers: 33 33
These numbers are equal

ch02_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template <typename T>
const T &my_max(const T &a, const T &b)
{
    return (a > b) ? a : b;
}

template <typename T>
const T &my_min(const T &a, const T &b)
{
    return (a < b) ? a : b;
}

int main(int argc, const char *argv[])
{
    try
    {
        int num1, num2, num3;

        std::cout << "Input three different integers: ";
        std::cin >> num1 >> num2 >> num3;

        std::cout << "Sum is " << num1 + num2 + num3 << std::endl;
        std::cout << "Average is " << (num1 + num2 + num3) / 3 << std::endl;
        std::cout << "Product is " << num1 *num2 *num3 << std::endl;
        std::cout << "Smallest is " << my_min(num1, my_min(num2, num3)) << std::endl;
        std::cout << "Largest is " << my_max(num1, my_max(num2, num3)) << std::endl;
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Input three different integers: 33 55 99
Sum is 187
Average is 62
Product is 179685
Smallest is 33
Largest is 99

ch02_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

const double PI = 3.14159;

int main(int argc, const char *argv[])
{
    try
    {
        int radius;

        std::cout << "Enter an integer value circle radius: ";
        std::cin >> radius;

        std::cout << "Diameter: " << 2 * radius << std::endl;
        std::cout << "Circumference: " << PI * (2 * radius) << std::endl;
        std::cout << "Area: " << PI * (radius * radius) << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter an integer value circle radius: 5
Diameter: 10
Circumference: 31.4159
Area: 78.5397

ch02_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "*********     ***       *         *" << std::endl;
        std::cout << "*       *    *   *     ***       *  *" << std::endl;
        std::cout << "*       *   *     *   *****     *    *" << std::endl;
        std::cout << "*       *   *     *     *      *      *" << std::endl;
        std::cout << "*       *   *     *     *     *        *" << std::endl;
        std::cout << "*       *   *     *     *      *      *" << std::endl;
        std::cout << "*       *   *     *     *       *    *" << std::endl;
        std::cout << "*       *    *   *      *        *  *" << std::endl;
        std::cout << "*********     ***       *          *" << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
*********     ***       *         *
*       *    *   *     ***       *  *
*       *   *     *   *****     *    *
*       *   *     *     *      *      *
*       *   *     *     *     *        *
*       *   *     *     *      *      *
*       *   *     *     *       *    *
*       *    *   *      *        *  *
*********     ***       *          *

ch02_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


template <typename T>
const T &my_max(const T &a, const T &b)
{
    return (a > b) ? a : b;
}

template <typename T>
const T &my_min(const T &a, const T &b)
{
    return (a < b) ? a : b;
}

int main(int argc, const char *argv[])
{
    try
    {
        int num1, num2, num3, num4, num5;

        std::cout << "Enter five integers: ";
        std::cin >> num1 >> num2 >> num3 >> num4 >> num5;

        std::cout << "Max: " << my_max(num1, my_max(num2, my_max(num3, my_max(num4, num5)))) << std::endl;
        std::cout << "Min: " << my_min(num1, my_min(num2, my_min(num3, my_min(num4, num5)))) << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter five integers: 3 5 9 6 2
Max: 9
Min: 2

ch02_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        int num1;

        std::cout << "Enter an integer: ";
        std::cin >> num1;

        std::cout << num1 << " is " << ((num1 % 2 == 0) ? "even" : "odd") << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter an integer: 6
6 is even

Enter an integer: 7
7 is odd

ch02_p10.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        int num1, num2;

        std::cout << "Enter two integers: ";
        std::cin >> num1 >> num2;

        std::cout << num1 << ((num1 % num2 == 0) ? " is " : " is not ")
                  << "a multiple of " << num2 << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter two integers: 15 5
15 is a multiple of 5

Enter two integers: 15 3
15 is a multiple of 3

Enter two integers: 15 6
15 is not a multiple of 6

ch02_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        std::string row = "* * * * * * * *";

        std::cout << "Eight Output Statements:\n" << std::endl;

        std::cout << row << std::endl;
        std::cout << ' ' << row << std::endl;
        std::cout << row << std::endl;
        std::cout << ' ' << row << std::endl;
        std::cout << row << std::endl;
        std::cout << ' ' << row << std::endl;
        std::cout << row << std::endl;
        std::cout << ' ' << row << std::endl;

        std::cout << "\nFor Loop:\n" << std::endl;
        for (int i = 0; i < 8; ++i)
        {
            if (i % 2 != 0)
            {
                std::cout << ' ';
            }

            std::cout << row << std::endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Eight Output Statements:

* * * * * * * *
 * * * * * * * *
* * * * * * * *
 * * * * * * * *
* * * * * * * *
 * * * * * * * *
* * * * * * * *
 * * * * * * * *

For Loop:

* * * * * * * *
 * * * * * * * *
* * * * * * * *
 * * * * * * * *
* * * * * * * *
 * * * * * * * *
* * * * * * * *
 * * * * * * * *

ch02_p12.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        char char1;

        std::cout << "Enter a character: ";
        std::cin >> char1;

        std::cout << "Integer equivalent of " << char1 << ": " 
                       << static_cast<int>(char1) << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter a character: A
Integer equivalent of A: 65

Enter a character: a
Integer equivalent of a: 97

Enter a character: Z
Integer equivalent of Z: 90

Enter a character: z
Integer equivalent of z: 122

Enter a character: M
Integer equivalent of M: 77

Enter a character: m
Integer equivalent of m: 109

ch02_p13.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

void printDigits(int num)
{
    static const std::string SPACES = "   ";
    if (num / 10 > 0)
    {
        printDigits(num / 10);
    }

    std::cout << num % 10 << SPACES;
}


int main(int argc, const char *argv[])
{
    try
    {
        int num;

        std::cout << "Enter a five digit integer: ";
        std::cin >> num;

        printDigits(num);

        std::cout << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter a five digit integer: 34567
3   4   5   6   7

ch02_p14.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "integer square  cube" << std::endl;

        for (int i = 0; i <= 10; ++i)
        {
            std::cout << i << "\t" << (i * i) << "\t" << (i * i * i) << std::endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
integer square  cube
0       0       0
1       1       1
2       4       8
3       9       27
4       16      64
5       25      125
6       36      216
7       49      343
8       64      512
9       81      729
10      100     1000

ch02_p15.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template <typename T>
T my_BMI(const T &w, const T &h)
{
    return (w * 703) / (h * h);
}

void print_BMI_info()
{
    std::cout << "\nBMI VALUES" << std::endl;
    std::cout << "Underweight: less than 18.5" << std::endl;
    std::cout << "Normal:      between 18.5 and 24.9" << std::endl;
    std::cout << "Overweight:  between 25 and 29.9" << std::endl;
    std::cout << "Obese:       30 or greater\n" << std::endl;
}


int main(int argc, const char *argv[])
{
    try
    {
        double weight, height;

        std::cout << "Enter you weight in pounds: ";
        std::cin >> weight;

        std::cout << "Enter your height in inches: ";
        std::cin >> height;

        std::cout << std::setprecision(2) << std::fixed
                  << "\nBMI: " << my_BMI(weight, height) << std::endl;

        print_BMI_info();

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter you weight in pounds: 136
Enter your height in inches: 67

BMI: 21.30

BMI VALUES
Underweight: less than 18.5
Normal:      between 18.5 and 24.9
Overweight:  between 25 and 29.9
Obese:       30 or greater

ch02_p16.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        double milesDriven = 0, costPerGallon = 0, milesPerGallon = 0,
               parkingFees = 0, dailyTolls = 0, dailyDrivingCost = 0;

        std::cout << "Enter your total miles driven per day: ";
        std::cin >> milesDriven;

        std::cout << "Enter your cost per gallon of gasoline: ";
        std::cin >> costPerGallon;

        std::cout << "Enter your average miles per gallon: ";
        std::cin >> milesPerGallon;

        std::cout << "Enter your parking fees per day: ";
        std::cin >> parkingFees;

        std::cout << "Enter your tolls per day: ";
        std::cin >> dailyTolls;

        dailyDrivingCost = ((milesDriven / milesPerGallon) * costPerGallon) +
                           parkingFees + dailyTolls;

        std::cout << "\nDaily Driving Cost: " << dailyDrivingCost << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter your total miles driven per day: 30
Enter your cost per gallon of gasoline: 11
Enter your average miles per gallon: 15
Enter your parking fees per day: 6
Enter your tolls per day: 9

Daily Driving Cost: 37

第3章 类、对象和字符串的介绍
3.1 简介
3.2 定义具有成员函数的类
3.3 定义具有形参的成员函数
3.4 数据成员、set成员函数和get成员函数
3.5 使用构造函数初始化对象
3.6 一个类对应一个独立文件的可复用性
3.7 接口与实现的分离
3.8 用set函数确认数据的有效性
3.9 本章小结
ch03_b01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class GradeBook
{
private:
    std::string courseName;
public:
    explicit GradeBook(const std::string &name) : courseName(name) { }
    void setCourseName(const std::string &name)
    {
        if (name.size() <= 25)
        {
            courseName = name;
        }
        else
        {
            courseName = name.substr(0, 25);

            std::cout << "Name \"" << name << "\" exceeds maximum length (25).\n";
            std::cout << "Limiting courseName to first 25 characters.\n";
        }
    }
    const std::string &getCourseName()
    {
        return courseName;
    }
    void displayMessage()
    {
        std::cout << "Welcome to the grade book for\n"
                  << getCourseName() << "!" << std::endl;
    }
};
int main(int argc, const char *argv[])
{
    try
    {
        GradeBook gradeBook1("CS101 Introduction to Programming in C++");
        GradeBook gradeBook2("CS102 Data Structures in C++");

        std::cout << "gradeBook1 initial course name: " << gradeBook1.getCourseName() << std::endl;
        std::cout << "gradeBook2 initial course name: " << gradeBook2.getCourseName() << std::endl;

        gradeBook1.setCourseName("CS101 Introduction to C++ Programming");

        std::cout << "gradeBook1 course name: " << gradeBook1.getCourseName() << std::endl;
        std::cout << "gradeBook2 course name: " << gradeBook2.getCourseName() << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
gradeBook1 initial course name: CS101 Introduction to Programming in C++
gradeBook2 initial course name: CS102 Data Structures in C++
Name "CS101 Introduction to C++ Programming" exceeds maximum length (25).
Limiting courseName to first 25 characters.
gradeBook1 course name: CS101 Introduction to C++
gradeBook2 course name: CS102 Data Structures in C++

ch03_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class GradeBook
{
private:
    std::string courseName;
    std::string instructorName;
public:
    GradeBook(const std::string &cn, const std::string &in) : courseName(cn), instructorName(in) { }

    void setCourseName(const std::string &cn)
    {
        courseName = cn;
    }
    void setInstructorName(const std::string &in)
    {
        instructorName = in;
    }
    const std::string &getCourseName()
    {
        return courseName;
    }
    const std::string &getInstructorName()
    {
        return instructorName;
    }

    void displayMessage()
    {
        std::cout << "Welcome to the grade book for " << getCourseName() << "!\n"
                  << "This course is presented by " << getInstructorName() << std::endl;
    }
};

int main(int argc, const char *argv[])
{
    try
    {
        GradeBook gradeBook1("CS102 Data Structures in C++", "Mike Pence");

        gradeBook1.displayMessage();

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Welcome to the grade book for CS102 Data Structures in C++!
This course is presented by Mike Pence

ch03_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template <typename T>
class Account
{
private:
    T accountBalance;
public:
    explicit Account(const T &v) : accountBalance(v)
    {
        if (v < 0)
        {
            std::cerr << "Error: Unable to initialise negative balance." << std::endl;
            accountBalance = 0;
        }
    }

    const T &getBalance() const
    {
        return accountBalance;
    }

    void credit(const T &v)
    {
        if (v > 0)
        {
            accountBalance = (accountBalance + v);
        }
        else
        {
            std::cerr << "Error: v <= 0 in credit(const T &v)." << std::endl;
        }
    }

    void debit(const T &v)
    {
        if (v > 0 && v > accountBalance)
        {
            std::cerr << "Error: v > accountBalance in debit(const T &v)." << std::endl;
        }
        else if (v > 0 && v <= accountBalance)
        {
            accountBalance = (accountBalance - v);
        }
        else
        {
            std::cerr << "Error: v <= 0 in debit(const T &v)." << std::endl;
        }
    }
};

int main(int argc, const char *argv[])
{
    try
    {
        Account<int> acc1(500);
        Account<int> acc2(1500);

        std::cout << "acc1 initial balance: " << acc1.getBalance() << std::endl;
        std::cout << "acc2 initial balance: " << acc2.getBalance() << std::endl;

        acc1.credit(150);
        acc1.debit(50);

        acc2.credit(500);
        acc2.debit(2000);

        std::cout << "acc1 new balance: " << acc1.getBalance() << std::endl;
        std::cout << "acc2 new balance: " << acc2.getBalance() << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
acc1 initial balance: 500
acc2 initial balance: 1500
acc1 new balance: 600
acc2 new balance: 0

ch03_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Invoice
{
private:
    std::string partNumber;
    std::string partDescription;

    int itemQuantity;
    int pricePerItem;
public:
    Invoice(const std::string &number, const std::string &description, int quantity, int price)
        : partNumber(number), partDescription(description), itemQuantity(quantity), pricePerItem(price)
    {
        if (quantity < 0)
        {
            itemQuantity = 0;
        }
        if (price < 0)
        {
            pricePerItem = 0;
        }
    }

    void setPartNumber(const std::string &number)
    {
        partNumber = number;
    }
    void setPartDescription(const std::string &description)
    {
        partDescription = description;
    }
    void setItemQuantity(int quantity)
    {
        itemQuantity = (quantity >= 0) ? quantity : 0;
    }
    void setPricePerItem(int price)
    {
        pricePerItem = (price >= 0) ? price : 0;
    }

    const std::string &getPartNumber() const
    {
        return partNumber;
    }
    const std::string &getPartDescription() const
    {
        return partDescription;
    }
    int getItemQuantity() const
    {
        return itemQuantity;
    }
    int getPricePerItem() const
    {
        return pricePerItem;
    }

    int getInvoiceAmount() const
    {
        return (getItemQuantity() * getPricePerItem());
    }
};

int main(int argc, const char *argv[])
{
    try
    {
        Invoice invoice1("12345", "Hammer", 12, 6);

        std::cout << "Part Number: " << invoice1.getPartNumber() << std::endl;
        std::cout << "Part Description: " << invoice1.getPartDescription() << std::endl;
        std::cout << invoice1.getItemQuantity() << " x " << invoice1.getPricePerItem();
        std::cout << " = " << invoice1.getInvoiceAmount() << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Part Number: 12345
Part Description: Hammer
12 x 6 = 72

ch03_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


class Employee
{
private:
    std::string firstName;
    std::string lastName;
    int monthlySalary;
public:
    Employee(const std::string &fName, const std::string &lName, int mSalary)
        : firstName(fName), lastName(lName), monthlySalary(mSalary)
    {
        if (mSalary < 0)
        {
            monthlySalary = 0;
        }
    }

    void setFirstName(const std::string &fName)
    {
        firstName = fName;
    }
    void setLastName(const std::string &lName)
    {
        lastName = lName;
    }
    void setMonthlySalary(int mSalary)
    {
        monthlySalary = (mSalary >= 0) ? mSalary : 0;
    }

    const std::string &getFirstName() const
    {
        return firstName;
    }
    const std::string &getLastName() const
    {
        return lastName;
    }
    int getMonthlySalary() const
    {
        return monthlySalary;
    }
    int calculateSalary(int months) const
    {
        return (getMonthlySalary() * months);
    }

    void giveRaise(int percent)
    {
        if (percent > 0)
        {
            monthlySalary += (monthlySalary / 100.0) * percent;
        }
        else
        {
            std::cerr << "Error: percent <= 0 in giveRaise(int percent).\n";
        }
    }

    void showEmployee() const
    {
        std::cout << "Name: " << getFirstName() << " " << getLastName() << std::endl
                  << "Monthly Salary: " << getMonthlySalary()  << std::endl
                  << "Yearly Salary: " << calculateSalary(12) << std::endl;
    }
};

int main(int argc, const char *argv[])
{
    try
    {
        Employee emp1("Bob", "Bobson", 1200);
        Employee emp2("Sue", "Sueson", 2000);

        emp1.showEmployee();
        emp2.showEmployee();

        emp1.giveRaise(10);
        emp2.giveRaise(10);

        emp1.showEmployee();
        emp2.showEmployee();

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Name: Bob Bobson
Monthly Salary: 1200
Yearly Salary: 14400
Name: Sue Sueson
Monthly Salary: 2000
Yearly Salary: 24000
Name: Bob Bobson
Monthly Salary: 1320
Yearly Salary: 15840
Name: Sue Sueson
Monthly Salary: 2200
Yearly Salary: 26400

ch03_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Date
{
private:
    int month;
    int day;
    int year;
public:
    Date(int m = 1, int d = 1, int y = 1970) : month(m), day(d), year(y)
    {
        if (m < 1 || m > 12)
        {
            month = 1;
        }
        if (!(is_date(y, m, d)))
        {
            day = 1;
        }
    }

    bool leapyear(int y)
    {
        return (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;
    }

    bool is_date(int y, int m, int d)
    {
        if (d <= 0)
        {
            return false;
        }

        int days_in_month = 31;

        switch (m)
        {
        case 2:
            days_in_month = (leapyear(y)) ? 29 : 28;
            break;
        case 4:
        case 6:
        case 9:
        case 11:
            days_in_month = 30;
            break;
        }

        if (days_in_month < d)
        {
            return false;
        }

        return true;
    }

    void setMonth(int m)
    {
        if (m >= 1 && m <= 12 && is_date(year, m, day))
        {
            month = m;
        }
    }
    void setDay(int d)
    {
        if (is_date(year, month, d))
        {
            day = d;
        }
    }
    void setYear(int y)
    {
        year = y;
    }

    int getMonth() const
    {
        return month;
    }
    int getDay() const
    {
        return day;
    }
    int getYear() const
    {
        return year;
    }

    void displayDate() const
    {
        std::cout << getMonth() << "/" << getDay() << "/" << getYear() << std::endl;
    }
};

int main(int argc, const char *argv[])
{
    try
    {
        Date date1(12, 7, 1983);
        Date date2(14, 23, 1255);

        date1.displayDate();
        date2.displayDate();

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
12/7/1983
1/23/1255

ch03_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


class Date
{
private:
    int month;
    int day;
    int year;
public:
    Date(int m = 1, int d = 1, int y = 1970) : month(m), day(d), year(y)
    {
        if (m < 1 || m > 12)
        {
            month = 1;
        }
        if (!(is_date(y, m, d)))
        {
            day = 1;
        }
    }

    bool leapyear(int y)
    {
        return (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;
    }

    bool is_date(int y, int m, int d)
    {
        if (d <= 0)
        {
            return false;
        }

        int days_in_month = 31;

        switch (m)
        {
        case 2:
            days_in_month = (leapyear(y)) ? 29 : 28;
            break;
        case 4:
        case 6:
        case 9:
        case 11:
            days_in_month = 30;
            break;
        }

        if (days_in_month < d)
        {
            return false;
        }

        return true;
    }

    void setMonth(int m)
    {
        if (m >= 1 && m <= 12 && is_date(year, m, day))
        {
            month = m;
        }
    }
    void setDay(int d)
    {
        if (is_date(year, month, d))
        {
            day = d;
        }
    }
    void setYear(int y)
    {
        year = y;
    }

    int getMonth() const
    {
        return month;
    }
    int getDay() const
    {
        return day;
    }
    int getYear() const
    {
        return year;
    }

    void displayDate() const
    {
        std::cout << getMonth() << "/" << getDay() << "/" << getYear() << std::endl;
    }
};

class HeartRates
{
private:
    std::string firstName;
    std::string lastName;
    Date birthYMD;
    int ageInYears;
public:
    HeartRates(const std::string &fName, const std::string &lName, int m, int d, int y)
        : firstName (fName), lastName(lName), birthYMD(m, d, y)
    {
        if (fName.size() <= 0)
        {
            firstName = "FirstName";
        }
        if (lName.size() <= 0)
        {
            lastName = "LastName";
        }

        setAge();
    }

    void setFirstName(const std::string &fName)
    {
        if (fName.size() > 0)
        {
            firstName = fName;
        }
    }
    void setLastName(const std::string &lName)
    {
        if (lName.size() > 0)
        {
            lastName = lName;
        }
    }
    void setYMD(int m, int d, int y)
    {
        birthYMD = Date(m, d, y);
        setAge();
    }
    void setAge()
    {
        int cDay, cMonth, cYear;

        std::cout << "Enter the current date(mm dd yyyy): ";
        std::cin >> cMonth >> cDay >> cYear;

        if (cMonth < birthYMD.getMonth())
        {
            ageInYears = ((cYear - birthYMD.getYear()) - 1);
        }
        else if (cMonth > birthYMD.getMonth())
        {
            ageInYears = (cYear - birthYMD.getYear());
        }
        else
        {
            ageInYears =  ((cDay < birthYMD.getDay()) ? ((cYear - birthYMD.getYear()) - 1) : (cYear - birthYMD.getYear()));
        }
    }

    const std::string &getFirstName() const
    {
        return firstName;
    }
    const std::string &getLastName() const
    {
        return lastName;
    }
    const Date &getYMD() const
    {
        return birthYMD;
    }
    int getAge() const
    {
        return ageInYears;
    }
    int getMaximumHeartRate() const
    {
        return 220 - getAge();
    }
    void displayTargetHeartRate() const
    {
        std::cout << "Your Target Heart Rate: "
                  << 0.5 * getMaximumHeartRate() << " - "
                  << 0.85 * getMaximumHeartRate() << std::endl;
    }
    void displayInformation() const
    {
        std::cout << "Name: " << getFirstName() << " " << getLastName() << std::endl;
        std::cout << "BirthDate ";
        birthYMD.displayDate();
        std::cout << "Maximum Heart Rate: " << getMaximumHeartRate() << std::endl;
        displayTargetHeartRate();
    }
};

int main(int argc, const char *argv[])
{
    try
    {
        HeartRates heartRates1("Billy", "Bunson", 11, 23, 1956);
        heartRates1.displayInformation();

        HeartRates heartRates2("Sue", "Sueson", 5, 13, 1983);
        heartRates2.displayInformation();

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter the current date(mm dd yyyy): 12 10 2020
Name: Billy Bunson
BirthDate 11/23/1956
Maximum Heart Rate: 156
Your Target Heart Rate: 78 - 132.6
Enter the current date(mm dd yyyy): 12 10 2020
Name: Sue Sueson
BirthDate 5/13/1983
Maximum Heart Rate: 183
Your Target Heart Rate: 91.5 - 155.55

ch03_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


class Date
{
private:
    int month;
    int day;
    int year;
public:
    Date(int m = 1, int d = 1, int y = 1970) : month(m), day(d), year(y)
    {
        if (m < 1 || m > 12)
        {
            month = 1;
        }
        if (!(is_date(y, m, d)))
        {
            day = 1;
        }
    }

    bool leapyear(int y)
    {
        return (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;
    }

    bool is_date(int y, int m, int d)
    {
        if (d <= 0)
        {
            return false;
        }

        int days_in_month = 31;

        switch (m)
        {
        case 2:
            days_in_month = (leapyear(y)) ? 29 : 28;
            break;
        case 4:
        case 6:
        case 9:
        case 11:
            days_in_month = 30;
            break;
        }

        if (days_in_month < d)
        {
            return false;
        }

        return true;
    }

    void setMonth(int m)
    {
        if (m >= 1 && m <= 12 && is_date(year, m, day))
        {
            month = m;
        }
    }
    void setDay(int d)
    {
        if (is_date(year, month, d))
        {
            day = d;
        }
    }
    void setYear(int y)
    {
        year = y;
    }

    int getMonth() const
    {
        return month;
    }
    int getDay() const
    {
        return day;
    }
    int getYear() const
    {
        return year;
    }

    void displayDate() const
    {
        std::cout << getMonth() << "/" << getDay() << "/" << getYear() << std::endl;
    }
};

class HealthProfile
{
private:
    std::string firstName;
    std::string lastName;
    std::string gender;
    Date birthYMD;
    int ageInYears;
    double height;
    double weight;
public:
    HealthProfile(const std::string &fName, const std::string &lName,
                  const std::string &g, int m, int d, int y, double h, double w)
        : firstName (fName), lastName(lName), gender(g), birthYMD(m, d, y), height(h), weight(w)
    {
        if (fName.size() <= 0)
        {
            firstName = "FirstName";
        }
        if (lName.size() <= 0)
        {
            lastName = "LastName";
        }
        if (g != "Male" && g != "Female")
        {
            gender = "Undefined";
        }

        setAge();
    }

    void setFirstName(const std::string &fName)
    {
        if (fName.size() > 0)
        {
            firstName = fName;
        }
    }
    void setLastName(const std::string &lName)
    {
        if (lName.size() > 0)
        {
            lastName = lName;
        }
    }
    void setGender(const std::string &g)
    {
        if (g == "Male" || g == "Female")
        {
            gender = g;
        }
    }
    void setYMD(int m, int d, int y)
    {
        birthYMD = Date(m, d, y);
        setAge();
    }
    void setAge()
    {
        int cDay, cMonth, cYear;

        std::cout << "Enter the current date(mm dd yyyy): ";
        std::cin >> cMonth >> cDay >> cYear;

        if (cMonth < birthYMD.getMonth())
        {
            ageInYears = ((cYear - birthYMD.getYear()) - 1);
        }
        else if (cMonth > birthYMD.getMonth())
        {
            ageInYears = (cYear - birthYMD.getYear());
        }
        else
        {
            ageInYears =  ((cDay < birthYMD.getDay()) ? ((cYear - birthYMD.getYear()) - 1) : (cYear - birthYMD.getYear()));
        }
    }
    void setHeight(int h)
    {
        height = h;
    }
    void setWeight(int w)
    {
        weight = w;
    }

    const std::string &getFirstName() const
    {
        return firstName;
    }
    const std::string &getLastName() const
    {
        return lastName;
    }
    const std::string &getGender() const
    {
        return gender;
    }
    const Date &getYMD() const
    {
        return birthYMD;
    }
    int getAge() const
    {
        return ageInYears;
    }
    double getHeight() const
    {
        return height;
    }
    double getWeight() const
    {
        return weight;
    }

    double getBMI() const
    {
        return ((getWeight() * 703) / (getHeight() * getHeight()));
    }

    int getMaximumHeartRate() const
    {
        return 220 - getAge();
    }
    void displayTargetHeartRate() const
    {
        std::cout << "Your Target Heart Rate: "
                  << 0.5 * getMaximumHeartRate() << " - "
                  << 0.85 * getMaximumHeartRate() << std::endl;
    }
    void printBMIInfo() const
    {
        std::cout << "\nBMI VALUES" << std::endl;
        std::cout << "Underweight: less than 18.5" << std::endl;
        std::cout << "Normal:      between 18.5 and 24.9" << std::endl;
        std::cout << "Overweight:  between 25 and 29.9" << std::endl;
        std::cout << "Obese:       30 or greater\n" << std::endl;
    }

    void showHealthProfile() const
    {
        std::cout << "Name: " << getFirstName() << " " << getLastName() << std::endl;
        std::cout << "Gender: " << getGender() << std::endl;
        std::cout << "BirthDate ";
        birthYMD.displayDate();
        std::cout << "Age: " << getAge() << std::endl;
        std::cout << "Maximum Heart Rate: " << getMaximumHeartRate() << std::endl;
        displayTargetHeartRate();
        std::cout << "BMI: " << getBMI() << std::endl;
        printBMIInfo();
    }
};

int main(int argc, const char *argv[])
{
    try
    {
        std::string fName, lName, gender;
        int month, day, year;
        double weight, height;

        std::cout << "Enter your first and last name: ";
        std::cin >> fName >> lName;
        std::cout << "Enter your gender (Male/Female): ";
        std::cin >> gender;
        std::cout << "Enter your date of birth (mm dd yyyy): ";
        std::cin >> month >> day >> year;
        std::cout << "Enter your weight in pounds: ";
        std::cin >> weight;
        std::cout << "Enter your height in inches: ";
        std::cin >> height;

        HealthProfile hp(fName, lName, gender, month, day, year, height, weight);
        hp.showHealthProfile();

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter your first and last name: Mike Pence
Enter your gender (Male/Female): Male
Enter your date of birth (mm dd yyyy): 9 25 1990
Enter your weight in pounds: 136
Enter your height in inches: 67
Enter the current date(mm dd yyyy): 12 10 2020
Name: Mike Pence
Gender: Male
BirthDate 9/25/1990
Age: 30
Maximum Heart Rate: 190
Your Target Heart Rate: 95 - 161.5
BMI: 21.2983

BMI VALUES
Underweight: less than 18.5
Normal:      between 18.5 and 24.9
Overweight:  between 25 and 29.9
Obese:       30 or greater

第4章 控制语句（第1部分）、赋值、自增和自减运算符
4.1 简介
4.2 算法
4.3 伪代码
4.4 控制结构
4.5 if选择语句
4.6 if else双路选择语句
4.7 while循环语句
4.8 算法详述：计数器控制的循环
4.9 算法详述：标记控制的循环
4.10 算法详述：嵌套的控制语句
4.11 赋值运算符
4.12 自增和自减运算符
4.13 本章小结
ch04_b01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class GradeBook
{
private:
    std::string courseName;
public:
    explicit GradeBook(const std::string &name) : courseName(name) { }
    void setCourseName(const std::string &name)
    {
        if (name.size() <= 25)
        {
            courseName = name;
        }
        else
        {
            courseName = name.substr(0, 25);

            std::cout << "Name \"" << name << "\" exceeds maximum length (25).\n";
            std::cout << "Limiting courseName to first 25 characters.\n";
        }
    }
    const std::string &getCourseName()
    {
        return courseName;
    }
    void displayMessage()
    {
        std::cout << "Welcome to the grade book for\n"
                  << getCourseName() << "!" << std::endl;
    }
    void determineClassAverage()
    {
        int total;
        int gradeCounter;
        int grade;

        total = 0;
        gradeCounter = 0;

        std::cout << "Enter grade or -1 to quit: ";
        std::cin >> grade;

        while (grade != -1)
        {
            total += grade;
            gradeCounter++;

            std::cout << "Enter grade or -1 to quit: ";
            std::cin >> grade;
        }

        if (gradeCounter != 0)
        {
            double average = static_cast<double>(total) / gradeCounter;

            std::cout << "Total of all " << gradeCounter << " grades is " << total << std::endl;
            std::cout << "Class average is " << std::setprecision(2) << std::fixed << average << std::endl;
        }
        else
        {
            std::cout << "No grades were entered" << std::endl;
        }
    }
};

int main(int argc, const char *argv[])
{
    try
    {
        GradeBook myGradeBook("CS101 C++ Programming");

        myGradeBook.displayMessage();
        myGradeBook.determineClassAverage();

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Welcome to the grade book for
CS101 C++ Programming!
Enter grade or -1 to quit: 23
Enter grade or -1 to quit: 25
Enter grade or -1 to quit: 36
Enter grade or -1 to quit: 53
Enter grade or -1 to quit: 69
Enter grade or -1 to quit: 78
Enter grade or -1 to quit: 81
Enter grade or -1 to quit: 93
Enter grade or -1 to quit: -1
Total of all 8 grades is 458
Class average is 57.25

ch04_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class GasMileage
{
private:
    double milesDriven;
    double gallonsUsed;
    double totalMilesDriven;
    double totalGallonsUsed;
public:
    GasMileage() : milesDriven(0.0), gallonsUsed(0.0), totalMilesDriven(0.0), totalGallonsUsed(0.0) { }

    void setMilesDriven()
    {
        double md = 0.0;

        std::cout << "Enter miles driven (-1 to quit): ";
        std::cin >> md;
        if (md > 0)
        {
            milesDriven = md;
        }
        else
        {
            milesDriven = 0.0;
        }
    }
    void setGallonsUsed()
    {
        double gu = 0.0;

        std::cout << "Enter gallons used: ";
        std::cin >> gu;
        if (gu > 0)
        {
            gallonsUsed = gu;
        }
        else
        {
            gallonsUsed = 0.0;
        }
    }
    void setTotalMilesDriven()
    {
        if (milesDriven > 0.0)
        {
            totalMilesDriven += milesDriven;
        }
    }
    void setTotalGallonsUsed()
    {
        if (gallonsUsed > 0.0)
        {
            totalGallonsUsed += gallonsUsed;
        }
    }

    double getMilesDriven() const
    {
        return milesDriven;
    }
    double getGallonsUsed() const
    {
        return gallonsUsed;
    }
    double getTotalMilesDriven() const
    {
        return totalMilesDriven;
    }
    double getTotalGallonsUsed() const
    {
        return totalGallonsUsed;
    }

    double getTripMPG() const
    {
        double md = getMilesDriven();
        double gu = getGallonsUsed();
        if (md > 0.0 && gu > 0.0)
        {
            return (md / gu);
        }
        else
        {
            return 0.0;
        }
    }
    double getTotalMPG() const
    {
        double tmd = getTotalMilesDriven();
        double tgu = getTotalGallonsUsed();
        if (tmd > 0.0 && tgu > 0.0)
        {
            return (tmd / tgu);
        }
        else
        {
            return 0.0;
        }
    }

    bool run()
    {
        setMilesDriven();
        if (getMilesDriven() > 0.0)
        {
            setGallonsUsed();
            setTotalMilesDriven();
            setTotalGallonsUsed();

            std::cout << "MPG this trip: " << getTripMPG() << std::endl
                      << "Total MPG: " << getTotalMPG() << std::endl;
            return true;
        }
        else
        {
            return false;
        }
    }
};

int main(int argc, const char *argv[])
{
    try
    {
        GasMileage gm;

        while (gm.run())
            ;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter miles driven (-1 to quit): 287
Enter gallons used: 13
MPG this trip: 22.0769
Total MPG: 22.0769
Enter miles driven (-1 to quit): 200
Enter gallons used: 10
MPG this trip: 20
Total MPG: 21.1739
Enter miles driven (-1 to quit): 120
Enter gallons used: 5
MPG this trip: 24
Total MPG: 21.6786
Enter miles driven (-1 to quit): -1

ch04_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class CreditLimits
{
private:
    int accountNumber;
    double beginningBalance;
    double totalMonthCharges;
    double totalMonthCredit;
    double creditLimit;
public:
    CreditLimits() : accountNumber(0), beginningBalance(0.0), totalMonthCharges(0.0),
        totalMonthCredit(0.0), creditLimit(0.0) { }

    void setAccountNumber()
    {
        int accNo = 0;
        std::cout << "Enter account number (or -1 to quit): ";
        std::cin >> accNo;
        if (accNo > 0)
        {
            accountNumber = accNo;
        }
        else
        {
            accountNumber = 0;
        }
    }
    void setBeginningBalance()
    {
        double startBalance = 0.0;

        std::cout << "Enter beginning balance: ";
        std::cin >> startBalance;
        if (startBalance > 0)
        {
            beginningBalance = startBalance;
        }
        else
        {
            beginningBalance = 0.0;
        }
    }
    void setTotalMonthCharges()
    {
        double totalCharges = 0.0;

        std::cout << "Enter total charges: ";
        std::cin >> totalCharges;
        if (totalCharges > 0)
        {
            totalMonthCharges = totalCharges;
        }
        else
        {
            totalMonthCharges = 0.0;
        }
    }
    void setTotalMonthCredit()
    {
        double totalCredit = 0.0;

        std::cout << "Enter total credits: ";
        std::cin >> totalCredit;
        if (totalCredit > 0)
        {
            totalMonthCredit = totalCredit;
        }
        else
        {
            totalMonthCredit = 0.0;
        }
    }
    void setCreditLimit()
    {
        double limit = 0.0;

        std::cout << "Enter credit limit: ";
        std::cin >> limit;
        if (limit > 0)
        {
            creditLimit = limit;
        }
        else
        {
            creditLimit = 0.0;
        }
    }

    int getAccountNumber() const
    {
        return accountNumber;
    }

    double getBeginningBalance() const
    {
        return beginningBalance;
    }

    double getTotalMonthCharges() const
    {
        return totalMonthCharges;
    }

    double getTotalMonthCredit() const
    {
        return totalMonthCredit;
    }

    double getCreditLimit() const
    {
        return creditLimit;
    }

    double getNewBalance() const
    {
        return ( (getBeginningBalance() + getTotalMonthCharges()) - getTotalMonthCredit() );
    }

    bool isCreditLimitExceeded() const
    {
        return (getCreditLimit() - getNewBalance() < 0) ? true : false;
    }
    void printInfo() const
    {
        std::cout << "Account: " << getAccountNumber() << std::endl;
        std::cout << "Credit limit: " << getCreditLimit() << std::endl;
        std::cout << "Balance: " << getNewBalance() << std::endl;

        if (isCreditLimitExceeded())
        {
            std::cout << "Credit Limit Exceeded." << std::endl;
        }
    }
    bool run()
    {
        setAccountNumber();
        if (getAccountNumber() > 0.0)
        {
            setBeginningBalance();
            setTotalMonthCharges();
            setTotalMonthCredit();
            setCreditLimit();

            printInfo();

            return true;
        }
        else
        {
            return false;
        }
    }
};

int main(int argc, const char *argv[])
{
    try
    {
        CreditLimits cl;

        while (cl.run())
            ;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter account number (or -1 to quit): 100
Enter beginning balance: 5394.78
Enter total charges: 1000
Enter total credits: 500
Enter credit limit: 5500
Account: 100
Credit limit: 5500
Balance: 5894.78
Credit Limit Exceeded.
Enter account number (or -1 to quit): 200
Enter beginning balance: 1000
Enter total charges: 123.45
Enter total credits: 321
Enter credit limit: 1500
Account: 200
Credit limit: 1500
Balance: 802.45
Enter account number (or -1 to quit): -1

ch04_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class SalesCommissionCalculator
{
private:
    const double COMMISSION;
    const double BASEPAY;

    double weeklySales;
    double weeklyEarnings;

public:
    SalesCommissionCalculator(double c = 0.09, double b = 200.0) : COMMISSION(c), BASEPAY(b),
        weeklySales(0.0), weeklyEarnings(0.0) { }

    void setWeeklySales()
    {
        double sales = 0.0;

        std::cout << "Enter sales in dollars (-1 to end): ";
        std::cin >> sales;
        if (sales > 0)
        {
            weeklySales = sales;
        }
        else
        {
            weeklySales = 0.0;
        }
    }

    double getWeeklySales() const
    {
        return weeklySales;
    }
    double getWeeklyEarnings() const
    {
        return ( BASEPAY + (getWeeklySales() * COMMISSION) );
    }

    bool run()
    {
        setWeeklySales();
        if (getWeeklySales() > 0.0)
        {
            std::cout << "Salary is: $" << getWeeklyEarnings() << std::endl;

            return true;
        }
        else
        {
            return false;
        }
    }
};

int main(int argc, const char *argv[])
{
    try
    {
        SalesCommissionCalculator scc;

        while (scc.run())
            ;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter sales in dollars (-1 to end): 5000
Salary is: $650
Enter sales in dollars (-1 to end): 6000
Salary is: $740
Enter sales in dollars (-1 to end): 7000
Salary is: $830
Enter sales in dollars (-1 to end): -1

ch04_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class SalaryCalculator
{
private:
    const double BASE_HOURS;
    double hoursWorked;
    double hourlyRate;
public:
    SalaryCalculator(double b = 40) : BASE_HOURS(b), hoursWorked(0.0), hourlyRate(0.0) { }

    void setHoursWorked()
    {
        double hours = 0.0;

        std::cout << "Enter hours worked (-1 to end): ";
        std::cin >> hours;
        if (hours > 0)
        {
            hoursWorked = hours;
        }
        else
        {
            hoursWorked = 0.0;
        }
    }

    void setHourlyRate()
    {
        double rate = 0.0;

        std::cout << "Enter hourly rate of the employee ($00.00): ";
        std::cin >> rate;
        if (rate > 0)
        {
            hourlyRate = rate;
        }
        else
        {
            hourlyRate = 0.0;
        }
    }

    double getHoursWorked() const
    {
        return hoursWorked;
    }
    double getHourlyRate() const
    {
        return hourlyRate;
    }
    double getSalary() const
    {
        if (getHoursWorked() > BASE_HOURS)
        {
            double overtime = getHoursWorked() - BASE_HOURS;
            double overtimePay = getHourlyRate() + (getHourlyRate() * 0.5);

            return (BASE_HOURS * getHourlyRate()) + (overtime * overtimePay);
        }
        else
        {
            return getHoursWorked() * getHourlyRate();
        }
    }

    bool run()
    {
        setHoursWorked();
        if (getHoursWorked() > 0.0)
        {
            setHourlyRate();
            std::cout << "Salary is: $" << getSalary() << std::endl;

            return true;
        }
        else
        {
            return false;
        }
    }
};

int main(int argc, const char *argv[])
{
    try
    {
        SalaryCalculator sc;

        while (sc.run())
            ;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter hours worked (-1 to end): 39
Enter hourly rate of the employee ($00.00): 10
Salary is: $390
Enter hours worked (-1 to end): 40
Enter hourly rate of the employee ($00.00): 10
Salary is: $400
Enter hours worked (-1 to end): 41
Enter hourly rate of the employee ($00.00): 10
Salary is: $415
Enter hours worked (-1 to end): -1

ch04_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template <typename T>
const T &my_max(const T &a, const T &b)
{
    return (a > b) ? a : b;
}

template <typename T>
const T &my_min(const T &a, const T &b)
{
    return (a < b) ? a : b;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Program to find the largest numbers." << std::endl;
        std::cout << "Please enter number: ";
        vector<int> v1;
        cin >> v1;
        std::cout << std::endl;
        cout << v1 << endl;
        int largest = numeric_limits<int>::min();
        for (int i = 0; i < v1.size(); i++)
        {
            largest = my_max(largest, v1[i]);
        }

        std::cout << "Largest Number is: " << largest << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to find the largest numbers.
Please enter number: { 1 , 3 , 9, 7 ,5 , 15 , 13 , 2 }

{ 1, 3, 9, 7, 5, 15, 13, 2 }
Largest Number is: 15

ch04_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        printf("N\t10*N\t100*N\t1000*N\n\n");
        for (int i = 1; i <= 5; i++)
        {
            printf("%d\t%d\t%d\t%d\n", i, i * 10, i * 100, i * 1000);
        }
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
N       10*N    100*N   1000*N

1       10      100     1000
2       20      200     2000
3       30      300     3000
4       40      400     4000
5       50      500     5000

ch04_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template <typename T>
const T &my_max(const T &a, const T &b)
{
    return (a > b) ? a : b;
}

template <typename T>
const T &my_min(const T &a, const T &b)
{
    return (a < b) ? a : b;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Program to find the largest numbers." << std::endl;
        std::cout << "Please enter number: ";
        vector<int> v1;
        cin >> v1;
        std::cout << std::endl;
        cout << v1 << endl;
        int first_largest = numeric_limits<int>::min();
        int second_largest = numeric_limits<int>::min();
        if (v1.size() >= 2)
        {
            for (int i = 0; i < v1.size(); i++)
            {
                if (my_max(first_largest, v1[i]) == v1[i])
                {
                    second_largest = first_largest;
                    first_largest = v1[i];
                }
                else
                {
                    second_largest = my_max(second_largest, v1[i]);
                }
            }

            std::cout << "First Largest Number is: " << first_largest << std::endl;
            std::cout << "Second Largest Number is: " << second_largest << std::endl;
        }
        else
        {
            cout << "Please enter at least two number." << endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to find the largest numbers.
Please enter number: { 1,3,9,7,5,15,13,2 }

{ 1, 3, 9, 7, 5, 15, 13, 2 }
First Largest Number is: 15
Second Largest Number is: 13

ch04_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        int passes = 0;
        int failures = 0;
        int studentCounter = 1;
        int result;

        while (studentCounter <= 10)
        {
            std::cout << "Enter result (" << studentCounter << "/10) (1 = pass, 2 = fail): ";
            std::cin >> result;

            if (result == 1)
            {
                ++passes;
                ++studentCounter;
            }
            else if (result == 2)
            {
                ++failures;
                ++studentCounter;
            }
        }

        std::cout << "Passed " << passes << "\nFailed " << failures << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter result (1/10) (1 = pass, 2 = fail): 1
Enter result (2/10) (1 = pass, 2 = fail): 1
Enter result (3/10) (1 = pass, 2 = fail): 2
Enter result (4/10) (1 = pass, 2 = fail): 2
Enter result (5/10) (1 = pass, 2 = fail): 1
Enter result (6/10) (1 = pass, 2 = fail): 2
Enter result (7/10) (1 = pass, 2 = fail): 3
Enter result (7/10) (1 = pass, 2 = fail): 6
Enter result (7/10) (1 = pass, 2 = fail): 9
Enter result (7/10) (1 = pass, 2 = fail): 1
Enter result (8/10) (1 = pass, 2 = fail): 2
Enter result (9/10) (1 = pass, 2 = fail): 3
Enter result (9/10) (1 = pass, 2 = fail): 1
Enter result (10/10) (1 = pass, 2 = fail): 2
Passed 5
Failed 5

ch04_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Program to print a square of asterisks\n" << std::endl;

        int count = 0;
        while (true)
        {
            std::cout << "Enter a number between 3 and 20: ";
            std::cin >> count;

            if (count >= 3 && count <= 20)
            {
                break;
            }
        }

        for (int i = 0; i < count; i++)
        {
            cout << '*';

            for (int j = 1; j < count - 1; j++)
            {
                if (i == 0 || i == count - 1)
                {
                    cout << '*';
                }
                else
                {
                    cout << ' ';
                }
            }
            cout << '*';
            cout << endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to print a square of asterisks

Enter a number between 3 and 20: 5
*****
*   *
*   *
*   *
*****

ch04_p10.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

bool is_palindrome(const string &s)
{
    if (s.size() <= 1)
    {
        return false;
    }
    int first = 0;
    int last = s.size() - 1;
    while (first < last)
    {
        if (s[first] != s[last])
        {
            return false;
        }
        ++first;
        --last;
    }
    return true;
}

int main(int argc, const char *argv[])
{
    try
    {
        int num = 0;

        std::cout << "A program to determine if a 5 digit integer is a palindrome." << std::endl;

        std::cout << "Enter a 5 digit integer: ";
        std::cin >> num;

        cout << num << " is " << (is_palindrome(to_string(num)) ? "" : "not ") << "a palindrome." << endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
A program to determine if a 5 digit integer is a palindrome.
Enter a 5 digit integer: 12321
12321 is a palindrome.

A program to determine if a 5 digit integer is a palindrome.
Enter a 5 digit integer: 11611
11611 is a palindrome.

A program to determine if a 5 digit integer is a palindrome.
Enter a 5 digit integer: 12345
12345 is not a palindrome.

ch04_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

long binaryToDecimal(const string &s)
{
    if (s.size() <= 0)
    {
        return 0;
    }
    const int base = 2;
    long b = 1;
    long sum = 0;
    char c;
    for (int i = s.size() - 1; i >= 0; --i)
    {
        c = s[i];
        if (c != '0' && c != '1')
        {
            return 0;
        }
        sum += ((c - '0') * b);
        b *= base;
    }
    return sum;
}
int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Printing the decimal equivalent of a binary number.\n";
        std::cout << "Enter a binary number for decimal conversion: ";
        string binNum;
        std::cin >> binNum;

        cout << binNum << " = " << binaryToDecimal(binNum) << endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Printing the decimal equivalent of a binary number.
Enter a binary number for decimal conversion: 1101
1101 = 13

ch04_p12.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        for (int i = 1; i <= 8; i++)
        {
            if (i % 2 == 0)
            {
                std::cout << ' ';
            }
            for (int j = 0; j < 8; j++)
            {
                std::cout << "* ";
            }
            std::cout << std::endl;
        }
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
* * * * * * * *
 * * * * * * * *
* * * * * * * *
 * * * * * * * *
* * * * * * * *
 * * * * * * * *
* * * * * * * *
 * * * * * * * *

ch04_p13.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        unsigned long long num = 2;

        while (true)
        {
            std::cout << num << std::endl;
            if (num > (num * 2)) { break; }
            num *= 2;
        }
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
2
4
8
16
32
64
128
256
512
1024
2048
4096
8192
16384
32768
65536
131072
262144
524288
1048576
2097152
4194304
8388608
16777216
33554432
67108864
134217728
268435456
536870912
1073741824
2147483648
4294967296
8589934592
17179869184
34359738368
68719476736
137438953472
274877906944
549755813888
1099511627776
2199023255552
4398046511104
8796093022208
17592186044416
35184372088832
70368744177664
140737488355328
281474976710656
562949953421312
1125899906842624
2251799813685248
4503599627370496
9007199254740992
18014398509481984
36028797018963968
72057594037927936
144115188075855872
288230376151711744
576460752303423488
1152921504606846976
2305843009213693952
4611686018427387904
9223372036854775808

ch04_p14.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

const double PI = 3.14159;

double getDiameter(double r)
{
    return r * 2;
}
double getArea(double r)
{
    return PI * pow(r, 2);
}
double getCircumference(double r)
{
    return 2 * (PI * r);
}

void printCircle(double r)
{
    std::cout << "Radius: " << r << std::endl;
    std::cout << "Diameter: " << getDiameter(r) << std::endl;
    std::cout << "Area: " << getArea(r) << std::endl;
    std::cout << "Circumference: " << getCircumference(r) << std::endl;
}

int main(int argc, const char *argv[])
{
    try
    {
        double radius;

        std::cout << "Program to print a circle's diameter, circumference and area." << std::endl;
        std::cout << "Enter a circles radius: ";
        std::cin >> radius;

        printCircle(radius);

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to print a circle's diameter, circumference and area.
Enter a circles radius: 5
Radius: 5
Diameter: 10
Area: 78.5397
Circumference: 31.4159

ch04_p15.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

bool isTriangle(double a, double b, double c)
{
    if (a <= 0 || b <= 0 || c <= 0) { return false; }
    if ((a + b > c) && (a + c > b) && (b + c > a))
    {
        return true;
    }

    return false;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Program to determine if 3 values make a triangle." << std::endl;
        double a = 0, b = 0, c = 0;
        std::cout << "Enter 3 space separated nonzero length: ";
        std::cin >> a >> b >> c;
        cout << a << ", " << b << ", " << c << " could " << (isTriangle(a, b, c) ? "" : "not ") << "represent a triangle.\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to determine if 3 values make a triangle.
Enter 3 space separated nonzero length: 1 2 3
1, 2, 3 could not represent a triangle.

Program to determine if 3 values make a triangle.
Enter 3 space separated nonzero length: 2 3 3
2, 3, 3 could represent a triangle.

Program to determine if 3 values make a triangle.
Enter 3 space separated nonzero length: 3 5 9
3, 5, 9 could not represent a triangle.

ch04_p16.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

bool isTriangle(double a, double b, double c)
{
    if (a <= 0 || b <= 0 || c <= 0) { return false; }
    if ((a + b > c) && (a + c > b) && (b + c > a))
    {
        return true;
    }

    return false;
}

bool isRightTriangle(double a, double b, double c)
{
    if (!(isTriangle(a, b, c))) { return false; }
    double hypotenuse = std::max(a, std::max(b, c));

    if (hypotenuse == a)
    {
        return pow(b, 2) + pow(c, 2) == pow(hypotenuse, 2);
    }
    else if (hypotenuse == b)
    {
        return pow(a, 2) + pow(c, 2) == pow(hypotenuse, 2);
    }
    else
    {
        return pow(a, 2) + pow(b, 2) == pow(hypotenuse, 2);
    }

    return false;
}

int main(int argc, const char *argv[])
{
    try
    {

        std::cout << "Program to check whether three values represent a right triangle." << std::endl;
        double a = 0, b = 0, c = 0;
        std::cout << "Enter three space separated nonzero length: ";
        std::cin >> a >> b >> c;
        cout << a << ", " << b << ", " << c << " could " << (isRightTriangle(a, b, c) ? "" : "not ") << "represent a right triangle.\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to check whether three values represent a right triangle.
Enter three space separated nonzero length: 2 2 3
2, 2, 3 could not represent a right triangle.

Program to check whether three values represent a right triangle.
Enter three space separated nonzero length: 3 4 5
3, 4, 5 could represent a right triangle.

Program to check whether three values represent a right triangle.
Enter three space separated nonzero length: 5 12 13
5, 12, 13 could represent a right triangle.

Program to check whether three values represent a right triangle.
Enter three space separated nonzero length: 6 8 10
6, 8, 10 could represent a right triangle.


ch04_p17.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

unsigned long factorialA(int n)
{
    if (n <= 1)
    {
        return 1;
    }
    unsigned long factorial = 1;

    for (int i = 2; i <= n; i++)
    {
        factorial *= i;
    }

    return factorial;
}
double factorialB(int n)
{
    if (n <= 0)
    {
        return 1.0;
    }
    double sum = 1.0;
    for (int i = 1; i <= n; ++i)
    {
        sum += (1.0 / double(factorialA(i)));
    }
    return sum;
}

double factorialC(int x, int n)
{
    if (n <= 0)
    {
        return 1.0;
    }
    double sum = 1.0;
    for (int i = 1; i <= n; ++i)
    {
        sum += (pow(x, i) / double(factorialA(i)));
    }
    return sum;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "A program to determine the factorial of a non-negative integer." << std::endl;
        int a, b, c = 0;
        std::cout << "Enter a non-negative integer: ";
        std::cin >> a;

        std::cout << "Enter the desired accuracy of e: ";
        std::cin >> b;

        std::cout << "Enter the desired accuracy of e: ";
        std::cin >> c;

        cout << fixed << setprecision(11);
        cout << "Factorial A: " << factorialA(a) << endl
             << "Factorial B: " << factorialB(b) << endl
             << "Factorial C: " << factorialC(1, c) << endl;

             return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
A program to determine the factorial of a non-negative integer.
Enter a non-negative integer: 16
Enter the desired accuracy of e: 16
Enter the desired accuracy of e: 16
Factorial A: 20922789888000
Factorial B: 2.71828182846
Factorial C: 2.71828182846

ch04_p18.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

bool encrypt(string &input)
{
    if (input.size() != 4)
    {
        return false;
    }
    for (int i = 0; i < input.size(); ++i)
    {
        if (input[i] < '0' || input[i] > '9')
        {
            return false;
        }
    }
    for (int i = 0; i < input.size(); ++i)
    {
        input[i] = (((input[i] - '0') + 7) % 10) + '0';
    }
    swap(input[0], input[2]);
    swap(input[1], input[3]);

    return true;
}

bool decrypt(string &input)
{
    if (input.size() != 4)
    {
        return false;
    }
    for (int i = 0; i < input.size(); ++i)
    {
        if (input[i] < '0' || input[i] > '9')
        {
            return false;
        }
    }
    swap(input[0], input[2]);
    swap(input[1], input[3]);
    for (int i = 0; i < input.size(); ++i)
    {
        input[i] = (((input[i] - '0') + 10 - 7) % 10) + '0';
    }

    return true;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Welcome to encryption/decryption system." << std::endl;
        string code;
        std::cout << "Enter a 4 digit pass code to be encrypted: ";
        std::cin >> code;
        encrypt(code);
        std::cout << "Encrypted pass code: " << code << std::endl;
        decrypt(code);
        std::cout << "Decrypted pass code: " << code << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Welcome to encryption/decryption system.
Enter a 4 digit pass code to be encrypted: 1234
Encrypted pass code: 0189
Decrypted pass code: 1234

ch04_p19.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        long basePopulation = 7432663275;
        long population = basePopulation;
        long increase = 0;

        double growthRate = 0.0113;
        int sample = 0;

        std::cout << "Program to project world population." << std::endl;
        std::cout << "Enter a sample size (no of projection years): ";
        std::cin >> sample;
        cout << "Population projection for " << sample << " years." << endl;

        cout << "Year\t\tPopulation\t\tIncrease" << endl;

        for (int i = 1; i <= sample; i++)
        {
            increase = population * growthRate;
            population += increase;
            cout << i << "\t\t" << population << "\t\t" << increase << endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to project world population.
Enter a sample size (no of projection years): 23
Population projection for 23 years.
Year            Population              Increase
1               7516652370              83989095
2               7601590541              84938171
3               7687488514              85897973
4               7774357134              86868620
5               7862207369              87850235
6               7951050312              88842943
7               8040897180              89846868
8               8131759318              90862138
9               8223648198              91888880
10              8316575422              92927224
11              8410552724              93977302
12              8505591969              95039245
13              8601705158              96113189
14              8698904426              97199268
15              8797202046              98297620
16              8896610429              99408383
17              8997142126              100531697
18              9098809832              101667706
19              9201626383              102816551
20              9305604761              103978378
21              9410758094              105153333
22              9517099660              106341566
23              9624642886              107543226

第5章 控制语句（第2部分）和逻辑运算符
5.1 简介
5.2 计数器控制的循环的要素
5.3 for循环语句
5.4 使用for语句的例子
5.5 do while循环语句
5.6 switch多路选择语句
5.7 break和continue语句
5.8 逻辑运算符
5.9 ==运算符与=运算符的混淆问题
5.10 结构化编程小结
5.11 本章小结
ch05_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        int limit, num, total = 0;

        std::cout << "Enter number of values to be summed followed by values: ";
        std::cin >> limit;

        for (int i = 1; i <= limit; i++)
        {
            std::cin >> num;
            total += num;
        }

        std::cout << "Total = " << total << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter number of values to be summed followed by values: 5
100 200 300 400 500
Total = 1500

ch05_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Enter a list of space separated integers for average calculation. 9999 ends input." << endl;
        int cnt = 0;
        int sum = 0;
        int num;
        while (std::cin >> num && num != 9999)
        {
            sum += num;
            ++cnt;
        }

        cout << "Sum: " << sum << ", Count: " << cnt << endl;
        if (cnt > 1)
        {
            std::cout << "Average: " << double(sum) / cnt << std::endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter a list of space separated integers for average calculation. 9999 ends input.
10 8 11 7 9 9999
Sum: 45, Count: 5
Average: 9

ch05_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        int counter = 0;
        int smallest = 0;
        int current = 0;

        std::cout << "Enter a list of space separated integers to determine the smallest." << endl
                << "The first entry is number of separate entries." << endl;
        std::cin >> counter;

        smallest = numeric_limits<int>::min();

        for (int i = 0; i < counter && std::cin >> current; i++)
        {
            if ((current < smallest) || (i == 0))
            {
                smallest = current;
            }
        }

        std::cout << "Smallest: " << smallest << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter a list of space separated integers to determine the smallest.
The first entry is number of separate entries.
5 10 8 11 7 9
Smallest: 7

ch05_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        int product = 1;

        std::cout << "Product of odd integers 1 to 15: ";

        for (int i = 1; i <= 15; i += 2)
        {
            product *= i;
        }

        std::cout << product << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Product of odd integers 1 to 15: 2027025

ch05_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

unsigned long factorial(int n)
{
    if (n <= 1) { return 1; }
    int f = 1;

    for (int i = 2; i <= n; i++)
    {
        f *= i;
    }

    return f;
}

unsigned long factorialr(int n)
{
    if (n >= 2)
    {
        return n * factorialr(n - 1);
    }
    else
    {
        return 1;
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Factorials of 1 to 5." << std::endl;

        for (int i = 1; i <= 5; i++)
        {
            cout << i << "\t" << factorial(i) << endl;
        }
        std::cout << "\nRecursively: " << std::endl;
        for (int i = 1; i <= 5; i++)
        {
            cout << i << "\t" << factorialr(i) << endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Factorials of 1 to 5.
1       1
2       2
3       6
4       24
5       120

Recursively:
1       1
2       2
3       6
4       24
5       120

ch05_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        double amount;
        double principal = 1000.0f;

        std::cout << "Year" << std::setw(8) << "Rate" << std::setw(21)
                  << "Amount on deposit" << std::endl;

        std::cout << std::fixed << std::setprecision(2);

        for (int rate = 5; rate <= 10; rate++)
        {
            for (int year = 0; year <= 10; ++year)
            {
                amount = principal * pow(1.0 + rate / 100.0, year);

                std::cout << std::setw(4) << year << std::setw(8) << rate / 100.0
                          << std::setw(15) << amount << std::endl;
            }
            std::cout << std::endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下

Year    Rate    Amount on deposit
   0    0.05        1000.00
   1    0.05        1050.00
   2    0.05        1102.50
   3    0.05        1157.63
   4    0.05        1215.51
   5    0.05        1276.28
   6    0.05        1340.10
   7    0.05        1407.10
   8    0.05        1477.46
   9    0.05        1551.33
  10    0.05        1628.89

   0    0.06        1000.00
   1    0.06        1060.00
   2    0.06        1123.60
   3    0.06        1191.02
   4    0.06        1262.48
   5    0.06        1338.23
   6    0.06        1418.52
   7    0.06        1503.63
   8    0.06        1593.85
   9    0.06        1689.48
  10    0.06        1790.85

   0    0.07        1000.00
   1    0.07        1070.00
   2    0.07        1144.90
   3    0.07        1225.04
   4    0.07        1310.80
   5    0.07        1402.55
   6    0.07        1500.73
   7    0.07        1605.78
   8    0.07        1718.19
   9    0.07        1838.46
  10    0.07        1967.15

   0    0.08        1000.00
   1    0.08        1080.00
   2    0.08        1166.40
   3    0.08        1259.71
   4    0.08        1360.49
   5    0.08        1469.33
   6    0.08        1586.87
   7    0.08        1713.82
   8    0.08        1850.93
   9    0.08        1999.00
  10    0.08        2158.92

   0    0.09        1000.00
   1    0.09        1090.00
   2    0.09        1188.10
   3    0.09        1295.03
   4    0.09        1411.58
   5    0.09        1538.62
   6    0.09        1677.10
   7    0.09        1828.04
   8    0.09        1992.56
   9    0.09        2171.89
  10    0.09        2367.36

   0    0.10        1000.00
   1    0.10        1100.00
   2    0.10        1210.00
   3    0.10        1331.00
   4    0.10        1464.10
   5    0.10        1610.51
   6    0.10        1771.56
   7    0.10        1948.72
   8    0.10        2143.59
   9    0.10        2357.95
  10    0.10        2593.74

ch05_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

void printA()
{
    for (int i = 1; i <= 10; i++)
    {
        for (int j = 1; j <= 10; j++)
        {
            std::cout << ((j <= i) ? '*' : ' ');
        }
        std::cout << std::endl;
    }
}
void printB()
{
    for (int i = 10; i >= 1; i--)
    {
        for (int j = 1; j <= 10; j++)
        {
            std::cout << ((j <= i) ? '*' : ' ');
        }
        std::cout << std::endl;
    }
}
void printC()
{
    for (int i = 10; i >= 1; i--)
    {
        for (int j = 10; j >= 1; j--)
        {
            std::cout << ((j <= i) ? '*' : ' ');
        }
        std::cout << std::endl;
    }
}
void printD()
{
    for (int i = 1; i <= 10; i++)
    {
        for (int j = 10; j >= 1; j--)
        {
            std::cout << ((j <= i) ? '*' : ' ');
        }
        std::cout << std::endl;
    }
}
void printAll()
{
    for (int i = 1, j = 10; i <= 10; i++, j--)
    {
        for (int k = 1; k <= 10; k++)
        {
            std::cout << ((k <= i) ? '*' : ' ');
        }
        std::cout << "     ";
        for (int k = 1; k <= 10; k++)
        {
            std::cout << ((k <= j) ? '*' : ' ');
        }
        std::cout << "     ";
        for (int k = 10; k >= 1; k--)
        {
            std::cout << ((k <= j) ? '*' : ' ');
        }
        std::cout << "     ";
        for (int k = 10; k >= 1; k--)
        {
            std::cout << ((k <= i) ? '*' : ' ');
        }
        std::cout << std::endl;
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        printA();
        std::cout << std::endl;
        printB();
        std::cout << std::endl;
        printC();
        std::cout << std::endl;
        printD();
        std::cout << std::endl;
        printAll();
        std::cout << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
*
**
***
****
*****
******
*******
********
*********
**********

**********
*********
********
*******
******
*****
****
***
**
*

**********
 *********
  ********
   *******
    ******
     *****
      ****
       ***
        **
         *

         *
        **
       ***
      ****
     *****
    ******
   *******
  ********
 *********
**********

*              **********     **********              *
**             *********       *********             **
***            ********         ********            ***
****           *******           *******           ****
*****          ******             ******          *****
******         *****               *****         ******
*******        ****                 ****        *******
********       ***                   ***       ********
*********      **                     **      *********
**********     *                       *     **********

ch05_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

void printLine(int value)
{
    for (int i = 0; i < value; i++)
    {
        std::cout << "*";
    }
    std::cout << std::endl;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Program to print bar chart of entered values.\n" << std::endl;
        int value;
        int i = 0;
        cout << "Enter an integer value (1-30) : ";
        while (i < 5 && cin >> value)
        {
            if (value >= 1 && value <= 30)
            {
                printLine(value);
                ++i;
            }
            else
            {
                std::cout << "Incorrect value entered." << std::endl;
            }
            if (i < 5)
            {
                cout << "Enter an integer value (1-30) : ";
            }
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to print bar chart of entered values.

Enter an integer value (1-30) : 5
*****
Enter an integer value (1-30) : 9
*********
Enter an integer value (1-30) : 23
***********************
Enter an integer value (1-30) : 16
****************
Enter an integer value (1-30) : 2
**

ch05_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

double getPrice(int product, int quantity)
{
    switch (product)
    {
    case 1:
        return 2.98 * quantity;
        break;
    case 2:
        return 4.50 * quantity;
        break;
    case 3:
        return 9.98 * quantity;
        break;
    case 4:
        return 4.49 * quantity;
        break;
    case 5:
        return 6.87 * quantity;
        break;
    default:
        std::cout << "Incorrect product number entered." << std::endl;
        return 0.0;
        break;
    }

    return 0.0;
}

int main(int argc, const char *argv[])
{
    try
    {
        double total = 0.0;
        int product = 0, quantity = 0;

        cout << fixed << setprecision(2);
        std::cout << "Program to add retail prices for 5 products." << std::endl;
        std::cout << "Enter the product number and quantity sold (-1 to quit): ";
        while (std::cin >> product && product > 0 && std::cin >> quantity && quantity > 0)
        {
            total += getPrice(product, quantity);

            cout << "Running total: $" << total << endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to add retail prices for 5 products.
Enter the product number and quantity sold (-1 to quit): 1 3 2 4 3 5 4 6 5 7
Running total: $8.94
Running total: $26.94
Running total: $76.84
Running total: $103.78
Running total: $151.87
-1

ch05_p10.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


class GradeBook
{
private:
    std::string courseName;
    int aCount;
    int bCount;
    int cCount;
    int dCount;
    int fCount;
public:
    explicit GradeBook(const std::string &name) : courseName(name)
    {
        aCount = 0;
        bCount = 0;
        cCount = 0;
        dCount = 0;
        fCount = 0;
    }
    void setCourseName(const std::string &name)
    {
        if (name.size() <= 25)
        {
            courseName = name;
        }
        else
        {
            courseName = name.substr(0, 25);

            std::cout << "Name \"" << name << "\" exceeds maximum length (25).\n";
            std::cout << "Limiting courseName to first 25 characters.\n";
        }
    }
    const std::string &getCourseName()
    {
        return courseName;
    }
    void displayMessage()
    {
        std::cout << "Welcome to the grade book for\n"
                  << getCourseName() << "!" << std::endl;
    }
    void inputGrades()
    {
        char grade;
        char c;
        std::cout << "Enter the letter grades: " << std::endl;
        while (std::cin >> grade && (c = tolower(grade)) >= 'a' && c <= 'f')
        {
            switch (c)
            {
            case 'a':
                ++aCount;
                break;
            case 'b':
                ++bCount;
                break;
            case 'c':
                ++cCount;
                break;
            case 'd':
                ++dCount;
                break;
            case 'f':
                ++fCount;
                break;
            default:
                break;
            }
        }
    }
    void displayGradeReport() const
    {
        std::cout << "Number of students who received each letter grade: " << std::endl
                  << "A: " << aCount << "\nB: " << bCount << "\nC: " << cCount << std::endl
                  << "D: " << dCount << "\nF: " << fCount << std::endl;

        cout << "Grade Point Average: " <<
             (aCount * 4 + bCount * 3 + cCount * 2 + dCount * 1 + fCount * 0) /
             (aCount + bCount + cCount + dCount + fCount) << endl;
    }
};

int main(int argc, const char *argv[])
{
    try
    {
        GradeBook myGradeBook("Data Structures in C++");

        myGradeBook.displayMessage();
        myGradeBook.inputGrades();
        myGradeBook.displayGradeReport();

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Welcome to the grade book for
Data Structures in C++!
Enter the letter grades:
A B C D E F A A B C C C F F D q
Number of students who received each letter grade:
A: 3
B: 2
C: 4
D: 2
F: 3
Grade Point Average: 2

ch05_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int main(int argc, const char *argv[])
{
    try
    {
        double rate = 5 / 100.0;
        int principal = 1000;

        std::cout << "Year" << std::setw(21) << "Amount on deposit" << std::endl;

        std::cout << std::fixed << std::setprecision(2);

        for (int year = 0; year <= 10; ++year)
        {
            int amount = principal * pow(1.0 + rate, year);

            int dollar = amount / 100;
            int cent = amount % 100;

            std::cout << std::setw(4) << year << std::setw(12) << dollar << '.';
            if (cent < 10) { cout << '0';}
            cout << cent << std::endl; 
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Year    Amount on deposit
   0          10.00
   1          10.50
   2          11.02
   3          11.57
   4          12.15
   5          12.76
   6          13.40
   7          14.07
   8          14.77
   9          15.51
  10          16.28

ch05_p12.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

void print_bin(unsigned long n)
{
    if (n == 0)
    {
        cout << '0';
    }
    string s;
    while (n != 0)
    {
        if (n & 1UL)
        {
            s.push_back('1');
        }
        else
        {
            s.push_back('0');
        }
        n >>= 1;
    }
    for (int i = s.size() - 1; i >= 0; --i)
    {
        cout << s[i];
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Dec\tOct\tHex\tBin\n";

        for (int i = 1; i <= 256; i++)
        {
            std::cout << std::dec << i << "\t" << std::oct << i << "\t" << std::hex << i << "\t";
            print_bin(i);
            std::cout << std::endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Dec     Oct     Hex     Bin
1       1       1       1
2       2       2       10
3       3       3       11
4       4       4       100
5       5       5       101
6       6       6       110
7       7       7       111
8       10      8       1000
9       11      9       1001
10      12      a       1010
11      13      b       1011
12      14      c       1100
13      15      d       1101
14      16      e       1110
15      17      f       1111
16      20      10      10000
17      21      11      10001
18      22      12      10010
19      23      13      10011
20      24      14      10100
21      25      15      10101
22      26      16      10110
23      27      17      10111
24      30      18      11000
25      31      19      11001
26      32      1a      11010
27      33      1b      11011
28      34      1c      11100
29      35      1d      11101
30      36      1e      11110
31      37      1f      11111
32      40      20      100000
33      41      21      100001
34      42      22      100010
35      43      23      100011
36      44      24      100100
37      45      25      100101
38      46      26      100110
39      47      27      100111
...
252     374     fc      11111100
253     375     fd      11111101
254     376     fe      11111110
255     377     ff      11111111
256     400     100     100000000

ch05_p13.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


int main(int argc, const char *argv[])
{
    try
    {
        int toggle = 0;
        int limit = 1000;

        double pi = 4.0;
        double divisor = 3.0;
        cout << fixed << setprecision(15);
        std::cout << "Term" << "\tPI Approx" << std::endl;

        for (int i = 1; i <= limit; i++)
        {
            if (toggle == 0)
            {
                pi -= (4.0 / divisor);
            }
            else
            {
                pi += (4.0 / divisor);
            }
            toggle = (1 - toggle);

            divisor += 2.0;

            std::cout << i << "\t" << pi << std::endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Term    PI Approx
1       2.666666666666667
2       3.466666666666667
3       2.895238095238096
4       3.339682539682540
5       2.976046176046176
6       3.283738483738484
7       3.017071817071818
8       3.252365934718877
9       3.041839618929403
10      3.232315809405594
11      3.058402765927333
12      3.218402765927333
13      3.070254617779185
14      3.208185652261944
15      3.079153394197428
16      3.200365515409549
17      3.086079801123835
18      3.194187909231943
19      3.091623806667840
20      3.189184782277596
21      3.096161526463642
22      3.185050415352531
23      3.099944032373808
24      3.181576685435032
25      3.103145312886013
26      3.178617010999220
27      3.105889738271947
28      3.176065176868438
29      3.108268566698947
30      3.173842337190750
31      3.110350273698687
32      3.171888735237149
33      3.112187242699835
34      3.170158257192588
35      3.113820229023574
36      3.168614749571519
37      3.115281416238186
38      3.167229468186238
39      3.116596556793833

992     3.142599702679889
993     3.140586617627045
994     3.142597678461635
995     3.140588637778561
996     3.142595662364613
997     3.140590649833284
998     3.142593654340044
999     3.140592653839794
1000    3.142591654339544

ch05_p14.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

bool isTriangle(double a, double b, double c)
{
    if (a <= 0 || b <= 0 || c <= 0)
    {
        return false;
    }
    if ((a + b > c) && (a + c > b) && (b + c > a))
    {
        return true;
    }

    return false;
}

bool isRightTriangle(double a, double b, double c)
{
    if (!(isTriangle(a, b, c)))
    {
        return false;
    }
    double hypotenuse = std::max(a, std::max(b, c));

    if (hypotenuse == a)
    {
        return pow(b, 2) + pow(c, 2) == pow(hypotenuse, 2);
    }
    else if (hypotenuse == b)
    {
        return pow(a, 2) + pow(c, 2) == pow(hypotenuse, 2);
    }
    else
    {
        return pow(a, 2) + pow(b, 2) == pow(hypotenuse, 2);
    }

    return false;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "All Pythagorean Triples up to sides of 500" << std::endl;

        for (int i = 1; i <= 500; i++)
        {
            for (int j = i + 1; j <= 500; j++)
            {
                for (int k = j + 1; k <= 500; k++)
                {
                    if (isRightTriangle(i, j, k))
                    {
                        cout << i << ", " << j << ", " << k << endl;
                    }
                }
            }
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
All Pythagorean Triples up to sides of 500
3, 4, 5
5, 12, 13
6, 8, 10
7, 24, 25
8, 15, 17
9, 12, 15
9, 40, 41
10, 24, 26
11, 60, 61
12, 16, 20
12, 35, 37
13, 84, 85
14, 48, 50
15, 20, 25
15, 36, 39
15, 112, 113
16, 30, 34
16, 63, 65
17, 144, 145
18, 24, 30
18, 80, 82
19, 180, 181
20, 21, 29
20, 48, 52
20, 99, 101
21, 28, 35
21, 72, 75
21, 220, 221
22, 120, 122
23, 264, 265
24, 32, 40
24, 45, 51
24, 70, 74
24, 143, 145
25, 60, 65
25, 312, 313
26, 168, 170
27, 36, 45
27, 120, 123
27, 364, 365
28, 45, 53
28, 96, 100
28, 195, 197
29, 420, 421
30, 40, 50
30, 72, 78
30, 224, 226
31, 480, 481
32, 60, 68
32, 126, 130
32, 255, 257
33, 44, 55
33, 56, 65
33, 180, 183
34, 288, 290
35, 84, 91
35, 120, 125
36, 48, 60
36, 77, 85
36, 105, 111
36, 160, 164
36, 323, 325
38, 360, 362
39, 52, 65
39, 80, 89
39, 252, 255
40, 42, 58
40, 75, 85
40, 96, 104
40, 198, 202
40, 399, 401
42, 56, 70
42, 144, 150
42, 440, 442
44, 117, 125
44, 240, 244
44, 483, 485
45, 60, 75
45, 108, 117
45, 200, 205
45, 336, 339
48, 55, 73
48, 64, 80
48, 90, 102
48, 140, 148
48, 189, 195
48, 286, 290
49, 168, 175
50, 120, 130
51, 68, 85
51, 140, 149
51, 432, 435
52, 165, 173
52, 336, 340
54, 72, 90
54, 240, 246
55, 132, 143
55, 300, 305
56, 90, 106
56, 105, 119
56, 192, 200
56, 390, 394
57, 76, 95
57, 176, 185
60, 63, 87
60, 80, 100
60, 91, 109
60, 144, 156
60, 175, 185
60, 221, 229
60, 297, 303
60, 448, 452
63, 84, 105
63, 216, 225
63, 280, 287
64, 120, 136
64, 252, 260
65, 72, 97
65, 156, 169
65, 420, 425
66, 88, 110
66, 112, 130
66, 360, 366
68, 285, 293
69, 92, 115
69, 260, 269
70, 168, 182
70, 240, 250
72, 96, 120
72, 135, 153
72, 154, 170
72, 210, 222
72, 320, 328
72, 429, 435
75, 100, 125
75, 180, 195
75, 308, 317
76, 357, 365
77, 264, 275
77, 420, 427
78, 104, 130
78, 160, 178
80, 84, 116
80, 150, 170
80, 192, 208
80, 315, 325
80, 396, 404
81, 108, 135
81, 360, 369
84, 112, 140
84, 135, 159
84, 187, 205
84, 245, 259
84, 288, 300
84, 437, 445
85, 132, 157
85, 204, 221
87, 116, 145
87, 416, 425
88, 105, 137
88, 165, 187
88, 234, 250
88, 480, 488
90, 120, 150
90, 216, 234
90, 400, 410
91, 312, 325
93, 124, 155
93, 476, 485
95, 168, 193
95, 228, 247
96, 110, 146
96, 128, 160
96, 180, 204
96, 247, 265
96, 280, 296
96, 378, 390
98, 336, 350
99, 132, 165
99, 168, 195
99, 440, 451
100, 105, 145
100, 240, 260
102, 136, 170
102, 280, 298
104, 153, 185
104, 195, 221
104, 330, 346
105, 140, 175
105, 208, 233
105, 252, 273
105, 360, 375
108, 144, 180
108, 231, 255
108, 315, 333
108, 480, 492
110, 264, 286
111, 148, 185
112, 180, 212
112, 210, 238
112, 384, 400
112, 441, 455
114, 152, 190
114, 352, 370
115, 252, 277
115, 276, 299
117, 156, 195
117, 240, 267
119, 120, 169
119, 408, 425
120, 126, 174
120, 160, 200
120, 182, 218
120, 209, 241
120, 225, 255
120, 288, 312
120, 350, 370
120, 391, 409
120, 442, 458
123, 164, 205
125, 300, 325
126, 168, 210
126, 432, 450
128, 240, 272
129, 172, 215
130, 144, 194
130, 312, 338
132, 176, 220
132, 224, 260
132, 351, 375
132, 385, 407
132, 475, 493
133, 156, 205
133, 456, 475
135, 180, 225
135, 324, 351
135, 352, 377
136, 255, 289
136, 273, 305
138, 184, 230
140, 147, 203
140, 171, 221
140, 225, 265
140, 336, 364
140, 480, 500
141, 188, 235
144, 165, 219
144, 192, 240
144, 270, 306
144, 308, 340
144, 420, 444
145, 348, 377
145, 408, 433
147, 196, 245
150, 200, 250
150, 360, 390
152, 285, 323
152, 345, 377
153, 204, 255
153, 420, 447
155, 372, 403
155, 468, 493
156, 208, 260
156, 320, 356
156, 455, 481
159, 212, 265
160, 168, 232
160, 231, 281
160, 300, 340
160, 384, 416
161, 240, 289
162, 216, 270
165, 220, 275
165, 280, 325
165, 396, 429
168, 224, 280
168, 270, 318
168, 315, 357
168, 374, 410
168, 425, 457
170, 264, 314
170, 408, 442
171, 228, 285
174, 232, 290
175, 288, 337
175, 420, 455
176, 210, 274
176, 330, 374
176, 468, 500
177, 236, 295
180, 189, 261
180, 240, 300
180, 273, 327
180, 299, 349
180, 385, 425
180, 432, 468
183, 244, 305
184, 345, 391
185, 444, 481
186, 248, 310
189, 252, 315
189, 340, 389
190, 336, 386
190, 456, 494
192, 220, 292
192, 256, 320
192, 360, 408
195, 216, 291
195, 260, 325
195, 400, 445
196, 315, 371
198, 264, 330
198, 336, 390
200, 210, 290
200, 375, 425
201, 268, 335
203, 396, 445
204, 253, 325
204, 272, 340
207, 224, 305
207, 276, 345
208, 306, 370
208, 390, 442
210, 280, 350
210, 416, 466
213, 284, 355
216, 288, 360
216, 405, 459
219, 292, 365
220, 231, 319
222, 296, 370
224, 360, 424
224, 420, 476
225, 272, 353
225, 300, 375
228, 304, 380
228, 325, 397
231, 308, 385
231, 392, 455
232, 435, 493
234, 312, 390
237, 316, 395
238, 240, 338
240, 252, 348
240, 275, 365
240, 320, 400
240, 364, 436
240, 418, 482
243, 324, 405
246, 328, 410
249, 332, 415
252, 275, 373
252, 336, 420
252, 405, 477
255, 340, 425
255, 396, 471
258, 344, 430
260, 273, 377
260, 288, 388
261, 348, 435
261, 380, 461
264, 315, 411
264, 352, 440
266, 312, 410
267, 356, 445
270, 360, 450
273, 364, 455
276, 368, 460
279, 372, 465
280, 294, 406
280, 342, 442
280, 351, 449
282, 376, 470
285, 380, 475
288, 330, 438
288, 384, 480
291, 388, 485
294, 392, 490
297, 304, 425
297, 396, 495
300, 315, 435
300, 400, 500
319, 360, 481
320, 336, 464
325, 360, 485
340, 357, 493

ch05_p15.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class SalaryCalculator
{
private:
    const double COMMISSION_BASE = 250.0;
    const double COMMISSION_RATE = 5.7 / 100.0;
    const double BASE_HOURS = 40.0;
    const double HOURLY_OVERTIME = 1.5;
    const double PIECE_RATE = 10.0;

    double managerRate;
    double hourlyRate;
    double weeklySales;
    double hoursWorked;

    int employeeCode;
    int piecesProduced;
public:
    SalaryCalculator() { }

    void setEmployeeCode()
    {
        int val = 0;

        std::cout << "Enter an employee code (1-4). -1 to quit: ";
        std::cin >> val;
        if (val >= 1 && val <= 4)
        {
            employeeCode = val;
        }
        else
        {
            employeeCode = 0;
        }
    }

    void setPiecesProduced()
    {
        int val = 0;

        std::cout << "Enter pieces produced: ";
        std::cin >> val;
        if (val > 0)
        {
            piecesProduced = val;
        }
        else
        {
            piecesProduced = 0;
        }
    }

    void setWeeklySales()
    {
        double sales = 0.0;

        std::cout << "Enter weekly sales: ";
        std::cin >> sales;
        if (sales > 0)
        {
            weeklySales = sales;
        }
        else
        {
            weeklySales = 0.0;
        }
    }

    void setHoursWorked()
    {
        double hours = 0.0;

        std::cout << "Enter hours worked: ";
        std::cin >> hours;
        if (hours > 0)
        {
            hoursWorked = hours;
        }
        else
        {
            hoursWorked = 0.0;
        }
    }

    void setHourlyRate()
    {
        double rate = 0.0;

        std::cout << "Enter hourly rate: ";
        std::cin >> rate;
        if (rate > 0)
        {
            hourlyRate = rate;
        }
        else
        {
            hourlyRate = 0.0;
        }
    }

    void setManagerRate()
    {
        double rate = 0.0;

        std::cout << "Enter manager weekly salary: ";
        std::cin >> rate;
        if (rate > 0)
        {
            managerRate = rate;
        }
        else
        {
            managerRate = 0.0;
        }
    }

    double getManagerRate() const
    {
        return managerRate;
    }
    double getHourlyRate() const
    {
        return hourlyRate;
    }
    double getWeeklySales() const
    {
        return weeklySales;
    }
    double getHoursWorked() const
    {
        return hoursWorked;
    }
    int getEmployeeCode() const
    {
        return employeeCode;
    }
    int getPiecesProduced() const
    {
        return piecesProduced;
    }

    double getSalary()
    {
        double dValue = 0.0;

        switch (getEmployeeCode())
        {
        case 1:
            setManagerRate();
            dValue = getManagerRate();
            break;
        case 2:
            setHourlyRate();
            setHoursWorked();
            dValue = getHourlyRate();
            if (getHoursWorked() > BASE_HOURS)
            {
                dValue *= BASE_HOURS;
                dValue += ((getHoursWorked() - BASE_HOURS) * (getHourlyRate() * HOURLY_OVERTIME));
            }
            else
            {
                dValue *= getHoursWorked();
            }
            break;
        case 3:
            setWeeklySales();
            dValue = (COMMISSION_BASE + (getWeeklySales() * COMMISSION_RATE));
            break;
        case 4:
            setPiecesProduced();
            dValue = (getPiecesProduced() * PIECE_RATE);
            break;
        default:
            break;
        }
        return dValue;
    }

    bool run()
    {
        reset();
        double dValue = 0.0;
        setEmployeeCode();
        if ((dValue = getSalary()) > 0.0)
        {
            switch (getEmployeeCode())
            {
            case 1:
                cout << "Manager Salary: $" << dValue << endl;
                break;
            case 2:
                cout << "Hourly Worker Salary: $" << dValue << endl;
                break;
            case 3:
                cout << "Commission Worker Salary: $" << dValue << endl;
                break;
            case 4:
                cout << "Piece Worker Salary: $" << dValue << endl;
                break;
            default:
                break;
            }
            return true;
        }
        else
        {
            return false;
        }
    }

    void reset()
    {
        managerRate = 0.0;
        hourlyRate = 0.0;
        weeklySales = 0.0;
        hoursWorked = 0.0;
        employeeCode = 0;
        piecesProduced = 0;
    }
};

int main(int argc, const char *argv[])
{
    try
    {
        cout << fixed << setprecision(2);
        SalaryCalculator sc;

        while (sc.run())
            ;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter an employee code (1-4). -1 to quit: 1
Enter manager weekly salary: 666
Manager Salary: $666.00
Enter an employee code (1-4). -1 to quit: 2
Enter hourly rate: 20
Enter hours worked: 60
Hourly Worker Salary: $1400.00
Enter an employee code (1-4). -1 to quit: 3
Enter weekly sales: 100
Commission Worker Salary: $255.70
Enter an employee code (1-4). -1 to quit: 4
Enter pieces produced: 100
Piece Worker Salary: $1000.00
Enter an employee code (1-4). -1 to quit: -1

ch05_p16.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int main(int argc, const char *argv[])
{
    try
    {
        int x = 4;
        int y = 8;
        int a = 10;
        int b = 5;
        int g = 2;
        int i = 4;
        int j = 9;

        if ((!(x < 5) && !(y >= 7)) == !((x < 5) || (y >= 7)))
        {
            std::cout << "!(x < 5) && !(y >= 7) is comparable to !((x < 5) || (y >= 7))" << std::endl;
        }

        if ((!(a == b) || !(g != 5)) == (!((a == g) && (g != 5))))
        {
            std::cout << "!(a == b) || !(g != 5) is comparable to !((a == b) && (g != 5))" << std::endl;
        }

        if ((!((x <= 8) && (y > 4))) == (!(x <= 8) || !(y > 4)))
        {
            std::cout << "!((x <= 8) && (y > 4)) is comparable to !(x <= 8) || !(y > 4)" << std::endl;
        }

        if (!((i > 4) || (j <= 6)) == (!(i > 4) && !(j <= 6)))
        {
            std::cout << "!((i > 4) || (j <= 6)) is comparable to !(i > 4) && !(j <= 6)" << std::endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
!(x < 5) && !(y >= 7) is comparable to !((x < 5) || (y >= 7))
!(a == b) || !(g != 5) is comparable to !((a == b) && (g != 5))
!((x <= 8) && (y > 4)) is comparable to !(x <= 8) || !(y > 4)
!((i > 4) || (j <= 6)) is comparable to !(i > 4) && !(j <= 6)

ch05_p17.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int main(int argc, const char *argv[])
{
    try
    {
        for (int i = 1, j = 1, k = 4; i <= 9; i++)
        {
            for (int s = 0; s < k; s++)
            {
                std::cout << " ";
            }
            for (int d = 0; d < j; d++)
            {
                std::cout << "*";
            }

            (i >= 5) ? j -= 2 : j += 2;
            (i >= 5) ? k++ : k--;

            std::cout << std::endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
    *
   ***
  *****
 *******
*********
 *******
  *****
   ***
    *

ch05_p18.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int main(int argc, const char *argv[])
{
    try
    {
        int rows = 0;

        std::cout << "Enter number of rows to display: 1-19: ";
        std::cin >> rows;

        for (int i = 1, j = 1, k = rows / 2; i <= rows; i++)
        {
            for (int s = 0; s < k; s++)
            {
                std::cout << " ";
            }
            for (int d = 0; d < j; d++)
            {
                std::cout << "*";
            }

            (i > rows / 2) ? j -= 2 : j += 2;
            (i > rows / 2) ? k++ : k--;

            std::cout << std::endl;
        }
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter number of rows to display: 1-19: 19
         *
        ***
       *****
      *******
     *********
    ***********
   *************
  ***************
 *****************
*******************
 *****************
  ***************
   *************
    ***********
     *********
      *******
       *****
        ***
         *

ch05_p19.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int main(int argc, const char *argv[])
{
    try
    {
        int count = 1;
        bool exit = false;

        while (!exit)
        {
            std::cout << count++ << " ";

            exit = (count == 5);
        }

        std::cout << "\nBroke out of loop at count = " << count << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
1 2 3 4
Broke out of loop at count = 5

ch05_p20.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int main(int argc, const char *argv[])
{
    try
    {
        for (int count = 1;  count <= 10; ++count)
        {
            if (count != 5)
            {
                std::cout << count << ' ';
            }
        }

        std::cout << "\nSkipped printing 5 without continue" << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
1 2 3 4 6 7 8 9 10
Skipped printing 5 without continue

ch05_p21.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

std::string getDay(int day)
{
    switch (day)
    {
    case 1:
        return "first";
    case 2:
        return "second";
    case 3:
        return "third";
    case 4:
        return "fourth";
    case 5:
        return "fifth";
    case 6:
        return "sixth";
    case 7:
        return "seventh";
    case 8:
        return "eighth";
    case 9:
        return "ninth";
    case 10:
        return "tenth";
    case 11:
        return "eleventh";
    case 12:
        return "twelfth";
    default:
        return "";
    }
}

void printVerse(int day)
{
    switch (day)
    {
    case 12:
        std::cout << "12 Drummers Drumming" << std::endl;
    case 11:
        std::cout << "Eleven Pipers Piping" << std::endl;
    case 10:
        std::cout << "Ten Lords a Leaping" << std::endl;
    case 9:
        std::cout << "Nine Ladies Dancing" << std::endl;
    case 8:
        std::cout << "Eight Maids a Milking" << std::endl;
    case 7:
        std::cout << "Seven Swans a Swimming" << std::endl;
    case 6:
        std::cout << "Six Geese a Laying" << std::endl;
    case 5:
        std::cout << "Five Gold Rings" << std::endl;
    case 4:
        std::cout << "Four Calling Birds" << std::endl;
    case 3:
        std::cout << "Three French Hens" << std::endl;
    case 2:
        std::cout << "Two Turtle Doves" << std::endl;
    case 1:
        cout << ((day > 1) ? "and a" : "A") << " Partridge in a Pear Tree\n";
    default:
        break;
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        for (int i = 1; i <= 12; i++)
        {
            std::cout << "\nOn the " << getDay(i) << " day of Christmas\nmy true love sent to me:\n";
            printVerse(i);
        }
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
On the first day of Christmas
my true love sent to me:
A Partridge in a Pear Tree

On the second day of Christmas
my true love sent to me:
Two Turtle Doves
and a Partridge in a Pear Tree

On the third day of Christmas
my true love sent to me:
Three French Hens
Two Turtle Doves
and a Partridge in a Pear Tree

On the fourth day of Christmas
my true love sent to me:
Four Calling Birds
Three French Hens
Two Turtle Doves
and a Partridge in a Pear Tree

On the fifth day of Christmas
my true love sent to me:
Five Gold Rings
Four Calling Birds
Three French Hens
Two Turtle Doves
and a Partridge in a Pear Tree

On the sixth day of Christmas
my true love sent to me:
Six Geese a Laying
Five Gold Rings
Four Calling Birds
Three French Hens
Two Turtle Doves
and a Partridge in a Pear Tree

On the seventh day of Christmas
my true love sent to me:
Seven Swans a Swimming
Six Geese a Laying
Five Gold Rings
Four Calling Birds
Three French Hens
Two Turtle Doves
and a Partridge in a Pear Tree

On the eighth day of Christmas
my true love sent to me:
Eight Maids a Milking
Seven Swans a Swimming
Six Geese a Laying
Five Gold Rings
Four Calling Birds
Three French Hens
Two Turtle Doves
and a Partridge in a Pear Tree

On the ninth day of Christmas
my true love sent to me:
Nine Ladies Dancing
Eight Maids a Milking
Seven Swans a Swimming
Six Geese a Laying
Five Gold Rings
Four Calling Birds
Three French Hens
Two Turtle Doves
and a Partridge in a Pear Tree

On the tenth day of Christmas
my true love sent to me:
Ten Lords a Leaping
Nine Ladies Dancing
Eight Maids a Milking
Seven Swans a Swimming
Six Geese a Laying
Five Gold Rings
Four Calling Birds
Three French Hens
Two Turtle Doves
and a Partridge in a Pear Tree

On the eleventh day of Christmas
my true love sent to me:
Eleven Pipers Piping
Ten Lords a Leaping
Nine Ladies Dancing
Eight Maids a Milking
Seven Swans a Swimming
Six Geese a Laying
Five Gold Rings
Four Calling Birds
Three French Hens
Two Turtle Doves
and a Partridge in a Pear Tree

On the twelfth day of Christmas
my true love sent to me:
12 Drummers Drumming
Eleven Pipers Piping
Ten Lords a Leaping
Nine Ladies Dancing
Eight Maids a Milking
Seven Swans a Swimming
Six Geese a Laying
Five Gold Rings
Four Calling Birds
Three French Hens
Two Turtle Doves
and a Partridge in a Pear Tree

ch05_p22.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int main(int argc, const char *argv[])
{
    try
    {
        double amount;
        double principal = 24.0;

        std::cout << std::fixed << std::setprecision(2);

        for (double rate = 0.05; rate <= 0.10; rate += 0.01)
        {
            std::cout << "\nInterest rate: " << rate * 100 << "%\n"
                      << "Year" << std::setw(30) << "Amount on deposit" << std::endl;

            for (int year = 1626; year < 2020; year++)
            {
                amount = principal * pow(1.0 + rate, year - 1626);

                if (year == 1626 || year == 2008 || year == 2010 || year == 2020 || year % 50 == 0)
                {
                    std::cout << std::setw(4) << year << std::setw(30) << amount << std::endl;
                }
            }
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Interest rate: 5.00%
Year             Amount on deposit
1626                         24.00
1650                         77.40
1700                        887.60
1750                      10178.51
1800                     116721.08
1850                    1338487.23
1900                   15348968.22
1950                  176012754.87
2000                 2018408627.52
2008                 2982108814.52
2010                 3287774968.00

Interest rate: 6.00%
Year             Amount on deposit
1626                         24.00
1650                         97.17
1700                       1789.97
1750                      32971.49
1800                     607339.88
1850                   11187294.25
1900                  206071685.96
1950                 3795872247.09
2000                69920552399.63
2008               111442737812.29
2010               125217060205.89

Interest rate: 7.00%
Year             Amount on deposit
1626                         24.00
1650                        121.74
1700                       3586.00
1750                     105633.01
1800                    3111634.36
1850                   91659491.42
1900                 2700015936.03
1950                79534437098.38
2000              2342847906984.15
2008              4025448895228.30
2010              4608736440146.88

Interest rate: 8.00%
Year             Amount on deposit
1626                         24.00
1650                        152.19
1700                       7137.88
1750                     334778.01
1800                   15701628.45
1850                  736431693.51
1900                34539833931.46
1950              1619973907324.87
2000             75979388482896.58
2008            140632545501736.62
2010            164033801073225.62

Interest rate: 9.00%
Year             Amount on deposit
1626                         24.00
1650                        189.87
1700                      14117.96
1750                    1049776.84
1800                   78058802.30
1850                 5804258959.22
1900               431590302085.40
1950             32091984551844.54
2000           2386280385586673.50
2008           4754813148918076.00
2010           5649193502229566.00

Interest rate: 10.00%
Year             Amount on deposit
1626                         24.00
1650                        236.39
1700                      27750.44
1750                    3257648.34
1800                  382418117.45
1850                44892388964.66
1900              5269955828368.73
1950            618644609330529.25
2000          72623218318737040.00
2008         155674318134231808.00
2010         188365924942420544.00

ch05_p23.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


class Question
{
private:
    std::string _q;
    std::string _a;
    std::string _b;
    std::string _c;
    std::string _d;

    std::vector<std::string> _answers;

    int _correct;
public:
    Question() : _correct(0)
    {
        initialise();
    }

    Question(const std::string &Q, const std::string &A, const std::string &B,
             const std::string &C, const std::string &D) : _q(Q), _a(A), _b(B), _c(C), _d(D), _correct(0)
    {
        initialise();
    }
    ~Question()
    {
        cleanup();
    }

    void initialise();

    void setQuestion(const std::string &);
    void setA(const std::string &);
    void setB(const std::string &);
    void setC(const std::string &);
    void setD(const std::string &);

    void getQuestion() const;

    bool answer(int);

    bool isCorrect()
    {
        return _correct == 1;
    }

    void cleanup()
    {
        _answers.clear();
    }
};

void Question::initialise()
{
    std::string tmp;
    if (_q.empty())
    {
        std::cout << "Enter a question: ";
        std::cin >> tmp;
        setQuestion(tmp);
    }
    if (_a.empty())
    {
        std::cout << "Enter correct answer: ";
        std::cin >> tmp;
        setA(tmp);
    }
    if (_b.empty())
    {
        std::cout << "Enter first incorrect answer: ";
        std::cin >> tmp;
        setB(tmp);
    }
    if (_c.empty())
    {
        std::cout << "Enter second incorrect answer: ";
        std::cin >> tmp;
        setC(tmp);
    }
    if (_d.empty())
    {
        std::cout << "Enter third incorrect answer: ";
        std::cin >> tmp;
        setD(tmp);
    }

    _answers.push_back(_a);
    _answers.push_back(_b);
    _answers.push_back(_c);
    _answers.push_back(_d);

    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();

    shuffle(_answers.begin(), _answers.end(), std::default_random_engine(seed));
}

void Question::setQuestion(const std::string &Q)
{
    _q = Q;
}
void Question::setA(const std::string &A)
{
    _a = A;
}
void Question::setB(const std::string &B)
{
    _b = B;
}
void Question::setC(const std::string &C)
{
    _c = C;
}
void Question::setD(const std::string &D)
{
    _d = D;
}

void Question::getQuestion() const
{
    std::cout << _q << std::endl << std::endl;

    for (int i = 0; i < _answers.size(); i++)
    {
        std::cout << _answers[i] << std::endl;
    }
    std::cout << std::endl;
}

bool Question::answer(int ans)
{
    ans--;

    if (_answers[ans] == _a)
    {
        _correct = 1;
        return true;
    }
    return false;
}

enum class GameStates { INIT, PLAY, EXIT };

class Quiz
{
private:
    std::vector<Question> _questions;

    GameStates _currentState;

    int _correctAnswers;
public:
    Quiz() : _currentState(GameStates::INIT), _correctAnswers(0) {}

    ~Quiz()
    {
        cleanup();
    }

    void run();

    bool initialise();
    bool setQuestions();

    void gameLoop();

    void askQuestion();

    int checkScore();

    void cleanup();
};


void Quiz::run()
{
    if (_currentState != GameStates::INIT)
    {
        return;
    }
    if (!initialise())
    {
        std::cout << "ERROR: Quiz failed to initialise" << std::endl;
        return;
    }
    gameLoop();
    cleanup();
}
bool Quiz::initialise()
{
    if (!_questions.empty())
    {
        _questions.clear();
        _correctAnswers = 0;
    }
    if (setQuestions())
    {
        return true;
    }
    return false;
}
bool Quiz::setQuestions()
{
    _questions.push_back(
        Question("What...is your name?", "Sir Lancelot of Camelot",
                 "Uh...er...ah...Joe?", "Uh...Princess Peach Fuzz?",
                 "Sir Geldof of Bob?"));
    _questions.push_back(
        Question("What...is your quest?", "To seek the Holy Grail",
                 "To...uh...find the cup of Christ", "To not do well at chess",
                 "To not choose this answer"));
    _questions.push_back(Question("What...is your favourite color?", "Blue",
                                  "Blue! NO! YELLOOOOOOOOWW!!!", "Greeeen?",
                                  "Uh...er...Africa"));
    _questions.push_back(Question(
                             "What...is the capital of Assyria?", "Ninev.hpp", "Used to be Assur",
                             "In the past it was Numrud", "At one time it was at Dur Sarukin"));
    _questions.push_back(
        Question("What...is the airspeed velocity of an unladen swallow?",
                 "An African or European Swallow?", "Uh uh .hpp", "Uh...er...ah",
                 "Well...I don't know..."));

    _currentState = GameStates::PLAY;
    return true;
}
void Quiz::gameLoop()
{
    char choice;

    while (_currentState != GameStates::EXIT)
    {
        askQuestion();
        checkScore();

        std::cout << "You scored: " << _correctAnswers << "/5" << std::endl;
        if (_correctAnswers == 5)
        {
            cout << "I say, jolly well done old chap.\n"; 
        }
        else
        {
            cout << "Better luck next time. Perhaps something with less thinking would be more your style.\n";
        }

        std::cout << "Play Again? ";
        std::cin >> choice;

        if (choice == 'n' || choice == 'N')
        {
            _currentState = GameStates::EXIT;
        }
        else
        {
            initialise();
        }
    }
}
void Quiz::askQuestion()
{
    int choice = 0;

    for (int i = 0; i < _questions.size(); i++)
    {
        std::cout << "Question " << i + 1 << ": ";
        _questions[i].getQuestion();

        std::cout << "Answer (1-4): ";
        std::cin >> choice;

        if (choice < 1 || choice > 4)
        {
            std::cout << "Incorrect choice" << std::endl;
            i--;
            continue;
        }
        _questions[i].answer(choice);
    }
}
int Quiz::checkScore()
{
    for (int i = 0; i < _questions.size(); i++)
    {
        if (_questions[i].isCorrect())
        {
            _correctAnswers++;
        }
    }
    return _correctAnswers;
}
void Quiz::cleanup()
{
    _questions.clear();
    _correctAnswers = 0;
}

int main(int argc, const char *argv[])
{
    try
    {
        Quiz q;

        q.run();

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Question 1: What...is your name?

Uh...er...ah...Joe?
Uh...Princess Peach Fuzz?
Sir Geldof of Bob?
Sir Lancelot of Camelot

Answer (1-4): 3
Question 2: What...is your quest?

To...uh...find the cup of Christ
To seek the Holy Grail
To not do well at chess
To not choose this answer

Answer (1-4): 2
Question 3: What...is your favourite color?

Greeeen?
Uh...er...Africa
Blue! NO! YELLOOOOOOOOWW!!!
Blue

Answer (1-4): 4
Question 4: What...is the capital of Assyria?

Used to be Assur
In the past it was Numrud
At one time it was at Dur Sarukin
Ninev.hpp

Answer (1-4): 4
Question 5: What...is the airspeed velocity of an unladen swallow?

Uh uh .hpp
An African or European Swallow?
Uh...er...ah
Well...I don't know...

Answer (1-4): 2
You scored: 4/5
Better luck next time. Perhaps something with less thinking would be more your style.
Play Again? n

ch05_p24.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

inline double calculateTax(double baseAmount)
{
    return baseAmount * 0.23;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Program to calculate tax rate of 23%" << std::endl;
        std::cout << "Enter expenses (-1 to quit): ";
        double dAmount;
        double dAmountTotal = 0.0;
        while (std::cin >> dAmount && dAmount > 0)
        {
            dAmountTotal += dAmount;
            std::cout << "Enter expenses (-1 to quit): ";
        }

        std::cout << "Total amount: " << dAmountTotal << std::endl;
        std::cout << "Tax: " << calculateTax(dAmountTotal) << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to calculate tax rate of 23%
Enter expenses (-1 to quit): 100
Enter expenses (-1 to quit): 200
Enter expenses (-1 to quit): 300
Enter expenses (-1 to quit): 500
Enter expenses (-1 to quit): 1000
Enter expenses (-1 to quit): -1
Total amount: 2100
Tax: 483

第6章 函数和递归入门
6.1 简介
6.2 C++的程序组件
6.3 数学库函数
6.4 具有多个形参的函数定义
6.5 函数原型和实参类型的强制转换
6.6 C++标准库头文件
6.7 实例研究：随机数生成
6.8 实例研究：博彩游戏和枚举类型简介
6.9 C++11的随机数
6.10 存储类别和存储期
6.11 作用域规则
6.12 函数调用堆栈和活动记录
6.13 无形参的函数
6.14 内联函数
6.15 引用和引用形参
6.16 默认实参
6.17 一元的作用域分辨运算符
6.18 函数重载
6.19 函数模板
6.20 递归
6.21 递归应用示例：Fibonacci（斐波那契）数列
6.22 递归与迭代
6.23 本章小结
ch06_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

const double BASE_HOURS = 3.0;
const double MINIMUM_FEE = 2.00;
const double PART_CHARGE = 0.50;
const double MAXIMUM_FEE = 10.0;

double calculateCharges(double hours)
{
    if (hours >= 24)
    {
        return MAXIMUM_FEE;
    }
    if (hours <= BASE_HOURS)
    {
        return MINIMUM_FEE;
    }
    double charge = MINIMUM_FEE + ((ceil(hours - BASE_HOURS)) * PART_CHARGE);

    return (charge <= MAXIMUM_FEE) ? charge : MAXIMUM_FEE;
}

int main(int argc, const char *argv[])
{
    try
    {
        double hours1;
        double hours2;
        double hours3;

        std::cout << "Program to calculate parking charges for 3 cars." << std::endl;
        std::cout << "Enter hours parked of 3 cars: ";
        std::cin >> hours1 >> hours2 >> hours3;

        std::cout << "Car" << std::setw(15) << "Hours" << std::setw(15) << "Charge" << std::endl;

        double charges1 = calculateCharges(hours1);
        double charges2 = calculateCharges(hours2);
        double charges3 = calculateCharges(hours3);

        std::cout << std::fixed << std::setprecision(2);
        std::cout << "1" << std::setw(17) << hours1 << std::setw(10) << "$" << charges1 << std::endl;
        std::cout << "2" << std::setw(17) << hours2 << std::setw(10) << "$" << charges2 << std::endl;
        std::cout << "3" << std::setw(17) << hours3 << std::setw(10) << "$" << charges3 << std::endl;
        std::cout << "TOTAL" << std::setw(13) << hours1 + hours2 + hours3
                  << std::setw(10) << "$" << charges1 + charges2 + charges3 << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to calculate parking charges for 3 cars.
Enter hours parked of 3 cars: 1 4 24
Car          Hours         Charge
1             1.00         $2.00
2             4.00         $2.50
3            24.00         $10.00
TOTAL        29.00         $14.50

ch06_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Program to round number to the nearest integer." << std::endl;
        std::cout << "Enter a number to round (-1 to exit): ";
        double num;
        while (std::cin >> num && num != -1)
        {
            std::cout << "num: " << num << "\nnearest integer: " << nearbyint(num) << std::endl;
            std::cout << "Enter a number to round (-1 to exit): ";
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to round number to the nearest integer.
Enter a number to round (-1 to exit): 1.3
num: 1.3
nearest integer: 1
Enter a number to round (-1 to exit): 1.5
num: 1.5
nearest integer: 2
Enter a number to round (-1 to exit): 1.9
num: 1.9
nearest integer: 2
Enter a number to round (-1 to exit): 2.0
num: 2
nearest integer: 2
Enter a number to round (-1 to exit): 2.1
num: 2.1
nearest integer: 2
Enter a number to round (-1 to exit): 1.0
num: 1
nearest integer: 1
Enter a number to round (-1 to exit): -1.3
num: -1.3
nearest integer: -1
Enter a number to round (-1 to exit): -1.5
num: -1.5
nearest integer: -2
Enter a number to round (-1 to exit): -1.9
num: -1.9
nearest integer: -2
Enter a number to round (-1 to exit): -2.1
num: -2.1
nearest integer: -2
Enter a number to round (-1 to exit): -1

ch06_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

double roundToInteger(double num)
{
    return nearbyint(num);
}
double roundToTenths(double num)
{
    return nearbyint(num * 10.0) / 10.0;
}
double roundToHundreths(double num)
{
    return nearbyint(num * 100.0) / 100.0;
}
double roundToThousandths(double num)
{
    return nearbyint(num * 1000.0) / 1000.0;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Program to round numbers to int, 10s, 100s and 1000s." << std::endl;
        std::cout << "Enter a number to round (-1 to exit): ";
        double num;
        while (std::cin >> num && num != -1)
        {
            std::cout << "Original: " << num
                      << "\nroundToInteger: " << roundToInteger(num)
                      << "\nroundToTenths: " << roundToTenths(num)
                      << "\nroundToHundredths: " << roundToHundreths(num)
                      << "\nroundToThousandths: " << roundToThousandths(num)
                      << std::endl;

            std::cout << "Enter a number to round (-1 to exit): ";
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to round numbers to int, 10s, 100s and 1000s.
Enter a number to round (-1 to exit): 3.1415926
Original: 3.14159
roundToInteger: 3
roundToTenths: 3.1
roundToHundredths: 3.14
roundToThousandths: 3.142
Enter a number to round (-1 to exit): -1

ch06_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

std::random_device rd;
std::mt19937 gen(rd());

int getRandomNumber(const int &min, const int &max)
{
    return std::uniform_int_distribution<int> {min, max}(gen);
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Program to assign random integers to variables in the following ranges." << std::endl;

        std::cout << "1 <= n <= 2: " << getRandomNumber(1, 2)
                  << "\n1 <= n <= 100: " << getRandomNumber(1, 100)
                  << "\n0 <= n <= 9: " << getRandomNumber(0, 9)
                  << "\n1000 <= n <= 1112: " << getRandomNumber(1000, 1112)
                  << "\n-1 <= n <= 1: " << getRandomNumber(-1, 1)
                  << "\n-3 <= n <= 11: " << getRandomNumber(-3, 11) << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to assign random integers to variables in the following ranges.
1 <= n <= 2: 1
1 <= n <= 100: 25
0 <= n <= 9: 2
1000 <= n <= 1112: 1023
-1 <= n <= 1: 0
-3 <= n <= 11: -1

ch06_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

std::random_device rd;
std::mt19937 gen(rd());

int getRandomNumber(const int &min, const int &max)
{
    return std::uniform_int_distribution<int> {min, max}(gen);
}

int main(int argc, const char *argv[])
{
    try
    {
        std::vector<int> v1 {2, 4, 6, 8, 10, 3, 5, 7, 9, 11, 6, 10, 14, 18, 22};

        std::cout << "Random number from each of the following sets: " << std::endl;
        std::cout << "2 4 6 8 10: " << v1[getRandomNumber(0, 4)];
        std::cout << "\n3 5 7 9 11: " << v1[getRandomNumber(5, 9)];
        std::cout << "\n6 10 14 18 22: " << v1[getRandomNumber(10, v1.size() - 1)] << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Random number from each of the following sets:
2 4 6 8 10: 4
3 5 7 9 11: 5
6 10 14 18 22: 18

ch06_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int integerPower(int base, int exponent)
{
    if (exponent <= 0)
    {
        return 1;
    }

    return base * integerPower(base, exponent - 1);
}

int main(int argc, const char *argv[])
{
    try
    {
        int base, exponent;

        std::cout << "Enter base and exponent: ";
        std::cin >> base >> exponent;

        std::cout << base << " to the power of " << exponent << ": "
                  << integerPower(base, exponent) << std::endl;
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter base and exponent: 2 3
2 to the power of 3: 8

Enter base and exponent: 3 2
3 to the power of 2: 9

ch06_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

double hypotenuse(double sideA, double sideB)
{
    return sqrt(pow(sideA, 2) + pow(sideB, 2));
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Triangle" << std::setw(10) << "Side1" << std::setw(10)
                  << "Side2" << std::setw(15) << "Hypotenuse" << std::endl;

        std::cout << "1" << std::setw(15) << "3.0" << std::setw(10) << "4.0"
                  << std::setw(8) << hypotenuse(3.0, 4.0) << std::endl;

        std::cout << "2" << std::setw(15) << "5.0" << std::setw(11) << "12.0"
                  << std::setw(8) << hypotenuse(5.0, 12.0) << std::endl;

        std::cout << "3" << std::setw(15) << "8.0" << std::setw(11) << "15.0"
                  << std::setw(8) << hypotenuse(8.0, 15.0) << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Triangle     Side1     Side2     Hypotenuse
1            3.0       4.0       5
2            5.0       12.0      13
3            8.0       15.0      17

ch06_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

inline bool multiple(int x, int y)
{
    return (y % x == 0);
}

int main(int argc, const char *argv[])
{
    try
    {

        std::cout << "Program to determine if second integer is a multiple of first integer." << std::endl;
        std::cout << "Enter two integers (-1 to quit): ";
        int x;
        int y;
        while (std::cin >> x && x > 0 && std::cin >> y && y > 0)
        {
            std::cout << x << " and " << y << (multiple(x, y) ? ": true" : ": false") << std::endl;
            std::cout << "Enter two integers (-1 to quit): ";
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to determine if second integer is a multiple of first integer.
Enter two integers (-1 to quit): 3 15
3 and 15: true
Enter two integers (-1 to quit): 2 9
2 and 9: false
Enter two integers (-1 to quit): 2 8
2 and 8: true
Enter two integers (-1 to quit): -1

ch06_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

inline bool isEven(int x)
{
    return (x % 2 == 0);
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Program to determine whether an integer is even." << std::endl;
        std::cout << "Enter an integer (-1 to quit): ";
        int input;
        while (std::cin >> input && input >= 0)
        {
            std::cout << input << ":" << (isEven(input) ? "" : " not") << " even" << std::endl;
            std::cout << "Enter an integer (-1 to quit): ";
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to determine whether an integer is even.
Enter an integer (-1 to quit): 0
0: even
Enter an integer (-1 to quit): 1
1: not even
Enter an integer (-1 to quit): 2
2: even
Enter an integer (-1 to quit): 3
3: not even
Enter an integer (-1 to quit): 4
4: even
Enter an integer (-1 to quit): 5
5: not even
Enter an integer (-1 to quit): 6
6: even
Enter an integer (-1 to quit): -1

ch06_p10.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

void displaySquare(int n)
{
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            std::cout << "*";
        }
        std::cout << std::endl;
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Program to display a square of asterisks of size n." << std::endl;
        std::cout << "Enter side: ";
        int side;
        std::cin >> side;

        displaySquare(side);
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to display a square of asterisks of size n.
Enter side: 3
***
***
***

Program to display a square of asterisks of size n.
Enter side: 5
*****
*****
*****
*****
*****

ch06_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

void squareOfChars(int n, char fillChar)
{
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            std::cout << fillChar;
        }
        std::cout << std::endl;
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Program to print a square of size n of any character." << std::endl;
        std::cout << "Enter side: ";
        int n;
        std::cin >> n;

        std::cout << "Enter char: ";
        char fillChar;
        std::cin >> fillChar;

        squareOfChars(n, fillChar);

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to print a square of size n of any character.
Enter side: 5
Enter char: +
+++++
+++++
+++++
+++++
+++++

ch06_p12.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

void separateInt(long n)
{
    string s = to_string(n);
    for (int i = 0; i < s.size(); ++i)
    {
        cout << s[i] << ' ';
    }
    std::cout << std::endl;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "A program to print a separated a sequence of integers." << std::endl;
        std::cout << "Enter multi digit integer: ";
        long n;
        std::cin >> n;

        separateInt(n);

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
A program to print a separated a sequence of integers.
Enter multi digit integer: 56789
5 6 7 8 9

ch06_p13.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

long numSeconds(int h, int m, int s)
{
    return ((h * 60) * 60) + (m * 60) + s;
}

int main(int argc, const char *argv[])
{
    try
    {
        int h1, m1, s1;
        int h2, m2, s2;

        std::cout << "Program to print number of elapsed seconds between n and n." << std::endl;

        std::cout << "Enter hours minutes seconds (start time): ";
        std::cin >> h1 >> m1 >> s1;

        std::cout << "Enter hours minutes seconds (finish time): ";
        std::cin >> h2 >> m2 >> s2;

        std::cout << "Difference: "
                  << (numSeconds(h2, m2, s2) - numSeconds(h1, m1, s1))
                  << " seconds." << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to print number of elapsed seconds between n and n.
Enter hours minutes seconds (start time): 12 15 35
Enter hours minutes seconds (finish time): 18 18 39
Difference: 21784 seconds.

ch06_p14.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

inline double celsius(double f)
{
    return (f - 32.0) * 5.0 / 9.0;
}

inline double farenheit(double c)
{
    return c * 9.0 / 5.0 + 32.0;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Farenheit equivalent of Celsius 0 to 100\n" << std::endl;
        std::cout << "Celsius\tFarenheit" << std::fixed << std::setprecision(1) << std::endl;

        for (int c = 0; c <= 100; ++c)
        {
            std::cout << static_cast<double>(c) << "\t" << farenheit(static_cast<double>(c)) << std::endl;
        }

        std::cout << "\nCelsius equivalent of Farenheit 32 to 212\n" << std::endl;
        std::cout << "Farenheit\tCelsius" << std::fixed << std::setprecision(1) << std::endl;

        for (int f = 32; f <= 212; f++)
        {
            std::cout << static_cast<double>(f) << "\t" << celsius(static_cast<double>(f)) << std::endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Farenheit equivalent of Celsius 0 to 100

Celsius Farenheit
0.0     32.0
1.0     33.8
2.0     35.6
3.0     37.4
4.0     39.2
5.0     41.0
6.0     42.8
7.0     44.6
8.0     46.4
9.0     48.2
10.0    50.0
11.0    51.8
12.0    53.6
13.0    55.4
14.0    57.2
15.0    59.0
16.0    60.8
17.0    62.6
18.0    64.4
19.0    66.2
20.0    68.0
21.0    69.8
22.0    71.6
23.0    73.4
24.0    75.2
25.0    77.0
26.0    78.8
27.0    80.6
28.0    82.4
29.0    84.2
30.0    86.0
31.0    87.8
32.0    89.6
33.0    91.4
34.0    93.2
35.0    95.0
36.0    96.8
37.0    98.6
38.0    100.4
39.0    102.2
40.0    104.0
41.0    105.8
42.0    107.6
43.0    109.4
44.0    111.2
45.0    113.0
46.0    114.8
47.0    116.6
48.0    118.4
49.0    120.2
50.0    122.0
51.0    123.8
52.0    125.6
53.0    127.4
54.0    129.2
55.0    131.0
56.0    132.8
57.0    134.6
58.0    136.4
59.0    138.2
60.0    140.0
61.0    141.8
62.0    143.6
63.0    145.4
64.0    147.2
65.0    149.0
66.0    150.8
67.0    152.6
68.0    154.4
69.0    156.2
70.0    158.0
71.0    159.8
72.0    161.6
73.0    163.4
74.0    165.2
75.0    167.0
76.0    168.8
77.0    170.6
78.0    172.4
79.0    174.2
80.0    176.0
81.0    177.8
82.0    179.6
83.0    181.4
84.0    183.2
85.0    185.0
86.0    186.8
87.0    188.6
88.0    190.4
89.0    192.2
90.0    194.0
91.0    195.8
92.0    197.6
93.0    199.4
94.0    201.2
95.0    203.0
96.0    204.8
97.0    206.6
98.0    208.4
99.0    210.2
100.0   212.0

Celsius equivalent of Farenheit 32 to 212

Farenheit       Celsius
32.0    0.0
33.0    0.6
34.0    1.1
35.0    1.7
36.0    2.2
37.0    2.8
38.0    3.3
39.0    3.9
40.0    4.4
41.0    5.0
42.0    5.6
43.0    6.1
44.0    6.7
45.0    7.2
46.0    7.8
47.0    8.3
48.0    8.9
49.0    9.4
50.0    10.0
51.0    10.6
52.0    11.1
53.0    11.7
54.0    12.2
55.0    12.8
56.0    13.3
57.0    13.9
58.0    14.4
59.0    15.0
60.0    15.6
61.0    16.1
62.0    16.7
63.0    17.2
64.0    17.8
65.0    18.3
66.0    18.9
67.0    19.4
68.0    20.0
69.0    20.6
70.0    21.1
71.0    21.7
72.0    22.2
73.0    22.8
74.0    23.3
75.0    23.9
76.0    24.4
77.0    25.0
78.0    25.6
79.0    26.1
80.0    26.7
81.0    27.2
82.0    27.8
83.0    28.3
84.0    28.9
85.0    29.4
86.0    30.0
87.0    30.6
88.0    31.1
89.0    31.7
90.0    32.2
91.0    32.8
92.0    33.3
93.0    33.9
94.0    34.4
95.0    35.0
96.0    35.6
97.0    36.1
98.0    36.7
99.0    37.2
100.0   37.8
101.0   38.3
102.0   38.9
103.0   39.4
104.0   40.0
105.0   40.6
106.0   41.1
107.0   41.7
108.0   42.2
109.0   42.8
110.0   43.3
111.0   43.9
112.0   44.4
113.0   45.0
114.0   45.6
115.0   46.1
116.0   46.7
117.0   47.2
118.0   47.8
119.0   48.3
120.0   48.9
121.0   49.4
122.0   50.0
123.0   50.6
124.0   51.1
125.0   51.7
126.0   52.2
127.0   52.8
128.0   53.3
129.0   53.9
130.0   54.4
131.0   55.0
132.0   55.6
133.0   56.1
134.0   56.7
135.0   57.2
136.0   57.8
137.0   58.3
138.0   58.9
139.0   59.4
140.0   60.0
141.0   60.6
142.0   61.1
143.0   61.7
144.0   62.2
145.0   62.8
146.0   63.3
147.0   63.9
148.0   64.4
149.0   65.0
150.0   65.6
151.0   66.1
152.0   66.7
153.0   67.2
154.0   67.8
155.0   68.3
156.0   68.9
157.0   69.4
158.0   70.0
159.0   70.6
160.0   71.1
161.0   71.7
162.0   72.2
163.0   72.8
164.0   73.3
165.0   73.9
166.0   74.4
167.0   75.0
168.0   75.6
169.0   76.1
170.0   76.7
171.0   77.2
172.0   77.8
173.0   78.3
174.0   78.9
175.0   79.4
176.0   80.0
177.0   80.6
178.0   81.1
179.0   81.7
180.0   82.2
181.0   82.8
182.0   83.3
183.0   83.9
184.0   84.4
185.0   85.0
186.0   85.6
187.0   86.1
188.0   86.7
189.0   87.2
190.0   87.8
191.0   88.3
192.0   88.9
193.0   89.4
194.0   90.0
195.0   90.6
196.0   91.1
197.0   91.7
198.0   92.2
199.0   92.8
200.0   93.3
201.0   93.9
202.0   94.4
203.0   95.0
204.0   95.6
205.0   96.1
206.0   96.7
207.0   97.2
208.0   97.8
209.0   98.3
210.0   98.9
211.0   99.4
212.0   100.0

ch06_p15.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template <typename T>
const T &my_max(const T &a, const T &b)
{
    return (a > b) ? a : b;
}

template <typename T>
const T &my_min(const T &a, const T &b)
{
    return (a < b) ? a : b;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Program to find the smallest of 3 doubles." << std::endl;
        std::cout << "Enter three double values: ";
        double d1, d2, d3;
        std::cin >> d1 >> d2 >> d3;

        std::cout << std::fixed << std::setprecision(1)
                  << "Smallest: " << my_min(d1, my_min(d2, d3)) << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to find the smallest of 3 doubles.
Enter three double values: 1.1 2.2 3.3
Smallest: 1.1

ch06_p16.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

vector<int> primes_norm;

bool is_prime(int n)
{
    for (int i = 0; i < primes_norm.size() && primes_norm[i] <= sqrt(n); ++i)
    {
        if (n % primes_norm[i] == 0)
        {
            return false;
        }
    }
    return true;
}

int getPrimeFactor(int n)
{
    if (n <= 1)
    {
        return 0;
    }

    for (int i = 0; i < primes_norm.size() && primes_norm[i] <= sqrt(n); ++i)
    {
        if (n % primes_norm[i] == 0)
        {
            return primes_norm[i];
        }
    }

    return 0;
}

string isPerfect(int n)
{
    if (is_prime(n))
    {
        return "";
    }

    string s = "";
    int remainder = n;
    int currentSum = 1;
    bool isFirstTerm = true;
    while (true)
    {
        int primeFactor = getPrimeFactor(remainder);
        if (!isFirstTerm)
        {
            s += ", ";
        }
        s += to_string(primeFactor);
        currentSum += primeFactor;
        remainder = (remainder / primeFactor);

        if (is_prime(remainder))
        {
            s += ", " + to_string(remainder);
            currentSum += remainder;
            break;
        }
    }
    if (currentSum == n)
    {
        return s;
    }
    else
    {
        return "";
    }
}

int main(int argc, const char *argv[])
{
    int n_primes = 2000;
    primes_norm.push_back(2);
    int i = 3;
    while (primes_norm.size() < n_primes)
    {
        if (is_prime(i))
        {
            primes_norm.push_back(i);
        }
        i += 2;
    }

    try
    {
        std::cout << "Program to test whether a number is perfect or not." << std::endl;
        std::cout << "Perfect number between 2 and 1000: " << std::endl;
        string s;
        for (long i = 2; i <= 1000; i++)
        {
            s = isPerfect(i);
            if (s.size() > 0)
            {
                std::cout << i << ":" << "\t" << s << std::endl;
            }
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to test whether a number is perfect or not.
Perfect number between 2 and 1000:
6:      2, 3

ch06_p17.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

vector<int> primes_norm;

bool is_prime(int n)
{
    for (int i = 0; i < primes_norm.size() && primes_norm[i] <= sqrt(n); ++i)
    {
        if (n % primes_norm[i] == 0)
        {
            return false;
        }
    }
    return true;
}

int main(int argc, const char *argv[])
{
    int n_primes = 10000;
    primes_norm.push_back(2);
    int i = 3;
    while (primes_norm.size() < n_primes)
    {
        if (is_prime(i))
        {
            primes_norm.push_back(i);
        }
        i += 2;
    }

    try
    {
        std::cout << "A program to print all prime numbers between 2 and 10000." << std::endl;
        int j = 0;
        for (int i = 2; i <= 10000; i++)
        {
            if (is_prime(i))
            {
                std::cout << i << "\t";
                ++j;
                if (j % 8 == 0)
                {
                    std::cout << std::endl;
                }
            }
        }
        if (j % 8 != 0)
        {
            std::cout << std::endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
A program to print all prime numbers between 2 and 10000.
2       3       5       7       11      13      17      19
23      29      31      37      41      43      47      53
59      61      67      71      73      79      83      89
97      101     103     107     109     113     127     131
137     139     149     151     157     163     167     173
179     181     191     193     197     199     211     223
227     229     233     239     241     251     257     263
269     271     277     281     283     293     307     311
313     317     331     337     347     349     353     359
367     373     379     383     389     397     401     409
419     421     431     433     439     443     449     457
461     463     467     479     487     491     499     503
509     521     523     541     547     557     563     569
571     577     587     593     599     601     607     613
617     619     631     641     643     647     653     659
661     673     677     683     691     701     709     719
727     733     739     743     751     757     761     769
773     787     797     809     811     821     823     827
829     839     853     857     859     863     877     881
883     887     907     911     919     929     937     941
947     953     967     971     977     983     991     997
1009    1013    1019    1021    1031    1033    1039    1049
1051    1061    1063    1069    1087    1091    1093    1097
1103    1109    1117    1123    1129    1151    1153    1163
1171    1181    1187    1193    1201    1213    1217    1223
1229    1231    1237    1249    1259    1277    1279    1283
1289    1291    1297    1301    1303    1307    1319    1321
1327    1361    1367    1373    1381    1399    1409    1423
1427    1429    1433    1439    1447    1451    1453    1459
1471    1481    1483    1487    1489    1493    1499    1511
1523    1531    1543    1549    1553    1559    1567    1571
1579    1583    1597    1601    1607    1609    1613    1619
1621    1627    1637    1657    1663    1667    1669    1693
1697    1699    1709    1721    1723    1733    1741    1747
1753    1759    1777    1783    1787    1789    1801    1811
1823    1831    1847    1861    1867    1871    1873    1877
1879    1889    1901    1907    1913    1931    1933    1949
1951    1973    1979    1987    1993    1997    1999    2003
2011    2017    2027    2029    2039    2053    2063    2069
2081    2083    2087    2089    2099    2111    2113    2129
2131    2137    2141    2143    2153    2161    2179    2203
2207    2213    2221    2237    2239    2243    2251    2267
2269    2273    2281    2287    2293    2297    2309    2311
2333    2339    2341    2347    2351    2357    2371    2377
2381    2383    2389    2393    2399    2411    2417    2423
2437    2441    2447    2459    2467    2473    2477    2503
2521    2531    2539    2543    2549    2551    2557    2579
2591    2593    2609    2617    2621    2633    2647    2657
2659    2663    2671    2677    2683    2687    2689    2693
2699    2707    2711    2713    2719    2729    2731    2741
2749    2753    2767    2777    2789    2791    2797    2801
2803    2819    2833    2837    2843    2851    2857    2861
2879    2887    2897    2903    2909    2917    2927    2939
2953    2957    2963    2969    2971    2999    3001    3011
3019    3023    3037    3041    3049    3061    3067    3079
3083    3089    3109    3119    3121    3137    3163    3167
3169    3181    3187    3191    3203    3209    3217    3221
3229    3251    3253    3257    3259    3271    3299    3301
3307    3313    3319    3323    3329    3331    3343    3347
3359    3361    3371    3373    3389    3391    3407    3413
3433    3449    3457    3461    3463    3467    3469    3491
3499    3511    3517    3527    3529    3533    3539    3541
3547    3557    3559    3571    3581    3583    3593    3607
3613    3617    3623    3631    3637    3643    3659    3671
3673    3677    3691    3697    3701    3709    3719    3727
3733    3739    3761    3767    3769    3779    3793    3797
3803    3821    3823    3833    3847    3851    3853    3863
3877    3881    3889    3907    3911    3917    3919    3923
3929    3931    3943    3947    3967    3989    4001    4003
4007    4013    4019    4021    4027    4049    4051    4057
4073    4079    4091    4093    4099    4111    4127    4129
4133    4139    4153    4157    4159    4177    4201    4211
4217    4219    4229    4231    4241    4243    4253    4259
4261    4271    4273    4283    4289    4297    4327    4337
4339    4349    4357    4363    4373    4391    4397    4409
4421    4423    4441    4447    4451    4457    4463    4481
4483    4493    4507    4513    4517    4519    4523    4547
4549    4561    4567    4583    4591    4597    4603    4621
4637    4639    4643    4649    4651    4657    4663    4673
4679    4691    4703    4721    4723    4729    4733    4751
4759    4783    4787    4789    4793    4799    4801    4813
4817    4831    4861    4871    4877    4889    4903    4909
4919    4931    4933    4937    4943    4951    4957    4967
4969    4973    4987    4993    4999    5003    5009    5011
5021    5023    5039    5051    5059    5077    5081    5087
5099    5101    5107    5113    5119    5147    5153    5167
5171    5179    5189    5197    5209    5227    5231    5233
5237    5261    5273    5279    5281    5297    5303    5309
5323    5333    5347    5351    5381    5387    5393    5399
5407    5413    5417    5419    5431    5437    5441    5443
5449    5471    5477    5479    5483    5501    5503    5507
5519    5521    5527    5531    5557    5563    5569    5573
5581    5591    5623    5639    5641    5647    5651    5653
5657    5659    5669    5683    5689    5693    5701    5711
5717    5737    5741    5743    5749    5779    5783    5791
5801    5807    5813    5821    5827    5839    5843    5849
5851    5857    5861    5867    5869    5879    5881    5897
5903    5923    5927    5939    5953    5981    5987    6007
6011    6029    6037    6043    6047    6053    6067    6073
6079    6089    6091    6101    6113    6121    6131    6133
6143    6151    6163    6173    6197    6199    6203    6211
6217    6221    6229    6247    6257    6263    6269    6271
6277    6287    6299    6301    6311    6317    6323    6329
6337    6343    6353    6359    6361    6367    6373    6379
6389    6397    6421    6427    6449    6451    6469    6473
6481    6491    6521    6529    6547    6551    6553    6563
6569    6571    6577    6581    6599    6607    6619    6637
6653    6659    6661    6673    6679    6689    6691    6701
6703    6709    6719    6733    6737    6761    6763    6779
6781    6791    6793    6803    6823    6827    6829    6833
6841    6857    6863    6869    6871    6883    6899    6907
6911    6917    6947    6949    6959    6961    6967    6971
6977    6983    6991    6997    7001    7013    7019    7027
7039    7043    7057    7069    7079    7103    7109    7121
7127    7129    7151    7159    7177    7187    7193    7207
7211    7213    7219    7229    7237    7243    7247    7253
7283    7297    7307    7309    7321    7331    7333    7349
7351    7369    7393    7411    7417    7433    7451    7457
7459    7477    7481    7487    7489    7499    7507    7517
7523    7529    7537    7541    7547    7549    7559    7561
7573    7577    7583    7589    7591    7603    7607    7621
7639    7643    7649    7669    7673    7681    7687    7691
7699    7703    7717    7723    7727    7741    7753    7757
7759    7789    7793    7817    7823    7829    7841    7853
7867    7873    7877    7879    7883    7901    7907    7919
7927    7933    7937    7949    7951    7963    7993    8009
8011    8017    8039    8053    8059    8069    8081    8087
8089    8093    8101    8111    8117    8123    8147    8161
8167    8171    8179    8191    8209    8219    8221    8231
8233    8237    8243    8263    8269    8273    8287    8291
8293    8297    8311    8317    8329    8353    8363    8369
8377    8387    8389    8419    8423    8429    8431    8443
8447    8461    8467    8501    8513    8521    8527    8537
8539    8543    8563    8573    8581    8597    8599    8609
8623    8627    8629    8641    8647    8663    8669    8677
8681    8689    8693    8699    8707    8713    8719    8731
8737    8741    8747    8753    8761    8779    8783    8803
8807    8819    8821    8831    8837    8839    8849    8861
8863    8867    8887    8893    8923    8929    8933    8941
8951    8963    8969    8971    8999    9001    9007    9011
9013    9029    9041    9043    9049    9059    9067    9091
9103    9109    9127    9133    9137    9151    9157    9161
9173    9181    9187    9199    9203    9209    9221    9227
9239    9241    9257    9277    9281    9283    9293    9311
9319    9323    9337    9341    9343    9349    9371    9377
9391    9397    9403    9413    9419    9421    9431    9433
9437    9439    9461    9463    9467    9473    9479    9491
9497    9511    9521    9533    9539    9547    9551    9587
9601    9613    9619    9623    9629    9631    9643    9649
9661    9677    9679    9689    9697    9719    9721    9733
9739    9743    9749    9767    9769    9781    9787    9791
9803    9811    9817    9829    9833    9839    9851    9857
9859    9871    9883    9887    9901    9907    9923    9929
9931    9941    9949    9967    9973

ch06_p18.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

long str_to_num(const string &s)
{
    if (s.size() <= 0)
    {
        return 0;
    }
    const int base = 10;
    long b = 1;
    long sum = 0;
    char c;
    for (int i = s.size() - 1; i >= 0; --i)
    {
        c = s[i];
        if (c < '0' || c > '9')
        {
            return 0;
        }
        sum += ((c - '0') * b);
        b *= base;
    }
    return sum;
}
long reverseDigits(long n)
{
    if (n == 0)
    {
        return 0;
    }
    bool negetive = false;
    if (n < 0)
    {
        negetive = true;
        n = -n;
    }
    string s = to_string(n);
    for (int i = 0, j = s.size() - 1; i < j; ++i, --j)
    {
        swap(s[i], s[j]);
    }
    n = str_to_num(s);
    if (negetive)
    {
        n = -n;
    }
    return n;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Program to reverse the digits of a given integer." << std::endl;
        std::cout << "Enter a number to be reversed: ";
        long n;
        std::cin >> n;

        std::cout << "\n" << reverseDigits(n) << std::endl;
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to reverse the digits of a given integer.
Enter a number to be reversed:12345

54321

Program to reverse the digits of a given integer.
Enter a number to be reversed: 0

0

Program to reverse the digits of a given integer.
Enter a number to be reversed: -12345

-54321

ch06_p19.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int gcd(int a, int b)
{
    while (b != 0)
    {
        int t = b;
        b = a % b;
        a = t;
    }
    return a;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Program to print the gcd of two integers." << std::endl;
        std::cout << "Enter two integers: ";
        int num1, num2;
        std::cin >> num1 >> num2;

        if (num1 < 0) { num1 = -num1; }
        if (num2 < 0) { num2 = -num2; }
        if (num1 > 0 && num2 > 0)
       {
            std::cout << "Greatest Common Divisor: " << gcd(num1, num2) << std::endl;
       }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to print the gcd of two integers.
Enter two integers: 195 273
Greatest Common Divisor: 39

ch06_p20.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int qualityPoints(int average)
{
    if (average >= 90)
    {
        return 4;
    }
    else if (average >= 80)
    {
        return 3;
    }
    else if (average >= 70)
    {
        return 2;
    }
    else if (average >= 60)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Input student average: ";
        int average = 0;
        std::cin >> average;

        std::cout << "Quality Point: " << qualityPoints(average) << std::endl;
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Input student average: 99
Quality Point: 4

Input student average: 89
Quality Point: 3

Input student average: 79
Quality Point: 2

Input student average: 69
Quality Point: 1

Input student average: 59
Quality Point: 0

ch06_p21.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


std::random_device rd;
std::mt19937 gen(rd());

int getRandomNumber(const int &min, const int &max)
{
    return std::uniform_int_distribution<int> {min, max}(gen);
}

inline int flip()
{
    return std::uniform_int_distribution<int> {0, 1}(gen);
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Program to simulate coin tossing." << std::endl;

        int heads = 0;
        int tails = 0;

        for (int i = 1; i <= 100; ++i)
        {
            std::cout << i << ": ";

            if (flip() == 1)
            {
                std::cout << "heads" << std::endl;
                heads++;
            }
            else
            {
                std::cout << "tails" << std::endl;
                tails++;
            }
        }

        std::cout << "\nHeads: " << heads << "\nTails:" << tails << std::endl;
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下

Program to simulate coin tossing.
1: heads
2: heads
3: tails
4: tails
5: heads
6: tails
7: tails
8: tails
9: heads
10: tails
11: tails
12: tails
13: heads
14: tails
15: tails
16: heads
17: heads
18: tails
19: tails
20: tails
21: tails
22: tails
23: tails
24: heads
25: tails
26: tails
27: heads
28: heads
29: heads
30: heads
31: tails
32: heads
33: tails
34: tails
35: heads
36: heads
37: tails
38: heads
39: heads
40: heads
41: heads
42: heads
43: tails
44: tails
45: tails
46: tails
47: heads
48: tails
49: heads
50: tails
51: heads
52: tails
53: tails
54: heads
55: heads
56: heads
57: tails
58: tails
59: tails
60: heads
61: tails
62: heads
63: heads
64: tails
65: tails
66: tails
67: tails
68: tails
69: heads
70: heads
71: heads
72: tails
73: tails
74: tails
75: tails
76: heads
77: tails
78: tails
79: heads
80: tails
81: heads
82: heads
83: heads
84: tails
85: heads
86: tails
87: heads
88: heads
89: heads
90: heads
91: heads
92: tails
93: tails
94: tails
95: heads
96: tails
97: heads
98: tails
99: heads
100: heads

Heads: 47
Tails:53

ch06_p22.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


enum class GameStates { PLAY, EXIT, WON };

class GuessTheNumber
{
private:
    GameStates _currentState;

    const int MIN = 0;
    const int MAX = 1000;

    int _randNumber;
    int _playerGuess;
    char _playerContinue;

    std::mt19937 gen;

    void initialise();
    GameStates guess(int) const;
    int getRandomNumber();

public:
    GuessTheNumber();
    ~GuessTheNumber() {}

    void run();
};

int GuessTheNumber::getRandomNumber()
{
    return std::uniform_int_distribution<int> {MIN, MAX}(gen);
}

GuessTheNumber::GuessTheNumber() : gen(std::random_device()())
{
    initialise();
}
void GuessTheNumber::initialise()
{
    _currentState = GameStates::PLAY;

    _randNumber = getRandomNumber();

    cout << "I have a number between " << MIN << " and " << MAX << endl;
}

GameStates GuessTheNumber::guess(int playerGuess) const
{
    if (playerGuess == _randNumber)
    {
        std::cout << "Excellent! You guessed the number!" << std::endl;
        return GameStates::WON;
    }

    cout << "Too " << (playerGuess < _randNumber ? "low" : "high") << " Try again." << endl;
    return GameStates::PLAY;
}

void GuessTheNumber::run()
{
    while (_currentState != GameStates::EXIT)
    {
        if (_currentState == GameStates::PLAY)
        {
            cout << "\nCan you guess my number?\nPlease type your guess: ";
            std::cin >> _playerGuess;

            _currentState = guess(_playerGuess);
        }
        if (_currentState == GameStates::WON)
        {
            std::cout << "Would you like to play again (y or n)? ";
            std::cin >> _playerContinue;

            if (_playerContinue == 'y')
            {
                initialise();
            }
            else
            {
                _currentState = GameStates::EXIT;
            }
        }
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        GuessTheNumber gtn;

        gtn.run();
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
I have a number between 0 and 1000

Can you guess my number?
Please type your guess: 200
Too low Try again.

Can you guess my number?
Please type your guess: 500
Too low Try again.

Can you guess my number?
Please type your guess: 800
Too high Try again.

Can you guess my number?
Please type your guess: 650
Too high Try again.

Can you guess my number?
Please type your guess: 550
Too low Try again.

Can you guess my number?
Please type your guess: 600
Too low Try again.

Can you guess my number?
Please type your guess: 620
Too high Try again.

Can you guess my number?
Please type your guess: 616
Too high Try again.

Can you guess my number?
Please type your guess: 610
Too high Try again.

Can you guess my number?
Please type your guess: 605
Too high Try again.

Can you guess my number?
Please type your guess: 602
Too low Try again.

Can you guess my number?
Please type your guess: 603
Excellent! You guessed the number!
Would you like to play again (y or n)? n

ch06_p23.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


enum class GameStates { PLAY, EXIT, WON };

class GuessTheNumber
{
private:
    GameStates _currentState;

    const int MIN = 0;
    const int MAX = 1000;

    int _randNumber;
    int _playerGuess;
    char _playerContinue;
    int _numGuesses;

    std::mt19937 gen;

    void initialise();
    GameStates guess(int);
    int getRandomNumber();
    void victoryMessage() const;

public:
    GuessTheNumber();
    ~GuessTheNumber() {}

    void run();
};

void GuessTheNumber::victoryMessage() const
{
    if (_numGuesses == 10)
    {
        cout << "\nGuesses: " << _numGuesses << "\nAhah! You know the secret!\n";
    }
    else if (_numGuesses < 10)
    {
        cout << "\nGuesses: " << _numGuesses << "\nEither you know the secret or you got lucky!\n";
    }
    else
    {
        cout << "\nGuesses: " << _numGuesses << "\nYou should be able to do better!\n";
    }
}

int GuessTheNumber::getRandomNumber()
{
    return std::uniform_int_distribution<int> {MIN, MAX}(gen);
}

GuessTheNumber::GuessTheNumber() : gen(std::random_device()())
{
    initialise();
}
void GuessTheNumber::initialise()
{
    _currentState = GameStates::PLAY;

    _randNumber = getRandomNumber();
    _numGuesses = 0;

    cout << "I have a number between " << MIN << " and " << MAX << endl;
}

GameStates GuessTheNumber::guess(int playerGuess)
{
    _numGuesses++;
    if (playerGuess == _randNumber)
    {
        std::cout << "Excellent! You guessed the number!" << std::endl;
        return GameStates::WON;
    }

    cout << "Too " << (playerGuess < _randNumber ? "low" : "high") << " Try again." << endl;
    return GameStates::PLAY;
}

void GuessTheNumber::run()
{
    while (_currentState != GameStates::EXIT)
    {
        if (_currentState == GameStates::PLAY)
        {
            cout << "\nCan you guess my number?\nPlease type your guess: ";
            std::cin >> _playerGuess;
            if (_playerGuess < MIN || _playerGuess > MAX)
            {
                cout << "\nInvalid guess. Your number needs to be between " << MIN << " and " << MAX << endl;
                continue;
            }

            _currentState = guess(_playerGuess);
        }
        if (_currentState == GameStates::WON)
        {
            victoryMessage();

            std::cout << "Would you like to play again (y or n)? ";
            std::cin >> _playerContinue;

            if (_playerContinue == 'y')
            {
                initialise();
            }
            else
            {
                _currentState = GameStates::EXIT;
            }
        }
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        GuessTheNumber gtn;

        gtn.run();
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下

I have a number between 0 and 1000

Can you guess my number?
Please type your guess: 500
Too low Try again.

Can you guess my number?
Please type your guess: 750
Too low Try again.

Can you guess my number?
Please type your guess: 875
Too low Try again.

Can you guess my number?
Please type your guess: 938
Too low Try again.

Can you guess my number?
Please type your guess: 970
Too low Try again.

Can you guess my number?
Please type your guess: 986
Too low Try again.

Can you guess my number?
Please type your guess: 994
Too low Try again.

Can you guess my number?
Please type your guess: 999
Too low Try again.

Can you guess my number?
Please type your guess: 1000
Excellent! You guessed the number!

Guesses: 9
Either you know the secret or you got lucky!
Would you like to play again (y or n)? n

ch06_p24.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int power(int base, int exponent)
{
    if (exponent == 0)
    {
        return 1;
    }

    return base * power(base, exponent - 1);
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "A program to recursively calculate exponents." << std::endl;
        std::cout << "Enter the base and exponent: ";
        int base, exponent;
        std::cin >> base >> exponent;
        if (exponent >= 0)
        {
            cout << base << " to the power of " << exponent << ": " << power(base, exponent) << endl;
        }
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
A program to recursively calculate exponents.
Enter the base and exponent: 3 2
3 to the power of 2: 9

A program to recursively calculate exponents.
Enter the base and exponent: 2 3
2 to the power of 3: 8

ch06_p25.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int fibonacci(int n)
{
    if (n == 0)
    {
        return 0;
    }
    if (n == 1)
    {
        return 1;
    }
    int fib = 0;
    int firstTerm = 0;
    int secondTerm = 1;

    for (int i = 2; i <= n; ++i)
    {
        fib = firstTerm + secondTerm;
        firstTerm = secondTerm;
        secondTerm = fib;
    }

    return fib;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Program to non recursively calculate fibonacci to n." << std::endl;
        std::cout << "Enter n: ";
        int n;
        std::cin >> n;
        if (n >= 0)
        {
            cout << "Fibonacci(" << n << ") =  " << fibonacci(n) << endl;
        }
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to non recursively calculate fibonacci to n.
Enter n: 0
Fibonacci(0) =  0

Program to non recursively calculate fibonacci to n.
Enter n: 1
Fibonacci(1) =  1

Program to non recursively calculate fibonacci to n.
Enter n: 2
Fibonacci(2) =  1

Program to non recursively calculate fibonacci to n.
Enter n: 3
Fibonacci(3) =  2

Program to non recursively calculate fibonacci to n.
Enter n: 4
Fibonacci(4) =  3

Program to non recursively calculate fibonacci to n.
Enter n: 5
Fibonacci(5) =  5

Program to non recursively calculate fibonacci to n.
Enter n: 6
Fibonacci(6) =  8

Program to non recursively calculate fibonacci to n.
Enter n: 7
Fibonacci(7) =  13

Program to non recursively calculate fibonacci to n.
Enter n: 8
Fibonacci(8) =  21

Program to non recursively calculate fibonacci to n.
Enter n: 9
Fibonacci(9) =  34

ch06_p26.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

struct Disc
{
    int size = 0;
    Disc *next = nullptr;
    Disc *previous = nullptr;
};

Disc *getSmallestDisk(Disc *p_list);
int getSmallestDiskSize(Disc *p_list, Disc **p_smallest);

Disc *addNewToLinkedList(Disc *p_list, int size);
Disc *addToLinkedListBeginning(Disc *head, Disc *node);
Disc *addToLinkedListEnd(Disc *head, Disc *node);
Disc *removeFromLinkedList(Disc *p_list, Disc *p_item);

struct Discs
{
    Disc *head = nullptr;

    Disc *pop()
    {
        Disc *smallestDisk = getSmallestDisk(head);
        head = removeFromLinkedList(head, smallestDisk);
        return smallestDisk;
    }

    void push(Disc *disc)
    {
        head = addToLinkedListBeginning(head, disc);
    }
};

Discs *generatePegA(int size);
void moveDisc(int discSize, Discs *source, Discs *target, Discs *auxiliary);

void printList(Discs *p_list);
void printAllLists(Discs *pegA, Discs *pegB, Discs *pegC);

Discs *pegA;
Discs *pegB;
Discs *pegC;
int iteration = 0;

Discs *generatePegA(int size)
{
    Disc *p_items = nullptr;
    for (int i = 1; i <= size; i++)
    {
        p_items = addNewToLinkedList(p_items, i);
    }

    Discs *pegA = new Discs;
    pegA->head = p_items;
    return pegA;
}

void moveDisc(int discSize, Discs *source, Discs *target, Discs *auxiliary)
{
    if (discSize > 0)
    {
        moveDisc(discSize - 1, source, auxiliary, target);

        target->push(source->pop());

        cout << "Iteration " << ++iteration;
        printAllLists(pegA, pegB, pegC);

        moveDisc(discSize - 1, auxiliary, target, source);
    }
}
Disc *getSmallestDisk(Disc *p_list)
{
    Disc *p_smallest = nullptr;

    getSmallestDiskSize(p_list, &p_smallest);

    return p_smallest;
}
int getSmallestDiskSize(Disc *p_list, Disc **p_smallest)
{
    Disc *p_current = p_list;
    Disc *p_temp;

    int minSize = p_current->size;
    p_temp = p_current;
    while (p_current != nullptr)
    {
        if (p_current->size < minSize)
        {
            minSize = p_current->size;
            p_temp = p_current;
        }
        p_current = p_current->next;
    }
    if (p_smallest != nullptr)
    {
        *p_smallest = p_temp;
    }
    return minSize;
}
Disc *addNewToLinkedList(Disc *p_list, int size)
{
    Disc *p_item = new Disc;
    p_item->size = size;

    return addToLinkedListEnd(p_list, p_item);
}
Disc *addToLinkedListEnd(Disc *head, Disc *node)
{
    if (head == nullptr)
    {
        node->previous = head;
        node->next = nullptr;
        return node;
    }
    else
    {
        Disc *temp = head;

        while (temp->next != nullptr)
        {
            temp = temp->next;
        }

        temp->next = node;
        node->previous = temp;
        node->next = nullptr;
        return head;
    }
}
Disc *addToLinkedListBeginning(Disc *head, Disc *node)
{
    if (head == nullptr)
    {
        node->previous = nullptr;
        node->next = head;
        return node;
    }
    else
    {
        Disc *temp = head;
        node->previous = nullptr;
        node->next = temp;
        temp->previous = node;
        return node;
    }
}
Disc *removeFromLinkedList(Disc *p_list, Disc *p_item)
{
    Disc *p_next = p_item->next;
    Disc *p_previous = p_item->previous;
    p_item->next = nullptr;
    p_item->previous = nullptr;

    if (p_next == nullptr && p_previous == nullptr)
    {
        return nullptr;
    }

    if ( p_next != nullptr && p_previous == nullptr )
    {
        p_next->previous = p_previous;
        return p_next;
    }

    if (p_next == nullptr && p_previous != nullptr)
    {
        p_previous->next = p_next;
    }
    else if (p_next != nullptr && p_previous != nullptr)
    {
        p_previous->next = p_next;
        p_next->previous = p_previous;
    }

    while (p_previous->previous != nullptr)
    {
        p_previous = p_previous->previous;
    }

    return p_previous;
}
void printAllLists(Discs *pegA, Discs *pegB, Discs *pegC)
{
    cout << '\n';
    cout << "Peg A:\n";
    printList(pegA);
    cout << '\n';

    cout << "Peg B:\n";
    printList(pegB);
    cout << '\n';

    cout << "Peg C:\n";
    printList(pegC);
    cout << '\n';
}
void printList(Discs *p_list)
{
    if (p_list == nullptr || p_list->head == nullptr)
    {
        cout << "Disk peg is empty.\n";
        return;
    }

    cout << "Printing the list...\n";
    Disc *p_current = p_list->head;
    while (p_current != nullptr)
    {
        cout << "Disk Size: " << p_current->size << '\n';
        p_current = p_current->next;
    }
    cout << '\n';
}

int main(int argc, const char *argv[])
{
    try
    {
        const int minDiscSize = 2;
        int maxDiscSize = minDiscSize;
        do
        {
            cout << "Please enter the maximum disk size: ";
            cin >> maxDiscSize;
        }
        while (maxDiscSize < minDiscSize);

        pegA = generatePegA(maxDiscSize);
        pegB = new Discs;
        pegC = new Discs;

        printAllLists(pegA, pegB, pegC);

        cout << '\n';
        cout << "Solving the Tower of Hanoi Problem using recursion.\n\n";
        moveDisc(maxDiscSize, pegA, pegC, pegB);

        if (pegA->head != nullptr)
        {
            Disc *p_current = pegA->head;
            Disc *p_next;
            while (p_current != nullptr)
            {
                p_next = p_current->next;
                delete p_current;
                p_current = p_next;
            }
        }
        delete pegA;

        if (pegB->head != nullptr)
        {
            Disc *p_current = pegB->head;
            Disc *p_next;
            while (p_current != nullptr)
            {
                p_next = p_current->next;
                delete p_current;
                p_current = p_next;
            }
        }
        delete pegB;

        if (pegC->head != nullptr)
        {
            Disc *p_current = pegC->head;
            Disc *p_next;
            while (p_current != nullptr)
            {
                p_next = p_current->next;
                delete p_current;
                p_current = p_next;
            }
        }
        delete pegC;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Please enter the maximum disk size: 3

Peg A:
Printing the list...
Disk Size: 1
Disk Size: 2
Disk Size: 3


Peg B:
Disk peg is empty.

Peg C:
Disk peg is empty.


Solving the Tower of Hanoi Problem using recursion.

Iteration 1
Peg A:
Printing the list...
Disk Size: 2
Disk Size: 3


Peg B:
Disk peg is empty.

Peg C:
Printing the list...
Disk Size: 1


Iteration 2
Peg A:
Printing the list...
Disk Size: 3


Peg B:
Printing the list...
Disk Size: 2


Peg C:
Printing the list...
Disk Size: 1


Iteration 3
Peg A:
Printing the list...
Disk Size: 3


Peg B:
Printing the list...
Disk Size: 1
Disk Size: 2


Peg C:
Disk peg is empty.

Iteration 4
Peg A:
Disk peg is empty.

Peg B:
Printing the list...
Disk Size: 1
Disk Size: 2


Peg C:
Printing the list...
Disk Size: 3


Iteration 5
Peg A:
Printing the list...
Disk Size: 1


Peg B:
Printing the list...
Disk Size: 2


Peg C:
Printing the list...
Disk Size: 3


Iteration 6
Peg A:
Printing the list...
Disk Size: 1


Peg B:
Disk peg is empty.

Peg C:
Printing the list...
Disk Size: 2
Disk Size: 3


Iteration 7
Peg A:
Disk peg is empty.

Peg B:
Disk peg is empty.

Peg C:
Printing the list...
Disk Size: 1
Disk Size: 2
Disk Size: 3

ch06_p27.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

unsigned long factorial(unsigned long number)
{
    if (number <= 1)
    {
        std::cout << number << std::endl;
        return 1;
    }
    else
    {
        std::cout << number << " * ";
        return number * factorial(number - 1);
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        for (unsigned long counter = 0; counter <= 17; ++counter)
        {
            cout << counter << "! = " << factorial(counter) << endl;
        }
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
0! = 0
1
1! = 1
1
2! = 2 * 1
2
3! = 3 * 2 * 1
6
4! = 4 * 3 * 2 * 1
24
5! = 5 * 4 * 3 * 2 * 1
120
6! = 6 * 5 * 4 * 3 * 2 * 1
720
7! = 7 * 6 * 5 * 4 * 3 * 2 * 1
5040
8! = 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
40320
9! = 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
362880
10! = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
3628800
11! = 11 * 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
39916800
12! = 12 * 11 * 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
479001600
13! = 13 * 12 * 11 * 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
6227020800
14! = 14 * 13 * 12 * 11 * 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
87178291200
15! = 15 * 14 * 13 * 12 * 11 * 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
1307674368000
16! = 16 * 15 * 14 * 13 * 12 * 11 * 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
20922789888000
17! = 17 * 16 * 15 * 14 * 13 * 12 * 11 * 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
355687428096000

ch06_p28.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int gcd(int a, int b)
{
    while (b != 0)
    {
        int t = b;
        b = a % b;
        a = t;
    }
    return a;
}

int gcd_rec(int x, int y)
{
    if (y == 0)
    {
        return x;
    }
    else
    {
        return gcd(y, x % y);
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Program to recursively find the gcd of two numbers." << std::endl;
        std::cout << "Enter x and y: ";
        int x, y;
        std::cin >> x >> y;
        if (x < 0) { x = -x; }
        if (y < 0) { y = -y; }
        if (x > 0 && y > 0)
       {
            std::cout << "Greatest Common Divisor: " << ( x > y ? gcd(x, y) : gcd(y, x) ) << std::endl;
            std::cout << "Greatest Common Divisor: " << ( x > y ? gcd_rec(x, y) : gcd_rec(y, x) ) << std::endl;
       }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to recursively find the gcd of two numbers.
Enter x and y: 195 273
Greatest Common Divisor: 39
Greatest Common Divisor: 39

ch06_p29.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

struct Points
{
    Points(double X, double Y)
    {
        x = X;
        y = Y;
    }

    double x;
    double y;
};

double distance(Points pointA, Points pointB)
{
    double diffX = pointA.x - pointB.x;
    double diffY = pointA.y - pointB.y;

    return sqrt((diffY * diffY) + (diffX * diffX));
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Program to print the distance between two points." << std::endl;
        Points pointA(1, 5);
        Points pointB(2, 6);

        std::cout << "Distance between (" << pointA.x << "," << pointA.y << ") and (" << pointB.x << "," << pointB.y << ") = " 
                      << distance(pointA, pointB) << std::endl;
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Program to print the distance between two points.
Distance between (1,5) and (2,6) = 1.41421

ch06_p30.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

const double PI = 3.14159;

inline double circleArea(double r)
{
    return PI * (r * r);
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "A program to print the area of a circle from the radius" << std::endl;
        std::cout << "Enter circle radius: ";
        double radius;
        std::cin >> radius;

        std::cout << std::fixed << std::setprecision(2) << "Area: " << circleArea(radius) << std::endl;
        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
A program to print the area of a circle from the radius
Enter circle radius: 5
Area: 78.54

ch06_p31.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

inline int tripleByValue(int n)
{
    return n * n * n;
}
inline int tripleByReference(const int &n)
{
    return n * n * n;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Demonstrating passing parameters by reference and value." << endl;

        int count = 3;

        std::cout << "tripleByValue = " << tripleByValue(count) << std::endl;
        std::cout << "tripleByReference = " << tripleByReference(count) << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Demonstrating passing parameters by reference and value.
tripleByValue = 27
tripleByReference = 27

ch06_p32.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template <typename T>
const T &my_max(const T &a, const T &b)
{
    return (a > b) ? a : b;
}

template <typename T>
const T &my_min(const T &a, const T &b)
{
    return (a < b) ? a : b;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "my_min(91,78): " << my_min(91, 78) << std::endl;
        std::cout << "my_min('x', 'G'): " << my_min('x', 'G') << std::endl;
        std::cout << "my_min(61.25, 68.5): " << my_min(61.25, 68.5) << std::endl;

        std::cout << "my_max(58, 78): " << my_max(58, 78) << std::endl;
        std::cout << "my_max('A', '#'): " << my_max('A', '#') << std::endl;
        std::cout << "my_max(1.359, 1.3598): " << my_max(1.359, 1.3598) << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
my_min(91,78): 78
my_min('x', 'G'): G
my_min(61.25, 68.5): 61.25
my_max(58, 78): 78
my_max('A', '#'): A
my_max(1.359, 1.3598): 1.3598

第7章 类模板array和vector、异常捕获
7.1 简介
7.2 array对象
7.3 array对象的声明
7.4 使用array对象的例子
7.5 基于范围的for语句
7.6 实例研究：利用array对象存放成绩的GradeBook类
7.7 array对象的排序与查找
7.8 多维array对象
7.9 实例研究：利用二维array对象的GradeBook类
7.10 C++标准库类模板vector的介绍
7.11 本章小结
ch07_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

const size_t salaryRange = 9;

int main(int argc, const char *argv[])
{
    try
    {
        int arrSalaries[salaryRange] = {};
        std::cout << "Enter salary (-1 to quit): ";
        int choice;
        while (std::cin >> choice && choice > 0)
        {
            if (choice > 999)
            {
                ++arrSalaries[8];
            }
            else if (choice > 899)
            {
                ++arrSalaries[7];
            }
            else if (choice > 799)
            {
                ++arrSalaries[6];
            }
            else if (choice > 699)
            {
                ++arrSalaries[5];
            }
            else if (choice > 599)
            {
                ++arrSalaries[4];
            }
            else if (choice > 499)
            {
                ++arrSalaries[3];
            }
            else if (choice > 399)
            {
                ++arrSalaries[2];
            }
            else if (choice > 299)
            {
                ++arrSalaries[1];
            }
            else if (choice >= 200)
            {
                ++arrSalaries[0];
            }
            std::cout << "Enter salary (-1 to quit): ";
        }

        for (int i = 0; i < salaryRange; ++i)
        {
            if (i != salaryRange - 1)
            {
                std::cout << "$" << i + 2 << "00-" << i + 2 << "99: " << arrSalaries[i] << std::endl;
            }
            else
            {
                std::cout << "$1000+:   " << arrSalaries[i] << std::endl;
            }
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter salary (-1 to quit): 222
Enter salary (-1 to quit): 333
Enter salary (-1 to quit): 555
Enter salary (-1 to quit): 666
Enter salary (-1 to quit): 777
Enter salary (-1 to quit): 888
Enter salary (-1 to quit): 1111
Enter salary (-1 to quit): -1
$200-299: 1
$300-399: 1
$400-499: 0
$500-599: 1
$600-699: 1
$700-799: 1
$800-899: 1
$900-999: 0
$1000+:   1

ch07_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

std::random_device rd;
std::mt19937 gen(rd());

int getRandomNumber(const int &min, const int &max)
{
    return std::uniform_int_distribution<int> {min, max}(gen);
}

const int limit = 10;

int main(int argc, const char *argv[])
{
    try
    {
        vector<int> v1;

        for (int i = 0; i < limit; ++i)
        {
            v1.push_back(getRandomNumber(0, 100));
        }

        std::cout << "Unsorted array: " << std::endl;
        cout << v1 << endl;
        sort(v1.begin(), v1.end());

        std::cout << "\nSorted array : " << std::endl;
        cout << v1 << endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Unsorted array:
{ 70, 57, 62, 90, 35, 90, 34, 11, 32, 78 }

Sorted array :
{ 11, 32, 34, 35, 57, 62, 70, 78, 90, 90 }

ch07_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}


std::random_device rd;
std::mt19937 gen(rd());

int getRandomNumber(const int &min, const int &max)
{
    return std::uniform_int_distribution<int> {min, max}(gen);
}

const int limit = 30;

int main(int argc, const char *argv[])
{
    try
    {
        vector<int> v1;

        for (int i = 0; i < limit; ++i)
        {
            v1.push_back(getRandomNumber(0, 100));
        }

        std::cout << "before unique: " << std::endl;
        cout << v1 << endl;

        sort(v1.begin(), v1.end());
       std::cout << "sort : " << std::endl;
        cout << v1 << endl;

        std::vector<int>::iterator end = unique(v1.begin(), v1.end());
        v1.erase(end, v1.end());

        std::cout << "after unique: " << std::endl;
        cout << v1 << endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
before unique:
{ 43, 74, 14, 47, 61, 11, 32, 34, 45, 68, 56, 80, 86, 15, 83, 37, 51, 84, 48, 99, 12, 2, 17, 69, 25, 34, 18, 42, 37, 86 }
sort :
{ 2, 11, 12, 14, 15, 17, 18, 25, 32, 34, 34, 37, 37, 42, 43, 45, 47, 48, 51, 56, 61, 68, 69, 74, 80, 83, 84, 86, 86, 99 }
after unique:
{ 2, 11, 12, 14, 15, 17, 18, 25, 32, 34, 37, 42, 43, 45, 47, 48, 51, 56, 61, 68, 69, 74, 80, 83, 84, 86, 99 }

第8章 指针
8.1 简介
8.2 指针变量的声明和初始化
8.3 指针运算符
8.4 使用指针的按引用传递方式
8.5 内置数组
8.6 使用const修饰指针
8.7 sizeof运算符
8.8 指针表达式和指针算术运算
8.9 指针和内置数组之间的关系
8.10 基于指针的字符串
8.11 本章小结

第9章 类的深入剖析：抛出异常
9.1 简介
9.2 Time类实例研究.
9.3 类的作用域和类成员的访问
9.4 访问函数和工具函数
9.5 Time类实例研究：具有默认实参的构造函数
9.6 析构函数
9.7 何时调用构造函数和析构函数
9.8 Time类实例研究：微妙的陷阱-返回private数据成员的引用或指针
9.9 默认的逐个成员赋值
9.10 const对象和const成员函数
9.11 组成：对象作为类的成员
9.12 friend函数和friend类
9.13 使用this指针
9.14 static类成员
9.15 本章小结
ch09_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Time
{
private:
    int hour;
    int minute;
    int second;
public:
    Time();
    Time(int, int, int);

    void setTime(int, int, int);
    void setHour(int);
    void setMinute(int);
    void setSecond(int);

    int getHour();
    int getMinute();
    int getSecond();

    void printUniversal();
    void printStandard();
};

Time::Time()
{
    time_t currentTime;
    struct tm *localTime;

    time(&currentTime);

    localTime = localtime(&currentTime);

    hour = localTime->tm_hour;
    minute = localTime->tm_min;
    second = localTime->tm_sec;
}

Time::Time(int hour, int minute, int second)
{
    setTime(hour, minute, second);
}

void Time::setTime(int h, int m, int s)
{
    setHour(h);
    setMinute(m);
    setSecond(s);
}

void Time::setHour(int h)
{
    if (h >= 0 && h <= 23)
    {
        hour = h;
    }
    else
    {
        throw std::invalid_argument("hour must be 0-23");
    }
}
void Time::setMinute(int m)
{
    if (m >= 0 && m <= 59)
    {
        minute = m;
    }
    else
    {
        throw std::invalid_argument("minute must be 0-59");
    }
}
void Time::setSecond(int s)
{
    if (s >= 0 && s <= 59)
    {
        second = s;
    }
    else
    {
        throw std::invalid_argument("second must be 0-59");
    }
}
int Time::getHour()
{
    return hour;
}
int Time::getMinute()
{
    return minute;
}
int Time::getSecond()
{
    return second;
}
void Time::printUniversal()
{
    std::cout << std::setfill('0') << std::setw(2) << getHour() << ":"
              << std::setw(2) << getMinute() << ":" << std::setw(2) << getSecond();
}
void Time::printStandard()
{
    std::cout << ((getHour() == 0 || getHour() == 12) ? 12 : getHour() % 12)
              << ":" << std::setfill('0') << std::setw(2) << getMinute() << ":"
              << std::setw(2) << getSecond() << (hour < 12 ? " AM" : " PM");
}

int main(int argc, const char *argv[])
{
    try
    {
        Time time1;
        Time time2(12, 12, 12);

        std::cout << "time1: ";
        time1.printUniversal();
        std::cout << std::endl;
        time1.printStandard();
        std::cout << std::endl;

        std::cout << "time2: ";
        time2.printUniversal();
        std::cout << std::endl;
        time2.printStandard();
        std::cout << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
time1: 13:09:55
1:09:55 PM
time2: 12:12:12
12:12:12 PM

ch09_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Complex
{
private:
    double m_real;
    double m_imag;
public:
    Complex();
    Complex(double n1, double n2);
    ~Complex();
    friend Complex operator + (const Complex &n1, const Complex &n2);
    friend Complex operator - (const Complex &n1, const Complex &n2);
    friend Complex operator * (const Complex &n1, const Complex &n2);
    friend Complex operator * (double num, const Complex &n);
    friend Complex operator * (const Complex &n, double num);
    friend Complex operator ~ (const Complex &c);
    friend std::istream &operator>>(std::istream &is, Complex &c);
    friend std::ostream &operator<<(std::ostream &os, const Complex &c);
};


Complex::Complex()
{
    m_real = 0;
    m_imag = 0;
}
Complex::Complex(double n1, double n2)
{
    m_real = n1;
    m_imag = n2;
}
Complex::~Complex()
{

}
Complex operator + (const Complex &n1, const Complex &n2)
{
    return Complex (n1.m_real + n2.m_real, n1.m_imag + n2.m_imag);
}
Complex operator - (const Complex &n1, const Complex &n2)
{
    return Complex (n1.m_real - n2.m_real, n1.m_imag - n2.m_imag);
}
Complex operator * (const Complex &n1, const Complex &n2)
{
    return Complex ( (n1.m_real * n2.m_real) - (n1.m_imag * n2.m_imag),  (n1.m_real * n2.m_imag) + (n1.m_imag * n2.m_real));
}
Complex operator * (double num, const Complex &n)
{
    return Complex (n.m_real * num, n.m_imag * num);
}
Complex operator * (const Complex &n, double num)
{
    return Complex (n.m_real * num, n.m_imag * num);
}
Complex operator ~ (const Complex &c)
{
    return Complex (c.m_real, -c.m_imag);
}
std::istream &operator >> (std::istream &is, Complex &c)
{
    std::cout << "real: ";
    if (is >> c.m_real)
    {
        std::cout << "imaginary: ";
        is >> c.m_imag;
    }
    return is;
}
std::ostream &operator<<(std::ostream &os, const Complex &c)
{
    os << "(" << c.m_real << ", " << c.m_imag << "i)";
    return os;
}

int main(int argc, const char *argv[])
{
    try
    {
        Complex a(3.0, 4.0);
        Complex c;

        std::cout << "Enter a complex number (q to quit) :\n";
        while (std::cin >> c)
        {
            std::cout << "c is " << c << '\n';
            std::cout << "complex conjugate is " << ~c << '\n';

            std::cout << "a is " << a << '\n';
            std::cout << "a + c is " << a + c << '\n';
            std::cout << "a - c is " << a - c << '\n';
            std::cout << "a * c is " << a *c << '\n';
            std::cout << "2 * c is " << 2 * c << '\n';
            std::cout << "Enter a complex number (q to quit) :\n";
        }
        std::cout << "Done.\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter a complex number (q to quit) :
real: 6
imaginary: 5
c is (6, 5i)
complex conjugate is (6, -5i)
a is (3, 4i)
a + c is (9, 9i)
a - c is (-3, -1i)
a * c is (-2, 39i)
2 * c is (12, 10i)
Enter a complex number (q to quit) :
real: q
Done.

ch09_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int gcd(int a, int b)
{
    while (b != 0)
    {
        int t = b;
        b = a % b;
        a = t;
    }
    return a;
}

class Rational
{
public:
    Rational() : numer(0), denom(1) { }
    Rational(int n) : numer(n), denom(1) { }
    Rational(int n, int d) : numer(n), denom(d)
    {
        normalise();
    }

    int get_numer() const
    {
        return numer;
    }
    int get_denom() const
    {
        return denom;
    }
    double conv_double() const
    {
        return double(numer) / denom;
    }

    void normalise()
    {
        if (denom == 0)
        {
            error("denominator is zero");
        }
        if (denom < 0)
        {
            denom = -denom;
            numer = -numer;
        }
        int n = 0;
        if (numer < 0)
        {
            n = gcd(-numer, denom);
        }
        else if (numer > 0)
        {
            n = gcd(numer, denom);
        }
        if (n > 1)
        {
            numer /= n;
            denom /= n;
        }
    }

private:
    int numer;
    int denom;
};

Rational operator+(const Rational &r1, const Rational &r2);
Rational operator-(const Rational &r1, const Rational &r2);
Rational operator*(const Rational &r1, const Rational &r2);
Rational operator/(const Rational &r1, const Rational &r2);
bool operator==(const Rational &r1, const Rational &r2);
bool operator!=(const Rational &r1, const Rational &r2);
ostream &operator<<(ostream &os, const Rational &r);

Rational operator+(const Rational &r1, const Rational &r2)
{
    Rational r(r1.get_numer()*r2.get_denom() + r1.get_denom()*r2.get_numer(),
               r1.get_denom()*r2.get_denom());
    r.normalise();
    return r;
}

Rational operator-(const Rational &r1, const Rational &r2)
{
    Rational r(r1.get_numer()*r2.get_denom() - r1.get_denom()*r2.get_numer(),
               r1.get_denom()*r2.get_denom());
    r.normalise();
    return r;
}

Rational operator*(const Rational &r1, const Rational &r2)
{
    Rational r(r1.get_numer()*r2.get_numer(), r1.get_denom()*r2.get_denom());
    r.normalise();
    return r;
}

Rational operator/(const Rational &r1, const Rational &r2)
{
    Rational r(r1.get_numer()*r2.get_denom(), r1.get_denom()*r2.get_numer());
    r.normalise();
    return r;
}

bool operator==(const Rational &r1, const Rational &r2)
{
    return r1.get_numer() * r2.get_denom() == r1.get_denom() * r2.get_numer();
}

bool operator!=(const Rational &r1, const Rational &r2)
{
    return !(r1 == r2);
}

ostream &operator<<(ostream &os, const Rational &r)
{
    return cout << '(' << r.get_numer() << '/' << r.get_denom() << ')';
}

int main(int argc, const char *argv[])
{
    try
    {
        Rational r1;
        Rational r2(5);
        Rational r3(7, 3);
        cout << "r1: " << r1 << endl
             << "r2: " << r2 << endl
             << "r3: " << r3 << endl;

        cout << "5/3 + 7/2 = " << Rational(5, 3) + Rational(7, 2) <<
             " = " << (Rational(5, 3) + Rational(7, 2)).conv_double() << endl;
        cout << "8/5 - 40/7 = " << Rational(8, 5) - Rational(40, 7) <<
             " = " << (Rational(8, 5) - Rational(40, 7)).conv_double() << endl;
        cout << "10/11 * 17/18 = " << Rational(10, 11) * Rational(17, 18) <<
             " = " << (Rational(10, 11) * Rational(17, 18)).conv_double() << endl;
        cout << "(5/7) / (1/3) = " << Rational(5, 7) / Rational(1, 3) <<
             " = " << (Rational(5, 7) / Rational(1, 3)).conv_double() << endl;

        if (r1 == Rational(0, 1))
        {
            cout << "r1 == 0/1" << endl;
        }
        if (Rational(1, 2) == Rational(2, 4))
        {
            cout << "1/2 == 2/4" << endl;
        }
        if (r2 != r2)
        {
            cout << "r2 != r2" << endl;
        }

        cout << r3 << " = " << r3.conv_double() << endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
r1: (0/1)
r2: (5/1)
r3: (7/3)
5/3 + 7/2 = (31/6) = 5.16667
8/5 - 40/7 = (-144/35) = -4.11429
10/11 * 17/18 = (85/99) = 0.858586
(5/7) / (1/3) = (15/7) = 2.14286
r1 == 0/1
1/2 == 2/4
(7/3) = 2.33333

ch09_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Time
{
private:
    int hour;
    int minute;
    int second;
public:
    Time();
    explicit Time(int, int, int);

    void setTime(int, int, int);
    void setHour(int);
    void setMinute(int);
    void setSecond(int);

    int getHour();
    int getMinute();
    int getSecond();

    void tick();

    void printUniversal();
    void printStandard();
};

Time::Time()
{
    time_t currentTime;
    struct tm *localTime;

    time(&currentTime);

    localTime = localtime(&currentTime);

    hour = localTime->tm_hour;
    minute = localTime->tm_min;
    second = localTime->tm_sec;
}

Time::Time(int hour, int minute, int second)
{
    setTime(hour, minute, second);
}

void Time::setTime(int h, int m, int s)
{
    setHour(h);
    setMinute(m);
    setSecond(s);
}

void Time::setHour(int h)
{
    if (h >= 0 && h <= 23)
    {
        hour = h;
    }
    else
    {
        throw std::invalid_argument("hour must be 0-23");
    }
}
void Time::setMinute(int m)
{
    if (m >= 0 && m <= 59)
    {
        minute = m;
    }
    else
    {
        throw std::invalid_argument("minute must be 0-59");
    }
}
void Time::setSecond(int s)
{
    if (s >= 0 && s <= 59)
    {
        second = s;
    }
    else
    {
        throw std::invalid_argument("second must be 0-59");
    }
}
int Time::getHour()
{
    return hour;
}
int Time::getMinute()
{
    return minute;
}
int Time::getSecond()
{
    return second;
}

void Time::tick()
{
    if (second < 59)
    {
        second++;
    }
    else
    {
        second = 0;
        if (minute < 59)
        {
            minute++;
        }
        else
        {
            minute = 0;
            if (hour < 23)
            {
                hour++;
            }
            else
            {
                hour = 0;
                minute = 0;
                second = 0;
            }
        }
    }
}

void Time::printUniversal()
{
    std::cout << std::setfill('0') << std::setw(2) << getHour() << ":"
              << std::setw(2) << getMinute() << ":" << std::setw(2) << getSecond();
}
void Time::printStandard()
{
    std::cout << ((getHour() == 0 || getHour() == 12) ? 12 : getHour() % 12)
              << ":" << std::setfill('0') << std::setw(2) << getMinute() << ":"
              << std::setw(2) << getSecond() << (hour < 12 ? " AM" : " PM");
}

int main(int argc, const char *argv[])
{
    try
    {
        Time t1(23, 59, 58);

        std::cout << "t1: ";

        t1.printUniversal();
        std::cout << " ";
        t1.printStandard();
        std::cout << std::endl;

        for (int i = 0; i < 100; ++i)
        {
            t1.tick();

            if (i % 10 == 0)
            {
                t1.printUniversal();

                std::cout << " ";

                t1.printStandard();

                std::cout << std::endl;
            }
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
t1: 23:59:58 11:59:58 PM
23:59:59 11:59:59 PM
00:00:09 12:00:09 AM
00:00:19 12:00:19 AM
00:00:29 12:00:29 AM
00:00:39 12:00:39 AM
00:00:49 12:00:49 AM
00:00:59 12:00:59 AM
00:01:09 12:01:09 AM
00:01:19 12:01:19 AM
00:01:29 12:01:29 AM

ch09_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

namespace Chrono
{
    class Date
    {
    public:
        enum Month
        {
            jan = 1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
        };

        Date(int y, Month m, int d);
        Date();

        int day() const
        {
            return d;
        }
        Month month() const
        {
            return m;
        }
        int year() const
        {
            return y;
        }

        void add_day(int n);
        void add_month(int n);
        void add_year(int n);
    private:
        int y;
        Month m;
        int d;
    };

    bool is_date(int y, Date::Month m, int d);
    bool leapyear(int y);

    int day_in_year(const Date &d);
    void split_date(int day_of_year, int year, int *month, int *day);
    int n_leapyears(int y);
    long int days_linear(const Date &d);

    enum Day
    {
        sunday, monday, tuesday, wednesday, thursday, friday, saturday
    };
    Day day_of_week(const Date &d);
    ostream &operator<<(ostream &os, Day d);

    bool operator==(const Date &a, const Date &b);
    bool operator!=(const Date &a, const Date &b);

    ostream &operator<<(ostream &os, const Date &d);
    istream &operator>>(istream &is, Date &dd);
}

namespace Chrono
{
    Date::Date(int yy, Month mm, int dd) : y(yy), m(mm), d(dd)
    {
        if (!is_date(yy, mm, dd))
        {
            error("invalid date");
        }
    }

    const Date &default_date()
    {
        static const Date dd(2001, Date::jan, 1);
        return dd;
    }

    Date::Date() : y(default_date().year()), m(default_date().month()), d(default_date().day()) { }

    int nmonth(Date::Month m)
    {
        switch (m)
        {
        case Date::jan:
            return 0;
        case Date::feb:
            return 31;
        case Date::mar:
            return 31 + 28;
        case Date::apr:
            return 31 + 28 + 31;
        case Date::may:
            return 31 + 28 + 31 + 30;
        case Date::jun:
            return 31 + 28 + 31 + 30 + 31;
        case Date::jul:
            return 31 + 28 + 31 + 30 + 31 + 30;
        case Date::aug:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31;
        case Date::sep:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31;
        case Date::oct:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30;
        case Date::nov:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31;
        case Date::dec:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30;
        }
    }

    void Date::add_day(int n)
    {
        int doy = nmonth(dec);
        doy += 31;
        if (leapyear(y - 1))
        {
            ++doy;
        }
        int diy = nmonth(dec);
        diy += 31;
        if (leapyear(y))
        {
            ++diy;
        }
        int day_of_year = day_in_year(*this);
        day_of_year += n;
        if (day_of_year >= 1 && day_of_year <= diy)
        {
            int res_month, res_day;
            split_date(day_of_year, y, &res_month, &res_day);
            m = Month(res_month);
            d = res_day;
        }
        else if (day_of_year > diy && day_of_year <= (diy + 365))
        {
            day_of_year -= diy;
            int res_month, res_day;
            split_date(day_of_year, y + 1, &res_month, &res_day);
            y++;
            m = Month(res_month);
            d = res_day;
        }
        else if (day_of_year < 1 && (day_of_year + doy) >= 1)
        {
            day_of_year += doy;
            int res_month, res_day;
            split_date(day_of_year, y - 1, &res_month, &res_day);
            y--;
            m = Month(res_month);
            d = res_day;
        }
    }

    void Date::add_month(int n)
    {
        int month = m + n;
        bool day_large = false;
        if (d > 28)
        {
            day_large = true;
            add_day(-3);
        }
        if (month >= jan && month <= dec)
        {
            m = Month(month);
            if (day_large == true)
            {
                add_day(3);
            }
        }
        else if (month > dec && month <= dec + 12)
        {
            month -= dec;
            y++;
            m = Month(month);
            if (day_large == true)
            {
                add_day(3);
            }
        }
        else if(month < jan && month + 12 >= 1)
        {
            month += 12;
            y--;
            m = Month(month);
            if (day_large == true)
            {
                add_day(3);
            }
        }
    }

    void Date::add_year(int n)
    {
        if (m == feb && d == 29 && !leapyear(y + n))
        {
            m = mar;
            d = 1;
        }
        y += n;
    }

    bool is_date(int y, Date::Month m, int d)
    {
        if (d <= 0)
        {
            return false;
        }

        int days_in_month = 31;

        switch (m)
        {
        case Date::feb:
            days_in_month = (leapyear(y)) ? 29 : 28;
            break;
        case Date::apr:
        case Date::jun:
        case Date::sep:
        case Date::nov:
            days_in_month = 30;
            break;
        }

        if (days_in_month < d)
        {
            return false;
        }

        return true;
    }

    bool leapyear(int y)
    {
        return (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;
    }

    bool operator==(const Date &a, const Date &b)
    {
        return a.year() == b.year() && a.month() == b.month() && a.day() == b.day();
    }

    bool operator!=(const Date &a, const Date &b)
    {
        return !(a == b);
    }

    ostream &operator<<(ostream &os, const Date &d)
    {
        return os << '(' << d.year() << ',' << d.month() << ',' << d.day() << ')';
    }

    istream &operator>>(istream &is, Date &dd)
    {
        int y, m, d;
        char ch1, ch2, ch3, ch4;
        is >> ch1 >> y >> ch2 >> m >> ch3 >> d >> ch4;
        if (!is)
        {
            return is;
        }
        if (ch1 != '(' || ch2 != ',' || ch3 != ',' || ch4 != ')')
        {
            is.clear(std::ios_base::failbit);
            return is;
        }
        dd = Date(y, Date::Month(m), d);
        return is;
    }

    ostream &operator<<(ostream &os, Day d)
    {
        switch (d)
        {
        case sunday:
            os << "Sunday";
            break;
        case monday:
            os << "Monday";
            break;
        case tuesday:
            os << "Tuesday";
            break;
        case wednesday:
            os << "Wednesday";
            break;
        case thursday:
            os << "Thursday";
            break;
        case friday:
            os << "Friday";
            break;
        case saturday:
            os << "Saturday";
            break;
        }
        return os;
    }

    const Date first_date = Date(1970, Date::jan, 1);
    const Day first_day = thursday;

    Day day_of_week(const Date &d)
    {
        if (d.year() < first_date.year())
        {
            error("day_of_week: works only for 1970 and later");
        }
        int dlin = days_linear(d);
        return Day((first_day + dlin) % 7);
    }

    Date next_Sunday(const Date &d)
    {
        Date nsd = d;
        Day day = day_of_week(d);
        nsd.add_day(7 - day);
        return nsd;
    }

    int day_in_year(const Date &d)
    {
        int diy = nmonth(d.month());
        diy += d.day();
        if (leapyear(d.year()) && d.month() > Date::feb)
        {
            ++diy;
        }
        return diy;
    }

    void split_date(int day_of_year, int year, int *month, int *day)
    {
        int i;
        bool found = false;

        for (i = 1; i <= 12 && !found; i++)
        {
            switch(i)
            {
            case 1:
            case 3:
            case 5:
            case 7:
            case 8:
            case 10:
            case 12:
                if (day_of_year <= 31)
                {
                    found = true;
                }
                else
                {
                    day_of_year -= 31;
                }
                break;
            case 4:
            case 6:
            case 9:
            case 11:
                if (day_of_year <= 30)
                {
                    found = true;
                }
                else
                {
                    day_of_year -= 30;
                }
                break;
            case 2:
                if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0))
                {
                    if (day_of_year <= 29)
                    {
                        found = true;
                    }
                    else
                    {
                        day_of_year -= 29;
                    }
                }
                else
                {
                    if (day_of_year <= 28)
                    {
                        found = true;
                    }
                    else
                    {
                        day_of_year -= 28;
                    }
                }
                break;
            default :
                break;
            }
        }
        *month = i - 1;
        *day = day_of_year;
    }

    int n_leapyears(int y)
    {
        int nl = 0;
        for (int i = 1970; i < y; ++i)
        {
            if (leapyear(i))
            {
                ++nl;
            }
        }
        return nl;
    }

    long int days_linear(const Date &d)
    {
        if (d.year() < first_date.year())
        {
            error("days_linear: year must be 1970 or later");
        }
        int y = d.year() - first_date.year();
        return y * 365 + n_leapyears(d.year()) + day_in_year(d) - 1;
    }

    Date next_workday(const Date &d)
    {
        Date nwd = d;
        Day day = day_of_week(d);
        switch (day)
        {
        case sunday:
        case monday:
        case tuesday:
        case wednesday:
        case thursday:
            nwd.add_day(1);
            break;
        case saturday:
            nwd.add_day(2);
            break;
        case friday:
            nwd.add_day(3);
            break;
        }
        return nwd;
    }
}

using Chrono::Date;

int main(int argc, const char *argv[])
{
    try
    {
        Date dd(2015, Date::Month(11), 30);

        for (int i = 0; i < 365; ++i)
        {
            dd.add_day(1);

            std::cout << dd << std::endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
(2015,12,1)
(2015,12,2)
(2015,12,3)
(2015,12,4)
(2015,12,5)
(2015,12,6)
(2015,12,7)
(2015,12,8)
(2015,12,9)
(2015,12,10)
(2015,12,11)
(2015,12,12)
(2015,12,13)
(2015,12,14)
(2015,12,15)
(2015,12,16)
(2015,12,17)
(2015,12,18)
(2015,12,19)
(2015,12,20)
(2015,12,21)
(2015,12,22)
(2015,12,23)
(2015,12,24)
(2015,12,25)
(2015,12,26)
(2015,12,27)
(2015,12,28)
(2015,12,29)
(2015,12,30)
(2015,12,31)
(2016,1,1)
(2016,1,2)
(2016,1,3)
(2016,1,4)
(2016,1,5)
(2016,1,6)
(2016,1,7)
(2016,1,8)
(2016,1,9)
(2016,1,10)
(2016,1,11)
(2016,1,12)
(2016,1,13)
(2016,1,14)
(2016,1,15)
(2016,1,16)
(2016,1,17)
(2016,1,18)
(2016,1,19)
(2016,1,20)
(2016,1,21)
(2016,1,22)
(2016,1,23)
(2016,1,24)
(2016,1,25)
(2016,1,26)
(2016,1,27)
(2016,1,28)
(2016,1,29)
(2016,1,30)
(2016,1,31)
(2016,2,1)
(2016,2,2)
(2016,2,3)
(2016,2,4)
(2016,2,5)
(2016,2,6)
(2016,2,7)
(2016,2,8)
(2016,2,9)
(2016,2,10)
(2016,2,11)
(2016,2,12)
(2016,2,13)
(2016,2,14)
(2016,2,15)
(2016,2,16)
(2016,2,17)
(2016,2,18)
(2016,2,19)
(2016,2,20)
(2016,2,21)
(2016,2,22)
(2016,2,23)
(2016,2,24)
(2016,2,25)
(2016,2,26)
(2016,2,27)
(2016,2,28)
(2016,2,29)
(2016,3,1)
(2016,3,2)
(2016,3,3)
(2016,3,4)
(2016,3,5)
(2016,3,6)
(2016,3,7)
(2016,3,8)
(2016,3,9)
(2016,3,10)
(2016,3,11)
(2016,3,12)
(2016,3,13)
(2016,3,14)
(2016,3,15)
(2016,3,16)
(2016,3,17)
(2016,3,18)
(2016,3,19)
(2016,3,20)
(2016,3,21)
(2016,3,22)
(2016,3,23)
(2016,3,24)
(2016,3,25)
(2016,3,26)
(2016,3,27)
(2016,3,28)
(2016,3,29)
(2016,3,30)
(2016,3,31)
(2016,4,1)
(2016,4,2)
(2016,4,3)
(2016,4,4)
(2016,4,5)
(2016,4,6)
(2016,4,7)
(2016,4,8)
(2016,4,9)
(2016,4,10)
(2016,4,11)
(2016,4,12)
(2016,4,13)
(2016,4,14)
(2016,4,15)
(2016,4,16)
(2016,4,17)
(2016,4,18)
(2016,4,19)
(2016,4,20)
(2016,4,21)
(2016,4,22)
(2016,4,23)
(2016,4,24)
(2016,4,25)
(2016,4,26)
(2016,4,27)
(2016,4,28)
(2016,4,29)
(2016,4,30)
(2016,5,1)
(2016,5,2)
(2016,5,3)
(2016,5,4)
(2016,5,5)
(2016,5,6)
(2016,5,7)
(2016,5,8)
(2016,5,9)
(2016,5,10)
(2016,5,11)
(2016,5,12)
(2016,5,13)
(2016,5,14)
(2016,5,15)
(2016,5,16)
(2016,5,17)
(2016,5,18)
(2016,5,19)
(2016,5,20)
(2016,5,21)
(2016,5,22)
(2016,5,23)
(2016,5,24)
(2016,5,25)
(2016,5,26)
(2016,5,27)
(2016,5,28)
(2016,5,29)
(2016,5,30)
(2016,5,31)
(2016,6,1)
(2016,6,2)
(2016,6,3)
(2016,6,4)
(2016,6,5)
(2016,6,6)
(2016,6,7)
(2016,6,8)
(2016,6,9)
(2016,6,10)
(2016,6,11)
(2016,6,12)
(2016,6,13)
(2016,6,14)
(2016,6,15)
(2016,6,16)
(2016,6,17)
(2016,6,18)
(2016,6,19)
(2016,6,20)
(2016,6,21)
(2016,6,22)
(2016,6,23)
(2016,6,24)
(2016,6,25)
(2016,6,26)
(2016,6,27)
(2016,6,28)
(2016,6,29)
(2016,6,30)
(2016,7,1)
(2016,7,2)
(2016,7,3)
(2016,7,4)
(2016,7,5)
(2016,7,6)
(2016,7,7)
(2016,7,8)
(2016,7,9)
(2016,7,10)
(2016,7,11)
(2016,7,12)
(2016,7,13)
(2016,7,14)
(2016,7,15)
(2016,7,16)
(2016,7,17)
(2016,7,18)
(2016,7,19)
(2016,7,20)
(2016,7,21)
(2016,7,22)
(2016,7,23)
(2016,7,24)
(2016,7,25)
(2016,7,26)
(2016,7,27)
(2016,7,28)
(2016,7,29)
(2016,7,30)
(2016,7,31)
(2016,8,1)
(2016,8,2)
(2016,8,3)
(2016,8,4)
(2016,8,5)
(2016,8,6)
(2016,8,7)
(2016,8,8)
(2016,8,9)
(2016,8,10)
(2016,8,11)
(2016,8,12)
(2016,8,13)
(2016,8,14)
(2016,8,15)
(2016,8,16)
(2016,8,17)
(2016,8,18)
(2016,8,19)
(2016,8,20)
(2016,8,21)
(2016,8,22)
(2016,8,23)
(2016,8,24)
(2016,8,25)
(2016,8,26)
(2016,8,27)
(2016,8,28)
(2016,8,29)
(2016,8,30)
(2016,8,31)
(2016,9,1)
(2016,9,2)
(2016,9,3)
(2016,9,4)
(2016,9,5)
(2016,9,6)
(2016,9,7)
(2016,9,8)
(2016,9,9)
(2016,9,10)
(2016,9,11)
(2016,9,12)
(2016,9,13)
(2016,9,14)
(2016,9,15)
(2016,9,16)
(2016,9,17)
(2016,9,18)
(2016,9,19)
(2016,9,20)
(2016,9,21)
(2016,9,22)
(2016,9,23)
(2016,9,24)
(2016,9,25)
(2016,9,26)
(2016,9,27)
(2016,9,28)
(2016,9,29)
(2016,9,30)
(2016,10,1)
(2016,10,2)
(2016,10,3)
(2016,10,4)
(2016,10,5)
(2016,10,6)
(2016,10,7)
(2016,10,8)
(2016,10,9)
(2016,10,10)
(2016,10,11)
(2016,10,12)
(2016,10,13)
(2016,10,14)
(2016,10,15)
(2016,10,16)
(2016,10,17)
(2016,10,18)
(2016,10,19)
(2016,10,20)
(2016,10,21)
(2016,10,22)
(2016,10,23)
(2016,10,24)
(2016,10,25)
(2016,10,26)
(2016,10,27)
(2016,10,28)
(2016,10,29)
(2016,10,30)
(2016,10,31)
(2016,11,1)
(2016,11,2)
(2016,11,3)
(2016,11,4)
(2016,11,5)
(2016,11,6)
(2016,11,7)
(2016,11,8)
(2016,11,9)
(2016,11,10)
(2016,11,11)
(2016,11,12)
(2016,11,13)
(2016,11,14)
(2016,11,15)
(2016,11,16)
(2016,11,17)
(2016,11,18)
(2016,11,19)
(2016,11,20)
(2016,11,21)
(2016,11,22)
(2016,11,23)
(2016,11,24)
(2016,11,25)
(2016,11,26)
(2016,11,27)
(2016,11,28)
(2016,11,29)

ch09_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

enum SquareState
{
    TTTS_Blank,
    TTTS_O,
    TTTS_X
};

struct Position
{
    int row = 0;
    int column = 0;
};

struct TicTacToeSquare
{
    SquareState state = TTTS_Blank;
    Position position;
};

class TicTacToeBoard
{
public:
    static int const minToWin = 4;
    static int const maxSize = 50;
    int size = maxSize;

    void populateGameBoard();
    string setPlayer(bool playerXInSession);

    bool validIndex(Position boardPosition);
    bool choiceTaken(Position boardPosition);
    void setChoice(Position boardPosition);

    bool choiceWins();
    bool boardIsFull();

    void drawBoard();

private:
    bool _playerXInSession = true;
    TicTacToeSquare _gameBoard[maxSize][maxSize];

    static TicTacToeSquare createSquare(int row, int column, SquareState state);
    TicTacToeSquare getSquare(Position boardPosition);
    SquareState choiceSquare();
    static string translateEnumToString(SquareState squareState);
};

void TicTacToeBoard::populateGameBoard()
{
    for (int i = 0; i < maxSize; i++)
    {
        for (int j = 0; j < maxSize; j++)
        {
            _gameBoard[i][j] = createSquare(i, j, TTTS_Blank);
        }
    }
}

TicTacToeSquare TicTacToeBoard::createSquare(int row, int column, SquareState state)
{
    TicTacToeSquare newSquare;
    newSquare.position.row = row;
    newSquare.position.row = column;
    newSquare.state = state;

    return newSquare;
}

TicTacToeSquare TicTacToeBoard::getSquare(Position boardPosition)
{
    if (validIndex(boardPosition))
    {
        return _gameBoard[boardPosition.row][boardPosition.column];
    }
    TicTacToeSquare empty;
    return empty;
}

string TicTacToeBoard::setPlayer(bool playerXInSession)
{
    _playerXInSession = playerXInSession;
    if (_playerXInSession)
    {
        return "X";
    }
    return "O";
}

bool TicTacToeBoard::validIndex(Position boardPosition)
{
    return ( ( (boardPosition.row >= 0) && (boardPosition.column >= 0) ) &&
             ( (boardPosition.row < size) && (boardPosition.column < size) ) );
}

bool TicTacToeBoard::choiceTaken(Position boardPosition)
{
    return (_gameBoard[boardPosition.row][boardPosition.column].state != TTTS_Blank);
}

void TicTacToeBoard::setChoice(Position boardPosition)
{
    _gameBoard[boardPosition.row][boardPosition.column].state = choiceSquare();
}

SquareState TicTacToeBoard::choiceSquare()
{
    if (_playerXInSession)
    {
        return TTTS_X;
    }
    return TTTS_O;
}

bool TicTacToeBoard::choiceWins()
{
    SquareState choiceCheck = choiceSquare();;
    double score;

    for (int i = 0; i < size; i++)
    {
        score = 0;
        for (int j = 0; j < size; j++)
        {
            if (_gameBoard[i][j].state == choiceCheck)
            {
                score++;
                if (score >= minToWin)
                {
                    return true;
                }
            }
            else
            {
                score = 0;
            }
        }
    }

    for (int j = 0; j < size; j++)
    {
        score = 0;
        for (int i = 0; i < size; i++)
        {
            if (_gameBoard[i][j].state == choiceCheck)
            {
                score++;
                if (score >= minToWin)
                {
                    return true;
                }
            }
            else
            {
                score = 0;
            }
        }
    }

    score = 0;
    for (int i = 0; i < size; i++)
    {
        if (_gameBoard[i][i].state == choiceCheck)
        {
            score++;
            if (score >= minToWin)
            {
                return true;
            }
        }
        else
        {
            score = 0;
        }
    }

    score = 0;
    int maxIndex = size - 1;
    for (int i = 0; i < size; i++)
    {
        if (_gameBoard[i][maxIndex - i].state == choiceCheck)
        {
            score++;
            if (score >= minToWin)
            {
                return true;
            }
        }
        else
        {
            score = 0;
        }
    }

    return false;
}

bool TicTacToeBoard::boardIsFull()
{
    for (int i = 0; i < size; i++)
    {
        for (int j = 0; j < size; j++)
        {
            if (_gameBoard[i][j].state == TTTS_Blank)
            {
                return false;
            }
        }
    }
    return true;
}

string TicTacToeBoard::translateEnumToString(SquareState squareState)
{
    switch (squareState)
    {
    case TTTS_Blank:
        return " ";
    case TTTS_O:
        return "O";
    case TTTS_X:
        return "X";
    default:
        return "~";
    }
}

void TicTacToeBoard::drawBoard()
{
    cout << "Tic-Tac-Toe\n";
    cout << minToWin << "-in-a-row are needed to win!\n";
    string horizontalBar = " _";
    for (int row = 0; row < size; row++)
    {
        horizontalBar += "__";
    }

    for (int row = 0; row <= size; row++)
    {
        if (row == 0)
        {
            for (int column = 0; column <= size; column++)
            {
                if (column == 0)
                {
                    cout << " ";
                }
                else
                {
                    cout << " " << column;
                }
            }
            cout << "\n";
        }
        else
        {
            cout << horizontalBar << "\n";
            for (int column = 0; column <= size; column++)
            {
                if (column == 0)
                {
                    cout << row;
                }
                else
                {
                    Position boardPosition;
                    boardPosition.row = row - 1;
                    boardPosition.column = column - 1;
                    TicTacToeSquare currentSquare = getSquare(boardPosition);
                    cout << "|" << translateEnumToString(currentSquare.state);
                }
            }
            cout << "|\n";
        }
    }
    cout << horizontalBar << "\n\n";
}

int main(int argc, const char *argv[])
{
    try
    {
        bool gameFinished = false;
        bool playerXInSession = true;
        string player = "";
        int row = 0;
        int column = 0;

        int sizeUsed = 4;
        TicTacToeBoard gameBoard;

        cout << "Please specify the number of spaces to be used for the rows/columns of the square board:\n";
        cout << "(Default is " << gameBoard.minToWin << " and max is " << gameBoard.maxSize << ")\n";
        cin >> sizeUsed;
        cin.clear();
        cin.ignore(80, '\n');

        if (sizeUsed < gameBoard.minToWin)
        {
            sizeUsed = gameBoard.minToWin;
        }
        if (sizeUsed > gameBoard.maxSize)
        {
            sizeUsed = gameBoard.maxSize;
        }

        gameBoard.size = sizeUsed;
        gameBoard.populateGameBoard();

        do
        {
            row = 0;
            column = 0;
            player = gameBoard.setPlayer(playerXInSession);

            gameBoard.drawBoard();

            cout << "Player " << player << ", choose your next board position to claim:\n";

            cout << "Row: \n";
            cin >> row;
            cin.clear();
            cin.ignore(80, '\n');
            row--;

            cout << "Column: \n";
            cin >> column;
            cin.clear();
            cin.ignore(80, '\n');
            column--;

            Position boardPosition;
            boardPosition.row = row;
            boardPosition.column = column;

            if (!gameBoard.validIndex(boardPosition))
            {
                cout << "That is an invalid choice. Please try again.\n";
                continue;
            }

            if (gameBoard.choiceTaken(boardPosition))
            {
                cout << "That square is already taken. Please try again.\n";
                continue;
            }

            gameBoard.setChoice(boardPosition);

            if (gameBoard.choiceWins())
            {
                cout << "Player " << player << " wins!\n";
                gameFinished = true;
            }
            else if (gameBoard.boardIsFull())
            {
                cout << "Board is full. The game is a tie!\n";
                gameFinished = true;
            }

            playerXInSession = !playerXInSession;
        }
        while (!gameFinished);

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Please specify the number of spaces to be used for the rows/columns of the square board:
(Default is 4 and max is 50)
6
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | | | |
 _____________
2| | | | | | |
 _____________
3| | | | | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
1
Column:
5
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | |X| |
 _____________
2| | | | | | |
 _____________
3| | | | | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
2
Column:
2
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | |X| |
 _____________
2| |O| | | | |
 _____________
3| | | | | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
2
Column:
5
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | |X| |
 _____________
2| |O| | |X| |
 _____________
3| | | | | | |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
3
Column:
5
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1| | | | |X| |
 _____________
2| |O| | |X| |
 _____________
3| | | | |O| |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
1
Column:
1
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| | | |X| |
 _____________
2| |O| | |X| |
 _____________
3| | | | |O| |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
3
Column:
2
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X| | | |X| |
 _____________
2| |O| | |X| |
 _____________
3| |O| | |O| |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
1
Column:
2
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X| | |X| |
 _____________
2| |O| | |X| |
 _____________
3| |O| | |O| |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
1
Column:
3
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X|O| |X| |
 _____________
2| |O| | |X| |
 _____________
3| |O| | |O| |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
2
Column:
3
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X|O| |X| |
 _____________
2| |O|X| |X| |
 _____________
3| |O| | |O| |
 _____________
4| | | | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
4
Column:
2
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X|O| |X| |
 _____________
2| |O|X| |X| |
 _____________
3| |O| | |O| |
 _____________
4| |O| | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player X, choose your next board position to claim:
Row:
3
Column:
3
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6
 _____________
1|X|X|O| |X| |
 _____________
2| |O|X| |X| |
 _____________
3| |O|X| |O| |
 _____________
4| |O| | | | |
 _____________
5| | | | | | |
 _____________
6| | | | | | |
 _____________

Player O, choose your next board position to claim:
Row:
5
Column:
2
Player O wins!

ch09_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

enum suit_t {HEART, DIAMOND, SPADE, CLUB};

vector <int> dealhand();
vector <int> assign_value(vector <int>   &hand);
vector <int> assign_suit(vector <int>   &hand);
void analyze_hand (vector <int> &hand_value, vector <int> &hand_suit);
void print_result (void);

bool hand_straight, hand_royal_flush, hand_flush, hand_four, hand_three;
int hand_pairs;

#define NUM_RANKS 13
#define NUM_SUITS    4
#define NUM_CARDS 5

void analyze_hand (vector <int> &hand_value, vector <int> &hand_suit)
{
    int num_in_rank[NUM_RANKS] = {0};
    int num_in_suit[NUM_SUITS] = {0};

    int rank, suit;
    int size = hand_suit.size();
    for(int i = 0; i < size; i++)
    {
        suit = hand_suit.at(i);
        rank = hand_value.at(i);
        num_in_rank[rank]++;
        num_in_suit[suit]++;
    }

    hand_straight = false;
    hand_royal_flush = false;
    hand_flush = false;
    hand_four = false;
    hand_three = false;
    hand_pairs = 0;

    /* check for flush */
    for (suit = 0; suit < NUM_SUITS; suit++)
    {
        if (num_in_suit[suit] == NUM_CARDS)
        {
            hand_flush = true;
        }
    }

    int num_consec = 0;
    /* checks for royal flush */
    if (hand_flush)
    {
        for (rank = 8; rank < NUM_RANKS && num_in_rank[rank] > 0; rank++)
        {
            num_consec++;
        }
        if (num_consec == NUM_CARDS)
        {
            hand_royal_flush = true;
            return;
        }
    }

    num_consec = 0;
    /* check for straight */
    rank = 0;
    while (num_in_rank[rank] == 0)
    {
        rank++;
    }

    for (; rank < NUM_RANKS && num_in_rank[rank] > 0; rank++)
    {
        num_consec++;

        /* special case: low-straight */
        if (num_consec == 4 && rank == 3 && num_in_rank[12] > 0)
        {
            hand_straight = true;
            return;
        }
    }

    if (num_consec == NUM_CARDS)
    {
        hand_straight = true;
        return;
    }

    /* check for 4-of-a-kind, 3-of-a-kind, and pairs */
    for (rank = 0; rank < NUM_RANKS; rank++)
    {
        if (num_in_rank[rank] == 4)
        {
            hand_four = true;
        }
        if (num_in_rank[rank] == 3)
        {
            hand_three = true;
        }
        if (num_in_rank[rank] == 2)
        {
            hand_pairs++;
        }
    }
}
void print_result (void)
{
    if (hand_royal_flush)
    {
        cout << "Royal flush";
    }
    else if (hand_straight && hand_flush)
    {
        cout <<  "Straight flush";
    }
    else if (hand_four)
    {
        cout << "Four of a kind";
    }
    else if (hand_three && hand_pairs == 1)
    {
        cout << "Full house";
    }
    else if (hand_flush)
    {
        cout << "Flush";
    }
    else if (hand_straight)
    {
        cout << "Straight";
    }
    else if (hand_three)
    {
        cout << "Three of a kind";
    }
    else if (hand_pairs == 2)
    {
        cout << "Two pairs";
    }
    else if (hand_pairs == 1)
    {
        cout << "Pair";
    }
    else
    {
        cout << "High card";
    }

    cout <<  "\n";
}
std::random_device rd;
std::mt19937 gen(rd());

int getRandomNumber(const int &min, const int &max)
{
    return std::uniform_int_distribution<int> {min, max}(gen);
}

vector <int> dealhand()
{
    int r;
    vector <int> deck;
    vector <int> hand;

    for (int i = 0; i < 52; i++)
    {
        deck.push_back(i + 1);
    }

    for (int i = 0; i < NUM_CARDS; i++)
    {
        do
        {
            r = getRandomNumber(0, 51);
        }
        while (deck.at(r) == 0);
        deck.at(r) = 0;
        hand.push_back(r);
    }
    return hand;
}
vector <int> assign_suit(vector <int> &hand)
{
    vector <int> hand_suit;
    int size = hand.size();
    for(int i = 0; i < size; i++)
    {
        int r = hand.at(i);
        if (r < 13)
        {
            hand_suit.push_back(HEART);
        }
        else if (r < 26)
        {
            hand_suit.push_back(DIAMOND);
        }
        else if (r < 39)
        {
            hand_suit.push_back(SPADE);
        }
        else if (r < 52)
        {
            hand_suit.push_back(CLUB);
        }
        else
        {
            cout << "Error in assigning values in hand";
        }
    }
    return hand_suit;
}
vector <int> assign_value(vector <int> &hand)
{
    vector <int> hand_value;
    int size = hand.size();
    for(int i = 0; i < size; i++)
    {
        int r = hand.at(i);
        if (r < 13)
        {
            hand_value.push_back(r);
        }
        else if (r < 26)
        {
            hand_value.push_back(r - 13);
        }
        else if (r < 39)
        {
            hand_value.push_back(r - 26);
        }
        else if (r < 52)
        {
            hand_value.push_back(r - 39);
        }
        else
        {
            cout << "Error in assigning values in hand";
        }
    }
    return hand_value;
}

int main(int argc, const char *argv[])
{
    try
    {
        const char *rank_code[] = {"Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Jack", "Queen", "King", "Ace"};
        const char *suit_code[] = {"Hearts", "Diamonds", "Spades", "Clubs"};

        vector <int> hand_prelim;
        vector <int> hand_suit;
        vector <int> hand_value;

        hand_prelim = dealhand();
        hand_suit = assign_suit(hand_prelim);
        hand_value = assign_value(hand_prelim);


        int rank, suit;
        int size = hand_suit.size();
        for(int i = 0; i < size; i++)
        {
            suit = hand_suit.at(i);
            rank = hand_value.at(i);
            cout << rank_code[rank] << " of " << suit_code[suit] << "\n";
        }
        analyze_hand (hand_value, hand_suit);
        cout <<  "\n";
        print_result ();

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Three of Spades
Eight of Clubs
Eight of Diamonds
Five of Diamonds
Queen of Clubs

Pair

Ace of Spades
Seven of Diamonds
Two of Spades
Three of Spades
Ten of Hearts

High card

King of Clubs
Eight of Diamonds
Queen of Diamonds
Queen of Spades
Two of Diamonds

Pair

第10章 运算符重载：string类
10.1 简介
10.2 使用标准库中string类的重载运算符
10.3 运算符重载的基础知识
10.4 重载二元运算符
10.5 重载二元流插入运算符和流提取运算符
10.6 重载一元运算符
10.7 重载一元前置与后置运算符：++和--
10.8 实例研究：Date类
10.9 动态内存管理
10.10 实例研究：Array类
10.11 运算符作为成员函数和非成员函数的比较
10.12 类型转换
10.13 explicit构造函数与转换运算符
10.14 重载函数调用运算符()
10.15 本章小结
ch10_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it);
            alloc.destroy(it++);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() { }
    Str(size_type n, char c) : data(n, c) { }
    Str(const char *cp)
    {
        copy(cp, cp + strlen(cp), back_inserter(data));
    }

    template<typename In>
    Str(In b, In e) : data(b, e) { }

    size_type size() const
    {
        return data.size();
    }

    char &operator[](size_type i)
    {
        return data[i];
    }
    const char &operator[](size_type i) const
    {
        return data[i];
    }

    Str &operator+=(const Str &s)
    {
        copy(s.data.begin(), s.data.end(), back_inserter(data));
        return *this;
    }

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        data.insert(position, first, last);
    };

    iterator begin()
    {
        return data.begin();
    };
    const_iterator begin() const
    {
        return data.begin();
    };
    iterator end()
    {
        return data.end();
    };
    const_iterator end() const
    {
        return data.end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data.clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data.push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }
    friend ostream &operator<<(ostream &os, const Str &s)
    {
        for (size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }
    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Vec<char> data;
};

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char ch)
    {
        append(ch);
        return *this;
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = str;
    r += s;
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

int main(int argc, const char *argv[])
{
    try
    {
        Str s = "A lonesome string.";

        Vec<char> v(s.begin(), s.end());

        for (size_t i = 0; i < v.size(); i++)
        {
            cout << v[i];
        }
        cout << endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
A lonesome string.

ch10_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template<typename T>
T *clone(const T *tp)
{
    return tp->clone();
}

template<typename T>
class Ptr
{
public:
    Ptr() : refptr(new size_t(1)), p(nullptr) { }
    Ptr(T *t) : refptr(new size_t(1)), p(t) { }
    Ptr(const Ptr<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ptr<T> &operator=(const Ptr<T> &);
    ~Ptr();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr");
    }

    void make_unique()
    {
        if (*refptr > 1)
        {
            --*refptr;
            refptr = new size_t(1);
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

    void print()
    {
        cout << (void *)p << ": " << (void *)refptr << ", " << *refptr << endl;
    }
private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ptr<T> &Ptr<T>::operator=(const Ptr<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ptr<T>::~Ptr()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

class Tracer
{
private:
    int val;
public:
    Tracer() : val(0)
    {
        cout << "Tracer()\n";
    }
    Tracer(int n) : val(n)
    {
        cout << "Tracer(int n)\n";
    }
    Tracer(const Tracer &arg) : val(arg.val)
    {
        cout << "Tracer(const Tracer &arg)\n";
    }
    Tracer &operator=(const Tracer &arg)
    {
        cout << "operator=(const Tracer &arg)\n";
        if (this == &arg) { return *this; }
        val = arg.val;
        return *this;
    }
    ~Tracer()
    {
        cout << "~Tracer()\n";
    }
    int & get()
    {
        return val;
    }
    const int & get() const
    {
        return val;
    }
};

template<>
inline Tracer *clone<Tracer>(const Tracer *pt)
{
    return new Tracer(*pt);
}

void f1()
{
    Ptr<Tracer> p1(new Tracer());
    Ptr<Tracer> p2(new Tracer(5));
    Ptr<Tracer> p3(p2);
    p1.print();
    p2.print();
    p3.print();
    p1 = p3;
    p1.print();
    p2.print();
    p3.print();
    cout << (*p1).get() << ", " << p2->get() << ", " << (*p3).get() << endl;
}

void f2()
{
    Ptr<Tracer> p1(new Tracer());
    Ptr<Tracer> p2(new Tracer(5));
    Ptr<Tracer> p3(p2);
    error("Exception!");
}

int main(int argc, const char *argv[])
{
    try
    {
        f1();
        f2();

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Tracer()
Tracer(int n)
0x55e781dc7eb0: 0x55e781dc82e0, 1
0x55e781dc8300: 0x55e781dc8320, 2
0x55e781dc8300: 0x55e781dc8320, 2
~Tracer()
0x55e781dc8300: 0x55e781dc8320, 3
0x55e781dc8300: 0x55e781dc8320, 3
0x55e781dc8300: 0x55e781dc8320, 3
5, 5, 5
~Tracer()
Tracer()
Tracer(int n)
Exception!
~Tracer()
~Tracer()
error: Exception!

第11章 面向对象编程：继承
11.1 简介
11.2 基类和派生类
11.3 基类和派生类之间的关系
11.4 派生类中的构造函数和析构函数
11.5 public，protected和private继承
11.6 继承与软件工程
11.7 本章小结
ch11_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template <typename T>
class Handle
{
public:
    Handle() : p(nullptr) { }
    Handle(T *t) : p(t) { }
    Handle(const Handle<T> &s) : p(nullptr)
    {
        if (s.p != nullptr)
        {
            p = s.p->clone();
        }
    }

    Handle<T> &operator=(const Handle<T> &);
    ~Handle()
    {
        delete p;
    }

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const;
    T *operator->() const;

private:
    T *p;
};

template<typename T>
Handle<T> &Handle<T>::operator=(const Handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    delete p;
    p = rhs.p != nullptr ? rhs.p->clone() : nullptr;
    return *this;
}

template <typename T>
T &Handle<T>::operator*() const
{
    if (p != nullptr)
    {
        return *p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
T *Handle<T>::operator->() const
{
    if (p != nullptr)
    {
        return p;
    }
    throw runtime_error("unbound Handle");
}

template <typename T>
class Ref_handle
{
public:
    Ref_handle() : refptr(new size_t(1)), p(nullptr) { }
    Ref_handle(T *t) : refptr(new size_t(1)), p(t) { }

    Ref_handle(const Ref_handle<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ref_handle<T> &operator=(const Ref_handle<T> &);

    ~Ref_handle();

    operator bool() const
    {
        return p != nullptr;
    }
    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ref_handle");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ref_handle");
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ref_handle<T> &Ref_handle<T>::operator=(const Ref_handle<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;

    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }

    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ref_handle<T>::~Ref_handle()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

class Ref_counter
{
public:
    Ref_counter() : counter(new size_t(1)) { };
    Ref_counter(size_t s) : counter(new size_t(s)) { };
    Ref_counter(const Ref_counter &r) : counter(r.counter) { };

    Ref_counter &operator=(const Ref_counter &rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        if (*counter <= 0)
        {
            delete counter;
        }
        counter = rhs.counter;
        return *this;
    };

    Ref_counter &operator++()
    {
        (*counter)++;
        return *this;
    };

    Ref_counter &operator--()
    {
        (*counter)--;
        return *this;
    };

    Ref_counter operator++(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)++;
        return ret;
    };

    Ref_counter operator--(int)
    {
        Ref_counter ret(*(this->counter));
        (*counter)--;
        return ret;
    };

    ~Ref_counter()
    {
        if (*counter <= 0)
        {
            delete counter;
        }
    };

    size_t count()
    {
        return *counter;
    };

private:
    size_t *counter;
};


template<typename T>
T *clone(const T *tp)
{
    return tp->clone();
}

template<typename T>
class Ptr
{
public:
    Ptr() : refptr(new size_t(1)), p(nullptr) { }
    Ptr(T *t) : refptr(new size_t(1)), p(t) { }
    Ptr(const Ptr<T> &h) : refptr(h.refptr), p(h.p)
    {
        ++*refptr;
    }

    Ptr<T> &operator=(const Ptr<T> &);
    ~Ptr();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr");
    }

    void make_unique()
    {
        if (*refptr > 1)
        {
            --*refptr;
            refptr = new size_t(1);
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    size_t *refptr;
};

template<typename T>
Ptr<T> &Ptr<T>::operator=(const Ptr<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    ++*rhs.refptr;
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
    refptr = rhs.refptr;
    p = rhs.p;
    return *this;
}

template<typename T>
Ptr<T>::~Ptr()
{
    if (--*refptr == 0)
    {
        delete refptr;
        delete p;
    }
}

template<typename T>
class Ptr_r
{
public:
    Ptr_r() : p(nullptr) { }
    Ptr_r(T *t) : p(t) { }
    Ptr_r(const Ptr_r<T> &h) : ref_c(h.ref_c), p(h.p)
    {
        ++ref_c;
    }

    Ptr_r<T> &operator=(const Ptr_r<T> &);
    ~Ptr_r();

    operator bool() const
    {
        return p != nullptr;
    }

    T &operator*() const
    {
        if (p != nullptr)
        {
            return *p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    T *operator->() const
    {
        if (p != nullptr)
        {
            return p;
        }
        throw runtime_error("unbound Ptr_r");
    }

    void make_unique()
    {
        if (ref_c.count() > 1)
        {
            --ref_c;
            ref_c = Ref_counter();
            p = p != nullptr ? clone(p) : nullptr;
        }
    }

private:
    T *p;
    Ref_counter ref_c;
};

template<typename T>
Ptr_r<T> &Ptr_r<T>::operator=(const Ptr_r<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
    ref_c = rhs.ref_c;
    p = rhs.p;
    ++ref_c;
    return *this;
}

template<typename T>
Ptr_r<T>::~Ptr_r()
{
    if ((--ref_c).count() == 0)
    {
        delete p;
    }
}

template <typename T>
class Vec
{
public:
    typedef T *iterator;
    typedef const T *const_iterator;
    typedef size_t size_type;
    typedef T value_type;

    Vec()
    {
        create();
    }
    explicit Vec(size_type n, const T &val = T())
    {
        create(n, val);
    }
    Vec(const Vec<T> &v)
    {
        create(v.begin(), v.end());
    }
    template<typename In>
    Vec(In b, In e)
    {
        create(b, e);
    }

    Vec &operator=(const Vec<T> &);
    ~Vec()
    {
        uncreate();
    }
    T &operator[](size_type i)
    {
        return data[i];
    }
    const T &operator[](size_type i) const
    {
        return data[i];
    }

    void push_back(const T &val, bool double_grow = true)
    {
        if (avail == limit)
        {
            grow(double_grow);
        }
        unchecked_append(val);
    }

    size_type size() const
    {
        return avail - data;
    }
    iterator begin()
    {
        return data;
    }
    const_iterator begin() const
    {
        return data;
    }
    iterator end()
    {
        return avail;
    }
    const_iterator end() const
    {
        return avail;
    }

    ostream &print_vec(ostream &);
    void clear()
    {
        destroy();
    };
    iterator erase(iterator it)
    {
        return destroy(it);
    };
    iterator erase(iterator b, iterator e)
    {
        return destroy(b, e);
    };

    template <typename In>
    void insert(iterator position, In first, In last)
    {
        insert_elements(position, first, last);
    };

    template <typename In>
    void assign(In first, In last)
    {
        assign_elements(first, last);
    };

private:
    iterator data;
    iterator avail;
    iterator limit;

    allocator<T> alloc;

    void create();
    void create(size_type, const T &);
    void create(const_iterator, const_iterator);
    template<typename In>
    void create(In, In);

    void uncreate();

    void grow(bool);

    void unchecked_append(const T &);

    void destroy();
    iterator destroy(iterator);
    iterator destroy(iterator, iterator);

    template <typename In>
    void insert_elements(iterator, In, In);

    template <typename In>
    void assign_elements(In, In);
};

template <typename T>
void Vec<T>::create()
{
    data = avail = limit = nullptr;
}

template <typename T>
void Vec<T>::create(size_type n, const T &val)
{
    data = alloc.allocate(n);
    limit = avail = data + n;
    uninitialized_fill(data, limit, val);
}

template <typename T>
void Vec<T>::create(const_iterator i, const_iterator j)
{
    data = alloc.allocate(j - i);
    limit = avail = uninitialized_copy(i, j, data);
}

template<typename T>
template<typename In>
void Vec<T>::create(In b, In e)
{
    data = alloc.allocate(e - b);
    limit = avail = std::uninitialized_copy(b, e, data);
}

template <typename T>
void Vec<T>::uncreate()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
        alloc.deallocate(data, limit - data);
    }
    data = limit = avail = nullptr;
}

template <typename T>
Vec<T> &Vec<T>::operator=(const Vec<T> &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

template <typename T>
void Vec<T>::grow(bool double_grow)
{
    size_type new_size;

    if (double_grow)
    {
        new_size = max(2 * (limit - data), ptrdiff_t(1));
    }
    else
    {
        new_size = (limit - data) + 1;
    }

    iterator new_data = alloc.allocate(new_size);
    iterator new_avail = uninitialized_copy(data, avail, new_data);
    uncreate();
    data = new_data;
    avail = new_avail;
    limit = data + new_size;
}

template <typename T>
void Vec<T>::unchecked_append(const T &val)
{
    alloc.construct(avail++, val);
}

template<typename T>
std::ostream &Vec<T>::print_vec(std::ostream &os)
{
    if (avail - data > 0)
    {
        iterator iter = data;

        os << *iter++;

        while (iter != avail)
        {
            os << ", " << *iter++;
        }

        os << std::endl;
    }
    return os;
}

template <typename T>
void Vec<T>::destroy()
{
    if (data != nullptr)
    {
        iterator it = avail;
        while (it != data)
        {
            alloc.destroy(--it);
        }
    }
    avail = data;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator pos)
{
    if (data != nullptr && pos != avail)
    {
        alloc.destroy(pos);
        iterator it = pos + 1;

        while (it != avail)
        {
            alloc.construct(pos++, *it);
            alloc.destroy(it++);
        }
        avail = pos;
    }
    return avail;
}

template<typename T>
typename Vec<T>::iterator Vec<T>::destroy(iterator b, iterator e)
{
    if (data != nullptr && b != avail && b != e)
    {
        iterator it = b;
        while (it != e)
        {
            alloc.destroy(it++);
        }

        while (e != avail)
        {
            alloc.construct(b++, *e);
            alloc.destroy(e++);
        }

        avail = b;
    }
    return avail;
}

template <typename T>
template <typename In>
void Vec<T>::insert_elements(iterator pos, In first, In last)
{
    Vec<T> tail(pos, avail);

    destroy(pos, avail);

    In iter1 = first;

    while (iter1 != last)
    {
        push_back(*iter1++);
    }

    iterator iter2 = tail.begin();

    while (iter2 != tail.end())
    {
        push_back(*iter2++);
    }
}

template <typename T>
template <typename In>
void Vec<T>::assign_elements(In first, In last)
{
    uncreate();
    create(first, last);
}

template<>
inline Vec<char> *clone< Vec<char> >(const Vec<char> *vp)
{
    return new Vec<char>(*vp);
}

class Str
{
public:
    typedef Vec<char>::size_type size_type;
    typedef Vec<char>::iterator iterator;
    typedef Vec<char>::const_iterator const_iterator;

    Str() : data(new Vec<char>) { }
    Str(size_type n, char c) : data(new Vec<char>(n, c)) { }
    Str(const char *cp) : data(new Vec<char>)
    {
        copy(cp, cp + strlen(cp), back_inserter(*data));
    }
    template<class In>
    Str(In b, In e) : data(new Vec<char>(b, e)) { }

    size_type size() const
    {
        return data->size();
    }

    char &operator[](size_type i)
    {
        data.make_unique();
        return (*data)[i];
    }

    const char &operator[](size_type i) const
    {
        return (*data)[i];
    }

    Str &operator+=(const Str &s)
    {
        data.make_unique();
        copy(s.data->begin(), s.data->end(), back_inserter(*data));
        return *this;
    }

    iterator begin()
    {
        return data->begin();
    };
    const_iterator begin() const
    {
        return data->begin();
    };
    iterator end()
    {
        return data->end();
    };
    const_iterator end() const
    {
        return data->end();
    };

    friend istream &operator >> (istream &is, Str &s)
    {
        s.data->clear();
        char c;
        while (is.get(c) && isspace(c))
            ;
        if (is)
        {
            do
            {
                s.data->push_back(c);
            }
            while (is.get(c) && !isspace(c));
            if (is)
            {
                is.unget();
            }
        }
        return is;
    }

    friend ostream &operator<< (ostream &os, const Str &s)
    {
        for (Str::size_type i = 0; i != s.size(); ++i)
        {
            os << s[i];
        }
        return os;
    }

    friend Str operator+(const Str &l, const Str &r)
    {
        Str ret = l;
        ret += r;
        return ret;
    }

private:
    Ptr< Vec<char> > data;
};

class Str_c
{
public:
    typedef size_t size_type;
    typedef char *iterator;
    typedef const char *const_iterator;

    Str_c()
    {
        create();
    }
    Str_c(size_t n, char c)
    {
        create(n, c);
    }
    Str_c(const Str_c &s)
    {
        create(s.begin(), s.end());
    }
    Str_c(const char *cp)
    {
        create(cp, cp + strlen(cp));
    }
    template<typename In>
    Str_c(In b, In e)
    {
        create(b, e);
    }

    ~Str_c()
    {
        uncreate();
    }

    Str_c &operator=(const Str_c &);

    size_t size() const
    {
        return length - 1;
    }

    char &operator[](size_t i)
    {
        return d[i];
    }
    const char &operator[](size_t i) const
    {
        return d[i];
    }

    Str_c &operator+=(const char ch)
    {
        append(ch);
        return *this;
    }

    Str_c &operator+=(const char *cp)
    {
        append(cp, strlen(cp));
        return *this;
    }

    Str_c &operator+=(const Str_c &s)
    {
        append(s);
        return *this;
    }

    operator void *() const
    {
        return is_not_empty();
    };
    const char *c_str() const
    {
        return d;
    }
    const char *data() const
    {
        return d;
    }

    size_t copy(char *p, size_t n) const
    {
        return copy_characters(p, n);
    }

    iterator begin()
    {
        return d;
    };
    const_iterator begin() const
    {
        return d;
    };
    iterator end()
    {
        return d + size();
    };
    const_iterator end() const
    {
        return d + size();
    };

    friend istream &operator >> (istream &, Str_c &);
    friend ostream &operator<<(ostream &, const Str_c &);
    friend istream &getline(istream &, Str_c &);
    friend Str_c operator+(const Str_c &, const Str_c &);
    friend Str_c operator+(const Str_c &, const char *);
    friend Str_c operator+(const char *, const Str_c &);

    friend bool operator== (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) == 0;
    }

    friend  bool operator!= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) != 0;
    }

    friend  bool operator< (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) < 0;
    }

    friend  bool operator<= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) <= 0;
    }

    friend  bool operator> (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) > 0;
    }

    friend  bool operator>= (const Str_c &lhs, const Str_c &rhs)
    {
        return strcmp(lhs.c_str(), rhs.c_str()) >= 0;
    }

private:
    char *d;
    size_t length;
    size_t max_length;

    void create();
    void create(size_t, char);
    void create(const_iterator i, const_iterator j)
    {
        length = j - i + 1;
        max_length =  j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void uncreate()
    {
        if (length != 0)
        {
            delete[] d;
        }
        length = 0;
        max_length = 0;
    }

    template<class In>
    void create(In i, In j)
    {
        length = j - i + 1;
        max_length = j - i + 1;
        d = new char[length];
        std::copy(i, j, d);
        d[length - 1] = '\0';
    }

    void append(const Str_c &);
    void append(const char *, const size_t);
    void prepend(const char *, const size_t);
    void append(const char);

    size_t copy_characters (char *, size_t) const;

    void *is_not_empty() const
    {
        if (size() > 0)
        {
            return d;
        }
        else
        {
            return nullptr;
        }
    }
};

void Str_c::create()
{
    d = new char[1];
    length = 1;
    max_length = 1;
    d[0] = '\0';
}

void Str_c::create(size_t s, char c)
{
    if (s <= 0)
    {
        create();
    }
    else
    {
        d = new char[s + 1];
        length = s + 1;
        max_length = s + 1;
        memset(d, c, s);
        d[s] = '\0';
    }
}

Str_c &Str_c::operator=(const Str_c &rhs)
{
    if (this == &rhs)
    {
        return *this;
    }

    uncreate();
    create(rhs.begin(), rhs.end());
    return *this;
}

void Str_c::append(const Str_c &s)
{
    append(s.data(), s.size());
}

void Str_c::append(const char *str, const size_t count)
{
    size_t old_length = size();
    if (max_length >= old_length + count + 1)
    {
        length = old_length + count + 1;
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';
    }
    else
    {
        size_type new_size = max_length;
        while (new_size < old_length + count + 1)
        {
            new_size *= 2;
        }
        char *copy = new char[old_length];
        memcpy(copy, d, old_length);
        uncreate();
        length = old_length + count + 1;
        max_length = new_size;
        d = new char[max_length];
        memcpy(d, copy, old_length);
        memcpy(&d[old_length], str, count);
        d[length - 1] = '\0';

        delete[] copy;
    }
}

void Str_c::prepend(const char *str, const size_t count)
{
    size_t old_length = size();
    size_type new_size = max_length;
    while (new_size < old_length + count + 1)
    {
        new_size *= 2;
    }

    char *copy = new char[old_length];
    memcpy(copy, d, old_length);
    uncreate();

    length = old_length + count + 1;
    max_length = new_size;
    d = new char[max_length];
    memcpy(d, str, count);
    memcpy(&d[count], copy, old_length);
    d[length - 1] = '\0';

    delete[] copy;
}

void Str_c::append(const char c)
{
    append(&c, 1);
}

Str_c operator+(const Str_c &s, const Str_c &t)
{
    Str_c r = s;
    r += t;
    return r;
}

Str_c operator+(const Str_c &s, const char *str)
{
    Str_c r = s;
    r += str;
    return r;
}

Str_c operator+(const char *str, const Str_c &s)
{
    Str_c r = str;
    r += s;
    return r;
}

ostream &operator<<(ostream &os, const Str_c &s)
{
    copy(s.begin(), s.end(), ostream_iterator<char>(os));
    return os;
}

istream &operator>>(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();
    char c;
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
        {
            s.append(c);
        }
        while (is.get(c) && !isspace(c));
        if (is)
        {
            is.unget();
        }
    }
    return is;
}

size_t Str_c::copy_characters(char *dest, size_t count) const
{
    size_t i;

    for (i = 0; i < count && i < size(); i++)
    {
        dest[i] = d[i];
    }

    return i;
}

istream &getline(istream &is, Str_c &s)
{
    s.uncreate();
    s.create();

    char c;

    if (is)
    {
        while (is.get(c) && c != '\n')
        {
            s.append(c);
        }
    }

    return is;
}

class Picture;

class Pic_base
{
    friend class Frame_Pic;
    friend class HCat_Pic;
    friend class VCat_Pic;
    friend class String_Pic;
    friend class Picture;
    friend ostream &operator<<(ostream &, const Picture &);

    typedef vector<string>::size_type ht_sz;
    typedef string::size_type wd_sz;

    virtual wd_sz width() const = 0;
    virtual ht_sz height() const = 0;
    virtual void display(ostream &, ht_sz, bool) const = 0;
    virtual void reframe(const char, const char, const char) = 0;

protected:
    static void pad(ostream &os, wd_sz beg, wd_sz end);
};

class Frame_Pic : public Pic_base
{
    friend Picture frame(const Picture &);
    friend Picture frame(const Picture &, const char, const char, const char);

    Ptr<Pic_base> p;
    char corner;
    char top_bottom;
    char side;

    Frame_Pic(const Ptr<Pic_base> &pic, const char corner_val = '+',
              const char top_bottom_val = '-', const char side_val = '|')
        : p(pic), corner(corner_val), top_bottom(top_bottom_val), side(side_val) { }

    wd_sz width() const
    {
        return p->width() + 4;
    }
    ht_sz height() const
    {
        return p->height() + 4;
    }

    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char);
};

class VCat_Pic : public Pic_base
{
    friend Picture vcat(const Picture &, const Picture &);

    Ptr<Pic_base> top, bottom;

    VCat_Pic(const Ptr<Pic_base> &t, const Ptr<Pic_base> &b) : top(t), bottom(b) { }

    wd_sz width() const
    {
        return max(top->width(), bottom->width());
    }

    ht_sz height() const
    {
        return top->height() + bottom->height();
    }

    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char);
};

class HCat_Pic : public Pic_base
{
    friend Picture hcat(const Picture &, const Picture &);

    Ptr<Pic_base> left, right;

    HCat_Pic(const Ptr<Pic_base> &l, const Ptr<Pic_base> &r) : left(l), right(r) { }

    wd_sz width() const
    {
        return left->width() + right->width();
    }

    ht_sz height() const
    {
        return max(left->height(), right->height());
    }

    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char);
};

class String_Pic : public Pic_base
{
    friend class Picture;

    vector<string> data;
    String_Pic(const vector<string> &v) : data(v) { }

    wd_sz width() const;
    ht_sz height() const
    {
        return data.size();
    };
    void display(ostream &, ht_sz, bool) const;
    void reframe(const char, const char, const char) {}
};

class Picture
{
    friend Picture frame(const Picture &);
    friend Picture frame(const Picture &, const char, const char, const char);
    friend Picture hcat(const Picture &, const Picture &);
    friend Picture vcat(const Picture &, const Picture &);
    friend ostream &operator<<(ostream &, const Picture &);

public:
    Picture(const vector<string> & = vector<string>());
    void reframe(const char corner, const char top_bottom, const char side);

private:
    Ptr<Pic_base> p;

    Picture(Pic_base *ptr) : p(ptr) { }
};

Picture frame(const Picture &pic)
{
    return new Frame_Pic(pic.p);
}

Picture frame(const Picture &pic, const char corner_val, const char top_bottom_val, const char side_val)
{
    return new Frame_Pic(pic.p, corner_val, top_bottom_val, side_val);
}

Picture hcat(const Picture &l, const Picture &r)
{
    return new HCat_Pic(l.p, r.p);
}

Picture vcat(const Picture &t, const Picture &b)
{
    return new VCat_Pic(t.p, b.p);
}

Picture::Picture(const vector<string> &v) : p(new String_Pic(v)) { }

ostream &operator<<(ostream &os, const Picture &picture)
{
    const Pic_base::ht_sz ht = picture.p->height();
    for (Pic_base::ht_sz i = 0; i != ht; ++i)
    {
        picture.p->display(os, i, false);
        os << endl;
    }
    return os;
};

Pic_base::wd_sz String_Pic::width() const
{
    Pic_base::wd_sz n = 0;
    for (Pic_base::ht_sz i = 0; i != data.size(); ++i)
    {
        n = max(n, data[i].size());
    }
    return n;
}

void String_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz start = 0;
    if (row < height())
    {
        os << data[row];
        start = data[row].size();
    }
    if (do_pad)
    {
        pad(os, start, width());
    }
}

void VCat_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz w = 0;
    if (row < top->height())
    {
        top->display(os, row, do_pad);
        w = top->width();
    }
    else if (row < height())
    {
        bottom->display(os, row - top->height(), do_pad);
        w = bottom->width();
    }
    if (do_pad)
    {
        pad(os, w, width());
    }
}

void HCat_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    ht_sz left_row = row;
    ht_sz right_row = row;

    if (left->height() > right->height())
    {
        ht_sz index = ((left->height() - right->height()) / 2);

        if (row >= index)
        {
            right_row = row - index;
        }
        else
        {
            right_row = right->height();
        }
    }
    else
    {
        ht_sz index = ((right->height() - left->height()) / 2);

        if (row >= index)
        {
            left_row = row - index;
        }
        else
        {
            left_row = left->height();
        }
    }

    left->display(os, left_row, do_pad || right_row < right->height());
    right->display(os, right_row, do_pad);
}

void Frame_Pic::display(ostream &os, ht_sz row, bool do_pad) const
{
    if (row >= height())
    {
        if (do_pad)
        {
            pad(os, 0, width());
        }
    }
    else
    {
        if (row == 0 || row == height() - 1)
        {
            os << corner << string(width() - 2, top_bottom) << corner;
        }
        else if (row == 1 || row == height() - 2)
        {
            os << side;
            pad(os, 1, width() - 1);
            os << side;
        }
        else
        {
            os << side << ' ';
            p->display(os, row - 2, true);
            os << ' ' << side;
        }
    }
}

void Pic_base::pad(ostream &os, wd_sz beg, wd_sz end)
{
    while (beg != end)
    {
        os << " ";
        ++beg;
    }
}

class Picture_v;

class Pic_base_v
{
    friend class Frame_Pic_v;
    friend class HCat_Pic_v;
    friend class VCat_Pic_v;
    friend class String_Pic_v;
    friend class Picture_v;
    friend ostream &operator<<(ostream &, const Picture_v &);

    typedef Vec<Str>::size_type ht_sz;
    typedef Str::size_type wd_sz;

    virtual wd_sz width() const = 0;
    virtual ht_sz height() const = 0;
    virtual void display(ostream &, ht_sz, bool) const = 0;

protected:
    static void pad(ostream &os, wd_sz beg, wd_sz end);
};

class Frame_Pic_v : public Pic_base_v
{
    friend Picture_v frame(const Picture_v &);

    Ptr<Pic_base_v> p;

    Frame_Pic_v(const Ptr<Pic_base_v> &pic) : p(pic) { }

    wd_sz width() const
    {
        return p->width() + 4;
    }
    ht_sz height() const
    {
        return p->height() + 4;
    }

    void display(ostream &, ht_sz, bool) const;
};

class VCat_Pic_v : public Pic_base_v
{
    friend Picture_v vcat(const Picture_v &, const Picture_v &);

    Ptr<Pic_base_v> top, bottom;

    VCat_Pic_v(const Ptr<Pic_base_v> &t, const Ptr<Pic_base_v> &b) : top(t), bottom(b) { }

    wd_sz width() const
    {
        return max(top->width(), bottom->width());
    }

    ht_sz height() const
    {
        return top->height() + bottom->height();
    }

    void display(ostream &, ht_sz, bool) const;
};

class HCat_Pic_v : public Pic_base_v
{
    friend Picture_v hcat(const Picture_v &, const Picture_v &);

    Ptr<Pic_base_v> left, right;

    HCat_Pic_v(const Ptr<Pic_base_v> &l, const Ptr<Pic_base_v> &r) : left(l), right(r) { }

    wd_sz width() const
    {
        return left->width() + right->width();
    }

    ht_sz height() const
    {
        return max(left->height(), right->height());
    }

    void display(ostream &, ht_sz, bool) const;
};

class String_Pic_v : public Pic_base_v
{
    friend class Picture_v;

    Vec<Str> data;
    String_Pic_v(const Vec<Str> &v) : data(v) { }

    wd_sz width() const;
    ht_sz height() const
    {
        return data.size();
    };
    void display(ostream &, ht_sz, bool) const;
};

class Picture_v
{
    friend Picture_v frame(const Picture_v &);
    friend Picture_v hcat(const Picture_v &, const Picture_v &);
    friend Picture_v vcat(const Picture_v &, const Picture_v &);
    friend ostream &operator<<(ostream &, const Picture_v &);

public:
    Picture_v(const Vec<Str> & = Vec<Str>());

private:
    Ptr<Pic_base_v> p;
    Picture_v(Pic_base_v *ptr) : p(ptr) { }
};

Picture_v frame(const Picture_v &pic)
{
    return new Frame_Pic_v(pic.p);
}

Picture_v hcat(const Picture_v &l, const Picture_v &r)
{
    return new HCat_Pic_v(l.p, r.p);
}

Picture_v vcat(const Picture_v &t, const Picture_v &b)
{
    return new VCat_Pic_v(t.p, b.p);
}

Picture_v::Picture_v(const Vec<Str> &v) : p(new String_Pic_v(v)) { }

ostream &operator<<(ostream &os, const Picture_v &picture_v)
{
    const Pic_base_v::ht_sz ht = picture_v.p->height();
    for (Pic_base_v::ht_sz i = 0; i != ht; ++i)
    {
        picture_v.p->display(os, i, false);
        os << endl;
    }
    return os;
};

Pic_base_v::wd_sz String_Pic_v::width() const
{
    Pic_base_v::wd_sz n = 0;
    for (Pic_base_v::ht_sz i = 0; i != data.size(); ++i)
    {
        n = max(n, data[i].size());
    }
    return n;
}

void String_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz start = 0;
    if (row < height())
    {
        os << data[row];
        start = data[row].size();
    }
    if (do_pad)
    {
        pad(os, start, width());
    }
}

void VCat_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    wd_sz w = 0;
    if (row < top->height())
    {
        top->display(os, row, do_pad);
        w = top->width();
    }
    else if (row < height())
    {
        bottom->display(os, row - top->height(), do_pad);
        w = bottom->width();
    }
    if (do_pad)
    {
        pad(os, w, width());
    }
}

void HCat_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    left->display(os, row, do_pad || row < right->height());
    right->display(os, row, do_pad);
}

void Frame_Pic_v::display(ostream &os, ht_sz row, bool do_pad) const
{
    if (row >= height())
    {
        if (do_pad)
        {
            pad(os, 0, width());
        }
    }
    else
    {
        if (row == 0 || row == height() - 1)
        {
            os << Str(width(), '*');
        }
        else if (row == 1 || row == height() - 2)
        {
            os << '*';
            pad(os, 1, width() - 1);
            os << '*';
        }
        else
        {
            os << "* ";
            p->display(os, row - 2, true);
            os << " *";
        }
    }
}

void Pic_base_v::pad(ostream &os, wd_sz beg, wd_sz end)
{
    while (beg != end)
    {
        os << " ";
        ++beg;
    }
}

void Frame_Pic::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    this->corner = corner_val;
    this->top_bottom = top_bottom_val;
    this->side = side_val;

    p->reframe(corner_val, top_bottom_val, side_val);
}

void VCat_Pic::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    top->reframe(corner_val, top_bottom_val, side_val);
    bottom->reframe(corner_val, top_bottom_val, side_val);
}

void HCat_Pic::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    left->reframe(corner_val, top_bottom_val, side_val);
    right->reframe(corner_val, top_bottom_val, side_val);
}

void Picture::reframe(const char corner_val, const char top_bottom_val, const char side_val)
{
    p->reframe(corner_val, top_bottom_val, side_val);
}

double median(vector<double> vec)
{
    typedef vector<double>::size_type vec_sz;

    vec_sz size = vec.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }

    sort(vec.begin(), vec.end());
    vec_sz mid = size / 2;

    return size % 2 == 0 ? (vec[mid] + vec[mid - 1]) / 2 : vec[mid];
}

double grade(double midterm, double final, double homework)
{
    return 0.2 * midterm + 0.4 * final + 0.4 * homework;
}

double grade(double midterm, double final, const vector<double> &hw)
{
    if (hw.size() == 0)
    {
        throw domain_error("Student has done no homework");
    }
    return grade(midterm, final, median(hw));
}

istream &read_hw(istream &is, vector<double> &hw)
{
    if (is)
    {
        double x;
        while (is >> x)
        {
            hw.push_back(x);
        }

        is.clear();
        while (is.get() != '\n')
        {
            continue;
        }
    }

    return is;
}

class Core
{
public:
    friend class Student_info;
    friend class Audit;
    Core() : midterm(0), final(0)
    {
        cerr << "constructor Core()" << endl;
    }
    Core(istream &is)
    {
        cerr << "constructor Core(istream &is)" << endl;
        read(is);
    }

    virtual ~Core()
    {
        cerr << "destructor ~Core()" << endl;
    }

    const string &name() const
    {
        return _name;
    }
    virtual double grade() const
    {
        return ::grade(midterm, final, homework);
    }
    string letter_grade() const;
    virtual istream &read(istream &);

    bool valid() const
    {
        return !homework.empty();
    }
    virtual bool requirements_met() const
    {
        return find(homework.begin(), homework.end(), 0.0) == homework.end();
    }
    virtual Core *clone() const
    {
        return new Core(*this);
    }

protected:
    istream &read_common(istream &in)
    {
        in >> _name >> midterm >> final;
        return in;
    }
    double midterm, final;
    vector<double> homework;

private:
    string _name;
};

istream &Core::read(istream &in)
{
    read_common(in);
    read_hw(in, homework);
    return in;
}

string Core::letter_grade() const
{
    static const double numbers[] =
    {
        97, 94, 90, 87, 84, 80, 77, 74, 70, 60, 0
    };

    static const char *const letters[] =
    {
        "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D", "F"
    };

    static const size_t ngrades = sizeof(numbers) / sizeof(*numbers);

    double result = grade();

    for (size_t i = 0; i < ngrades; ++i)
    {
        if (result >= numbers[i])
        {
            return letters[i];
        }
    }
    return "?\?\?";
}

inline bool compare(const Core &c1, const Core &c2)
{
    return c1.name() < c2.name();
}

inline bool compare_Core_ptrs(const Core *cp1, const Core *cp2)
{
    return compare(*cp1, *cp2);
}

class Grad : public Core
{
public:
    Grad() : thesis(0.0)
    {
        cerr << "constructor Grad()" << endl;
    }
    Grad(istream &is)
    {
        cerr << "constructor Grad(istream &is)" << endl;
        read(is);
    }

    ~Grad()
    {
        cerr << "destructor ~Grad()" << endl;
    }
    double grade() const;
    istream &read(istream &);

    bool requirements_met() const
    {
        return Core::requirements_met() && thesis != 0.0;
    }
    Grad *clone() const
    {
        return new Grad(*this);
    }

protected:

private:
    double thesis;
};

istream &Grad::read(istream &in)
{
    Core::read_common(in);
    in >> Grad::thesis;
    read_hw(in, Core::homework);
    return in;
}

double Grad::grade() const
{
    return min(Core::grade(), Grad::thesis);
}

class Credit : public Core
{
public:
    Credit() {}
    Credit(istream &is) : Core(is) {}

    double grade() const;
    bool passed() const
    {
        return grade() >= 60;
    }

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }
    Credit *clone() const
    {
        return new Credit(*this);
    }

protected:
};

double Credit::grade() const
{
    if (Core::homework.empty())
    {
        return (midterm + final) / 2.0;
    }
    else
    {
        return Core::grade();
    }
}

class Audit : public Core
{
public:
    Audit() {}
    Audit(istream &is)
    {
        read(is);
    }

    istream &read(istream &in)
    {
        in >> _name;
        return in;
    }

    double grade() const
    {
        return 0.0;
    };

    bool valid() const
    {
        return true;
    }
    bool requirements_met() const
    {
        return true;
    }
    Audit *clone() const
    {
        return new Audit(*this);
    }

protected:
};

class Student_info
{
public:
    Student_info() { }
    Student_info(istream &is)
    {
        read(is);
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Handle<Core> cp;
};

istream &Student_info::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

inline bool compare_info(const Student_info &s1, const Student_info &s2)
{
    return s1.name() < s2.name();
}

class Student_info_p
{
public:
    Student_info_p() { }
    Student_info_p(istream &is)
    {
        read(is);
    }

    istream &read(istream &);

    const string &name() const
    {
        if (cp)
        {
            return cp->name();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

    double grade() const
    {
        if (cp)
        {
            return cp->grade();
        }
        else
        {
            throw runtime_error("uninitialized Student");
        }
    }

private:
    Ptr<Core> cp;
};

istream &Student_info_p::read(istream &is)
{
    char ch;
    cout << "Enter U for new Core, C for new Credit, A for new Audit, G for new Grad" << endl;
    if (is >> ch)
    {
        if (ch == 'U')
        {
            cout << "new Core" << endl;
            cp = new Core(is);
        }
        else if (ch == 'C')
        {
            cout << "new Credit" << endl;
            cp = new Credit(is);
        }
        else if (ch == 'A')
        {
            cout << "new Audit" << endl;
            cp = new Audit(is);
        }
        else
        {
            cout << "new Grad" << endl;
            cp = new Grad(is);
        }
    }
    return is;
}

inline bool compare_info_p(const Student_info_p &s1, const Student_info_p &s2)
{
    return s1.name() < s2.name();
}

inline bool compare_Core_handles(const Handle<Core> hc1, const Handle<Core> hc2)
{
    return compare(*hc1, *hc2);
}

inline bool compare_Core_Ptr(const Ptr<Core> hc1, const Ptr<Core> hc2)
{
    return compare(*hc1, *hc2);
}

inline bool compare_Core_Ptr_r(const Ptr_r<Core> hc1, const Ptr_r<Core> hc2)
{
    return compare(*hc1, *hc2);
}

Picture histogram(const vector<Student_info> &students)
{
    Picture names;
    Picture grades;
    for (vector<Student_info>::const_iterator it = students.begin(); it != students.end(); ++it)
    {
        names = vcat(names, vector<string>(1, it->name()));
        grades = vcat(grades, vector<string>(1, " " + string((int)it->grade() / 5, '=')));
    }
    return hcat(names, grades);
}

int main(int argc, const char *argv[])
{
    try
    {
        vector<Student_info> students;
        Student_info record;
        while (record.read(cin))
        {
            students.push_back(record);
        }
        sort(students.begin(), students.end(), compare_info);
        cout << frame(histogram(students)) << endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
U
new Core
constructor Core(istream &is)
Geert 50 80 90 45 30 80 end
destructor ~Core()
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
G
new Grad
constructor Core()
constructor Grad(istream &is)
Joris 80 90 62 60 70 60 70 60 end
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
U
new Core
constructor Core(istream &is)
Pieter 40 50 30 40 50 50 40 end
destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
G
new Grad
constructor Core()
constructor Grad(istream &is)
Lotte 40 80 62 90 45 60 70 end
destructor ~Core()
destructor ~Grad()
destructor ~Core()
Enter U for new Core, C for new Credit, A for new Audit, G for new Grad
destructor ~Grad()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
+----------------------+
|                      |
| Geert  ============= |
| Joris  ============  |
| Lotte  ============  |
| Pieter ========      |
|                      |
+----------------------+

destructor ~Grad()
destructor ~Core()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Grad()
destructor ~Core()
destructor ~Core()

第12章 面向对象编程：多态性
12.1 简介
12.2 多态性介绍：多态视频游戏
12.3 类继承层次中对象之间的关系
12.4 类型域和switch语句
12.5 抽象类和纯virtual函数
12.6 实例研究：应用多态性的工资发放系统
12.7（选读）多态性、virtual函数和动态绑定的底层实现机制
12.8 实例研究：应用向下强制类型转换、dynamic-cast，typeid和typeinfo
       并使用多态性和运行时类型信息的工资发放系统
12.9 本章小结
ch12_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class abstr_emp
{
private:
    std::string fname;
    std::string lname;
    std::string job;
public:
    enum classkind { Employee, Manager, Fink, Highfink };
    abstr_emp();
    abstr_emp(const std::string &fn, const std::string   &ln, const std::string   &j);
    virtual void ShowAll() const;
    virtual void SetAll();
    friend std::ostream &operator <<(std::ostream &os, const abstr_emp &e);
    virtual ~abstr_emp() = 0;
    virtual void writeall(std::ofstream &ofs) const;
    virtual void getall(std::ifstream &ofs);
};

class employee : public abstr_emp
{
public:
    employee();
    employee(const std::string &fn, const std::string &ln, const std::string &j);
    virtual void ShowAll() const;
    virtual void SetAll();
    virtual void writeall(std::ofstream &ofs) const;
    virtual void getall(std::ifstream &ofs);
};

class manager : virtual public abstr_emp
{
private:
    int inchargeof;
protected:
    int InChargeOf() const
    {
        return inchargeof;
    }
    int &InChargeOf()
    {
        return inchargeof;
    }
public:
    manager();
    manager(const std::string &fn, const std::string &ln, const std::string &j, int ico = 0);
    manager(const abstr_emp &e, int ico);
    manager(const manager &m);
    virtual void ShowAll() const;
    virtual void SetAll();
    virtual void writeall(std::ofstream &ofs) const;
    virtual void getall(std::ifstream &ofs);
};

class fink : virtual public abstr_emp
{
private:
    std::string reportsto;
protected:
    const std::string &ReportsTo() const
    {
        return reportsto;
    }
    std::string &ReportsTo()
    {
        return reportsto;
    }
public:
    fink();
    fink(const std::string &fn, const std::string &ln, const std::string &j, const std::string &rpo);
    fink(const abstr_emp &e, const std::string &rpo);
    fink(const fink &e);
    virtual void ShowAll() const;
    virtual void SetAll();
    virtual void writeall(std::ofstream &ofs) const;
    virtual void getall(std::ifstream &ofs);
};

class highfink : public manager, public fink
{
public:
    highfink();
    highfink(const std::string &fn, const std::string &ln, const std::string &j, const std::string &rpo, int ico);
    highfink(const abstr_emp &e, const std::string &rpo, int ico);
    highfink(const fink &f, int ico);
    highfink(const manager &m, const std::string &rpo);
    highfink(const highfink &h);
    virtual void ShowAll() const;
    virtual void SetAll();
    virtual void writeall(std::ofstream &ofs) const;
    virtual void getall(std::ifstream &ofs);
};


abstr_emp::abstr_emp()
{
    fname = "";
    lname = "";
    job = "";
}

abstr_emp::abstr_emp(const std::string &fn, const std::string   &ln, const std::string   &j) : fname(fn), lname(ln), job(j)
{

}

void abstr_emp::ShowAll() const
{
    std::cout << "First name: " << fname << std::endl;
    std::cout << "Last name: " << lname << std::endl;
    std::cout << "Job: " << job << std::endl;
}

void abstr_emp::SetAll()
{
    std::cout << "Enter first name: ";
    std::cin >> fname;

    while (std::cin.get() != '\n')
    {
        continue;
    }

    std::cout << "Enter last name: ";
    std::cin >> lname;

    while (std::cin.get() != '\n')
    {
        continue;
    }

    std::cout << "Enter the job: ";
    std::getline(std::cin, job, '\n');
}

std::ostream &operator<<(std::ostream &os, const abstr_emp &e)
{
    os << e.lname << ", " << e.fname << " : " << e.job;
    return os;
}

abstr_emp::~abstr_emp()
{

}

void abstr_emp::writeall(std::ofstream &ofs) const
{
    ofs << "First name: " << fname << std::endl;
    ofs << "Last name: " << lname << std::endl;
    ofs << "Job: " << job << std::endl;
}
void abstr_emp::getall(std::ifstream &ifs)
{
    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    std::getline(ifs, fname, '\n');
    std::cout << "First name is " << fname << std::endl;

    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    std::getline(ifs, lname, '\n');
    std::cout << "Last name is " << lname << std::endl;

    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    std::getline(ifs, job, '\n');
    std::cout << "Job is " << job << std::endl;
}

employee::employee() : abstr_emp()
{

}

employee::employee(const std::string &fn, const std::string   &ln, const std::string   &j) : abstr_emp(fn, ln, j)
{

}

void employee::ShowAll() const
{
    std::cout << "Status: Employee" << std::endl;
    abstr_emp::ShowAll();
}

void employee::SetAll()
{
    abstr_emp::SetAll();
}

void employee::writeall(std::ofstream &ofs) const
{
    ofs << abstr_emp::Employee << std::endl;
    abstr_emp::writeall(ofs);
}

void employee::getall(std::ifstream &ifs)
{
    abstr_emp::getall(ifs);
}

manager::manager() : abstr_emp()
{
    inchargeof = 0;
}

manager::manager(const std::string &fn, const std::string &ln,
                 const std::string &j, int ico) : abstr_emp(fn, ln, j)
{
    inchargeof = ico;

    if (inchargeof < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        inchargeof = 0;
    }
}

manager::manager(const abstr_emp &e, int ico) : abstr_emp(e)
{
    inchargeof = ico;

    if (inchargeof < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        inchargeof = 0;
    }
}

manager::manager(const manager &m) : abstr_emp(m)
{
    inchargeof = m.inchargeof;
}

void manager::ShowAll() const
{
    std::cout << "Status: Manager" << std::endl;
    abstr_emp::ShowAll();
    std::cout << "In charge of " << inchargeof << " people" << std::endl;
}

void manager::SetAll()
{
    abstr_emp::SetAll();
    std::cout << "Enter the number of people the manager is in charge of: ";
    std::cin >> inchargeof;
    while (std::cin.get() != '\n')
    {
        continue;
    }
    if (inchargeof < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        inchargeof = 0;
    }
}

void manager::writeall(std::ofstream &ofs) const
{
    ofs << abstr_emp::Manager << std::endl;
    abstr_emp::writeall(ofs);
    ofs << "Number of people managed: " << inchargeof << std::endl;
}

void manager::getall(std::ifstream &ifs)
{
    abstr_emp::getall(ifs);
    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    ifs >> inchargeof;
    ifs.get();
}

fink::fink() : abstr_emp(), reportsto("")
{

}

fink::fink(const std::string &fn, const std::string &ln,
           const std::string &j, const std::string &rpo) : abstr_emp(fn, ln, j), reportsto(rpo)
{

}

fink::fink(const abstr_emp &e, const std::string &rpo) : abstr_emp(e), reportsto(rpo)
{

}

fink::fink(const fink &e) : abstr_emp(e)
{
    reportsto = e.reportsto;
}

void fink::ShowAll() const
{
    std::cout << "Status: fink" << std::endl;
    abstr_emp::ShowAll();
    std::cout << "Reports to " << reportsto << std::endl;
}

void fink::SetAll()
{
    abstr_emp::SetAll();
    std::cout << "Enter whomever is reported to: ";
    std::getline(std::cin, reportsto, '\n');
}

void fink::writeall(std::ofstream &ofs) const
{
    ofs << abstr_emp::Fink << std::endl;
    abstr_emp::writeall(ofs);
    ofs << "Reports to: " << reportsto << std::endl;
}

void fink::getall(std::ifstream &ifs)
{
    abstr_emp::getall(ifs);
    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    std::getline(ifs, reportsto, '\n');
}
highfink::highfink() : abstr_emp(), manager(), fink()
{

}
highfink::highfink(const std::string &fn, const std::string &ln,
                   const std::string &j, const std::string &rpo, int ico) : abstr_emp(fn, ln, j), manager(fn, ln, j, ico), fink(fn, ln, j, rpo)
{

}
highfink::highfink(const abstr_emp &e, const std::string &rpo, int ico) : abstr_emp(e), manager(e, ico), fink(e, rpo)
{

}

highfink::highfink(const fink &f, int ico) : abstr_emp(f), manager(f, ico), fink(f)
{

}

highfink::highfink(const manager &m, const std::string &rpo) : abstr_emp(m), manager(m), fink(m, rpo)
{

}

highfink::highfink(const highfink &h) : abstr_emp(h), manager(h), fink(h)
{

}

void highfink::ShowAll() const
{
    std::cout << "Status: Highfink" << std::endl;
    abstr_emp::ShowAll();
    std::cout << "In charge of " << InChargeOf() << " people" << std::endl;
    std::cout << "Reports to " << ReportsTo() << std::endl;
}

void highfink::SetAll()
{
    abstr_emp::SetAll();
    std::cout << "Enter the number of people managed: ";
    std::cin >> InChargeOf();
    while (std::cin.get() != '\n')
    {
        continue;
    }
    if (InChargeOf() < 0)
    {
        std::cout << "Error, cannot be in charge of negative people." << std::endl;
        std::cout << "Setting inchargeof to 0" << std::endl;
        InChargeOf() = 0;
    }

    std::cout << "Enter whomever is reported to: ";
    std::getline(std::cin, ReportsTo(), '\n');
}

void highfink::writeall(std::ofstream &ofs) const
{
    ofs << abstr_emp::Highfink << std::endl;
    abstr_emp::writeall(ofs);
    ofs << "Number of people managed: " << InChargeOf() << std::endl;
    ofs << "Reports to: " << ReportsTo() << std::endl;
}

void highfink::getall(std::ifstream &ifs)
{
    abstr_emp::getall(ifs);
    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    ifs >> InChargeOf();
    ifs.get();
    ifs.ignore(256, ':');
    while (' ' == ifs.peek())
    {
        ifs.get();
    }
    std::getline(ifs, ReportsTo(), '\n');
}

const int MAX = 10;

void displayMenu(void)
{
    std::cout << "Select one of the following:" << std::endl;
    std::cout << std::left;
    std::cout << std::setw(20) << "a. Employee";
    std::cout << std::setw(20) << "b. Manager";
    std::cout << std::endl;
    std::cout << std::setw(20) << "c. Fink";
    std::cout << std::setw(20) << "d. Highfink";
    std::cout << std::endl;
    std::cout << "(q to quit)" << std::endl;
}

void eatline(void)
{
    while (std::cin.get() != '\n')
    {
        continue;
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        abstr_emp *pc[MAX];
        std::cout << "You may enter of to " << MAX << " employees" << std::endl;

        int count = 0;
        char ch;
        std::ifstream fin;
        fin.open("employeeList.dat");

        if (fin.is_open())
        {
            int classtype = 0;
            while ( fin >> classtype && fin.get(ch) )
            {
                switch (classtype)
                {
                case abstr_emp::Employee:
                    std::cout << "Creating an employee object" << std::endl;
                    pc[count] = new employee;
                    pc[count++]->getall(fin);
                    break;
                case abstr_emp::Manager:
                    std::cout << "Creating an manager object" << std::endl;
                    pc[count] = new manager;
                    pc[count++]->getall(fin);
                    break;
                case abstr_emp::Fink:
                    std::cout << "Creating an fink object" << std::endl;
                    pc[count] = new fink;
                    pc[count++]->getall(fin);
                    break;
                case abstr_emp::Highfink:
                    std::cout << "Creating an highfink object" << std::endl;
                    pc[count] = new highfink;
                    pc[count++]->getall(fin);
                    break;
                default:
                    std::cerr << "It looks like an error has occurred" << std::endl;
                    break;
                }
            }
            std::cout << "Here is your current employee list: " << std::endl;
            for (int i = 0; i < count; i++)
            {
                pc[i]->ShowAll();
                std::cout << std::endl;
            }
            fin.close();
        }

        while (count < MAX)
        {
            displayMenu();
            std::cin >> ch;
            eatline();

            switch (ch)
            {
            case 'a':
                pc[count] = new employee;
                pc[count]->SetAll();
                count++;
                break;
            case 'b':
                pc[count] = new manager;
                pc[count]->SetAll();
                count++;
                break;
            case 'c':
                pc[count] = new fink;
                pc[count]->SetAll();
                count++;
                break;
            case 'd':
                pc[count] = new highfink;
                pc[count]->SetAll();
                count++;
                break;
            case 'q':
                break;
            default:
                std::cout << "Error input not recognized" << std::endl;
                continue;
                break;
            }
            if (ch == 'q')
            {
                break;
            }
        }

        std::ofstream fout;
        fout.open("employeeList.dat");

        if (!fout.is_open())
        {
            std::cerr << "Error, cannot open employeeList.dat" << std::endl;
            exit(EXIT_FAILURE);
        }

        std::cout << "Here's our updated list: " << std::endl;

        for (int i = 0; i < count; i++)
        {
            pc[i]->ShowAll();
            std::cout << std::endl;
            pc[i]->writeall(fout);
        }
        fout.close();
        for (int i = 0; i < count; i++)
        {
            delete pc[i];
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
You may enter of to 10 employees
Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
a
Enter first name: Hello
Enter last name: World
Enter the job: aaabbb
Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
b
Enter first name: Mike
Enter last name: Pence
Enter the job: cccddd
Enter the number of people the manager is in charge of: 5
Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
c
Enter first name: Peter
Enter last name: Smith
Enter the job: eeefff
Enter whomever is reported to: Mike
Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
d
Enter first name: Apple
Enter last name: Flower
Enter the job: hhhiii
Enter the number of people managed: 8
Enter whomever is reported to: Mike
Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
q
Here's our updated list:
Status: Employee
First name: Hello
Last name: World
Job: aaabbb

Status: Manager
First name: Mike
Last name: Pence
Job: cccddd
In charge of 5 people

Status: fink
First name: Peter
Last name: Smith
Job: eeefff
Reports to Mike

Status: Highfink
First name: Apple
Last name: Flower
Job: hhhiii
In charge of 8 people
Reports to Mike

ch12_p01
You may enter of to 10 employees
Creating an employee object
First name is Hello
Last name is World
Job is aaabbb
Creating an manager object
First name is Mike
Last name is Pence
Job is cccddd
Creating an fink object
First name is Peter
Last name is Smith
Job is eeefff
Creating an highfink object
First name is Apple
Last name is Flower
Job is hhhiii
Here is your current employee list:
Status: Employee
First name: Hello
Last name: World
Job: aaabbb

Status: Manager
First name: Mike
Last name: Pence
Job: cccddd
In charge of 5 people

Status: fink
First name: Peter
Last name: Smith
Job: eeefff
Reports to Mike

Status: Highfink
First name: Apple
Last name: Flower
Job: hhhiii
In charge of 8 people
Reports to Mike

Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
b
Enter first name: Sun
Enter last name: Flower
Enter the job: jjjkkk
Enter the number of people the manager is in charge of: 9
Select one of the following:
a. Employee         b. Manager
c. Fink             d. Highfink
(q to quit)
q
Here's our updated list:
Status: Employee
First name: Hello
Last name: World
Job: aaabbb

Status: Manager
First name: Mike
Last name: Pence
Job: cccddd
In charge of 5 people

Status: fink
First name: Peter
Last name: Smith
Job: eeefff
Reports to Mike

Status: Highfink
First name: Apple
Last name: Flower
Job: hhhiii
In charge of 8 people
Reports to Mike

Status: Manager
First name: Sun
Last name: Flower
Job: jjjkkk
In charge of 9 people

ch12_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

std::random_device rd;
std::mt19937 gen(rd());

int getRandomNumber(const int &min, const int &max)
{
    return std::uniform_int_distribution<int> {min, max}(gen);
}

class Person
{
private:
    std::string firstname;
    std::string lastname;
protected:
    virtual void Data() const;
public:
    Person(const std::string &first = "", const std::string &last = "");
    virtual ~Person() {};
    void setFirstName(const std::string &s)
    {
        firstname = s;
    }
    void setLastName(const std::string &s)
    {
        lastname = s;
    }
    virtual void Show() const;
    virtual void Set();
};
class Gunslinger : virtual public Person
{
private:
    double drawtime;
    int notches;
protected:
    void Data() const;
    virtual void setData();
public:
    Gunslinger(const std::string &first = "", const std::string &last = "", double d = 0, int n = 0);
    ~Gunslinger() {};
    void setDrawTime(double d);
    void setNotches(int n);
    double Draw() const
    {
        return drawtime;
    }
    int Notches() const
    {
        return notches;
    }
    virtual void Show() const;
    virtual void Set()
    {
        Person::Set();
        Gunslinger::setData();
    }
};

class PokerPlayer : virtual public Person
{
public:
    PokerPlayer(std::string first = "", std::string last = "");
    ~PokerPlayer() {}
    int Draw() const
    {
        return getRandomNumber(1, 52);
    }
    virtual void Show() const;
    virtual void Set()
    {
        Person::Set();
    }
};

class BadDude : public Gunslinger, public PokerPlayer
{
private:
public:
    BadDude(std::string first = "", std::string last = "", double d = 0, int n = 0);
    ~BadDude() {}
    double Gdraw() const
    {
        return Gunslinger::Draw();
    }
    int Cdraw() const
    {
        return PokerPlayer::Draw();
    }
    virtual void Show() const;
    void Set();
};


void Person::Data() const
{
    std::cout << "First name: " << firstname << std::endl;
    std::cout << "Last name: " << lastname << std::endl;
}
Person::Person(const std::string &first, const std::string &last)
{
    firstname = first;
    lastname = last;
}
void Person::Show() const
{
    std::cout << "Type Person" << std::endl;
    Data();
}
void Person::Set()
{
    std::cout << "Enter the first name: ";
    std::getline(std::cin, firstname, '\n');
    std::cout << "Enter the last name: ";
    std::getline(std::cin, lastname, '\n');
}
void Gunslinger::Data() const
{
    std::cout << "Draw time: " << drawtime << std::endl;
    std::cout << "Notches: " << notches << std::endl;
}
void Gunslinger::setData()
{
    std::cout << "Enter the draw time: ";
    std::cin >> drawtime;
    while (!std::cin || drawtime < 0)
    {
        std::cin.clear();
        while (std::cin.get() != '\n')
        {
            continue;
        }
        std::cout << "Draw time must be a positive number.\nTry again: ";
        std::cin >> drawtime;
    }

    std::cout << "Enter the number of notches: ";
    std::cin >> notches;
    while (!std::cin || notches < 0)
    {
        std::cin.clear();
        while (std::cin.get() != '\n')
        {
            continue;
        }
        std::cout << "Notches must be a positive integer.\nTry again: ";
        std::cin >> notches;
    }
    while (std::cin.get() != '\n')
    {
        continue;
    }
}

Gunslinger::Gunslinger(const std::string &first, const std::string &last, double d, int n) : Person(first, last)
{
    drawtime = d;
    notches = n;
}

void Gunslinger::setDrawTime(double d)
{
    if (d < 0)
    {
        std::cerr << "Error, draw time cannot be negative. ";
        std::cerr << "Setting draw time to 0." << std::endl;
        drawtime = 0;
    }
    else
    {
        drawtime = d;
    }
}
void Gunslinger::setNotches(int n)
{
    if (n < 0)
    {
        std::cerr << "Error, notches cannot be negative. ";
        std::cerr << "Setting notches to 0." << std::endl;
        notches = 0;
    }
    else
    {
        notches = n;
    }
}

void Gunslinger::Show() const
{
    std::cout << "Type Gunslinger" << std::endl;
    Person::Data();
    Data();
}
PokerPlayer::PokerPlayer(std::string first, std::string last) : Person(first, last)
{

}
void PokerPlayer::Show() const
{
    std::cout << "Type Poker Player" << std::endl;
    Person::Data();
}
BadDude::BadDude(std::string first, std::string last, double d, int n) : Person(first, last), Gunslinger(first, last, d, n), PokerPlayer(first, last)
{

}
void BadDude::Show() const
{
    std::cout << "Type BadDude" << std::endl;
    Person::Data();
    Gunslinger::Data();
}
void BadDude::Set()
{
    Person::Set();
    Gunslinger::setData();
}

const int SIZE = 4;

int main(int argc, const char *argv[])
{
    try
    {
        Person *pp[SIZE];
        int ct;
        for (ct = 0; ct < SIZE; ct++)
        {
            std::cout << "Enter the person category:\n";
            std::cout << "p: person        g: gunslinger" << std::endl;
            std::cout << "k: poker player  b: bad dude" << std::endl;
            std::cout << "q: quit" << std::endl;

            char choice = 0;
            std::cin >> choice;
            while (std::cin.get() != '\n')
            {
                continue;
            }

            while (std::strchr("pgkbq", choice) == nullptr)
            {
                std::cout << "Please enter a p, g, k, b, or q: ";
                std::cin >> choice;
                while (std::cin.get() != '\n')
                {
                    continue;
                }
            }

            if (choice == 'q')
            {
                break;
            }

            switch (choice)
            {
            case 'p':
                pp[ct] = new Person;
                break;
            case 'g':
                pp[ct] = new Gunslinger;
                break;
            case 'k':
                pp[ct] = new PokerPlayer;
                break;
            case 'b':
                pp[ct] = new BadDude;
                break;
            default:
                pp[ct] = new BadDude;
                break;
            }
            pp[ct]->Set();
            pp[ct]->Show();
            std::cout << "ct = " << ct << std::endl;
            std::cout << std::endl;
        }

        std::cout << "Your selection:" << std::endl;
        for (int i = 0; i < ct; i++)
        {
            pp[i]->Show();
            std::cout << std::endl;
            delete *(pp + i);
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter the person category:
p: person        g: gunslinger
k: poker player  b: bad dude
q: quit
p
Enter the first name: Mike
Enter the last name: Pence
Type Person
First name: Mike
Last name: Pence
ct = 0

Enter the person category:
p: person        g: gunslinger
k: poker player  b: bad dude
q: quit
g
Enter the first name: Peter
Enter the last name: Smith
Enter the draw time: 3
Enter the number of notches: 6
Type Gunslinger
First name: Peter
Last name: Smith
Draw time: 3
Notches: 6
ct = 1

Enter the person category:
p: person        g: gunslinger
k: poker player  b: bad dude
q: quit
k
Enter the first name: Hello
Enter the last name: World
Type Poker Player
First name: Hello
Last name: World
ct = 2

Enter the person category:
p: person        g: gunslinger
k: poker player  b: bad dude
q: quit
b
Enter the first name: Apple
Enter the last name: Orange
Enter the draw time: 2
Enter the number of notches: 3
Type BadDude
First name: Apple
Last name: Orange
Draw time: 2
Notches: 3
ct = 3

Your selection:
Type Person
First name: Mike
Last name: Pence

Type Gunslinger
First name: Peter
Last name: Smith
Draw time: 3
Notches: 6

Type Poker Player
First name: Hello
Last name: World

Type BadDude
First name: Apple
Last name: Orange
Draw time: 2
Notches: 3

ch12_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template <typename T>
class QueueTp
{
private:
    struct Node
    {
        T value;
        Node *next = nullptr;
        Node *prev = nullptr;
    };
    using link = Node*;
    link head = nullptr;
    link tail = nullptr;
    void emptyList();
public:
    QueueTp();
    QueueTp(const QueueTp<T> &q);
    ~QueueTp();

    bool enqueue(const T &val);
    bool dequeue(T &val);
    bool isEmpty() const;

    QueueTp<T> &operator = (const QueueTp<T> &q);
};

template <typename T>
QueueTp<T>::QueueTp() : head(nullptr), tail(nullptr)
{

}

template <typename T>
QueueTp<T>::QueueTp(const QueueTp<T> &q)
{
    link tail = q.tail;
    while (tail != nullptr)
    {
        enqueue(tail->value);
        tail = tail->prev;
    }
}
template <typename T>
QueueTp<T>::~QueueTp()
{
    emptyList();
}
template <typename T>
void QueueTp<T>::emptyList()
{
    link t = head;
    link next;
    while (t != nullptr)
    {
        next = t->next;
        delete t;
        t = next;
    }
    head = nullptr;
    tail = nullptr;
}
template <typename T>
bool QueueTp<T>::enqueue(const T &val)
{
    link l = new (std::nothrow) Node;
    if (l == nullptr)
    {
        return false;
    }
    else
    {
        if (isEmpty())
        {
            l->value = val;
            l->next = nullptr;
            l->prev = nullptr;
            head = l;
            tail = l;
        }
        else
        {
            l->value = val;
            l->next = head;
            l->prev = nullptr;
            head->prev = l;
            head = l;
        }
        return true;
    }
}
template <typename T>
bool QueueTp<T>::dequeue(T &val)
{
    if (isEmpty())
    {
        return false;
    }
    else
    {
        if (head == tail)
        {
            val = tail->value;
            delete tail;
            head = tail = nullptr;
        }
        else
        {
            val = tail->value;
            link prev = tail->prev;
            delete tail;
            tail = prev;
            tail->next = nullptr;
        }
        return true;
    }
}
template <typename T>
bool QueueTp<T>::isEmpty() const
{
    if (nullptr == head && nullptr == tail)
    {
        return true;
    }
    else
    {
        return false;
    }
}
template <typename T>
QueueTp<T> &QueueTp<T>::operator = (const QueueTp<T> &q)
{
    if (&q == this)
    {
        return *this;
    }

    emptyList();
    link t = q.tail;
    while (t != nullptr)
    {
        enqueue(t->value);
        t = t->prev;
    }
    return *this;
}

class Worker
{
private:
    std::string fullname;
    long id;
protected:
    virtual void Data() const;
    virtual void Get();
public:
    Worker() : fullname("no one"), id(0L) {}
    Worker(const std::string &s, long n) : fullname(s), id(n) {}
    virtual ~Worker() = 0;
    virtual void Set() = 0;
    virtual void Show() const = 0;
};

class Waiter : virtual public Worker
{
private:
    int panache;
protected:
    void Data() const;
    void Get();
public:
    Waiter() : Worker(), panache(0) {}
    Waiter(const std::string &s, long n, int p = 0) : Worker(s, n), panache(p) {}
    Waiter(const Worker &wk, int p = 0) : Worker(wk), panache(p) {}
    void Set();
    void Show() const;
};

class Singer : virtual public Worker
{
protected:
    enum
    {
        other, alto, contralto, soprano,
        bass, baritone, tenor
    };
    enum { Vtypes = 7 };
    void Data() const;
    void Get();
private:
    static const char *pv[Vtypes];
    int voice;
public:
    Singer() : Worker(), voice(other) {}
    Singer(const std::string &s, long n, int v = other) : Worker(s, n), voice(v) {}
    Singer(const Worker &wk, int v = other) : Worker(wk), voice(v) {}
    void Set();
    void Show() const;
};
class SingingWaiter : public Singer, public Waiter
{
protected:
    void Data() const;
    void Get();
public:
    SingingWaiter() {}
    SingingWaiter(const std::string &s, long n, int p = 0, int v = Singer::other) : Worker(s, n), Waiter(s, n, p), Singer(s, n, v) {}
    SingingWaiter(const Worker &wk, int p = 0, int v = Singer::other) : Worker(wk), Waiter(wk, p), Singer(wk, v) {}
    SingingWaiter(const Waiter &wt, int v = Singer::other) : Worker(wt), Waiter(wt), Singer(wt, v) {}
    SingingWaiter(const Singer &wt, int p = 0) : Worker(wt), Waiter(wt, p), Singer(wt) {}
    void Set();
    void Show() const;
};

Worker::~Worker() { }

void Worker::Data() const
{
    cout << "Name: " << fullname << endl;
    cout << "Employee ID: " << id << endl;
}

void Worker::Get()
{
    std::getline(cin, fullname, '\n');
    cout << "Enter worker's ID: ";
    cin >> id;
    while (cin.get() != '\n')
    {
        continue;
    }
}

void Waiter::Set()
{
    cout << "Enter waiter's name: ";
    Worker::Get();
    Get();
}
void Waiter::Show() const
{
    cout << "Category: waiter\n";
    Worker::Data();
    Data();
}
void Waiter::Data() const
{
    cout << "Panache rating: " << panache << endl;
}
void Waiter::Get()
{
    cout << "Enter waiter's panache rating: ";
    cin >> panache;
    while (cin.get() != '\n')
    {
        continue;
    }
}
const char *Singer::pv[Singer::Vtypes] = { "other", "alto", "contralto", "soprano", "bass", "baritone", "tenor" };

void Singer::Set()
{
    cout << "Enter singer's name: ";
    Worker::Get();
    Get();
}

void Singer::Show() const
{
    cout << "Category: singer\n";
    Worker::Data();
    Data();
}
void Singer::Data() const
{
    cout << "Vocal range: " << pv[voice] << endl;
}
void Singer::Get()
{
    cout << "Enter number for singer's vocal range:\n";
    int i;
    for (i = 0; i < Vtypes; i++)
    {
        cout << i << ": " << pv[i] << "   ";
        if (i % 4 == 3)
        {
            cout << endl;
        }
    }
    if (i % 4 != 0)
    {
        cout << '\n';
    }
    while (cin >> voice && (voice < 0 || voice >= Vtypes))
    {
        cout << "Please enter a value >= 0 and < " << Vtypes << endl;
    }
    cin.clear();
    while (cin.get() != '\n')
    {
        continue;
    }
}
void SingingWaiter::Data() const
{
    Singer::Data();
    Waiter::Data();
}
void SingingWaiter::Get()
{
    Waiter::Get();
    Singer::Get();
}
void SingingWaiter::Set()
{
    cout << "Enter singing waiter's name: ";
    Worker::Get();
    Get();
}
void SingingWaiter::Show() const
{
    cout << "Category: singing waiter\n";
    Worker::Data();
    Data();
}

const int SIZE = 5;

int main(int argc, const char *argv[])
{
    try
    {
        QueueTp<Worker *> q;
        Worker *pw;
        int ct;
        for (ct = 0; ct < SIZE; ct++)
        {
            std::cout << "Enter the employee category:\n";
            std::cout << "w: waiter  s: singer  ";
            std::cout << "t: singing waiter  q: quit\n";

            char choice = 0;
            std::cin >> choice;
            while (std::cin.get() != '\n')
            {
                continue;
            }
            while (std::strchr("wstq", choice) == nullptr)
            {
                std::cout << "Please enter a w, s, t, or q: ";
                std::cin >> choice;
                while (std::cin.get() != '\n')
                {
                    continue;
                }
            }

            if (choice == 'q')
            {
                break;
            }

            switch (choice)
            {
            case 'w':
                pw = new Waiter;
                break;
            case 's':
                pw = new Singer;
                break;
            case 't':
                pw = new SingingWaiter;
                break;
            default:
                pw = new SingingWaiter;
                break;
            }

            pw->Set();
            q.enqueue(pw);
        }

        std::cout << "\nHere is your staff:\n";

        for (int i = 0; i < ct; i++)
        {
            q.dequeue(pw);
            pw->Show();
            delete pw;
            std::cout << std::endl;
        }
        std::cout << "Done.\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
w
Enter waiter's name: Apple
Enter worker's ID: 222333
Enter waiter's panache rating: 8
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
s
Enter singer's name: Orange
Enter worker's ID: 555666
Enter number for singer's vocal range:
0: other   1: alto   2: contralto   3: soprano
4: bass   5: baritone   6: tenor
1
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
t
Enter singing waiter's name: Water
Enter worker's ID: 888999
Enter waiter's panache rating: 9
Enter number for singer's vocal range:
0: other   1: alto   2: contralto   3: soprano
4: bass   5: baritone   6: tenor
6
Enter the employee category:
w: waiter  s: singer  t: singing waiter  q: quit
q

Here is your staff:
Category: waiter
Name: Apple
Employee ID: 222333
Panache rating: 8

Category: singer
Name: Orange
Employee ID: 555666
Vocal range: alto

Category: singing waiter
Name: Water
Employee ID: 888999
Vocal range: tenor
Panache rating: 9

Done.

第13章 输入/输出流的深入剖析
13.1 简介
13.2 流
13.3 输出流
13.4 输入流
13.5 使用read，write和gcount的非格式化的I/O
13.6 流操作符简介
13.7 流的格式状态和流操作符
13.8 流的错误状态
13.9 将输出流连接到输入流
13.10 本章小结
ch13_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Store
{
private:
    std::ofstream *pfout;
public:
    Store(std::ofstream &fout)
    {
        pfout = &fout;
    }
    ~Store() {}
    Store &operator()(const std::string &str)
    {
        size_t len = str.length();
        pfout->write((char *)&len, sizeof(size_t));
        pfout->write(str.data(), len);
        return *this;
    }
};


void ShowStr(const std::string &str)
{
    std::cout << str << std::endl;
}

void GetStrs(std::ifstream &fin, std::vector<std::string> &vistr)
{
    size_t len = 0;
    std::string str;
    char ch;
    fin.peek();
    while (!fin.eof())
    {
        fin.read((char *)&len, sizeof(size_t));
        for (size_t i = 0; i < len; i++)
        {
            fin.read(&ch, sizeof(char));
            str.push_back(ch);
        }
        vistr.push_back(str);
        str.clear();
        fin.peek();
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        std::vector<std::string> vostr;
        std::string temp;

        std::cout << "Enter strings (empty line to quit) :\n";
        while (std::getline(std::cin, temp, '\n') && temp[0] != '\0')
        {
            vostr.push_back(temp);
        }

        std::cout << "Here is your input. \n";
        for_each(vostr.begin(), vostr.end(), ShowStr);

        std::ofstream fout("strings.dat", std::ios_base::out | std::ios_base::binary);
        for_each(vostr.begin(), vostr.end(), Store(fout));
        fout.close();

        std::vector<std::string> vistr;
        std::ifstream fin("strings.dat", std::ios_base::in | std::ios_base::binary);
        if (!fin.is_open())
        {
            std::cerr << "Could not open file for input. \n";
            exit(EXIT_FAILURE);
        }
        GetStrs(fin, vistr);
        std::cout << "\nHere are the strings read from the file:\n";

        for_each(vistr.begin(), vistr.end(), ShowStr);

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter strings (empty line to quit) :
Hello World
Peter Smith
Mike Pence
Apple Water
Sun Flower

Here is your input.
Hello World
Peter Smith
Mike Pence
Apple Water
Sun Flower

Here are the strings read from the file:
Hello World
Peter Smith
Mike Pence
Apple Water
Sun Flower

ch13_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

const int LIM = 20;

struct planet
{
    char name[LIM];
    double population;
    double g;
};

const char *file = "planets.dat";

inline void eatline()
{
    while (std::cin.get() != '\n') continue;
}

int main(int argc, const char *argv[])
{
    try
    {
        planet pl;
        cout << fixed << right;

        ifstream fin;
        fin.open(file, ios_base::in | ios_base::binary);
        if (fin.is_open())
        {
            cout << "Here are the current contents of the "
                 << file << " file:\n";
            while (fin.read((char *)&pl, sizeof pl))
            {
                cout << setw(20) << pl.name << ": "
                     << setprecision(0) << setw(12) << pl.population
                     << setprecision(2) << setw(6) << pl.g << endl;
            }
            fin.close();
        }

        ofstream fout(file, ios_base::out | ios_base::app | ios_base::binary);
        if (!fout.is_open())
        {
            cerr << "Can't open " << file << " file for output:\n";
            exit(EXIT_FAILURE);
        }

        cout << "Enter planet name (enter a blank line to quit):\n";
        cin.get(pl.name, 20);
        while (pl.name[0] != '\0')
        {
            eatline();
            cout << "Enter planetary population: ";
            cin >> pl.population;
            cout << "Enter planet's acceleration of gravity: ";
            cin >> pl.g;
            eatline();
            fout.write((char *)&pl, sizeof pl);
            cout << "Enter planet name (enter a blank line to quit):\n";
            cin.get(pl.name, 20);
        }
        fout.close();

        fin.clear();
        fin.open(file, ios_base::in | ios_base::binary);
        if (fin.is_open())
        {
            cout << "Here are the new contents of the "
                 << file << " file:\n";
            while (fin.read((char *)&pl, sizeof pl))
            {
                cout << setw(20) << pl.name << ": "
                     << setprecision(0) << setw(12) << pl.population
                     << setprecision(2) << setw(6) << pl.g << endl;
            }
            fin.close();
        }
        cout << "Done.\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter planet name (enter a blank line to quit):
Peter Smith
Enter planetary population: 120
Enter planet's acceleration of gravity: 7.15
Enter planet name (enter a blank line to quit):
Mike Pence
Enter planetary population: 221
Enter planet's acceleration of gravity: 8.1
Enter planet name (enter a blank line to quit):
Hello World
Enter planetary population: 188
Enter planet's acceleration of gravity: 7.8
Enter planet name (enter a blank line to quit):

Here are the new contents of the planets.dat file:
         Peter Smith:          120  7.15
          Mike Pence:          221  8.10
         Hello World:          188  7.80
Done.

ch13_p02
Here are the current contents of the planets.dat file:
         Peter Smith:          120  7.15
          Mike Pence:          221  8.10
         Hello World:          188  7.80
Enter planet name (enter a blank line to quit):
Apple Water
Enter planetary population: 166
Enter planet's acceleration of gravity: 7.5
Enter planet name (enter a blank line to quit):
Sun Flower
Enter planetary population: 181
Enter planet's acceleration of gravity: 7.9
Enter planet name (enter a blank line to quit):

Here are the new contents of the planets.dat file:
         Peter Smith:          120  7.15
          Mike Pence:          221  8.10
         Hello World:          188  7.80
         Apple Water:          166  7.50
          Sun Flower:          181  7.90
Done.

ch13_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

const int LIM = 20;

struct planet
{
    char name[LIM];
    double population;
    double g;
};

const char *file = "planets.dat";

inline void eatline()
{
    while (std::cin.get() != '\n') continue;
}

int main(int argc, const char *argv[])
{
    try
    {
        planet pl;
        cout << fixed;

        fstream finout;
        finout.open(file, ios_base::in | ios_base::out | ios_base::binary);
        int ct = 0;
        if (finout.is_open())
        {
            finout.seekg(0);
            cout << "Here are the current contents of the "
                 << file << " file:\n";
            while (finout.read((char *)&pl, sizeof pl))
            {
                cout << ct++ << ": " << setw(LIM) << pl.name << ": "
                     << setprecision(0) << setw(12) << pl.population
                     << setprecision(2) << setw(6) << pl.g << endl;
            }
            if (finout.eof())
            {
                finout.clear();
            }
            else
            {
                cerr << "Error in reading " << file << ".\n";
                exit(EXIT_FAILURE);
            }
        }
        else
        {
            cerr << file << " could not be opened -- bye.\n";
            exit(EXIT_FAILURE);
        }

        cout << "Enter the record number you wish to change: ";
        long rec;
        cin >> rec;
        eatline();
        if (rec < 0 || rec >= ct)
        {
            cerr << "Invalid record number -- bye\n";
            exit(EXIT_FAILURE);
        }
        streampos place = rec * sizeof pl;
        finout.seekg(place);
        if (finout.fail())
        {
            cerr << "Error on attempted seek\n";
            exit(EXIT_FAILURE);
        }

        finout.read((char *)&pl, sizeof pl);
        cout << "Your selection:\n";
        cout << rec << ": " << setw(LIM) << pl.name << ": "
             << setprecision(0) << setw(12) << pl.population
             << setprecision(2) << setw(6) << pl.g << endl;
        if (finout.eof())
        {
            finout.clear();
        }

        cout << "Enter planet name: ";
        cin.get(pl.name, LIM);
        eatline();
        cout << "Enter planetary population: ";
        cin >> pl.population;
        cout << "Enter planet's acceleration of gravity: ";
        cin >> pl.g;
        eatline();
        finout.seekp(place);
        finout.write((char *)&pl, sizeof pl) << flush;
        if (finout.fail())
        {
            cerr << "Error on attempted write\n";
            exit(EXIT_FAILURE);
        }

        ct = 0;
        finout.seekg(0);
        cout << "Here are the new contents of the " << file
             << " file:\n";
        while (finout.read((char *)&pl, sizeof pl))
        {
            cout << ct++ << ": " << setw(LIM) << pl.name << ": "
                 << setprecision(0) << setw(12) << pl.population
                 << setprecision(2) << setw(6) << pl.g << endl;
        }
        finout.close();
        cout << "Done.\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Here are the current contents of the planets.dat file:
0:          Peter Smith:          120  7.15
1:           Mike Pence:          221  8.10
2:          Hello World:          188  7.80
3:          Apple Water:          166  7.50
4:           Sun Flower:          181  7.90
Enter the record number you wish to change: 3
Your selection:
3:          Apple Water:          166  7.50
Enter planet name: Apple Cake
Enter planetary population: 182
Enter planet's acceleration of gravity: 7.68
Here are the new contents of the planets.dat file:
0:          Peter Smith:          120  7.15
1:           Mike Pence:          221  8.10
2:          Hello World:          188  7.80
3:           Apple Cake:          182  7.68
4:           Sun Flower:          181  7.90
Done.

ch13_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int main(int argc, const char *argv[])
{
    try
    {
        ostringstream outstr;

        string hdisk;
        cout << "What's the name of your hard disk? ";
        std::getline(cin, hdisk, '\n');
        int cap;
        cout << "What's its capacity in GB? ";
        cin >> cap;
        outstr << "The hard disk " << hdisk << " has a capacity of "
               << cap << " gigabytes.\n";
        cout << outstr.str();

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
What's the name of your hard disk? Hello World
What's its capacity in GB? 256
The hard disk Hello World has a capacity of 256 gigabytes.

ch13_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int main(int argc, const char *argv[])
{
    try
    {
        string lit = "It was a dark and stormy day, and "
                     " the full moon glowed brilliantly. ";
        istringstream instr(lit);
        string word;
        while (instr >> word)
        {
            cout << word << endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
It
was
a
dark
and
stormy
day,
and
the
full
moon
glowed
brilliantly.

ch13_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

const char *file = "guests.txt";

int main(int argc, const char *argv[])
{
    try
    {
        char ch;

        ifstream fin;
        fin.open(file);

        if (fin.is_open())
        {
            cout << "Here are the current contents of the "
                 << file << " file:\n";
            while (fin.get(ch))
            {
                cout << ch;
            }
            fin.close();
        }

        ofstream fout(file, std::ios::out | std::ios::app);
        if (!fout.is_open())
        {
            cerr << "Can't open " << file << " file for output.\n";
            exit(EXIT_FAILURE);
        }

        cout << "Enter guest names (enter a blank line to quit):\n";
        string name;
        while (std::getline(cin, name, '\n') && name.size() > 0)
        {
            fout << name << endl;
        }
        fout.close();

        fin.clear();
        fin.open(file);
        if (fin.is_open())
        {
            cout << "Here are the new contents of the "
                 << file << " file:\n";
            while (fin.get(ch))
            {
                cout << ch;
            }
            fin.close();
        }
        cout << "Done.\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter guest names (enter a blank line to quit):
Mike Pence
Peter Smith
Hello World

Here are the new contents of the guests.txt file:
Mike Pence
Peter Smith
Hello World
Done.

ch13_p06
Here are the current contents of the guests.txt file:
Mike Pence
Peter Smith
Hello World
Enter guest names (enter a blank line to quit):
Apple Water
Sun Flower

Here are the new contents of the guests.txt file:
Mike Pence
Peter Smith
Hello World
Apple Water
Sun Flower
Done.

cat guests.txt
Mike Pence
Peter Smith
Hello World
Apple Water
Sun Flower

ch13_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int main(int argc, const char *argv[])
{
    try
    {
        int character;

        std::cout << "Before input, cin.eof() is " << std::cin.eof() << std::endl
                  << "Enter a sentence followed by end-of-file:" << std::endl;

        while ((character = std::cin.get()) != EOF)
        {
            std::cout.put(character);
        }

        std::cout << "\nEOF in this system is: " << character << std::endl;
        std::cout << "After input of EOF, cin.eof() is " << std::cin.eof()
                  << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Before input, cin.eof() is 0
Enter a sentence followed by end-of-file:
Hello, World!
Hello, World!

EOF in this system is: -1
After input of EOF, cin.eof() is 1

ch13_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int main(int argc, const char *argv[])
{
    try
    {
        const int SIZE = 80;
        char buffer[SIZE];

        std::cout << "Enter a sentence:" << std::endl;
        std::cin.read(buffer, 20);

        std::cout << std::endl;
        std::cout << "The sentence entered was:" << std::endl;
        std::cout.write(buffer, std::cin.gcount());
        std::cout << std::endl;

        std::istringstream stream("Hello, World!");

        stream.read(buffer, 20);
        buffer[stream.gcount()] = '\0';

        std::cout << "Characters extracted: " << stream.gcount() << endl;
        cout << buffer << endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter a sentence:
Mike Pence Peter Smith

The sentence entered was:
Mike Pence Peter Smi
Characters extracted: 13
Hello, World!

ch13_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

std::ostream &tab(std::ostream &output)
{
    return output << '\t';
}

std::ostream &endLine(std::ostream &output)
{
    return output << '\n' << std::flush;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::cout << "Testing the tab manipulator:" << endLine << 'a' << tab << 'b'
                  << tab << 'c' << endLine;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Testing the tab manipulator:
a       b       c


第14章 文件处理
14.1 简介
14.2 文件和流
14.3 创建顺序文件
14.4 从顺序文件读取数据
14.5 更新顺序文件
14.6 随机存取文件
14.7 创建随机存取文件
14.8 向随机存取文件随机写入数据
14.9 从随机存取文件顺序读取数据
14.10 实例研究：事务处理程序
14.11 对象序列化
14.12 本章小结
ch14_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int main(int argc, const char *argv[])
{
    try
    {
        fstream file ( "highscores.txt", std::ios::in | std::ios::out );
        if ( ! file.is_open() )
        {
            cout << "Could not open file!" << '\n';
            return 0;
        }
        int new_high_score;
        cout << "Enter a new high score: ";
        cin >> new_high_score;

        streampos pre_score_pos = file.tellg();
        int cur_score;
        while ( file >> cur_score )
        {
            if ( cur_score < new_high_score )
            {
                break;
            }
            pre_score_pos = file.tellg();
        }

        if ( ! file.eof() && file.fail()  )
        {
            cout << "Bad score, could not read, exit\n";
            return 0;
        }

        file.clear();

        file.seekg( pre_score_pos );

        vector<int> scores;
        while ( file >> cur_score )
        {
            scores.push_back( cur_score );
        }
        if ( ! file.eof() && file.fail()  )
        {
            cout << "Bad score, could not read, exit\n";
            return 0;
        }

        file.clear();

        file.seekp( pre_score_pos );
        if ( pre_score_pos != 0 )
        {
            file << endl;
        }
        file << new_high_score << endl;
        for ( vector<int>::iterator itr = scores.begin(); itr != scores.end(); ++itr )
        {
            file << *itr << endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
cat highscores.txt
66
33
10
9
8
7
6
5
4
3
2
1
0
-66

ch14_p01
Enter a new high score: 36
ch14_p01
Enter a new high score: -36

cat highscores.txt
66
36
33
10
9
8
7
6
5
4
3
2
1
0
-36
-66

ch14_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

vector<int> readBinaryFile(string fileName)
{
    cout << "Opening binary file " << fileName << '\n';
    ifstream aFile(fileName + ".bin", ios::binary);
    if (!aFile.is_open())
    {
        cout << "Could not open file!" << '\n';
        vector<int> scoresEmpty;
        return scoresEmpty;
    }
    else
    {
        cout << "File is opened!\n";
    }

    cout << "Reading file...\n";

    int numberOfScores;
    if( !aFile.read( reinterpret_cast<char *>(&numberOfScores), sizeof(numberOfScores) ) )
    {
        cout << "Error reading from file." << endl;
        vector<int> scoresEmpty;
        return scoresEmpty;
    }

    vector<int> scores(numberOfScores);
    aFile.read( reinterpret_cast<char *>(&scores[0]), numberOfScores * sizeof(int) );

    return scores;
}

vector<int> readTextFile(string fileName)
{
    cout << "Opening text file " << fileName << '\n';
    ifstream fileReader(fileName + ".txt");
    if (!fileReader.is_open())
    {
        cout << "Could not open file!" << '\n';
        vector<int> scoresEmpty;
        return scoresEmpty;
    }
    else
    {
        cout << "File is opened!\n";
    }

    cout << "Reading file...\n";
    vector<int> scores;
    int score;
    while (fileReader >> score)
    {
        scores.push_back(score);
    }

    return scores;
}

int writeBinaryFile(string fileName, const vector<int> &scores)
{
    if (scores.size() <= 0)
    {
        cout << "Vector is empty.\n";
        return 0;
    }
    cout << "Writing file to binary format..." << '\n';
    ofstream aFile(fileName + ".bin", ios::trunc | ios::binary );
    if (!aFile.is_open())
    {
        cout << "Could not open file!" << '\n';
        return 1;
    }

    int numberOfScores = scores.size();
    if ( !aFile.write( reinterpret_cast<char *>(&numberOfScores), sizeof(numberOfScores) ) )
    {
        cout << "Error writing to file." << endl;
        return 1;
    }
    aFile.write( reinterpret_cast<const char *>(&scores[0]), numberOfScores * sizeof(int) );

    return 0;
}

int writeTextFile(string fileName, const vector<int> &scores)
{
    if (scores.size() <= 0)
    {
        cout << "Vector is empty.\n";
        return 0;
    }
    cout << "Writing file to text format..." << '\n';
    ofstream fileWriter(fileName + ".txt", ios::trunc);
    if (!fileWriter.is_open())
    {
        cout << "Could not open file!" << '\n';
        return 1;
    }

    for (vector<int>::const_iterator itr = scores.begin(), end = scores.end(); itr != end; ++itr)
    {
        fileWriter << *itr << '\n';
    }

    return 0;
}

int insertBinaryFile(string fileName)
{
    cout << "Inserting data into binary file..." << '\n';
    fstream aFile(fileName + ".bin", ios::binary | ios::out | ios::in);

    if (!aFile.is_open())
    {
        cout << "Could not open file!" << '\n';
        return 1;
    }

    int newHighScore;
    cout << "Enter a new high score: ";
    cin >> newHighScore;

    int numberOfScores;
    if ( !aFile.read( reinterpret_cast<char *>(&numberOfScores), sizeof(numberOfScores) ) )
    {
        cout << "Error reading from file." << endl;
        return 1;
    }

    streampos preScorePosition = aFile.tellg();
    int currentScore = 0;
    while ( aFile.read( reinterpret_cast<char *>(&currentScore), sizeof(currentScore) ) )
    {
        if (currentScore < newHighScore)
        {
            break;
        }
        preScorePosition = aFile.tellg();
    }

    if ( !aFile.eof() && aFile.fail() )
    {
        cout << "Bad score, could not read, exit.\n";
        return 1;
    }

    aFile.clear();

    aFile.seekg(preScorePosition);

    vector<int> scores;
    while ( aFile.read( reinterpret_cast<char *>(&currentScore), sizeof(currentScore) ) )
    {
        scores.push_back(currentScore);
    }

    if ( !aFile.eof() && aFile.fail() )
    {
        cout << "Bad score, could not read, exit.\n";
        return 1;
    }

    aFile.clear();

    aFile.seekp(preScorePosition);

    aFile.write( reinterpret_cast<char *>(&newHighScore), sizeof(newHighScore) );
    if (scores.size() > 0)
    {
        aFile.write( reinterpret_cast<char *>(&scores[0]), scores.size() * sizeof(int) );
    }

    numberOfScores++;
    aFile.seekp(0, ios_base::beg);
    if ( !aFile.write( reinterpret_cast<char *>(&numberOfScores), sizeof(numberOfScores) ) )
    {
        cout << "Error writing to file." << endl;
        return 1;
    }

    return 0;
}

void print(const vector<int> &scores)
{

    cout << "File contents are: \n";
    for (vector<int>::const_iterator itr = scores.begin(), end = scores.end(); itr != end; ++itr)
    {
        cout << *itr << '\n';
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        string fileName = "highScores";
        cout << "Writing base file " << fileName << '\n';
        vector<int> scores
        {
            1000,
            987,
            864,
            766,
            744,
            500,
            453,
            321,
            201,
            98,
            5
        };
        writeTextFile(fileName, scores);
        writeBinaryFile(fileName, scores);
        print(scores);

        if (insertBinaryFile(fileName) != 0)
        {
            cout << "Error inserting into binary file. Program will exit...\n";
            return 1;
        }

        vector<int> newScores = readBinaryFile(fileName);
        writeTextFile(fileName, newScores);
        print(newScores);

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Writing base file highScores
Writing file to text format...
Writing file to binary format...
File contents are:
1000
987
864
766
744
500
453
321
201
98
5
Inserting data into binary file...
Enter a new high score: 888
Opening binary file highScores
File is opened!
Reading file...
Writing file to text format...
File contents are:
1000
987
888
864
766
744
500
453
321
201
98
5

cat highScores.txt
1000
987
888
864
766
744
500
453
321
201
98
5

ch14_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

const string openTagStart = "<";
const string closeTagStart = "</";
const string tagEnd = ">";

string readHTMLFileAsStream(string fileName)
{
    string stream;

    cout << "Opening HTML file " << fileName << '\n';
    ifstream fileReader(fileName + ".html");
    if (!fileReader.is_open())
    {
        cout << "Could not open file!" << '\n';
        return stream;
    }
    else
    {
        cout << "File is opened!\n";
    }

    cout << "Reading file...\n";
    string line;
    while (getline(fileReader, line, '\n'))
    {
        stream += line;
    }

    return stream;
}

int writeHTMLFile(string fileName, const vector<string> &lines)
{
    cout << "Writing file to HTML format..." << '\n';
    ofstream fileWriter(fileName + ".html");
    if (!fileWriter.is_open())
    {
        cout << "Could not open file!" << '\n';
        return 1;
    }

    for (vector<string>::const_iterator itr = lines.begin(), end = lines.end(); itr != end; ++itr)
    {
        fileWriter << *itr << '\n';
    }
    return 0;
}

void print(const vector<string> &input)
{
    for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
    {
        cout << *itr << endl;
    }
    cout << '\n';
}

vector<string> mergeChildElements(const vector<string> &input, const string &tagName)
{
    string openingTag = openTagStart + tagName;
    string closingTag = closeTagStart + tagName + tagEnd;
    bool isInMergeRegion = false;

    vector<string> output;
    string currentMerge = "";
    for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
    {
        string itrOpening = itr->substr(0, openingTag.length());
        if (itrOpening == openingTag)
        {
            isInMergeRegion = true;
            output.push_back(*itr);
        }
        else if (isInMergeRegion && *itr == closingTag)
        {
            isInMergeRegion = false;
            if (currentMerge != "")
            {
                output.push_back(currentMerge);
            }
            output.push_back(*itr);
        }
        else if (isInMergeRegion)
        {
            currentMerge += *itr;
        }
        else
        {
            output.push_back(*itr);
        }
    }
    return output;
}

vector<string> parseHTMLStringToVector(const string &htmlDOMStream)
{
    bool isInOpenTag = false;
    bool isInCloseTag = false;

    vector<string> htmlDOM;
    string currentEntry = "";

    for (int i = 0; i < htmlDOMStream.length(); i++)
    {
        string currentLetter(1, htmlDOMStream[i]);

        string previousLetter = "";
        if (i - 1 >= 0)
        {
            previousLetter.push_back(htmlDOMStream[i - 1]);
        }

        string nextLetter = "";
        if (i + 1 < htmlDOMStream.length())
        {
            nextLetter.push_back(htmlDOMStream[i + 1]);
        }

        if (currentLetter + nextLetter == closeTagStart)
        {
            isInCloseTag = true;
            if (currentEntry != "")
            {
                htmlDOM.push_back(currentEntry);
            }
            currentEntry = htmlDOMStream[i];
        }
        else if(currentLetter == openTagStart)
        {
            isInOpenTag = true;
            if (currentEntry != "")
            {
                htmlDOM.push_back(currentEntry);
            }
            currentEntry = htmlDOMStream[i];
        }
        else if (isInOpenTag && previousLetter == tagEnd)
        {
            isInOpenTag = false;
            if (currentEntry != "")
            {
                htmlDOM.push_back(currentEntry);
            }
            currentEntry = htmlDOMStream[i];
        }
        else if (isInCloseTag && currentLetter == tagEnd)
        {
            isInCloseTag = false;
            currentEntry += htmlDOMStream[i];
            if (currentEntry != "")
            {
                htmlDOM.push_back(currentEntry);
            }
            currentEntry = "";
        }
        else
        {
            currentEntry += htmlDOMStream[i];
        }
    }
    return htmlDOM;
}

vector<string> stripTag(const vector<string> &input, const string &tagName)
{
    string openingTag = openTagStart + tagName;
    string closingTag = closeTagStart + tagName + tagEnd;
    bool isInStripRegion = false;

    vector<string> output;
    for(vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
    {
        string itrOpening = itr->substr(0, openingTag.length());
        if (!isInStripRegion && itrOpening == openingTag)
        {
            isInStripRegion = true;
        }
        else if (isInStripRegion && *itr == closingTag)
        {
            isInStripRegion = false;
        }
        else
        {
            output.push_back(*itr);
        }
    }
    return output;
}

vector<string> stripTagAttributes(const vector<string> &input, const string &tagName)
{
    string openingTag = openTagStart + tagName;

    vector<string> output;
    for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
    {
        string itrOpening = itr->substr(0, openingTag.length());
        if (itrOpening == openingTag)
        {
            output.push_back(openingTag + tagEnd);
        }
        else
        {
            output.push_back(*itr);
        }
    }
    return output;
}

vector<string> stripText(const vector<string> &input, const string &tagName)
{
    string openingTag = openTagStart + tagName;
    string closingTag = closeTagStart + tagName + tagEnd;
    bool isInStripRegion = false;

    vector<string> output;
    for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
    {
        string itrOpening = itr->substr(0, openingTag.length());
        if (!isInStripRegion && itrOpening == openingTag)
        {
            isInStripRegion = true;
            output.push_back(*itr);
        }
        else if (isInStripRegion && *itr == closingTag)
        {
            isInStripRegion = false;
            output.push_back(*itr);
        }
        else if (!isInStripRegion)
        {
            output.push_back(*itr);
        }
    }
    return output;
}

vector<string> substituteTag(const vector<string> &input, const string &tagName, const string &tagNameSubstitute)
{
    string openingTag = openTagStart + tagName + tagEnd;
    string closingTag = closeTagStart + tagName + tagEnd;

    vector<string> output;
    for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
    {
        if (*itr == openingTag || *itr == closingTag)
        {
            output.push_back(tagNameSubstitute);
        }
        else
        {
            output.push_back(*itr);
        }
    }
    return output;
}

string getLinkURL(const string &hrefTag)
{
    const string hyperlinkURL = "href=";
    int position = hrefTag.find(hyperlinkURL, 0) + hyperlinkURL.length();

    string linkURL = "";
    char endDemaractor;
    if (hrefTag[position] == '\"')
    {
        endDemaractor = '\"';
        position++;
    }
    else
    {
        endDemaractor = ' ';
    }

    for (int i = position; i < hrefTag.length(); i++)
    {
        if (hrefTag[i] == endDemaractor)
        {
            break;
        }
        linkURL += hrefTag[i];
    }
    return linkURL;
}

vector<string> formatBold(const vector<string> &input)
{
    return substituteTag(input, "b", "*");
}

vector<string> formatItalic(const vector<string> &input)
{
    return substituteTag(input, "i", "_");
}

vector<string> formatHyperlink(const vector<string> &input)
{
    const string hyperlink = "a";
    bool insidetag = false;

    string openingTag = openTagStart + hyperlink;
    string closingTag = closeTagStart + hyperlink + tagEnd;

    vector<string> output;
    for (vector<string>::const_iterator itr = input.begin(), end = input.end(); itr != end; ++itr)
    {
        string itrOpening = itr->substr(0, openingTag.length());
        if (itrOpening == openingTag)
        {
            insidetag = true;

            string linkURL = getLinkURL(*itr);

            vector<string>::const_iterator next = itr;
            ++next;
            string innerText = *next;

            output.push_back(innerText + "(" + linkURL + ")");
        }
        else if (*itr == closingTag)
        {
            insidetag = false;
        }
        else if (!insidetag)
        {
            output.push_back(*itr);
        }
    }
    return output;
}

int main(int argc, const char *argv[])
{
    try
    {
        string fileName = "sampleHTML";
        string htmlDOMStream = readHTMLFileAsStream(fileName);

        vector<string> htmlDOM = parseHTMLStringToVector(htmlDOMStream);
        const string body = "body";

        cout << "Original HTML: \n";
        vector<string> htmlDOMPrint = mergeChildElements(htmlDOM, body);
        print(htmlDOMPrint);

        const string html = "html";
        htmlDOM = stripTag(htmlDOM, html);

        const string head = "head";
        htmlDOM = stripText(htmlDOM, head);

        htmlDOM = stripTagAttributes(htmlDOM, body);
        htmlDOM = formatBold(htmlDOM);
        htmlDOM = formatItalic(htmlDOM);
        htmlDOM = formatHyperlink(htmlDOM);

        cout << "Parsed HTML:\n";
        htmlDOMPrint = mergeChildElements(htmlDOM, body);
        print(htmlDOMPrint);

        string newFileName = fileName + "_parsed";
        writeHTMLFile(newFileName, htmlDOMPrint);

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
cat sampleHTML.html
<html xmlns="http://www.w3.org/1999/xhtml" itemscope="" itemtype="http://schema.org/WebPage">
<head>
        <meta property="og : image" content="https ://lh3.googleusercontent.com/-mln6PaqJChw/UOIaqjWmkgI/AAAAAAABno0/sck_C8SCr-0/s240/DSCN6032a.jpg" ></meta>
        <script type="text / javascript">
                window.jstiming.load.tick('cl');
        </script>
</head>
<body xmlns="http://www.google.com/ns/jotspot" id="body" class=" en            ">
        This is an html text file that is parsed to handle text such as <b>bold text</b>, <i>italic text</i>, and even <a href="www.google.com">hyperlink text</a>.
  <br></br>
  Even new lines.
  <ul>
    <li>first item</li>
    <li>second item</li>
  </ul>
  <ol>
    <li>first item</li>
    <li>second item</li>
  </ol>
  Blah blah blah.
  <ol>
    <li>first item</li>
    <li>second item</li>
  </ol>
</body>
</html>

ch14_p03
Opening HTML file sampleHTML
File is opened!
Reading file...
Original HTML:
<html xmlns="http://www.w3.org/1999/xhtml" itemscope="" itemtype="http://schema.org/WebPage">
<head>

<meta property="og : image" content="https ://lh3.googleusercontent.com/-mln6PaqJChw/UOIaqjWmkgI/AAAAAAABno0/sck_C8SCr-0/s240/DSCN6032a.jpg" >
</meta>

<script type="text / javascript">
                window.jstiming.load.tick('cl');
</script>
</head>
<body xmlns="http://www.google.com/ns/jotspot" id="body" class=" en            ">
        This is an html text file that is parsed to handle text such as <b>bold text</b>, <i>italic text</i>, and even <a href="www.google.com">hyperlink text</a>.  <br></br>  Even new lines.  <ul>    <li>first item</li>    <li>second item</li>  </ul>  <ol>    <li>first item</li>    <li>second item</li>  </ol>  Blah blah blah.  <ol>    <li>first item</li>    <li>second item</li>  </ol>
</body>
</html>

Parsed HTML:
<head>
</head>
<body>
        This is an html text file that is parsed to handle text such as *bold text*, _italic text_, and even hyperlink text(www.google.com).  <br></br>  Even new lines.  <ul>    <li>first item</li>    <li>second item</li>  </ul>  <ol>    <li>first item</li>    <li>second item</li>  </ol>  Blah blah blah.  <ol>    <li>first item</li>    <li>second item</li>  </ol>
</body>

Writing file to HTML format...

cat sampleHTML_parsed.html
<head>
</head>
<body>
        This is an html text file that is parsed to handle text such as *bold text*, _italic text_, and even hyperlink text(www.google.com).  <br></br>  Even new lines.  <ul>    <li>first item</li>    <li>second item</li>  </ul>  <ol>    <li>first item</li>    <li>second item</li>  </ol>  Blah blah blah.  <ol>    <li>first item</li>    <li>second item</li>  </ol>
</body>

ch14_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class XmlNode
{
public:
    char TagOpen() const;
    char CloseTagStart() const;
    char TagClose() const;
    std::string Name() const;
    std::vector<std::string> Attributes();
    std::string AttributeValue(std::string attribute);
    std::string InnerText() const;
    int NumberOfChildren() const;
    XmlNode *Child(int index);

    XmlNode();
    XmlNode(char tagOpen, char tagClose, char nodeClose);
    ~XmlNode();

    static XmlNode *createNode(const std::string &input);
    void nodeStart(const std::string &input);
    std::string print(int level = 0, const std::string &spacer = "");
private:
    const std::string _spacer = "  ";

    char _tagOpen;
    char _closeTagStart;
    char _tagClose;
    std::string _name;
    std::map<std::string, std::string> _attributes;
    std::vector<XmlNode *> _children;
    std::string _innerText;

    void attributeRead(const std::string &attributesStream);
    void nodeTextRead(const std::string &innerText);
    std::string nodeEnd(const std::string &nameNode) const;
    static std::string clearEmpty(std::string &text);
};

char XmlNode::TagOpen() const
{
    return _tagOpen;
}

char XmlNode::CloseTagStart() const
{
    return _closeTagStart;
}

char XmlNode::TagClose() const
{
    return _tagClose;
}

string XmlNode::Name() const
{
    return _name;
}

vector<string> XmlNode::Attributes()
{
    vector<string> attributeKeys;
    for (map<string, string>::iterator itr = _attributes.begin(), end = _attributes.end(); itr != end; ++itr)
    {
        attributeKeys.push_back(itr->first);
    }
    return attributeKeys;
}

string XmlNode::AttributeValue(string attribute)
{
    return _attributes[attribute];
}

string XmlNode::InnerText() const
{
    return _innerText;
}

int XmlNode::NumberOfChildren() const
{
    return _children.size();
}

XmlNode *XmlNode::Child(int index)
{
    return _children[index];
}

XmlNode::XmlNode()
{
    _tagOpen = '<';
    _closeTagStart = '/';
    _tagClose = '>';
}

XmlNode::XmlNode(char tagOpen, char tagClose, char nodeClose)
{
    _tagOpen = tagOpen;
    _tagClose = tagClose;
    _closeTagStart = nodeClose;
}

XmlNode::~XmlNode()
{
    for (vector<XmlNode *>::iterator itr = _children.begin(), end = _children.end(); itr != end; ++itr)
    {
        delete *itr;
    }
    _children.clear();
}

XmlNode *XmlNode::createNode(const string &input)
{
    XmlNode *node = new XmlNode();
    node->nodeStart(input);
    return node;
}

void XmlNode::nodeStart(const string &input)
{
    int startTagOpenIndex = input.find_first_of(_tagOpen);
    int spaceIndex = input.find_first_of(' ', startTagOpenIndex);
    int startTagCloseIndex = input.find_first_of(_tagClose, startTagOpenIndex);
    if (spaceIndex != string::npos && spaceIndex < startTagCloseIndex)
    {
        _name = input.substr(startTagOpenIndex + 1, (spaceIndex - 1) - startTagOpenIndex);
        attributeRead(input.substr(spaceIndex + 1, (startTagCloseIndex - 1) - spaceIndex));
    }
    else
    {
        _name = input.substr(startTagOpenIndex + 1, (startTagCloseIndex - 1) - startTagOpenIndex);
    }

    string closeTag = nodeEnd(_name);
    int endTagOpenIndex = input.find_last_of(closeTag);
    string innerText = input.substr( startTagCloseIndex + 1, (endTagOpenIndex - 1) - startTagCloseIndex - ( closeTag.length() - 1 ) );
    nodeTextRead(innerText);
}

void XmlNode::attributeRead(const string &attributesStream)
{
    string currentKey = "";
    string currentEntry = "";
    bool isInValue = false;
    for (int i = 0; i < attributesStream.length(); i++)
    {
        if (attributesStream[i] == '=')
        {
            currentKey = currentEntry;
            currentEntry.clear();
        }
        else if (attributesStream[i] == '"' && !isInValue)
        {
            isInValue = true;
        }
        else if (attributesStream[i] == '"' && isInValue)
        {
            isInValue = false;
            currentEntry = clearEmpty(currentEntry);
            _attributes[currentKey] = currentEntry;
            currentKey.clear();
            currentEntry.clear();
        }
        else if (attributesStream[i] != '=' &&
                 attributesStream[i] != '"' &&
                 !(attributesStream[i] == ' ' && !isInValue))
        {
            currentEntry += attributesStream[i];
        }
    }
}

void XmlNode::nodeTextRead(const string &innerText)
{
    int startTagOpenIndex = innerText.find_first_of(_tagOpen);
    if (startTagOpenIndex == string::npos)
    {
        _innerText = innerText;
        _innerText = clearEmpty(_innerText);
        return;
    }

    _innerText += innerText.substr(0, startTagOpenIndex);
    int openTagCount = 0;
    int tagCount = 0;
    string innerInnerText;
    for (int i = startTagOpenIndex; i < innerText.length(); i++)
    {
        char currentCharacter = innerText[i];
        if (currentCharacter == _tagOpen)
        {
            tagCount++;
            if ( (i + 1) < innerText.length() && innerText[i + 1] == _closeTagStart)
            {
                openTagCount--;
            }
            else
            {
                openTagCount++;
            }
        }
        else if (currentCharacter == _tagClose)
        {
            tagCount--;
        }

        if (openTagCount == 0 && tagCount == 0 && currentCharacter != _tagClose)
        {
            _innerText.push_back(currentCharacter);
        }
        else
        {
            innerInnerText.push_back(currentCharacter);
        }

        if (currentCharacter == _tagClose && openTagCount == 0)
        {
            _children.push_back(createNode(innerInnerText));
            innerInnerText.clear();
        }
    }
    _innerText = clearEmpty(_innerText);
}


string XmlNode::nodeEnd(const string &nameNode) const
{
    string nodeEndTag;
    nodeEndTag.push_back(_tagOpen);
    nodeEndTag.push_back(_closeTagStart);
    return (nodeEndTag + nameNode + _tagClose);
}

string XmlNode::print(int level, const string &spacer)
{
    string tabs = "";
    string currentSpacer;
    spacer.empty() ? currentSpacer = _spacer : currentSpacer = spacer;
    for (int i = 0; i < level; i++)
    {
        tabs += currentSpacer;
    }
    string currentNode = tabs;

    currentNode.push_back(_tagOpen);
    currentNode += _name;
    vector<string> attributes = Attributes();
    for (vector<string>::iterator itr = attributes.begin(), end = attributes.end(); itr != end; ++itr)
    {
        currentNode += " " + *itr + "=\"" + _attributes[*itr] + "\"";
    }
    currentNode += _tagClose;

    if (!_innerText.empty())
    {
        currentNode += '\n' + tabs + currentSpacer;
        currentNode += _innerText;
    }

    int children = NumberOfChildren();
    for (int i = 0; i < children; i++)
    {
        currentNode += '\n';
        currentNode += _children[i]->print(level + 1);
    }

    currentNode += '\n' + tabs;
    currentNode += nodeEnd(_name);

    return currentNode;
}

string XmlNode::clearEmpty(string &text)
{
    if (text.find_first_not_of(' ') == string::npos)
    {
        return "";
    }
    return text;
}

string readXMLFileAsStream(string &fileName)
{
    cout << "Opening XML file " << fileName << '\n';
    ifstream fileReader(fileName + ".xml");
    if (!fileReader.is_open())
    {
        cout << "Could not open file!" << '\n';
        return "";
    }
    cout << "File is opened!\n";

    cout << "Reading file...\n";
    string stream;
    string line;
    while (getline(fileReader, line, '\n'))
    {
        stream += line;
    }

    return stream;
}

int main(int argc, const char *argv[])
{
    try
    {
        string xmlToString;
        string xmlDOMStream;
        string fileName;
        XmlNode *root;
        vector<string> fileNames =
        {
            "addresses",
            "books",
            "attributesSample"
        };

        for(vector<string>::iterator itr = fileNames.begin(), end = fileNames.end(); itr != end; ++itr)
        {
            cout << "Reading & parsing " << *itr << ".xml\n";
            xmlDOMStream = readXMLFileAsStream(*itr);
            if (!xmlDOMStream.empty())
            {
                root = XmlNode::createNode(xmlDOMStream);
                cout << "Printing XML object...\n\n";
                xmlToString = root->print();
                cout << xmlToString;
                delete root;
            }
            cout << "\n\n";
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Reading & parsing addresses.xml
Opening XML file addresses
File is opened!
Reading file...
Printing XML object...

<address-book>
  <entry>
    <name>
      Alex Allain
    </name>
    <email>
      webmaster@cprogramming.com
    </email>
  </entry>
  <entry>
    <name>
      Joe Doe
    </name>
    <email>
      john@doe.com
    </email>
  </entry>
</address-book>

Reading & parsing books.xml
Opening XML file books
File is opened!
Reading file...
Printing XML object...

<html>
  <head>
    <title>
      Doc title
    </title>
  </head>
  <body>
    This is a nice  to a website.
    <a href="http://www.cprogramming.com">
      link
    </a>
  </body>
</html>

Reading & parsing attributesSample.xml
Opening XML file attributesSample
File is opened!
Reading file...
Printing XML object...

<model documentation_status="not applicable" is_bug="no" is_public="yes" status="done" xmlns="http://www.csiberkeley.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.csiberkeley.com http://www.csiamerica.com/sites/default/files/schemas/model_database_model_V0_4.xsd">
  <id>
    387
  </id>
  <id_secondary>
  </id_secondary>
  <title>
    Template - Steel Deck
  </title>
  <path type="relative">
        models\0387.edb
    <database_file_name attribute1="value with spaces" attribute_2="valueWithoutSpaces">
      <another_child>
      </another_child>
    </database_file_name>
  </path>
</model>

 cat addresses.xml
<address-book>
  <entry>
    <name>Alex Allain</name>
    <email>webmaster@cprogramming.com</email>
  </entry>
  <entry>
    <name>Joe Doe</name>
    <email>john@doe.com</email>
  </entry>
</address-book>

cat books.xml
<html>
  <head>
    <title>Doc title</title>
  </head>
  <body>This is a nice <a href="http://www.cprogramming.com">link</a> to a website.</body>
</html>

cat attributesSample.xml
<model is_public="yes" is_bug="no" status="done" xmlns="http://www.csiberkeley.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.csiberkeley.com http://www.csiamerica.com/sites/default/files/schemas/model_database_model_V0_4.xsd" documentation_status="not applicable">
  <id  >387</id   >
  <id_secondary>
  </id_secondary>
  <title>Template - Steel Deck</title>
  <path type="relative">
    models\0387.edb
      <database_file_name attribute1="value with spaces" attribute_2="valueWithoutSpaces">
        <another_child>
        </another_child>
      </database_file_name>
  </path>
</model>

ch14_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class XmlNode
{
public:
    char TagOpen() const;
    char CloseTagStart() const;
    char TagClose() const;
    std::string Name() const;
    std::vector<std::string> Attributes();
    std::string AttributeValue(std::string attribute);
    std::string InnerText() const;
    int NumberOfChildren() const;
    XmlNode *Child(int index);

    XmlNode();
    XmlNode(const std::string &input);
    XmlNode(char tagOpen, char tagClose, char nodeClose);
    virtual ~XmlNode();

    static XmlNode *createNode(const std::string &input);
    void nodeStart(const std::string &input);
    virtual std::string print(XmlNode *node, int indentLevel = 0, const std::string &spacer = "");
protected:
    const std::string _spacer = "  ";
    const std::string _textNode = "#text";

    virtual std::string printOpeningTag(XmlNode *node, const std::string &tabs = "");
    virtual std::string printClosingTag(XmlNode *node, const std::string &tabs = "");
    virtual std::string printInnerText(XmlNode *node, const std::string &tabs = "", const std::string &currentSpacer = "");
    virtual std::string printChildNodes(XmlNode *node, int childIndex, int indentLevel);

    std::string nodeEnd(const std::string &nameNode) const;
    std::string getTabs(int indentationLevel, const std::string &spacer = "") const;
private:
    char _tagOpen;
    char _closeTagStart;
    char _tagClose;
    std::string _name;
    std::map<std::string, std::string> _attributes;
    std::vector<XmlNode *> _children;
    std::string _innerText;

    static XmlNode *createTextNode(const std::string &input);
    void attributeRead(const std::string &attributesStream);
    void nodeTextRead(const std::string &innerText);
    static std::string clearEmpty(std::string &text);
};

char XmlNode::TagOpen() const
{
    return _tagOpen;
}

char XmlNode::CloseTagStart() const
{
    return _closeTagStart;
}

char XmlNode::TagClose() const
{
    return _tagClose;
}

string XmlNode::Name() const
{
    return _name;
}

vector<string> XmlNode::Attributes()
{
    vector<string> attributeKeys;
    for (map<string, string>::iterator itr = _attributes.begin(), end = _attributes.end(); itr != end; ++itr)
    {
        attributeKeys.push_back(itr->first);
    }
    return attributeKeys;
}

string XmlNode::AttributeValue(string attribute)
{
    return _attributes[attribute];
}

string XmlNode::InnerText() const
{
    return _innerText;
}

int XmlNode::NumberOfChildren() const
{
    return _children.size();
}

XmlNode *XmlNode::Child(int index)
{
    return _children[index];
}

XmlNode::XmlNode()
{
    _tagOpen = '<';
    _closeTagStart = '/';
    _tagClose = '>';
}

XmlNode::XmlNode(const string &input) : XmlNode()
{
    _name = _textNode;
    _innerText = input;
}

XmlNode::XmlNode(char tagOpen, char tagClose, char nodeClose)
{
    _tagOpen = tagOpen;
    _tagClose = tagClose;
    _closeTagStart = nodeClose;
}

XmlNode::~XmlNode()
{
    for (vector<XmlNode *>::iterator itr = _children.begin(), end = _children.end(); itr != end; ++itr)
    {
        delete *itr;
    }
    _children.clear();
}

XmlNode *XmlNode::createNode(const string &input)
{
    XmlNode *node = new XmlNode();
    node->nodeStart(input);
    return node;
}

XmlNode *XmlNode::createTextNode(const string &input)
{
    XmlNode *node = new XmlNode(input);
    return node;
}

void XmlNode::nodeStart(const string &input)
{
    int startTagOpenIndex = input.find_first_of(_tagOpen);
    int spaceIndex = input.find_first_of(' ', startTagOpenIndex);
    int startTagCloseIndex = input.find_first_of(_tagClose, startTagOpenIndex);
    if (spaceIndex != string::npos && spaceIndex < startTagCloseIndex)
    {
        _name = input.substr(startTagOpenIndex + 1, (spaceIndex - 1) - startTagOpenIndex);
        attributeRead(input.substr(spaceIndex + 1, (startTagCloseIndex - 1) - spaceIndex));
    }
    else
    {
        _name = input.substr(startTagOpenIndex + 1, (startTagCloseIndex - 1) - startTagOpenIndex);
    }

    string closeTag = nodeEnd(_name);
    int endTagOpenIndex = input.find_last_of(closeTag);
    string innerText = input.substr( startTagCloseIndex + 1, (endTagOpenIndex - 1) - startTagCloseIndex - ( closeTag.length() - 1 ) );
    nodeTextRead(innerText);
}

void XmlNode::attributeRead(const string &attributesStream)
{
    string currentKey = "";
    string currentEntry = "";
    bool isInValue = false;
    for (int i = 0; i < attributesStream.length(); i++)
    {
        if (attributesStream[i] == '=')
        {
            currentKey = currentEntry;
            currentEntry.clear();
        }
        else if (attributesStream[i] == '"' && !isInValue)
        {
            isInValue = true;
        }
        else if (attributesStream[i] == '"' && isInValue)
        {
            isInValue = false;
            currentEntry = clearEmpty(currentEntry);
            _attributes[currentKey] = currentEntry;
            currentKey.clear();
            currentEntry.clear();
        }
        else if (attributesStream[i] != '=' &&
                 attributesStream[i] != '"' &&
                 !(attributesStream[i] == ' ' && !isInValue))
        {
            currentEntry += attributesStream[i];
        }
    }
}

void XmlNode::nodeTextRead(const string &innerText)
{
    if (innerText.empty())
    {
        return;
    }
    int startTagOpenIndex = innerText.find_first_of(_tagOpen);
    if (startTagOpenIndex == string::npos)
    {
        _innerText = innerText;
        _innerText = clearEmpty(_innerText);
        return;
    }

    if (startTagOpenIndex > 0)
    {
        _innerText += innerText.substr(0, startTagOpenIndex);
    }

    int openTagCount = 0;
    int tagCount = 0;
    string innerInnerText;
    for (int i = startTagOpenIndex; i < innerText.length(); i++)
    {
        char currentCharacter = innerText[i];
        if (currentCharacter == _tagOpen)
        {
            if (openTagCount == 0 && !_innerText.empty())
            {
                _innerText = clearEmpty(_innerText);
                if (!_innerText.empty())
                {
                    _children.push_back(createTextNode(_innerText));
                    _innerText.clear();
                }
            }
            tagCount++;
            if ( (i + 1) < innerText.length() && innerText[i + 1] == _closeTagStart)
            {
                openTagCount--;
            }
            else
            {
                openTagCount++;
            }
        }
        else if (currentCharacter == _tagClose)
        {
            tagCount--;
        }

        if (openTagCount == 0 && tagCount == 0 && currentCharacter != _tagClose)
        {
            _innerText.push_back(currentCharacter);
            if ( (i + 1) >= innerText.length() && !_innerText.empty() )
            {
                _innerText = clearEmpty(_innerText);
                if (!_innerText.empty())
                {
                    _children.push_back(createTextNode(_innerText));
                    _innerText.clear();
                }
            }
        }
        else
        {
            innerInnerText.push_back(currentCharacter);
        }

        if (currentCharacter == _tagClose && openTagCount == 0)
        {
            _children.push_back(createNode(innerInnerText));
            innerInnerText.clear();
        }
    }
    _innerText = clearEmpty(_innerText);
}


string XmlNode::nodeEnd(const string &nameNode) const
{
    string nodeEndTag;
    nodeEndTag.push_back(_tagOpen);
    nodeEndTag.push_back(_closeTagStart);
    return (nodeEndTag + nameNode + _tagClose);
}

string XmlNode::getTabs(int indentationLevel, const string &spacer) const
{
    string tabs = "";
    string currentSpacer;
    spacer.empty() ? currentSpacer = _spacer : currentSpacer = spacer;
    for (int i = 0; i < indentationLevel; i++)
    {
        tabs += currentSpacer;
    }
    return tabs;
}

string XmlNode::printOpeningTag(XmlNode *node, const string &tabs)
{
    string currentNode = tabs;
    currentNode.push_back(_tagOpen);
    currentNode += node->Name();
    vector<string> attributes = node->Attributes();
    for (vector<string>::iterator itr = attributes.begin(), end = attributes.end(); itr != end; ++itr)
    {
        currentNode += " " + *itr + "=\"" + node->AttributeValue(*itr) + "\"";
    }
    currentNode += _tagClose;
    return currentNode;
}

string XmlNode::printInnerText(XmlNode *node, const string &tabs, const string &currentSpacer)
{
    string currentNode;
    if (!node->InnerText().empty())
    {
        currentNode += '\n' + tabs + currentSpacer;
        currentNode += node->InnerText();
    }
    return currentNode;
}

string XmlNode::printChildNodes(XmlNode *node, int childIndex, int indentLevel)
{
    string currentNode;
    currentNode += '\n';
    currentNode += print(node->Child(childIndex), indentLevel + 1);
    return currentNode;
}

string XmlNode::printClosingTag(XmlNode *node, const string &tabs)
{
    string currentNode = '\n' + tabs;
    currentNode += nodeEnd(node->Name());
    return  currentNode;
}

string XmlNode::print(XmlNode *node, int indentLevel, const string &spacer)
{
    string currentSpacer;
    spacer.empty() ? currentSpacer = _spacer : currentSpacer = spacer;
    string tabs = getTabs(indentLevel, currentSpacer);

    string currentNode = printOpeningTag(node, tabs);

    currentNode += printInnerText(node, tabs, currentSpacer);

    int children = node->NumberOfChildren();
    for (int i = 0; i < children; i++)
    {
        currentNode += printChildNodes(node, i, indentLevel);
    }

    currentNode += printClosingTag(node, tabs);

    return currentNode;
}

string XmlNode::clearEmpty(string &text)
{
    if (text.find_first_not_of(' ') == string::npos)
    {
        return "";
    }
    if (text.find_first_not_of('\t') == string::npos)
    {
        return "";
    }
    return text;
}

class HtmlPrinter : public XmlNode
{
public:
    HtmlPrinter(const std::string &XmlDOMStream);

    static HtmlPrinter *createNode(const std::string &input);
    std::string print(XmlNode *node, int indentLevel = 0, const std::string &spacer = "");
protected:
    std::string printOpeningTag(XmlNode *node, const std::string &tabs = "");
    std::string printClosingTag(XmlNode *node, const std::string &tabs = "");
    std::string printInnerText(XmlNode *node, const std::string &tabs = "", const std::string &currentSpacer = "");
    std::string printChildNodes(XmlNode *node, int childIndex, int indentLevel);
};

HtmlPrinter *HtmlPrinter::createNode(const string &XmlDOMStream)
{
    HtmlPrinter *node = new HtmlPrinter(XmlDOMStream);
    return node;
}

HtmlPrinter::HtmlPrinter(const string &XmlDOMStream)
{
    nodeStart(XmlDOMStream);
}

string HtmlPrinter::print(XmlNode *node, int indentLevel, const string &spacer)
{
    string currentSpacer;
    spacer.empty() ? currentSpacer = _spacer : currentSpacer = spacer;
    string tabs = getTabs(indentLevel, currentSpacer);

    string currentNode = printOpeningTag(node, tabs);

    currentNode += printInnerText(node, tabs, currentSpacer);

    int children = node->NumberOfChildren();
    for (int i = 0; i < children; i++)
    {
        currentNode += printChildNodes(node, i, indentLevel);
    }

    currentNode += printClosingTag(node, tabs);

    return currentNode;
}

string HtmlPrinter::printOpeningTag(XmlNode *node, const string &tabs)
{
    string currentNode;
    if (node->Name() == _textNode)
    {
        return "";
    }
    if (node->Name() == "html")
    {
        return "";
    }
    if (node->Name() == "br")
    {
        return "";
    }
    if (node->Name() == "a")
    {
        return "";
    }
    if (node->Name() == "ul")
    {
        return "\n";
    }
    if (node->Name() == "ol")
    {
        return "\n";
    }
    if (node->Name() == "li")
    {
        return "";
    }
    if (node->Name() == "b")
    {
        return "*";
    }
    if (node->Name() == "i")
    {
        return "_";
    }
    if (node->Name() == "body")
    {
        currentNode = "\n" + tabs;
        currentNode.push_back(TagOpen());
        currentNode += node->Name() + TagClose() + '\n';
        return currentNode;
    }
    return XmlNode::printOpeningTag(node, tabs);
}

string HtmlPrinter::printClosingTag(XmlNode *node, const string &tabs)
{
    if (node->Name() == _textNode)
    {
        return "";
    }
    if (node->Name() == "html")
    {
        return "";
    }
    if (node->Name() == "br")
    {
        return "";
    }
    if (node->Name() == "a")
    {
        return "";
    }
    if (node->Name() == "ul")
    {
        return "";
    }
    if (node->Name() == "ol")
    {
        return "";
    }
    if (node->Name() == "li")
    {
        return "";
    }
    if (node->Name() == "b")
    {
        return "*";
    }
    if (node->Name() == "i")
    {
        return "_";
    }
    return XmlNode::printClosingTag(node, tabs);
}

string HtmlPrinter::printInnerText(XmlNode *node, const string &tabs, const string &currentSpacer)
{
    if (node->Name() == _textNode)
    {
        return node->InnerText();
    }
    if (node->Name() == "head")
    {
        return "";
    }
    if (node->Name() == "br")
    {
        return "\n";
    }
    if (node->Name() == "b")
    {
        return node->InnerText();
    }
    if (node->Name() == "i")
    {
        return node->InnerText();
    }
    if (node->Name() == "ul")
    {
        return "";
    }
    if (node->Name() == "ol")
    {
        return "";
    }
    if (node->Name() == "li")
    {
        return node->InnerText() + '\n';
    }
    if (node->Name() == "a")
    {
        return node->InnerText() + '(' + node->AttributeValue("href") + ')';
    }
    return XmlNode::printInnerText(node, tabs, currentSpacer);
}

string HtmlPrinter::printChildNodes(XmlNode *node, int childIndex, int indentLevel)
{
    string currentNode;
    XmlNode *childNode = node->Child(childIndex);
    if (node->Name() == _textNode)
    {
        return "";
    }
    if (node->Name() == "html")
    {
        return print(childNode, indentLevel + 1);
    }
    if (node->Name() == "head")
    {
        return "";
    }
    if (node->Name() == "b")
    {
        return print(childNode);
    }
    if (node->Name() == "i")
    {
        return print(childNode);
    }
    if (node->Name() == "a")
    {
        return print(childNode);
    }
    if (node->Name() == "ul" && childNode->Name() == "li")
    {
        string tabs = getTabs(indentLevel, _spacer);
        currentNode += tabs;
        currentNode += "* ";
        currentNode += print(childNode, indentLevel + 1);
        return currentNode;
    }
    if (node->Name() == "ol" && childNode->Name() == "li")
    {
        string tabs = getTabs(indentLevel, _spacer);
        currentNode += tabs;
        currentNode += to_string(childIndex + 1) + ". ";
        currentNode += print(childNode, indentLevel + 1);
        return currentNode;
    }

    currentNode += print(childNode, indentLevel + 1);
    return currentNode;
}

string readFileAsStream(const string &fileName, const string &fileExtension)
{
    cout << "Opening '" << fileExtension << "' file " << fileName << '\n';
    ifstream fileReader(fileName + "." + fileExtension);
    if (!fileReader.is_open())
    {
        cout << "Could not open file!" << '\n';
        return "";
    }
    cout << "File is opened!\n";

    cout << "Reading file...\n";
    string stream;
    string line;
    while (getline(fileReader, line, '\n'))
    {
        stream += line;
    }

    return stream;
}

int writeToTextFile(const string &fileName, const string &content)
{
    cout << "Writing file to text format..." << '\n';
    ofstream fileWriter(fileName + ".txt");
    if (!fileWriter.is_open())
    {
        cout << "Could not open file!" << '\n';
        return 1;
    }

    fileWriter << content;
    return 0;
}

int main(int argc, const char *argv[])
{
    try
    {
        string XmlToString;
        string XmlDOMStream;
        HtmlPrinter *root;
        map<string, string> files;
        files["addresses"] = "xml";
        files["books"] = "xml";
        files["attributesSample"] = "xml";
        files["sampleHTML"] = "html";

        for (map<string, string>::iterator itr = files.begin(), end = files.end(); itr != end; ++itr)
        {
            string fileName = itr->first;
            string fileExtension = itr->second;
            cout << "Reading & parsing " << fileName << "." << fileExtension << "\n";
            XmlDOMStream = readFileAsStream(fileName, fileExtension);
            if (!XmlDOMStream.empty())
            {
                root = HtmlPrinter::createNode(XmlDOMStream);
                cout << "Printing XML object...\n\n";
                XmlToString = root->print(root);
                writeToTextFile(fileName + "_output", XmlToString);
                cout << XmlToString;
                delete root;
            }
            cout << "\n\n";
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Reading & parsing addresses.xml
Opening 'xml' file addresses
File is opened!
Reading file...
Printing XML object...

Writing file to text format...
<address-book>  <entry>    <name>
      Alex Allain
    </name>    <email>
      webmaster@cprogramming.com
    </email>
  </entry>  <entry>    <name>
      Joe Doe
    </name>    <email>
      john@doe.com
    </email>
  </entry>
</address-book>

Reading & parsing attributesSample.xml
Opening 'xml' file attributesSample
File is opened!
Reading file...
Printing XML object...

Writing file to text format...
<model documentation_status="not applicable" is_bug="no" is_public="yes" status="done" xmlns="http://www.csiberkeley.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.csiberkeley.com http://www.csiamerica.com/sites/default/files/schemas/model_database_model_V0_4.xsd">  <id>387
  </id>  <id_secondary>
  </id_secondary>  <title>
    Template - Steel Deck
  </title>  <path type="relative">    models\0387.edb          <database_file_name attribute1="value with spaces" attribute_2="valueWithoutSpaces">      <another_child>
      </another_child>
    </database_file_name>
  </path>
</model>

Reading & parsing books.xml
Opening 'xml' file books
File is opened!
Reading file...
Printing XML object...

Writing file to text format...
  <head>
  </head>
  <body>
This is a nice link(http://www.cprogramming.com) to a website.
  </body>

Reading & parsing sampleHTML.html
Opening 'html' file sampleHTML
File is opened!
Reading file...
Printing XML object...

Writing file to text format...
  <head>
  </head>
  <body>
        This is an html text file that is parsed to handle text such as *bold text*, _italic text_, and even hyperlink text(www.google.com).
  Even new lines.
    * first item
    * second item

    1. first item
    2. second item
  Blah blah blah.
    1. first item
    2. second item

  </body>

cat addresses.xml
<address-book>
  <entry>
    <name>Alex Allain</name>
    <email>webmaster@cprogramming.com</email>
  </entry>
  <entry>
    <name>Joe Doe</name>
    <email>john@doe.com</email>
  </entry>
</address-book>

cat books.xml
<html>
  <head>
    <title>Doc title</title>
  </head>
  <body>This is a nice <a href="http://www.cprogramming.com">link</a> to a website.</body>
</html>

cat attributesSample.xml
<model is_public="yes" is_bug="no" status="done" xmlns="http://www.csiberkeley.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.csiberkeley.com http://www.csiamerica.com/sites/default/files/schemas/model_database_model_V0_4.xsd" documentation_status="not applicable">
  <id  >387</id   >
  <id_secondary>
  </id_secondary>
  <title>Template - Steel Deck</title>
  <path type="relative">
    models\0387.edb
      <database_file_name attribute1="value with spaces" attribute_2="valueWithoutSpaces">
        <another_child>
        </another_child>
      </database_file_name>
  </path>
</model>

cat sampleHTML.html
<html xmlns="http://www.w3.org/1999/xhtml" itemscope="" itemtype="http://schema.org/WebPage">
<head>
        <meta property="og : image" content="https ://lh3.googleusercontent.com/-mln6PaqJChw/UOIaqjWmkgI/AAAAAAABno0/sck_C8SCr-0/s240/DSCN6032a.jpg" ></meta>
        <script type="text / javascript">
                window.jstiming.load.tick('cl');
        </script>
</head>
<body xmlns="http://www.google.com/ns/jotspot" id="body" class=" en            ">
        This is an html text file that is parsed to handle text such as <b>bold text</b>, <i>italic text</i>, and even <a href="www.google.com">hyperlink text</a>.
  <br></br>
  Even new lines.
  <ul>
    <li>first item</li>
    <li>second item</li>
  </ul>
  <ol>
    <li>first item</li>
    <li>second item</li>
  </ol>
  Blah blah blah.
  <ol>
    <li>first item</li>
    <li>second item</li>
  </ol>
</body>
</html>


第15章 标准库的容器和迭代器
15.1 标准模板库（STL）简介
15.2 容器简介
15.3 迭代器简介
15.4 算法简介
15.5 序列容器
15.6 关联容器
15.7 容器适配器
15.8 bitset类
15.9 本章小结
ch15_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

const char let = 'L';
const char con = 'C';
const char quit = 'q';
const char help = 'h';
const char print = ';';
const char number = '8';
const char name = 'a';
const char square_root = 's';
const char power = 'p';
const string declkey = "let";
const string conkey = "const";
const string sqrtkey = "sqrt";
const string powkey = "pow";
const string quitkey = "quit";
const string helpkey = "help";
const string prompt = "> ";
const string result = "= ";

class Token
{
public:
    char kind;
    double value;
    string name;
    Token(char ch) : kind(ch), value(0) { }
    Token(char ch, double val) : kind(ch), value(val) { }
    Token(char ch, string n) : kind(ch), value(0), name(n) { }
};

class Token_stream
{
public:
    Token_stream();
    Token_stream(istream &is);
    Token_stream(istream &is, ostream &os);
    Token get();
    void putback(Token t);
    void ignore(char c);
    istream &get_istream();
    void set_istream(istream &is);
    ostream &get_ostream();
    void set_ostream(ostream &os);
private:
    bool full;
    Token buffer;
    istream *is_ptr;
    ostream *os_ptr;
};

Token_stream::Token_stream() : full(false), buffer(0), is_ptr(&cin), os_ptr(&cout) { }
Token_stream::Token_stream(istream &is) : full(false), buffer(0), is_ptr(&is), os_ptr(&cout) { }
Token_stream::Token_stream(istream &is, ostream &os) : full(false), buffer(0), is_ptr(&is), os_ptr(&os) { }
istream   &Token_stream::get_istream()
{
    return (*is_ptr);
}
void   Token_stream::set_istream(istream &is)
{
    is_ptr = &is;
}
ostream   &Token_stream::get_ostream()
{
    return (*os_ptr);
}
void   Token_stream::set_ostream(ostream &os)
{
    os_ptr = &os;
}
void Token_stream::putback(Token t)
{
    if (full)
    {
        error("putback() into a full buffer");
    }
    buffer = t;
    full = true;
}

Token Token_stream::get()
{
    if (full)
    {
        full = false;
        return buffer;
    }

    char ch;
    (*is_ptr).get(ch);
    while (isspace(ch))
    {
        if (ch == '\n')
        {
            return Token(print);
        }
        (*is_ptr).get(ch);
    }

    switch (ch)
    {
    case print:
    case '!':
    case '{':
    case '}':
    case '(':
    case ')':
    case '+':
    case '-':
    case '*':
    case '/':
    case '%':
    case '=':
    case ',':
        return Token(ch);
    case '.':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    {
        (*is_ptr).putback(ch);
        double val;
        (*is_ptr) >> val;
        return Token(number, val);
    }
    default:
        if (isalpha(ch))
        {
            string s;
            s += ch;
            while ((*is_ptr).get(ch) && (isalpha(ch) || isdigit(ch) || ch == '_'))
            {
                s += ch;
            }
            (*is_ptr).putback(ch);
            if (s == declkey)
            {
                return Token(let);
            }
            if (s == conkey)
            {
                return Token(con);
            }
            if (s == sqrtkey)
            {
                return Token(square_root);
            }
            if (s == powkey)
            {
                return Token(power);
            }
            if (s == helpkey)
            {
                return Token(help);
            }
            if (s == quitkey)
            {
                return Token(quit);
            }
            return Token(name, s);
        }
        error("Bad token");
    }
}

void Token_stream::ignore(char c)
{
    if (full && c == buffer.kind)
    {
        full = false;
        return;
    }
    full = false;

    char ch = 0;
    while ((*is_ptr) >> ch)
    {
        if (ch == c)
        {
            return;
        }
    }
}

class Variable
{
public:
    string name;
    double value;
    bool is_const;
    Variable(string n, double v, bool b) : name(n), value(v), is_const(b) { }
};

class Symbol_table
{
public:
    double get(string s);
    void set(string s, double d);
    bool is_declared(string var);
    double declare(string var, double val, bool b);
private:
    vector<Variable> var_table;
};

double Symbol_table::get(string s)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            return var_table[i].value;
        }
    }
    error("get: undefined variable " + s);
}

void Symbol_table::set(string s, double d)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            if (var_table[i].is_const)
            {
                error(s + " is a constant");
            }
            var_table[i].value = d;
            return;
        }
    }
    error("set: undefined variable " + s);
}

bool Symbol_table::is_declared(string var)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == var)
        {
            return true;
        }
    }
    return false;
}

double Symbol_table::declare(string var, double val, bool b)
{
    if (is_declared(var))
    {
        error(var + " declared twice");
    }
    var_table.push_back(Variable(var, val, b));
    return val;
}

Token_stream ts;
Symbol_table st;
double expression();

double factorial(double d)
{
    int p = d;
    if (double(p) != d)
    {
        error("factorial not defined for non-integers");
    }
    if (p < 0)
    {
        error("factorial not defined for negative values");
    }
    else if (p == 0)
    {
        return 1;
    }
    else
    {
        double res = p;
        for (int i = p - 1; i > 0; --i)
        {
            res *= i;
            if (res > 1.0e+16)
            {
                error("factorial too large");
            }
        }
        return res;
    }
}

double my_pow(double base, int expo)
{
    if (expo < 0)
    {
        error("my_pow not defined for negative expo");
    }
    if (expo == 0)
    {
        if (base == 0)
        {
            return 0;
        }
        return 1;
    }
    double res = base;
    for (int i = 2; i <= expo; ++i)
    {
        res *= base;
    }
    return res;
}

double primary()
{
    Token t = ts.get();
    double d = 0;
    switch (t.kind)
    {
    case '(':
        d = expression();
        t = ts.get();
        if (t.kind != ')')
        {
            error("')' expected");
        }
        break;
    case '{':
        d = expression();
        t = ts.get();
        if (t.kind != '}')
        {
            error("'}' expected");
        }
        break;
    case number:
        d = t.value;
        break;
    case '-':
        d = -primary();
        break;
    case '+':
        d = primary();
        break;
    case name:
    {
        Token t2 = ts.get();
        if (t2.kind == '=')
        {
            d = expression();
            st.set(t.name, d);
        }
        else
        {
            ts.putback(t2);
            d = st.get(t.name);
        }
    }
    break;
    case square_root:
    {
        Token t2 = ts.get();
        if (t2.kind != '(')
        {
            error("'(' expected");
        }
        double d2 = expression();
        if (d2 < 0)
        {
            error("Square roots of negative numbers... nope!");
        }
        t2 = ts.get();
        if (t2.kind != ')')
        {
            error("')' expected");
        }
        d = sqrt(d2);
    }
    break;
    case power:
    {
        Token t2 = ts.get();
        if (t2.kind != '(')
        {
            error("'(' expected");
        }
        double d2 = expression();
        t2 = ts.get();
        if (t2.kind != ',')
        {
            error("',' expected");
        }
        t2 = ts.get();
        if (t2.kind != number)
        {
            error("second argument of 'pow' is not a number");
        }
        int i2 = int(t2.value);
        if (i2 != t2.value)
        {
            error("second argument of 'pow' is not an integer");
        }
        t2 = ts.get();
        if (t2.kind != ')')
        {
            error("')' expected");
        }
        d = my_pow(d2, i2);
    }
    break;
    default:
        error("primary expected");
    }

    t = ts.get();
    if (t.kind != '!')
    {
        ts.putback(t);
        return d;
    }
    return factorial(d);
}

double term()
{
    double left = primary();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '*':
            left *= primary();
            t = ts.get();
            break;
        case '/':
        {
            double d = primary();
            if (d == 0)
            {
                error("divide by zero");
            }
            left /= d;
            t = ts.get();
            break;
        }
        case '%':
        {
            double d = primary();
            int i1 = int(left);
            if (i1 != left)
            {
                error("left-hand operand of % not int");
            }
            int i2 = int(d);
            if (i2 != d)
            {
                error("right-hand operand of % not int");
            }
            if (i2 == 0)
            {
                error("%: divide by zero");
            }
            left = i1 % i2;
            t = ts.get();
            break;
        }
        default:
            ts.putback(t);
            return left;
        }
    }
}

double expression()
{
    double left = term();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '+':
            left += term();
            t = ts.get();
            break;
        case '-':
            left -= term();
            t = ts.get();
            break;
        case '=':
            error("use of '=' outside of a declaration");
        default:
            ts.putback(t);
            return left;
        }
    }
}

double declaration(bool b)
{
    Token t = ts.get();
    if (t.kind != name)
    {
        error ("name expected in declaration");
    }
    string var_name = t.name;

    Token t2 = ts.get();
    if (t2.kind != '=')
    {
        error("= missing in declaration of " + var_name);
    }

    double d = expression();
    st.declare(var_name, d, b);
    return d;
}

double statement()
{
    Token t = ts.get();
    switch(t.kind)
    {
    case let:
        return declaration(false);
    case con:
        return declaration(true);
    default:
        ts.putback(t);
        return expression();
    }
}

void clean_up_mess()
{
    ts.ignore(print);
}

void print_help()
{
    cout << "Instructions: enter expressions, there are\n";
    cout << "a few functions, you can declare variables using\n";
    cout << "the 'let' keyword and constants with the 'const'\n";
    cout << "keyword.\n";
}

void calculate()
{
    while (ts.get_istream())
    {
        try
        {
            Token t = ts.get();
            while (t.kind == print)
            {
                t = ts.get();
            }
            if (t.kind == help)
            {
                print_help();
            }
            else if (t.kind == quit)
            {
                return;
            }
            else
            {
                ts.putback(t);
                ostream &file_out = ts.get_ostream();
                file_out << result << statement() << endl;
            }
        }
        catch(exception &e)
        {
            cerr << e.what() << endl;
            clean_up_mess();
        }
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        st.declare("pi", 3.1415926535, true);
        st.declare("e", 2.7182818284, true);
        st.declare("k", 1000, true);

        string s1, s2;
        cout << "Enter input file name: ";
        cin >> s1;
        cout << "Enter output file name: ";
        cin >> s2;

        ifstream ifs(s1.c_str());
        if (!ifs)
        {
            error("can't open input file " + s1);
        }
        ofstream ofs(s2.c_str());
        if (!ofs)
        {
            error("can't open output file " + s2);
        }
        ts.set_istream(ifs);
        ts.set_ostream(ofs);

        calculate();

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
7*8!
sqrt(2+6.7)
pow(2.5,3)
let x = 3.4
let y = 2
let z = (x+y*2)/pi
2+3*z
quit
[weiyayun@weiyayun-PC code]$ ch15_p01
Enter input file name: ch15_p01_in.txt
Enter output file name: ch15_p01_out.txt
[weiyayun@weiyayun-PC code]$ cat ch15_p01_out.txt
= 282240
= 2.94958
= 15.625
= 3.4
= 2
= 2.35549
= 9.06648

ch15_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

typedef vector<char> Line;

class Text_iterator;

class Document
{
public:
    list<Line> line;

    Document();

    Text_iterator begin();
    Text_iterator end();

    Text_iterator erase(Text_iterator pos);
    Text_iterator insert(Text_iterator pos, char ch);
    void concat(Text_iterator &pos);
    void break_ln(Text_iterator pos);
    void find_replace(const string &find_str, const string &repl_str);
};

class Text_iterator
{
private:
    Document &doc;
    list<Line>::iterator ln;
    Line::iterator pos;
public:
    Text_iterator(Document &d, list<Line>::iterator l, Line::iterator p) : doc(d), ln(l), pos(p) { }
    Text_iterator(const Text_iterator &other) : doc(other.doc), ln(other.ln), pos(other.pos) { }
    Text_iterator &operator=(const Text_iterator &rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        doc = rhs.doc;
        ln = rhs.ln;
        pos = rhs.pos;
        return *this;
    }

    list<Line>::iterator get_line()
    {
        return ln;
    }
    Line::iterator get_pos()
    {
        return pos;
    }

    char &operator*()
    {
        return *pos;
    }
    Text_iterator &operator++();

    bool operator==(const Text_iterator &other) const
    {
        return ln == other.ln && pos == other.pos;
    }
    bool operator!=(const Text_iterator &other) const
    {
        return !(*this == other);
    }
};

Text_iterator &Text_iterator::operator++()
{
    if (ln == doc.line.end())
    {
        return *this;
    }
    list<Line>::iterator last = doc.line.end();
    --last;
    if (ln == last && pos == (*ln).begin())
    {
        return *this;
    }
    if (pos != (*ln).end())
    {
        ++pos;
    }
    if (pos == (*ln).end())
    {
        if (ln != last)
        {
            ++ln;
            pos = (*ln).begin();
        }
    }
    return *this;
}

template<typename Iter>
bool my_match(Iter first, Iter last, const string &s)
{
    if (first == last)
    {
        return false;
    }
    if (s.size() == 0)
    {
        return false;
    }
    string::const_iterator s_itr = s.begin();
    while (first != last && s_itr != s.end())
    {
        if (*first != *s_itr)
        {
            return false;
        }
        ++first;
        ++s_itr;
    }
    if (first == last && s_itr != s.end())
    {
        return false;
    }
    return true;
}

template<typename Iter, typename T>
Iter my_find(Iter first, Iter last, const T &val)
{
    Iter p = first;
    while (p != last)
    {
        if (*p == val)
        {
            return p;
        }
        ++p;
    }
    return p;
}

Text_iterator find_txt(Text_iterator first, Text_iterator last, const string &s)
{
    if (first == last)
    {
        return last;
    }
    if (s.size() == 0)
    {
        return last;
    }
    char first_char = s[0];
    while (true)
    {
        Text_iterator p = my_find<Text_iterator, char>(first, last, first_char);
        if (p == last)
        {
            return last;
        }
        if (my_match<Text_iterator>(p, last, s))
        {
            return p;
        }
        first = ++p;
    }
}

Document::Document()
{
    line.push_back(Line());
}
Text_iterator Document::begin()
{
    return Text_iterator(*this, line.begin(), (* ( line.begin() ) ).begin());
}
Text_iterator Document::end()
{
    list<Line>::iterator last = line.end();
    --last;
    return Text_iterator(*this, last, (*last).begin());
}

Text_iterator Document::erase(Text_iterator pos)
{
    list<Line>::iterator list_it = pos.get_line();
    Line::iterator line_it = pos.get_pos();
    line_it = (*list_it).erase(line_it);
    return Text_iterator(*this, list_it, line_it);
}

Text_iterator Document::insert(Text_iterator pos, char ch)
{
    list<Line>::iterator list_it = pos.get_line();
    Line::iterator line_it = pos.get_pos();
    line_it = (*list_it).insert(line_it, ch);
    return Text_iterator(*this, list_it, line_it);
}

void Document::concat(Text_iterator &pos)
{
    list<Line>::iterator cur_line = pos.get_line();
    Line::iterator line_pos = pos.get_pos();
    Line::size_type index = line_pos - (*cur_line).begin();
    list<Line>::iterator nxt_line = cur_line;
    ++nxt_line;
    list<Line>::iterator last = line.end();
    --last;
    if (nxt_line != last && (*nxt_line).begin() != (*nxt_line).end())
    {
        (*cur_line).insert((*cur_line).end(), (*nxt_line).begin(), (*nxt_line).end());
        pos = Text_iterator(*this, cur_line, (*cur_line).begin() + index);
        line.erase(nxt_line);
    }
}

void Document::break_ln(Text_iterator pos)
{
    list<Line>::iterator cur_line = pos.get_line();
    list<Line>::iterator nxt_line = cur_line;
    ++nxt_line;
    list<Line>::iterator last = line.end();
    --last;
    if (pos.get_pos() + 1 != (*cur_line).end())
    {
        if (nxt_line == last)
        {
            line.push_back(Line());
        }
        (*nxt_line).insert((*nxt_line).begin(), pos.get_pos() + 1, (*cur_line).end());
        (*cur_line).erase(pos.get_pos() + 1, (*cur_line).end());
    }
}

void Document::find_replace(const string &find_str, const string &repl_str)
{
    if (begin() == end())
    {
        return ;
    }
    if (find_str.size() == 0)
    {
        return ;
    }
    Text_iterator pos = find_txt(begin(), end(), find_str);
    while (pos != end())
    {
        string::const_iterator find_it = find_str.begin();
        string::const_iterator repl_it = repl_str.begin();
        while (find_it != find_str.end() && repl_it != repl_str.end())
        {
            if (*find_it != *repl_it)
            {
                *pos = *repl_it;
                if (*find_it == '\n')
                {
                    concat(pos);
                }
                if (*repl_it == '\n')
                {
                    break_ln(pos);
                }
            }
            ++pos;
            ++find_it;
            ++repl_it;
        }

        while (find_it != find_str.end())
        {
            list<Line>::iterator cur_line = pos.get_line();
            if (*pos == '\n')
            {
                concat(pos);
            }
            else if (*pos != '\n' && (*cur_line).size() == 1)
            {
                concat(pos);
            }
            pos = erase(pos);
            cur_line = pos.get_line();
            if ((*cur_line).size() == 0)
            {
                line.erase(cur_line);
                pos = end();
                break;
            }
            ++find_it;
        }

        while (repl_it != repl_str.end())
        {
            list<Line>::iterator cur_line = pos.get_line();
            list<Line>::iterator last = line.end();
            --last;
            if (cur_line == last)
            {
                line.push_back(Line());
            }
            pos = insert(pos, *repl_it);
            if (*repl_it == '\n')
            {
                break_ln(pos);
            }
            ++pos;
            ++repl_it;
        }

        pos = find_txt(pos, end(), find_str);
    }
}

istream &operator>>(istream &is, Document &d)
{
    char ch;
    while (is.get(ch))
    {
        d.line.back().push_back(ch);
        if (ch == '\n')
        {
            d.line.push_back(Line());
        }
    }
    if (d.line.back().size() > 0)
    {
        d.line.push_back(Line());
    }
    return is;
}

void print(Document &d, Text_iterator p)
{
    for ( ; p != d.end(); ++p)
    {
        cout << *p;
    }
    cout << "\n";
}

int char_count(Document &d)
{
    Text_iterator iter = d.begin();
    int ctr = 0;
    while (iter != d.end())
    {
        ++iter;
        ++ctr;
    }
    return ctr;
}

int file_word_count(const string &fname)
{
    ifstream ifs(fname.c_str());
    if (!ifs)
    {
        error("can't open file " + fname);
    }
    string s;
    int ctr = 0;
    while (ifs >> s)
    {
        ++ctr;
    }
    return ctr;
}

int word_count1(Document &d)
{
    Text_iterator p = d.begin();
    string fname = "ch15_p02_tmp1.txt";
    ofstream ofs(fname.c_str());
    if (!ofs)
    {
        error("can't open file " + fname);
    }
    while (p != d.end())
    {
        ofs << *p;
        ++p;
    }
    ofs.close();

    int ctr = file_word_count(fname);
    return ctr;
}

int word_count2(Document &d)
{
    Text_iterator p = d.begin();
    string fname = "ch15_p02_tmp2.txt";
    ofstream ofs(fname.c_str());
    if (!ofs)
    {
        error("can't open file " + fname);
    }
    while (p != d.end())
    {
        if (isalpha(*p))
        {
            ofs << *p;
        }
        else
        {
            ofs << ' ';
        }
        ++p;
    }
    ofs.close();

    int ctr = file_word_count(fname);
    return ctr;
}

bool is_whitespace(char c, const string &white)
{
    for (int i = 0; i < white.size(); ++i)
    {
        if (white[i] == c)
        {
            return true;
        }
    }
    return false;
}

int word_count3(Document &d, const string &white)
{
    Text_iterator p = d.begin();
    string fname = "ch15_p02_tmp3.txt";
    ofstream ofs(fname.c_str());
    if (!ofs)
    {
        error("can't open file " + fname);
    }
    while (p != d.end())
    {
        if (is_whitespace(*p, white))
        {
            ofs << ' ';
        }
        else
        {
            ofs << *p;
        }
        ++p;
    }
    ofs.close();

    int ctr = file_word_count(fname);
    return ctr;
}

int main(int argc, const char *argv[])
{
    try
    {
        string ifname = "ch15_p02_in.txt";
        ifstream ifs(ifname.c_str());
        if (!ifs)
        {
            error("can't open file " + ifname);
        }
        Document my_doc;
        ifs >> my_doc;
        print(my_doc, my_doc.begin());

        cout << "\nSearching for string 'wrong':\n";
        string f_str = "wrong";
        Text_iterator p = find_txt(my_doc.begin(), my_doc.end(), f_str);
        if (p == my_doc.end())
        {
            cout << "not found";
        }
        else
        {
            print(my_doc, p);
        }

        cout << "\nReplace 'wrong' with 'HelloWorld':\n";
        f_str = "wrong";
        string r_str = "HelloWorld";
        my_doc.find_replace(f_str, r_str);
        print(my_doc, my_doc.begin());


        cout << "\nNumber of characters in this document: "
             << char_count(my_doc) << "\n";

        cout << "Number of words (whitespace-separated) in this document: "
             << word_count1(my_doc) << "\n";

        cout << "Number of words (sequences of alphabetic characters) in this "
             << "document: " << word_count2(my_doc) << "\n";

        cout << "Number of words separated by whitespace or \".!'\" in this "
             << "document: " << word_count3(my_doc, ".!'") << "\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Peter Smith Mike Pence Water Flower
123abc wrong 56789 How are You?
Orange Egg Smile wrong
Internet


Searching for string 'wrong':
wrong 56789 How are You?
Orange Egg Smile wrong
Internet


Replace 'wrong' with 'HelloWorld':
Peter Smith Mike Pence Water Flower
123abc HelloWorld 56789 How are You?
Orange Egg Smile HelloWorld
Internet


Number of characters in this document: 110
Number of words (whitespace-separated) in this document: 17
Number of words (sequences of alphabetic characters) in this document: 16
Number of words separated by whitespace or ".!'" in this document: 17

cat ch15_p02_in.txt
Peter Smith Mike Pence Water Flower
123abc wrong 56789 How are You?
Orange Egg Smile wrong
Internet

cat ch15_p02_tmp1.txt
Peter Smith Mike Pence Water Flower
123abc HelloWorld 56789 How are You?
Orange Egg Smile HelloWorld
Internet

cat ch15_p02_tmp2.txt
Peter Smith Mike Pence Water Flower    abc HelloWorld       How are You  Orange Egg Smile HelloWorld Internet

cat ch15_p02_tmp3.txt
Peter Smith Mike Pence Water Flower
123abc HelloWorld 56789 How are You?
Orange Egg Smile HelloWorld
Internet

ch15_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

namespace Text_query
{
    map<string, int> clean_txt(const string &fname);
    int num_of_occurrences(const string &word, const map<string, int> &clean_txt);
    string most_frequent(const map<string, int> &clean_txt);
    string longest(const map<string, int> &clean_txt);
    string shortest(const map<string, int> &clean_txt);

    class First_char
    {
    private:
        char ch;
    public:
        First_char(char c) : ch(c) { }
        bool operator()(const pair<string, int> &p) const
        {
            return p.first[0] == ch;
        }
    };

    vector<string> start_with(char ch, const map<string, int> &clean_txt);

    class Length
    {
    private:
        int n;
    public:
        Length(int nn) : n(nn) { }
        bool operator()(const pair<string, int> &p) const
        {
            return p.first.size() == n;
        }
    };

    vector<string> has_length(int n, const map<string, int> &clean_txt);
}

namespace Text_query
{
    map<string, int> clean_txt(const string &fname)
    {
        ifstream ifs(fname);
        if (!ifs)
        {
            error("Can not open file " + fname);
        }
        ostringstream oss;

        char ch;
        while (ifs.get(ch))
        {
            if (ispunct(ch) && ch != '\'')
            {
                ch = ' ';
            }
            oss << char(tolower(ch));
        }

        map<string, int> words;
        istringstream iss(oss.str());
        string w;
        while (iss >> w)
        {
            if (w == "can't")
            {
                ++words["cannot"];
            }
            else if (w == "shan't")
            {
                ++words["shall"];
                ++words["not"];
            }
            else if (w == "won't")
            {
                ++words["will"];
                ++words["not"];
            }
            else if (w == "let's")
            {
                ++words["let"];
                ++words["us"];
            }
            else if (w == "'" || w.size() == 2 && w[0] == '\'')
            {
                // do nothing, don't add word
            }
            else if (w.size() >= 3 && *(w.end() - 2) == '\'')
            {
                switch (w.back())
                {
                case 'd':
                    ++words["would"];
                    ++words[w.substr(0, w.size() - 2)];
                    break;
                case 'm':
                    ++words["am"];
                    ++words[w.substr(0, w.size() - 2)];
                    break;
                case 's':
                    ++words["is"];
                    ++words[w.substr(0, w.size() - 2)];
                    break;
                case 't':
                    ++words["not"];
                    ++words[w.substr(0, w.size() - 3)];
                    break;
                default:
                    break;
                }
            }
            else if (w.size() >= 4 && *(w.end() - 3) == '\'')
            {
                switch (*(w.end() - 2))
                {
                case 'l':
                    ++words["will"];
                    ++words[w.substr(0, w.size() - 3)];
                    break;
                case 'r':
                    ++words["are"];
                    ++words[w.substr(0, w.size() - 3)];
                    break;
                case 'v':
                    ++words["have"];
                    ++words[w.substr(0, w.size() - 3)];
                    break;
                default:
                    break;
                }
            }
            else
            {
                ++words[w];
            }
        }

        typedef map<string, int>::iterator Iter;
        for (Iter p = words.begin(); p != words.end(); ++p)
        {
            Iter q = p;
            ++q;
            if (q != words.end() && q->first[0] == p->first[0]
                    && q->first.size() == p->first.size() + 1
                    && q->first == p->first + "s")
            {
                q = words.erase(q);
            }
        }

        return words;
    }

    int num_of_occurrences(const string &word, const map<string, int> &clean_txt)
    {
        if (clean_txt.find(word) != clean_txt.end())
        {
            return clean_txt.at(word);
        }
        else
        {
            return 0;
        }
    }

    string most_frequent(const map<string, int> &clean_txt)
    {
        string s;
        int max = 0;
        typedef map<string, int>::const_iterator Iter;
        for (Iter p = clean_txt.begin(); p != clean_txt.end(); ++p)
        {
            if (p->second > max)
            {
                max = p->second;
                s = p->first;
            }
        }
        return s;
    }

    string longest(const map<string, int> &clean_txt)
    {
        string s;
        int l_max = 0;
        typedef map<string, int>::const_iterator Iter;
        for (Iter p = clean_txt.begin(); p != clean_txt.end(); ++p)
        {
            if (p->first.length() > l_max)
            {
                l_max = p->first.length();
                s = p->first;
            }
        }
        return s;
    }

    string shortest(const map<string, int> &clean_txt)
    {
        string s;
        typedef map<string, int>::const_iterator Iter;
        Iter p = clean_txt.begin();
        s = p->first;
        int l_min = p->first.length();
        ++p;
        for (; p != clean_txt.end(); ++p)
        {
            if (p->first.length() < l_min)
            {
                l_min = p->first.length();
                s = p->first;
            }
        }
        return s;
    }

    vector<string> start_with(char ch, const map<string, int> &clean_txt)
    {
        int count = count_if(clean_txt.begin(), clean_txt.end(), First_char(ch));
        vector<pair<string, int>> vp(count);
        copy_if(clean_txt.begin(), clean_txt.end(), vp.begin(), First_char(ch));
        vector<string> vs;
        for (int i = 0; i < vp.size(); ++i)
        {
            vs.push_back(vp[i].first);
        }
        return vs;
    }

    vector<string> has_length(int n, const map<string, int> &clean_txt)
    {
        int count = count_if(clean_txt.begin(), clean_txt.end(), Length(n));
        vector<pair<string, int>> vp(count);
        copy_if(clean_txt.begin(), clean_txt.end(), vp.begin(), Length(n));
        vector<string> vs;
        for (int i = 0; i < vp.size(); ++i)
        {
            vs.push_back(vp[i].first);
        }
        return vs;
    }
}

void print_menu()
{
    cout << "What would you like to do?\n"
         << "1 - Enter input file name\n"
         << "2 - Get number of occurrences of a word\n"
         << "3 - Get most frequent word\n"
         << "4 - Get longest word\n"
         << "5 - Get shortest word\n"
         << "6 - Get words starting with a specific letter\n"
         << "7 - Get words of a specific length\n"
         << "0 - Exit\n";
}

string get_ifname()
{
    cout << "\nEnter input file name: ";
    string s;
    cin >> s;
    cout << '\n';
    return s;
}

bool file_check(const string &fname)
{
    if (fname == "")
    {
        cout << "\nFile name is empty!\n\n";
        return false;
    }

    ifstream ifs(fname.c_str());
    if (!ifs)
    {
        cout << "\nFile " << fname << " doesn't exist!\n\n";
        return false;
    }

    return true;
}

void get_n_occurrences(const map<string, int> &clean_txt)
{
    if (clean_txt.size() == 0)
    {
        cout << "\nNo text loaded!\n\n";
        return;
    }
    cout << "\nEnter word: ";
    string s;
    cin >> s;
    int n = Text_query::num_of_occurrences(s, clean_txt);
    cout << "\n\'" << s << "\' occurs " << n << " time" << (n == 1 ? "" : "s") << ".\n\n";
}

void get_most_frequent(const map<string, int> &clean_txt)
{
    if (clean_txt.size() == 0)
    {
        cout << "\nNo text loaded!\n\n";
        return;
    }
    string s = Text_query::most_frequent(clean_txt);
    cout << "\nThe most frequent word is \'" << s << "\'.\n\n";
}

void get_longest(const map<string, int> &clean_txt)
{
    if (clean_txt.size() == 0)
    {
        cout << "\nNo text loaded!\n\n";
        return;
    }
    string s = Text_query::longest(clean_txt);
    cout << "\nThe longest word is \'" << s << "\'.\n\n";
}

void get_shortest(const map<string, int> &clean_txt)
{
    if (clean_txt.size() == 0)
    {
        cout << "\nNo text loaded!\n\n";
        return;
    }
    string s = Text_query::shortest(clean_txt);
    cout << "\nThe shortest word is \'" << s << "\'.\n\n";
}

void get_start_with(const map<string, int> &clean_txt)
{
    if (clean_txt.size() == 0)
    {
        cout << "\nNo text loaded!\n\n";
        return;
    }
    cout << "\nEnter character: ";
    char ch;
    cin >> ch;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    vector<string> vs = Text_query::start_with(ch, clean_txt);
    cout << "\nWords starting with '" << ch << "':\n";
    for (int i = 0; i < vs.size(); ++i)
    {
        cout << vs[i] << '\n';
    }
    cout << '\n';
}

void get_has_length(const map<string, int> &clean_txt)
{
    if (clean_txt.size() == 0)
    {
        cout << "\nNo text loaded!\n\n";
        return;
    }
    cout << "\nEnter number of characters: ";
    int n;
    while (!( cin >> n))
    {
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
        cout << "\nPlease enter a number\n";
        cout << "\nEnter number of characters: ";
    }
    vector<string> vs = Text_query::has_length(n, clean_txt);
    cout << "\nWords with " << n << " characters:\n";
    for (int i = 0; i < vs.size(); ++i)
    {
        cout << vs[i] << '\n';
    }
    cout << '\n';
}

int main(int argc, const char *argv[])
{
    try
    {
        string ifname;
        map<string, int> words;

        bool keep_running = true;
        while (keep_running)
        {
            print_menu();
            int n;
            while (!(cin >> n))
            {
                cin.clear();
                cin.ignore(numeric_limits<streamsize>::max(), '\n');
                cout << "\nPlease enter a number\n";
                print_menu();
            }
            switch (n)
            {
            case 0:
                keep_running = false;
                break;
            case 1:
                ifname = get_ifname();
                if (file_check(ifname))
                {
                    words = Text_query::clean_txt(ifname);
                }
                break;
            case 2:
                get_n_occurrences(words);
                break;
            case 3:
                get_most_frequent(words);
                break;
            case 4:
                get_longest(words);
                break;
            case 5:
                get_shortest(words);
                break;
            case 6:
                get_start_with(words);
                break;
            case 7:
                get_has_length(words);
                break;
            default:
                cout << "\nEnter a number between 0 and 7\n\n";
                break;
            }
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
1

Enter input file name: ch15_p03_in.txt

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
2

Enter word: would

'would' occurs 9 times.

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
3

The most frequent word is 'not'.

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
4

The longest word is 'cannot'.

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
5

The shortest word is 'i'.

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
6

Enter character: w

Words starting with 'w':
we
were
what
where
who
will
would

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
7

Enter number of characters: 5

Words with 5 characters:
could
shall
there
where
would

What would you like to do?
1 - Enter input file name
2 - Get number of occurrences of a word
3 - Get most frequent word
4 - Get longest word
5 - Get shortest word
6 - Get words starting with a specific letter
7 - Get words of a specific length
0 - Exit
0

cat ch15_p03_in.txt
I'm I'd aren't can't couldn't didn't doesn't don't hadn't hasn't haven't he'd he'll he's I'd I'll I'm I've
isn't it's let's mustn't shan't she'd she'll she's shouldn't that's there's they'd they'll they're
they've we'd we're we've weren't what'll what're what's what've where's who'd who'll who're
who's who've won't wouldn't you'd you'll you're you've

ch15_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

namespace Chrono
{
    class Date
    {
    public:
        enum Month
        {
            jan = 1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
        };

        Date(int y, Month m, int d);
        Date();

        int day() const
        {
            return d;
        }
        Month month() const
        {
            return m;
        }
        int year() const
        {
            return y;
        }

        void add_day(int n);
        void add_month(int n);
        void add_year(int n);
    private:
        int y;
        Month m;
        int d;
    };

    bool is_date(int y, Date::Month m, int d);
    bool leapyear(int y);

    int day_in_year(const Date &d);
    void split_date(int day_of_year, int year, int *month, int *day);
    int n_leapyears(int y);
    long int days_linear(const Date &d);

    enum Day
    {
        sunday, monday, tuesday, wednesday, thursday, friday, saturday
    };
    Day day_of_week(const Date &d);
    ostream &operator<<(ostream &os, Day d);

    bool operator==(const Date &a, const Date &b);
    bool operator!=(const Date &a, const Date &b);

    ostream &operator<<(ostream &os, const Date &d);
    istream &operator>>(istream &is, Date &dd);
}

namespace Chrono
{
    Date::Date(int yy, Month mm, int dd) : y(yy), m(mm), d(dd)
    {
        if (!is_date(yy, mm, dd))
        {
            error("invalid date");
        }
    }

    const Date &default_date()
    {
        static const Date dd(2001, Date::jan, 1);
        return dd;
    }

    Date::Date() : y(default_date().year()), m(default_date().month()), d(default_date().day()) { }

    int nmonth(Date::Month m)
    {
        switch (m)
        {
        case Date::jan:
            return 0;
        case Date::feb:
            return 31;
        case Date::mar:
            return 31 + 28;
        case Date::apr:
            return 31 + 28 + 31;
        case Date::may:
            return 31 + 28 + 31 + 30;
        case Date::jun:
            return 31 + 28 + 31 + 30 + 31;
        case Date::jul:
            return 31 + 28 + 31 + 30 + 31 + 30;
        case Date::aug:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31;
        case Date::sep:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31;
        case Date::oct:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30;
        case Date::nov:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31;
        case Date::dec:
            return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30;
        }
    }

    void Date::add_day(int n)
    {
        int doy = nmonth(dec);
        doy += 31;
        if (leapyear(y - 1))
        {
            ++doy;
        }
        int diy = nmonth(dec);
        diy += 31;
        if (leapyear(y))
        {
            ++diy;
        }
        int day_of_year = day_in_year(*this);
        day_of_year += n;
        if (day_of_year >= 1 && day_of_year <= diy)
        {
            int res_month, res_day;
            split_date(day_of_year, y, &res_month, &res_day);
            m = Month(res_month);
            d = res_day;
        }
        else if (day_of_year > diy && day_of_year <= (diy + 365))
        {
            day_of_year -= diy;
            int res_month, res_day;
            split_date(day_of_year, y + 1, &res_month, &res_day);
            y++;
            m = Month(res_month);
            d = res_day;
        }
        else if (day_of_year < 1 && (day_of_year + doy) >= 1)
        {
            day_of_year += doy;
            int res_month, res_day;
            split_date(day_of_year, y - 1, &res_month, &res_day);
            y--;
            m = Month(res_month);
            d = res_day;
        }
    }

    void Date::add_month(int n)
    {
        int month = m + n;
        bool day_large = false;
        if (d > 28)
        {
            day_large = true;
            add_day(-3);
        }
        if (month >= jan && month <= dec)
        {
            m = Month(month);
            if (day_large == true)
            {
                add_day(3);
            }
        }
        else if (month > dec && month <= dec + 12)
        {
            month -= dec;
            y++;
            m = Month(month);
            if (day_large == true)
            {
                add_day(3);
            }
        }
        else if(month < jan && month + 12 >= 1)
        {
            month += 12;
            y--;
            m = Month(month);
            if (day_large == true)
            {
                add_day(3);
            }
        }
    }

    void Date::add_year(int n)
    {
        if (m == feb && d == 29 && !leapyear(y + n))
        {
            m = mar;
            d = 1;
        }
        y += n;
    }

    bool is_date(int y, Date::Month m, int d)
    {
        if (d <= 0)
        {
            return false;
        }

        int days_in_month = 31;

        switch (m)
        {
        case Date::feb:
            days_in_month = (leapyear(y)) ? 29 : 28;
            break;
        case Date::apr:
        case Date::jun:
        case Date::sep:
        case Date::nov:
            days_in_month = 30;
            break;
        }

        if (days_in_month < d)
        {
            return false;
        }

        return true;
    }

    bool leapyear(int y)
    {
        return (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;
    }

    bool operator==(const Date &a, const Date &b)
    {
        return a.year() == b.year() && a.month() == b.month() && a.day() == b.day();
    }

    bool operator!=(const Date &a, const Date &b)
    {
        return !(a == b);
    }

    ostream &operator<<(ostream &os, const Date &d)
    {
        return os << '(' << d.year() << ',' << d.month() << ',' << d.day() << ')';
    }

    istream &operator>>(istream &is, Date &dd)
    {
        int y, m, d;
        char ch1, ch2, ch3, ch4;
        is >> ch1 >> y >> ch2 >> m >> ch3 >> d >> ch4;
        if (!is)
        {
            return is;
        }
        if (ch1 != '(' || ch2 != ',' || ch3 != ',' || ch4 != ')')
        {
            is.clear(std::ios_base::failbit);
            return is;
        }
        dd = Date(y, Date::Month(m), d);
        return is;
    }

    ostream &operator<<(ostream &os, Day d)
    {
        switch (d)
        {
        case sunday:
            os << "Sunday";
            break;
        case monday:
            os << "Monday";
            break;
        case tuesday:
            os << "Tuesday";
            break;
        case wednesday:
            os << "Wednesday";
            break;
        case thursday:
            os << "Thursday";
            break;
        case friday:
            os << "Friday";
            break;
        case saturday:
            os << "Saturday";
            break;
        }
        return os;
    }

    const Date first_date = Date(1970, Date::jan, 1);
    const Day first_day = thursday;

    Day day_of_week(const Date &d)
    {
        if (d.year() < first_date.year())
        {
            error("day_of_week: works only for 1970 and later");
        }
        int dlin = days_linear(d);
        return Day((first_day + dlin) % 7);
    }

    Date next_Sunday(const Date &d)
    {
        Date nsd = d;
        Day day = day_of_week(d);
        nsd.add_day(7 - day);
        return nsd;
    }

    int day_in_year(const Date &d)
    {
        int diy = nmonth(d.month());
        diy += d.day();
        if (leapyear(d.year()) && d.month() > Date::feb)
        {
            ++diy;
        }
        return diy;
    }

    void split_date(int day_of_year, int year, int *month, int *day)
    {
        int i;
        bool found = false;

        for (i = 1; i <= 12 && !found; i++)
        {
            switch(i)
            {
            case 1:
            case 3:
            case 5:
            case 7:
            case 8:
            case 10:
            case 12:
                if (day_of_year <= 31)
                {
                    found = true;
                }
                else
                {
                    day_of_year -= 31;
                }
                break;
            case 4:
            case 6:
            case 9:
            case 11:
                if (day_of_year <= 30)
                {
                    found = true;
                }
                else
                {
                    day_of_year -= 30;
                }
                break;
            case 2:
                if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0))
                {
                    if (day_of_year <= 29)
                    {
                        found = true;
                    }
                    else
                    {
                        day_of_year -= 29;
                    }
                }
                else
                {
                    if (day_of_year <= 28)
                    {
                        found = true;
                    }
                    else
                    {
                        day_of_year -= 28;
                    }
                }
                break;
            default :
                break;
            }
        }
        *month = i - 1;
        *day = day_of_year;
    }

    int n_leapyears(int y)
    {
        int nl = 0;
        for (int i = 1970; i < y; ++i)
        {
            if (leapyear(i))
            {
                ++nl;
            }
        }
        return nl;
    }

    long int days_linear(const Date &d)
    {
        if (d.year() < first_date.year())
        {
            error("days_linear: year must be 1970 or later");
        }
        int y = d.year() - first_date.year();
        return y * 365 + n_leapyears(d.year()) + day_in_year(d) - 1;
    }

    Date next_workday(const Date &d)
    {
        Date nwd = d;
        Day day = day_of_week(d);
        switch (day)
        {
        case sunday:
        case monday:
        case tuesday:
        case wednesday:
        case thursday:
            nwd.add_day(1);
            break;
        case saturday:
            nwd.add_day(2);
            break;
        case friday:
            nwd.add_day(3);
            break;
        }
        return nwd;
    }
}

namespace Liber
{
    class ISBN
    {
    public:
        int n1;
        int n2;
        int n3;
        int n4;
        char x;

        ISBN(int n1_val, int n2_val, int n3_val, int n4_val, char x_val);
        ISBN();
    };

    bool is_isbn(int, int, int, int, char);

    bool operator==(const ISBN &i1, const ISBN &i2);

    class Book
    {
    public:
        enum Genre
        {
            fiction = 0, nonfiction, periodical, biography, children
        };

        Book(const ISBN &isbn_num, const string &title, const string &author, int c_date, Genre gen, bool checked_out);
        Book();

        const ISBN &isbn() const
        {
            return in;
        }
        const string &title() const
        {
            return t;
        }
        const string &author() const
        {
            return a;
        }
        int c_date() const
        {
            return cd;
        }
        Genre genre() const
        {
            return g;
        }
        bool checked_out() const
        {
            return ch_out;
        }

        void check_out();
        void check_in();

    private:
        ISBN in;
        string t;
        string a;
        int cd;
        Genre g;
        bool ch_out;
    };

    bool operator==(const Book &b1, const Book &b2);
    bool operator!=(const Book &b1, const Book &b2);
    ostream &operator<<(ostream &os, const Book &b);


    class Patron
    {
    public:
        Patron(const string &name, int card_number, double fees);
        Patron();

        const string &get_name() const
        {
            return name;
        }
        int get_number() const
        {
            return card_number;
        }
        double get_fees() const
        {
            return fees;
        }

        void set_fee(double f);
    private:
        string name;
        int card_number;
        double fees;
    };

    bool owes_fee(const Patron &p);

    bool operator==(const Patron &p1, const Patron &p2);
    bool operator!=(const Patron &p1, const Patron &p2);

    class Library
    {
    public:
        class Transaction
        {
        public:
            Book b;
            Patron p;
            Chrono::Date d;

            Transaction(const Book &bb, const Patron &pp, const Chrono::Date &dd);
            Transaction();
        };

        Library(const vector<Book> &books, const vector<Patron> &patrons, const vector<Transaction> &transactions);
        Library();

        void add_book(const Book &b);
        void add_patron(const Patron &p);
        void check_out(const Book &b, const Patron &p, const Chrono::Date &d);
        void set_fee(const Patron &p, double f);

        const vector<Book> &get_books() const
        {
            return books;
        }
        const vector<Patron> &get_patrons() const
        {
            return patrons;
        }
        const vector<Transaction> &get_transactions() const
        {
            return transactions;
        }
        vector<Patron> get_debtors() const;

    private:
        vector<Book> books;
        vector<Patron> patrons;
        vector<Transaction> transactions;
    };

}

namespace Liber
{
    ISBN::ISBN(int n1_val, int n2_val, int n3_val, int n4_val, char x_val)
        : n1(n1_val), n2(n2_val), n3(n3_val), n4(n4_val), x(x_val)
    {
        if (!is_isbn(n1, n2, n3, n4, x))
        {
            error("is_isbn(): invalid number");
        }
    }

    const ISBN &default_isbn()
    {
        static const ISBN in(0, 0, 0, 0, '0');
        return in;
    }

    ISBN::ISBN()
        : n1(default_isbn().n1),
          n2(default_isbn().n2),
          n3(default_isbn().n3),
          n4(default_isbn().n4),
          x(default_isbn().x)
    {
    }

    bool is_isbn(int, int, int, int, char x)
    {
        return (isalpha(x) || isdigit(x));
    }

    bool operator==(const ISBN &i1, const ISBN &i2)
    {
        return (i1.n1 == i2.n1 && i1.n2 == i2.n2 && i1.n3 == i2.n3 && i1.n4 == i2.n4 && i1.x == i2.x);
    }

    Book::Book(const ISBN &isbn_num, const string &title, const string &author, int c_date, Genre gen, bool checked_out)
        : in(isbn_num), t(title), a(author), cd(c_date), g(gen), ch_out(checked_out)
    {
    }

    const Book &default_book()
    {
        static const Book b(ISBN(), "", "", 0, Book::fiction, false);
        return b;
    }

    Book::Book()
        : in(default_book().isbn()),
          t(default_book().title()),
          a(default_book().author()),
          cd(default_book().c_date()),
          g(default_book().genre()),
          ch_out(default_book().checked_out())
    {
    }

    void Book::check_out()
    {
        if (checked_out())
        {
            error("already checked out");
        }
        ch_out = true;
    }

    void Book::check_in()
    {
        if (!checked_out())
        {
            error("already checked in");
        }
        ch_out = false;
    }

    bool operator==(const Book &b1, const Book &b2)
    {
        return (b1.isbn() == b2.isbn());
    }

    bool operator!=(const Book &b1, const Book &b2)
    {
        return !(b1 == b2);
    }

    ostream &operator<<(ostream &os, const Book &b)
    {
        return os << b.title() << endl
               << b.author() << endl
               << b.isbn().n1 << '-'
               << b.isbn().n2 << '-'
               << b.isbn().n3 << '-'
               << b.isbn().n4 << '-'
               << b.isbn().x << endl;
    }

    Patron::Patron(const string &n, int cn, double f)
        : name(n), card_number(cn), fees(f)
    {
    }

    const Patron &default_patron()
    {
        static const Patron p("", 0, 0);
        return p;
    }

    Patron::Patron()
        : name(default_patron().get_name()),
          card_number(default_patron().get_number()),
          fees(default_patron().get_fees())
    {
    }

    void Patron::set_fee(double f)
    {
        if (f < 0)
        {
            error("set_fee(): fee cannot be smaller than zero");
        }
        fees = f;
    }

    bool owes_fee(const Patron &p)
    {
        return p.get_fees() > 0;
    }

    bool operator==(const Patron &p1, const Patron &p2)
    {
        return p1.get_number() == p2.get_number();
    }

    bool operator!=(const Patron &p1, const Patron &p2)
    {
        return !(p1 == p2);
    }

    Library::Transaction::Transaction(const Book &bb, const Patron &pp, const Chrono::Date &dd)
        : b(bb), p(pp), d(dd)
    {
    }

    const Library::Transaction &default_transaction()
    {
        static const Library::Transaction tt = Library::Transaction(Book(), Patron(), Chrono::Date());
        return tt;
    }

    Library::Transaction::Transaction()
        : b(default_transaction().b),
          p(default_transaction().p),
          d(default_transaction().d)
    {
    }

    Library::Library(const vector<Book> &b, const vector<Patron> &p, const vector<Transaction> &t)
        : books(b), patrons(p), transactions(t)
    {
    }

    const Library &default_library()
    {
        vector<Book> b;
        vector<Patron> p;
        vector<Library::Transaction> t;
        static const Library l(b, p, t);
        return l;
    }

    Library::Library()
        : books(default_library().get_books()),
          patrons(default_library().get_patrons()),
          transactions(default_library().get_transactions())
    {
    }

    void Library::add_book(const Book &b)
    {
        for (int i = 0; i < books.size(); ++i)
        {
            if (books[i] == b)
            {
                error("add_book(): book is already in library");
            }
        }
        books.push_back(b);
    }

    void Library::add_patron(const Patron &p)
    {
        for (int i = 0; i < patrons.size(); ++i)
        {
            if (patrons[i] == p)
            {
                error("add_patron(): patron is already registered");
            }
        }
        patrons.push_back(p);
    }

    void Library::check_out(const Book &b, const Patron &p, const Chrono::Date &d)
    {
        bool b_exists = false;
        int b_idx = 0;
        for (int i = 0; i < books.size(); ++i)
        {
            if (books[i] == b)
            {
                b_exists = true;
                b_idx = i;
                break;
            }
        }
        if (!b_exists)
        {
            error("check_out(): book is not in library");
        }

        if (books[b_idx].checked_out())
        {
            error("check_out(): book is already checked out");
        }

        bool p_exists = false;
        int p_idx = 0;
        for (int i = 0; i < patrons.size(); ++i)
        {
            if (patrons[i] == p)
            {
                p_exists = true;
                p_idx = i;
                break;
            }
        }
        if (!p_exists)
        {
            error("check_out(): patron is not registered");
        }

        if (patrons[p_idx].get_fees() > 0)
        {
            error("check_out(): patron owes library fees");
        }

        transactions.push_back(Transaction(books[b_idx], patrons[p_idx], d));
        books[b_idx].check_out();
    }

    void Library::set_fee(const Patron &p, double f)
    {
        int idx = 0;
        bool exists = false;
        for (int i = 0; i < patrons.size(); ++i)
        {
            if (patrons[i] == p)
            {
                exists = true;
                idx = i;
                break;
            }
        }
        if (!exists)
        {
            error("Library::set_fee(): patron does not exist");
        }
        patrons[idx].set_fee(f);
    }

    vector<Patron> Library::get_debtors() const
    {
        vector<Patron> debtors;
        for (int i = 0; i < patrons.size(); ++i)
        {
            if (patrons[i].get_fees() > 0)
            {
                debtors.push_back(patrons[i]);
            }
        }
        return debtors;
    }

}

using Liber::Library;
using Liber::Book;
using Liber::ISBN;
using Liber::Patron;
using Chrono::Date;
using Chrono::leapyear;
using Chrono::day_in_year;
using Chrono::n_leapyears;
using Chrono::days_linear;
using Chrono::day_of_week;

void test_liber()
{
    Library my_lib;

    Book my_book(ISBN(9780, 4390, 2348, 0, '1'),
                 "Hunger Games, The",
                 "Collins, Suzanne",
                 2008,
                 Book::fiction,
                 false);
    my_lib.add_book(my_book);

    Book my_book2(ISBN(9780, 4393, 5807, 0, '1'),
                  "Harry Potter and the Order of the Phoenix",
                  "Rowling, J.K.",
                  2003,
                  Book::children,
                  false);
    my_lib.add_book(my_book2);

    my_lib.add_book(Book(ISBN(9781, 4165, 3932, 0, '2'),
                         "Einstein: His Life and Universe",
                         "Isaacson, Walter",
                         2007,
                         Book::biography,
                         false));

    my_lib.add_book(Book(ISBN(9780, 3160, 6760, 0, '7'),
                         "Lone Survivor",
                         "Luttrell, Marcus",
                         2008,
                         Book::nonfiction,
                         false));

    my_lib.add_book(Book(ISBN(1234, 5678, 1234, 0, 'x'),
                         "Triathlete Issue 2/14",
                         "Competitor Group",
                         2014,
                         Book::periodical,
                         false));

    cout << "All my books:\n\n";
    const vector<Book> &books = my_lib.get_books();
    for (int i = 0; i < books.size(); ++i)
    {
        cout << books[i] << endl;
    }

    Patron my_patron1 = Patron("Forrest, Kara", 100, 0);
    my_lib.add_patron(my_patron1);
    Patron my_patron2 = Patron("Wuethrich, Benjamin", 101, 0);
    my_lib.add_patron(my_patron2);
    my_lib.add_patron(Patron("Buehler, Catriona", 102, 0));
    my_lib.add_patron(Patron("Schaerli, Tobias", 103, 0));
    my_lib.add_patron(Patron("Bieler, Ueli", 104, 0));

    cout << "List of patrons:\n\n";
    const vector<Patron> &patrons = my_lib.get_patrons();
    for (int i = 0; i < patrons.size(); ++i)
    {
        cout << patrons[i].get_name() << ", " << patrons[i].get_number() << ", " << patrons[i].get_fees() << endl;
    }

    my_lib.set_fee(my_patron1, 10);
    my_lib.set_fee(my_patron2, 15);

    cout << "\nList of debtors:\n\n";
    vector<Patron> debtors = my_lib.get_debtors();
    for (int i = 0; i < debtors.size(); ++i)
    {
        cout << debtors[i].get_name() << ", " << debtors[i].get_number() << ", " << debtors[i].get_fees() << endl;
    }

    my_lib.check_out(my_book, patrons[2], Date(2014, Date::jan, 31));
    my_lib.check_out(my_book2, patrons[3], Date());

    cout << "\nTransactions:\n";
    const vector<Library::Transaction> &transactions = my_lib.get_transactions();
    for (int i = 0; i < transactions.size(); ++i)
    {
        cout << transactions[i].b <<
             transactions[i].d << endl <<
             transactions[i].p.get_name() << endl;
    }
}

void test_leapyear()
{
    if (leapyear(2000))
    {
        cout << "2000 is a leap year\n";
    }
    if (leapyear(2004))
    {
        cout << "2004 is a leap year\n";
    }
    if (leapyear(2005))
    {
        cout << "2005 is a leap year\n";
    }
    if (leapyear(2100))
    {
        cout << "2100 is a leap year\n";
    }
}

void test_lineardate()
{
    cout << "Jan 1, 2000 is day #" <<
         day_in_year(Date(2000, Date::jan, 1)) <<
         " of the year.\n";
    cout << "Feb 29, 2000 is day #" <<
         day_in_year(Date(2000, Date::feb, 29)) <<
         " of the year.\n";
    cout << "Mar 1, 2000 is day #" <<
         day_in_year(Date(2000, Date::mar, 1)) <<
         " of the year.\n";

    cout << "Number of leap years since 1970:\n" <<
         "1971: " << n_leapyears(1971) << endl <<
         "1972: " << n_leapyears(1972) << endl <<
         "1973: " << n_leapyears(1973) << endl <<
         "1974: " << n_leapyears(1974) << endl <<
         "2000: " << n_leapyears(2000) << endl <<
         "2001: " << n_leapyears(2001) << endl <<
         "2101: " << n_leapyears(2101) << endl;

    cout << "Days since Jan 1, 1970:\n" <<
         "Jan 1, 1970: " << days_linear(Date(1970, Date::jan, 1)) << endl <<
         "Mar 1, 2001: " << days_linear(Date(2001, Date::mar, 1)) << endl <<
         "Jan 31, 2014: " << days_linear(Date(2014, Date::jan, 31)) << endl <<
         "Nov 30, 2111: " << days_linear(Date(2111, Date::nov, 30)) << endl;

    cout << "Day of week:\n" <<
         "Jan 1, 1970: " << day_of_week(Date(1970, Date::jan, 1)) << endl <<
         "Sep 11, 2001: " << day_of_week(Date(2001, Date::sep, 11)) << endl <<
         "Jan 31, 2014: " << day_of_week(Date(2014, Date::jan, 31)) << endl;
}

int main(int argc, const char *argv[])
{
    try
    {
        test_liber();
        test_leapyear();
        test_lineardate();

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
All my books:

Hunger Games, The
Collins, Suzanne
9780-4390-2348-0-1

Harry Potter and the Order of the Phoenix
Rowling, J.K.
9780-4393-5807-0-1

Einstein: His Life and Universe
Isaacson, Walter
9781-4165-3932-0-2

Lone Survivor
Luttrell, Marcus
9780-3160-6760-0-7

Triathlete Issue 2/14
Competitor Group
1234-5678-1234-0-x

List of patrons:

Forrest, Kara, 100, 0
Wuethrich, Benjamin, 101, 0
Buehler, Catriona, 102, 0
Schaerli, Tobias, 103, 0
Bieler, Ueli, 104, 0

List of debtors:

Forrest, Kara, 100, 10
Wuethrich, Benjamin, 101, 15

Transactions:
Hunger Games, The
Collins, Suzanne
9780-4390-2348-0-1
(2014,1,31)
Buehler, Catriona
Harry Potter and the Order of the Phoenix
Rowling, J.K.
9780-4393-5807-0-1
(2001,1,1)
Schaerli, Tobias
2000 is a leap year
2004 is a leap year
Jan 1, 2000 is day #1 of the year.
Feb 29, 2000 is day #60 of the year.
Mar 1, 2000 is day #61 of the year.
Number of leap years since 1970:
1971: 0
1972: 0
1973: 1
1974: 1
2000: 7
2001: 8
2101: 32
Days since Jan 1, 1970:
Jan 1, 1970: 0
Mar 1, 2001: 11382
Jan 31, 2014: 16101
Nov 30, 2111: 51832
Day of week:
Jan 1, 1970: Thursday
Sep 11, 2001: Tuesday
Jan 31, 2014: Friday

ch15_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Day
{
public:
    explicit Day(int d) : val(d) { }
    int val;
};

ostream &operator<<(ostream &os, const Day &d)
{
    os << d.val;
    return os;
}

class Month
{
public:
    explicit Month(int m) : val(m) { }
    int val;
};

ostream &operator<<(ostream &os, const Month &m)
{
    os << m.val;
    return os;
}

class Year
{
public:
    explicit Year(int y) : val(y) { }
    int val;
};

ostream &operator<<(ostream &os, const Year &y)
{
    os << y.val;
    return os;
}

class Date
{
private:
    Day d;
    Month m;
    Year y;
public:
    Date() : d(1), m(1), y(1970) { }
    Date(const Day &day, const Month &month, const Year &year) : d(day), m(month), y(year) { }
    Date(const Date &r) : d(r.d), m(r.m), y(r.y) { }
    const Day &day() const
    {
        return d;
    }
    const Month &month() const
    {
        return m;
    }
    const Year &year() const
    {
        return y;
    }
};

ostream &operator<<(ostream &os, const Date &date)
{
    os << date.day() << '.' << date.month() << '.' << date.year();
    return os;
}

istream &operator>>(istream &is, Date &date)
{
    int d;
    int m;
    int y;
    char ch1;
    char ch2;
    is >> d;
    if (!is)
    {
        return is;
    }
    is >> ch1;
    if (!is)
    {
        return is;
    }
    is >> m;
    if (!is)
    {
        return is;
    }
    is >> ch2;
    if (!is)
    {
        return is;
    }
    is >> y;
    if (!is)
    {
        return is;
    }
    if (ch1 != '.' || ch2 != '.')
    {
        is.clear(std::ios_base::failbit);
        return is;
    }
    date = Date(Day(d), Month(m), Year(y));
    return is;
}

class Purchase
{
private:
    string n;
    double up;
    int c;
public:
    Purchase() : n(""), up(0.0), c(0) { }
    Purchase(const string &name, double unit_price, int count) : n(name), up(unit_price), c(count) { }
    const string &name() const
    {
        return n;
    }
    double unit_price() const
    {
        return up;
    }
    int count() const
    {
        return c;
    }
};

ostream &operator<<(ostream &os, const Purchase &p)
{
    os << p.name() << " | " << p.unit_price() << " | " << p.count();
    return os;
}

istream &operator>>(istream &is, Purchase &p)
{
    string name;
    getline(is, name, '|');
    if (!is)
    {
        return is;
    }
    if (name.size() == 0)
    {
        is.clear(std::ios_base::failbit);
        return is;
    }
    name.pop_back();
    double unit_price;
    char ch2;
    int count;
    is >> unit_price;
    if (!is)
    {
        return is;
    }
    is >> ch2;
    if (!is)
    {
        return is;
    }
    is >> count;
    if (!is)
    {
        return is;
    }
    if (ch2 != '|')
    {
        is.clear(std::ios_base::failbit);
        return is;
    }
    p = Purchase(name, unit_price, count);
    return is;
}

class Order
{
private:
    string n;
    string addr;
    Date d;
    vector<Purchase> vp;
public:
    Order() : n(), addr(), d(), vp() { }
    Order(const string &name, const string &address, const Date &date, const vector<Purchase> &vpurchases)
        : n(name), addr(address), d(date), vp(vpurchases) { }
    const string &name() const
    {
        return n;
    }
    const string &address() const
    {
        return addr;
    }
    const Date &date() const
    {
        return d;
    }
    int n_purchases() const
    {
        return vp.size();
    }
    const Purchase &purchase(int i) const
    {
        return vp[i];
    }
};

ostream &operator<<(ostream &os, const Order &o)
{
    os << o.name() << '\n' << o.address() << '\n' << o.date() << '\n';
    for (int i = 0; i < o.n_purchases(); ++i)
    {
        os << o.purchase(i) << '\n';
    }
    return os;
}

istream &operator>>(istream &is, Order &o)
{
    char ch;
    is >> ch;
    if (!is)
    {
        return is;
    }
    is.unget();
    string name;
    getline(is, name, '\n');
    if (!is)
    {
        return is;
    }
    string address;
    getline(is, address, '\n');
    if (!is)
    {
        return is;
    }
    Date date;
    is >> date;
    if (!is)
    {
        return is;
    }
    is.ignore();
    string line;
    vector<Purchase> purchases;
    while (getline(is, line, '\n') && line != "")
    {
        Purchase purchase;
        istringstream iss(line);
        iss >> purchase;
        purchases.push_back(purchase);
    }
    is.clear();
    o = Order(name, address, date, purchases);
    return is;
}

template<typename T>
class Sort_by_name
{
public:
    bool operator()(const T &a, const T &b) const
    {
        return a.name() < b.name();
    }
};

template<typename T>
class Sort_by_address
{
public:
    bool operator()(const T &a, const T &b) const
    {
        return a.address() < b.address();
    }
};

template<typename Cont>
void read_orders_from_file(Cont &c, const string &fname)
{
    ifstream ifs(fname.c_str());
    if (!ifs)
    {
        error("can't open file " + fname);
    }
    Order o;
    while (ifs >> o)
    {
        c.push_back(o);
    }
}

template<typename Iter>
void write_orders_to_file(Iter first, Iter last, const string &fname)
{
    ofstream ofs(fname.c_str());
    if (!ofs)
    {
        error("can't open file " + fname);
    }
    while (first != last)
    {
        ofs << *first << '\n';
        ++first;
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        const string ifname1 = "ch15_p05_in1.txt";
        vector<Order> vo;
        read_orders_from_file(vo, ifname1);

        sort(vo.begin(), vo.end(), Sort_by_name<Order>());
        for (int i = 0; i < vo.size(); ++i)
        {
            cout << vo[i] << '\n';
        }

        const string ofname1 = "ch15_p05_out1.txt";
        write_orders_to_file(vo.begin(), vo.end(), ofname1);

        const string ifname2 = "ch15_p05_in2.txt";
        list<Order> lo;
        read_orders_from_file(lo, ifname2);

        cout << "\n";
        lo.sort(Sort_by_address<Order>());
        typedef list<Order>::iterator Liter;
        for (Liter it = lo.begin(); it != lo.end(); ++it)
        {
            cout << *it << '\n';
        }

        const string ofname2 = "ch15_p05_out2.txt";
        write_orders_to_file(lo.begin(), lo.end(), ofname2);

        lo.sort(Sort_by_name<Order>());
        vector<Order> vo_merge(vo.size() + lo.size());
        merge(vo.begin(), vo.end(), lo.begin(), lo.end(), vo_merge.begin(), Sort_by_name<Order>());
        const string ofname3 = "ch15_p05_out3.txt";
        write_orders_to_file(vo_merge.begin(), vo_merge.end(), ofname3);

        set<Order, Sort_by_name<Order>> so;
        typedef vector<Order>::iterator Viter;
        for (Viter it = vo_merge.begin(); it != vo_merge.end(); ++it)
        {
            so.insert(*it);
        }

        cout << "\n";
        double val_t = 0;
        double val_s;
        for (set<Order>::iterator it = so.begin(); it != so.end(); ++it)
        {
            cout << *it << '\n';
            val_s = 0;
            for (int i = 0; i < (*it).n_purchases(); ++i)
            {
                val_s += (*it).purchase(i).count() * (*it).purchase(i).unit_price();
                val_t += (*it).purchase(i).count() * (*it).purchase(i).unit_price();
            }
            cout << "Total of the order: " << val_s << "\n";
            cout << "Running total so far: " << val_t << "\n\n";
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Ardelia Allington
16 Warren Close, Ryton-on-Dunsmore, Coventry, Warwickshire CV8 3JZ, UK
20.11.2014
Frozen Little Golden Book | 2.17 | 3
Humans of New York | 17.99 | 3

Babette Brennan
4 Livera Street, Evanton, Dingwall, Highland IV16, UK
6.2.2014
Yes Please | 14.5 | 2
The Book with No Pictures | 10.79 | 5
Ultimate Sticker Book: Frozen | 4.19 | 5

Cliff Cantin
1 Bealings Road, Martlesham, Woodbridge, Suffolk IP12 4RW, UK
15.1.2014
Diary of a Wimpy Kid | 7.75 | 2

Emilee Eiler
29 Clayfield Road, Bretforton, Evesham, Worcestershire WR11 7HS, UK
26.9.2014
What If? | 14.4 | 5

Ha Hollowell
21 Heddon Place, Birmingham, West Midlands B7 4EX, UK
23.2.2014
Laugh-Out-Loud Jokes for Kids | 2.99 | 1
Unbroken: A World War II Story | 9.6 | 5

Logan Laino
4 Denmark Rise, North Cave, Brough, East Riding of Yorkshire HU15 2NB, UK
6.3.2013
Diary of a Wimpy Kid | 7.75 | 5
Killing Patton | 15.41 | 5

Lucius Legrand
16 Mundys Field, Ruan Minor, Helston, Cornwall TR12 7LF, UK
1.1.2013
Yes Please | 14.5 | 2
Minecraft: The Complete Handbook | 19.18 | 1

Matt Manahan
9 Haslam Crescent, Sheffield, South Yorkshire S8 7GT, UK
21.5.2013
Knock-Knock Jokes for Kids | 3.23 | 1
Killing Patton | 15.41 | 2
Thug Kitchen | 14.9 | 4

Nicolette New
9-11 Nevill Road, Brighton and Hove, Brighton, East Sussex BN2 7HH, UK
17.6.2013
The Day the Crayons Quit | 9.12 | 5

Tyler Tevis
New Road, Worcester, Worcestershire WR2, UK
6.4.2013
The Boys in the Boat | 10.2 | 2


Cliff Cantin
1 Bealings Road, Martlesham, Woodbridge, Suffolk IP12 4RW, UK
15.1.2014
Diary of a Wimpy Kid | 7.75 | 2

Augustus Amyx
17 Manner Street, Macduff, Aberdeenshire AB44 1SE, UK
28.4.2014
Ultra Pro 25.9 | 8.29 | 2

Bari Barnette
1A Orchard Castle, Cardiff, Cardiff CF14 9BA, UK
12.8.2013
FlipBelt | 27.19 | 1
Spalding NBA Street Basketball | 10.59 | 1

Ha Hollowell
21 Heddon Place, Birmingham, West Midlands B7 4EX, UK
23.2.2014
Laugh-Out-Loud Jokes for Kids | 2.99 | 1
Unbroken: A World War II Story | 9.6 | 5

Charolette Cusick
352-354 Birmingham Road, Sutton Coldfield, West Midlands B72 1YH, UK
4.7.2013
Lifestraw Personal Water Filter | 19.9 | 3
Zipp A-Frame Hand Warmer | 9.83 | 2
New Era On field Hat | 14.4 | 1

Logan Laino
4 Denmark Rise, North Cave, Brough, East Riding of Yorkshire HU15 2NB, UK
6.3.2013
Diary of a Wimpy Kid | 7.75 | 5
Killing Patton | 15.41 | 5

Roman Rierson
40 Anyards Road, Cobham, Surrey KT11 2LA, UK
22.11.2014
Black Mountain Resistance Bands | 29.99 | 2

Miguelina Marinelli
5 Stevens Place, Gourock, Inverclyde PA19 1YY, UK
16.2.2014
Wrist Wraps + Lifting Straps | 16.95 | 3
Razor A Kick Scooter | 27.72 | 3
Tac Force TF-705 Series | 3.96 | 2
Victorinox Swiss Army Classic | 9.99 | 2

Bernita Biggerstaff
New Forest National Park, 1 Yewtree Cottages, Lyndhurst, Hampshire SO43 7AY, UK
25.4.2014
Nalgene Tritan Wide Mouth | 5.75 | 3
SoundAsleep Dream Series Mattress | 119.95 | 2
Replacement Wrist Band | 0.65 | 1

Clarine Chance
RAF Mildenhall, 139A Lancaster Road, Beck Row, Bury Saint Edmunds, Suffolk IP28 8HE, UK
26.10.2013
Zippo Lighter Fluid | 7.09 | 3
Polar FT4 HRM | 50.2 | 2
SKLZ Pro Mini Basketball Hoop | 19.99 | 1


Ardelia Allington
16 Warren Close, Ryton-on-Dunsmore, Coventry, Warwickshire CV8 3JZ, UK
20.11.2014
Frozen Little Golden Book | 2.17 | 3
Humans of New York | 17.99 | 3

Total of the order: 60.48
Running total so far: 60.48

Augustus Amyx
17 Manner Street, Macduff, Aberdeenshire AB44 1SE, UK
28.4.2014
Ultra Pro 25.9 | 8.29 | 2

Total of the order: 16.58
Running total so far: 77.06

Babette Brennan
4 Livera Street, Evanton, Dingwall, Highland IV16, UK
6.2.2014
Yes Please | 14.5 | 2
The Book with No Pictures | 10.79 | 5
Ultimate Sticker Book: Frozen | 4.19 | 5

Total of the order: 103.9
Running total so far: 180.96

Bari Barnette
1A Orchard Castle, Cardiff, Cardiff CF14 9BA, UK
12.8.2013
FlipBelt | 27.19 | 1
Spalding NBA Street Basketball | 10.59 | 1

Total of the order: 37.78
Running total so far: 218.74

Bernita Biggerstaff
New Forest National Park, 1 Yewtree Cottages, Lyndhurst, Hampshire SO43 7AY, UK
25.4.2014
Nalgene Tritan Wide Mouth | 5.75 | 3
SoundAsleep Dream Series Mattress | 119.95 | 2
Replacement Wrist Band | 0.65 | 1

Total of the order: 257.8
Running total so far: 476.54

Charolette Cusick
352-354 Birmingham Road, Sutton Coldfield, West Midlands B72 1YH, UK
4.7.2013
Lifestraw Personal Water Filter | 19.9 | 3
Zipp A-Frame Hand Warmer | 9.83 | 2
New Era On field Hat | 14.4 | 1

Total of the order: 93.76
Running total so far: 570.3

Clarine Chance
RAF Mildenhall, 139A Lancaster Road, Beck Row, Bury Saint Edmunds, Suffolk IP28 8HE, UK
26.10.2013
Zippo Lighter Fluid | 7.09 | 3
Polar FT4 HRM | 50.2 | 2
SKLZ Pro Mini Basketball Hoop | 19.99 | 1

Total of the order: 141.66
Running total so far: 711.96

Cliff Cantin
1 Bealings Road, Martlesham, Woodbridge, Suffolk IP12 4RW, UK
15.1.2014
Diary of a Wimpy Kid | 7.75 | 2

Total of the order: 15.5
Running total so far: 727.46

Emilee Eiler
29 Clayfield Road, Bretforton, Evesham, Worcestershire WR11 7HS, UK
26.9.2014
What If? | 14.4 | 5

Total of the order: 72
Running total so far: 799.46

Ha Hollowell
21 Heddon Place, Birmingham, West Midlands B7 4EX, UK
23.2.2014
Laugh-Out-Loud Jokes for Kids | 2.99 | 1
Unbroken: A World War II Story | 9.6 | 5

Total of the order: 50.99
Running total so far: 850.45

Logan Laino
4 Denmark Rise, North Cave, Brough, East Riding of Yorkshire HU15 2NB, UK
6.3.2013
Diary of a Wimpy Kid | 7.75 | 5
Killing Patton | 15.41 | 5

Total of the order: 115.8
Running total so far: 966.25

Lucius Legrand
16 Mundys Field, Ruan Minor, Helston, Cornwall TR12 7LF, UK
1.1.2013
Yes Please | 14.5 | 2
Minecraft: The Complete Handbook | 19.18 | 1

Total of the order: 48.18
Running total so far: 1014.43

Matt Manahan
9 Haslam Crescent, Sheffield, South Yorkshire S8 7GT, UK
21.5.2013
Knock-Knock Jokes for Kids | 3.23 | 1
Killing Patton | 15.41 | 2
Thug Kitchen | 14.9 | 4

Total of the order: 93.65
Running total so far: 1108.08

Miguelina Marinelli
5 Stevens Place, Gourock, Inverclyde PA19 1YY, UK
16.2.2014
Wrist Wraps + Lifting Straps | 16.95 | 3
Razor A Kick Scooter | 27.72 | 3
Tac Force TF-705 Series | 3.96 | 2
Victorinox Swiss Army Classic | 9.99 | 2

Total of the order: 161.91
Running total so far: 1269.99

Nicolette New
9-11 Nevill Road, Brighton and Hove, Brighton, East Sussex BN2 7HH, UK
17.6.2013
The Day the Crayons Quit | 9.12 | 5

Total of the order: 45.6
Running total so far: 1315.59

Roman Rierson
40 Anyards Road, Cobham, Surrey KT11 2LA, UK
22.11.2014
Black Mountain Resistance Bands | 29.99 | 2

Total of the order: 59.98
Running total so far: 1375.57

Tyler Tevis
New Road, Worcester, Worcestershire WR2, UK
6.4.2013
The Boys in the Boat | 10.2 | 2

Total of the order: 20.4
Running total so far: 1395.97



 wc -l ch15_p05*.txt
  57 ch15_p05_in1.txt
  61 ch15_p05_in2.txt
  58 ch15_p05_out1.txt
  62 ch15_p05_out2.txt
 120 ch15_p05_out3.txt
 358 total



 cat ch15_p05_in1.txt
Lucius Legrand
16 Mundys Field, Ruan Minor, Helston, Cornwall TR12 7LF, UK
01.01.2013
Yes Please | 14.50 | 2
Minecraft: The Complete Handbook | 19.18 | 1

Ha Hollowell
21 Heddon Place, Birmingham, West Midlands B7 4EX, UK
23.02.2014
Laugh-Out-Loud Jokes for Kids | 2.99 | 1
Unbroken: A World War II Story | 9.60 | 5

Emilee Eiler
29 Clayfield Road, Bretforton, Evesham, Worcestershire WR11 7HS, UK
26.09.2014
What If? | 14.40 | 5

Matt Manahan
9 Haslam Crescent, Sheffield, South Yorkshire S8 7GT, UK
21.05.2013
Knock-Knock Jokes for Kids | 3.23 | 1
Killing Patton | 15.41 | 2
Thug Kitchen | 14.90 | 4

Babette Brennan
4 Livera Street, Evanton, Dingwall, Highland IV16, UK
06.02.2014
Yes Please | 14.50 | 2
The Book with No Pictures | 10.79 | 5
Ultimate Sticker Book: Frozen | 4.19 | 5

Cliff Cantin
1 Bealings Road, Martlesham, Woodbridge, Suffolk IP12 4RW, UK
15.01.2014
Diary of a Wimpy Kid | 7.75 | 2

Ardelia Allington
16 Warren Close, Ryton-on-Dunsmore, Coventry, Warwickshire CV8 3JZ, UK
20.11.2014
Frozen Little Golden Book | 2.17 | 3
Humans of New York | 17.99 | 3

Nicolette New
9-11 Nevill Road, Brighton and Hove, Brighton, East Sussex BN2 7HH, UK
17.06.2013
The Day the Crayons Quit | 9.12 | 5

Tyler Tevis
New Road, Worcester, Worcestershire WR2, UK
06.04.2013
The Boys in the Boat | 10.20 | 2

Logan Laino
4 Denmark Rise, North Cave, Brough, East Riding of Yorkshire HU15 2NB, UK
06.03.2013
Diary of a Wimpy Kid | 7.75 | 5
Killing Patton | 15.41 | 5



cat ch15_p05_in2.txt
Ha Hollowell
21 Heddon Place, Birmingham, West Midlands B7 4EX, UK
23.02.2014
Laugh-Out-Loud Jokes for Kids | 2.99 | 1
Unbroken: A World War II Story | 9.60 | 5

Cliff Cantin
1 Bealings Road, Martlesham, Woodbridge, Suffolk IP12 4RW, UK
15.01.2014
Diary of a Wimpy Kid | 7.75 | 2

Logan Laino
4 Denmark Rise, North Cave, Brough, East Riding of Yorkshire HU15 2NB, UK
06.03.2013
Diary of a Wimpy Kid | 7.75 | 5
Killing Patton | 15.41 | 5

Charolette Cusick
352-354 Birmingham Road, Sutton Coldfield, West Midlands B72 1YH, UK
04.07.2013
Lifestraw Personal Water Filter | 19.90 | 3
Zipp A-Frame Hand Warmer | 9.83 | 2
New Era On field Hat | 14.40 | 1

Bari Barnette
1A Orchard Castle, Cardiff, Cardiff CF14 9BA, UK
12.08.2013
FlipBelt | 27.19 | 1
Spalding NBA Street Basketball | 10.59 | 1

Clarine Chance
RAF Mildenhall, 139A Lancaster Road, Beck Row, Bury Saint Edmunds, Suffolk IP28 8HE, UK
26.10.2013
Zippo Lighter Fluid | 7.09 | 3
Polar FT4 HRM | 50.20 | 2
SKLZ Pro Mini Basketball Hoop | 19.99 | 1

Miguelina Marinelli
5 Stevens Place, Gourock, Inverclyde PA19 1YY, UK
16.02.2014
Wrist Wraps + Lifting Straps | 16.95 | 3
Razor A Kick Scooter | 27.72 | 3
Tac Force TF-705 Series | 3.96 | 2
Victorinox Swiss Army Classic | 9.99 | 2

Bernita Biggerstaff
New Forest National Park, 1 Yewtree Cottages, Lyndhurst, Hampshire SO43 7AY, UK
25.04.2014
Nalgene Tritan Wide Mouth | 5.75 | 3
SoundAsleep Dream Series Mattress | 119.95 | 2
Replacement Wrist Band | 0.65 | 1

Augustus Amyx
17 Manner Street, Macduff, Aberdeenshire AB44 1SE, UK
28.04.2014
Ultra Pro 25.9 | 8.29 | 2

Roman Rierson
40 Anyards Road, Cobham, Surrey KT11 2LA, UK
22.11.2014
Black Mountain Resistance Bands | 29.99 | 2

ch15_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::logic_error;
using std::exception;
using std::transform;
using std::inserter;
using std::back_inserter;
using std::ostream_iterator;
using std::istream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

std::random_device rd;
std::mt19937 gen(rd());

int getRandomNumber(const int &min, const int &max)
{
    return std::uniform_int_distribution<int> {min, max}(gen);
}

typedef std::vector<std::string> Rule;
typedef std::vector<Rule> Rule_collection;
typedef std::map<std::string, Rule_collection> Grammar;

template<typename T>
T median(vector<T> v)
{
    typedef typename vector<T>::size_type vec_sz;
    vec_sz size = v.size();
    if (size == 0)
    {
        throw domain_error("median of empty vector");
    }
    sort(v.begin(), v.end());

    vec_sz mid = size / 2;
    return size % 2 == 0 ? (v[mid] + v[mid - 1]) / 2 : v[mid];
}

double average(const vector<double> &v)
{
    return accumulate(v.begin(), v.end(), 0.0) / v.size();
}

istream &count_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    for (map<string, int>::const_iterator it = counters.begin(); it != counters.end(); ++it)
    {
        os << it->first << "\t" << it->second << endl;
    }

    return is;
}

pair<int, string> flip_count_pair(const pair<string, int> &p)
{
    return pair<int, string>(p.second, p.first);
}

istream &count_sort_words(istream &is, ostream &os)
{
    string s;
    map<string, int> counters;

    while (is >> s)
    {
        ++counters[s];
    }

    multimap<int, string> counters_r;
    transform(counters.begin(), counters.end(), inserter(counters_r, counters_r.begin()), flip_count_pair);

    for (multimap<int, string>::const_iterator it = counters_r.begin(); it != counters_r.end(); ++it)
    {
        os << it->second << "\t" << it->first << endl;
    }

    return is;
}

bool space(char c)
{
    return isspace(c) != 0;
}

bool not_space(char c)
{
    return !isspace(c);
}

vector<string> split(const string &str)
{
    typedef string::const_iterator iter;
    vector<string> ret;

    iter i = str.begin();
    while (i != str.end())
    {
        i = find_if(i, str.end(), not_space);

        iter j = find_if(i, str.end(), space);

        if (i != j)
        {
            ret.push_back(string(i, j));
            i = j;
        }
    }
    return ret;
}

list<string> split_to_list(const string &str)
{
    vector<string> ret = split(str);
    list <string> list;
    copy(ret.begin(), ret.end(), back_inserter(list));

    return list;
}

template <typename T>
void split(const string &str, T os)
{
    typedef string::const_iterator iter;
    iter i = str.begin();
    while (i != str.end())
    {
        i = std::find_if(i, str.end(), not_space);

        iter j = std::find_if(i, str.end(), space);

        if (i != j)
        {
            *os++ = string(i, j);
            i = j;
        }
    }
}

map<string, vector<int> > xref(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    return ret;
}

map<string, vector<int> > xref_unique(istream &in, vector<string> find_words(const string &))
{
    string line;
    int line_number = 0;
    map<string, vector<int> > ret;

    while (getline(in, line, '\n'))
    {
        ++line_number;

        vector<string> words = find_words(line);

        for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it)
        {
            ret[*it].push_back(line_number);
        }
    }

    for (map<string, vector<int> >::iterator it = ret.begin(); it != ret.end(); ++it)
    {
        it->second.resize( distance(it->second.begin(), unique(it->second.begin(), it->second.end()) ) );
    }

    return ret;
}

template <typename Out>
void xref_uniq(istream &in, Out os, vector<string> find_words(const string &))
{
    const map<string, vector<int> > ret = xref_unique(in, find_words);

    for (map<string, vector<int> >::const_iterator it = ret.begin(); it != ret.end(); ++it)
    {
        stringstream ss;
        ss << it->first << " occurs on line(s): ";

        vector<int>::const_iterator line_it = it->second.begin();
        ss << *line_it++;

        while (line_it != it->second.end())
        {
            ss << ", " << *line_it++;
        }

        *os++ = ss.str();
    }

    in.clear();
    in.seekg(0, std::ios::beg);
}

bool bracketed(const string &s)
{
    return s.size() > 1 && s[0] == '<' && s[s.size() - 1] == '>';
}

Grammar read_grammar(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        vector<string> entry = split(line);

        if (entry.size() > 1)
        {
            ret[entry[0]].push_back( Rule( entry.begin() + 1, entry.end() ) );
        }
    }

    return ret;
}

Grammar read_grammar_list(istream &in)
{
    Grammar ret;
    string line;

    while (getline(in, line, '\n'))
    {
        list<string> entry = split_to_list(line);

        if (entry.size() > 1)
        {
            ret[entry.front()].push_back( Rule( ++entry.begin(), entry.end() ) );
        }
    }

    return ret;
}
void gen_aux(const Grammar &g, const string &word, vector<string> &ret)
{
    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[getRandomNumber(0, c.size() - 1)];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}

void gen_aux(const Grammar &g, const string &word, list<string> &ret)
{
    if (!bracketed(word))
    {
        ret.push_back(word);
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[getRandomNumber(0, c.size() - 1)];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, ret);
        }
    }
}

template <typename Out>
void gen_aux(const Grammar &g, const string &word, Out os)
{
    if (!bracketed(word))
    {
        *os++ = word;
    }
    else
    {
        Grammar::const_iterator it = g.find(word);

        if (it == g.end())
        {
            throw logic_error("empty rule");
        }

        const Rule_collection &c = it->second;

        const Rule &r = c[getRandomNumber(0, c.size() - 1)];

        for (Rule::const_iterator i = r.begin(); i != r.end(); ++i)
        {
            gen_aux(g, *i, os);
        }
    }
}

vector<string> gen_sentence(const Grammar &g)
{
    vector<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

list<string> gen_sentence_list(const Grammar &g)
{
    list<string> ret;
    gen_aux(g, "<sentence>", ret);

    return ret;
}

template <typename Out>
void gen_sentence(const Grammar &g, Out os)
{
    gen_aux(g, "<sentence>", os);
}

int generate_sentence_list_output(string file)
{
    ifstream infile;
    infile.open(file);
    list<string> sentence = gen_sentence_list(read_grammar_list(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;

    return 0;
}

vector<string> gen_sentence_vectors(const Grammar &g)
{
    vector<string> ret;
    vector<string> rules;

    rules.push_back("<sentence>");

    while (!rules.empty())
    {
        string segment = rules.back();
        rules.pop_back();

        if (!bracketed(segment))
        {
            ret.push_back(segment);
        }
        else
        {

            Grammar::const_iterator it = g.find(segment);

            if (it == g.end())
            {
                throw logic_error("empty rule");
            }

            const Rule_collection &c = it->second;

            const Rule &r = c[getRandomNumber(0, c.size() - 1)];

            for (Rule::const_reverse_iterator i = r.rbegin(); i != r.rend(); ++i)
            {
                rules.push_back(*i);
            }
        }
    }

    return ret;
}

int generate_sentence_vectors_output(string file)
{
    ifstream infile;
    infile.open(file);
    vector<string> sentence = gen_sentence_vectors(read_grammar(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;

    return 0;
}

int test_generate_sentence(string file)
{
    ifstream infile;
    infile.open(file);
    Grammar g = read_grammar(infile);

    vector<string> sentence_vector;
    list<string> sentence_list;

    gen_sentence(g, back_inserter(sentence_vector));
    gen_sentence(g, back_inserter(sentence_list));
    gen_sentence(g, ostream_iterator<string>(cout, " "));

    cout << endl;

    vector<string>::const_iterator itv = sentence_vector.begin();
    if (!sentence_vector.empty())
    {
        cout << *itv++;
    }
    while (itv != sentence_vector.end())
    {
        cout << " " << *itv++;
    }
    cout << endl;

    list<string>::const_iterator itl = sentence_list.begin();
    if (!sentence_list.empty())
    {
        cout << *itl++;
    }
    while (itl != sentence_list.end())
    {
        cout << " " << *itl++;
    }
    cout << endl;

    return 0;
}

bool not_url_char(char c)
{
    static const string url_ch = "~;/?:@=&$-_.+!*'(),";

    return !(isalnum(c) || find(url_ch.begin(), url_ch.end(), c) != url_ch.end());
}

string::const_iterator url_beg(string::const_iterator b, string::const_iterator e)
{
    static const string sep = "://";

    typedef string::const_iterator iter;

    iter i = b;

    while ( ( i = search(i, e, sep.begin(), sep.end()) ) != e )
    {

        if (i != b && i + sep.size() != e)
        {

            iter beg = i;
            while (beg != b && isalpha(beg[-1]))
            {
                --beg;
            }

            if (beg != i && !not_url_char( i[sep.size()] ))
            {
                return beg;
            }
        }

        i += sep.size();
    }

    return e;
}

string::const_iterator url_end(string::const_iterator b, string::const_iterator e)
{
    return find_if(b, e, not_url_char);
}

vector<string> find_urls(const string &s)
{
    vector<string> ret;
    typedef string::const_iterator iter;
    iter b = s.begin(), e = s.end();

    while (b != e)
    {

        b = url_beg(b, e);

        if (b != e)
        {
            iter after = url_end(b, e);

            ret.push_back(string(b, after));

            b = after;
        }
    }

    return ret;
}

int print_formatted_xref(string file, size_t line_length)
{
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        string s = it->first + " occurs on line(s): ";
        string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
    }

    return 0;
}

int print_formatted_line_xref(string file, size_t line_length)
{
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        string line = it->second.size() > 1 ? "lines" : "line";
        string s = it->first + " occurs on " + line + ": ";
        string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
    }

    return 0;
}

int print_xref_urls(string file, size_t line_length)
{
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, find_urls);
    infile.close();
    infile.clear();
    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        string line = it->second.size() > 1 ? "lines" : "line";
        string s = it->first + " occurs on " + line + ": ";
        string s_spaces(s.size(), ' ');

        vector<int>::const_iterator line_it = it->second.begin();

        while (line_it != it->second.end())
        {
            string nr = to_string(*line_it);

            if (line_it != it->second.end() - 1)
            {
                nr += ", ";
            }

            if (s.size() + nr.size() > line_length)
            {
                cout << s << endl;
                s = s_spaces + nr;
            }
            else
            {
                s += nr;
            }

            ++line_it;
        }

        if (s.size() > s_spaces.size())
        {
            cout << s << endl;
        }
    }

    return 0;
}

int test_xref()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    map<string, vector<int> > ret = xref(infile, split);
    infile.close();
    infile.clear();
    infile.open(file);
    map<string, vector<int> > ret_uniq = xref_unique(infile, split);
    infile.close();
    infile.clear();

    for (map<string, vector<int> >::const_iterator it = ret.begin(); it != ret.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    cout << endl;
    for (map<string, vector<int> >::const_iterator it = ret_uniq.begin(); it != ret_uniq.end(); ++it)
    {
        cout << it->first << " occurs on line(s): ";
        const vector<int> &v = it->second;
        copy(v.begin(), v.end(), std::ostream_iterator<int, char>(cout, " "));
        cout << endl;
    }
    return 0;
}

int test_xref(string file)
{
    ifstream infile;
    infile.open(file);

    vector<string> xref_vector;
    list<string> xref_list;

    xref_uniq(infile, back_inserter(xref_vector), split);
    xref_uniq(infile, back_inserter(xref_list), split);
    xref_uniq(infile, ostream_iterator<string>(cout, "\n"), split);

    cout << endl;

    vector<string>::const_iterator itv = xref_vector.begin();
    if (!xref_vector.empty())
    {
        cout << *itv++ << endl;
    }
    while (itv != xref_vector.end())
    {
        cout << *itv++ << endl;
    }
    cout << endl;

    list<string>::const_iterator itl = xref_list.begin();
    if (!xref_list.empty())
    {
        cout << *itl++ << endl;
    }
    while (itl != xref_list.end())
    {
        cout << *itl++ << endl;
    }
    cout << endl;

    return 0;
}

int test_generate_sentence()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    vector<string> sentence = gen_sentence(read_grammar(infile));
    infile.close();
    infile.clear();
    copy(sentence.begin(), sentence.end(), std::ostream_iterator<string, char>(cout, " "));
    cout << endl;
    return 0;
}

int test_count_words()
{
    string file = "grammar_ch07.txt";
    ifstream infile;
    infile.open(file);
    count_sort_words(infile, cout);
    infile.close();
    infile.clear();
    return 0;
}

int test_split()
{
    cout << "Enter lines to split: " << endl;
    string s;
    while (getline(cin, s, '\n') && s != "quit")
    {
        split(s, ostream_iterator<string, char>(cout, "\n"));
    }
    return 0;
}

void test_stream_iterators()
{
    cout << "Enter a few integers: ";

    vector<int> v;
    copy(istream_iterator<int>(cin), istream_iterator<int>(), back_inserter(v));
    cout << endl;

    copy(v.begin(), v.end(), ostream_iterator<int>(cout, " "));
    cout << endl;
}

void test_median()
{
    vector<double> v_double = { 12.5, 16.3, 25.7 };
    cout << median(v_double) << endl;

    vector<int> v_int = { 12, 25, 16, 30 };
    cout << median(v_int) << endl;
}

int main(int argc, const char *argv[])
{
    try
    {
        test_xref();
        cout << endl;
        test_generate_sentence();
        cout << endl;
        generate_sentence_list_output("grammar_ch07.txt");
        cout << endl;
        generate_sentence_vectors_output("grammar_ch07.txt");
        cout << endl;
        test_count_words();
        cout << endl;
        print_formatted_line_xref("grammar_ch07.txt", 60);
        cout << endl;
        print_xref_urls("urls_ch07.txt", 60);
        cout << endl;
        unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
        mt19937 engine(seed);
        for (int i = 0; i < 10; i++)
        {
            cout << nrand_two(0, 100, engine) << endl;
        }
        cout << endl;
        test_median();
        test_stream_iterators();
        cin.clear();
        while (cin.get() != '\n')
        {
            continue;
        }
        test_split();
        cout << endl;
        test_generate_sentence("grammar_ch07.txt");
        cout << endl;
        test_xref("grammar_ch07.txt");

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

<adjective> occurs on line(s): 5 6 7 8
<location> occurs on line(s): 11 12 13 14
<noun-phrase> occurs on line(s): 4 5 14
<noun> occurs on line(s): 1 2 3 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9 10 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11 12 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

the cat jumps on the stairs

the brown cat jumps on the stairs

the cat sits under the sky

<sentence>      1
absurd  1
brown   1
cat     1
dog     1
it      1
jumps   1
large   1
on      1
sits    1
sky     1
stairs  1
table   1
under   1
wants   1
wherever        1
the     3
<verb>  3
<adjective>     4
<location>      4
<noun-phrase>   4
<noun>  4

<adjective> occurs on lines: 5, 6, 7, 8
<location> occurs on lines: 11, 12, 13, 14
<noun-phrase> occurs on lines: 4, 5, 14
<noun> occurs on lines: 1, 2, 3, 4
<sentence> occurs on line: 14
<verb> occurs on lines: 9, 10, 14
absurd occurs on line: 8
brown occurs on line: 7
cat occurs on line: 1
dog occurs on line: 2
it occurs on line: 13
jumps occurs on line: 9
large occurs on line: 6
on occurs on line: 11
sits occurs on line: 10
sky occurs on line: 12
stairs occurs on line: 11
table occurs on line: 3
the occurs on lines: 11, 12, 14
under occurs on line: 12
wants occurs on line: 13
wherever occurs on line: 13

ftp://www.telenet.be occurs on line: 5
http://www.amazon.com occurs on lines: 2, 6, 7
http://www.disneyland.com occurs on line: 4
http://www.google.be occurs on lines: 1, 4

51
19
42
96
65
1
95
35
68
94

16.3
20
Enter a few integers: 23 69 33 36 11 q

23 69 33 36 11
Enter lines to split:
Peter Smith Mike Pence Hello World Apple Orange Water Flower quit
Peter
Smith
Mike
Pence
Hello
World
Apple
Orange
Water
Flower
quit
quit

the large absurd large table jumps under the sky
the brown table sits under the sky
the dog sits wherever it wants

<adjective> occurs on line(s): 5, 6, 7, 8
<location> occurs on line(s): 11, 12, 13, 14
<noun-phrase> occurs on line(s): 4, 5, 14
<noun> occurs on line(s): 1, 2, 3, 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9, 10, 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11, 12, 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

<adjective> occurs on line(s): 5, 6, 7, 8
<location> occurs on line(s): 11, 12, 13, 14
<noun-phrase> occurs on line(s): 4, 5, 14
<noun> occurs on line(s): 1, 2, 3, 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9, 10, 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11, 12, 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13

<adjective> occurs on line(s): 5, 6, 7, 8
<location> occurs on line(s): 11, 12, 13, 14
<noun-phrase> occurs on line(s): 4, 5, 14
<noun> occurs on line(s): 1, 2, 3, 4
<sentence> occurs on line(s): 14
<verb> occurs on line(s): 9, 10, 14
absurd occurs on line(s): 8
brown occurs on line(s): 7
cat occurs on line(s): 1
dog occurs on line(s): 2
it occurs on line(s): 13
jumps occurs on line(s): 9
large occurs on line(s): 6
on occurs on line(s): 11
sits occurs on line(s): 10
sky occurs on line(s): 12
stairs occurs on line(s): 11
table occurs on line(s): 3
the occurs on line(s): 11, 12, 14
under occurs on line(s): 12
wants occurs on line(s): 13
wherever occurs on line(s): 13



cat grammar_ch07.txt
<noun>  cat
<noun>  dog
<noun>  table
<noun-phrase>   <noun>
<noun-phrase>   <adjective> <noun-phrase>
<adjective>     large
<adjective>     brown
<adjective>     absurd
<verb>          jumps
<verb>          sits
<location>      on the stairs
<location>      under the sky
<location>      wherever it wants
<sentence>      the <noun-phrase> <verb> <location>



cat urls_ch07.txt
anna barbara http://www.google.be fantastic http://www.google.be
Boy oh  boy http://www.amazon.com great
this is just a test
wald disney is at http://www.disneyland.com not at http://www.google.be you know
this is a really obnoxious sentence ftp://www.telenet.be yay
this is really http://www.amazon.com good
and just once more http://www.amazon.com okay

ch15_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

string getOneDigitNumber(char number)
{
    switch(number)
    {
    case '1':
        return "one";
    case '2':
        return "two";
    case '3':
        return "three";
    case '4':
        return "four";
    case '5':
        return "five";
    case '6':
        return "six";
    case '7':
        return "seven";
    case '8':
        return "eight";
    case '9':
        return "nine";
    default:
        return "";
    }
}

string getTeensNumber(char number)
{
    switch (number)
    {
    case '0':
        return "ten";
    case '1':
        return "eleven";
    case '2':
        return "twelve";
    case '3':
        return "thirteen";
    case '4':
        return "fourteen";
    case '5':
        return "fifteen";
    case '6':
        return "sixteen";
    case '7':
        return "seventeen";
    case '8':
        return "eighteen";
    case '9':
        return "nineteen";
    default:
        return "";
    }
}

string getTensNumber(char number)
{
    switch (number)
    {
    case '2':
        return "twenty";
    case '3':
        return "thirty";
    case '4':
        return "fourty";
    case '5':
        return "fifty";
    case '6':
        return "sixty";
    case '7':
        return "seventy";
    case '8':
        return "eighty";
    case '9':
        return "ninety";
    default:
        return "";
    }
}

string getTwoDigitNumber(char ten, char one)
{
    if (ten == '0')
    {
        return  getOneDigitNumber(one);
    }
    else if (ten == '1')
    {
        return getTeensNumber(one);
    }
    else
    {
        if (one == '0')
        {
            return getTensNumber(ten);
        }
        else
        {
            return (getTensNumber(ten) + " " + getOneDigitNumber(one));
        }
    }
}

string getThreeDigitNumber(char hundred, char ten, char one)
{
    if (hundred == '0')
    {
        return  getTwoDigitNumber(ten, one);
    }
    else
    {
        if (ten == '0' && one == '0')
        {
            return (getOneDigitNumber(hundred) + " hundred");
        }
        else
        {
            return (getOneDigitNumber(hundred) + " hundred " + getTwoDigitNumber(ten, one));
        }
    }
}

string getMagnitude(int divisionsOfThree)
{
    switch (divisionsOfThree)
    {
    case 1:
        return "thousand";
    case 2:
        return "million";
    case 3:
        return "billion";
    case 4:
        return "trillion";
    default:
        return "";
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        int i;

        cout << "Please enter an integer number: ";
        cin >> i;
        string numberAsString = to_string(i);

        string sign = "";
        bool isNegative = (numberAsString.at(0) == '-');
        if (isNegative)
        {
            sign = "Negative ";
        }

        int signOffset = 0;
        if (isNegative)
        {
            signOffset = 1;
        }

        int numberCount = numberAsString.length() - signOffset;

        string numberInEnglish = "";
        int tens = numberCount % 3;
        int divisionsOfThree = (numberCount - 1) / 3;

        if ( numberCount <= 3 )
        {
            switch (numberCount)
            {
            case 1:
                if ( numberAsString.at(signOffset) == '0' )
                {
                    numberInEnglish = "zero";
                }
                else
                {
                    numberInEnglish = getOneDigitNumber(numberAsString.at(signOffset));
                }
                break;
            case 2:
                numberInEnglish = getTwoDigitNumber(numberAsString.at(signOffset), numberAsString.at(signOffset + 1));
                break;
            case 3:
                numberInEnglish = getThreeDigitNumber(numberAsString.at(signOffset), numberAsString.at(signOffset + 1), numberAsString.at(signOffset + 2));
                break;
            default:
                break;
            }
            cout << numberAsString << ": " << sign << numberInEnglish << '\n';
            return 0;
        }

        if ( tens > 0 )
        {
            switch (tens)
            {
            case 1:
                numberInEnglish = getOneDigitNumber(numberAsString.at(signOffset));
                break;
            case 2:
                numberInEnglish = getTwoDigitNumber(numberAsString.at(signOffset), numberAsString.at(signOffset + 1));
                break;
            default:
                break;
            }
            numberInEnglish += " " + getMagnitude(divisionsOfThree);
            divisionsOfThree--;
        }

        for (size_t j = tens + signOffset; j < numberAsString.length(); j += 3)
        {
            string threeDigits = numberAsString.substr(j, 3);
            if (threeDigits != "000")
            {
                if(numberInEnglish.length() > 0)
                {
                    numberInEnglish += ", ";
                }
                if (divisionsOfThree == 0)
                {
                    numberInEnglish +=
                        getThreeDigitNumber(threeDigits.at(0), threeDigits.at(1), threeDigits.at(2));
                }
                else
                {
                    numberInEnglish +=
                        getThreeDigitNumber(threeDigits.at(0), threeDigits.at(1), threeDigits.at(2)) + " " + getMagnitude(divisionsOfThree);
                }
            }

            divisionsOfThree--;
        }
        cout << numberAsString << ": " << sign << numberInEnglish << '\n';

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Please enter an integer number: 0
0: zero

Please enter an integer number: 100023
100023: one hundred thousand, twenty three

Please enter an integer number: 1000000002
1000000002: one billion, two

ch15_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

char const space = ' ';
char const comma = ',';
char const hyphen = '-';

bool isNumberDemarcator(char character)
{
    return ( (character == hyphen) ||
             (character == comma) ||
             (character == space) );
}

bool isFirstLetter(const string & numberInEnglish, int numberIndexFromEnd)
{
    return ( numberIndexFromEnd == numberInEnglish.length() - 1 );
}

bool isNegative(const string & number)
{
    string negative = "negative";
    if (number.length() > negative.length())
    {
        for (size_t i = 0; i < negative.length(); i++)
        {
            if (!(tolower(number[i]) == negative[i]))
            {
                return false;
            }
        }
        return true;
    }
    return false;
}

bool isTens(const string & word)
{
    return ((word == "twenty") ||
            (word == "thirty") ||
            (word == "forty") ||
            (word == "fifty") ||
            (word == "sixty") ||
            (word == "seventy") ||
            (word == "eighty") ||
            (word == "ninety"));
}

bool isHundreds(const string & word)
{
    return (word == "hundred");
}

string wordsToNumbers(const string & word)
{
    if (word == "zero")
        return "0";
    if (word == "one")
        return "1";
    if (word == "two")
        return "2";
    if (word == "three")
        return "3";
    if (word == "four")
        return "4";
    if (word == "five")
        return "5";
    if (word == "six")
        return "6";
    if (word == "seven")
        return "7";
    if (word == "eight")
        return "8";
    if (word == "nine")
        return "9";
    if (word == "ten")
        return "10";
    if (word == "eleven")
        return "11";
    if (word == "twelve")
        return "12";
    if (word == "thirteen")
        return "13";
    if (word == "fourteen")
        return "14";
    if (word == "fifteen")
        return "15";
    if (word == "sixteen")
        return "16";
    if (word == "seventeen")
        return "17";
    if (word == "eighteen")
        return "18";
    if (word == "nineteen")
        return "19";
    if (word == "twenty")
        return "2";
    if (word == "thirty")
        return "3";
    if (word == "forty")
        return "4";
    if (word == "fifty")
        return "5";
    if (word == "sixty")
        return "6";
    if (word == "seventy")
        return "7";
    if (word == "eighty")
        return "8";
    if (word == "ninety")
        return "9";
    return "";
}

int wordsToMagnitude(const string & word)
{
    if (word == "thousand")
    {
        return 3;
    }
    if (word == "million")
    {
        return 6;
    }
    if (word == "billion")
    {
        return 9;
    }
    if (word == "trillion")
    {
        return 12;
    }
    return 0;
}

string addZeroPadding(int numberOfZeroes)
{
    string currentPadding = "";
    for (size_t j = 0; j < numberOfZeroes; j++)
    {
        currentPadding += "0";
    }
    return currentPadding;
}

string addCommasMagnitude(const string & numberAsWord)
{
    string numberAsWordWithCommas = "";
    int subcount = 0;
    int originalLength = numberAsWord.length();
    for (size_t i = 0; i < originalLength; i++)
    {
        numberAsWordWithCommas = numberAsWord[originalLength - 1 - i] + numberAsWordWithCommas;
        subcount++;
        if ((subcount == 3) && !(i == originalLength - 1))
        {
            subcount = 0;
            numberAsWordWithCommas = "," + numberAsWordWithCommas;
        }
    }
    return numberAsWordWithCommas;
}

string getTens(string  numberAsWord)
{
    int numberLength = numberAsWord.length();
    if (numberLength < 2)
    {
        numberAsWord = addZeroPadding(1 - numberLength) + numberAsWord;
    }
    else
    {
        int offset = 1;
        while (offset - numberLength < 0)
        {
            offset += 3;
        }
        numberAsWord = addZeroPadding(offset - numberLength) + numberAsWord;
    }
    return numberAsWord;
}

string getHundreds(string numberAsWord)
{
    int numberLength = numberAsWord.length();

    int offset = 2;
    while (offset - numberLength < 0)
    {
        offset += 3;
    }
    numberAsWord = addZeroPadding(offset - numberLength) + numberAsWord;

    return numberAsWord;
}

int getMagnitudeBalance(const string & currentWord, const string & numberAsString)
{
    int currentMagnitude = wordsToMagnitude(currentWord);
    int numberLength = numberAsString.length();
    return (currentMagnitude - numberLength);
}


string getPaddedForMagnitude(const string & numberAsString, int magnitudeBalance)
{
    return (addZeroPadding(magnitudeBalance) + numberAsString);
}

int main(int argc, const char *argv[])
{
    try
    {
        string numberInEnglish = "";
        cout << "Please write in any number you wish to see written out in digits: " << '\n';
        getline(cin, numberInEnglish, '\n');

        string numberAsString = "";
        string currentWord = "";
        for (size_t i = 0; i < numberInEnglish.length(); i++)
        {
            char currentLetter = tolower(numberInEnglish[numberInEnglish.length() - 1 - i]);

            if (!isNumberDemarcator(currentLetter))
            {
                currentWord = currentLetter + currentWord;
            }

            if ( !(currentWord == "") && ( isNumberDemarcator(currentLetter) || isFirstLetter(numberInEnglish, i) ) )
            {
                int magnitudeBalance;

                if (isTens(currentWord))
                {
                    numberAsString = getTens(numberAsString);
                }
                else if (isHundreds(currentWord))
                {
                    numberAsString = getHundreds(numberAsString);
                }
                else if ( ( magnitudeBalance = getMagnitudeBalance(currentWord, numberAsString) ) > 0 )
                {
                    numberAsString = getPaddedForMagnitude(numberAsString, magnitudeBalance);
                }
                string currentNumber = wordsToNumbers(currentWord);

                if (!(currentNumber == ""))
                {
                    numberAsString = currentNumber + numberAsString;
                }

                currentWord = "";
            }
        }

        numberAsString = addCommasMagnitude(numberAsString);

        if (isNegative(numberInEnglish))
        {
            numberAsString = "-" + numberAsString;
        }
        cout << "The number you entered was " << numberAsString << '\n';

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Please write in any number you wish to see written out in digits:
zero
The number you entered was 0

Please write in any number you wish to see written out in digits:
one
The number you entered was 1

Please write in any number you wish to see written out in digits:
two
The number you entered was 2

Please write in any number you wish to see written out in digits:
three
The number you entered was 3

Please write in any number you wish to see written out in digits:
four
The number you entered was 4

Please write in any number you wish to see written out in digits:
one billion two
The number you entered was 1,000,000,002

Please write in any number you wish to see written out in digits:
one hundred thousand twenty three
The number you entered was 100,023

第16章 标准库算法
16.1 简介
16.2 对迭代器的最低要求
16.3 算法
16.4 函数对象
16.5 lambda表达式
16.6 标准库算法总结
16.7 本章小结
ch16_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Item
{
public:
    string name;
    int iid;
    double value;
    Item() : name(), iid(0), value(0) { }
    Item(const string &n, int i, double v) : name(n), iid(i), value(v) { }
};

istream &operator>>(istream &is, Item &it)
{
    string name;
    int iid;
    double value;
    is >> name;
    if (!is)
    {
        return is;
    }
    is >> iid;
    if (!is)
    {
        return is;
    }
    is >> value;
    if (!is)
    {
        return is;
    }
    it = Item(name, iid, value);
    return is;
}

ostream &operator<<(ostream &os, const Item &it)
{
    return os << it.name << '\t' << it.iid << '\t' << it.value;
}

class  Comp_by_name
{
public:
    bool operator()(const Item &a, const Item &b) const
    {
        return a.name < b.name;
    }
};

class Comp_by_iid
{
public:
    bool operator()(const Item &a, const Item &b) const
    {
        return a.iid < b.iid;
    }
};

bool comp_by_value(const Item &a, const Item &b)
{
    return a.value < b.value;
}

class Find_by_name
{
private:
    string name;
public:
    Find_by_name(const string &s) : name(s) { }
    bool operator()(const Item &it) const
    {
        return it.name == name;
    }
};

class Find_by_iid
{
private:
    int iid;
public:
    Find_by_iid(int i) : iid(i) { }
    bool operator()(const Item &it) const
    {
        return it.iid == iid;
    }
};

template<typename iter>
void print(iter first, iter last)
{
    while (first != last)
    {
        cout << *first << '\n';
        ++first;
    }
}

void f1()
{
    cout << "First round: vector\n";
    vector<Item> vi;
    const string ifname = "ch16_p01_in1.txt";

    cout << "fill with ten items from file\n";
    ifstream ifs(ifname.c_str());
    if (!ifs)
    {
        error("can't open " + ifname);
    }
    Item i;
    while (ifs >> i)
    {
        vi.insert(vi.end(), i);
    }
    print(vi.begin(), vi.end());

    cout << "\nsort by name\n";
    sort(vi.begin(), vi.end(), Comp_by_name());
    print(vi.begin(), vi.end());

    cout << "\nsort by iid\n";
    sort(vi.begin(), vi.end(), Comp_by_iid());
    print(vi.begin(), vi.end());

    cout << "\nsort by value, print in decreasing order\n";
    sort(vi.begin(), vi.end(), comp_by_value);
    reverse(vi.begin(), vi.end());
    print(vi.begin(), vi.end());

    cout << "\ninsert two items, sort by value, print in decreasing order\n";
    vi.insert(vi.end(), Item("Horsesh", 99, 12.34));
    vi.insert(vi.end(), Item("C S400", 9988, 499.95));
    sort(vi.begin(), vi.end(), comp_by_value);
    reverse(vi.begin(), vi.end());
    print(vi.begin(), vi.end());

    cout << "\nremove two items identified by name\n";
    vector<Item>::iterator vi_it = find_if(vi.begin(), vi.end(), Find_by_name("GoPro"));
    vi.erase(vi_it);
    vi_it = find_if(vi.begin(), vi.end(), Find_by_name("Xbox"));
    vi.erase(vi_it);
    print(vi.begin(), vi.end());

    cout << "\nremove two tems identified by iid\n";
    vi_it = find_if(vi.begin(), vi.end(), Find_by_iid(14910));
    vi.erase(vi_it);
    vi_it = find_if(vi.begin(), vi.end(), Find_by_iid(754));
    vi.erase(vi_it);
    print(vi.begin(), vi.end());
}

void f2()
{
    cout << "\nSecond round: list\n";
    list<Item> li;
    const string ifname = "ch16_p01_in1.txt";

    cout << "fill with ten items from file\n";
    ifstream ifs(ifname.c_str());
    if (!ifs)
    {
        error("can't open " + ifname);
    }
    Item i;
    while (ifs >> i)
    {
        li.insert(li.end(), i);
    }
    print(li.begin(), li.end());

    cout << "\nsort by name\n";
    li.sort(Comp_by_name());
    print(li.begin(), li.end());

    cout << "\nsort by iid\n";
    li.sort(Comp_by_iid());
    print(li.begin(), li.end());

    cout << "\nsort by value, print in decreasing order\n";
    li.sort(comp_by_value);
    reverse(li.begin(), li.end());
    print(li.begin(), li.end());

    cout << "\ninsert two items, sort by value, print in decreasing order\n";
    li.insert(li.end(), Item("Horsesh", 99, 12.34));
    li.insert(li.end(), Item("C S400", 9988, 499.95));
    li.sort(comp_by_value);
    reverse(li.begin(), li.end());
    print(li.begin(), li.end());

    cout << "\nremove two items identified by name\n";
    list<Item>::iterator li_it = find_if(li.begin(), li.end(), Find_by_name("GoPro"));
    li.erase(li_it);
    li_it = find_if(li.begin(), li.end(), Find_by_name("Xbox"));
    li.erase(li_it);
    print(li.begin(), li.end());

    cout << "\nremove two tems identified by iid\n";
    li_it = find_if(li.begin(), li.end(), Find_by_iid(14910));
    li.erase(li_it);
    li_it = find_if(li.begin(), li.end(), Find_by_iid(754));
    li.erase(li_it);
    print(li.begin(), li.end());
}

void read_pair(map<string, int> &msi)
{
    string s;
    int i;
    cin >> s;
    if (!cin)
    {
        error("Problem reading from cin");
    }
    cin >> i;
    if (!cin)
    {
        error("Problem reading from cin");
    }
    msi[s] = i;
}

template<typename T, typename U>
ostream &operator<<(ostream &os, const pair<T, U> &p)
{
    os << setw(12) << left << p.first << '\t' << p.second;
    return os;
}

template<typename T>
class Map_add
{
public:
    T operator()(const T &v, const pair<string, T> &p)
    {
        return v + p.second;
    }
};

void f3()
{
    map<string, int> msi;

    msi["lecture"] = 21;
    msi["university"] = 35;
    msi["education"] = 15;
    msi["school"] = 99;
    msi["kindergarten"] = 105;
    msi["river"] = 5;
    msi["city"] = 10;
    msi["capital"] = 70;
    msi["software"] = 88;
    msi["hardware"] = 43;

    print(msi.begin(), msi.end());

    typedef map<string, int>::const_iterator MI;
    MI p = msi.begin();
    while (p != msi.end())
    {
        p = msi.erase(p);
    }
    cout << "Size of map after deleting: " << msi.size() << '\n';

    cout << "Enter 10 (string,int) pairs, separated by space:\n";
    for (int i = 0; i < 10; ++i)
    {
        read_pair(msi);
    }

    cout << '\n';
    print(msi.begin(), msi.end());

    int msi_sum = 0;
    msi_sum = accumulate(msi.begin(), msi.end(), msi_sum, Map_add<int>());
    cout << "\nSum of all ints in msi: " << msi_sum << '\n';

    map<int, string> mis;

    for (p = msi.begin(); p != msi.end(); ++p)
    {
        mis[p->second] = p->first;
    }

    cout << "\nContents of mis:\n";
    print(mis.begin(), mis.end());
}

template<typename T>
class Less_than
{
private:
    T v;
public:
    Less_than(const T &val) : v(val) { }
    bool operator()(const T &x) const
    {
        return x < v;
    }
};

void f4()
{
    const string fname = "ch16_p01_in2.txt";
    ifstream ifs(fname.c_str());
    if (!ifs)
    {
        error("can't open " + fname);
    }
    vector<double> vd;
    double d;
    while (ifs >> d)
    {
        vd.push_back(d);
    }

    cout << "vd:\n";
    print(vd.begin(), vd.end());

    vector<int> vi(vd.size());
    copy(vd.begin(), vd.end(), vi.begin());

    cout << "\n(vd,vi) pairs:\n";
    for (int i = 0; i < vd.size(); ++i)
    {
        cout << '(' << vd[i] << ',' << vi[i] << ")\n";
    }

    double sum_vd = 0;
    sum_vd = accumulate(vd.begin(), vd.end(), sum_vd);
    cout << "\nSum of the elements of vd: " << sum_vd << '\n';

    int sum_vi = 0;
    sum_vi = accumulate(vi.begin(), vi.end(), sum_vi);
    cout << "Difference of sum_vd and sum_vi: " << sum_vd - sum_vi << '\n';

    reverse(vd.begin(), vd.end());
    cout << "\nvd after reverse:\n";
    print(vd.begin(), vd.end());

    double vd_mean = sum_vd / vd.size();
    cout << "\nMean value of elements in vd: " << vd_mean << '\n';

    vector<double> vd2(count_if(vd.begin(), vd.end(), Less_than<double>(vd_mean)));
    copy_if(vd.begin(), vd.end(), vd2.begin(), Less_than<double>(vd_mean));
    cout << "\nvd2:\n";
    print(vd2.begin(), vd2.end());

    sort(vd.begin(), vd.end());
    cout << "\nAfter sort, vd:\n";
    print(vd.begin(), vd.end());
}

int main(int argc, const char *argv[])
{
    try
    {
        f1();
        f2();
        f3();
        f4();

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
cat ch16_p01_in1.txt
Cards 14910 25.0
Fuji 3484 10.0
Call 2517 10.0
Lol 153 17.99
Hat 162 399.99
GoPro 667 49.95
Xbox 135 39.99
WhatIf 368 349.0
Fleece 223 39.99
Beanie 754 2.99

cat ch16_p01_in2.txt
25.0
10.0
10.0
17.99
399.99
49.95
39.99
349.0
39.99
2.99
3.14
2.17
64.2
55.1
91.1
32.1

ch16_p01
First round: vector
fill with ten items from file
Cards   14910   25
Fuji    3484    10
Call    2517    10
Lol     153     17.99
Hat     162     399.99
GoPro   667     49.95
Xbox    135     39.99
WhatIf  368     349
Fleece  223     39.99
Beanie  754     2.99

sort by name
Beanie  754     2.99
Call    2517    10
Cards   14910   25
Fleece  223     39.99
Fuji    3484    10
GoPro   667     49.95
Hat     162     399.99
Lol     153     17.99
WhatIf  368     349
Xbox    135     39.99

sort by iid
Xbox    135     39.99
Lol     153     17.99
Hat     162     399.99
Fleece  223     39.99
WhatIf  368     349
GoPro   667     49.95
Beanie  754     2.99
Call    2517    10
Fuji    3484    10
Cards   14910   25

sort by value, print in decreasing order
Hat     162     399.99
WhatIf  368     349
GoPro   667     49.95
Fleece  223     39.99
Xbox    135     39.99
Cards   14910   25
Lol     153     17.99
Fuji    3484    10
Call    2517    10
Beanie  754     2.99

insert two items, sort by value, print in decreasing order
C S400  9988    499.95
Hat     162     399.99
WhatIf  368     349
GoPro   667     49.95
Xbox    135     39.99
Fleece  223     39.99
Cards   14910   25
Lol     153     17.99
Horsesh 99      12.34
Call    2517    10
Fuji    3484    10
Beanie  754     2.99

remove two items identified by name
C S400  9988    499.95
Hat     162     399.99
WhatIf  368     349
Fleece  223     39.99
Cards   14910   25
Lol     153     17.99
Horsesh 99      12.34
Call    2517    10
Fuji    3484    10
Beanie  754     2.99

remove two tems identified by iid
C S400  9988    499.95
Hat     162     399.99
WhatIf  368     349
Fleece  223     39.99
Lol     153     17.99
Horsesh 99      12.34
Call    2517    10
Fuji    3484    10

Second round: list
fill with ten items from file
Cards   14910   25
Fuji    3484    10
Call    2517    10
Lol     153     17.99
Hat     162     399.99
GoPro   667     49.95
Xbox    135     39.99
WhatIf  368     349
Fleece  223     39.99
Beanie  754     2.99

sort by name
Beanie  754     2.99
Call    2517    10
Cards   14910   25
Fleece  223     39.99
Fuji    3484    10
GoPro   667     49.95
Hat     162     399.99
Lol     153     17.99
WhatIf  368     349
Xbox    135     39.99

sort by iid
Xbox    135     39.99
Lol     153     17.99
Hat     162     399.99
Fleece  223     39.99
WhatIf  368     349
GoPro   667     49.95
Beanie  754     2.99
Call    2517    10
Fuji    3484    10
Cards   14910   25

sort by value, print in decreasing order
Hat     162     399.99
WhatIf  368     349
GoPro   667     49.95
Fleece  223     39.99
Xbox    135     39.99
Cards   14910   25
Lol     153     17.99
Fuji    3484    10
Call    2517    10
Beanie  754     2.99

insert two items, sort by value, print in decreasing order
C S400  9988    499.95
Hat     162     399.99
WhatIf  368     349
GoPro   667     49.95
Xbox    135     39.99
Fleece  223     39.99
Cards   14910   25
Lol     153     17.99
Horsesh 99      12.34
Call    2517    10
Fuji    3484    10
Beanie  754     2.99

remove two items identified by name
C S400  9988    499.95
Hat     162     399.99
WhatIf  368     349
Fleece  223     39.99
Cards   14910   25
Lol     153     17.99
Horsesh 99      12.34
Call    2517    10
Fuji    3484    10
Beanie  754     2.99

remove two tems identified by iid
C S400  9988    499.95
Hat     162     399.99
WhatIf  368     349
Fleece  223     39.99
Lol     153     17.99
Horsesh 99      12.34
Call    2517    10
Fuji    3484    10
capital         70
city            10
education       15
hardware        43
kindergarten    105
lecture         21
river           5
school          99
software        88
university      35
Size of map after deleting: 0
Enter 10 (string,int) pairs, separated by space:
Mike 23 Pence 55 Peter 66 Smith 35 Hello 87 World 99 Water 101 Flower 32 Apple 123 Orange 36

Apple           123
Flower          32
Hello           87
Mike            23
Orange          36
Pence           55
Peter           66
Smith           35
Water           101
World           99

Sum of all ints in msi: 657

Contents of mis:
23              Mike
32              Flower
35              Smith
36              Orange
55              Pence
66              Peter
87              Hello
99              World
101             Water
123             Apple
vd:
25
10
10
17.99
399.99
49.95
39.99
349
39.99
2.99
3.14
2.17
64.2
55.1
91.1
32.1

(vd,vi) pairs:
(25,25)
(10,10)
(10,10)
(17.99,17)
(399.99,399)
(49.95,49)
(39.99,39)
(349,349)
(39.99,39)
(2.99,2)
(3.14,3)
(2.17,2)
(64.2,64)
(55.1,55)
(91.1,91)
(32.1,32)

Sum of the elements of vd: 1192.71
Difference of sum_vd and sum_vi: 6.71

vd after reverse:
32.1
91.1
55.1
64.2
2.17
3.14
2.99
39.99
349
39.99
49.95
399.99
17.99
10
10
25

Mean value of elements in vd: 74.5444

vd2:
32.1
55.1
64.2
2.17
3.14
2.99
39.99
39.99
49.95
17.99
10
10
25

After sort, vd:
2.17
2.99
3.14
10
10
17.99
25
32.1
39.99
39.99
49.95
55.1
64.2
91.1
349
399.99

ch16_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Roman_int
{
public:
    Roman_int();
    Roman_int(int n);
    int as_int() const;
    void set_val(int v);
private:
    int val;
};

// N = 0 I = 1 V = 5 X= 10 L= 50 C = 100 D = 500 M = 1000
const char N = 'N';
const char I = 'I';
const char V = 'V';
const char X = 'X';
const char L = 'L';
const char C = 'C';
const char D = 'D';
const char M = 'M';

bool is_valid_char(char ch);
int get_value(char ch);
bool counter_illegal(int counter, char ch);
int roman_int_to_int(const string &s);


Roman_int::Roman_int() : val(0) { }

Roman_int::Roman_int(int n) : val(n) { }

int Roman_int::as_int() const
{
    return val;
}

void Roman_int::set_val(int v)
{
    val = v;
}

Roman_int operator+(const Roman_int &r1, const Roman_int &r2)
{
    return Roman_int(r1.as_int() + r2.as_int());
}

Roman_int operator-(const Roman_int &r1, const Roman_int &r2)
{
    return Roman_int(r1.as_int() - r2.as_int());
}

Roman_int operator-(const Roman_int &r)
{
    return Roman_int(-r.as_int());
}

Roman_int operator*(const Roman_int &r1, const Roman_int &r2)
{
    return Roman_int(r1.as_int() * r2.as_int());
}

Roman_int operator/(const Roman_int &r1, const Roman_int &r2)
{
    if (r2.as_int() == 0)
    {
        error("division / by zero");
    }
    return Roman_int(r1.as_int() / r2.as_int());
}

Roman_int operator%(const Roman_int &r1, const Roman_int &r2)
{
    if (r2.as_int() == 0)
    {
        error("division % by zero");
    }
    return Roman_int(r1.as_int() % r2.as_int());
}

bool operator==(const Roman_int &r1, const Roman_int &r2)
{
    return r1.as_int() == r2.as_int();
}

bool operator!=(const Roman_int &r1, const Roman_int &r2)
{
    return !(r1 == r2);
}

bool operator<(const Roman_int &r1, const Roman_int &r2)
{
    return r1.as_int() < r2.as_int();
}

bool operator>(const Roman_int &r1, const Roman_int &r2)
{
    return r2 < r1;
}

bool operator<=(const Roman_int &r1, const Roman_int &r2)
{
    return !(r2 < r1);
}

bool operator>=(const Roman_int &r1, const Roman_int &r2)
{
    return !(r1 < r2);
}

bool is_valid_char(char ch)
{
    return ch == N || ch == I || ch == V || ch == X || ch == L || ch == C || ch == D || ch == M;
}

ostream &operator<<(ostream &os, const Roman_int &r)
{
    int val = r.as_int();
    if (val == 0)
    {
        return os << N;
    }
    if (val < 0)
    {
        os << '-';
        val = -val;
    }

    while (val >= 1000)
    {
        os << M;
        val -= 1000;
    }
    if (val >= 900)
    {
        os << C << M;
        val -= 900;
    }
    else if (val >= 500)
    {
        os << D;
        val -= 500;
    }
    else if (val >= 400)
    {
        os << C << D;
        val -= 400;
    }
    while (val >= 100)
    {
        os << C;
        val -= 100;
    }
    if (val >= 90)
    {
        os << X << C;
        val -= 90;
    }
    else if (val >= 50)
    {
        os << L;
        val -= 50;
    }
    else if (val >= 40)
    {
        os << X << L;
        val -= 40;
    }
    while (val >= 10)
    {
        os << X;
        val -= 10;
    }
    if (val == 9)
    {
        os << I << X;
        val -= 9;
    }
    else if (val >= 5)
    {
        os << V;
        val -= 5;
    }
    else if (val == 4)
    {
        os << I << V;
        val -= 4;
    }
    while (val >= 1)
    {
        os << I;
        --val;
    }
    return os;
}

int get_value(char ch)
{
    switch (ch)
    {
    case N:
        return 0;
    case I:
        return 1;
    case V:
        return 5;
    case X:
        return 10;
    case L:
        return 50;
    case C:
        return 100;
    case D:
        return 500;
    case M:
        return 1000;
    default:
        error("illegal letter used: " + string(1, ch));
    }
}

bool counter_illegal(int counter, char ch)
{
    switch (ch)
    {
    case N:
    case V:
    case L:
    case D:
        return counter > 1;
    case I:
    case X:
    case C:
    case M:
        return counter > 3;
    default:
        error("counter_illegal: invalid character " + string(1, ch));
    }
}

int roman_int_to_int(const string &s)
{
    if (s.size() == 0)
    {
        error("roman_to_int: empty string");
    }
    if (s.size() == 1)
    {
        return get_value(s[0]);
    }

    int counter = 1;
    int val = get_value(s[s.size() - 1]);

    for (int i = s.size() - 2; i >= 0; --i)
    {
        if (s[i] == s[i + 1])
        {
            ++counter;
            if (counter_illegal(counter, s[i]))
            {
                error("illegal repetition of letter: " + string(1, s[i]));
            }
        }
        else
        {
            counter = 1;
        }

        if (get_value(s[i]) < get_value(s[i + 1]))
        {
            if ((s[i] == I || s[i] == X || s[i] == C) && get_value(s[i + 1]) <= 10 * get_value(s[i]))
            {
                val -= get_value(s[i]);
            }
            else
            {
                error("illegal use of " + string(1, s[i]));
            }
        }
        else
        {
            val += get_value(s[i]);
        }
    }
    return val;
}

istream &operator>>(istream &is, Roman_int &r)
{
    is.exceptions(is.exceptions() | std::ios_base::badbit);

    string s;
    char ch;

    while (is.get(ch))
    {
        if (is_valid_char(ch))
        {
            s += ch;
        }
        else
        {
            is.putback(ch);
            break;
        }
    }

    int val = roman_int_to_int(s);
    r.set_val(val);
    return is;
}

void test_output()
{
    cout << Roman_int(0) << " equals " << Roman_int(0).as_int() << endl;
    cout << Roman_int(1) << " equals " << Roman_int(1).as_int() << endl;
    cout << Roman_int(4) << " equals " << Roman_int(4).as_int() << endl;
    cout << Roman_int(5) << " equals " << Roman_int(5).as_int() << endl;
    cout << Roman_int(8) << " equals " << Roman_int(8).as_int() << endl;
    cout << Roman_int(9) << " equals " << Roman_int(9).as_int() << endl;
    cout << Roman_int(10) << " equals " << Roman_int(10).as_int() << endl;
    cout << Roman_int(48) << " equals " << Roman_int(48).as_int() << endl;
    cout << Roman_int(81) << " equals " << Roman_int(81).as_int() << endl;
    cout << Roman_int(99) << " equals " << Roman_int(99).as_int() << endl;
    cout << Roman_int(105) << " equals " << Roman_int(105).as_int() << endl;
    cout << Roman_int(2014) << " equals " << Roman_int(2014).as_int() << endl;
    cout << Roman_int(-2014) << " equals " << Roman_int(-2014).as_int() << endl;
    cout << Roman_int(1499) << " equals " << Roman_int(1499).as_int() << endl << endl;
    cout << Roman_int(1) << " + " << Roman_int(3) << " = " << Roman_int(1) + Roman_int(3) << endl;
    cout << Roman_int(15) << " * " << Roman_int(37) << " = " << Roman_int(15)*Roman_int(37) << endl;
    cout << Roman_int(105) << " - " << Roman_int(207) << " = " << Roman_int(105) - Roman_int(207) << endl;
    cout << -Roman_int(7) << " * " << Roman_int(5) << " = " << -Roman_int(7)*Roman_int(5) << endl;
    cout << Roman_int(15) << " / " << Roman_int(5) << " = " << Roman_int(15) / Roman_int(5) << endl;
}

int main(int argc, const char *argv[])
{
    try
    {
        test_output();

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
N equals 0
I equals 1
IV equals 4
V equals 5
VIII equals 8
IX equals 9
X equals 10
XLVIII equals 48
LXXXI equals 81
XCIX equals 99
CV equals 105
MMXIV equals 2014
-MMXIV equals -2014
MCDXCIX equals 1499

I + III = IV
XV * XXXVII = DLV
CV - CCVII = -CII
-VII * V = -XXXV
XV / V = III

ch16_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Roman_int
{
public:
    Roman_int();
    Roman_int(int n);
    int as_int() const;
    void set_val(int v);
private:
    int val;
};

// N = 0 I = 1 V = 5 X= 10 L= 50 C = 100 D = 500 M = 1000
const char N = 'N';
const char I = 'I';
const char V = 'V';
const char X = 'X';
const char L = 'L';
const char C = 'C';
const char D = 'D';
const char M = 'M';

bool is_valid_char(char ch);
int get_value(char ch);
bool counter_illegal(int counter, char ch);
int roman_int_to_int(const string &s);


Roman_int::Roman_int() : val(0) { }

Roman_int::Roman_int(int n) : val(n) { }

int Roman_int::as_int() const
{
    return val;
}

void Roman_int::set_val(int v)
{
    val = v;
}

Roman_int operator+(const Roman_int &r1, const Roman_int &r2)
{
    return Roman_int(r1.as_int() + r2.as_int());
}

Roman_int operator-(const Roman_int &r1, const Roman_int &r2)
{
    return Roman_int(r1.as_int() - r2.as_int());
}

Roman_int operator-(const Roman_int &r)
{
    return Roman_int(-r.as_int());
}

Roman_int operator*(const Roman_int &r1, const Roman_int &r2)
{
    return Roman_int(r1.as_int() * r2.as_int());
}

Roman_int operator/(const Roman_int &r1, const Roman_int &r2)
{
    if (r2.as_int() == 0)
    {
        error("division / by zero");
    }
    return Roman_int(r1.as_int() / r2.as_int());
}

Roman_int operator%(const Roman_int &r1, const Roman_int &r2)
{
    if (r2.as_int() == 0)
    {
        error("division % by zero");
    }
    return Roman_int(r1.as_int() % r2.as_int());
}

bool operator==(const Roman_int &r1, const Roman_int &r2)
{
    return r1.as_int() == r2.as_int();
}

bool operator!=(const Roman_int &r1, const Roman_int &r2)
{
    return !(r1 == r2);
}

bool operator<(const Roman_int &r1, const Roman_int &r2)
{
    return r1.as_int() < r2.as_int();
}

bool operator>(const Roman_int &r1, const Roman_int &r2)
{
    return r2 < r1;
}

bool operator<=(const Roman_int &r1, const Roman_int &r2)
{
    return !(r2 < r1);
}

bool operator>=(const Roman_int &r1, const Roman_int &r2)
{
    return !(r1 < r2);
}

bool is_valid_char(char ch)
{
    return ch == N || ch == I || ch == V || ch == X || ch == L || ch == C || ch == D || ch == M;
}

ostream &operator<<(ostream &os, const Roman_int &r)
{
    int val = r.as_int();
    if (val == 0)
    {
        return os << N;
    }
    if (val < 0)
    {
        os << '-';
        val = -val;
    }

    while (val >= 1000)
    {
        os << M;
        val -= 1000;
    }
    if (val >= 900)
    {
        os << C << M;
        val -= 900;
    }
    else if (val >= 500)
    {
        os << D;
        val -= 500;
    }
    else if (val >= 400)
    {
        os << C << D;
        val -= 400;
    }
    while (val >= 100)
    {
        os << C;
        val -= 100;
    }
    if (val >= 90)
    {
        os << X << C;
        val -= 90;
    }
    else if (val >= 50)
    {
        os << L;
        val -= 50;
    }
    else if (val >= 40)
    {
        os << X << L;
        val -= 40;
    }
    while (val >= 10)
    {
        os << X;
        val -= 10;
    }
    if (val == 9)
    {
        os << I << X;
        val -= 9;
    }
    else if (val >= 5)
    {
        os << V;
        val -= 5;
    }
    else if (val == 4)
    {
        os << I << V;
        val -= 4;
    }
    while (val >= 1)
    {
        os << I;
        --val;
    }
    return os;
}

int get_value(char ch)
{
    switch (ch)
    {
    case N:
        return 0;
    case I:
        return 1;
    case V:
        return 5;
    case X:
        return 10;
    case L:
        return 50;
    case C:
        return 100;
    case D:
        return 500;
    case M:
        return 1000;
    default:
        error("illegal letter used: " + string(1, ch));
    }
}

bool counter_illegal(int counter, char ch)
{
    switch (ch)
    {
    case N:
    case V:
    case L:
    case D:
        return counter > 1;
    case I:
    case X:
    case C:
    case M:
        return counter > 3;
    default:
        error("counter_illegal: invalid character " + string(1, ch));
    }
}

int roman_int_to_int(const string &s)
{
    if (s.size() == 0)
    {
        error("roman_to_int: empty string");
    }
    if (s.size() == 1)
    {
        return get_value(s[0]);
    }

    int counter = 1;
    int val = get_value(s[s.size() - 1]);

    for (int i = s.size() - 2; i >= 0; --i)
    {
        if (s[i] == s[i + 1])
        {
            ++counter;
            if (counter_illegal(counter, s[i]))
            {
                error("illegal repetition of letter: " + string(1, s[i]));
            }
        }
        else
        {
            counter = 1;
        }

        if (get_value(s[i]) < get_value(s[i + 1]))
        {
            if ((s[i] == I || s[i] == X || s[i] == C) && get_value(s[i + 1]) <= 10 * get_value(s[i]))
            {
                val -= get_value(s[i]);
            }
            else
            {
                error("illegal use of " + string(1, s[i]));
            }
        }
        else
        {
            val += get_value(s[i]);
        }
    }
    return val;
}

istream &operator>>(istream &is, Roman_int &r)
{
    is.exceptions(is.exceptions() | std::ios_base::badbit);

    string s;
    char ch;

    while (is.get(ch))
    {
        if (is_valid_char(ch))
        {
            s += ch;
        }
        else
        {
            is.putback(ch);
            break;
        }
    }

    int val = roman_int_to_int(s);
    r.set_val(val);
    return is;
}

const char let = 'L';
const char con = 'C';
const char quit = 'q';
const char help = 'h';
const char print = ';';
const char number = '8';
const char name = 'a';
const string declkey = "let";
const string conkey = "const";
const string quitkey = "quit";
const string helpkey = "help";
const string prompt = "> ";
const string result = "= ";

class Token
{
public:
    char kind;
    Roman_int value;
    string name;
    Token(char ch) : kind(ch), value(0) { }
    Token(char ch, const Roman_int &val) : kind(ch), value(val) { }
    Token(char ch, const string &n) : kind(ch), value(0), name(n) { }
};

class Token_stream
{
public:
    Token_stream();
    Token_stream(istream &is);
    Token get();
    void putback(const Token &t);
    void ignore(char c);
    istream &get_istream();
private:
    bool full;
    Token buffer;
    istream *is_ptr;
};

Token_stream::Token_stream() : full(false), buffer(0), is_ptr(&cin) { }
Token_stream::Token_stream(istream &is) : full(false), buffer(0), is_ptr(&is) { }
istream   &Token_stream::get_istream()
{
    return (*is_ptr);
}

void Token_stream::putback(const Token &t)
{
    if (full)
    {
        error("putback() into a full buffer");
    }
    buffer = t;
    full = true;
}

Token Token_stream::get()
{
    if (full)
    {
        full = false;
        return buffer;
    }

    char ch;
    (*is_ptr).get(ch);
    while (isspace(ch))
    {
        if (ch == '\n')
        {
            return Token(print);
        }
        (*is_ptr).get(ch);
    }

    switch (ch)
    {
    case print:
    case '{':
    case '}':
    case '(':
    case ')':
    case '+':
    case '-':
    case '*':
    case '/':
    case '%':
    case '=':
        return Token(ch);
    case N:
    case I:
    case V:
    case X:
    case L:
    case C:
    case D:
    case M:
    {
        (*is_ptr).putback(ch);
        Roman_int val;
        (*is_ptr) >> val;
        return Token(number, val);
    }
    default:
        if (isalpha(ch))
        {
            string s;
            s += ch;
            while ((*is_ptr).get(ch) && (isalpha(ch) || isdigit(ch) || ch == '_'))
            {
                s += ch;
            }
            (*is_ptr).putback(ch);
            if (s == declkey)
            {
                return Token(let);
            }
            if (s == conkey)
            {
                return Token(con);
            }
            if (s == helpkey)
            {
                return Token(help);
            }
            if (s == quitkey)
            {
                return Token(quit);
            }
            return Token(name, s);
        }
        error("Bad token");
    }
}

void Token_stream::ignore(char c)
{
    if (full && c == buffer.kind)
    {
        full = false;
        return;
    }
    full = false;

    char ch = 0;
    while ((*is_ptr) >> ch)
    {
        if (ch == c)
        {
            return;
        }
    }
}

class Variable
{
public:
    string name;
    Roman_int value;
    bool is_const;
    Variable(const string &n, const Roman_int &v, bool b) : name(n), value(v), is_const(b) { }
};

class Symbol_table
{
public:
    Roman_int get(const string &s);
    void set(const string &s, const Roman_int &d);
    bool is_declared(const string &var);
    Roman_int declare(const string &var, const Roman_int &val, bool b);
private:
    vector<Variable> var_table;
};

Roman_int Symbol_table::get(const string &s)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            return var_table[i].value;
        }
    }
    error("get: undefined variable " + s);
}

void Symbol_table::set(const string &s, const Roman_int &d)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == s)
        {
            if (var_table[i].is_const)
            {
                error(s + " is a constant");
            }
            var_table[i].value = d;
            return;
        }
    }
    error("set: undefined variable " + s);
}

bool Symbol_table::is_declared(const string &var)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].name == var)
        {
            return true;
        }
    }
    return false;
}

Roman_int Symbol_table::declare(const string &var, const Roman_int &val, bool b)
{
    if (is_declared(var))
    {
        error(var + " declared twice");
    }
    var_table.push_back(Variable(var, val, b));
    return Roman_int(val);
}

Token_stream ts;
Symbol_table st;
Roman_int expression();

Roman_int primary()
{
    Token t = ts.get();
    Roman_int d(0);
    switch (t.kind)
    {
    case '(':
        d = expression();
        t = ts.get();
        if (t.kind != ')')
        {
            error("')' expected");
        }
        break;
    case '{':
        d = expression();
        t = ts.get();
        if (t.kind != '}')
        {
            error("'}' expected");
        }
        break;
    case number:
        d = t.value;
        break;
    case '-':
        d = -primary();
        break;
    case '+':
        d = primary();
        break;
    case name:
    {
        Token t2 = ts.get();
        if (t2.kind == '=')
        {
            d = expression();
            st.set(t.name, d);
        }
        else
        {
            ts.putback(t2);
            d = st.get(t.name);
        }
    }
    break;
    default:
        error("primary expected");
    }

    return d;
}

Roman_int term()
{
    Roman_int left = primary();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '*':
            left = left * primary();
            t = ts.get();
            break;
        case '/':
        {
            Roman_int d = primary();
            if (d == Roman_int(0))
            {
                error("divide by zero");
            }
            left = left / d;
            t = ts.get();
            break;
        }
        case '%':
        {
            Roman_int d = primary();
            if (d == Roman_int(0))
            {
                error("%: divide by zero");
            }
            left = left % d;
            t = ts.get();
            break;
        }
        default:
            ts.putback(t);
            return left;
        }
    }
}

Roman_int expression()
{
    Roman_int left = term();
    Token t = ts.get();

    while (true)
    {
        switch (t.kind)
        {
        case '+':
            left = left + term();
            t = ts.get();
            break;
        case '-':
            left = left - term();
            t = ts.get();
            break;
        default:
            ts.putback(t);
            return left;
        }
    }
}

Roman_int declaration(bool b)
{
    Token t = ts.get();
    if (t.kind != name)
    {
        error ("name expected in declaration");
    }
    string var_name = t.name;

    Token t2 = ts.get();
    if (t2.kind != '=')
    {
        error("= missing in declaration of " + var_name);
    }

    Roman_int d = expression();
    st.declare(var_name, d, b);
    return d;
}

Roman_int statement()
{
    Token t = ts.get();
    switch(t.kind)
    {
    case let:
        return declaration(false);
    case con:
        return declaration(true);
    default:
        ts.putback(t);
        return expression();
    }
}

void clean_up_mess()
{
    ts.ignore(print);
}

void print_help()
{
    cout << "Instructions: enter expressions, you can declare variables using\n";
    cout << "the 'let' keyword and constants with the 'const' keyword.\n";
}

void calculate()
{
    while (ts.get_istream())
    {
        try
        {
            cout << prompt;
            Token t = ts.get();
            while (t.kind == print)
            {
                t = ts.get();
            }
            if (t.kind == help)
            {
                print_help();
            }
            else if (t.kind == quit)
            {
                return;
            }
            else
            {
                ts.putback(t);
                cout << result << statement() << endl;
            }
        }
        catch(exception &e)
        {
            cerr << e.what() << endl;
            clean_up_mess();
        }
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        cout << "Welcome to our simple calculator.\n";
        cout << "Enter '" << helpkey << "' to get the help info; enter '" << quitkey << "' to quit.\n";

        calculate();

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Welcome to our simple calculator.
Enter 'help' to get the help info; enter 'quit' to quit.
> V+VII
= XII
> V-VII
= -II
> V*VII
= XXXV
> V/VII
= N
> XXXV/VII
= V
> quit

ch16_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

enum SquareState
{
    TTTS_Blank,
    TTTS_O,
    TTTS_X
};

struct Position
{
    int row;
    int column;
};

struct TicTacToeSquare
{
    SquareState state;
    Position position;
    TicTacToeSquare *next;
    TicTacToeSquare *previous;
};

int const minToWin = 4;

TicTacToeSquare *addToLinkedList(TicTacToeSquare *p_list, int row, int column, SquareState state)
{
    TicTacToeSquare *p_item = new TicTacToeSquare;
    p_item->position.row = row;
    p_item->position.column = column;
    p_item->state = state;

    p_item->previous = nullptr;
    p_item->next = p_list;
    if (p_list != nullptr)
    {
        p_list->previous = p_item;
    }

    return p_item;
}

TicTacToeSquare *createGameBoard(int size)
{
    TicTacToeSquare *p_item = nullptr;
    for (int row = 0; row < size; row++)
    {
        for (int column = 0; column < size; column++)
        {
            p_item = addToLinkedList(p_item, row, column, TTTS_Blank);
        }
    }
    return p_item;
}

TicTacToeSquare *getSquare(Position boardPosition, TicTacToeSquare *gameBoard)
{
    TicTacToeSquare *p_current = gameBoard;
    while (p_current != nullptr)
    {
        if ( (p_current->position.row == boardPosition.row) &&
                (p_current->position.column == boardPosition.column) )
        {
            return p_current;
        }
        p_current = p_current->next;
    }
    return nullptr;
}

string setPlayer(bool playerXInSession)
{
    if (playerXInSession)
    {
        return "X";
    }
    return "O";
}

bool validIndex(Position boardPosition, int boardSize)
{
    return ( ( (boardPosition.row >= 0) && (boardPosition.column >= 0) ) &&
             ( (boardPosition.row < boardSize) && (boardPosition.column < boardSize) ) );
}

bool choiceTaken(TicTacToeSquare &gameSquare)
{
    return (gameSquare.state != TTTS_Blank);
}

bool squareMatches(TicTacToeSquare &gameBoard, SquareState choiceCheck, int row, int column)
{
    Position boardPosition = { row, column };
    TicTacToeSquare *currentSquare = getSquare(boardPosition, &gameBoard);
    return (currentSquare->state == choiceCheck);
}

bool boardIsFull(TicTacToeSquare *gameBoard)
{
    TicTacToeSquare *p_current = gameBoard;
    while (p_current != nullptr)
    {
        if ((p_current->state == TTTS_Blank))
        {
            return false;
        }
        p_current = p_current->next;
    }
    return true;
}

string translateEnumToString(SquareState squareState)
{
    switch (squareState)
    {
    case TTTS_Blank:
        return " ";
    case TTTS_O:
        return "O";
    case TTTS_X:
        return "X";
    default:
        return "~";
    }
}

SquareState choiceSquare(bool playerXInSession)
{
    if (playerXInSession)
    {
        return TTTS_X;
    }
    return TTTS_O;
}

void setChoice(TicTacToeSquare *gameSquare, bool playerXInSession)
{
    gameSquare->state = choiceSquare(playerXInSession);
}

void drawBoard(int size, TicTacToeSquare &gameBoard)
{
    cout << "Tic-Tac-Toe\n";
    cout << minToWin << "-in-a-row are needed to win!\n";
    string horizontalBar = " _";
    for (int row = 0; row < size; row++)
    {
        horizontalBar += "__";
    }

    for (int row = 0; row <= size; row++)
    {
        if (row == 0)
        {
            for (int column = 0; column <= size; column++)
            {
                if (column == 0)
                {
                    cout << " ";
                }
                else
                {
                    cout << " " << column;
                }
            }
            cout << "\n";
        }
        else
        {
            cout << horizontalBar << "\n";
            for (int column = 0; column <= size; column++)
            {
                if (column == 0)
                {
                    cout << row;
                }
                else
                {
                    Position boardPosition = { row - 1, column - 1 };
                    TicTacToeSquare *currentSquare = getSquare(boardPosition, &gameBoard);
                    cout << "|" << translateEnumToString(currentSquare->state);
                }
            }
            cout << "|\n";
        }
    }
    cout << horizontalBar << "\n\n";
}

bool choiceWins(bool playerXInSession, TicTacToeSquare &gameBoard, int size)
{
    SquareState choiceCheck = choiceSquare(playerXInSession);;
    double score;

    for (int row = 0; row < size; row++)
    {
        score = 0;
        for (int column = 0; column < size; column++)
        {
            if (squareMatches(gameBoard, choiceCheck, row, column))
            {
                score++;
                if (score >= minToWin)
                {
                    return true;
                }
            }
            else
            {
                score = 0;
            }
        }
    }

    for (int column = 0; column < size; column++)
    {
        score = 0;
        for (int row = 0; row < size; row++)
        {
            if (squareMatches(gameBoard, choiceCheck, row, column))
            {
                score++;
                if (score >= minToWin)
                {
                    return true;
                }
            }
            else
            {
                score = 0;
            }
        }
    }

    score = 0;
    for (int i = 0; i < size; i++)
    {
        if (squareMatches(gameBoard, choiceCheck, i, i))
        {
            score++;
            if (score >= minToWin)
            {
                return true;
            }
        }
        else
        {
            score = 0;
        }
    }

    int maxIndex = size - 1;
    score = 0;
    for (int i = 0; i < size; i++)
    {
        if (squareMatches(gameBoard, choiceCheck, i, maxIndex - i))
        {
            score++;
            if (score >= minToWin)
            {
                return true;
            }
        }
        else
        {
            score = 0;
        }
    }

    return false;
}

int main(int argc, const char *argv[])
{
    try
    {
        bool gameFinished = false;
        bool playerXInSession = true;
        string player = "";
        int row = 0;
        int column = 0;

        int sizeUsed = 4;

        cout << "Please specify the number of spaces to be used for the rows/columns of the square board:\n";
        cout << "(Default is " << minToWin << ")\n";
        cin >> sizeUsed;
        if (sizeUsed < minToWin)
        {
            sizeUsed = minToWin;
        }

        TicTacToeSquare *gameBoard = createGameBoard(sizeUsed);

        do
        {
            row = 0;
            column = 0;
            player = setPlayer(playerXInSession);

            drawBoard(sizeUsed, *gameBoard);

            cout << "Player " << player << ", choose your next board position to claim:\n";

            cout << "Row: \n";
            cin >> row;
            row--;

            cout << "Column: \n";
            cin >> column;
            column--;

            Position boardPosition = { row, column };
            if (!validIndex(boardPosition, sizeUsed))
            {
                cout << "That is an invalid choice. Please try again.\n";
                continue;
            }

            TicTacToeSquare *currentSquare = getSquare(boardPosition, gameBoard);
            if (currentSquare == nullptr)
            {
                cout << "You have selected a position that does not exist on the board. Please try again.\n";
                continue;;
            }

            if (choiceTaken(*currentSquare))
            {
                cout << "That square is already taken. Please try again.\n";
                continue;
            }

            setChoice(currentSquare, playerXInSession);

            if (choiceWins(playerXInSession, *gameBoard, sizeUsed))
            {
                cout << "Player " << player << " wins!\n";
                gameFinished = true;
            }

            if (boardIsFull(gameBoard))
            {
                cout << "Board is full. The game is a tie!\n";
                gameFinished = true;
            }

            playerXInSession = !playerXInSession;
        }
        while (!gameFinished);

        if (gameBoard != nullptr)
        {
            TicTacToeSquare *p_current = gameBoard;
            TicTacToeSquare *p_next;
            while (p_current != nullptr)
            {
                p_next = p_current->next;
                delete p_current;
                p_current = p_next;
            }
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Please specify the number of spaces to be used for the rows/columns of the square board:
(Default is 4)
8
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6 7 8
 _________________
1| | | | | | | | |
 _________________
2| | | | | | | | |
 _________________
3| | | | | | | | |
 _________________
4| | | | | | | | |
 _________________
5| | | | | | | | |
 _________________
6| | | | | | | | |
 _________________
7| | | | | | | | |
 _________________
8| | | | | | | | |
 _________________

Player X, choose your next board position to claim:
Row:
1
Column:
2
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6 7 8
 _________________
1| |X| | | | | | |
 _________________
2| | | | | | | | |
 _________________
3| | | | | | | | |
 _________________
4| | | | | | | | |
 _________________
5| | | | | | | | |
 _________________
6| | | | | | | | |
 _________________
7| | | | | | | | |
 _________________
8| | | | | | | | |
 _________________

Player O, choose your next board position to claim:
Row:
6
Column:
6
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6 7 8
 _________________
1| |X| | | | | | |
 _________________
2| | | | | | | | |
 _________________
3| | | | | | | | |
 _________________
4| | | | | | | | |
 _________________
5| | | | | | | | |
 _________________
6| | | | | |O| | |
 _________________
7| | | | | | | | |
 _________________
8| | | | | | | | |
 _________________

Player X, choose your next board position to claim:
Row:
2
Column:
3
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6 7 8
 _________________
1| |X| | | | | | |
 _________________
2| | |X| | | | | |
 _________________
3| | | | | | | | |
 _________________
4| | | | | | | | |
 _________________
5| | | | | | | | |
 _________________
6| | | | | |O| | |
 _________________
7| | | | | | | | |
 _________________
8| | | | | | | | |
 _________________

Player O, choose your next board position to claim:
Row:
5
Column:
6
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6 7 8
 _________________
1| |X| | | | | | |
 _________________
2| | |X| | | | | |
 _________________
3| | | | | | | | |
 _________________
4| | | | | | | | |
 _________________
5| | | | | |O| | |
 _________________
6| | | | | |O| | |
 _________________
7| | | | | | | | |
 _________________
8| | | | | | | | |
 _________________

Player X, choose your next board position to claim:
Row:
3
Column:
4
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6 7 8
 _________________
1| |X| | | | | | |
 _________________
2| | |X| | | | | |
 _________________
3| | | |X| | | | |
 _________________
4| | | | | | | | |
 _________________
5| | | | | |O| | |
 _________________
6| | | | | |O| | |
 _________________
7| | | | | | | | |
 _________________
8| | | | | | | | |
 _________________

Player O, choose your next board position to claim:
Row:
4
Column:
6
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6 7 8
 _________________
1| |X| | | | | | |
 _________________
2| | |X| | | | | |
 _________________
3| | | |X| | | | |
 _________________
4| | | | | |O| | |
 _________________
5| | | | | |O| | |
 _________________
6| | | | | |O| | |
 _________________
7| | | | | | | | |
 _________________
8| | | | | | | | |
 _________________

Player X, choose your next board position to claim:
Row:
4
Column:
5
Tic-Tac-Toe
4-in-a-row are needed to win!
  1 2 3 4 5 6 7 8
 _________________
1| |X| | | | | | |
 _________________
2| | |X| | | | | |
 _________________
3| | | |X| | | | |
 _________________
4| | | | |X|O| | |
 _________________
5| | | | | |O| | |
 _________________
6| | | | | |O| | |
 _________________
7| | | | | | | | |
 _________________
8| | | | | | | | |
 _________________

Player O, choose your next board position to claim:
Row:
3
Column:
6
Player O wins!

ch16_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

enum CheckersSquare
{
    Checkers_Filled,
    Checkers_NotFilled,
    Checkers_SinglePiece_Black,
    Checkers_KingPiece_Black,
    Checkers_SinglePiece_Red,
    Checkers_KingPiece_Red
};

enum CheckersPlayers
{
    CheckersPlayers_Black,
    CheckersPlayers_Red
};

enum CheckersMoves
{
    CheckersMoves_ForwardLeft = 1,
    CheckersMoves_ForwardRight = 2,
    CheckersMoves_BackwardLeft = 3,
    CheckersMoves_BackwardRight = 4
};

int const maxBoardSize = 50;
int const minBoardSize = 10;

int const maxPieces = 500;
int const minPieces = 20;

bool isEven(int number)
{
    return (number % 2 == 0);
}

bool isOdd(int number)
{
    return !isEven(number);
}

bool isValidSquare(int row, int column)
{
    return ( ( isEven(row) && isOdd(column) ) || ( isOdd(row) && isEven(column) ) );
}

void populateGameBoard(CheckersSquare array[][50], int size)
{
    for (int i = 0; i < size; i++)
    {
        for (int j = 0; j < size; j++)
        {
            if (isValidSquare(i, j))
            {
                array[i][j] = Checkers_Filled;
            }
            else
            {
                array[i][j] = Checkers_NotFilled;
            }
        }
    }
}

void populateBlackPieces(int boardSize, CheckersSquare playerPieces[][50], int numberOfPieces)
{
    int currentPlayerPiece = 1;

    for (int i = 0; i < boardSize; i++)
    {
        for (int j = 0; j < boardSize; j++)
        {
            if ( (currentPlayerPiece <= numberOfPieces) &&
                    ( isValidSquare(i, j) ) )
            {
                playerPieces[i][j] = Checkers_SinglePiece_Black;
                currentPlayerPiece++;
            }
            else
            {
                playerPieces[i][j] = Checkers_NotFilled;
            }
        }
    }
}

void populateRedPieces(int boardSize, CheckersSquare playerPieces[][50], int numberOfPieces)
{
    int currentPlayerPiece = 1;

    for (int i = boardSize - 1; i >= 0 ; i--)
    {
        for (int j = boardSize - 1; j >= 0; j--)
        {
            if ( (currentPlayerPiece <= numberOfPieces) &&
                    ( isValidSquare(i, j) ) )
            {
                playerPieces[i][j] = Checkers_SinglePiece_Red;
                currentPlayerPiece++;
            }
            else
            {
                playerPieces[i][j] = Checkers_NotFilled;
            }
        }
    }
}

string translateEnumToString(CheckersSquare squareState)
{
    switch (squareState)
    {
    case Checkers_Filled:
        return "#";
    case Checkers_NotFilled:
        return " ";
    case Checkers_SinglePiece_Red:
        return "x";
    case Checkers_KingPiece_Red:
        return "X";
    case Checkers_SinglePiece_Black:
        return "o";
    case Checkers_KingPiece_Black:
        return "O";
    default:
        return "~";
    }
}

string translateEnumToString(CheckersPlayers squareState)
{
    switch (squareState)
    {
    case CheckersPlayers_Black:
        return "O";
    case CheckersPlayers_Red:
        return "X";
    default:
        return "~";
    }
}

void drawBoard(CheckersSquare gameBoard[][50], int boardSizeUsed, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50])
{
    cout << "Checkers\n";
    cout << "Black (O) Side\n";
    string horizontalBar = " _";
    for (int i = 0; i < boardSizeUsed; i++)
    {
        horizontalBar += "__";
    }

    for (int i = 0; i <= boardSizeUsed; i++)
    {
        if (i == 0)
        {
            for (int j = 0; j <= boardSizeUsed; j++)
            {
                if (j == 0)
                {
                    cout << " ";
                }
                else
                {
                    cout << " " << j;
                }
            }
            cout << "\n";
        }
        else
        {
            cout << horizontalBar << "\n";
            for (int j = 0; j <= boardSizeUsed; j++)
            {
                if (j == 0)
                {
                    cout << i;
                }
                else
                {
                    string squareCharacter;
                    if (playerPieces[i - 1][j - 1] != Checkers_NotFilled)
                    {
                        squareCharacter = translateEnumToString(playerPieces[i - 1][j - 1]);
                    }
                    else if (oppositionPieces[i - 1][j - 1] != Checkers_NotFilled)
                    {
                        squareCharacter = translateEnumToString(oppositionPieces[i - 1][j - 1]);
                    }
                    else
                    {
                        squareCharacter = translateEnumToString(gameBoard[i - 1][j - 1]);
                    }

                    cout << "|" << squareCharacter;
                }
            }
            cout << "|\n";
        }
    }
    cout << "Red (X) Side\n";
    cout << horizontalBar << "\n\n";
}

CheckersPlayers setPlayer(CheckersPlayers playerBlackInSession)
{
    if (playerBlackInSession == CheckersPlayers_Red)
    {
        return CheckersPlayers_Black;
    }
    return CheckersPlayers_Red;
}

CheckersPlayers getPlayer(CheckersSquare playerPiece)
{
    if ((playerPiece == Checkers_SinglePiece_Black) || (playerPiece == Checkers_KingPiece_Black))
    {
        return CheckersPlayers_Black;
    }
    return CheckersPlayers_Red;
}

bool isPieceKing(CheckersSquare playerPiece)
{
    return ((playerPiece == Checkers_KingPiece_Black) || (playerPiece == Checkers_KingPiece_Red));
}

void getMoveOffset(CheckersPlayers player, CheckersMoves move, int moveOffset[2])
{
    switch (move)
    {
    case CheckersMoves_ForwardLeft:
        moveOffset[0] = 1;
        moveOffset[1] = 1;
        break;
    case CheckersMoves_ForwardRight:
        moveOffset[0] = 1;
        moveOffset[1] = -1;
        break;
    case CheckersMoves_BackwardLeft:
        moveOffset[0] = -1;
        moveOffset[1] = 1;
        break;
    case CheckersMoves_BackwardRight:
        moveOffset[0] = -1;
        moveOffset[1] = -1;
        break;
    default:
        moveOffset[0] = 0;
        moveOffset[1] = 0;
        break;
    }

    int direction = 1;
    if (player == CheckersPlayers_Red)
    {
        direction = -1;
    }

    moveOffset[0] = moveOffset[0] * direction;
    moveOffset[1] = moveOffset[1] * direction;
}

bool isInBounds(int row, int column, int boardSizeUse)
{
    return ( (0 <= row) && (row < boardSizeUse) &&
             (0 <= column) && (column < boardSizeUse) );
}

bool moveIsOntoOppositionPiece(int landingRow, int landingColumn, CheckersSquare oppositionPieces[][50])
{
    CheckersSquare neighboringOpposingPiece = oppositionPieces[landingRow][landingColumn];
    return (neighboringOpposingPiece != Checkers_NotFilled);
}

bool moveIsValid(int boardPosition[], int offset[], int boardSizeUsed, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50])
{
    int landingRow = boardPosition[0] + offset[0];
    int landingColumn = boardPosition[1] + offset[1];

    if (!isInBounds(landingRow, landingColumn, boardSizeUsed))
    {
        return false;
    }

    CheckersSquare neighboringPlayerPiece = playerPieces[landingRow][landingColumn];
    if (neighboringPlayerPiece != Checkers_NotFilled)
    {
        return false;
    }

    if (moveIsOntoOppositionPiece(landingRow, landingColumn, oppositionPieces))
    {
        landingRow += offset[0];
        landingColumn += offset[1];

        if (!isInBounds(landingRow, landingColumn, boardSizeUsed))
        {
            return false;
        }

        CheckersSquare landingSquareOpposition = oppositionPieces[landingRow][landingColumn];
        CheckersSquare landingSquarePlayer = playerPieces[landingRow][landingColumn];
        if ( (landingSquareOpposition != Checkers_NotFilled) ||
                (landingSquarePlayer != Checkers_NotFilled) )
        {
            return false;
        }
    }
    return true;
}

bool isValidPosition(int boardPosition[], CheckersPlayers player, CheckersSquare playerPieces[][50])
{
    if (player == CheckersPlayers_Black)
    {
        return ( (playerPieces[ boardPosition[0] ][ boardPosition[1] ] == Checkers_SinglePiece_Black) ||
                 (playerPieces[ boardPosition[0] ][ boardPosition[1] ] == Checkers_KingPiece_Black) );
    }

    if (player == CheckersPlayers_Red)
    {
        return ( (playerPieces[ boardPosition[0] ][ boardPosition[1] ] == Checkers_SinglePiece_Red) ||
                 (playerPieces[ boardPosition[0] ][ boardPosition[1] ] == Checkers_KingPiece_Red) );
    }

    return false;
}

bool isPieceTrapped(int boardPosition[], CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50], int boardSizeUsed)
{
    CheckersSquare playerPiece = playerPieces[boardPosition[0]][boardPosition[1]];
    CheckersPlayers player = getPlayer(playerPiece);
    bool isCurrentPieceKing = isPieceKing(playerPiece);

    int maxEnum = 2;
    if (isCurrentPieceKing)
    {
        maxEnum = 4;
    }
    int tempMove[2];
    for (int i = 1; i <= maxEnum; i++)
    {
        getMoveOffset(player, static_cast<CheckersMoves>(i), tempMove);
        if (moveIsValid(boardPosition, tempMove, boardSizeUsed, playerPieces, oppositionPieces))
        {
            return false;
        }
    }

    return true;
}

void getBoardPosition(int boardPosition[], int boardSizeUsed, CheckersPlayers player, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50])
{
    int startRow = 0;
    int startColumn = 0;
    bool isCurrentValidPosition;

    do
    {
        cout << "Player " << translateEnumToString(player) << ", choose the piece to move:\n";

        cout << "Row: \n";
        cin >> startRow;
        startRow--;
        boardPosition[0] = startRow;

        cout << "Column: \n";
        cin >> startColumn;
        startColumn--;
        boardPosition[1] = startColumn;

        cout << '\n';
        isCurrentValidPosition = isValidPosition(boardPosition, player, playerPieces);
        if (!isCurrentValidPosition)
        {
            cout << "Position chosen is invalid. \n";
            cout << "Please choose a row/column locating the piece to move.\n";
            continue;
        }

        isCurrentValidPosition = !isPieceTrapped(boardPosition, playerPieces, oppositionPieces, boardSizeUsed);
        if (!isCurrentValidPosition)
        {
            cout << "Piece chosen is trapped! \n";
            cout << "Please choose a different piece.\n";
            continue;
        }
    }
    while (!isCurrentValidPosition);
}

void chooseBoardMove(int boardPosition[], int boardMove[], int boardSizeUsed, CheckersSquare playerPiece, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50])
{
    int moveChoice = 0;
    int tempMove[2];
    bool isCurrentValidMove = false;
    CheckersPlayers player = getPlayer(playerPiece);

    bool isCurrentPieceKing = isPieceKing(playerPiece);
    int maxEnum = 2;
    if (isCurrentPieceKing)
    {
        maxEnum = 4;
    }

    string pieceType = "regular";
    if (isCurrentPieceKing)
    {
        pieceType = "king";
    }

    do
    {
        cout << "Player " << translateEnumToString(player) << ", choose where to move the " << pieceType << " piece in reference to your starting side and direction:\n";
        cout << "1: Forward-Left\n";
        cout << "2: Forward-Right\n";
        if (isCurrentPieceKing)
        {
            cout << "3: Backward-Left\n";
            cout << "4: Backward-Right\n";
        }
        cin >> moveChoice;

        if (moveChoice < 1 || moveChoice > maxEnum)
        {
            cout << "Please enter a valid move number.\n";
            continue;
        }

        getMoveOffset(player, static_cast<CheckersMoves>(moveChoice), tempMove);

        isCurrentValidMove = moveIsValid(boardPosition, tempMove, boardSizeUsed, playerPieces, oppositionPieces);
        if (!isCurrentValidMove)
        {
            cout << "\n" << "Move will land piece out of bounds, or onto an occupied square." << "\n";
            cout << "Please choose another move." << "\n";
        }
    }
    while (!isCurrentValidMove);

    boardMove[0] = tempMove[0];
    boardMove[1] = tempMove[1];
}

bool pieceCanJumpNeighboringPiece(int boardPosition[], CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50], int boardSizeUsed)
{
    CheckersSquare playerPiece = playerPieces[boardPosition[0]][boardPosition[1]];
    CheckersPlayers player = getPlayer(playerPiece);
    bool isCurrentPieceKing = isPieceKing(playerPiece);

    int maxEnum = 2;
    if (isCurrentPieceKing)
    {
        maxEnum = 4;
    }
    int tempMove[2];
    for (int i = 1; i <= maxEnum; i++)
    {
        getMoveOffset(player, static_cast<CheckersMoves>(i), tempMove);
        if (moveIsValid(boardPosition, tempMove, boardSizeUsed, playerPieces, oppositionPieces))
        {
            return true;
        }
    }

    return false;
}

bool isOnBoardTopBottomEdge(int row, int boardSizeUsed)
{
    return ((row == 0) || (row == (boardSizeUsed - 1)));
}

void kingPiece(int row, int column, CheckersSquare playerPieces[][50])
{
    CheckersSquare currentPiece = playerPieces[row][column];
    if (currentPiece == Checkers_SinglePiece_Black)
    {
        playerPieces[row][column] = Checkers_KingPiece_Black;
    }
    if (currentPiece == Checkers_SinglePiece_Red)
    {
        playerPieces[row][column] = Checkers_KingPiece_Red;
    }
}

bool makeBoardMove(int boardPosition[], int boardMove[], int boardSizeUsed, CheckersSquare playerPieces[][50],  CheckersSquare oppositionPieces[][50])
{
    int landingRow = boardPosition[0] + boardMove[0];
    int landingColumn = boardPosition[1] + boardMove[1];
    bool continueTurn = false;
    bool pieceWasJumped = false;

    if (moveIsOntoOppositionPiece(landingRow, landingColumn, oppositionPieces))
    {
        oppositionPieces[landingRow][landingColumn] = Checkers_NotFilled;
        pieceWasJumped = true;
        cout << "A piece was just jumped!\n";

        landingRow += boardMove[0];
        landingColumn += boardMove[1];

        continueTurn = true;
    }

    CheckersSquare currentPiece = playerPieces[ boardPosition[0] ][ boardPosition[1] ];
    playerPieces[ boardPosition[0] ][ boardPosition[1] ] = Checkers_NotFilled;
    playerPieces[landingRow][landingColumn] = currentPiece;
    boardPosition[0] = landingRow;
    boardPosition[1] = landingColumn;

    if (pieceWasJumped)
    {
        continueTurn = pieceCanJumpNeighboringPiece(boardPosition, playerPieces, oppositionPieces, boardSizeUsed);
    }

    if (isOnBoardTopBottomEdge(landingRow, boardSizeUsed))
    {
        if (!isPieceKing(currentPiece))
        {
            kingPiece(landingRow, landingColumn, playerPieces);
            cout << "Piece is upgraded to a king!\n";
        }
        continueTurn = false;
    }

    return continueTurn;
}

bool areAllOppositionPiecesEliminated(int boardSizeUsed, CheckersSquare oppositionPieces[][50])
{
    for (int i = 0; i < boardSizeUsed; i++)
    {
        for (int j = 0; j < boardSizeUsed; j++)
        {
            if (oppositionPieces[i][j] != Checkers_NotFilled)
            {
                return false;
            }
        }
    }
    return true;
}

bool areAllOppositionPiecesTrapped(int boardSizeUsed, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50])
{
    for (int i = 0; i < boardSizeUsed; i++)
    {
        for (int j = 0; j < boardSizeUsed; j++)
        {
            if (oppositionPieces[i][j] != Checkers_NotFilled)
            {
                int boardPosition[2] = { i, j };
                if (!isPieceTrapped(boardPosition, oppositionPieces, playerPieces, boardSizeUsed))
                {
                    return false;
                }
            }
        }
    }
    return true;
}

bool choiceWins(int boardSizeUsed, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50])
{
    return (areAllOppositionPiecesEliminated(boardSizeUsed, oppositionPieces) || areAllOppositionPiecesTrapped(boardSizeUsed, playerPieces, oppositionPieces));
}

bool isTurnWinning(int boardPosition[], int boardMove[], CheckersPlayers player, CheckersSquare playerPieces[][50], CheckersSquare oppositionPieces[][50], CheckersSquare gameBoard[][50], int boardSizeUsed)
{
    getBoardPosition(boardPosition, boardSizeUsed, player, playerPieces, oppositionPieces);
    CheckersSquare playerPiece = playerPieces[ boardPosition[0] ][ boardPosition[1] ];

    bool nextPlayer;
    do
    {
        chooseBoardMove(boardPosition, boardMove, boardSizeUsed, playerPiece, playerPieces, oppositionPieces);
        nextPlayer = !makeBoardMove(boardPosition, boardMove, boardSizeUsed, playerPieces, oppositionPieces);
        drawBoard(gameBoard, boardSizeUsed, playerPieces, oppositionPieces);

        if (choiceWins(boardSizeUsed, playerPieces, oppositionPieces))
        {
            cout << "Player " << translateEnumToString(player) << " wins!\n";
            return true;
        }
    }
    while (!nextPlayer);
    return false;
}

int main(int argc, const char *argv[])
{
    try
    {
        int boardSizeUsed = minBoardSize;
        int numberOfPiecesUsed = minPieces;

        CheckersSquare gameBoard[maxBoardSize][maxBoardSize];
        populateGameBoard(gameBoard, maxBoardSize);

        CheckersSquare BlackPieces[maxBoardSize][maxBoardSize];
        populateBlackPieces(boardSizeUsed, BlackPieces, numberOfPiecesUsed);

        CheckersSquare RedPieces[maxBoardSize][maxBoardSize];
        populateRedPieces(boardSizeUsed, RedPieces, numberOfPiecesUsed);

        CheckersPlayers player = CheckersPlayers_Black;

        bool gameFinished = false;
        int boardPosition[2];
        int boardMove[2];
        drawBoard(gameBoard, boardSizeUsed, BlackPieces, RedPieces);
        do
        {
            if (player == CheckersPlayers_Black)
            {
                gameFinished = isTurnWinning(boardPosition, boardMove, player, BlackPieces, RedPieces, gameBoard, boardSizeUsed);
            }
            else
            {
                gameFinished = isTurnWinning(boardPosition, boardMove, player, RedPieces, BlackPieces, gameBoard, boardSizeUsed);
            }

            player = setPlayer(player);
        }
        while (!gameFinished);

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Checkers
Black (O) Side
  1 2 3 4 5 6 7 8 9 10
 _____________________
1| |o| |o| |o| |o| |o|
 _____________________
2|o| |o| |o| |o| |o| |
 _____________________
3| |o| |o| |o| |o| |o|
 _____________________
4|o| |o| |o| |o| |o| |
 _____________________
5| |#| |#| |#| |#| |#|
 _____________________
6|#| |#| |#| |#| |#| |
 _____________________
7| |x| |x| |x| |x| |x|
 _____________________
8|x| |x| |x| |x| |x| |
 _____________________
9| |x| |x| |x| |x| |x|
 _____________________
10|x| |x| |x| |x| |x| |
Red (X) Side
 _____________________

Player O, choose the piece to move:
Row:
4
Column:
3

Player O, choose where to move the regular piece in reference to your starting side and direction:
1: Forward-Left
2: Forward-Right
1
Checkers
Black (O) Side
  1 2 3 4 5 6 7 8 9 10
 _____________________
1| |o| |o| |o| |o| |o|
 _____________________
2|o| |o| |o| |o| |o| |
 _____________________
3| |o| |o| |o| |o| |o|
 _____________________
4|o| |#| |o| |o| |o| |
 _____________________
5| |#| |o| |#| |#| |#|
 _____________________
6|#| |#| |#| |#| |#| |
 _____________________
7| |x| |x| |x| |x| |x|
 _____________________
8|x| |x| |x| |x| |x| |
 _____________________
9| |x| |x| |x| |x| |x|
 _____________________
10|x| |x| |x| |x| |x| |
Red (X) Side
 _____________________

Player X, choose the piece to move:
Row:
7
Column:
4

Player X, choose where to move the regular piece in reference to your starting side and direction:
1: Forward-Left
2: Forward-Right
2
Checkers
Black (O) Side
  1 2 3 4 5 6 7 8 9 10
 _____________________
1| |o| |o| |o| |o| |o|
 _____________________
2|o| |o| |o| |o| |o| |
 _____________________
3| |o| |o| |o| |o| |o|
 _____________________
4|o| |#| |o| |o| |o| |
 _____________________
5| |#| |o| |#| |#| |#|
 _____________________
6|#| |#| |x| |#| |#| |
 _____________________
7| |x| |#| |x| |x| |x|
 _____________________
8|x| |x| |x| |x| |x| |
 _____________________
9| |x| |x| |x| |x| |x|
 _____________________
10|x| |x| |x| |x| |x| |
Red (X) Side
 _____________________

Player O, choose the piece to move:
Row:
3
Column:
3

Position chosen is invalid.
Please choose a row/column locating the piece to move.
Player O, choose the piece to move:
Row:
3
Column:
4

Player O, choose where to move the regular piece in reference to your starting side and direction:
1: Forward-Left
2: Forward-Right
2
Checkers
Black (O) Side
  1 2 3 4 5 6 7 8 9 10
 _____________________
1| |o| |o| |o| |o| |o|
 _____________________
2|o| |o| |o| |o| |o| |
 _____________________
3| |o| |#| |o| |o| |o|
 _____________________
4|o| |o| |o| |o| |o| |
 _____________________
5| |#| |o| |#| |#| |#|
 _____________________
6|#| |#| |x| |#| |#| |
 _____________________
7| |x| |#| |x| |x| |x|
 _____________________
8|x| |x| |x| |x| |x| |
 _____________________
9| |x| |x| |x| |x| |x|
 _____________________
10|x| |x| |x| |x| |x| |
Red (X) Side
 _____________________

Player X, choose the piece to move:
Row:
6
Column:
5

Player X, choose where to move the regular piece in reference to your starting side and direction:
1: Forward-Left
2: Forward-Right
2
Checkers
Black (O) Side
  1 2 3 4 5 6 7 8 9 10
 _____________________
1| |o| |o| |o| |o| |o|
 _____________________
2|o| |o| |o| |o| |o| |
 _____________________
3| |o| |#| |o| |o| |o|
 _____________________
4|o| |o| |o| |o| |o| |
 _____________________
5| |#| |o| |x| |#| |#|
 _____________________
6|#| |#| |#| |#| |#| |
 _____________________
7| |x| |#| |x| |x| |x|
 _____________________
8|x| |x| |x| |x| |x| |
 _____________________
9| |x| |x| |x| |x| |x|
 _____________________
10|x| |x| |x| |x| |x| |
Red (X) Side
 _____________________

Player O, choose the piece to move:
Row:
2
Column:
5

Player O, choose where to move the regular piece in reference to your starting side and direction:
1: Forward-Left
2: Forward-Right
2
Checkers
Black (O) Side
  1 2 3 4 5 6 7 8 9 10
 _____________________
1| |o| |o| |o| |o| |o|
 _____________________
2|o| |o| |#| |o| |o| |
 _____________________
3| |o| |o| |o| |o| |o|
 _____________________
4|o| |o| |o| |o| |o| |
 _____________________
5| |#| |o| |x| |#| |#|
 _____________________
6|#| |#| |#| |#| |#| |
 _____________________
7| |x| |#| |x| |x| |x|
 _____________________
8|x| |x| |x| |x| |x| |
 _____________________
9| |x| |x| |x| |x| |x|
 _____________________
10|x| |x| |x| |x| |x| |
Red (X) Side
 _____________________

Player X, choose the piece to move:
Row:

ch16_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

enum Direction
{
    North,
    South,
    East,
    West
};

struct Position
{
    int row;
    int column;
};

struct Cell
{
    enum Wall
    {
        Wall_North = 0x0008,
        Wall_South = 0x0002,
        Wall_East = 0x0004,
        Wall_West = 0x0001,
        Wall_All = 0x000f,
        Wall_None = 0x0000
    };

    struct Position position;
    int walls;

    int getWalls() const
    {
        return walls & Wall_All;
    }
    void setWalls(const int w)
    {
        walls = w & Wall_All;
    }
    void removeWall(const int w)
    {
        if (w != Wall_North && w != Wall_East && w != Wall_South && w != Wall_West)
        {
            return;
        }
        walls &= ~w;
    }


    string print() const
    {
        string cell = "<";
        if ( ( getWalls() & Wall_West ) != 0 )
        {
            cell += 'W';
        }
        else
        {
            cell += " ";
        }

        if ( ( getWalls() & Wall_South ) != 0 )
        {
            cell += 'S';
        }
        else
        {
            cell += " ";
        }

        if ( ( getWalls() & Wall_North ) != 0 )
        {
            cell += 'N';
        }
        else
        {
            cell += " ";
        }

        if ( ( getWalls() & Wall_East ) != 0 )
        {
            cell += 'E';
        }
        else
        {
            cell += " ";
        }
        cell += ">";
        return cell;
    }
};

struct VectorCell
{
    Cell *array = nullptr;
    int size = 0;
    int maxSize = 0;

    bool isEmpty() const
    {
        return (size == 0);
    }

    void clear()
    {
        size = 0;
        maxSize = 0;
        if (array != nullptr)
        {
            delete[] array;
            array = nullptr;
        }
    }

    void pushBack(Cell *cell)
    {
        if (size == maxSize)
        {
            if (maxSize == 0)
            {
                Cell *p_newvalues = new Cell[8];
                p_newvalues[size] = *cell;
                if (array != nullptr)
                {
                    delete[] array;
                    array = nullptr;
                }
                array = p_newvalues;
                size++;
                maxSize = 8;
            }
            else
            {
                Cell *p_newvalues = new Cell[maxSize * 2];
                for (int i = 0; i < size; i++)
                {
                    p_newvalues[i] = array[i];
                }
                p_newvalues[size] = *cell;
                if (array != nullptr)
                {
                    delete[] array;
                    array = nullptr;
                }
                array = p_newvalues;
                size++;
                maxSize *= 2;
            }
        }
        else
        {
            array[size] = *cell;
            size++;
        }
    }

    void popBack()
    {
        if (size > 0)
        {
            size--;
            if (size == 0)
            {
                clear();
            }
        }
    }
};

struct VectorDirection
{
    Direction *array = nullptr;
    int size = 0;
    int maxSize = 0;

    bool isEmpty() const
    {
        return (size == 0);
    }

    void clear()
    {
        size = 0;
        maxSize = 0;
        if (array != nullptr)
        {
            delete[] array;
            array = nullptr;
        }
    }

    void pushBack(Direction direction)
    {
        if (size == maxSize)
        {
            if (maxSize == 0)
            {
                Direction *p_newvalues = new Direction[8];
                p_newvalues[size] = direction;
                if (array != nullptr)
                {
                    delete[] array;
                    array = nullptr;
                }
                array = p_newvalues;
                size++;
                maxSize = 8;
            }
            else
            {
                Direction *p_newvalues = new Direction[maxSize * 2];
                for (int i = 0; i < size; i++)
                {
                    p_newvalues[i] = array[i];
                }
                p_newvalues[size] = direction;
                if (array != nullptr)
                {
                    delete[] array;
                    array = nullptr;
                }
                array = p_newvalues;
                size++;
                maxSize *= 2;
            }
        }
        else
        {
            array[size] = direction;
            size++;
        }
    }

    void popBack()
    {
        if (size > 0)
        {
            size--;
            if (size == 0)
            {
                clear();
            }
        }
    }
};

int main(int argc, const char *argv[])
{
    try
    {
        srand( time(nullptr) );

        int mazeWidth = 6;
        int mazeHeight = 6;

        do
        {
            mazeWidth = 6;
            mazeHeight = 6;
            cout << "Please specify the dimensions of the maze (at least 6x6):\n";
            cout << "Width: ";
            cin >> mazeWidth;
            cin.clear();
            cin.ignore(80, '\n');

            cout << "Height: ";
            cin >> mazeHeight;
            cin.clear();
            cin.ignore(80, '\n');

            cout << '\n';
        }
        while ( (mazeWidth < 6) || (mazeHeight < 6) );

        Cell **maze = new Cell*[mazeWidth];
        for (int i = 0; i < mazeWidth; i++)
        {
            maze[i] = new Cell[mazeHeight];
        }

        for (int row = 0; row < mazeWidth; row++)
        {
            for (int column = 0; column < mazeHeight; column++)
            {
                maze[row][column].position.row = row;
                maze[row][column].position.column = column;
                maze[row][column].setWalls(Cell::Wall_All);
            }
        }

        int currentRow = rand() % mazeWidth;
        int currentColumn = rand() % mazeHeight;

        VectorCell trail;
        trail.pushBack( & ( maze[currentRow][currentColumn] ) );

        VectorDirection currentDirections;

        while ( !trail.isEmpty() )
        {
            currentDirections.clear();
            if (currentColumn > 0)
            {
                if (maze[currentRow][currentColumn - 1].getWalls() == Cell::Wall_All)
                {
                    currentDirections.pushBack(West);
                }
            }

            if (currentColumn < mazeHeight - 1)
            {
                if (maze[currentRow][currentColumn + 1].getWalls() == Cell::Wall_All)
                {
                    currentDirections.pushBack(East);
                }
            }

            if (currentRow > 0)
            {
                if (maze[currentRow - 1][currentColumn].getWalls() == Cell::Wall_All)
                {
                    currentDirections.pushBack(North);
                }
            }

            if (currentRow < mazeWidth - 1)
            {
                if (maze[currentRow + 1][currentColumn].getWalls() == Cell::Wall_All)
                {
                    currentDirections.pushBack(South);
                }
            }

            if ( !currentDirections.isEmpty() )
            {
                int randomDirectionIndex = rand() % currentDirections.size;

                switch (currentDirections.array[randomDirectionIndex])
                {
                case North:
                    maze[currentRow][currentColumn].removeWall(Cell::Wall_North);
                    maze[currentRow - 1][currentColumn].removeWall(Cell::Wall_South);
                    --currentRow;
                    break;
                case South:
                    maze[currentRow][currentColumn].removeWall(Cell::Wall_South);
                    maze[currentRow + 1][currentColumn].removeWall(Cell::Wall_North);
                    ++currentRow;
                    break;
                case East:
                    maze[currentRow][currentColumn].removeWall(Cell::Wall_East);
                    maze[currentRow][currentColumn + 1].removeWall(Cell::Wall_West);
                    ++currentColumn;
                    break;
                case West:
                    maze[currentRow][currentColumn].removeWall(Cell::Wall_West);
                    maze[currentRow][currentColumn - 1].removeWall(Cell::Wall_East);
                    --currentColumn;
                    break;
                default:
                    break;
                }

                trail.pushBack( & ( maze[currentRow][currentColumn] ) );
            }
            else
            {
                trail.popBack();

                if ( !trail.isEmpty() )
                {
                    currentRow = trail.array[trail.size - 1].position.row;
                    currentColumn = trail.array[trail.size - 1].position.column;
                }
            }
        }


        for (int row = 0; row < mazeWidth; row++)
        {
            for (int column = 0; column < mazeHeight; column++)
            {
                if (column != 0)
                {
                    cout << ", ";
                }
                cout << maze[row][column].print();
            }
            cout << "\n";
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Please specify the dimensions of the maze (at least 6x6):
Width: 9
Height: 9

<WSN >, <  N >, < SNE>, <W N >, < SN >, < SN >, < SN >, <  NE>, <W NE>
<W N >, <   E>, <W N >, < S E>, <W NE>, <W N >, < SN >, < S E>, <W  E>
<W  E>, <WS E>, <WS  >, < SN >, <   E>, <WS E>, <W NE>, <W N >, <   E>
<W  E>, <W N >, < SN >, <  NE>, <W  E>, <WSN >, < S  >, < S E>, <W  E>
<W   >, < S E>, <W N >, < S E>, <W  E>, <W N >, <  NE>, <W N >, < S E>
<W  E>, <W NE>, <WS  >, <  NE>, <W  E>, <W  E>, <W  E>, <WS  >, <  NE>
<W  E>, <W   >, <  NE>, <W  E>, <WS  >, < S E>, <WS  >, < SN >, <   E>
<WS  >, < S E>, <W  E>, <WS  >, < SN >, < SN >, <  NE>, <W N >, < S E>
<WSN >, < SN >, < S  >, < SN >, < SN >, < SNE>, <WS  >, < S  >, < SNE>

ch16_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

const int not_a_reading = -7777;
const int not_a_month = -1;

class Day
{
public:
    vector<double> hour;
    Day();
};

Day::Day() : hour(24)
{
    for (int i = 0; i < hour.size(); ++i)
    {
        hour[i] = not_a_reading;
    }
}

class Month
{
public:
    int month;
    vector<Day> day;
    Month() : month(not_a_month), day(32) { }
};

class Year
{
public:
    int year;
    vector<Month> month;
    Year() : month(12) { }
};

class Reading
{
public:
    int day;
    int hour;
    double temperature;
    Reading() : day(0), hour(0), temperature(0) { }
};

int month_to_int(const string &s);
bool is_valid(const Reading &r);
void end_of_loop(istream &ist, char term, const string &message);

istream &operator>>(istream &is, Reading &r)
{
    char ch1;
    if (is >> ch1 && ch1 != '(')
    {
        is.unget();
        is.clear(std::ios_base::failbit);
        return is;
    }
    if (!is)
    {
        return is;
    }

    char ch2;
    int d;
    int h;
    double t;
    is >> d >> h >> t >> ch2;
    if (!is || ch2 != ')')
    {
        error("bad reading");
    }
    r.day = d;
    r.hour = h;
    r.temperature = t;
    return is;
}

istream &operator>>(istream &is, Month &m)
{
    char ch = 0;
    if (is >> ch && ch != '{')
    {
        is.unget();
        is.clear(std::ios_base::failbit);
        return is;
    }
    if (!is)
    {
        return is;
    }

    string month_marker;
    string mm;
    is >> month_marker >> mm;
    if (!is || month_marker != "month")
    {
        error("bad start of month");
    }
    m.month = month_to_int(mm);

    Reading r;
    int no_of_duplicate_readings = 0;
    int no_invalid_readings = 0;

    while (is >> r)
    {
        if (is_valid(r))
        {
            if (m.day[r.day].hour[r.hour] != not_a_reading)
            {
                ++no_of_duplicate_readings;
            }
            m.day[r.day].hour[r.hour] = r.temperature;
        }
        else
        {
            ++no_invalid_readings;
        }
    }
    end_of_loop(is, '}', "bad end of month");
    return is;
}

const int implausible_min = -200;
const int implausible_max = 200;

bool is_valid(const Reading &r)
{
    if (r.day < 1 || 31 < r.day)
    {
        return false;
    }
    if (r.hour < 0 || 23 < r.hour)
    {
        return false;
    }
    if (r.temperature < implausible_min || implausible_max < r.temperature)
    {
        return false;
    }
    return true;
}

istream &operator>>(istream &is, Year &y)
{
    char ch;
    is >> ch;
    if (!is)
    {
        return is;
    }
    if (ch != '{')
    {
        is.unget();
        is.clear(std::ios::failbit);
        return is;
    }

    string year_marker;
    int yy;
    is >> year_marker >> yy;
    if (!is || year_marker != "year")
    {
        error("bad start of year");
    }
    y.year = yy;

    while (true)
    {
        Month m;
        if (!(is >> m))
        {
            break;
        }
        y.month[m.month] = m;
    }

    end_of_loop(is, '}', "bad end of year");
    return is;
}

void end_of_loop(istream &ist, char term, const string &message)
{
    if (ist.fail())
    {
        ist.clear();
        char ch;
        if (ist >> ch && ch == term)
        {
            return;
        }
        error(message);
    }
}

vector<string> month_input_tbl;

void init_input_tbl(vector<string> &tbl)
{
    tbl.push_back("jan");
    tbl.push_back("feb");
    tbl.push_back("mar");
    tbl.push_back("apr");
    tbl.push_back("may");
    tbl.push_back("jun");
    tbl.push_back("jul");
    tbl.push_back("aug");
    tbl.push_back("sep");
    tbl.push_back("oct");
    tbl.push_back("nov");
    tbl.push_back("dec");
}

int month_to_int(const string &s)
{
    for (int i = 0; i < 12; ++i)
    {
        if (month_input_tbl[i] == s)
        {
            return i;
        }
    }
    return -1;
}

vector<string> month_print_tbl;

void init_print_tbl(vector<string> &tbl)
{
    tbl.push_back("January");
    tbl.push_back("February");
    tbl.push_back("March");
    tbl.push_back("April");
    tbl.push_back("May");
    tbl.push_back("June");
    tbl.push_back("July");
    tbl.push_back("August");
    tbl.push_back("September");
    tbl.push_back("October");
    tbl.push_back("November");
    tbl.push_back("December");
}

string int_to_month(int i)
{
    if (i < 0 || 12 <= i)
    {
        error("bad month index");
    }
    return month_print_tbl[i];
}

void print_day(ostream &ost, const Day &d, int daynum)
{
    bool is_empty = true;
    for (int i = 0; i < 24; ++i)
    {
        if (d.hour[i] != not_a_reading)
        {
            is_empty = false;
            break;
        }
    }
    if (is_empty)
    {
        return;
    }
    ost << "\n        " << daynum;
    for (int i = 0; i < 24; ++i)
    {
        if (d.hour[i] != not_a_reading)
        {
            ost << "\n            " << i << ":00 - " << d.hour[i] << " F";
        }
    }
}

void print_month(ostream &ost, const Month &m)
{
    if (m.month == not_a_month)
    {
        return;
    }
    ost << "\n    " << int_to_month(m.month);
    for (int i = 1; i < 32; ++i)
    {
        print_day(ost, m.day[i], i);
    }
}

void print_year(ostream &ost, const Year &y)
{
    ost << y.year << ' ';
    for (int i = 0; i < 12; ++i)
    {
        print_month(ost, y.month[i]);
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        init_print_tbl(month_print_tbl);
        init_input_tbl(month_input_tbl);

        cout << "Please enter input file name\n";
        string name;
        cin >> name;
        ifstream ifs(name.c_str());
        if (!ifs)
        {
            error("can't open input file " + name);
        }

        ifs.exceptions(ifs.exceptions() | std::ios_base::badbit);

        cout << "Please enter output file name\n";
        cin >> name;
        ofstream ofs(name.c_str());
        if (!ofs)
        {
            error("can't open output file " + name);
        }

        vector<Year> ys;
        while (true)
        {
            Year y;
            if (!(ifs >> y))
            {
                break;
            }
            ys.push_back(y);
        }
        cout << "read " << ys.size() << " years of readings\n";

        for (int i = 0; i < ys.size(); ++i)
        {
            print_year(ofs, ys[i]);
            ofs  << endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
cat ch16_p07.txt
{ year 1990 }
{ year 1991 { month jun } }
{ year 1992 { month jan (1 0 61.5) } { month feb (1 1 64) (2 2 65.2) } }
{ year 2000 { month feb (1 1 68) (2 3 66.66) (1 0 67.2) } { month dec (15 15 -9.2) (15 14 -8.8) (14 0 -2) } }

ch16_p07
Please enter input file name
ch16_p07.txt
Please enter output file name
ch16_p07_out.txt
read 4 years of readings

cat ch16_p07_out.txt
1990
1991
    June
1992
    January
        1
            0:00 - 61.5 F
    February
        1
            1:00 - 64 F
        2
            2:00 - 65.2 F
2000
    February
        1
            0:00 - 67.2 F
            1:00 - 68 F
        2
            3:00 - 66.66 F
    December
        14
            0:00 - -2 F
        15
            14:00 - -8.8 F
            15:00 - -9.2 F

ch16_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

std::random_device rd;
std::mt19937 gen(rd());

int getRandomNumber(const int &min, const int &max)
{
    return std::uniform_int_distribution<int> {min, max}(gen);
}

template<typename T>
bool isAscending(const vector<T> &v)
{
    bool isArrayAscending = true;
    for (int i = 1; i < v.size(); i++)
    {
        if (v[i] < v[i - 1])
        {
            isArrayAscending = false;
            break;
        }
    }
    return isArrayAscending;
}

template<typename T>
bool isSorted(const vector<T> &v)
{
    bool isArrayAscending = isAscending(v);

    for (int i = 1; i < v.size(); i++)
    {
        if ( isArrayAscending && (v[i] < v[i - 1]) )
        {
            return false;
        }

        if ( !isArrayAscending && (v[i] >= v[i - 1]) )
        {
            return false;
        }
    }
    return true;
}

template<typename T>
class Sort_by_ascending
{
public:
    bool operator()(const T &a, const T &b) const
    {
        return a <= b;
    }
};

template<typename T>
class Sort_by_descending
{
public:
    bool operator()(const T &a, const T &b) const
    {
        return a > b;
    }
};

template<typename T>
void sort(vector<T> &v, bool ascending)
{
        if (ascending)
        {
            sort(v.begin(), v.end(), Sort_by_ascending<T>());
        }
        else
        {
            sort(v.begin(), v.end(), Sort_by_descending<T>());
        }
}

int main(int argc, const char *argv[])
{
    try
    {
        vector<int> v1;

        for (int i = 0; i < 30; ++i)
        {
            v1.push_back(getRandomNumber(0, 100));
        }

        cout << "Original array: ";
        cout << v1;
        cout << '\n';

        if (isSorted(v1))
        {
            cout << "Array is sorted. No sorting action will be done." << '\n';
        }
        else
        {
            cout << "Array is not sorted. " << '\n';
            cout << "Array will be sorted based on the ordering of the first two elements." << '\n';
            bool isArrayAscending = isAscending(v1);

            sort(v1, isArrayAscending);

            cout << "Sorted array: ";
            cout << v1;
            cout << '\n';

            if (isSorted(v1))
            {
                cout << "Array has been correctly sorted." << '\n';
            }
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Original array: { 68, 54, 77, 44, 77, 32, 45, 20, 22, 10, 88, 36, 33, 78, 77, 76, 81, 22, 72, 28, 61, 1, 49, 42, 15, 66, 9, 50, 74, 8 }
Array is not sorted.
Array will be sorted based on the ordering of the first two elements.
Sorted array: { 88, 81, 78, 77, 77, 77, 76, 74, 72, 68, 66, 61, 54, 50, 49, 45, 44, 42, 36, 33, 32, 28, 22, 22, 20, 15, 10, 9, 8, 1 }

ch16_p09.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int numberOfPaddingItems(int number, int maxSize)
{
    string numberAsString = to_string(number);
    string maxSizeAsString = to_string(maxSize);

    return (maxSizeAsString.length() - numberAsString.length());
}

string numberWithPadding(int number, int maxSize)
{
    string numberAsString = to_string(number);
    string zeros;
    int paddingCount = numberOfPaddingItems(number, maxSize);
    if (paddingCount > 0)
    {
        for (int i = 0; i < paddingCount; i++)
        {
            zeros += '0';
        }
        numberAsString = zeros + numberAsString;
    }
    return numberAsString;
}

void printBoard(int tableSize, int **p_p_table, int maxEntrySize)
{
    string horizontalBar = " _";
    for (int i = 0; i < tableSize; i++)
    {
        horizontalBar += "__";
        int paddingCount = numberOfPaddingItems(1, maxEntrySize);
        if (paddingCount > 0)
        {
            for (int j = 0; j < paddingCount; j++)
            {
                horizontalBar += "_";
            }
        }
    }

    for (int i = 0; i <= tableSize; i++)
    {
        if (i == 0)
        {
            for (int j = 0; j <= tableSize; j++)
            {
                if (j == 0)
                {
                    cout << " ";
                }
                else
                {
                    cout << " " << numberWithPadding(j - 1, maxEntrySize);
                }
            }
            cout << "\n";
        }
        else
        {
            cout << horizontalBar << "\n";
            for (int j = 0; j <= tableSize; j++)
            {
                if (j == 0)
                {
                    cout << i - 1;
                }
                else
                {
                    string value = numberWithPadding(p_p_table[i - 1][j - 1], maxEntrySize);
                    cout << "|" << value;
                }
            }
            cout << "|\n";
        }
    }
    cout << horizontalBar << "\n\n";
}

int main(int argc, const char *argv[])
{
    try
    {
        int tableSize = 10;

        cout << "Please specify the size of the multiplication table (Default is 10x10): ";
        cin >> tableSize;

        int **p_p_table;
        p_p_table = new int *[tableSize];

        for (int i = 0; i < tableSize; i++)
        {
            p_p_table[i] = new int[tableSize];
        }

        for (int i = 0; i < tableSize; i++)
        {
            for (int j = 0; j < tableSize; j++)
            {
                p_p_table[i][j] = i * j;
            }
        }
        int maxEntrySize = (tableSize - 1) * (tableSize - 1);
        printBoard(tableSize, p_p_table, maxEntrySize);

        for (int i = 0; i < tableSize; i++)
        {
            delete [] p_p_table[i];
        }
        delete [] p_p_table;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Please specify the size of the multiplication table (Default is 10x10): 10
  00 01 02 03 04 05 06 07 08 09
 _______________________________
0|00|00|00|00|00|00|00|00|00|00|
 _______________________________
1|00|01|02|03|04|05|06|07|08|09|
 _______________________________
2|00|02|04|06|08|10|12|14|16|18|
 _______________________________
3|00|03|06|09|12|15|18|21|24|27|
 _______________________________
4|00|04|08|12|16|20|24|28|32|36|
 _______________________________
5|00|05|10|15|20|25|30|35|40|45|
 _______________________________
6|00|06|12|18|24|30|36|42|48|54|
 _______________________________
7|00|07|14|21|28|35|42|49|56|63|
 _______________________________
8|00|08|16|24|32|40|48|56|64|72|
 _______________________________
9|00|09|18|27|36|45|54|63|72|81|
 _______________________________

ch16_p10.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int **initializeTable2D(int tableWidth, int tableLength)
{
    int **p_p_table2D = new int *[tableWidth];
    for (int j = 0; j < tableWidth; j++)
    {
        p_p_table2D[j] = new int[tableLength];
    }
    return p_p_table2D;
}

void disposeTable2D(int **p_p_table2D, int tableWidth)
{
    for (int j = 0; j < tableWidth; j++)
    {
        delete[] p_p_table2D[j];
    }

    delete[] p_p_table2D;
}

int numberOfPaddingItems(int number, int maxSize)
{
    string numberAsString = to_string(number);
    string maxSizeAsString = to_string(maxSize);

    return (maxSizeAsString.length() - numberAsString.length());
}

string numberWithPadding(int number, int maxSize)
{
    string numberAsString = to_string(number);
    string zeros;
    int paddingCount = numberOfPaddingItems(number, maxSize);
    if (paddingCount > 0)
    {
        for (int i = 0; i < paddingCount; i++)
        {
            zeros += '0';
        }
        numberAsString = zeros + numberAsString;
    }
    return numberAsString;
}

void printTable(int tableWidth, int tableLength, int tableRow, int ***p_p_table, int maxEntrySize)
{
    string horizontalBar = " _";
    for (int i = 0; i < tableWidth; i++)
    {
        horizontalBar += "__";
        int paddingCount = numberOfPaddingItems(1, maxEntrySize);
        if (paddingCount > 0)
        {
            for (int j = 0; j < paddingCount; j++)
            {
                horizontalBar += "_";
            }
        }
    }

    for (int i = 0; i <= tableWidth; i++)
    {
        if (i == 0)
        {
            for (int j = 0; j <= tableLength; j++)
            {
                if (j == 0)
                {
                    cout << " ";
                }
                else
                {
                    cout << " " << numberWithPadding(j - 1, maxEntrySize);
                }
            }
            cout << "\n";
        }
        else
        {
            cout << horizontalBar << "\n";
            for (int j = 0; j <= tableLength; j++)
            {
                if (j == 0)
                {
                    cout << i - 1;
                }
                else
                {
                    string value = numberWithPadding(p_p_table[tableRow - 1][i - 1][j - 1], maxEntrySize);
                    cout << "|" << value;
                }
            }
            cout << "|\n";
        }
    }
    cout << horizontalBar << "\n\n";
}

int main(int argc, const char *argv[])
{
    try
    {
        int tableLength = 10;
        int tableWidth = 10;
        int tableHeight = 10;

        cout << "Please specify the size of the multiplication table (Default is 10x10x10): \n";
        cout << "Table length:";
        cin >> tableLength;

        cout << "Table width:";
        cin >> tableWidth;

        cout << "Table height:";
        cin >> tableHeight;


        int ***p_p_table3D;
        p_p_table3D = new int **[tableHeight];

        for (int i = 0; i < tableHeight; i++)
        {
            p_p_table3D[i] = initializeTable2D(tableWidth, tableLength);
        }


        for (int i = 0; i < tableHeight; i++)
        {
            for (int j = 0; j < tableWidth; j++)
            {
                for (int k = 0; k < tableLength; k++)
                {
                    p_p_table3D[i][j][k] = i * j * k;
                }
            }
        }
        int maxEntrySize = (tableWidth - 1) * (tableLength - 1) * (tableHeight - 1);

        int displayPlane = 1;
        while (displayPlane != 0)
        {
            cout << "Please specify which 2D table plane to print from the 3D table of " << tableHeight << " layers (0 to quit): \n";
            cout << "Current layer is: " << displayPlane << '\n';
            cin >> displayPlane;
            if (displayPlane == 0)
            {
                continue;
            }
            if (displayPlane < 0 || tableHeight < displayPlane)
            {
                cout << "You have selected a plane index that is out of bounds. Please try again.\n";
                continue;
            }
            printTable(tableWidth, tableLength, displayPlane, p_p_table3D, maxEntrySize);
        }

        for (int i = 0; i < tableHeight; i++)
        {
            disposeTable2D(p_p_table3D[i], tableWidth);
        }
        delete[] p_p_table3D;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Please specify the size of the multiplication table (Default is 10x10x10):
Table length:10
Table width:10
Table height:10
Please specify which 2D table plane to print from the 3D table of 10 layers (0 to quit):
Current layer is: 1
2
  000 001 002 003 004 005 006 007 008 009
 _________________________________________
0|000|000|000|000|000|000|000|000|000|000|
 _________________________________________
1|000|001|002|003|004|005|006|007|008|009|
 _________________________________________
2|000|002|004|006|008|010|012|014|016|018|
 _________________________________________
3|000|003|006|009|012|015|018|021|024|027|
 _________________________________________
4|000|004|008|012|016|020|024|028|032|036|
 _________________________________________
5|000|005|010|015|020|025|030|035|040|045|
 _________________________________________
6|000|006|012|018|024|030|036|042|048|054|
 _________________________________________
7|000|007|014|021|028|035|042|049|056|063|
 _________________________________________
8|000|008|016|024|032|040|048|056|064|072|
 _________________________________________
9|000|009|018|027|036|045|054|063|072|081|
 _________________________________________

Please specify which 2D table plane to print from the 3D table of 10 layers (0 to quit):
Current layer is: 2
3
  000 001 002 003 004 005 006 007 008 009
 _________________________________________
0|000|000|000|000|000|000|000|000|000|000|
 _________________________________________
1|000|002|004|006|008|010|012|014|016|018|
 _________________________________________
2|000|004|008|012|016|020|024|028|032|036|
 _________________________________________
3|000|006|012|018|024|030|036|042|048|054|
 _________________________________________
4|000|008|016|024|032|040|048|056|064|072|
 _________________________________________
5|000|010|020|030|040|050|060|070|080|090|
 _________________________________________
6|000|012|024|036|048|060|072|084|096|108|
 _________________________________________
7|000|014|028|042|056|070|084|098|112|126|
 _________________________________________
8|000|016|032|048|064|080|096|112|128|144|
 _________________________________________
9|000|018|036|054|072|090|108|126|144|162|
 _________________________________________

Please specify which 2D table plane to print from the 3D table of 10 layers (0 to quit):
Current layer is: 3
0

ch16_p11.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int numberOfPaddingItems(long number, long maxSize)
{
    string numberAsString = to_string(number);
    string maxSizeAsString = to_string(maxSize);

    return (maxSizeAsString.length() - numberAsString.length());
}

string numberWithPadding(long number, long maxSize)
{
    string numberAsString = to_string(number);
    string zeros;
    int paddingCount = numberOfPaddingItems(number, maxSize);
    if (paddingCount > 0)
    {
        for (int i = 0; i < paddingCount; i++)
        {
            zeros += '0';
        }
        numberAsString = zeros + numberAsString;
    }
    return numberAsString;
}

void printBoard(int tableSize, int **p_p_table, int maxEntrySize)
{
    string horizontalBar = " _";
    for (int i = 0; i < tableSize; i++)
    {
        horizontalBar += "__";
        int paddingCount = numberOfPaddingItems(1, 88888888888888);
        if (paddingCount > 0)
        {
            for (int j = 0; j < paddingCount; j++)
            {
                horizontalBar += "_";
            }
        }
    }

    for (int i = 0; i <= tableSize; i++)
    {
        if (i == 0)
        {
            for (int j = 0; j <= tableSize; j++)
            {
                if (j == 0)
                {
                    cout << " ";
                }
                else
                {
                    cout << " " << numberWithPadding(j - 1, 88888888888888);
                }
            }
            cout << "\n";
        }
        else
        {
            cout << horizontalBar << "\n";
            for (int j = 0; j <= tableSize; j++)
            {
                if (j == 0)
                {
                    cout << i - 1;
                }
                else
                {
                    cout << "|" << & ( p_p_table[i - 1][j - 1] );
                }
            }
            cout << "|\n";
        }
    }
    cout << horizontalBar << "\n\n";
}

int main(int argc, const char *argv[])
{
    try
    {
        int tableSize = 8;

        cout << "Please specify the size of the multiplication table (Default is 8x8): ";
        cin >> tableSize;

        int **p_p_table;
        p_p_table = new int *[tableSize];

        for (int i = 0; i < tableSize; i++)
        {
            p_p_table[i] = new int[tableSize];
        }

        for (int i = 0; i < tableSize; i++)
        {
            for (int j = 0; j < tableSize; j++)
            {
                p_p_table[i][j] = i * j;
            }
        }
        int maxEntrySize = (tableSize - 1) * (tableSize - 1);
        printBoard(tableSize, p_p_table, maxEntrySize);

        for (int i = 0; i < tableSize; i++)
        {
            delete[] p_p_table[i];
        }
        delete[] p_p_table;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Please specify the size of the multiplication table (Default is 8x8): 6
  00000000000000 00000000000001 00000000000002 00000000000003 00000000000004 00000000000005
 ___________________________________________________________________________________________
0|0x556cf26f5710|0x556cf26f5714|0x556cf26f5718|0x556cf26f571c|0x556cf26f5720|0x556cf26f5724|
 ___________________________________________________________________________________________
1|0x556cf26f5730|0x556cf26f5734|0x556cf26f5738|0x556cf26f573c|0x556cf26f5740|0x556cf26f5744|
 ___________________________________________________________________________________________
2|0x556cf26f5750|0x556cf26f5754|0x556cf26f5758|0x556cf26f575c|0x556cf26f5760|0x556cf26f5764|
 ___________________________________________________________________________________________
3|0x556cf26f5770|0x556cf26f5774|0x556cf26f5778|0x556cf26f577c|0x556cf26f5780|0x556cf26f5784|
 ___________________________________________________________________________________________
4|0x556cf26f5790|0x556cf26f5794|0x556cf26f5798|0x556cf26f579c|0x556cf26f57a0|0x556cf26f57a4|
 ___________________________________________________________________________________________
5|0x556cf26f57b0|0x556cf26f57b4|0x556cf26f57b8|0x556cf26f57bc|0x556cf26f57c0|0x556cf26f57c4|
 ___________________________________________________________________________________________

ch16_p12.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::stoi;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int arrayMaxLength = 8;

struct Talk
{
    string name;
    string daysSinceLastSpoken;
};

string getName()
{
    string name;
    cout << "Friend name: ";
    getline(cin, name, '\n');
    cout << '\n';
    return name;
}
int getDaysSinceLastSpoken()
{
    int daysSinceLastSpokenInput = 0;
    do
    {
        cout << "Number of days ago you last spoke with them: ";
        cin >> daysSinceLastSpokenInput;
        cin.clear();
        cin.ignore(80, '\n');

        if (daysSinceLastSpokenInput < 0)
        {
            cout << "Please enter a value >= 0\n";
        }
    }
    while (daysSinceLastSpokenInput < 0);
    cout << '\n';
    return daysSinceLastSpokenInput;
}
int getDaysSinceLastSpoken(int lastDaysSinceLastSpoken)
{
    int daysSinceLastSpokenInput = 0;
    do
    {
        cout << "Number of days ago you last spoke with them: ";
        cin >> daysSinceLastSpokenInput;
        cin.clear();
        cin.ignore(80, '\n');

        if (daysSinceLastSpokenInput < 0)
        {
            cout << "Please enter a value >= 0\n\n";
        }
        if (daysSinceLastSpokenInput > lastDaysSinceLastSpoken)
        {
            cout << "You last spoke with your friend " << lastDaysSinceLastSpoken << " days ago.\n";
            cout << "You must enter a number less than or equal to this.\n\n";
        }
    }
    while ((daysSinceLastSpokenInput < 0) || (daysSinceLastSpokenInput > lastDaysSinceLastSpoken));
    cout << '\n';
    return daysSinceLastSpokenInput;
}
int lookUpDaysSinceLastSpoken(Talk *p_array, int size, string name)
{
    for (int i = 0; i < size; i++)
    {
        if (p_array[i].name == name)
        {
            return stoi( p_array[i].daysSinceLastSpoken );
        }
    }
    return -1;
}

int findSmallestElementByName(Talk *p_array, int size, int index)
{
    int indexOfSmallestValue = index;
    for (int i = index + 1; i < size; i++)
    {
        if ( p_array[i].name < p_array[indexOfSmallestValue].name )
        {
            indexOfSmallestValue = i;
        }
    }
    return indexOfSmallestValue;
}

int findSmallestElementByDate(Talk *p_array, int size, int index)
{
    int indexOfSmallestValue = index;
    for (int i = index + 1; i < size; i++)
    {
        int arrayCurrent = stoi( p_array[i].daysSinceLastSpoken );
        int arraySmallest = stoi( p_array[indexOfSmallestValue].daysSinceLastSpoken );
        if (arrayCurrent < arraySmallest)
        {
            indexOfSmallestValue = i;
        }
    }
    return indexOfSmallestValue;
}

void swap(Talk *p_array, int firstIndex, int secondIndex)
{
    if (firstIndex == secondIndex)
    {
        return;
    }
    Talk temp = p_array[firstIndex];
    p_array[firstIndex] = p_array[secondIndex];
    p_array[secondIndex] = temp;
}

void sortByName(Talk *p_array, int size)
{
    for (int i = 0; i < size; i++)
    {
        int index = findSmallestElementByName(p_array, size, i);
        swap(p_array, i, index);
    }
}
void sortByDate(Talk *p_array, int size)
{
    for (int i = 0; i < size; i++)
    {
        int index = findSmallestElementByDate(p_array, size, i);
        swap(p_array, i, index);
    }
}

Talk *arraySortedByName(Talk *p_array, int size)
{
    Talk *p_newArray = new Talk[size];
    for (int i = 0; i < size; i++)
    {
        p_newArray[i] = p_array[i];
    }
    sortByName(p_newArray, size);

    return p_newArray;
}

Talk *arraySortedByDate(Talk *p_array, int size)
{
    Talk *p_newArray = new Talk[size];
    for (int i = 0; i < size; i++)
    {
        p_newArray[i] = p_array[i];
    }
    sortByDate(p_newArray, size);

    return p_newArray;
}

bool nameExistsInArray(Talk *p_array, int size, string name)
{
    for (int i = 0; i < size; i++)
    {
        if (p_array[i].name == name)
        {
            return true;
        }
    }
    return false;
}

void disposeArray(Talk *p_array)
{
    delete[] p_array;
}

void printFriends(Talk *p_array, int size)
{
    for (int i = 0; i < size; i++)
    {
        cout << p_array[i].name << ": " << p_array[i].daysSinceLastSpoken << " days since last spoken\n";
    }
}

void printFriendsByName(Talk *p_array, int size)
{
    Talk *sortedArray = arraySortedByName(p_array, size);
    printFriends(sortedArray, size);
    disposeArray(sortedArray);
}
void printFriendsByDate(Talk *p_array, int size)
{
    Talk *sortedArray = arraySortedByDate(p_array, size);
    printFriends(sortedArray, size);
    disposeArray(sortedArray);
}

string getNameToUpdate(Talk *p_array, int size)
{
    string name;
    do
    {
        printFriendsByName(p_array, size);
        cout << '\n';
        cout << "Please enter an existing name to update: ";
        getline(cin, name, '\n');
        cout << '\n';
    }
    while (!nameExistsInArray(p_array, size, name));
    return name;
}

void updateArray(Talk *p_array, int size, string name, int daySinceLastSpoken)
{
    for (int i = 0; i < size; i++)
    {
        if (p_array[i].name == name)
        {
            p_array[i].daysSinceLastSpoken = to_string(daySinceLastSpoken);
            return;
        }
    }
}
Talk *addToArray(Talk *p_array, int *size, string name, int daySinceLastSpoken)
{
    if (*size >= arrayMaxLength)
    {
        Talk *p_newvalues = new Talk[ arrayMaxLength * 2 ];
        for (int j = 0; j < arrayMaxLength; j++)
        {
            p_newvalues[j] = p_array[j];
        }
        p_newvalues[arrayMaxLength].name = name;
        p_newvalues[arrayMaxLength].daysSinceLastSpoken = to_string(daySinceLastSpoken);
        disposeArray(p_array);
        *size += 1;
        arrayMaxLength *= 2;
        return p_newvalues;
    }
    else
    {
        p_array[*size].name = name;
        p_array[*size].daysSinceLastSpoken = to_string(daySinceLastSpoken);
        *size += 1;
        return p_array;
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        int arrayLength = 0;
        Talk *p_array = new Talk[ arrayMaxLength ];

        int option = 0;
        string name;
        int daysSinceLastSpoken;
        do
        {
            cout << "Please select an option:\n";
            cout << "(1) Add new friend\n";
            if(arrayLength > 0)
            {
                cout << "(2) Update friend\n";
                cout << "(3) List friends by name\n";
                cout << "(4) List friends by most recently spoken with\n";
            }
            cout << "(0) Exit\n";
            cin >> option;
            cin.clear();
            cin.ignore(80, '\n');

            cout << '\n';
            switch (option)
            {
            case 1:
                name = getName();
                daysSinceLastSpoken = getDaysSinceLastSpoken();
                p_array = addToArray(p_array, &arrayLength, name, daysSinceLastSpoken);
                cout << '\n';
                break;
            case 2:
                name = getNameToUpdate(p_array, arrayLength);
                daysSinceLastSpoken = lookUpDaysSinceLastSpoken(p_array, arrayLength, name);
                daysSinceLastSpoken = getDaysSinceLastSpoken(daysSinceLastSpoken);
                updateArray(p_array, arrayLength, name, daysSinceLastSpoken);
                cout << '\n';
                break;
            case 3:
                printFriendsByName(p_array, arrayLength);
                cout << '\n';
                break;
            case 4:
                printFriendsByDate(p_array, arrayLength);
                cout << '\n';
                break;
            case 0:
                break;
            default:
                break;
            }
        }
        while (option != 0);

        disposeArray(p_array);

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Please select an option:
(1) Add new friend
(0) Exit
1

Friend name: Peter Smith

Number of days ago you last spoke with them: 2


Please select an option:
(1) Add new friend
(2) Update friend
(3) List friends by name
(4) List friends by most recently spoken with
(0) Exit
1

Friend name: Mike Pence

Number of days ago you last spoke with them: 3


Please select an option:
(1) Add new friend
(2) Update friend
(3) List friends by name
(4) List friends by most recently spoken with
(0) Exit
1

Friend name: Hello World

Number of days ago you last spoke with them: 2


Please select an option:
(1) Add new friend
(2) Update friend
(3) List friends by name
(4) List friends by most recently spoken with
(0) Exit
3

Hello World: 2 days since last spoken
Mike Pence: 3 days since last spoken
Peter Smith: 2 days since last spoken

Please select an option:
(1) Add new friend
(2) Update friend
(3) List friends by name
(4) List friends by most recently spoken with
(0) Exit
4

Peter Smith: 2 days since last spoken
Hello World: 2 days since last spoken
Mike Pence: 3 days since last spoken

Please select an option:
(1) Add new friend
(2) Update friend
(3) List friends by name
(4) List friends by most recently spoken with
(0) Exit
2

Hello World: 2 days since last spoken
Mike Pence: 3 days since last spoken
Peter Smith: 2 days since last spoken

Please enter an existing name to update: Mike Pence

Number of days ago you last spoke with them: 1


Please select an option:
(1) Add new friend
(2) Update friend
(3) List friends by name
(4) List friends by most recently spoken with
(0) Exit
3

Hello World: 2 days since last spoken
Mike Pence: 1 days since last spoken
Peter Smith: 2 days since last spoken

Please select an option:
(1) Add new friend
(2) Update friend
(3) List friends by name
(4) List friends by most recently spoken with
(0) Exit
0

ch16_p13.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

const int BUF = 512;
const int N = 5;
char buffer[BUF];

int main(int argc, const char *argv[])
{
    try
    {
        double *pd1, *pd2;
        int i;
        cout << "Calling new and placement new:\n";
        pd1 = new double[N];
        pd2 = new (buffer) double[N];
        for (i = 0; i < N; i++)
        {
            pd2[i] = pd1[i] = 1000 + 20.0 * i;
        }
        cout << "Memory addresses: \n" << "heap: " << pd1 << ", static: " << (void *) buffer << ", " << pd2 << endl;
        cout << "Memory contents:\n";
        for (i = 0; i < N; i++)
        {
            cout << pd1[i] << " at " << &(pd1[i]) << "; ";
            cout << pd2[i] << " at " << &(pd2[i]) << endl;
        }

        cout << "\nCalling new and placement new a second time:\n";
        double *pd3, *pd4;
        pd3 = new double[N];
        pd4 = new (buffer) double[N];
        for (i = 0; i < N; i++)
        {
            pd4[i] = pd3[i] = 1000 + 40.0 * i;
        }
        cout << "Memory addresses: \n" << "heap: " << pd3 << ", static: " << pd4 << endl;
        cout << "Memory contents:\n";
        for (i = 0; i < N; i++)
        {
            cout << pd3[i] << " at " << &(pd3[i]) << "; ";
            cout << pd4[i] << " at " << &(pd4[i]) << endl;
        }

        cout << "\nCalling new and placement new a third time:\n";
        delete [] pd1;
        pd1 = new double[N];
        pd2 = new (buffer + N * sizeof(double)) double[N];
        for (i = 0; i < N; i++)
        {
            pd2[i] = pd1[i] = 1000 + 60.0 * i;
        }
        cout << "Memory addresses: \n" << "heap: " << pd1 << ", static: " << pd2 << endl;
        cout << "Memory contents:\n";
        for (i = 0; i < N; i++)
        {
            cout << pd1[i] << " at " << &(pd1[i]) << "; ";
            cout << pd2[i] << " at " << &(pd2[i]) << endl;
        }
        delete[] pd1;
        delete[] pd3;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Calling new and placement new:
Memory addresses:
heap: 0x5641e68bb2c0, static: 0x5641e61b7300, 0x5641e61b7300
Memory contents:
1000 at 0x5641e68bb2c0; 1000 at 0x5641e61b7300
1020 at 0x5641e68bb2c8; 1020 at 0x5641e61b7308
1040 at 0x5641e68bb2d0; 1040 at 0x5641e61b7310
1060 at 0x5641e68bb2d8; 1060 at 0x5641e61b7318
1080 at 0x5641e68bb2e0; 1080 at 0x5641e61b7320

Calling new and placement new a second time:
Memory addresses:
heap: 0x5641e68bb2f0, static: 0x5641e61b7300
Memory contents:
1000 at 0x5641e68bb2f0; 1000 at 0x5641e61b7300
1040 at 0x5641e68bb2f8; 1040 at 0x5641e61b7308
1080 at 0x5641e68bb300; 1080 at 0x5641e61b7310
1120 at 0x5641e68bb308; 1120 at 0x5641e61b7318
1160 at 0x5641e68bb310; 1160 at 0x5641e61b7320

Calling new and placement new a third time:
Memory addresses:
heap: 0x5641e68bb2c0, static: 0x5641e61b7328
Memory contents:
1000 at 0x5641e68bb2c0; 1000 at 0x5641e61b7328
1060 at 0x5641e68bb2c8; 1060 at 0x5641e61b7330
1120 at 0x5641e68bb2d0; 1120 at 0x5641e61b7338
1180 at 0x5641e68bb2d8; 1180 at 0x5641e61b7340
1240 at 0x5641e68bb2e0; 1240 at 0x5641e61b7348

ch16_p14.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

const int STRUCTSIZE = 2;
const int BUFFSIZE = 512;
char buffer[BUFFSIZE];

struct chaff
{
    char dross[32];
    int slag;
};

void show_chaff(const chaff &chf)
{
    std::cout << "Dross : " << chf.dross << std::endl;
    std::cout << "Slag : " << chf.slag << std::endl;
}

void set_chaff(chaff &chf, const char *name, int qlty)
{
    strcpy(chf.dross, name);
    chf.slag = qlty;
}

int main(int argc, const char *argv[])
{
    try
    {
        chaff *pchaff = new (buffer) chaff[STRUCTSIZE];
        char name[32];
        int quantity = 0;

        for (int i = 0; i < STRUCTSIZE; i++)
        {
            std::cout << "Enter name: ";
            std::cin.getline(name, 32);
            std::cout << "Enter the quantity: ";
            (std::cin >> quantity).get();
            set_chaff(pchaff[i], name, quantity);
        }
        std::cout << pchaff << ", " << (void *)buffer << std::endl;
        for (int i = 0; i < STRUCTSIZE; i++)
        {
            std::cout << "Chaff " << i + 1 << std::endl;
            show_chaff(pchaff[i]);
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter name: Mike Pence
Enter the quantity: 3
Enter name: Peter Smith
Enter the quantity: 6
0x557db3370460, 0x557db3370460
Chaff 1
Dross : Mike Pence
Slag : 3
Chaff 2
Dross : Peter Smith
Slag : 6

ch16_p15.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

const int BUF = 512;

class JustTesting
{
private:
    string words;
    int number;
public:
    JustTesting(const string &s = "Just Testing", int n = 0)
    {
        words = s;
        number = n;
        cout << words << " constructed\n";
    }
    ~JustTesting()
    {
        cout << words << " destroyed\n";
    }
    void Show() const
    {
        cout << words << ", " << number << endl;
    }
};

int main(int argc, const char *argv[])
{
    try
    {
        char *buffer = new char[BUF];
        JustTesting *pc1, *pc2;
        pc1 = new (buffer) JustTesting;
        pc2 = new JustTesting("Heap1", 20);
        cout << "Memory block addresses:\n" << "buffer: " << (void *) buffer << " pc1: " << pc1;
        cout << " pc2: " << pc2 << endl;
        cout << "Memory contents:\n";
        cout << "pc1 : ";
        pc1->Show();
        cout << "pc2 : ";
        pc2->Show();
        JustTesting *pc3, *pc4;
        pc3 = new (buffer) JustTesting("Bad Idea", 6);
        pc4 = new JustTesting("Heap2", 10);
        cout << "Memory block addresses:\n" << " pc3: " << pc3 << " pc4: " << pc4 << endl;
        cout << "Memory contents : \n";
        cout << "pc3 : ";
        pc3->Show();
        cout << "pc4 : ";
        pc4->Show();
        delete pc2;
        delete pc4;
        delete[] buffer;
        cout << "Done.\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Just Testing constructed
Heap1 constructed
Memory block addresses:
buffer: 0x562a4c2a3eb0 pc1: 0x562a4c2a3eb0 pc2: 0x562a4c2a44d0
Memory contents:
pc1 : Just Testing, 0
pc2 : Heap1, 20
Bad Idea constructed
Heap2 constructed
Memory block addresses:
 pc3: 0x562a4c2a3eb0 pc4: 0x562a4c2a4500
Memory contents :
pc3 : Bad Idea, 6
pc4 : Heap2, 10
Heap1 destroyed
Heap2 destroyed
Done.

ch16_p16.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

const int BUF = 512;

class JustTesting
{
private:
    string words;
    int number;
public:
    JustTesting(const string &s = "Just Testing", int n = 0)
    {
        words = s;
        number = n;
        cout << words << " constructed\n";
    }
    ~JustTesting()
    {
        cout << words << " destroyed\n";
    }
    void Show() const
    {
        cout << words << ", " << number << endl;
    }
};

int main(int argc, const char *argv[])
{
    try
    {
        char *buffer = new char[BUF];
        JustTesting *pc1, *pc2;
        pc1 = new (buffer) JustTesting;
        pc2 = new JustTesting("Heap1", 20);
        cout << "Memory block addresses:\n" << "buffer: " << (void *) buffer << " pc1: " << pc1;
        cout << " pc2: " << pc2 << endl;
        cout << "Memory contents:\n";
        cout << "pc1 : ";
        pc1->Show();
        cout << "pc2 : ";
        pc2->Show();
        JustTesting *pc3, *pc4;
        pc3 = new (buffer + sizeof(JustTesting)) JustTesting("Bad Idea", 6);
        pc4 = new JustTesting("Heap2", 10);
        cout << "Memory block addresses:\n" << "pc3: " << pc3 << " pc4: " << pc4 << endl;
        cout << "Memory contents : \n";
        cout << "pc3 : ";
        pc3->Show();
        cout << "pc4 : ";
        pc4->Show();
        delete pc2;
        delete pc4;
        pc3->~JustTesting();
        pc1->~JustTesting();
        delete[] buffer;
        cout << "Done.\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Just Testing constructed
Heap1 constructed
Memory block addresses:
buffer: 0x5631fc9b1eb0 pc1: 0x5631fc9b1eb0 pc2: 0x5631fc9b24d0
Memory contents:
pc1 : Just Testing, 0
pc2 : Heap1, 20
Bad Idea constructed
Heap2 constructed
Memory block addresses:
pc3: 0x5631fc9b1ed8 pc4: 0x5631fc9b2500
Memory contents :
pc3 : Bad Idea, 6
pc4 : Heap2, 10
Heap1 destroyed
Heap2 destroyed
Bad Idea destroyed
Just Testing destroyed
Done.

ch16_p17.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

inline double f(double tf)
{
    return 5.0 * (tf - 32.0) / 9.0;
};

int main(int argc, const char *argv[])
{
    try
    {
        double tc = 21.5;
        double &&rd1 = 7.07;
        double &&rd2 = 1.8 * tc + 32.0;
        double &&rd3 = f(rd2);

        std::cout << " tc value and address: " << tc << ", " << &tc << std::endl;
        std::cout << "rd1 value and address: " << rd1 << ", " << &rd1 << std::endl;
        std::cout << "rd2 value and address: " << rd2 << ", " << &rd2 << std::endl;
        std::cout << "rd3 value and address: " << rd3 << ", " << &rd3 << std::endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
 tc value and address: 21.5, 0x7ffe37f38168
rd1 value and address: 7.07, 0x7ffe37f38170
rd2 value and address: 70.7, 0x7ffe37f38178
rd3 value and address: 21.5, 0x7ffe37f38180

ch16_p18.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Useless
{
private:
    int n;
    char *pc;
    static int ct;
    void ShowObject() const;
public:
    Useless();
    explicit Useless(int k);
    Useless(int k, char ch);
    Useless(const Useless &f);
    Useless(Useless &&f);
    ~Useless();
    Useless operator+(const Useless &f) const;

    void ShowData() const;
};

int Useless::ct = 0;

Useless::Useless()
{
    ++ct;
    n = 0;
    pc = nullptr;
    cout << "default constructor called; number of objects: " << ct << endl;
    ShowObject();
}
Useless::Useless(int k) : n(k)
{
    ++ct;
    cout << "int constructor called; number of objects: " << ct << endl;
    pc = new char[n];
    ShowObject();
}

Useless::Useless(int k, char ch) : n(k)
{
    ++ct;
    cout << "int, char constructor called; number of objects: " << ct << endl;
    pc = new char[n];
    for (int i = 0; i < n; i++)
    {
        pc[i] = ch;
    }
    ShowObject();
}

Useless::Useless(const Useless &f) : n(f.n)
{
    ++ct;
    cout << "copy const called; number of objects: " << ct << endl;
    pc = new char[n];
    for (int i = 0; i < n; i++)
    {
        pc[i] = f.pc[i];
    }
    ShowObject();
}

Useless::Useless(Useless &&f) : n(f.n)
{
    ++ct;
    cout << "move constructor called; number of objects: " << ct << endl;
    pc = f.pc;
    f.pc = nullptr;
    f.n = 0;
    ShowObject();

}

Useless::~Useless()
{
    cout << "destructor called; objects left: " << --ct << endl;
    cout << "deleted object:\n";
    ShowObject();
    delete[] pc;
}

Useless Useless::operator+(const Useless &f)const
{
    cout << "Entering operator+()\n";
    Useless temp = Useless(n + f.n);
    for (int i = 0; i < n; i++)
    {
        temp.pc[i] = pc[i];
    }
    for (int i = n; i < temp.n; i++)
    {
        temp.pc[i] = f.pc[i - n];
    }
    cout << "temp object:\n";
    cout << "Leaving operator+()\n";
    return temp;
}

void Useless::ShowObject() const
{
    cout << "Number of elements: " << n;
    cout << " Data address: " << (void *)pc << endl;
}

void Useless::ShowData() const
{
    if (n == 0)
    {
        cout << "(object empty)";
    }
    else
    {
        for (int i = 0; i < n; i++)
        {
            cout << pc[i];
        }
    }
    cout << endl;
}

int main(int argc, const char *argv[])
{
    try
    {
        {
            Useless one(10, 'x');
            Useless two = one;
            Useless three(20, 'o');
            Useless four(one + three);
            cout << "object one: ";
            one.ShowData();
            cout << "object two: ";
            two.ShowData();
            cout << "object three: ";
            three.ShowData();
            cout << "object four: ";
            four.ShowData();
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
int, char constructor called; number of objects: 1
Number of elements: 10 Data address: 0x559b402532c0
copy const called; number of objects: 2
Number of elements: 10 Data address: 0x559b402532e0
int, char constructor called; number of objects: 3
Number of elements: 20 Data address: 0x559b40253300
Entering operator+()
int constructor called; number of objects: 4
Number of elements: 30 Data address: 0x559b40253320
temp object:
Leaving operator+()
object one: xxxxxxxxxx
object two: xxxxxxxxxx
object three: oooooooooooooooooooo
object four: xxxxxxxxxxoooooooooooooooooooo
destructor called; objects left: 3
deleted object:
Number of elements: 30 Data address: 0x559b40253320
destructor called; objects left: 2
deleted object:
Number of elements: 20 Data address: 0x559b40253300
destructor called; objects left: 1
deleted object:
Number of elements: 10 Data address: 0x559b402532e0
destructor called; objects left: 0
deleted object:
Number of elements: 10 Data address: 0x559b402532c0

ch16_p19.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Useless
{
private:
    int n;
    char *pc;
    static int ct;
    void ShowObject() const;
public:
    Useless();
    explicit Useless(int k);
    Useless(int k, char ch);
    Useless(const Useless &f);
    Useless(Useless &&f);
    ~Useless();
    Useless operator+(const Useless &f) const;
    Useless &operator=(const Useless &f);
    Useless &operator=(Useless &&f);
    void ShowData() const;
};

int Useless::ct = 0;

Useless::Useless()
{
    ++ct;
    n = 0;
    pc = nullptr;
}

Useless::Useless(int k) : n(k)
{
    ++ct;
    pc = new char[n];
}

Useless::Useless(int k, char ch) : n(k)
{
    ++ct;
    pc = new char[n];
    for (int i = 0; i < n; i++)
    {
        pc[i] = ch;
    }
}

Useless::Useless(const Useless &f) : n(f.n)
{
    ++ct;
    pc = new char[n];
    for (int i = 0; i < n; i++)
    {
        pc[i] = f.pc[i];
    }
}

Useless::Useless(Useless &&f) : n(f.n)
{
    ++ct;
    pc = f.pc;
    f.pc = nullptr;
    f.n = 0;
}

Useless::~Useless()
{
    delete[] pc;
}

Useless &Useless::operator=(const Useless &f)
{
    std::cout << "copy assignment operator called:\n";
    if (this == &f)
    {
        return *this;
    }
    delete[] pc;
    n = f.n;
    pc = new char[n];
    for (int i = 0; i < n; i++)
    {
        pc[i] = f.pc[i];
    }
    return *this;
}

Useless &Useless::operator=(Useless &&f)
{
    std::cout << "move assignment operator called:\n";
    if (this == &f)
    {
        return *this;
    }
    delete[] pc;
    n = f.n;
    pc = f.pc;
    f.n = 0;
    f.pc = nullptr;
    return *this;
}

Useless Useless::operator+(const Useless &f) const
{
    Useless temp = Useless(n + f.n);
    for (int i = 0; i < n; i++)
    {
        temp.pc[i] = pc[i];
    }
    for (int i = n; i < temp.n; i++)
    {
        temp.pc[i] = f.pc[i - n];
    }
    return temp;
}
void Useless::ShowObject() const
{
    std::cout << "Number of elements: " << n;
    std::cout << " Data address: " << (void *) pc << std::endl;
}

void Useless::ShowData() const
{
    if (n == 0)
    {
        std::cout << " (object empty)";
    }
    else
    {
        for (int i = 0; i < n; i++)
        {
            std::cout << pc[i];
        }
    }
    std::cout << std::endl;
}

int main(int argc, const char *argv[])
{
    try
    {
        {
            Useless one(10, 'x');
            Useless two = one + one;
            cout << "object one: ";
            one.ShowData();
            cout << "object two: ";
            two.ShowData();
            Useless three, four;
            cout << "three = one\n";
            three = one;
            cout << "now object three = ";
            three.ShowData();
            cout << "and object one = ";
            one.ShowData();
            cout << "four = one + two\n";
            four = one + two;
            cout << "now object four = ";
            four.ShowData();
            cout << "four = move(one)\n";
            four = std::move(one);
            cout << "now object four = ";
            four.ShowData();
            cout << "and object one = ";
            one.ShowData();
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
object one: xxxxxxxxxx
object two: xxxxxxxxxxxxxxxxxxxx
three = one
copy assignment operator called:
now object three = xxxxxxxxxx
and object one = xxxxxxxxxx
four = one + two
move assignment operator called:
now object four = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
four = move(one)
move assignment operator called:
now object four = xxxxxxxxxx
and object one =  (object empty)

ch16_p20.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

const long Size1 = 39L;
const long Size2 = 100 * Size1;
const long Size3 = 100 * Size2;

bool f3(int x)
{
    return x % 3 == 0;
}
bool f13(int x)
{
    return x % 13 == 0;
}

int main(int argc, const char *argv[])
{
    try
    {
        std::vector<int> numbers(Size1);
        std::srand(std::time(nullptr));
        std::generate(numbers.begin(), numbers.end(), std::rand);
        cout << "Sample size = " << Size1 << '\n';
        int count3 = std::count_if(numbers.begin(), numbers.end(), f3);
        cout << "Count of numbers divisible by 3: " << count3 << '\n';
        int count13 = std::count_if(numbers.begin(), numbers.end(), f13);
        cout << "Count of numbers divisible by 13: " << count13 << "\n\n";

        numbers.resize(Size2);
        std::generate(numbers.begin(), numbers.end(), std::rand);
        cout << "Sample size = " << Size2 << '\n';

        class f_mod
        {
        private:
            int dv;
        public:
            f_mod(int d = 1) : dv(d) {}
            bool operator () (int x)
            {
                return x % dv == 0;
            }
        };

        count3 = std::count_if(numbers.begin(), numbers.end(), f_mod(3));
        cout << "Count of numbers divisible by 3 : " << count3 << '\n';
        count13 = std::count_if(numbers.begin(), numbers.end(), f_mod(13));
        cout << "Count of numbers divisible by 13: " << count13 << "\n\n";

        numbers.resize(Size3);
        std::generate(numbers.begin(), numbers.end(), std::rand);
        cout << "Sample size = " << Size3 << '\n';

        count3 = std::count_if(numbers.begin(), numbers.end(),
                               [] (int x) -> bool
        {
            return x % 3 == 0;
        });
        cout << "Count of numbers divisible by 3: " << count3 << '\n';
        count13 = std::count_if(numbers.begin(), numbers.end(),
                                [] (int x) -> bool
        {
            return x % 13 == 0;
        });
        cout << "Count of numbers divisible by 13: " << count13 << '\n';

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Sample size = 39
Count of numbers divisible by 3: 15
Count of numbers divisible by 13: 3

Sample size = 3900
Count of numbers divisible by 3 : 1275
Count of numbers divisible by 13: 279

Sample size = 390000
Count of numbers divisible by 3: 130328
Count of numbers divisible by 13: 29983

ch16_p21.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

const long Size = 390000L;

int main(int argc, const char *argv[])
{
    try
    {
        std::vector<int> numbers(Size);
        std::srand(std::time(nullptr));
        std::generate(numbers.begin(), numbers.end(), std::rand);
        cout << "Sample size = " << Size << '\n';

        int count3 = std::count_if(numbers.begin(), numbers.end(),
                                   [] (int x) -> bool {return x % 3 == 0; });
        cout << "Count of numbers divisible by 3 : " << count3 << '\n';
        int count13 = 0;
        std::for_each(numbers.begin(), numbers.end(),
                      [&count13] (int x)
        {
            count13 += (x % 13 == 0);
        });
        cout << "Count of numbers divisible by 13: " << count13 << '\n';

        count3 = count13 = 0;
        std::for_each(numbers.begin(), numbers.end(),
                      [&] (int x)
        {
            count3 += (x % 3 == 0);
            count13 += (x % 13 == 0);
        });
        cout << "Count of numbers divisible by 3: " << count3 << '\n';
        cout << "Count of numbers divisible by 13: " << count13 << '\n';

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Sample size = 390000
Count of numbers divisible by 3 : 130042
Count of numbers divisible by 13: 30133
Count of numbers divisible by 3: 130042
Count of numbers divisible by 13: 30133

ch16_p22.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template <typename T, typename F>
T use_f(T v, F f)
{
    static int count = 0;
    count++;
    std::cout << " use_f count = " << count
              << ", &count = " << &count << std::endl;
    return f(v);
}

class Fp
{
private:
    double z_;
public:
    Fp(double z = 1.0) : z_(z) {}
    double operator () (double p)
    {
        return z_ * p;
    }
};

class Fq
{
private:
    double z_;
public:
    Fq(double z = 1.0) : z_(z) {}
    double operator () (double q)
    {
        return z_ + q;
    }
};

double dub(double x)
{
    return 2.0 * x;
}
double square(double x)
{
    return x * x;
}

int main(int argc, const char *argv[])
{
    try
    {
        double y = 1.21;
        cout << "Function pointer dub:\n";
        cout << " " << use_f(y, dub) << endl;
        cout << "Function pointer square:\n";
        cout << " " << use_f(y, square) << endl;
        cout << "Function object Fp:\n";
        cout << " " << use_f(y, Fp(5.0)) << endl;
        cout << "Function object Fq:\n";
        cout << " " << use_f(y, Fq(5.0)) << endl;
        cout << "Lambda expression 1:\n";
        cout << " " << use_f(y, [] (double u) -> double { return u *u; }) << endl;
        cout << "Lambda expression 2:\n";
        cout << " " << use_f(y, [] (double u) -> double { return u + u / 2.0; }) << endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Function pointer dub:
  use_f count = 1, &count = 0x562bfd19b300
2.42
Function pointer square:
  use_f count = 2, &count = 0x562bfd19b300
1.4641
Function object Fp:
  use_f count = 1, &count = 0x562bfd19b304
6.05
Function object Fq:
  use_f count = 1, &count = 0x562bfd19b308
6.21
Lambda expression 1:
  use_f count = 1, &count = 0x562bfd19b2f8
1.4641
Lambda expression 2:
  use_f count = 1, &count = 0x562bfd19b2fc
1.815

ch16_p23.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <functional>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::function;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template <typename T, typename F>
T use_f(T v, F f)
{
    static int count = 0;
    count++;
    std::cout << " use_f count = " << count
              << ", &count = " << &count << std::endl;
    return f(v);
}

class Fp
{
private:
    double z_;
public:
    Fp(double z = 1.0) : z_(z) {}
    double operator () (double p)
    {
        return z_ * p;
    }
};

class Fq
{
private:
    double z_;
public:
    Fq(double z = 1.0) : z_(z) {}
    double operator () (double q)
    {
        return z_ + q;
    }
};

double dub(double x)
{
    return 2.0 * x;
}
double square(double x)
{
    return x * x;
}

int main(int argc, const char *argv[])
{
    try
    {
        double y = 1.21;
        function<double(double)> ef1 = dub;
        function<double(double)> ef2 = square;
        function<double(double)> ef3 = Fq(10.0);
        function<double(double)> ef4 = Fp(10.0);
        function<double(double)> ef5 = [] (double u) -> double {return u * u; };
        function<double(double)> ef6 = [] (double u) -> double {return u + u / 2.0; };
        cout << "Function pointer dub:\n";
        cout << " " << use_f(y, ef1) << endl;
        cout << "Function pointer square:\n";
        cout << " " << use_f(y, ef2) << endl;
        cout << "Function object Fp:\n";
        cout << " " << use_f(y, ef3) << endl;
        cout << "Function object Fq:\n";
        cout << " " << use_f(y, ef4) << endl;
        cout << "Lambda expression l:\n";
        cout << " " << use_f(y, ef5) << endl;
        cout << "Lambda expression 2:\n";
        cout << " " << use_f(y, ef6) << endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Function pointer dub:
  use_f count = 1, &count = 0x55e49a9c22f4
2.42
Function pointer square:
  use_f count = 2, &count = 0x55e49a9c22f4
1.4641
Function object Fp:
  use_f count = 3, &count = 0x55e49a9c22f4
11.21
Function object Fq:
  use_f count = 4, &count = 0x55e49a9c22f4
12.1
Lambda expression l:
  use_f count = 5, &count = 0x55e49a9c22f4
1.4641
Lambda expression 2:
  use_f count = 6, &count = 0x55e49a9c22f4
1.815

ch16_p24.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

void show_list3() {}

template<typename T, typename ... Args>
void show_list3(T value, Args ... args)
{
    std::cout << value << ", ";
    show_list3(args ...);
}

int main(int argc, const char *argv[])
{
    try
    {
        int n = 14;
        double x = 2.71828;
        std::string mr = "Mr. String objects!";
        show_list3(n, x);
        show_list3(x * x, '!', 7, mr);

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
14, 2.71828, 7.38905, !, 7, Mr. String objects!, 

ch16_p25.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

void show_list() {}

template<typename T>
void show_list(const T &value)
{
    std::cout << value << '\n';
}

template<typename T, typename ... Args>
void show_list(const T &value, const Args & ... args)
{
    std::cout << value << ", ";
    show_list(args ... );
}

int main(int argc, const char *argv[])
{
    try
    {
        int n = 14;
        double x = 2.71828;
        std::string mr = "Mr. String objects!";
        show_list(n, x);
        show_list(x * x, '!', 7, mr);

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
14, 2.71828
7.38905, !, 7, Mr. String objects!

ch16_p26.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::insert_iterator;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int main(int argc, const char *argv[])
{
    try
    {
        const int N = 6;
        string s1[N] = { "buffoon", "thinkers", "for", "heavy", "can", "for" };
        string s2[N] = { "metal", "any", "food", "elegant", "deliver", "for" };

        set<string> A(s1, s1 + N);
        set<string> B(s2, s2 + N);

        ostream_iterator<string, char> out(cout, " ");
        cout << "Set A: ";
        copy(A.begin(), A.end(), out);
        cout << endl;
        cout << "Set B: ";
        copy(B.begin(), B.end(), out);
        cout << endl;

        cout << "Union of A and B:\n";
        set_union(A.begin(), A.end(), B.begin(), B.end(), out);
        cout << endl;

        cout << "Intersection of A and B:\n";
        set_intersection(A.begin(), A.end(), B.begin(), B.end(), out);
        cout << endl;

        cout << "Difference of A and B:\n";
        set_difference(A.begin(), A.end(), B.begin(), B.end(), out);
        cout << endl;

        set<string> C;
        cout << "Set C:\n";
        set_union(A.begin(), A.end(), B.begin(), B.end(),
                  insert_iterator<set<string> >(C, C.begin()));
        copy(C.begin(), C.end(), out);
        cout << endl;

        string s3("grungy");
        C.insert(s3);
        cout << "Set C after insertion:\n";
        copy(C.begin(), C.end(), out);
        cout << endl;

        cout << "Showing a range:\n";
        copy(C.lower_bound("ghost"), C.upper_bound("spook"), out);
        cout << endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Set A: buffoon can for heavy thinkers
Set B: any deliver elegant food for metal
Union of A and B:
any buffoon can deliver elegant food for heavy metal thinkers
Intersection of A and B:
for
Difference of A and B:
buffoon can heavy thinkers
Set C:
any buffoon can deliver elegant food for heavy metal thinkers
Set C after insertion:
any buffoon can deliver elegant food for grungy heavy metal thinkers
Showing a range:
grungy heavy metal

ch16_p27.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

typedef int KeyType;
typedef std::pair<const KeyType, std::string> Pair;
typedef std::multimap<KeyType, std::string> MapCode;

int main(int argc, const char *argv[])
{
    try
    {
        MapCode codes;

        codes.insert(Pair(415, "San Francisco"));
        codes.insert(Pair(510, "Oakland"));
        codes.insert(Pair(718, "Brooklyn"));
        codes.insert(Pair(718, "Staten Island"));
        codes.insert(Pair(415, "San Rafael"));
        codes.insert(Pair(510, "Berkeley"));

        cout << "Number of cities with area code 415: "
             << codes.count(415) << endl;
        cout << "Number of cities with area code 718: "
             << codes.count(718) << endl;
        cout << "Number of cities with area code 510: "
             << codes.count(510) << endl;
        cout << "Area Code   City\n";
        MapCode::iterator it;
        for (it = codes.begin(); it != codes.end(); ++it)
        {
            cout << "    " << (*it).first << "     "
                 << (*it).second << endl;
        }

        auto range = codes.equal_range(718);
        cout << "Cities with area code 718:\n";
        for (it = range.first; it != range.second; ++it)
        {
            cout << (*it).second << endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Number of cities with area code 415: 2
Number of cities with area code 718: 2
Number of cities with area code 510: 2
Area Code   City
    415     San Francisco
    415     San Rafael
    510     Oakland
    510     Berkeley
    718     Brooklyn
    718     Staten Island
Cities with area code 718:
Brooklyn
Staten Island

ch16_p28.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <functional>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::plus;
using std::multiplies;
using std::bind1st;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

const int LIM = 6;

void Show(double v)
{
    std::cout.width(6);
    std::cout << v << ' ';
}

int main(int argc, const char *argv[])
{
    try
    {
        double arr1[LIM] = { 28, 29, 30, 35, 38, 59 };
        double arr2[LIM] = { 63, 65, 69, 75, 80, 99 };
        vector<double> gr8(arr1, arr1 + LIM);
        vector<double> m8(arr2, arr2 + LIM);
        cout.setf(ios_base::fixed);
        cout.precision(1);
        cout << "gr8:\t";
        for_each(gr8.begin(), gr8.end(), Show);
        cout << endl;
        cout << "m8:\t";
        for_each(m8.begin(), m8.end(), Show);
        cout << endl;

        vector<double> sum(LIM);
        transform(gr8.begin(), gr8.end(), m8.begin(), sum.begin(), plus<double>());
        cout << "sum:\t";
        for_each(sum.begin(), sum.end(), Show);
        cout << endl;

        vector<double> prod(LIM);
        transform(gr8.begin(), gr8.end(), prod.begin(), bind1st(multiplies<double>(), 2.5));
        cout << "prod:\t";
        for_each(prod.begin(), prod.end(), Show);
        cout << endl;

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
gr8:      28.0   29.0   30.0   35.0   38.0   59.0
m8:       63.0   65.0   69.0   75.0   80.0   99.0
sum:      91.0   94.0   99.0  110.0  118.0  158.0
prod:     70.0   72.5   75.0   87.5   95.0  147.5

ch16_p29.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;
using std::next_permutation;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int main(int argc, const char *argv[])
{
    try
    {
        string letters;

        cout << "Enter the letter grouping (quit to quit): ";
        while (cin >> letters && letters != "quit")
        {
            cout << "Permutations of " << letters << endl;
            sort(letters.begin(), letters.end());
            cout << letters << endl;
            while ( next_permutation( letters.begin(), letters.end() ) )
            {
                cout << letters << endl;
            }
            cout << "Enter next sequence (quit to quit): ";
        }
        cout << "Done.\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter the letter grouping (quit to quit): Water
Permutations of Water
Waert
Waetr
Waret
Warte
Water
Watre
Weart
Weatr
Werat
Werta
Wetar
Wetra
Wraet
Wrate
Wreat
Wreta
Wrtae
Wrtea
Wtaer
Wtare
Wtear
Wtera
Wtrae
Wtrea
aWert
aWetr
aWret
aWrte
aWter
aWtre
aeWrt
aeWtr
aerWt
aertW
aetWr
aetrW
arWet
arWte
areWt
aretW
artWe
arteW
atWer
atWre
ateWr
aterW
atrWe
atreW
eWart
eWatr
eWrat
eWrta
eWtar
eWtra
eaWrt
eaWtr
earWt
eartW
eatWr
eatrW
erWat
erWta
eraWt
eratW
ertWa
ertaW
etWar
etWra
etaWr
etarW
etrWa
etraW
rWaet
rWate
rWeat
rWeta
rWtae
rWtea
raWet
raWte
raeWt
raetW
ratWe
rateW
reWat
reWta
reaWt
reatW
retWa
retaW
rtWae
rtWea
rtaWe
rtaeW
rteWa
rteaW
tWaer
tWare
tWear
tWera
tWrae
tWrea
taWer
taWre
taeWr
taerW
tarWe
tareW
teWar
teWra
teaWr
tearW
terWa
teraW
trWae
trWea
traWe
traeW
treWa
treaW
Enter next sequence (quit to quit): quit
Done.

ch16_p30.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::insert_iterator;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

char toLower(char ch)
{
    return tolower(ch);
}

string &ToLower(string &st)
{
    transform(st.begin(), st.end(), st.begin(), toLower);
    return st;
}

void display(const string &s)
{
    cout << s << " ";
}

int main(int argc, const char *argv[])
{
    try
    {
        vector<string> words;
        cout << "Enter words (enter quit to quit):\n";
        string input;
        while (cin >> input && input != "quit")
        {
            words.push_back(input);
        }

        cout << "You entered the following words:\n";
        for_each(words.begin(), words.end(), display);
        cout << endl;

        set<string> wordset;
        transform(words.begin(), words.end(),
                  insert_iterator<set<string> >(wordset, wordset.begin()),
                  ToLower);
        cout << "\nAlphabetic list of words:\n";
        for_each(wordset.begin(), wordset.end(), display);
        cout << endl;

        map<string, int> wordmap;
        set<string>::iterator si;
        for (si = wordset.begin(); si != wordset.end(); si++)
        {
            wordmap[*si] = count(words.begin(), words.end(), *si);
        }

        cout << "\nWord frequency:\n";
        for (si = wordset.begin(); si != wordset.end(); si++)
        {
            cout << *si << ": " << wordmap[*si] << endl;
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter words (enter quit to quit):
Apple Orange Egg Water Banana Sun Apple Egg Water Sun Water World Water quit
You entered the following words:
Apple Orange Egg Water Banana Sun Apple Egg Water Sun Water World Water

Alphabetic list of words:
apple banana egg orange sun water world

Word frequency:
apple: 2
banana: 1
egg: 2
orange: 1
sun: 2
water: 4
world: 1

ch16_p31.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <valarray>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::valarray;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

int main(int argc, const char *argv[])
{
    try
    {
        vector<double> data;
        double temp;

        cout << "Enter numbers (<=0 to quit):\n";
        while (cin >> temp && temp > 0)
        {
            data.push_back(temp);
        }
        sort(data.begin(), data.end());
        int size = data.size();
        valarray<double> numbers(size);
        int i;
        for (i = 0; i < size; i++)
        {
            numbers[i] = data[i];
        }
        valarray<double> sq_rts(size);
        sq_rts = sqrt(numbers);
        valarray<double> results(size);
        results = numbers + 2.0 * sq_rts;
        cout.setf(ios_base::fixed);
        cout.precision(4);
        for (i = 0; i < size; i++)
        {
            cout.width(8);
            cout << numbers[i] << ": ";
            cout.width(8);
            cout << results[i] << endl;
        }
        cout << "Done.\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter numbers (<=0 to quit):
1 2 3 4 5 6 7 8 9 -1
  1.0000:   3.0000
  2.0000:   4.8284
  3.0000:   6.4641
  4.0000:   8.0000
  5.0000:   9.4721
  6.0000:  10.8990
  7.0000:  12.2915
  8.0000:  13.6569
  9.0000:  15.0000
Done.

ch16_p32.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <valarray>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::valarray;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

const int SIZE = 12;
typedef std::valarray<int> vint;

void show(const vint &v, int cols)
{
    using std::cout;
    using std::endl;

    int lim = v.size();
    int i;
    for (i = 0; i < lim; ++i)
    {
        cout.width(3);
        cout << v[i];
        if (i % cols == cols - 1)
        {
            cout << endl;
        }
        else
        {
            cout << ' ';
        }
    }
    if (i % cols != 0)
    {
        cout << endl;
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        using std::slice;
        vint valint(SIZE);

        std::srand(std::time(nullptr));

        int i;
        for (i = 0; i < SIZE; ++i)
        {
            valint[i] = std::rand() % 10;
        }
        cout << "Original array:\n";
        show(valint, 3);
        vint vcol(valint[slice(1, 4, 3)]);
        cout << "Second column:\n";
        show(vcol, 1);
        vint vrow(valint[slice(3, 3, 1)]);
        cout << "Second row:\n";
        show(vrow, 3);
        valint[slice(2, 4, 3)] = 10;
        cout << "Set last column to 10:\n";
        show(valint, 3);
        cout << "Set first column to sum of next two:\n";
        valint[slice(0, 4, 3)] = vint(valint[slice(1, 4, 3)])
                                 + vint(valint[slice(2, 4, 3)]);
        show(valint, 3);

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Original array:
  6   8   8
  5   7   0
  6   5   5
  3   3   1
Second column:
  8
  7
  5
  3
Second row:
  5   7   0
Set last column to 10:
  6   8  10
  5   7  10
  6   5  10
  3   3  10
Set first column to sum of next two:
 18   8  10
 17   7  10
 15   5  10
 13   3  10

ch16_p33.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <initializer_list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::initializer_list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

double sum(std::initializer_list<double> il)
{
    double tot = 0;
    for (auto p = il.begin(); p != il.end(); p++)
    {
        tot += *p;
    }
    return tot;
}

double average(const std::initializer_list<double> &ril)
{
    double tot = 0;
    int n = ril.size();
    double ave = 0.0;

    if (n > 0)
    {
        for (auto p = ril.begin(); p != ril.end(); p++)
        {
            tot += *p;
        }
        ave = tot / n;
    }
    return ave;
}

int main(int argc, const char *argv[])
{
    try
    {
        cout << "List 1: sum = " << sum({ 2, 3, 4 })
             << ", ave = " << average({ 2, 3, 4 }) << '\n';
        std::initializer_list<double> dl = { 1.1, 2.2, 3.3, 4.4, 5.5 };
        cout << "List 2: sum = " << sum(dl)
             << ", ave = " << average(dl) << '\n';
        dl = { 16.0, 25.0, 36.0, 40.0, 64.0 };
        cout << "List 3: sum = " << sum(dl)
             << ", ave = " << average(dl) << '\n';

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
List 1: sum = 9, ave = 3
List 2: sum = 16.5, ave = 3.3
List 3: sum = 181, ave = 36.2

第17章 异常处理深入剖析
17.1 简介
17.2 实例：处理除数为0的异常处理
17.3 重新抛出异常
17.4 堆栈展开
17.5 什么时候使用异常处理
17.6 构造函数、析构函数和异常处理
17.7 异常与继承
17.8 处理new失败
17.9 类unique_ptr和动态内存分配
17.10 标准库的异常类层次结构
17.11 本章小结
ch17_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Sales
{
public:
    enum { MONTHS = 12 };
    class bad_index : public std::logic_error
    {
    private:
        int bi;
    public:
        explicit bad_index(int ix, const std::string &s = "Index error in Sales object\n");
        int bi_val() const
        {
            return bi;
        }
        virtual ~bad_index() {}
    };
    explicit Sales(int yy = 0);
    Sales(int yy, const double *gr, int n);
    virtual ~Sales() { }
    int Year() const
    {
        return year;
    }
    virtual double operator[](int i) const;
    virtual double &operator[](int i);
private:
    double gross[MONTHS];
    int year;
};

class LabeledSales : public Sales
{
public:
    class nbad_index : public Sales::bad_index
    {
    private:
        std::string lbl;
    public:
        nbad_index(const std::string &lb, int ix, const std::string &s = "Index error in LabeledSales object\n");
        const std::string &label_val() const
        {
            return lbl;
        }
        virtual ~nbad_index() {}
    };
    explicit LabeledSales(const std::string &lb = "none", int yy = 0);
    LabeledSales(const std::string &lb, int yy, const double *gr, int n);
    virtual ~LabeledSales() { }
    const std::string &Label() const
    {
        return label;
    }
    virtual double operator[](int i) const;
    virtual double &operator[](int i);
private:
    std::string label;
};


Sales::bad_index::bad_index(int ix, const string &s) : std::logic_error(s), bi(ix)
{
}
Sales::Sales(int yy)
{
    year = yy;
    for (int i = 0; i < MONTHS; ++i)
    {
        gross[i] = 0;
    }
}

Sales::Sales(int yy, const double *gr, int n)
{
    year = yy;
    int lim = (n < MONTHS) ? n : MONTHS;
    int i;
    for (i = 0; i < lim; ++i)
    {
        gross[i] = gr[i];
    }
    for (; i < MONTHS; ++i)
    {
        gross[i] = 0;
    }
}
double Sales::operator[](int i) const
{
    if (i < 0 || i >= MONTHS)
    {
        throw bad_index(i);
    }
    return gross[i];
}

double &Sales::operator[](int i)
{
    if (i < 0 || i >= MONTHS)
    {
        throw bad_index(i);
    }
    return gross[i];
}

LabeledSales::nbad_index::nbad_index(const string &lb, int ix, const string &s) : Sales::bad_index(ix, s)
{
    lbl = lb;
}
LabeledSales::LabeledSales(const string &lb, int yy) : Sales(yy)
{
    label = lb;
}
LabeledSales::LabeledSales(const string &lb, int yy, const double *gr, int n) : Sales(yy, gr, n)
{
    label = lb;
}
double LabeledSales::operator[](int i) const
{
    if (i < 0 || i >= MONTHS)
    {
        throw nbad_index(Label(), i);
    }
    return Sales::operator[](i);
}
double &LabeledSales::operator[](int i)
{
    if (i < 0 || i >= MONTHS)
    {
        throw nbad_index(Label(), i);
    }
    return Sales::operator[](i);
}

int main(int argc, const char *argv[])
{
    try
    {

        double vals1[12] =
        {
            1220, 1100, 1122, 2212, 1232, 2334,
            2884, 2393, 3302, 2922, 3002, 3544
        };

        double vals2[12] =
        {
            12, 11, 22, 21, 32, 34,
            28, 29, 33, 29, 32, 35
        };

        Sales sales1(2011, vals1, 12);
        LabeledSales sales2("Blogstar", 2012, vals2, 12);

        cout << "First try block:\n";
        try
        {
            int i;
            cout << "Year = " << sales1.Year() << endl;
            for (i = 0; i < 12; ++i)
            {

                cout << sales1[i] << ' ';
                if (i % 6 == 5)
                {
                    cout << endl;
                }
            }
            cout << "Year = " << sales2.Year() << endl;
            cout << "Label = " << sales2.Label() << endl;
            for (i = 0; i <= 12; ++i)
            {

                cout << sales2[i] << ' ';
                if (i % 6 == 5)
                {
                    cout << endl;
                }
            }
            cout << "End of try block 1.\n";
        }
        catch (LabeledSales::nbad_index &bad)
        {
            cout << bad.what();
            cout << "Company: " << bad.label_val() << endl;
            cout << "bad index: " << bad.bi_val() << endl;
        }
        catch (Sales::bad_index &bad)
        {
            cout << bad.what();
            cout << "bad index: " << bad.bi_val() << endl;
        }
        cout << "\nNext try block:\n";
        try
        {
            sales2[2] = 37.5;
            sales1[20] = 23345;
            cout << "End of try block 2.\n";
        }
        catch (LabeledSales::nbad_index &bad)
        {
            cout << bad.what();
            cout << "Company: " << bad.label_val() << endl;
            cout << "bad index: " << bad.bi_val() << endl;
        }
        catch (Sales::bad_index &bad)
        {
            cout << bad.what();
            cout << "bad index: " << bad.bi_val() << endl;
        }
        cout << "Done.\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
First try block:
Year = 2011
1220 1100 1122 2212 1232 2334
2884 2393 3302 2922 3002 3544
Year = 2012
Label = Blogstar
12 11 22 21 32 34
28 29 33 29 32 35
Index error in LabeledSales object
Company: Blogstar
bad index: 12

Next try block:
Index error in Sales object
bad index: 20
Done.

ch17_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class bad_hmean : public std::logic_error
{
public:
    bad_hmean(const std::string &s = "hmean(a, b) invalid arguments: a = -b\n") : std::logic_error(s) {}
};

class bad_gmean : public std::logic_error
{
public:
    bad_gmean(const std::string &s = "gmean(a, b) arguments should be >= 0\n") : std::logic_error(s) {}
};

double hmean(double a, double b)
{
    if (a == -b)
    {
        throw bad_hmean();
    }
    return (2.0 * a * b) / (a + b);
}

double gmean(double a, double b)
{
    if (a < 0 || b < 0)
    {
        throw bad_gmean();
    }
    return std::sqrt(a * b);
}

int main(int argc, const char *argv[])
{
    try
    {
        double x, y, z;

        cout << "Enter two numbers <q to quit>: ";
        while (cin >> x && cin >> y)
        {
            try
            {
                z = hmean(x, y);
                cout << "Harmonic mean of " << x << " and " << y
                     << " is " << z << endl;
                z = gmean(x, y);
                cout << "Geometric mean of " << x << " and " << y
                     << " is " << z << endl;
                cout << "Enter two numbers <q to quit>: ";
            }
            catch (bad_hmean &bg)
            {
                cout << bg.what();
                cout << "Enter two numbers <q to quit>: ";
                continue;
            }
            catch (bad_gmean &hg)
            {
                cout << hg.what();
                std::cout << "Sorry, you don't get to play any more.\n";
                break;
            }
        }
        cout << "Done.\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter two numbers <q to quit>: 2 5
Harmonic mean of 2 and 5 is 2.85714
Geometric mean of 2 and 5 is 3.16228
Enter two numbers <q to quit>: 3 5
Harmonic mean of 3 and 5 is 3.75
Geometric mean of 3 and 5 is 3.87298
Enter two numbers <q to quit>: 3 -3
hmean(a, b) invalid arguments: a = -b
Enter two numbers <q to quit>: 5 3
Harmonic mean of 5 and 3 is 3.75
Geometric mean of 5 and 3 is 3.87298
Enter two numbers <q to quit>: 5 -3
Harmonic mean of 5 and -3 is -15
gmean(a, b) arguments should be >= 0
Sorry, you don't get to play any more.
Done.

ch17_p03.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class bad_hmean : public std::invalid_argument
{
private:
    int arg1;
    int arg2;
public:
    bad_hmean(int a, int b, const std::string &s = "hmean(a, b) invalid arguments: a = -b\n") : std::invalid_argument(s), arg1(a), arg2(b) {}
    void display() const;
};

void bad_hmean::display() const
{
    std::cout << "For function hmean(a, b), a != -b" << std::endl;
    std::cout << "You entered a = " << arg1 << ", b = " << arg2 << std::endl;
}
class bad_gmean : public std::domain_error
{
private:
    int arg1;
    int arg2;
public:
    bad_gmean(int a, int b, const std::string &s = "gmean(a, b) arguments should be >= 0\n") : std::domain_error(s), arg1(a), arg2(b) {}
    void display() const;
};
void bad_gmean::display() const
{
    std::cout << "For function gmean(a, b), a >= 0 and b >= 0" << std::endl;
    std::cout << "You entered a = " << arg1 << ", b = " << arg2 << std::endl;
}

double hmean(double a, double b)
{
    if (a == -b)
    {
        throw bad_hmean(a, b);
    }
    return (2.0 * a * b) / (a + b);
}

double gmean(double a, double b)
{
    if (a < 0 || b < 0)
    {
        throw bad_gmean(a, b);
    }
    return std::sqrt(a * b);
}

int main(int argc, const char *argv[])
{
    try
    {
        double x, y, z;

        cout << "Enter two numbers <q to quit>: ";
        while (cin >> x && cin >> y)
        {
            try
            {
                z = hmean(x, y);
                cout << "Harmonic mean of " << x << " and " << y
                     << " is " << z << endl;
                z = gmean(x, y);
                cout << "Geometric mean of " << x << " and " << y
                     << " is " << z << endl;
                cout << "Enter two numbers <q to quit>: ";
            }
            catch (std::exception &e)
            {
                if (typeid(bad_hmean &) == typeid(e))
                {
                    bad_hmean &bhm = dynamic_cast<bad_hmean &>(e);
                    bhm.display();
                }
                else if(typeid(bad_gmean &) == typeid(e))
                {
                    bad_gmean &bgm = dynamic_cast<bad_gmean &>(e);
                    bgm.display();
                }
                cout << "Sorry, you don't get to play any more.\n";
                break;
            }
        }
        cout << "Done.\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Enter two numbers <q to quit>: 2 5
Harmonic mean of 2 and 5 is 2.85714
Geometric mean of 2 and 5 is 3.16228
Enter two numbers <q to quit>: 3 5
Harmonic mean of 3 and 5 is 3.75
Geometric mean of 3 and 5 is 3.87298
Enter two numbers <q to quit>: 3 -3
For function hmean(a, b), a != -b
You entered a = 3, b = -3
Sorry, you don't get to play any more.
Done.

Enter two numbers <q to quit>: 5 3
Harmonic mean of 5 and 3 is 3.75
Geometric mean of 5 and 3 is 3.87298
Enter two numbers <q to quit>: 5 -3
Harmonic mean of 5 and -3 is -15
For function gmean(a, b), a >= 0 and b >= 0
You entered a = 5, b = -3
Sorry, you don't get to play any more.
Done.

ch17_p04.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <typeinfo>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Grand
{
private:
    int hold;
public:
    Grand(int h = 0) : hold(h) {}
    virtual void Speak() const
    {
        cout << "I am a grand class!\n";
    }
    virtual int Value() const
    {
        return hold;
    }
};

class Superb : public Grand
{
public:
    Superb(int h = 0) : Grand(h) {}
    void Speak() const
    {
        cout << "I am a superb class!!\n";
    }
    virtual void Say() const
    {
        cout << "I hold the superb value of " << Value() << "!\n";
    }
};

class Magnificent : public Superb
{
private:
    char ch;
public:
    Magnificent(int h = 0, char cv = 'A') : Superb(h), ch(cv) {}
    void Speak() const
    {
        cout << "I am a magnificent class!!!\n";
    }
    void Say() const
    {
        cout << "I hold the character " << ch << " and the integer " << Value() << "!\n";
    }
};

Grand *GetOne()
{
    Grand *p;

    switch (rand() % 3)
    {
    case 0:
        p = new Grand(rand() % 100);
        break;
    case 1:
        p = new Superb(rand() % 100);
        break;
    case 2:
        p = new Magnificent(rand() % 100, 'A' + rand() % 26);
        break;
    }
    return p;
}

int main(int argc, const char *argv[])
{
    try
    {
        srand(time(nullptr));
        Grand *pg;
        Superb *ps;
        for (int i = 0; i < 5; i++)
        {
            pg = GetOne();
            cout << "Now processing type " << typeid(*pg).name() << ".\n";
            pg->Speak();
            if ( ( ps = dynamic_cast<Superb *>(pg) ) != nullptr )
            {
                ps->Say();
            }
            if (typeid(Magnificent) == typeid(*pg))
            {
                cout << "Yes, you're really magnificent.\n";
            }
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Now processing type 11Magnificent.
I am a magnificent class!!!
I hold the character L and the integer 29!
Yes, you're really magnificent.
Now processing type 6Superb.
I am a superb class!!
I hold the superb value of 20!
Now processing type 5Grand.
I am a grand class!
Now processing type 5Grand.
I am a grand class!
Now processing type 5Grand.
I am a grand class!

ch17_p05.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template<typename T, typename U>
typename common_type<T, U>::type f(const vector<T> &vt, const vector<U> &vu)
{
    typename common_type<T, U>::type sum = 0;
    int min_size = vt.size() <= vu.size() ? vt.size() : vu.size();
    for (int i = 0; i < min_size; ++i)
    {
        sum += vt[i] * vu[i];
    }
    return sum;
}

int main(int argc, const char *argv[])
{
    try
    {
        vector<int> v1;
        for (int i = 0; i < 10; ++i)
        {
            v1.push_back(i);
        }
        cout << "v1: " << v1 << "\n";
        vector<double> v2;
        for (int i = 0; i < 8; ++i)
        {
            v2.push_back(i * 1.6);
        }
        cout << "v2: " << v2 << "\n";
        cout << "f(v1,v2): " << f(v1, v2) << "\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
v1: { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
v2: { 0, 1.6, 3.2, 4.8, 6.4, 8, 9.6, 11.2 }
f(v1,v2): 224

ch17_p06.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template<typename T, typename U>
class Pair
{
public:
    Pair(const T &vt, const U &vu) : val1(vt), val2(vu) { }
    T val1;
    U val2;
};

class Symbol_table
{
public:
    double get(const string &s);
    void set(const string &s, double d);
    bool is_declared(const string &s);
    double declare(const string &s, double val);
    void print();
private:
    vector< Pair<string, double> > var_table;
};

double Symbol_table::get(const string &s)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].val1 == s) { return var_table[i].val2; }
    }
    error("Variable not found: " + s);
}

void Symbol_table::set(const string &s, double d)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].val1 == s)
        {
            var_table[i].val2 = d;
            return;
        }
    }
    error("Variable not found: " + s);
}

bool Symbol_table::is_declared(const string &s)
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        if (var_table[i].val1 == s) { return true; }
    }
    return false;
}

double Symbol_table::declare(const string &s, double d)
{
    if (is_declared(s)) { error("Variable exists already: " + s); }
    var_table.push_back(Pair<string, double>(s, d));
    return d;
}

void Symbol_table::print()
{
    for (int i = 0; i < var_table.size(); ++i)
    {
        cout << var_table[i].val1 << ": " << var_table[i].val2 << "\n";
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        Symbol_table st;
        st.declare("Pi", 3.14);
        st.declare("e", 2.72);
        st.print();
        cout << "Pi is " << st.get("Pi") << "\n";
        if (st.is_declared("Pi"))
        {
            cout << "Pi is declared\n";
        }
        else
        {
            cout << "Pi is not declared\n";
        }
        if (st.is_declared("nd"))
        {
            cout << "nd is declared\n";
        }
        else
        {
            cout << "nd is not declared\n";
        }
        st.set("Pi", 4.14);
        cout << "Pi is now " << st.get("Pi") << "\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Pi: 3.14
e: 2.72
Pi is 3.14
Pi is declared
nd is not declared
Pi is now 4.14

ch17_p07.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Customer
{
private:
    long arrive;
    int processtime;
public:
    Customer()
    {
        arrive = processtime = 0;
    }
    void set(long when);
    long when() const
    {
        return arrive;
    }
    int ptime() const
    {
        return processtime;
    }
};

typedef Customer Item;

class Queue
{
private:
    struct Node
    {
        Item item;
        struct Node *next;
    };
    enum { Q_SIZE = 10 };
    Node *front;
    Node *rear;
    int items;
    const int qsize;

    Queue(const Queue &q) : qsize(0) { }
    Queue &operator=(const Queue &q)
    {
        return *this;
    }
public:
    Queue(int qs = Q_SIZE);
    ~Queue();
    bool isempty() const;
    bool isfull() const;
    int queuecount() const;
    bool enqueue(const Item &item);
    bool dequeue(Item &item);
};

Queue::Queue(int qs) : qsize(qs)
{
    front = rear = nullptr;
    items = 0;
}

Queue::~Queue()
{
    Node *next;
    while (front != nullptr)
    {
        next = front->next;
        delete front;
        front = next;
    }
}

bool Queue::isempty() const
{
    return items == 0;
}

bool Queue::isfull() const
{
    return items == qsize;
}

int Queue::queuecount() const
{
    return items;
}
bool Queue::enqueue(const Item &item)
{
    if (isfull())
    {
        return false;
    }
    Node *add = new Node;

    add->item = item;
    add->next = nullptr;
    if (items == 0)
    {
        front = add;
        rear = add;
    }
    else
    {
        rear->next = add;
        rear = add;
    }
    items++;
    return true;
}
bool Queue::dequeue(Item &item)
{
    if (isempty())
    {
        return false;
    }
    item = front->item;
    items--;
    Node *next = front->next;
    delete front;
    front = next;
    if (items == 0)
    {
        front = nullptr;
        rear = nullptr;
    }
    return true;
}
void Customer::set(long when)
{
    processtime = std::rand() % 3 + 1;
    arrive = when;
}

const int MIN_PER_HR = 60;

bool newcustomer(double x)
{
    return ( (std::rand() * x) / RAND_MAX < 1);
}

int main(int argc, const char *argv[])
{
    try
    {
        std::srand(std::time(nullptr));

        cout << "Case Study: Bank of Heather Automatic Teller\n";
        cout << "Enter maximum size of queue: ";
        int qs;
        cin >> qs;

        cout << "Enter the number of simulation hours: ";
        int hours;
        cin >> hours;
        long cyclelimit = MIN_PER_HR * hours;

        double perhour;
        double min_per_cust;

        Item temp;
        long turnaways = 0;
        long customers = 0;
        long served = 0;
        long sum_line = 0;
        int wait_time = 0;
        long line_wait = 0;

        int i = hours;

        do
        {
            perhour = i--;
            min_per_cust = MIN_PER_HR / perhour;
            Queue line(qs);
            turnaways = 0;
            customers = 0;
            served = 0;
            sum_line = 0;
            wait_time = 0;
            line_wait = 0;

            for (long cycle = 0; cycle < cyclelimit; cycle++)
            {
                if (newcustomer(min_per_cust))
                {
                    if (line.isfull())
                    {
                        turnaways++;
                    }
                    else
                    {
                        customers++;
                        temp.set(cycle);
                        line.enqueue(temp);
                    }
                }
                if (wait_time <= 0 && !line.isempty())
                {
                    line.dequeue(temp);
                    wait_time = temp.ptime();
                    line_wait += cycle - temp.when();
                    served++;
                }
                if (wait_time > 0)
                {
                    wait_time--;
                }
                sum_line += line.queuecount();
            }
        }
        while ((double)line_wait / served > 1.0);
        i++;

        if (customers > 0)
        {
            std::cout << "customers per hours: " << i << std::endl;
            cout << "customers accepted: " << customers << endl;
            cout << "customers served: " << served << endl;
            cout << "customers turnaways: " << turnaways << endl;
            cout.precision(2);
            cout.setf(ios_base::fixed, ios_base::floatfield);
            cout.setf(ios_base::showpoint);
            cout << "average queue size: " << (double)sum_line / cyclelimit << endl;
            cout << "average wait time: " << (double)line_wait / served << " minutes\n";
        }
        else
        {
            cout << "No customers!\n";
        }
        cout << "Done.\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 20
Enter the number of simulation hours: 100
customers per hours: 18
customers accepted: 1804
customers served: 1804
customers turnaways: 0
average queue size: 0.25
average wait time: 0.84 minutes
Done.

ch17_p08.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Customer
{
private:
    long arrive;
    int processtime;
public:
    Customer()
    {
        arrive = processtime = 0;
    }
    void set(long when);
    long when() const
    {
        return arrive;
    }
    int ptime() const
    {
        return processtime;
    }
};

typedef Customer Item;

class Queue
{
private:
    struct Node
    {
        Item item;
        struct Node *next;
    };
    enum { Q_SIZE = 10 };
    Node *front;
    Node *rear;
    int items;
    const int qsize;

    Queue(const Queue &q) : qsize(0) { }
    Queue &operator=(const Queue &q)
    {
        return *this;
    }
public:
    Queue(int qs = Q_SIZE);
    ~Queue();
    bool isempty() const;
    bool isfull() const;
    int queuecount() const;
    bool enqueue(const Item &item);
    bool dequeue(Item &item);
};

Queue::Queue(int qs) : qsize(qs)
{
    front = rear = nullptr;
    items = 0;
}

Queue::~Queue()
{
    Node *next;
    while (front != nullptr)
    {
        next = front->next;
        delete front;
        front = next;
    }
}

bool Queue::isempty() const
{
    return items == 0;
}

bool Queue::isfull() const
{
    return items == qsize;
}

int Queue::queuecount() const
{
    return items;
}
bool Queue::enqueue(const Item &item)
{
    if (isfull())
    {
        return false;
    }
    Node *add = new Node;

    add->item = item;
    add->next = nullptr;
    if (items == 0)
    {
        front = add;
        rear = add;
    }
    else
    {
        rear->next = add;
        rear = add;
    }
    items++;
    return true;
}
bool Queue::dequeue(Item &item)
{
    if (isempty())
    {
        return false;
    }
    item = front->item;
    items--;
    Node *next = front->next;
    delete front;
    front = next;
    if (items == 0)
    {
        front = nullptr;
        rear = nullptr;
    }
    return true;
}
void Customer::set(long when)
{
    processtime = std::rand() % 3 + 1;
    arrive = when;
}

const int MIN_PER_HR = 60;

bool newcustomer(double x)
{
    return ( (std::rand() * x) / RAND_MAX < 1);
}

int main(int argc, const char *argv[])
{
    try
    {
        std::srand(std::time(nullptr));

        cout << "Case Study: Bank of Heather Automatic Teller\n";
        cout << "Enter maximum size of queue: ";
        int qs;
        cin >> qs;

        cout << "Enter the number of simulation hours: ";
        int hours;
        cin >> hours;
        long cyclelimit = MIN_PER_HR * hours;

        double perhour;
        double min_per_cust;

        Item temp;

        long turnawaysL1 = 0;
        long customersL1 = 0;
        long servedL1 = 0;
        long sum_lineL1 = 0;
        int wait_timeL1 = 0;
        long line_waitL1 = 0;

        long turnawaysL2 = 0;
        long customersL2 = 0;
        long servedL2 = 0;
        long sum_lineL2 = 0;
        int wait_timeL2 = 0;
        long line_waitL2 = 0;

        double average_wait;

        int i = hours;

        do
        {
            perhour = i--;
            min_per_cust = MIN_PER_HR / perhour;
            Queue line1(qs);
            Queue line2(qs);
            turnawaysL1 = turnawaysL2 = 0;
            customersL1 = customersL2 = 0;
            servedL1 = servedL2 = 0;
            sum_lineL1 = sum_lineL2 = 0;
            wait_timeL1 = wait_timeL2 = 0;
            line_waitL1 = line_waitL2 = 0;

            for (long cycle = 0; cycle < cyclelimit; cycle++)
            {
                if (newcustomer(min_per_cust))
                {
                    if (line1.queuecount() <= line2.queuecount())
                    {
                        if (line1.isfull())
                        {
                            turnawaysL1++;
                        }
                        else
                        {
                            customersL1++;
                            temp.set(cycle);
                            line1.enqueue(temp);
                        }
                    }
                    else
                    {
                        if (line2.isfull())
                        {
                            turnawaysL2++;
                        }
                        else
                        {
                            customersL2++;
                            temp.set(cycle);
                            line2.enqueue(temp);
                        }
                    }
                }
                if (wait_timeL1 == 0 && !line1.isempty())
                {
                    line1.dequeue(temp);
                    wait_timeL1 = temp.ptime();
                    line_waitL1 += cycle - temp.when();
                    servedL1++;
                }

                if (wait_timeL2 == 0 && !line2.isempty())
                {
                    line2.dequeue(temp);
                    wait_timeL2 = temp.ptime();
                    line_waitL2 += cycle - temp.when();
                    servedL2++;
                }
                if (wait_timeL1 > 0)
                {
                    wait_timeL1--;
                }

                if (wait_timeL2 > 0)
                {
                    wait_timeL2--;
                }
                sum_lineL1 += line1.queuecount();
                sum_lineL2 += line2.queuecount();
            }
            average_wait = double(line_waitL1 + line_waitL2) / (servedL1 + servedL2);

        }
        while (average_wait > 1.0);
        i++;

        if (customersL1 + customersL2 > 0)
        {
            std::cout << "customers per hours: " << i << std::endl;
            cout << "customers accepted: " << customersL1 + customersL2 << endl;
            cout << "customers served: " << servedL1 + servedL2 << endl;
            cout << "customers turnaways: " << turnawaysL1 + turnawaysL2 << endl;
            cout.precision(2);
            cout.setf(ios_base::fixed, ios_base::floatfield);
            cout.setf(ios_base::showpoint);
            cout << "average queue1 size: " << (double)sum_lineL1 / cyclelimit << endl;
            cout << "average queue2 size: " << (double)sum_lineL2 / cyclelimit << endl;
            cout << "average wait time: " << average_wait << " minutes\n";
        }
        else
        {
            cout << "No customers!\n";
        }
        cout << "Done.\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Case Study: Bank of Heather Automatic Teller
Enter maximum size of queue: 20
Enter the number of simulation hours: 100
customers per hours: 50
customers accepted: 5047
customers served: 5046
customers turnaways: 0
average queue1 size: 0.58
average queue2 size: 0.22
average wait time: 0.95 minutes
Done.

第18章 自定义模板的介绍
18.1 简介
18.2 类模板
18.3 使用函数模板来操作类模板特化的对象
18.4 非类型形参
18.5 模板类型形参的默认实参
18.6 重载函数模板
18.7 本章小结
ch18_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template<typename T>
class Link
{
private:
    Link<T> *prev;
    Link<T> *succ;
public:
    T value;
    Link(const T &v = T(), Link<T> *p = nullptr, Link<T> *s = nullptr) : value(v), prev(p), succ(s) { }

    Link<T> *insert(Link<T> *n);
    Link<T> *add(Link<T> *n);
    Link<T> *add_ordered(Link<T> *n);
    Link<T> *erase();
    Link<T> *find(const T &v);

    Link<T> *advance(int n);

    Link<T> *next() const
    {
        return succ;
    }
    Link<T> *previous() const
    {
        return prev;
    }
    void print_all();
};

template<typename T>
Link<T> *Link<T>::insert(Link<T> *n)
{
    if (n == nullptr)
    {
        return n;
    }
    n->succ = this;
    if (prev != nullptr)
    {
        prev->succ = n;
    }
    n->prev = prev;
    prev = n;
    return n;
}

template<typename T>
Link<T> *Link<T>::add(Link<T> *n)
{
    if (n == nullptr)
    {
        return n;
    }
    n->prev = this;
    if (succ != nullptr)
    {
        succ->prev = n;
    }
    n->succ = succ;
    succ = n;
    return n;
}

template<typename T>
Link<T> *Link<T>::add_ordered(Link<T> *n)
{
    if (n == nullptr)
    {
        return n;
    }
    if (n->value < value)
    {
        Link<T> *p = insert(n);
        return p;
    }
    Link<T> *p = this;
    while (n->value >= p->value)
    {
        if (p->succ == nullptr)
        {
            p->add(n);
            return this;
        }
        p = p->succ;
    }
    p->insert(n);
    return this;
}

template<typename T>
Link<T> *Link<T>::erase()
{
    if (succ != nullptr)
    {
        succ->prev = prev;
    }
    if (prev != nullptr)
    {
        prev->succ = succ;
    }
    Link<T> *ret = succ;
    succ = nullptr;
    prev = nullptr;
    return ret;
}

template<typename T>
Link<T> *Link<T>::find(const T &v)
{
    Link<T> *p = this;
    while (p != nullptr)
    {
        if (p->value == v)
        {
            return p;
        }
        p = p->succ;
    }
    return nullptr;
}

template<typename T>
Link<T> *Link<T>::advance(int n)
{
    Link<T> *p = this;
    if (0 < n)
    {
        while (n--)
        {
            if (p->succ == nullptr)
            {
                return nullptr;
            }
            p = p->succ;
        }
    }
    else if (n < 0)
    {
        while (n++)
        {
            if (p->prev == nullptr)
            {
                return nullptr;
            }
            p = p->prev;
        }
    }
    return p;
}

template<typename T>
void Link<T>::print_all()
{
    Link<T> *p = this;
    while (p != nullptr)
    {
        cout << p->value << "\n";
        p = p->succ;
    }
}

template<typename T>
void delete_all(Link<T> *p)
{
    while (p != nullptr)
    {
        Link<T> *temp = p->next();
        delete p;
        p = temp;
    }
}

template<typename T>
Link<T> *extract(Link<T> **l, const T &v)
{
    if ( (*l) == nullptr )
    {
        return nullptr;
    }
    Link<T> *p = (*l)->find(v);
    if (p != nullptr)
    {
        if (p == (*l))
        {
            (*l) = p->next();
        }
        p->erase();
        return p;
    }
    return nullptr;
}

template<typename T>
void move(Link<T> *&from, Link<T> *&to, const T &v)
{
    Link<T> *temp = extract<T>(&from, v);
    if (temp != nullptr)
    {
        to = to->add_ordered(temp);
    }
}

template<typename T>
class my_list
{
private:
    Link<T> *first;
    Link<T> *last;
public:
    my_list() : first(new Link<T>()), last(first) { }
    ~my_list()
    {
        delete_all(first);
    }

    void print()
    {
        Link<T> *p = first;
        while (p != last)
        {
            cout << p->value << "\n";
            p = p->next();
        }
    }

    class iterator
    {
    private:
        Link<T> *curr;
    public:
        friend class my_list<T>;
        iterator(Link<T> *p) : curr(p) { }

        iterator &operator++()
        {
            curr = curr->next();
            return *this;
        }
        iterator &operator--()
        {
            curr = curr->previous();
            return *this;
        }
        T &operator*()
        {
            return curr->value;
        }

        bool operator==(const iterator &b) const
        {
            return curr == b.curr;
        }
        bool operator!=(const iterator &b) const
        {
            return curr != b.curr;
        }
    };

    iterator begin();
    iterator end();

    iterator insert(iterator p, const T &v);
    iterator erase(iterator p);

    void push_front(const T &v);
    void push_back(const T &v);
    void pop_front();
    void pop_back();

    T &front();
    T &back();
};

template<typename T>
typename my_list<T>::iterator my_list<T>::begin()
{
    return iterator(first);
}

template<typename T>
typename my_list<T>::iterator my_list<T>::end()
{
    return iterator(last);
}

template<typename T>
typename my_list<T>::iterator my_list<T>::insert(iterator p, const T &v)
{
    Link<T> *n = new Link<T>(v);
    Link<T> *p_link = p.curr;
    Link<T> *p_ret = p_link->insert(n);
    if (first == p_link)
    {
        first = p_ret;
    }
    return iterator(p_ret);
}

template<typename T>
typename my_list<T>::iterator my_list<T>::erase(iterator p)
{
    Link<T> *p_link = p.curr;
    Link<T> *p_ret = p_link->erase();
    if (first == p_link)
    {
        first = p_ret;
    }
    delete p_link;
    return iterator(p_ret);
}

template<typename T>
void my_list<T>::push_front(const T &v)
{
    Link<T> *n = new Link<T>(v);
    Link<T> *p_link = first;
    Link<T> *p_ret = p_link->insert(n);
    first = p_ret;
}

template<typename T>
void my_list<T>::push_back(const T &v)
{
    Link<T> *n = new Link<T>(v);
    Link<T> *p_link = last;
    Link<T> *p_ret = p_link->insert(n);
    if (first == p_link)
    {
        first = p_ret;
    }
}

template<typename T>
void my_list<T>::pop_front()
{
    Link<T> *p_link = first;
    Link<T> *p_ret = p_link->erase();
    first = p_ret;
    delete p_link;
}

template<typename T>
void my_list<T>::pop_back()
{
    Link<T> *p_link = last->previous();
    Link<T> *p_ret = p_link->erase();
    if (first == p_link)
    {
        first = p_ret;
    }
    delete p_link;
}

template<typename T>
T &my_list<T>::front()
{
    Link<T> *p_link = first;
    return p_link->value;
}

template<typename T>
T &my_list<T>::back()
{
    Link<T> *p_link = last->previous();
    return p_link->value;
}

template<typename Iterator>
Iterator high(Iterator first, Iterator last)
{
    Iterator high = first;
    for (Iterator p = first; p != last; ++p)
    {
        if (*high < *p)
        {
            high = p;
        }
    }
    return high;
}

int main(int argc, const char *argv[])
{
    try
    {
        my_list<int> lst;
        int x;
        while (cin >> x)
        {
            lst.push_front(x);
        }
        lst.print();
        my_list<int>::iterator p = high(lst.begin(), lst.end());
        cout << "The highest value was " << *p << "\n";

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
1 3 5 9 6 18 23 7 2
2
7
23
18
6
9
5
3
1
The highest value was 23

ch18_p02.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class element
{
public:
    element(int k, int new_height) : key(k), next(new_height + 1) { }
    int key;
    vector<element *> next;
};

class skip_list
{
public:
    skip_list();
    element *find(int x);
    void insert(int x);
    void remove(int x);
    void print();
    void debug_print();
    int get_height()
    {
        return height;
    }
private:
    const int max_height = 128;
    const int infty = numeric_limits<int>::max();
    element head;
    element tail;
    int height;
    mt19937 engine;
};

skip_list::skip_list()
    : head(infty, max_height), tail(infty, max_height), height(0), engine( unsigned ( std::chrono::system_clock::now().time_since_epoch().count() ) )
{
    for (int i = 0; i < head.next.size(); ++i)
    {
        head.next[i] = &tail;
    }
}

element *skip_list::find(int x)
{
    element *p = &head;

    for (int i = height; i >= 0; --i)
    {
        while (p->next[i]->key < x)
        {
            p = p->next[i];
        }
    }

    p = p->next[0];
    if (p->key == x)
    {
        return p;
    }
    else
    {
        return nullptr;
    }
}

void skip_list::insert(int x)
{
    vector<element *> update(max_height + 1);
    element *p = &head;

    for (int i = height; i >= 0; --i)
    {
        while (p->next[i]->key < x)
        {
            p = p->next[i];
        }
        update[i] = p;
    }
    p = p->next[0];

    if (p->key == x)
    {
        return;
    }

    int new_height = nrand_two(0, max_height + 1, engine);
    if (new_height > height)
    {
        for (int i = height + 1; i <= new_height; ++i)
        {
            update[i] = &head;
        }
        height = new_height;
    }

    p = new element(x, new_height);

    for (int i = 0; i <= new_height; ++i)
    {
        p->next[i] = update[i]->next[i];
        update[i]->next[i] = p;
    }
}

void skip_list::remove(int x)
{
    vector<element *> update(max_height + 1);
    element *p = &head;
    for (int i = height; i >= 0; --i)
    {
        while (p->next[i]->key < x)
        {
            p = p->next[i];
        }
        update[i] = p;
    }
    p = p->next[0];

    if (p->key == x)
    {
        for (int i = 0; i < p->next.size(); ++i)
        {
            update[i]->next[i] = p->next[i];
        }
        while (height >= 1 && head.next[height] == &tail)
        {
            --height;
        }
        delete p;
    }
}

void skip_list::print()
{
    element *p = head.next[0];
    while (p != &tail)
    {
        cout << setw(5) << p->key;
        p = p->next[0];
    }
    cout << endl;
}

void skip_list::debug_print()
{
    for (int i = 0; i <= height; ++i)
    {
        element *p = head.next[i];
        cout << setw(3) << i << ": ";
        while (p != &tail)
        {
            cout << setw(3) << p->key << " ";
            p = p->next[i];
        }
        cout << endl;
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
        mt19937 engine(seed);

        skip_list sl;
        for (int i = 0; i < 30; ++i)
        {
            sl.insert(nrand_two(0, 100, engine));
        }
        sl.debug_print();
        cout << "Enter value to remove: ";
        int x;
        cin >> x;
        element *p = sl.find(x);
        if (p != nullptr)
        {
            cout << "p->key = " << p->key << endl;
            sl.remove(x);
            sl.debug_print();
        }
        else
        {
            cout << x << " is not found\n";
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
  0:   0  10  13  16  17  20  27  29  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  93  96  99
  1:   0  10  13  16  17  20  27  29  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  93  96  99
  2:   0  10  13  16  17  20  27  29  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  93  96  99
  3:   0  10  13  16  20  27  29  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  93  96  99
  4:   0  10  13  16  20  27  29  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  93  96
  5:   0  10  13  16  20  27  29  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  93  96
  6:   0  10  13  16  20  27  29  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  93  96
  7:   0  10  13  16  20  27  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  93  96
  8:   0  10  13  16  20  27  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  96
  9:   0  10  13  16  20  27  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  96
 10:   0  10  13  16  20  27  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  96
 11:   0  10  13  16  20  27  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  96
 12:   0  10  13  16  20  27  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  96
 13:   0  10  13  16  20  27  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  96
 14:   0  10  13  16  20  27  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  96
 15:   0  10  13  16  20  27  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  96
 16:   0  10  13  16  20  27  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  96
 17:   0  10  13  16  20  27  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  96
 18:   0  10  13  16  20  27  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  96
 19:   0  10  13  16  20  27  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  96
 20:   0  10  13  16  20  27  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  96
 21:   0  10  13  16  20  27  30  40  41  50  54  57  65  66  67  69  72  84  86  89  92  96
 22:   0  10  13  16  20  27  30  40  41  50  54  57  65  66  69  72  84  86  89  92  96
 23:   0  10  13  16  27  30  40  41  50  54  57  65  66  69  72  84  86  89  92  96
 24:   0  10  13  16  27  30  40  41  50  54  57  65  66  69  72  84  86  89  92  96
 25:   0  10  13  16  27  30  40  41  50  54  57  65  66  69  72  84  86  89  92  96
 26:   0  10  13  16  27  30  40  41  50  54  57  65  66  69  72  84  86  89  92  96
 27:   0  10  13  16  27  30  40  41  50  54  57  65  66  69  72  84  86  89  92  96
 28:   0  10  13  16  27  30  40  41  50  54  65  66  69  72  84  86  92  96
 29:  10  13  16  27  30  40  41  50  54  65  66  69  72  84  86  92  96
 30:  10  13  16  27  30  40  41  50  54  65  66  69  72  84  86  92  96
 31:  10  13  16  27  30  40  41  50  54  65  66  69  72  84  86  92  96
 32:  10  13  16  27  30  40  41  50  54  65  66  69  72  84  86  92  96
 33:  10  13  16  27  30  40  41  50  54  65  66  69  72  84  86  92  96
 34:  10  13  16  27  30  40  41  50  54  65  66  69  72  84  86  92  96
 35:  10  13  16  27  30  40  41  50  54  65  66  69  72  84  86  92
 36:  10  13  16  27  30  40  41  50  54  65  66  69  72  84  86  92
 37:  10  13  16  27  30  40  41  50  54  65  66  69  72  84  86  92
 38:  10  13  16  27  40  41  50  54  65  66  69  72  84  86  92
 39:  10  13  16  27  40  41  50  54  65  66  69  72  84  86  92
 40:  10  13  16  27  40  41  50  54  65  66  69  72  84  86  92
 41:  10  13  16  27  40  41  50  54  65  66  69  72  84  86  92
 42:  10  13  16  27  40  50  54  65  66  69  72  84  86  92
 43:  10  13  16  27  40  50  54  65  66  69  72  84  86  92
 44:  10  13  16  27  40  50  54  65  66  69  72  84  86  92
 45:  10  13  16  27  40  50  54  65  66  69  72  84  86  92
 46:  10  13  16  27  50  54  65  66  69  72  84  86  92
 47:  10  13  16  50  54  65  66  69  72  84  86  92
 48:  10  13  16  50  54  65  66  69  72  84  86  92
 49:  10  13  16  50  54  65  66  69  72  84  86  92
 50:  10  13  16  50  54  65  66  69  72  84  86  92
 51:  10  13  16  50  54  65  66  69  72  84  86  92
 52:  10  13  16  50  54  65  66  69  72  84  86  92
 53:  10  13  16  50  54  65  66  69  72  84  86  92
 54:  10  13  16  50  54  65  66  69  72  84  86  92
 55:  10  13  16  50  54  65  66  72  84  86  92
 56:  10  13  16  50  54  65  66  72  84  86
 57:  10  13  16  50  54  65  66  72  84  86
 58:  10  13  16  50  54  65  66  72  84  86
 59:  10  13  16  50  54  65  66  72  84  86
 60:  10  13  16  50  54  65  66  72  84  86
 61:  10  13  16  50  54  65  66  72  84  86
 62:  10  13  16  50  54  65  66  72  84  86
 63:  10  13  16  50  54  65  66  72  84  86
 64:  10  13  16  50  54  65  66  72  84  86
 65:  10  13  16  50  54  65  66  72  84  86
 66:  10  13  16  50  54  65  66  72  84  86
 67:  10  13  16  50  54  65  66  72  84  86
 68:  10  13  16  50  54  65  66  72  84  86
 69:  10  13  16  50  54  65  66  72  84  86
 70:  10  13  16  50  54  65  66  72  84  86
 71:  10  13  16  50  54  65  66  72  84  86
 72:  10  13  16  50  54  65  66  72  84  86
 73:  10  13  16  50  54  65  66  72  84  86
 74:  10  13  16  50  65  66  72  84  86
 75:  10  13  16  50  65  66  72  84  86
 76:  10  13  16  50  65  66  72  84  86
 77:  10  13  16  50  65  66  72  84  86
 78:  10  13  16  50  65  66  72  84  86
 79:  10  13  16  50  65  66  72  84  86
 80:  10  13  16  50  65  66  72  84  86
 81:  10  13  16  50  65  66  72  84  86
 82:  10  13  16  50  65  66  72  84  86
 83:  10  13  16  50  65  66  72  84  86
 84:  10  13  16  50  65  66  72  84  86
 85:  10  13  16  50  65  66  72  84  86
 86:  13  16  50  65  66  72  84  86
 87:  13  16  50  65  66  72  84  86
 88:  13  16  50  65  66  72  84  86
 89:  13  16  50  65  66  72  84  86
 90:  13  16  50  65  66  72  84  86
 91:  13  16  50  65  66  72  84  86
 92:  13  16  50  65  66  72  84  86
 93:  13  16  50  65  66  72  84  86
 94:  13  16  50  66  72  84  86
 95:  13  16  50  66  72  84  86
 96:  13  16  50  66  72  84  86
 97:  13  16  50  66  72  84  86
 98:  13  16  50  66  84  86
 99:  13  16  50  66  84  86
100:  13  16  50  66  84  86
101:  13  16  50  66  84  86
102:  13  16  50  66  84  86
103:  13  16  50  66  84  86
104:  13  16  50  66  84  86
105:  13  16  50  66  84  86
106:  13  16  50  66  84  86
107:  13  16  50  66  84  86
108:  13  16  50  66  84  86
109:  13  16  50  66  84  86
110:  13  16  50  66  84  86
111:  13  16  50  66  86
112:  13  16  50  66  86
113:  13  16  66  86
114:  13  16  66  86
115:  13  16  66  86
116:  13  16  66  86
117:  13  16  66  86
118:  13  16  66  86
119:  13  16  66  86
120:  13  16  66  86
121:  13  16  66  86
122:  13  16  66  86
123:  13  66  86
124:  13  66  86
125:  13  86
126:  86
127:  86
Enter value to remove: 66
p->key = 66
  0:   0  10  13  16  17  20  27  29  30  40  41  50  54  57  65  67  69  72  84  86  89  92  93  96  99
  1:   0  10  13  16  17  20  27  29  30  40  41  50  54  57  65  67  69  72  84  86  89  92  93  96  99
  2:   0  10  13  16  17  20  27  29  30  40  41  50  54  57  65  67  69  72  84  86  89  92  93  96  99
  3:   0  10  13  16  20  27  29  30  40  41  50  54  57  65  67  69  72  84  86  89  92  93  96  99
  4:   0  10  13  16  20  27  29  30  40  41  50  54  57  65  67  69  72  84  86  89  92  93  96
  5:   0  10  13  16  20  27  29  30  40  41  50  54  57  65  67  69  72  84  86  89  92  93  96
  6:   0  10  13  16  20  27  29  30  40  41  50  54  57  65  67  69  72  84  86  89  92  93  96
  7:   0  10  13  16  20  27  30  40  41  50  54  57  65  67  69  72  84  86  89  92  93  96
  8:   0  10  13  16  20  27  30  40  41  50  54  57  65  67  69  72  84  86  89  92  96
  9:   0  10  13  16  20  27  30  40  41  50  54  57  65  67  69  72  84  86  89  92  96
 10:   0  10  13  16  20  27  30  40  41  50  54  57  65  67  69  72  84  86  89  92  96
 11:   0  10  13  16  20  27  30  40  41  50  54  57  65  67  69  72  84  86  89  92  96
 12:   0  10  13  16  20  27  30  40  41  50  54  57  65  67  69  72  84  86  89  92  96
 13:   0  10  13  16  20  27  30  40  41  50  54  57  65  67  69  72  84  86  89  92  96
 14:   0  10  13  16  20  27  30  40  41  50  54  57  65  67  69  72  84  86  89  92  96
 15:   0  10  13  16  20  27  30  40  41  50  54  57  65  67  69  72  84  86  89  92  96
 16:   0  10  13  16  20  27  30  40  41  50  54  57  65  67  69  72  84  86  89  92  96
 17:   0  10  13  16  20  27  30  40  41  50  54  57  65  67  69  72  84  86  89  92  96
 18:   0  10  13  16  20  27  30  40  41  50  54  57  65  67  69  72  84  86  89  92  96
 19:   0  10  13  16  20  27  30  40  41  50  54  57  65  67  69  72  84  86  89  92  96
 20:   0  10  13  16  20  27  30  40  41  50  54  57  65  67  69  72  84  86  89  92  96
 21:   0  10  13  16  20  27  30  40  41  50  54  57  65  67  69  72  84  86  89  92  96
 22:   0  10  13  16  20  27  30  40  41  50  54  57  65  69  72  84  86  89  92  96
 23:   0  10  13  16  27  30  40  41  50  54  57  65  69  72  84  86  89  92  96
 24:   0  10  13  16  27  30  40  41  50  54  57  65  69  72  84  86  89  92  96
 25:   0  10  13  16  27  30  40  41  50  54  57  65  69  72  84  86  89  92  96
 26:   0  10  13  16  27  30  40  41  50  54  57  65  69  72  84  86  89  92  96
 27:   0  10  13  16  27  30  40  41  50  54  57  65  69  72  84  86  89  92  96
 28:   0  10  13  16  27  30  40  41  50  54  65  69  72  84  86  92  96
 29:  10  13  16  27  30  40  41  50  54  65  69  72  84  86  92  96
 30:  10  13  16  27  30  40  41  50  54  65  69  72  84  86  92  96
 31:  10  13  16  27  30  40  41  50  54  65  69  72  84  86  92  96
 32:  10  13  16  27  30  40  41  50  54  65  69  72  84  86  92  96
 33:  10  13  16  27  30  40  41  50  54  65  69  72  84  86  92  96
 34:  10  13  16  27  30  40  41  50  54  65  69  72  84  86  92  96
 35:  10  13  16  27  30  40  41  50  54  65  69  72  84  86  92
 36:  10  13  16  27  30  40  41  50  54  65  69  72  84  86  92
 37:  10  13  16  27  30  40  41  50  54  65  69  72  84  86  92
 38:  10  13  16  27  40  41  50  54  65  69  72  84  86  92
 39:  10  13  16  27  40  41  50  54  65  69  72  84  86  92
 40:  10  13  16  27  40  41  50  54  65  69  72  84  86  92
 41:  10  13  16  27  40  41  50  54  65  69  72  84  86  92
 42:  10  13  16  27  40  50  54  65  69  72  84  86  92
 43:  10  13  16  27  40  50  54  65  69  72  84  86  92
 44:  10  13  16  27  40  50  54  65  69  72  84  86  92
 45:  10  13  16  27  40  50  54  65  69  72  84  86  92
 46:  10  13  16  27  50  54  65  69  72  84  86  92
 47:  10  13  16  50  54  65  69  72  84  86  92
 48:  10  13  16  50  54  65  69  72  84  86  92
 49:  10  13  16  50  54  65  69  72  84  86  92
 50:  10  13  16  50  54  65  69  72  84  86  92
 51:  10  13  16  50  54  65  69  72  84  86  92
 52:  10  13  16  50  54  65  69  72  84  86  92
 53:  10  13  16  50  54  65  69  72  84  86  92
 54:  10  13  16  50  54  65  69  72  84  86  92
 55:  10  13  16  50  54  65  72  84  86  92
 56:  10  13  16  50  54  65  72  84  86
 57:  10  13  16  50  54  65  72  84  86
 58:  10  13  16  50  54  65  72  84  86
 59:  10  13  16  50  54  65  72  84  86
 60:  10  13  16  50  54  65  72  84  86
 61:  10  13  16  50  54  65  72  84  86
 62:  10  13  16  50  54  65  72  84  86
 63:  10  13  16  50  54  65  72  84  86
 64:  10  13  16  50  54  65  72  84  86
 65:  10  13  16  50  54  65  72  84  86
 66:  10  13  16  50  54  65  72  84  86
 67:  10  13  16  50  54  65  72  84  86
 68:  10  13  16  50  54  65  72  84  86
 69:  10  13  16  50  54  65  72  84  86
 70:  10  13  16  50  54  65  72  84  86
 71:  10  13  16  50  54  65  72  84  86
 72:  10  13  16  50  54  65  72  84  86
 73:  10  13  16  50  54  65  72  84  86
 74:  10  13  16  50  65  72  84  86
 75:  10  13  16  50  65  72  84  86
 76:  10  13  16  50  65  72  84  86
 77:  10  13  16  50  65  72  84  86
 78:  10  13  16  50  65  72  84  86
 79:  10  13  16  50  65  72  84  86
 80:  10  13  16  50  65  72  84  86
 81:  10  13  16  50  65  72  84  86
 82:  10  13  16  50  65  72  84  86
 83:  10  13  16  50  65  72  84  86
 84:  10  13  16  50  65  72  84  86
 85:  10  13  16  50  65  72  84  86
 86:  13  16  50  65  72  84  86
 87:  13  16  50  65  72  84  86
 88:  13  16  50  65  72  84  86
 89:  13  16  50  65  72  84  86
 90:  13  16  50  65  72  84  86
 91:  13  16  50  65  72  84  86
 92:  13  16  50  65  72  84  86
 93:  13  16  50  65  72  84  86
 94:  13  16  50  72  84  86
 95:  13  16  50  72  84  86
 96:  13  16  50  72  84  86
 97:  13  16  50  72  84  86
 98:  13  16  50  84  86
 99:  13  16  50  84  86
100:  13  16  50  84  86
101:  13  16  50  84  86
102:  13  16  50  84  86
103:  13  16  50  84  86
104:  13  16  50  84  86
105:  13  16  50  84  86
106:  13  16  50  84  86
107:  13  16  50  84  86
108:  13  16  50  84  86
109:  13  16  50  84  86
110:  13  16  50  84  86
111:  13  16  50  86
112:  13  16  50  86
113:  13  16  86
114:  13  16  86
115:  13  16  86
116:  13  16  86
117:  13  16  86
118:  13  16  86
119:  13  16  86
120:  13  16  86
121:  13  16  86
122:  13  16  86
123:  13  86
124:  13  86
125:  13  86
126:  86
127:  86


第19章 自定义的模板化数据结构
19.1 简介
19.2 自引用类
19.3 链表
19.4 堆栈
19.5 队列
19.6 树
19.7 本章小结
ch19_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

struct node
{
    int depth_of_node;
    int count_of_nodes;
    string key;
    string value;
    node *p_parent;
    node *p_left;
    node *p_right;
};

static const int maxNumberOfNodes = 100;

node *insert (node *p_tree, string key, string value);
node *search (node *p_tree, string key);
void destroy_tree (node *p_tree);
node *remove (node *p_tree, string key);
node *find_max (node *p_tree);
node *remove_max_node (node *p_tree, node *p_max_node);

node *add_entry(node *p_tree);
node *update_entry(node *p_tree);
node *delete_entry(node *p_tree);
void display_entry(node *p_tree);

void printSorted(node *tree);
void InOrder (node *p_tree, int *currentCount, string nodeKeys[]);
void InOrderNonRecursive (node *p_tree, int *currentCount, string nodeKeys[]);
void postOrderNonRecursive (node *p_tree, int *currentCount, string nodeKeys[]);
void preOrderNonRecursive (node *p_tree, int *currentCount, string nodeKeys[]);
void destroyTreePostOrder (node *p_tree);


void printSorted(node *tree)
{
    int currentCount = 0;
    string nodeKeys[maxNumberOfNodes];
    InOrder (tree, &currentCount, nodeKeys);

    for (int i = 0; i < currentCount; i++)
    {
        cout << "key | value = " << nodeKeys[i] << '\n';
    }
    cout << "\n\n";
}

node *insert (node *p_tree, string key, string value)
{
    int left_depth, right_depth;
    int left_count, right_count;

    if ( p_tree == nullptr )
    {
        node *p_new_tree = new node;
        p_new_tree->depth_of_node = 0;
        p_new_tree->count_of_nodes = 1;
        p_new_tree->p_parent = nullptr;
        p_new_tree->p_left = nullptr;
        p_new_tree->p_right = nullptr;
        p_new_tree->key = key;
        p_new_tree->value = value;
        return p_new_tree;
    }
    if ( key == p_tree->key )
    {
        p_tree->value = value;
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
    else if( key < p_tree->key )
    {
        p_tree->p_left = insert( p_tree->p_left, key, value);
        if (p_tree->p_left != nullptr)
        {
            p_tree->p_left->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
    else
    {
        p_tree->p_right = insert( p_tree->p_right, key, value );
        if (p_tree->p_right != nullptr)
        {
            p_tree->p_right->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
}

node *search (node *p_tree, string key)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    else if ( key == p_tree->key )
    {
        return p_tree;
    }
    else if ( key < p_tree->key )
    {
        return search( p_tree->p_left, key );
    }
    else
    {
        return search( p_tree->p_right, key );
    }
}
void preOrderNonRecursive (node *p_tree, int *currentCount, string nodeKeys[])
{
    node *last_node;
    node *check_node;

    if (p_tree == nullptr)
    {
        return;
    }
    last_node = nullptr;
    check_node = p_tree;
    nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
    (*currentCount)++;
    if (check_node->p_left != nullptr)
    {
        last_node = check_node;
        check_node = check_node->p_left;
    }
    else
    {
        if (check_node->p_right != nullptr)
        {
            last_node = check_node;
            check_node = check_node->p_right;
        }
        else
        {
            return;
        }
    }
    while(last_node != nullptr && check_node != nullptr)
    {
        if(last_node == check_node->p_parent)
        {
            nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
            (*currentCount)++;
            if (check_node->p_left != nullptr)
            {
                last_node = check_node;
                check_node = check_node->p_left;
            }
            else
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
        }
        else
        {
            if(last_node == check_node->p_left)
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
            else
            {
                last_node = check_node;
                check_node = check_node->p_parent;
            }
        }
    }
}
void postOrderNonRecursive (node *p_tree, int *currentCount, string nodeKeys[])
{
    node *last_node;
    node *check_node;

    if (p_tree == nullptr)
    {
        return;
    }
    last_node = nullptr;
    check_node = p_tree;
    if (check_node->p_left != nullptr)
    {
        last_node = check_node;
        check_node = check_node->p_left;
    }
    else
    {
        if (check_node->p_right != nullptr)
        {
            last_node = check_node;
            check_node = check_node->p_right;
        }
        else
        {
            nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
            (*currentCount)++;
            return;
        }
    }
    while(last_node != nullptr && check_node != nullptr)
    {
        if(last_node == check_node->p_parent)
        {
            if (check_node->p_left != nullptr)
            {
                last_node = check_node;
                check_node = check_node->p_left;
            }
            else
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
                    (*currentCount)++;
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
        }
        else
        {
            if(last_node == check_node->p_left)
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
                    (*currentCount)++;
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
            else
            {
                nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
                (*currentCount)++;
                last_node = check_node;
                check_node = check_node->p_parent;
            }
        }
    }
}
void destroyTreePostOrder (node *p_tree)
{
    node *last_node;
    node *check_node;
    node *temp_node;

    if (p_tree == nullptr)
    {
        return;
    }
    last_node = nullptr;
    check_node = p_tree;
    if (check_node->p_left != nullptr)
    {
        last_node = check_node;
        check_node = check_node->p_left;
    }
    else
    {
        if (check_node->p_right != nullptr)
        {
            last_node = check_node;
            check_node = check_node->p_right;
        }
        else
        {
            temp_node = check_node;
            cout << temp_node->key << '\n';
            delete temp_node;
            return;
        }
    }
    while(last_node != nullptr && check_node != nullptr)
    {
        if(last_node == check_node->p_parent)
        {
            if (check_node->p_left != nullptr)
            {
                last_node = check_node;
                check_node = check_node->p_left;
            }
            else
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    temp_node = check_node;
                    last_node = check_node;
                    check_node = check_node->p_parent;
                    cout << temp_node->key << '\n';
                    delete temp_node;
                }
            }
        }
        else
        {
            if(last_node == check_node->p_left)
            {
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    temp_node = check_node;
                    last_node = check_node;
                    check_node = check_node->p_parent;
                    cout << temp_node->key << '\n';
                    delete temp_node;
                }
            }
            else
            {
                temp_node = check_node;
                last_node = check_node;
                check_node = check_node->p_parent;
                cout << temp_node->key << '\n';
                delete temp_node;
            }
        }
    }
}
void InOrderNonRecursive (node *p_tree, int *currentCount, string nodeKeys[])
{
    node *last_node;
    node *check_node;

    if (p_tree == nullptr)
    {
        return;
    }
    last_node = nullptr;
    check_node = p_tree;
    if (check_node->p_left != nullptr)
    {
        last_node = check_node;
        check_node = check_node->p_left;
    }
    else
    {
        nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
        (*currentCount)++;
        if (check_node->p_right != nullptr)
        {
            last_node = check_node;
            check_node = check_node->p_right;
        }
        else
        {
            return;
        }
    }
    while(last_node != nullptr && check_node != nullptr)
    {
        if(last_node == check_node->p_parent)
        {
            if (check_node->p_left != nullptr)
            {
                last_node = check_node;
                check_node = check_node->p_left;
            }
            else
            {
                nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
                (*currentCount)++;
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
        }
        else
        {
            if(last_node == check_node->p_left)
            {
                nodeKeys[ (*currentCount) ] = check_node->key + " | " + check_node->value;
                (*currentCount)++;
                if (check_node->p_right != nullptr)
                {
                    last_node = check_node;
                    check_node = check_node->p_right;
                }
                else
                {
                    last_node = check_node;
                    check_node = check_node->p_parent;
                }
            }
            else
            {
                last_node = check_node;
                check_node = check_node->p_parent;
            }
        }
    }
}

void InOrder (node *p_tree, int *currentCount, string nodeKeys[])
{
    if (p_tree != nullptr)
    {
        InOrder (p_tree->p_left, currentCount, nodeKeys);
        nodeKeys[ (*currentCount) ] = p_tree->key + " | " + p_tree->value;
        (*currentCount)++;
        InOrder (p_tree->p_right, currentCount, nodeKeys);
    }
}

void destroy_tree (node *p_tree)
{
    if ( p_tree != nullptr )
    {
        destroy_tree( p_tree->p_left );
        destroy_tree( p_tree->p_right );
        delete p_tree;
    }
}

node *find_max (node *p_tree)
{
    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->p_right == nullptr )
    {
        return p_tree;
    }
    else
    {
        return find_max( p_tree->p_right );
    }
}
node *remove_max_node (node *p_tree, node *p_max_node)
{
    int left_depth, right_depth;
    int left_count, right_count;

    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree == p_max_node )
    {
        return p_max_node->p_left;
    }
    else
    {
        p_tree->p_right = remove_max_node( p_tree->p_right, p_max_node);
        if (p_tree->p_right != nullptr)
        {
            p_tree->p_right->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
}
node *remove (node *p_tree, string key)
{
    int left_depth, right_depth;
    int left_count, right_count;

    if ( p_tree == nullptr )
    {
        return nullptr;
    }
    if ( p_tree->key == key )
    {
        if ( p_tree->p_left == nullptr )
        {
            node *p_right_subtree = p_tree->p_right;
            delete p_tree;
            return p_right_subtree;
        }
        if ( p_tree->p_right == nullptr )
        {
            node *p_left_subtree = p_tree->p_left;
            delete p_tree;
            return p_left_subtree;
        }
        node *p_left_subtree = p_tree->p_left;
        node *p_right_subtree = p_tree->p_right;
        node *p_max_node = find_max( p_left_subtree );
        p_max_node->p_left = remove_max_node( p_tree->p_left, p_max_node );
        if (p_max_node->p_left != nullptr)
        {
            p_max_node->p_left->p_parent = p_max_node;
        }
        p_max_node->p_right = p_right_subtree;
        if (p_max_node->p_right != nullptr)
        {
            p_max_node->p_right->p_parent = p_max_node;
        }
        if (p_max_node->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_max_node->p_left->depth_of_node;
            left_count = p_max_node->p_left->count_of_nodes;
        }
        if (p_max_node->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_max_node->p_right->depth_of_node;
            right_count = p_max_node->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_max_node->depth_of_node = right_depth + 1;
        }
        else
        {
            p_max_node->depth_of_node = left_depth + 1;
        }
        p_max_node->count_of_nodes = left_count + right_count + 1;
        delete p_tree;
        return p_max_node;
    }
    else if ( key < p_tree->key )
    {
        p_tree->p_left = remove( p_tree->p_left, key);
        if (p_tree->p_left != nullptr)
        {
            p_tree->p_left->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
    else
    {
        p_tree->p_right = remove( p_tree->p_right, key);
        if (p_tree->p_right != nullptr)
        {
            p_tree->p_right->p_parent = p_tree;
        }
        if (p_tree->p_left == nullptr)
        {
            left_depth = -1;
            left_count = 0;
        }
        else
        {
            left_depth = p_tree->p_left->depth_of_node;
            left_count = p_tree->p_left->count_of_nodes;
        }
        if (p_tree->p_right == nullptr)
        {
            right_depth = -1;
            right_count = 0;
        }
        else
        {
            right_depth = p_tree->p_right->depth_of_node;
            right_count = p_tree->p_right->count_of_nodes;
        }
        if (left_depth < right_depth)
        {
            p_tree->depth_of_node = right_depth + 1;
        }
        else
        {
            p_tree->depth_of_node = left_depth + 1;
        }
        p_tree->count_of_nodes = left_count + right_count + 1;
        return p_tree;
    }
}

void display_entry(node *p_tree)
{
    string name = "";
    node *temp_node;

    do
    {
        name = "";
        cout << "Please enter a name from the address book to display:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( temp_node = search(p_tree, name) ) == nullptr )
        {
            cout << "The name can not find in the address book.\n";
            continue;
        }

        cout << '\n';
        cout << name << " | " << temp_node->value << "\n\n";
    }
    while (name != "");
}
node *add_entry(node *p_tree)
{
    string name = "";
    string email = "";
    node *temp_node;

    do
    {
        name = "";
        cout << "Please enter a name for the address book:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( temp_node = search(p_tree, name) ) != nullptr )
        {
            cout << "The name already exists.\n";
            cout << "Please enter a unique name to add.\n";
            continue;
        }
        email = "";
        cout << "Please enter an email address for the name:\n";
        getline(cin, email, '\n');
        if (email == "")
        {
            break;
        }

        p_tree = insert(p_tree, name, email);
        cout << "\n\n";
    }
    while (name != "");

    return p_tree;
}
node *update_entry(node *p_tree)
{
    string name = "";
    string email = "";
    node *temp_node;

    do
    {
        name = "";
        cout << "Please enter a name to update:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( temp_node = search(p_tree, name) ) == nullptr )
        {
            cout << "The name can not find in the address book.\n";
            cout << "Please enter an existing name to update.\n";
            continue;
        }
        email = "";
        cout << "Please enter a new email address for the name:\n";
        getline(cin, email, '\n');
        if (email == "")
        {
            break;
        }

        p_tree = insert(p_tree, name, email);
        cout << "\n\n";
    }
    while (name != "");

    return p_tree;
}
node *delete_entry(node *p_tree)
{
    string name = "";
    node *temp_node;

    do
    {
        name = "";
        cout << "Please enter a name to delete:\n";
        getline(cin, name, '\n');
        if (name == "")
        {
            break;
        }

        if ( ( temp_node = search(p_tree, name) ) == nullptr )
        {
            cout << "The name can not find in the address book.\n";
            cout << "Please enter an existing name to delete.\n";
            continue;
        }

        p_tree = remove(p_tree, name);
        cout << name << " has been removed from the address book.\n\n";
    }
    while (name != "");

    return p_tree;
}

int main(int argc, const char *argv[])
{
    try
    {
        node *tree = nullptr;
        bool exitProgram = false;
        int choice = 0;
        int numberOfNodes = 0;

        while(!exitProgram)
        {
            choice = 0;
            if (tree == nullptr)
            {
                numberOfNodes = 0;
            }
            else
            {
                numberOfNodes = tree->count_of_nodes;
            }
            cout << "Please choose from the following options:\n";
            cout << "0. Exit\n";
            cout << "1. Add entry\n";
            if (numberOfNodes > 0)
            {
                cout << "2. Update entry\n";
                cout << "3. Delete entry\n";
                cout << "4. Display entry\n";
            }
            cin >> choice;
            cin.clear();
            cin.ignore(80, '\n');

            cout << '\n';

            switch (choice)
            {
            case 0:
                exitProgram = true;
                break;
            case 1:
                tree = add_entry(tree);
                cout << "Display tree in sorted order\n";
                printSorted(tree);
                cout << '\n';
                break;
            case 2:
                tree = update_entry(tree);
                cout << "Display tree in sorted order\n";
                printSorted(tree);
                cout << '\n';
                break;
            case 3:
                tree = delete_entry(tree);
                cout << "Display tree in sorted order\n";
                printSorted(tree);
                cout << '\n';
                break;
            case 4:
                display_entry(tree);
                break;
            default:
                exitProgram = true;
                break;
            }
        }

        destroyTreePostOrder(tree);

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Please choose from the following options:
0. Exit
1. Add entry
1

Please enter a name for the address book:
WEIYAYUN
Please enter an email address for the name:
1043836212@qq.com


Please enter a name for the address book:
Peter Smith
Please enter an email address for the name:
123456789@qq.com


Please enter a name for the address book:
Hello world
Please enter an email address for the name:
abcdefg@qq.com


Please enter a name for the address book:

Display tree in sorted order
key | value = Hello world | abcdefg@qq.com
key | value = Peter Smith | 123456789@qq.com
key | value = WEIYAYUN | 1043836212@qq.com



Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
4

Please enter a name from the address book to display:
Peter Smith

Peter Smith | 123456789@qq.com

Please enter a name from the address book to display:
2
The name can not find in the address book.
Please enter a name from the address book to display:

Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
2

Please enter a name to update:
WEIYAYUN
Please enter a new email address for the name:
hijklmn@qq.com


Please enter a name to update:

Display tree in sorted order
key | value = Hello world | abcdefg@qq.com
key | value = Peter Smith | 123456789@qq.com
key | value = WEIYAYUN | hijklmn@qq.com



Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
3

Please enter a name to delete:
Hello World
The name can not find in the address book.
Please enter an existing name to delete.
Please enter a name to delete:
Hello world
Hello world has been removed from the address book.

Please enter a name to delete:

Display tree in sorted order
key | value = Peter Smith | 123456789@qq.com
key | value = WEIYAYUN | hijklmn@qq.com



Please choose from the following options:
0. Exit
1. Add entry
2. Update entry
3. Delete entry
4. Display entry
0

Peter Smith
WEIYAYUN

第20章 查找与排序
20.1 简介
20.2 查找算法
20.3 排序算法
20.4 本章小结
ch20_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

template<typename Ran, typename T>
bool my_binary_search(Ran first, Ran last, const T &val)
{
    if (first == last)
    {
        return false;
    }
    Ran p = first + (last - first) / 2;
    if (*p == val)
    {
        return true;
    }
    Ran p2 = p;
    ++p2;
    if (*p < val && p2 != last)
    {
        return my_binary_search(p2, last, val);
    }
    if (*p > val)
    {
        return my_binary_search(first, p, val);
    }
    return false;
}

template<typename Iter>
void print(Iter first, Iter last)
{
    while (first != last)
    {
        cout << *first << '\n';
        ++first;
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        vector<int> vi;
        for (int i = 0; i < 20; ++i)
        {
            vi.push_back(2 * i);
        }
        cout << "Vector:\n";
        print(vi.begin(), vi.end());

        cout << "Enter int to find (-1 to exit): ";
        int i;
        while (cin >> i && i != -1)
        {
            cout << i << " is " << (my_binary_search(vi.begin(), vi.end(), i) ? "" : "not ") << "in vi.\n";
            cout << "Enter int to find (-1 to exit): ";
        }

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
Vector:
0
2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
Enter int to find (-1 to exit): 18
18 is in vi.
Enter int to find (-1 to exit): 19
19 is not in vi.
Enter int to find (-1 to exit): 20
20 is in vi.
Enter int to find (-1 to exit): 21
21 is not in vi.
Enter int to find (-1 to exit): 22
22 is in vi.
Enter int to find (-1 to exit): 23
23 is not in vi.
Enter int to find (-1 to exit): -1

第21章 string类和字符串流处理的深入剖析
21.1 简介
21.2 字符串的赋值和连接
21.3 字符串的比较
21.4 子串
21.5 交换字符串
21.6 string类的特征
21.7 查找字符串中的子串和字符
21.8 在字符串中替换字符
21.9 在字符串中插入字符
21.10 转换成C风格的基于指针的char*字符串
21.11 迭代器
21.12 字符串流处理
21.13 C++11数值转换函数
21.14 本章小结

第22章 位、字符、C字符串和结构体
22.1 简介
22.2 结构体的定义
22.3 typedef
22.4 示例：洗牌和发牌模拟
22.5 位运算符
22.6 位域
22.7 字符处理库
22.8 C字符串操作函数
22.9 C字符串转换函数
22.10 C字符串操作库中的搜索函数
22.11 C字符串操作库中的内存函数
22.12 本章小结

第23章 其他主题
23.1 简介
23.2 const_cast运算符
23.3 mutable类成员
23.4 命名空间
23.5 运算符关键字
23.6 指向类成员的指针（.*和->*）
23.7 多重继承
23.8 多重继承和virtual基类
23.9 本章小结
ch23_p01.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <stdexcept>
#include <numeric>
#include <iomanip>
#include <chrono>
#include <memory>
#include <utility>
#include <random>
#include <limits>
#include <type_traits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include<climits>
#include <ctime>
#include <cmath>

using std::cin;
using std::cout;
using std::cerr;
using std::endl;
using std::istream;
using std::ostream;
using std::ifstream;
using std::ofstream;
using std::fstream;
using std::istringstream;
using std::ostringstream;
using std::stringstream;
using std::vector;
using std::list;
using std::set;
using std::multiset;
using std::map;
using std::multimap;
using std::pair;
using std::string;
using std::getline;
using std::to_string;
using std::domain_error;
using std::runtime_error;
using std::exception;
using std::transform;
using std::back_inserter;
using std::ostream_iterator;
using std::search;
using std::sort;
using std::copy;
using std::accumulate;
using std::find;
using std::find_if;
using std::max;
using std::min;
using std::swap;
using std::stable_partition;
using std::streamsize;
using std::streampos;
using std::setprecision;
using std::setw;
using std::chrono::steady_clock;
using std::allocator;
using std::uninitialized_fill;
using std::uninitialized_copy;
using std::distance;
using std::unique;
using std::mt19937;
using std::uniform_int_distribution;
using std::ios_base;
using std::ios;
using std::showbase;
using std::hex;
using std::oct;
using std::dec;
using std::fixed;
using std::scientific;
using std::left;
using std::right;
using std::flush;
using std::numeric_limits;
using std::common_type;
using std::reverse;

inline void error(const string &errormessage)
{
    cerr << errormessage << endl;
    throw runtime_error(errormessage);
}

int nrand_one(int n, mt19937 &e)
{
    if (n <= 0)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(0, n - 1);
    return d(e);
}

int nrand_two(int m, int n, mt19937 &e)
{
    if (n <= m)
    {
        throw domain_error("Argument to nrand is out of range");
    }
    uniform_int_distribution<int> d(m, n - 1);
    return d(e);
}

inline std::ios_base &general(std::ios_base &b)
{
    b.setf(std::ios_base::fmtflags(0), std::ios_base::floatfield);
    return b;
}

template<typename T>
ostream &print_vector(const vector<T> &v, ostream &os)
{
    if (v.size() > 0)
    {
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << endl;
    }

    return os;
}

template<typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
    if (v.size() > 0)
    {
        os << "{ ";
        os << v[0];

        for (typename vector<T>::size_type i = 1; i < v.size(); i++)
        {
            os << ", " << v[i];
        }

        os << " }";
    }

    return os;
}

template<typename T>
istream &operator>>(istream &is, vector<T> &d)
{
    char ch1;
    char ch2;
    T temp;
    vector<T> v_temp;
    is >> ch1;
    if (!is)
    {
        return is;
    }
    if (ch1 != '{')
    {
        is.clear(ios_base::failbit);
        return is;
    }
    while (is >> temp && is >> ch2)
    {
        if (ch2 == ',')
        {
            v_temp.push_back(temp);
        }
        else if (ch2 == '}')
        {
            v_temp.push_back(temp);
            d = v_temp;
            return is;
        }
        else
        {
            is.clear(ios_base::failbit);
            return is;
        }
    }

    return is;
}

class Move
{
private:
    mutable double x;
    mutable double y;
public:
    Move() {};
    ~Move() {};
    Move(double a = 0, double b = 0);
    void show_move() const;

    Move add(const Move &m) const;
    void reset(double a = 0, double b = 0);
};

Move::Move(double a, double b)
{
    x = a;
    y = b;
}
void Move::show_move() const
{
    std::cout << "X = " << x << std::endl;
    std::cout << "Y = " << y << std::endl;
}

Move Move::add(const Move &m) const
{
    x += m.x;
    y += m.y;
    return *this;
}

void Move::reset(double a, double b)
{
    x = a;
    y = b;
}

int main(int argc, const char *argv[])
{
    try
    {
        Move test_1(5, 10);
        test_1.show_move();

        test_1.add(test_1);
        test_1.show_move();

        test_1.reset();
        test_1.show_move();

        test_1.reset(10.0, 20.0);
        test_1.show_move();

        Move test_2(25.0, 25.0);
        test_2.show_move();

        test_2.add(test_1);
        test_2.show_move();

        return 0;
    }
    catch (exception &e)
    {
        cerr << "error: " << e.what() << '\n';
        return 1;
    }
    catch (...)
    {
        cerr << "Oops: unknown exception!\n";
        return 2;
    }
}
显示结果如下
X = 5
Y = 10
X = 10
Y = 20
X = 0
Y = 0
X = 10
Y = 20
X = 25
Y = 25
X = 35
Y = 45
